568
#method_before
@Override
public Guid getVmId() {
    if (getParameters().isImportAsNewEntity()) {
        return getParameters().getVm().getId();
    } else {
        return super.getVmId();
    }
}
#method_after
@Override
public Guid getVmId() {
    if (getParameters().isImportAsNewEntity()) {
        return getParameters().getVm().getId();
    }
    return super.getVmId();
}
#end_block

#method_before
@Override
public VM getVm() {
    if (getParameters().isImportAsNewEntity()) {
        return getParameters().getVm();
    } else {
        return super.getVm();
    }
}
#method_after
@Override
public VM getVm() {
    if (getParameters().isImportAsNewEntity()) {
        return getParameters().getVm();
    }
    return super.getVm();
}
#end_block

#method_before
private void initImportClonedVm() {
    Guid guid = Guid.NewGuid();
    getVm().setId(guid);
    setVmId(guid);
    getVm().setvm_name(getParameters().getVm().getvm_name());
    getVm().setstorage_pool_id(getParameters().getStoragePoolId());
    getParameters().setVm(getVm());
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        iface.setId(Guid.NewGuid());
    }
}
#method_after
private void initImportClonedVm() {
    Guid guid = Guid.NewGuid();
    getVm().setId(guid);
    setVmId(guid);
    getVm().setVmName(getParameters().getVm().getVmName());
    getVm().setStoragePoolId(getParameters().getStoragePoolId());
    getParameters().setVm(getVm());
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        iface.setId(Guid.NewGuid());
    }
}
#end_block

#method_before
private boolean canDoAction_beforeCloneVm(boolean retVal, List<String> canDoActionMessages, Map<Guid, storage_domains> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    retVal = checkStoragePool();
    if (retVal) {
        Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
        for (Guid destGuid : destGuids) {
            storage_domains storageDomain = getStorageDomain(destGuid);
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validator.isDomainExistAndActive(canDoActionMessages) || !validator.domainIsValidDestination(canDoActionMessages)) {
                retVal = false;
                break;
            } else {
                domainsMap.put(destGuid, storageDomain);
            }
        }
    }
    if (retVal && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
        retVal = false;
    }
    if (retVal) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        retVal = validator.isDomainExistAndActive(canDoActionMessages);
        if (retVal && getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        // Load images from Import/Export domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            List<VM> vms = (List<VM>) qretVal.getReturnValue();
            VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

                @Override
                public boolean eval(VM vm) {
                    return vm.getId().equals(getParameters().getVm().getId());
                }
            });
            if (vm != null) {
                // At this point we should work with the VM that was read from
                // the OVF
                setVm(vm);
                // Iterate over all the VM images (active image and snapshots)
                for (DiskImage image : getVm().getImages()) {
                    if (getParameters().getCopyCollapse()) {
                        // a match with the image from the VM.
                        for (DiskImage p : imageList) {
                            // only if requested by the user
                            if (p.getImageId().equals(image.getImageId())) {
                                if (p.getvolume_format() != null) {
                                    image.setvolume_format(p.getvolume_format());
                                }
                                if (p.getvolume_type() != null) {
                                    image.setvolume_type(p.getvolume_type());
                                }
                                // Validate the configuration of the image got from the parameters.
                                retVal = validateImageConfig(canDoActionMessages, domainsMap, image);
                                break;
                            }
                        }
                    } else {
                        // If no copy collapse sent, validate each image configuration (snapshot or active image).
                        retVal = validateImageConfig(canDoActionMessages, domainsMap, image);
                    }
                    if (!retVal) {
                        break;
                    } else {
                        image.setstorage_pool_id(getParameters().getStoragePoolId());
                        // we put the source domain id in order that copy will
                        // work
                        // ok
                        // we fix it to DestDomainId in
                        // MoveOrCopyAllImageGroups();
                        image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
                    }
                }
                if (retVal) {
                    Map<Guid, List<DiskImage>> images = getImagesLeaf(getVm().getImages());
                    for (Guid id : images.keySet()) {
                        List<DiskImage> list = images.get(id);
                        getVm().getDiskMap().put(id, list.get(list.size() - 1));
                    }
                }
            } else {
                retVal = false;
            }
        }
    }
    return retVal;
}
#method_after
private boolean canDoAction_beforeCloneVm(boolean retVal, List<String> canDoActionMessages, Map<Guid, storage_domains> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    retVal = checkStoragePool();
    if (retVal) {
        Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
        for (Guid destGuid : destGuids) {
            storage_domains storageDomain = getStorageDomain(destGuid);
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validator.isDomainExistAndActive(canDoActionMessages) || !validator.domainIsValidDestination(canDoActionMessages)) {
                retVal = false;
                break;
            }
            domainsMap.put(destGuid, storageDomain);
        }
    }
    if (retVal && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
        retVal = false;
    }
    if (retVal) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        retVal = validator.isDomainExistAndActive(canDoActionMessages);
        if (retVal && getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        // Load images from Import/Export domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            List<VM> vms = (List<VM>) qretVal.getReturnValue();
            VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

                @Override
                public boolean eval(VM vm) {
                    return vm.getId().equals(getParameters().getVm().getId());
                }
            });
            if (vm != null) {
                // At this point we should work with the VM that was read from
                // the OVF
                setVm(vm);
                // Iterate over all the VM images (active image and snapshots)
                for (DiskImage image : getVm().getImages()) {
                    if (getParameters().getCopyCollapse()) {
                        // a match with the image from the VM.
                        for (DiskImage p : imageList) {
                            // only if requested by the user
                            if (p.getImageId().equals(image.getImageId())) {
                                if (p.getvolume_format() != null) {
                                    image.setvolume_format(p.getvolume_format());
                                }
                                if (p.getvolume_type() != null) {
                                    image.setvolume_type(p.getvolume_type());
                                }
                                // Validate the configuration of the image got from the parameters.
                                retVal = validateImageConfig(canDoActionMessages, domainsMap, image);
                                break;
                            }
                        }
                    } else {
                        // If no copy collapse sent, validate each image configuration (snapshot or active image).
                        retVal = validateImageConfig(canDoActionMessages, domainsMap, image);
                    }
                    if (!retVal) {
                        break;
                    }
                    image.setstorage_pool_id(getParameters().getStoragePoolId());
                    // we put the source domain id in order that copy will
                    // work properly.
                    // we fix it to DestDomainId in
                    // MoveOrCopyAllImageGroups();
                    image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
                }
                if (retVal) {
                    Map<Guid, List<DiskImage>> images = getImagesLeaf(getVm().getImages());
                    for (Guid id : images.keySet()) {
                        List<DiskImage> list = images.get(id);
                        getVm().getDiskMap().put(id, list.get(list.size() - 1));
                    }
                }
            } else {
                retVal = false;
            }
        }
    }
    return retVal;
}
#end_block

#method_before
private boolean canDoAction_afterCloneVm(boolean retVal, List<String> canDoActionMessages, Map<Guid, storage_domains> domainsMap) {
    VM vm = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (retVal) {
        VmStatic duplicateVm = getVmStaticDAO().get(getVm().getId());
        if (duplicateVm != null) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            addCanDoActionMessage(String.format("$VmName %1$s", duplicateVm.getvm_name()));
            retVal = false;
        }
    }
    setVmTemplateId(getVm().getvmt_guid());
    if (retVal) {
        if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
            retVal = false;
        }
    }
    if (retVal && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && getVmTemplate() != null && getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
        retVal = false;
    }
    if (retVal && getParameters().getCopyCollapse() && vm.getDiskMap() != null) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    retVal = ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, canDoActionMessages);
                    if (!retVal) {
                        break;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (retVal && getParameters().getCopyCollapse() && !templateExistsOnExportDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING);
        addCanDoActionMessage(String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getstorage_name()));
        retVal = false;
    }
    if (retVal) {
        boolean inCluster = false;
        List<VDSGroup> groups = getVdsGroupDAO().getAllForStoragePool(getParameters().getStoragePoolId());
        for (VDSGroup group : groups) {
            if (group.getId().equals(getParameters().getVdsGroupId())) {
                inCluster = true;
                break;
            }
        }
        if (!inCluster) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            retVal = false;
        }
    }
    if (retVal) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    // Check that the USB policy is legal
    if (retVal) {
        VmHandler.updateImportedVmUsbPolicy(vm.getStaticData());
        retVal = VmHandler.isUsbPolicyLegal(vm.getusb_policy(), vm.getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    }
    if (retVal) {
        retVal = validateMacAddress(getVm().getInterfaces());
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#method_after
private boolean canDoAction_afterCloneVm(boolean retVal, List<String> canDoActionMessages, Map<Guid, storage_domains> domainsMap) {
    VM vm = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (retVal) {
        VmStatic duplicateVm = getVmStaticDAO().get(getVm().getId());
        if (duplicateVm != null) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            addCanDoActionMessage(String.format("$VmName %1$s", duplicateVm.getvm_name()));
            retVal = false;
        }
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (retVal) {
        if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
            retVal = false;
        }
    }
    if (retVal && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
        retVal = false;
    }
    if (retVal && getParameters().getCopyCollapse() && vm.getDiskMap() != null) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    retVal = ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, canDoActionMessages);
                    if (!retVal) {
                        break;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (retVal && getParameters().getCopyCollapse() && !templateExistsOnExportDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING);
        addCanDoActionMessage(String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getstorage_name()));
        retVal = false;
    }
    if (retVal) {
        boolean inCluster = false;
        List<VDSGroup> groups = getVdsGroupDAO().getAllForStoragePool(getParameters().getStoragePoolId());
        for (VDSGroup group : groups) {
            if (group.getId().equals(getParameters().getVdsGroupId())) {
                inCluster = true;
                break;
            }
        }
        if (!inCluster) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            retVal = false;
        }
    }
    if (retVal) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    // Check that the USB policy is legal
    if (retVal) {
        VmHandler.updateImportedVmUsbPolicy(vm.getStaticData());
        retVal = VmHandler.isUsbPolicyLegal(vm.getUsbPolicy(), vm.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    }
    if (retVal) {
        retVal = validateMacAddress(getVm().getInterfaces());
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#end_block

#method_before
private boolean templateExistsOnExportDomain() {
    boolean retVal = false;
    if (!VmTemplateHandler.BlankVmTemplateId.equals(getParameters().getVm().getvmt_guid())) {
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        if (qretVal.getSucceeded()) {
            Map templates = (Map) qretVal.getReturnValue();
            for (Object template : templates.keySet()) {
                if (getParameters().getVm().getvmt_guid().equals(((VmTemplate) template).getId())) {
                    retVal = true;
                    break;
                }
            }
        }
    } else {
        retVal = true;
    }
    return retVal;
}
#method_after
private boolean templateExistsOnExportDomain() {
    boolean retVal = false;
    if (!VmTemplateHandler.BlankVmTemplateId.equals(getParameters().getVm().getVmtGuid())) {
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        if (qretVal.getSucceeded()) {
            Map templates = (Map) qretVal.getReturnValue();
            for (Object template : templates.keySet()) {
                if (getParameters().getVm().getVmtGuid().equals(((VmTemplate) template).getId())) {
                    retVal = true;
                    break;
                }
            }
        }
    } else {
        retVal = true;
    }
    return retVal;
}
#end_block

#method_before
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = getParameters().isImportAsNewEntity() || checkIfDisksExist(imageList);
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && !getParameters().getCopyCollapse()) {
        List<storage_domains> domains = (List<storage_domains>) Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new GetStorageDomainsByVmTemplateIdQueryParameters(getVm().getvmt_guid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<storage_domains, Guid>() {

            @Override
            public Guid eval(storage_domains storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = getParameters().isImportAsNewEntity() || checkIfDisksExist(imageList);
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<storage_domains> domains = (List<storage_domains>) Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new GetStorageDomainsByVmTemplateIdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<storage_domains, Guid>() {

            @Override
            public Guid eval(storage_domains storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
private boolean canAddVm() {
    // Checking if a desktop with same name already exists
    boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(getVm().getvm_name())).getReturnValue();
    if (exists) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_NAME_EXISTS);
    }
    return !exists;
}
#method_after
private boolean canAddVm() {
    // Checking if a desktop with same name already exists
    boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(getVm().getVmName())).getReturnValue();
    if (exists) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_NAME_EXISTS);
    }
    return !exists;
}
#end_block

#method_before
protected void addVmStatic() {
    logImportEvents();
    getVm().getStaticData().setId(getVmId());
    getVm().getStaticData().setcreation_date(new Date());
    getVm().getStaticData().setvds_group_id(getParameters().getVdsGroupId());
    getVm().getStaticData().setMinAllocatedMem(computeMinAllocatedMem());
    getVm().getStaticData().setQuotaId(getParameters().getQuotaId());
    if (getParameters().getCopyCollapse()) {
        getVm().setvmt_guid(VmTemplateHandler.BlankVmTemplateId);
    }
    DbFacade.getInstance().getVmStaticDao().save(getVm().getStaticData());
    getCompensationContext().snapshotNewEntity(getVm().getStaticData());
}
#method_after
protected void addVmStatic() {
    logImportEvents();
    getVm().getStaticData().setId(getVmId());
    getVm().getStaticData().setcreation_date(new Date());
    getVm().getStaticData().setvds_group_id(getParameters().getVdsGroupId());
    getVm().getStaticData().setMinAllocatedMem(computeMinAllocatedMem());
    getVm().getStaticData().setQuotaId(getParameters().getQuotaId());
    if (getParameters().getCopyCollapse()) {
        getVm().setVmtGuid(VmTemplateHandler.BlankVmTemplateId);
    }
    DbFacade.getInstance().getVmStaticDao().save(getVm().getStaticData());
    getCompensationContext().snapshotNewEntity(getVm().getStaticData());
}
#end_block

#method_before
private int computeMinAllocatedMem() {
    int vmMem = getVm().getmem_size_mb();
    int minAllocatedMem = vmMem;
    if (getVm().getMinAllocatedMem() > 0) {
        minAllocatedMem = getVm().getMinAllocatedMem();
    } else {
        // first get cluster memory over commit value
        VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(getVm().getvds_group_id());
        if (vdsGroup != null && vdsGroup.getmax_vds_memory_over_commit() > 0) {
            minAllocatedMem = (vmMem * 100) / vdsGroup.getmax_vds_memory_over_commit();
        }
    }
    return minAllocatedMem;
}
#method_after
private int computeMinAllocatedMem() {
    int vmMem = getVm().getMemSizeMb();
    int minAllocatedMem = vmMem;
    if (getVm().getMinAllocatedMem() > 0) {
        minAllocatedMem = getVm().getMinAllocatedMem();
    } else {
        // first get cluster memory over commit value
        VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(getVm().getVdsGroupId());
        if (vdsGroup != null && vdsGroup.getmax_vds_memory_over_commit() > 0) {
            minAllocatedMem = (vmMem * 100) / vdsGroup.getmax_vds_memory_over_commit();
        }
    }
    return minAllocatedMem;
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    List<String> invalidNetworkNames = new ArrayList<String>();
    List<String> invalidIfaceNames = new ArrayList<String>();
    Map<String, Network> networksInVdsByName = Entities.entitiesByName(getNetworkDAO().getAllForCluster(getVm().getvds_group_id()));
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        if (!vmInterfaceManager.isValidVmNetwork(iface, networksInVdsByName)) {
            invalidNetworkNames.add(iface.getNetworkName());
            invalidIfaceNames.add(iface.getName());
            iface.setNetworkName(StringUtils.EMPTY);
        }
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity());
        macsAdded.add(iface.getMacAddress());
    }
    auditInvalidInterfaces(invalidNetworkNames, invalidIfaceNames);
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    List<String> invalidNetworkNames = new ArrayList<String>();
    List<String> invalidIfaceNames = new ArrayList<String>();
    Map<String, Network> networksInVdsByName = Entities.entitiesByName(getNetworkDAO().getAllForCluster(getVm().getVdsGroupId()));
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        if (!vmInterfaceManager.isValidVmNetwork(iface, networksInVdsByName)) {
            invalidNetworkNames.add(iface.getNetworkName());
            invalidIfaceNames.add(iface.getName());
            iface.setNetworkName(StringUtils.EMPTY);
        }
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity());
        macsAdded.add(iface.getMacAddress());
    }
    auditInvalidInterfaces(invalidNetworkNames, invalidIfaceNames);
}
#end_block

#method_before
private void initInterface(VmNetworkInterface iface) {
    if (iface.getId() == null) {
        iface.setId(Guid.NewGuid());
    }
    fillMacAddressIfMissing(iface);
    iface.setVmTemplateId(null);
    iface.setVmId(getVmId());
    iface.setVmName(getVm().getvm_name());
}
#method_after
private void initInterface(VmNetworkInterface iface) {
    if (iface.getId() == null) {
        iface.setId(Guid.NewGuid());
    }
    fillMacAddressIfMissing(iface);
    iface.setVmTemplateId(null);
    iface.setVmId(getVmId());
    iface.setVmName(getVm().getVmName());
}
#end_block

#method_before
protected boolean updateVmInSpm() {
    return VmCommand.updateVmInSpm(getVm().getstorage_pool_id(), new ArrayList<VM>(Arrays.asList(new VM[] { getVm() })));
}
#method_after
protected boolean updateVmInSpm() {
    return VmCommand.updateVmInSpm(getVm().getStoragePoolId(), new ArrayList<VM>(Arrays.asList(new VM[] { getVm() })));
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    // special permission is needed to use custom properties
    if (getVm() != null && !StringUtils.isEmpty(getVm().getCustomProperties())) {
        permissionList.add(new PermissionSubject(getVm().getvds_group_id(), VdcObjectType.VdsGroups, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    // special permission is needed to use custom properties
    if (getVm() != null && !StringUtils.isEmpty(getVm().getCustomProperties())) {
        permissionList.add(new PermissionSubject(getVm().getVdsGroupId(), VdcObjectType.VdsGroups, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
    }
    return permissionList;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Set parameters for messeging.
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM__CLUSTER);
    VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    } else {
        if (ObjectIdentityChecker.CanUpdateField(vm, "vds_group_id", vm.getstatus())) {
            targetCluster = DbFacade.getInstance().getVdsGroupDao().get(getParameters().getClusterId());
            if (targetCluster == null) {
                addCanDoActionMessage(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
                return false;
            }
            // Check that the target cluster is in the same data center.
            if (!targetCluster.getstorage_pool_id().equals(vm.getstorage_pool_id())) {
                addCanDoActionMessage(VdcBllMessages.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
                return false;
            }
            List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmId());
            // Check the destination cluster have all the networks that the VM use
            List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(getParameters().getClusterId());
            StringBuilder missingNets = new StringBuilder();
            for (VmNetworkInterface iface : interfaces) {
                String netName = iface.getNetworkName();
                if (isNotEmpty(netName)) {
                    boolean exists = false;
                    for (Network net : networks) {
                        if (net.getname().equals(netName)) {
                            exists = true;
                            break;
                        }
                    }
                    if (!exists) {
                        if (missingNets.length() > 0) {
                            missingNets.append(", ");
                        }
                        missingNets.append(netName);
                    }
                }
            }
            if (missingNets.length() > 0) {
                addCanDoActionMessage(VdcBllMessages.MOVE_VM_CLUSTER_MISSING_NETWORK);
                addCanDoActionMessage(String.format("$networks %1$s", missingNets.toString()));
                return false;
            }
            // Check if VM static parameters are compatible for new cluster.
            boolean isCpuSocketsValid = AddVmCommand.CheckCpuSockets(vm.getStaticData().getnum_of_sockets(), vm.getStaticData().getcpu_per_socket(), targetCluster.getcompatibility_version().getValue(), getReturnValue().getCanDoActionMessages());
            if (!isCpuSocketsValid) {
                return false;
            }
            // Check that the USB policy is legal
            if (!VmHandler.isUsbPolicyLegal(vm.getusb_policy(), vm.getos(), targetCluster, getReturnValue().getCanDoActionMessages())) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.VM_STATUS_NOT_VALID_FOR_UPDATE);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Set parameters for messeging.
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM__CLUSTER);
    VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    } else {
        if (ObjectIdentityChecker.CanUpdateField(vm, "vds_group_id", vm.getStatus())) {
            targetCluster = DbFacade.getInstance().getVdsGroupDao().get(getParameters().getClusterId());
            if (targetCluster == null) {
                addCanDoActionMessage(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
                return false;
            }
            // Check that the target cluster is in the same data center.
            if (!targetCluster.getStoragePoolId().equals(vm.getStoragePoolId())) {
                addCanDoActionMessage(VdcBllMessages.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
                return false;
            }
            List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmId());
            // Check the destination cluster have all the networks that the VM use
            List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(getParameters().getClusterId());
            StringBuilder missingNets = new StringBuilder();
            for (VmNetworkInterface iface : interfaces) {
                String netName = iface.getNetworkName();
                if (isNotEmpty(netName)) {
                    boolean exists = false;
                    for (Network net : networks) {
                        if (net.getname().equals(netName)) {
                            exists = true;
                            break;
                        }
                    }
                    if (!exists) {
                        if (missingNets.length() > 0) {
                            missingNets.append(", ");
                        }
                        missingNets.append(netName);
                    }
                }
            }
            if (missingNets.length() > 0) {
                addCanDoActionMessage(VdcBllMessages.MOVE_VM_CLUSTER_MISSING_NETWORK);
                addCanDoActionMessage(String.format("$networks %1$s", missingNets.toString()));
                return false;
            }
            // Check if VM static parameters are compatible for new cluster.
            boolean isCpuSocketsValid = AddVmCommand.CheckCpuSockets(vm.getStaticData().getnum_of_sockets(), vm.getStaticData().getcpu_per_socket(), targetCluster.getcompatibility_version().getValue(), getReturnValue().getCanDoActionMessages());
            if (!isCpuSocketsValid) {
                return false;
            }
            // Check that the USB policy is legal
            if (!VmHandler.isUsbPolicyLegal(vm.getUsbPolicy(), vm.getOs(), targetCluster, getReturnValue().getCanDoActionMessages())) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.VM_STATUS_NOT_VALID_FOR_UPDATE);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // check that the cluster are not the same
    VM vm = getVm();
    if (vm.getvds_group_id().equals(getParameters().getClusterId())) {
        setSucceeded(true);
        return;
    }
    // update vm interfaces
    List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(getParameters().getClusterId());
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmId());
    for (final VmNetworkInterface iface : interfaces) {
        Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network n) {
                return iface.getNetworkName().equals(n.getname());
            }
        });
        // interface connection
        if (net == null) {
            iface.setNetworkName(null);
            DbFacade.getInstance().getVmNetworkInterfaceDao().update(iface);
        }
    }
    if (vm.getdedicated_vm_for_vds() != null) {
        vm.setdedicated_vm_for_vds(null);
        dedicatedHostWasCleared = true;
    }
    vm.setvds_group_id(getParameters().getClusterId());
    DbFacade.getInstance().getVmStaticDao().update(vm.getStaticData());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // check that the cluster are not the same
    VM vm = getVm();
    if (vm.getVdsGroupId().equals(getParameters().getClusterId())) {
        setSucceeded(true);
        return;
    }
    // update vm interfaces
    List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(getParameters().getClusterId());
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmId());
    for (final VmNetworkInterface iface : interfaces) {
        Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network n) {
                return iface.getNetworkName().equals(n.getname());
            }
        });
        // interface connection
        if (net == null) {
            iface.setNetworkName(null);
            DbFacade.getInstance().getVmNetworkInterfaceDao().update(iface);
        }
    }
    if (vm.getDedicatedVmForVds() != null) {
        vm.setDedicatedVmForVds(null);
        dedicatedHostWasCleared = true;
    }
    vm.setVdsGroupId(getParameters().getClusterId());
    DbFacade.getInstance().getVmStaticDao().update(vm.getStaticData());
    setSucceeded(true);
}
#end_block

#method_before
protected ImportVmParameters createParameters() {
    final VM v = createVM();
    v.setvm_name("testVm");
    final ImportVmParameters p = new ImportVmParameters(v, Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid());
    return p;
}
#method_after
protected ImportVmParameters createParameters() {
    final VM v = createVM();
    v.setVmName("testVm");
    final ImportVmParameters p = new ImportVmParameters(v, Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid());
    return p;
}
#end_block

#method_before
private void checkVmName(boolean isImportAsNewEntity, String name) {
    ImportVmParameters parameters = createParameters();
    parameters.getVm().setvm_name(name);
    parameters.setImportAsNewEntity(isImportAsNewEntity);
    ImportVmCommand command = spy(new ImportVmCommand(parameters));
    Set<ConstraintViolation<ImportVmParameters>> validate = ValidationUtils.getValidator().validate(parameters, command.getValidationGroups().toArray(new Class<?>[0]));
    Assert.isTrue(validate.isEmpty() == !isImportAsNewEntity);
}
#method_after
private void checkVmName(boolean isImportAsNewEntity, String name) {
    ImportVmParameters parameters = createParameters();
    parameters.getVm().setVmName(name);
    parameters.setImportAsNewEntity(isImportAsNewEntity);
    ImportVmCommand command = spy(new ImportVmCommand(parameters));
    Set<ConstraintViolation<ImportVmParameters>> validate = ValidationUtils.getValidator().validate(parameters, command.getValidationGroups().toArray(new Class<?>[0]));
    Assert.isTrue(validate.isEmpty() == !isImportAsNewEntity);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getInterface() != null && getVm() != null && getParameters().getInterface().isPortMirroring()) {
        permissionList.add(new PermissionSubject(getVm().getstorage_pool_id(), VdcObjectType.StoragePool, ActionGroup.PORT_MIRRORING));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getInterface() != null && getVm() != null && getParameters().getInterface().isPortMirroring()) {
        permissionList.add(new PermissionSubject(getVm().getStoragePoolId(), VdcObjectType.StoragePool, ActionGroup.PORT_MIRRORING));
    }
    return permissionList;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getInterface() != null && getVm() != null && getParameters().getInterface().isPortMirroring()) {
        permissionList.add(new PermissionSubject(getVm().getstorage_pool_id(), VdcObjectType.StoragePool, ActionGroup.PORT_MIRRORING));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getInterface() != null && getVm() != null && getParameters().getInterface().isPortMirroring()) {
        permissionList.add(new PermissionSubject(getVm().getStoragePoolId(), VdcObjectType.StoragePool, ActionGroup.PORT_MIRRORING));
    }
    return permissionList;
}
#end_block

#method_before
@Override
public NGuid getStoragePoolId() {
    if (super.getStoragePoolId() == null) {
        VM vm = getVm();
        if (vm != null) {
            setStoragePoolId(vm.getstorage_pool_id());
        }
    }
    return super.getStoragePoolId();
}
#method_after
@Override
public NGuid getStoragePoolId() {
    if (super.getStoragePoolId() == null) {
        VM vm = getVm();
        if (vm != null) {
            setStoragePoolId(vm.getStoragePoolId());
        }
    }
    return super.getStoragePoolId();
}
#end_block

#method_before
public static boolean updateVmInSpm(Guid storagePoolId, List<VM> vmsList, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>(vmsList.size());
    OvfManager ovfManager = new OvfManager();
    for (VM vm : vmsList) {
        ArrayList<DiskImage> AllVmImages = new ArrayList<DiskImage>();
        VmHandler.updateDisksFromDb(vm);
        if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
            vm.setInterfaces(DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
        }
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.isAllowSnapshot()) {
                DiskImage diskImage = (DiskImage) disk;
                AllVmImages.addAll(ImagesHandler.getAllImageSnapshots(diskImage.getImageId(), diskImage.getit_guid()));
            }
        }
        if (StringUtils.isEmpty(vm.getvmt_name())) {
            VmTemplate t = DbFacade.getInstance().getVmTemplateDao().get(vm.getvmt_guid());
            vm.setvmt_name(t.getname());
        }
        String vmMeta = ovfManager.ExportVm(vm, AllVmImages);
        vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<String, List<Guid>>(vmMeta, LinqUtils.foreach(vm.getDiskMap().values(), new Function<Disk, Guid>() {

            @Override
            public Guid eval(Disk a) {
                return a.getId();
            }
        })));
    }
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#method_after
public static boolean updateVmInSpm(Guid storagePoolId, List<VM> vmsList, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>(vmsList.size());
    OvfManager ovfManager = new OvfManager();
    for (VM vm : vmsList) {
        ArrayList<DiskImage> AllVmImages = new ArrayList<DiskImage>();
        VmHandler.updateDisksFromDb(vm);
        if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
            vm.setInterfaces(DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
        }
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.isAllowSnapshot()) {
                DiskImage diskImage = (DiskImage) disk;
                AllVmImages.addAll(ImagesHandler.getAllImageSnapshots(diskImage.getImageId(), diskImage.getit_guid()));
            }
        }
        if (StringUtils.isEmpty(vm.getVmtName())) {
            VmTemplate t = DbFacade.getInstance().getVmTemplateDao().get(vm.getVmtGuid());
            vm.setVmtName(t.getname());
        }
        String vmMeta = ovfManager.ExportVm(vm, AllVmImages);
        vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<String, List<Guid>>(vmMeta, LinqUtils.foreach(vm.getDiskMap().values(), new Function<Disk, Guid>() {

            @Override
            public Guid eval(Disk a) {
                return a.getId();
            }
        })));
    }
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#end_block

#method_before
protected void endActionOnVmConfiguration() {
    if (getVm() != null) {
        if (getVm().getstatus() == VMStatus.ImageLocked) {
            VmHandler.unlockVm(getVm(), getCompensationContext());
        }
        updateVmInSpm(getVm().getstorage_pool_id(), Arrays.asList(getVm()));
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VmCommand::EndVmCommand: Vm is null - not performing EndAction on Vm");
    }
}
#method_after
protected void endActionOnVmConfiguration() {
    if (getVm() != null) {
        if (getVm().getStatus() == VMStatus.ImageLocked) {
            VmHandler.unlockVm(getVm(), getCompensationContext());
        }
        updateVmInSpm(getVm().getStoragePoolId(), Arrays.asList(getVm()));
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VmCommand::EndVmCommand: Vm is null - not performing EndAction on Vm");
    }
}
#end_block

#method_before
protected boolean handleHibernatedVm(VdcActionType parentCommand, boolean startPollingTasks) {
    // this is temp code until it will be implemented in SPM
    String[] strings = getVm().gethibernation_vol_handle().split(",");
    List<Guid> guids = new LinkedList<Guid>();
    for (String string : strings) {
        guids.add(new Guid(string));
    }
    Guid[] imagesList = guids.toArray(new Guid[0]);
    if (imagesList.length == 6) {
        // get all vm disks in order to check post zero - if one of the
        // disks is marked with wipe_after_delete
        boolean postZero = LinqUtils.filter(getDiskDao().getAllForVm(getVm().getId()), new Predicate<Disk>() {

            @Override
            public boolean eval(Disk disk) {
                return disk.isWipeAfterDelete();
            }
        }).size() > 0;
        // delete first image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue1 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[2], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue1.getSucceeded()) {
            return false;
        }
        Guid guid1 = createTask(vdsRetValue1.getCreationInfo(), parentCommand, VdcObjectType.Storage, imagesList[0]);
        getTaskIdList().add(guid1);
        // delete second image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue2 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[4], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue2.getSucceeded()) {
            if (startPollingTasks) {
                updateTasksWithActionParameters();
                AsyncTaskManager.getInstance().StartPollingTask(guid1);
            }
            return false;
        }
        Guid guid2 = createTask(vdsRetValue2.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid2);
        if (startPollingTasks) {
            updateTasksWithActionParameters();
            AsyncTaskManager.getInstance().StartPollingTask(guid1);
            AsyncTaskManager.getInstance().StartPollingTask(guid2);
        }
    }
    return true;
}
#method_after
protected boolean handleHibernatedVm(VdcActionType parentCommand, boolean startPollingTasks) {
    // this is temp code until it will be implemented in SPM
    String[] strings = getVm().getHibernationVolHandle().split(",");
    List<Guid> guids = new LinkedList<Guid>();
    for (String string : strings) {
        guids.add(new Guid(string));
    }
    Guid[] imagesList = guids.toArray(new Guid[0]);
    if (imagesList.length == 6) {
        // get all vm disks in order to check post zero - if one of the
        // disks is marked with wipe_after_delete
        boolean postZero = LinqUtils.filter(getDiskDao().getAllForVm(getVm().getId()), new Predicate<Disk>() {

            @Override
            public boolean eval(Disk disk) {
                return disk.isWipeAfterDelete();
            }
        }).size() > 0;
        // delete first image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue1 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[2], postZero, false, getVm().getVdsGroupCompatibilityVersion().toString()));
        if (!vdsRetValue1.getSucceeded()) {
            return false;
        }
        Guid guid1 = createTask(vdsRetValue1.getCreationInfo(), parentCommand, VdcObjectType.Storage, imagesList[0]);
        getTaskIdList().add(guid1);
        // delete second image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue2 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[4], postZero, false, getVm().getVdsGroupCompatibilityVersion().toString()));
        if (!vdsRetValue2.getSucceeded()) {
            if (startPollingTasks) {
                updateTasksWithActionParameters();
                AsyncTaskManager.getInstance().StartPollingTask(guid1);
            }
            return false;
        }
        Guid guid2 = createTask(vdsRetValue2.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid2);
        if (startPollingTasks) {
            updateTasksWithActionParameters();
            AsyncTaskManager.getInstance().StartPollingTask(guid1);
            AsyncTaskManager.getInstance().StartPollingTask(guid2);
        }
    }
    return true;
}
#end_block

#method_before
protected boolean isVmNameValidLength(VM vm) {
    // get VM name
    String vmName = vm.getvm_name();
    // get the max VM name (configuration parameter)
    int maxVmNameLengthWindows = Config.<Integer>GetValue(ConfigValues.MaxVmNameLengthWindows);
    int maxVmNameLengthNonWindows = Config.<Integer>GetValue(ConfigValues.MaxVmNameLengthNonWindows);
    // names are allowed different lengths in Windows and non-Windows OSs,
    // consider this when setting the max length.
    int maxLength = vm.getvm_os().isWindows() ? maxVmNameLengthWindows : maxVmNameLengthNonWindows;
    // check if name is longer than allowed name
    boolean nameLengthValid = (vmName.length() <= maxLength);
    // return result
    return nameLengthValid;
}
#method_after
protected boolean isVmNameValidLength(VM vm) {
    // get VM name
    String vmName = vm.getVmName();
    // get the max VM name (configuration parameter)
    int maxVmNameLengthWindows = Config.<Integer>GetValue(ConfigValues.MaxVmNameLengthWindows);
    int maxVmNameLengthNonWindows = Config.<Integer>GetValue(ConfigValues.MaxVmNameLengthNonWindows);
    // names are allowed different lengths in Windows and non-Windows OSs,
    // consider this when setting the max length.
    int maxLength = vm.getVmOs().isWindows() ? maxVmNameLengthWindows : maxVmNameLengthNonWindows;
    // check if name is longer than allowed name
    boolean nameLengthValid = (vmName.length() <= maxLength);
    // return result
    return nameLengthValid;
}
#end_block

#method_before
protected boolean isOsSupportingHotPlug() {
    String vmOs = getVm().getos().name();
    String[] unsupportedOSs = Config.<String>GetValue(ConfigValues.HotPlugUnsupportedOsList).split(",");
    for (String os : unsupportedOSs) {
        if (os.equalsIgnoreCase(vmOs)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean isOsSupportingHotPlug() {
    String vmOs = getVm().getOs().name();
    String[] unsupportedOSs = Config.<String>GetValue(ConfigValues.HotPlugUnsupportedOsList).split(",");
    for (String os : unsupportedOSs) {
        if (os.equalsIgnoreCase(vmOs)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected void initStoragePoolId() {
    if (getVdsGroup() != null) {
        setStoragePoolId(getVdsGroup().getstorage_pool_id() != null ? getVdsGroup().getstorage_pool_id().getValue() : Guid.Empty);
    }
}
#method_after
protected void initStoragePoolId() {
    if (getVdsGroup() != null) {
        setStoragePoolId(getVdsGroup().getStoragePoolId() != null ? getVdsGroup().getStoragePoolId().getValue() : Guid.Empty);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    returnValue = buildAndCheckDestStorageDomains();
    if (returnValue) {
        storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
        returnValue = canDoAddVmCommand();
    }
    String vmName = getParameters().getVm().getvm_name();
    if (vmName == null || vmName.isEmpty()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        }
    }
    // check for Vm Payload
    if (returnValue && getParameters().getVmPayload() != null) {
        returnValue = checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getiso_path());
        if (returnValue) {
            // we save the content in base64 string
            getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getusb_policy(), getParameters().getVm().getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        returnValue = false;
    }
    // check cpuPinning
    if (returnValue && !isCpuPinningValid(getParameters().getVm().getCpuPinning())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    }
    return returnValue && checkCpuSockets();
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    returnValue = buildAndCheckDestStorageDomains();
    if (returnValue) {
        storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
        returnValue = canDoAddVmCommand();
    }
    String vmName = getParameters().getVm().getVmName();
    if (vmName == null || vmName.isEmpty()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        }
    }
    // check for Vm Payload
    if (returnValue && getParameters().getVmPayload() != null) {
        returnValue = checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getiso_path());
        if (returnValue) {
            // we save the content in base64 string
            getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        returnValue = false;
    }
    // check cpuPinning
    if (returnValue && !isCpuPinningValid(getParameters().getVm().getCpuPinning())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    }
    return returnValue && checkCpuSockets();
}
#end_block

#method_before
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getorigin() == null) {
        vmStatic.setorigin(OriginType.valueOf(Config.<String>GetValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setcreation_date(new Date());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getvds_group_id()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#method_after
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getorigin() == null) {
        vmStatic.setorigin(OriginType.valueOf(Config.<String>GetValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setcreation_date(new Date());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getVdsGroupId()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#end_block

#method_before
protected boolean addVmImages() {
    if (getVmTemplate().getDiskMap().size() > 0) {
        if (getVm().getstatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getstorage_ids().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getstorage_ids().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            getParameters().getImagesParameters().add(tempVar);
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalTaskIdList());
                newDiskImages.add((DiskImage) result.getActionReturnValue());
            }
        }
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (getVmTemplate().getDiskMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getstorage_ids().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getstorage_ids().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            getParameters().getImagesParameters().add(tempVar);
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalTaskIdList());
                newDiskImages.add((DiskImage) result.getActionReturnValue());
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    super.endActionOnDisks();
    if (getVm() != null) {
        removeVmInSpm(getVm().getstorage_pool_id(), getVmId());
    }
    removeVmRelatedEntitiesFromDb();
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    super.endActionOnDisks();
    if (getVm() != null) {
        removeVmInSpm(getVm().getStoragePoolId(), getVmId());
    }
    removeVmRelatedEntitiesFromDb();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected Map<String, String> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getvm_name())) {
        return Collections.singletonMap(getParameters().getVm().getvm_name(), LockingGroup.VM_NAME.name());
    }
    return null;
}
#method_after
@Override
protected Map<String, String> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getVmName())) {
        return Collections.singletonMap(getParameters().getVm().getVmName(), LockingGroup.VM_NAME.name());
    }
    return null;
}
#end_block

#method_before
private void glusterHostRemove() {
    if (isGlusterEnabled() && clusterHasMultipleHosts() && !hasVolumeOnServer()) {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostRemove, new GlusterHostRemoveVDSParameters(upServer.getId(), getVds().gethost_name(), getParameters().isForceAction()));
        setSucceeded(returnValue.getSucceeded());
        if (!getSucceeded()) {
            getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
            getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
            errorType = AuditLogType.GLUSTER_HOST_REMOVE_FAILED;
            return;
        }
    }
}
#method_after
private void glusterHostRemove() {
    if (isGlusterEnabled() && clusterHasMultipleHosts() && !hasVolumeOnServer()) {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.RemoveGlusterServer, new RemoveGlusterServerVDSParameters(upServer.getId(), getVds().gethost_name(), getParameters().isForceAction()));
        setSucceeded(returnValue.getSucceeded());
        if (!getSucceeded()) {
            getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
            getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
            errorType = AuditLogType.GLUSTER_SERVER_REMOVE_FAILED;
            return;
        }
    }
}
#end_block

#method_before
@Before
public void setUp() {
    MockitoAnnotations.initMocks(this);
    GlusterServerParameters parameters = createParameters();
    command = spy(new RemoveVdsCommand<GlusterServerParameters>(parameters));
    clusterUtils = mock(ClusterUtils.class);
    doReturn(vdsDAO).when(command).getVdsDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(storagePoolDAO).when(command).getStoragePoolDAO();
    doReturn(vdsDynamicDAO).when(command).getVdsDynamicDAO();
    doReturn(glusterBrickDao).when(command).getGlusterBrickDao();
    doReturn(vdsGroupDao).when(command).getVdsGroupDAO();
    doReturn(vdsGroup).when(vdsGroupDao).get(Mockito.any(Guid.class));
    doReturn(clusterUtils).when(command).getClusterUtils();
    when(clusterUtils.getUpServer(CLUSTER_ID)).thenReturn(getVds(VDSStatus.Up));
}
#method_after
@Before
public void setUp() {
    MockitoAnnotations.initMocks(this);
    command = spy(new RemoveVdsCommand<RemoveVdsParameters>(new RemoveVdsParameters(Guid.NewGuid(), false)));
    clusterUtils = mock(ClusterUtils.class);
    doReturn(vdsDAO).when(command).getVdsDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(storagePoolDAO).when(command).getStoragePoolDAO();
    doReturn(vdsDynamicDAO).when(command).getVdsDynamicDAO();
    doReturn(glusterBrickDao).when(command).getGlusterBrickDao();
    doReturn(vdsGroupDao).when(command).getVdsGroupDAO();
    doReturn(vdsGroup).when(vdsGroupDao).get(Mockito.any(Guid.class));
    doReturn(clusterUtils).when(command).getClusterUtils();
    when(clusterUtils.getUpServer(CLUSTER_ID)).thenReturn(getVds(VDSStatus.Up));
}
#end_block

#method_before
@Test
public void isCpuPinningValid() {
    Assert.assertTrue("null value must be accepted", VmManagementCommandBase.isCpuPinningValid(null));
    Assert.assertTrue("empty string must be accepted", VmManagementCommandBase.isCpuPinningValid(""));
    Assert.assertFalse(VmManagementCommandBase.isCpuPinningValid("intentionally invalid"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#0"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#^3"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#^3,^2"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^6"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^6,^7"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^6,^7"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^5,^6,^7"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1,2,3"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#^1,^2,^3"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4,6-8"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4,6-8,9-12"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4,^3,9-12,^10"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#0_1#1"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-2_1#1-2"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1,2,3_1#2,3"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1,2,3_1#1-4,^3"));
    // validate vcpus over 9
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("10#1,2,3_11#1-4,^3"));
}
#method_after
@Test
public void isCpuPinningValid() {
    Assert.assertTrue("null value must be accepted", VmManagementCommandBase.isCpuPinningValid(null));
    Assert.assertTrue("empty string must be accepted", VmManagementCommandBase.isCpuPinningValid(""));
    Assert.assertFalse(VmManagementCommandBase.isCpuPinningValid("intentionally invalid"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#0"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#^3"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#^3,^2"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^6"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^6,^7"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^6,^7"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^5,^6,^7"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1,2,3"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#^1,^2,^3"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4,6-8"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4,6-8,9-12"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4,^3,9-12,^10"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#0_1#1"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-2_1#1-2"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1,2,3_1#2,3"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1,2,3_1#1-4,^3"));
    // validate vcpus over 9
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("10#1,2,3_11#1-4,^3"));
    // negative tests
    Assert.assertFalse("random wrong text", VmManagementCommandBase.isCpuPinningValid("lorem ipsum"));
    Assert.assertFalse("no cpu id specified, should not pass", VmManagementCommandBase.isCpuPinningValid("0"));
    Assert.assertFalse("letter instead of vcpu ID", VmManagementCommandBase.isCpuPinningValid("A#1"));
    Assert.assertFalse("letter instead of cpu ID", VmManagementCommandBase.isCpuPinningValid("0#B"));
    Assert.assertFalse("A separating _ while only one vcpu pinning", VmManagementCommandBase.isCpuPinningValid("0#1_"));
    Assert.assertFalse("Trailing _", VmManagementCommandBase.isCpuPinningValid("0#1_1#2_"));
    Assert.assertFalse("Too many separators", VmManagementCommandBase.isCpuPinningValid("0#1__1#2"));
    Assert.assertFalse("trailing junk", VmManagementCommandBase.isCpuPinningValid("0#1_1#2..."));
}
#end_block

#method_before
@Override
protected void verify(VM model, VM transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getTemplate());
    assertEquals(model.getTemplate().getId(), transform.getTemplate().getId());
    assertNotNull(transform.getCluster());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.getOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertTrue(transform.isSetDisplay());
    assertEquals(model.isSetDisplay(), transform.isSetDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getPlacementPolicy().getHost().getId(), transform.getPlacementPolicy().getHost().getId());
    assertTrue(Math.abs(model.getMemoryPolicy().getGuaranteed() - transform.getMemoryPolicy().getGuaranteed()) <= (1024 * 1024));
    assertEquals(model.getDomain().getName(), transform.getDomain().getName());
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getUsb().isEnabled(), transform.getUsb().isEnabled());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.isPreventDeletion(), transform.isPreventDeletion());
}
#method_after
@Override
protected void verify(VM model, VM transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getTemplate());
    assertEquals(model.getTemplate().getId(), transform.getTemplate().getId());
    assertNotNull(transform.getCluster());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.getOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertTrue(transform.isSetDisplay());
    assertEquals(model.isSetDisplay(), transform.isSetDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getPlacementPolicy().getHost().getId(), transform.getPlacementPolicy().getHost().getId());
    assertTrue(Math.abs(model.getMemoryPolicy().getGuaranteed() - transform.getMemoryPolicy().getGuaranteed()) <= (1024 * 1024));
    assertEquals(model.getDomain().getName(), transform.getDomain().getName());
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getUsb().isEnabled(), transform.getUsb().isEnabled());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.isDeleteProtected(), transform.isDeleteProtected());
}
#end_block

#method_before
@Mapping(from = Template.class, to = VmTemplate.class)
public static VmTemplate map(Template model, VmTemplate incoming) {
    VmTemplate entity = incoming != null ? incoming : new VmTemplate();
    if (model.isSetName()) {
        entity.setname(model.getName());
    }
    if (model.isSetId()) {
        entity.setId(new Guid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setvds_group_id(new Guid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setauto_startup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setpriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        entity.setis_stateless(model.isStateless());
    }
    if (model.isSetPreventDeletion()) {
        entity.setPreventDeletion(model.isPreventDeletion());
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setvm_type(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        entity.setorigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        entity.setmem_size_mb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setcpu_per_socket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setnum_of_sockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            OsType osType = OsType.fromValue(model.getOs().getType());
            if (osType != null) {
                entity.setos(VmMapper.map(osType, null));
            }
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setdefault_boot_sequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setkernel_url(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setinitrd_url(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setkernel_params(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                entity.setdefault_display_type(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setnum_of_monitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        entity.setdomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        entity.settime_zone(TimeZoneMapping.getWindows(model.getTimezone()));
    }
    if (model.isSetUsb() && model.getUsb().isSetEnabled()) {
        entity.setusb_policy(model.getUsb().isEnabled() ? UsbPolicy.ENABLED_LEGACY : UsbPolicy.DISABLED);
    }
    return entity;
}
#method_after
@Mapping(from = Template.class, to = VmTemplate.class)
public static VmTemplate map(Template model, VmTemplate incoming) {
    VmTemplate entity = incoming != null ? incoming : new VmTemplate();
    if (model.isSetName()) {
        entity.setname(model.getName());
    }
    if (model.isSetId()) {
        entity.setId(new Guid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setvds_group_id(new Guid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setauto_startup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setpriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        entity.setis_stateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setvm_type(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        entity.setorigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        entity.setmem_size_mb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setcpu_per_socket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setnum_of_sockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            OsType osType = OsType.fromValue(model.getOs().getType());
            if (osType != null) {
                entity.setos(VmMapper.map(osType, null));
            }
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setdefault_boot_sequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setkernel_url(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setinitrd_url(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setkernel_params(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                entity.setdefault_display_type(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setnum_of_monitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        entity.setdomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        entity.settime_zone(TimeZoneMapping.getWindows(model.getTimezone()));
    }
    if (model.isSetUsb() && model.getUsb().isSetEnabled()) {
        entity.setusb_policy(model.getUsb().isEnabled() ? UsbPolicy.ENABLED_LEGACY : UsbPolicy.DISABLED);
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = Template.class, to = VmStatic.class)
public static VmStatic map(Template model, VmStatic incoming) {
    VmStatic staticVm = incoming != null ? incoming : new VmStatic();
    if (model.isSetName()) {
        staticVm.setvm_name(model.getName());
    }
    if (model.isSetId()) {
        staticVm.setId(new Guid(model.getId()));
    }
    if (model.isSetDescription()) {
        staticVm.setdescription(model.getDescription());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            staticVm.setauto_startup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            staticVm.setpriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        staticVm.setis_stateless(model.isStateless());
    }
    if (model.isSetPreventDeletion()) {
        staticVm.setPreventDeletion(model.isPreventDeletion());
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            staticVm.setvm_type(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        staticVm.setorigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        staticVm.setmem_size_mb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            staticVm.setcpu_per_socket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            staticVm.setnum_of_sockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            OsType osType = OsType.fromValue(model.getOs().getType());
            if (osType != null) {
                staticVm.setos(VmMapper.map(osType, null));
            }
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            staticVm.setkernel_url(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            staticVm.setkernel_params(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        staticVm.setdomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(model.getTimezone()));
    }
    return staticVm;
}
#method_after
@Mapping(from = Template.class, to = VmStatic.class)
public static VmStatic map(Template model, VmStatic incoming) {
    VmStatic staticVm = incoming != null ? incoming : new VmStatic();
    if (model.isSetName()) {
        staticVm.setvm_name(model.getName());
    }
    if (model.isSetId()) {
        staticVm.setId(new Guid(model.getId()));
    }
    if (model.isSetDescription()) {
        staticVm.setdescription(model.getDescription());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            staticVm.setauto_startup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            staticVm.setpriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        staticVm.setis_stateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            staticVm.setvm_type(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        staticVm.setorigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        staticVm.setmem_size_mb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            staticVm.setcpu_per_socket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            staticVm.setnum_of_sockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            OsType osType = OsType.fromValue(model.getOs().getType());
            if (osType != null) {
                staticVm.setos(VmMapper.map(osType, null));
            }
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            staticVm.setkernel_url(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            staticVm.setkernel_params(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        staticVm.setdomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(model.getTimezone()));
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = Template.class)
public static Template map(VmTemplate entity, Template incoming) {
    Template model = incoming != null ? incoming : new Template();
    model.setId(entity.getId().toString());
    model.setName(entity.getname());
    model.setDescription(entity.getdescription());
    model.setMemory((long) entity.getmem_size_mb() * BYTES_PER_MB);
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.getauto_startup());
    model.getHighAvailability().setPriority(entity.getpriority());
    model.setStateless(entity.getis_stateless());
    model.setPreventDeletion(entity.getPreventDeletion());
    if (entity.getvm_type() != null) {
        model.setType(VmMapper.map(entity.getvm_type(), null));
    }
    if (entity.getorigin() != null) {
        model.setOrigin(VmMapper.map(entity.getorigin(), null));
    }
    if (entity.getstatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getstatus(), null)));
    }
    if (entity.getos() != null || entity.getdefault_boot_sequence() != null || entity.getkernel_url() != null || entity.getinitrd_url() != null || entity.getkernel_params() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getos() != null) {
            OsType osType = VmMapper.map(entity.getos(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getdefault_boot_sequence() != null) {
            for (Boot boot : VmMapper.map(entity.getdefault_boot_sequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getkernel_url());
        os.setInitrd(entity.getinitrd_url());
        os.setCmdline(entity.getkernel_params());
        model.setOs(os);
    }
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getnum_of_sockets());
    topology.setCores(entity.getnum_of_cpus() / entity.getnum_of_sockets());
    model.setCpu(new CPU());
    model.getCpu().setTopology(topology);
    if (entity.getdefault_display_type() != null) {
        model.setDisplay(new Display());
        model.getDisplay().setType(VmMapper.map(entity.getdefault_display_type(), null));
        model.getDisplay().setMonitors(entity.getnum_of_monitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    if (entity.getcreation_date() != null) {
        model.setCreationTime(DateMapper.map(entity.getcreation_date(), null));
    }
    if (entity.getdomain() != null && !entity.getdomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getdomain());
        model.setDomain(domain);
    }
    if (entity.getusb_policy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getusb_policy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getusb_policy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    model.setTimezone(TimeZoneMapping.getJava(entity.gettime_zone()));
    return model;
}
#method_after
@Mapping(from = VmTemplate.class, to = Template.class)
public static Template map(VmTemplate entity, Template incoming) {
    Template model = incoming != null ? incoming : new Template();
    model.setId(entity.getId().toString());
    model.setName(entity.getname());
    model.setDescription(entity.getdescription());
    model.setMemory((long) entity.getmem_size_mb() * BYTES_PER_MB);
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.getauto_startup());
    model.getHighAvailability().setPriority(entity.getpriority());
    model.setStateless(entity.getis_stateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    if (entity.getvm_type() != null) {
        model.setType(VmMapper.map(entity.getvm_type(), null));
    }
    if (entity.getorigin() != null) {
        model.setOrigin(VmMapper.map(entity.getorigin(), null));
    }
    if (entity.getstatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getstatus(), null)));
    }
    if (entity.getos() != null || entity.getdefault_boot_sequence() != null || entity.getkernel_url() != null || entity.getinitrd_url() != null || entity.getkernel_params() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getos() != null) {
            OsType osType = VmMapper.map(entity.getos(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getdefault_boot_sequence() != null) {
            for (Boot boot : VmMapper.map(entity.getdefault_boot_sequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getkernel_url());
        os.setInitrd(entity.getinitrd_url());
        os.setCmdline(entity.getkernel_params());
        model.setOs(os);
    }
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getnum_of_sockets());
    topology.setCores(entity.getnum_of_cpus() / entity.getnum_of_sockets());
    model.setCpu(new CPU());
    model.getCpu().setTopology(topology);
    if (entity.getdefault_display_type() != null) {
        model.setDisplay(new Display());
        model.getDisplay().setType(VmMapper.map(entity.getdefault_display_type(), null));
        model.getDisplay().setMonitors(entity.getnum_of_monitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    if (entity.getcreation_date() != null) {
        model.setCreationTime(DateMapper.map(entity.getcreation_date(), null));
    }
    if (entity.getdomain() != null && !entity.getdomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getdomain());
        model.setDomain(domain);
    }
    if (entity.getusb_policy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getusb_policy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getusb_policy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    model.setTimezone(TimeZoneMapping.getJava(entity.gettime_zone()));
    return model;
}
#end_block

#method_before
@Override
protected void verify(Template model, Template transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getCluster());
    assertEquals(model.getCluster().getId(), transform.getCluster().getId());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.isSetOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertNotNull(model.getDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getDomain().getName(), transform.getDomain().getName());
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getUsb().isEnabled(), transform.getUsb().isEnabled());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.isPreventDeletion(), transform.isPreventDeletion());
}
#method_after
@Override
protected void verify(Template model, Template transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getCluster());
    assertEquals(model.getCluster().getId(), transform.getCluster().getId());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.isSetOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertNotNull(model.getDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getDomain().getName(), transform.getDomain().getName());
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getUsb().isEnabled(), transform.getUsb().isEnabled());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.isDeleteProtected(), transform.isDeleteProtected());
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setvmt_guid(entity.getId());
    staticVm.setdomain(entity.getdomain());
    staticVm.setvds_group_id(entity.getvds_group_id());
    staticVm.setmem_size_mb(entity.getmem_size_mb());
    staticVm.setos(entity.getos());
    staticVm.setnice_level(entity.getnice_level());
    staticVm.setfail_back(entity.getfail_back());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setis_stateless(entity.getis_stateless());
    staticVm.setPreventDeletion(entity.getPreventDeletion());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setdefault_boot_sequence(entity.getdefault_boot_sequence());
    staticVm.setvm_type(entity.getvm_type());
    entity.setdefault_display_type(entity.getdefault_display_type());
    staticVm.setiso_path(entity.getiso_path());
    staticVm.setnum_of_sockets(entity.getnum_of_sockets());
    staticVm.setcpu_per_socket(entity.getcpu_per_socket());
    staticVm.setkernel_url(entity.getkernel_url());
    staticVm.setkernel_params(entity.getkernel_params());
    staticVm.setinitrd_url(entity.getinitrd_url());
    staticVm.settime_zone(entity.gettime_zone());
    staticVm.setnum_of_monitors(entity.getnum_of_monitors());
    staticVm.setAllowConsoleReconnect(entity.getAllowConsoleReconnect());
    staticVm.setpriority(entity.getpriority());
    staticVm.setusb_policy(entity.getusb_policy());
    return staticVm;
}
#method_after
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setvmt_guid(entity.getId());
    staticVm.setdomain(entity.getdomain());
    staticVm.setvds_group_id(entity.getvds_group_id());
    staticVm.setmem_size_mb(entity.getmem_size_mb());
    staticVm.setos(entity.getos());
    staticVm.setnice_level(entity.getnice_level());
    staticVm.setfail_back(entity.getfail_back());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setis_stateless(entity.getis_stateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setdefault_boot_sequence(entity.getdefault_boot_sequence());
    staticVm.setvm_type(entity.getvm_type());
    entity.setdefault_display_type(entity.getdefault_display_type());
    staticVm.setiso_path(entity.getiso_path());
    staticVm.setnum_of_sockets(entity.getnum_of_sockets());
    staticVm.setcpu_per_socket(entity.getcpu_per_socket());
    staticVm.setkernel_url(entity.getkernel_url());
    staticVm.setkernel_params(entity.getkernel_params());
    staticVm.setinitrd_url(entity.getinitrd_url());
    staticVm.settime_zone(entity.gettime_zone());
    staticVm.setnum_of_monitors(entity.getnum_of_monitors());
    staticVm.setAllowConsoleReconnect(entity.getAllowConsoleReconnect());
    staticVm.setpriority(entity.getpriority());
    staticVm.setusb_policy(entity.getusb_policy());
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isSetPreventDeletion()) {
        staticVm.setPreventDeletion(vm.isPreventDeletion());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetUsb() && vm.getUsb().isSetEnabled()) {
        staticVm.setusb_policy(vm.getUsb().isEnabled() ? UsbPolicy.ENABLED_LEGACY : UsbPolicy.DISABLED);
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetUsb() && vm.getUsb().isSetEnabled()) {
        staticVm.setusb_policy(vm.getUsb().isEnabled() ? UsbPolicy.ENABLED_LEGACY : UsbPolicy.DISABLED);
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getvm_name());
    model.setDescription(entity.getvm_description());
    model.setMemory((long) entity.getmem_size_mb() * BYTES_PER_MB);
    if (entity.getvmt_guid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getvmt_guid().toString());
    }
    if (entity.getstatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getstatus(), null)));
        if (entity.getstatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getvm_os() != null || entity.getboot_sequence() != null || entity.getkernel_url() != null || entity.getinitrd_url() != null || entity.getkernel_params() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getvm_os() != null) {
            OsType osType = VmMapper.map(entity.getos(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getboot_sequence() != null) {
            for (Boot boot : map(entity.getdefault_boot_sequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getkernel_url());
        os.setInitrd(entity.getinitrd_url());
        os.setCmdline(entity.getkernel_params());
        model.setOs(os);
    }
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getnum_of_sockets());
    topology.setCores(entity.getnum_of_cpus() / entity.getnum_of_sockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getrun_on_vds() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getrun_on_vds().toString());
    }
    if (entity.getdefault_display_type() != null) {
        model.setDisplay(new Display());
        if (getIsVmRunning(entity) && entity.getDynamicData() != null) {
            model.getDisplay().setType(map(entity.getDynamicData().getdisplay_type(), null));
        } else {
            model.getDisplay().setType(map(entity.getdefault_display_type(), null));
        }
        model.getDisplay().setAddress(entity.getdisplay_ip());
        Integer displayPort = entity.getdisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getdisplay_secure_port();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getnum_of_monitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    model.setType(map(entity.getvm_type(), null));
    model.setStateless(entity.getis_stateless());
    model.setPreventDeletion(entity.getPreventDeletion());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.getauto_startup());
    model.getHighAvailability().setPriority(entity.getpriority());
    if (entity.getorigin() != null) {
        model.setOrigin(map(entity.getorigin(), null));
    }
    if (entity.getvm_creation_date() != null) {
        model.setCreationTime(DateMapper.map(entity.getvm_creation_date(), null));
    }
    if (entity.getDynamicData() != null && entity.getDynamicData().getLastStartTime() != null) {
        model.setStartTime(DateMapper.map(entity.getDynamicData().getLastStartTime(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getdedicated_vm_for_vds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getdedicated_vm_for_vds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getvm_domain() != null && !entity.getvm_domain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getvm_domain());
        model.setDomain(domain);
    }
    if (entity.getvm_ip() != null && !entity.getvm_ip().isEmpty()) {
        model.setGuestInfo(new GuestInfo());
        model.getGuestInfo().setIps(new IPs());
        for (String item : entity.getvm_ip().split(" ")) {
            if (!item.equals("")) {
                IP ip = new IP();
                ip.setAddress(item.trim());
                model.getGuestInfo().getIps().getIPs().add(ip);
            }
        }
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.gettime_zone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getusb_policy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getusb_policy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getusb_policy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getvm_name());
    model.setDescription(entity.getvm_description());
    model.setMemory((long) entity.getmem_size_mb() * BYTES_PER_MB);
    if (entity.getvmt_guid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getvmt_guid().toString());
    }
    if (entity.getstatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getstatus(), null)));
        if (entity.getstatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getvm_os() != null || entity.getboot_sequence() != null || entity.getkernel_url() != null || entity.getinitrd_url() != null || entity.getkernel_params() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getvm_os() != null) {
            OsType osType = VmMapper.map(entity.getos(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getboot_sequence() != null) {
            for (Boot boot : map(entity.getdefault_boot_sequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getkernel_url());
        os.setInitrd(entity.getinitrd_url());
        os.setCmdline(entity.getkernel_params());
        model.setOs(os);
    }
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getnum_of_sockets());
    topology.setCores(entity.getnum_of_cpus() / entity.getnum_of_sockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getrun_on_vds() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getrun_on_vds().toString());
    }
    if (entity.getdefault_display_type() != null) {
        model.setDisplay(new Display());
        if (getIsVmRunning(entity) && entity.getDynamicData() != null) {
            model.getDisplay().setType(map(entity.getDynamicData().getdisplay_type(), null));
        } else {
            model.getDisplay().setType(map(entity.getdefault_display_type(), null));
        }
        model.getDisplay().setAddress(entity.getdisplay_ip());
        Integer displayPort = entity.getdisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getdisplay_secure_port();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getnum_of_monitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    model.setType(map(entity.getvm_type(), null));
    model.setStateless(entity.getis_stateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.getauto_startup());
    model.getHighAvailability().setPriority(entity.getpriority());
    if (entity.getorigin() != null) {
        model.setOrigin(map(entity.getorigin(), null));
    }
    if (entity.getvm_creation_date() != null) {
        model.setCreationTime(DateMapper.map(entity.getvm_creation_date(), null));
    }
    if (entity.getDynamicData() != null && entity.getDynamicData().getLastStartTime() != null) {
        model.setStartTime(DateMapper.map(entity.getDynamicData().getLastStartTime(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getdedicated_vm_for_vds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getdedicated_vm_for_vds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getvm_domain() != null && !entity.getvm_domain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getvm_domain());
        model.setDomain(domain);
    }
    if (entity.getvm_ip() != null && !entity.getvm_ip().isEmpty()) {
        model.setGuestInfo(new GuestInfo());
        model.getGuestInfo().setIps(new IPs());
        for (String item : entity.getvm_ip().split(" ")) {
            if (!item.equals("")) {
                IP ip = new IP();
                ip.setAddress(item.trim());
                model.getGuestInfo().getIps().getIPs().add(ip);
            }
        }
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.gettime_zone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getusb_policy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getusb_policy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getusb_policy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    return model;
}
#end_block

#method_before
private MapSqlParameterSource getFullParameterSource(VmStatic vm) {
    return getIdParamterSource(vm.getId()).addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("domain", vm.getdomain()).addValue("creation_date", vm.getcreation_date()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("prevent_deletion", vm.getPreventDeletion()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect()).addValue("cpu_pinning", vm.getCpuPinning());
}
#method_after
private MapSqlParameterSource getFullParameterSource(VmStatic vm) {
    return getIdParamterSource(vm.getId()).addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("domain", vm.getdomain()).addValue("creation_date", vm.getcreation_date()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect()).addValue("cpu_pinning", vm.getCpuPinning());
}
#end_block

#method_before
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().getPreventDeletion()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    getVmTemplate().setQuotaId(getParameters().getMasterVm().getQuotaId());
    getVmTemplate().setdedicated_vm_for_vds(getParameters().getMasterVm().getdedicated_vm_for_vds());
    getVmTemplate().setMigrationSupport(getParameters().getMasterVm().getMigrationSupport());
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#method_after
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    getVmTemplate().setQuotaId(getParameters().getMasterVm().getQuotaId());
    getVmTemplate().setdedicated_vm_for_vds(getParameters().getMasterVm().getdedicated_vm_for_vds());
    getVmTemplate().setMigrationSupport(getParameters().getMasterVm().getMigrationSupport());
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#end_block

#method_before
public static void Init() {
    mUpdateVmTemplate = new ObjectIdentityChecker(VmTemplateHandler.class);
    BlankVmTemplateId = new Guid("00000000-0000-0000-0000-000000000000");
    mUpdateVmTemplate.AddPermittedFields(new String[] { "name", "description", "domain", "os", "osType", "is_auto_suspend", "interfaces", "mem_size_mb", "num_of_sockets", "cpu_per_socket", "vds_group_id", "num_of_monitors", "allowConsoleReconnect", "usb_policy", "time_zone", "diskMap", "default_boot_sequence", "iso_path", "diskImageMap", "default_display_type", "priority", "auto_startup", "is_stateless", "initrd_url", "kernel_url", "kernel_params", "images", "interfaces", "quotaId", "quotaName", "quotaEnforcementType", "migrationSupport", "dedicated_vm_for_vds", "smartcardEnabled", "preventDeletion" });
}
#method_after
public static void Init() {
    mUpdateVmTemplate = new ObjectIdentityChecker(VmTemplateHandler.class);
    BlankVmTemplateId = new Guid("00000000-0000-0000-0000-000000000000");
    mUpdateVmTemplate.AddPermittedFields(new String[] { "name", "description", "domain", "os", "osType", "is_auto_suspend", "interfaces", "mem_size_mb", "num_of_sockets", "cpu_per_socket", "vds_group_id", "num_of_monitors", "allowConsoleReconnect", "usb_policy", "time_zone", "diskMap", "default_boot_sequence", "iso_path", "diskImageMap", "default_display_type", "priority", "auto_startup", "is_stateless", "initrd_url", "kernel_url", "kernel_params", "images", "interfaces", "quotaId", "quotaName", "quotaEnforcementType", "migrationSupport", "dedicated_vm_for_vds", "smartcardEnabled", "deleteProtected" });
}
#end_block

#method_before
protected void writeGeneralData() {
    _writer.WriteStartElement("Description");
    _writer.WriteRaw(vmBase.getdescription());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Domain");
    _writer.WriteRaw(vmBase.getdomain());
    _writer.WriteEndElement();
    _writer.WriteStartElement("CreationDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(vmBase.getcreation_date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("ExportDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(new Date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsAutoSuspend");
    _writer.WriteRaw(String.valueOf(vmBase.getis_auto_suspend()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("PreventDeletion");
    _writer.WriteRaw(String.valueOf(vmBase.getPreventDeletion()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsSmartcardEnabled");
    _writer.WriteRaw(String.valueOf(vmBase.isSmartcardEnabled()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TimeZone");
    _writer.WriteRaw(vmBase.gettime_zone());
    _writer.WriteEndElement();
    _writer.WriteStartElement("default_boot_sequence");
    _writer.WriteRaw(String.valueOf(vmBase.getdefault_boot_sequence().getValue()));
    _writer.WriteEndElement();
    if (!StringHelper.isNullOrEmpty(vmBase.getinitrd_url())) {
        _writer.WriteStartElement("initrd_url");
        _writer.WriteRaw(vmBase.getinitrd_url());
        _writer.WriteEndElement();
    }
    if (!StringHelper.isNullOrEmpty(vmBase.getkernel_url())) {
        _writer.WriteStartElement("kernel_url");
        _writer.WriteRaw(vmBase.getkernel_url());
        _writer.WriteEndElement();
    }
    if (!StringHelper.isNullOrEmpty(vmBase.getkernel_params())) {
        _writer.WriteStartElement("kernel_params");
        _writer.WriteRaw(vmBase.getkernel_params());
        _writer.WriteEndElement();
    }
    _writer.WriteStartElement("VmType");
    _writer.WriteRaw(String.valueOf(vmBase.getvm_type().getValue()));
    _writer.WriteEndElement();
}
#method_after
protected void writeGeneralData() {
    _writer.WriteStartElement("Description");
    _writer.WriteRaw(vmBase.getdescription());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Domain");
    _writer.WriteRaw(vmBase.getdomain());
    _writer.WriteEndElement();
    _writer.WriteStartElement("CreationDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(vmBase.getcreation_date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("ExportDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(new Date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsAutoSuspend");
    _writer.WriteRaw(String.valueOf(vmBase.getis_auto_suspend()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("DeleteProtected");
    _writer.WriteRaw(String.valueOf(vmBase.isDeleteProtected()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsSmartcardEnabled");
    _writer.WriteRaw(String.valueOf(vmBase.isSmartcardEnabled()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TimeZone");
    _writer.WriteRaw(vmBase.gettime_zone());
    _writer.WriteEndElement();
    _writer.WriteStartElement("default_boot_sequence");
    _writer.WriteRaw(String.valueOf(vmBase.getdefault_boot_sequence().getValue()));
    _writer.WriteEndElement();
    if (!StringHelper.isNullOrEmpty(vmBase.getinitrd_url())) {
        _writer.WriteStartElement("initrd_url");
        _writer.WriteRaw(vmBase.getinitrd_url());
        _writer.WriteEndElement();
    }
    if (!StringHelper.isNullOrEmpty(vmBase.getkernel_url())) {
        _writer.WriteStartElement("kernel_url");
        _writer.WriteRaw(vmBase.getkernel_url());
        _writer.WriteEndElement();
    }
    if (!StringHelper.isNullOrEmpty(vmBase.getkernel_params())) {
        _writer.WriteStartElement("kernel_params");
        _writer.WriteRaw(vmBase.getkernel_params());
        _writer.WriteEndElement();
    }
    _writer.WriteStartElement("VmType");
    _writer.WriteRaw(String.valueOf(vmBase.getvm_type().getValue()));
    _writer.WriteEndElement();
}
#end_block

#method_before
@Override
public void BuildNetwork() {
}
#method_after
@Override
public void BuildNetwork() {
// No implementation - networks aren't read from the OVF.
}
#end_block

#method_before
@Override
public void BuildDisk() {
    XmlNodeList list = _document.SelectNodes("//*/Section/Disk");
    for (XmlNode node : list) {
        final Guid guid = new Guid(node.Attributes.get("ovf:diskId").getValue());
        DiskImage image = LinqUtils.firstOrNull(_images, new Predicate<DiskImage>() {

            @Override
            public boolean eval(DiskImage diskImage) {
                return diskImage.getImageId().equals(guid);
            }
        });
        if (node.Attributes.get("ovf:vm_snapshot_id") != null) {
            image.setvm_snapshot_id(new Guid(node.Attributes.get("ovf:vm_snapshot_id").getValue()));
        }
        if (!StringHelper.isNullOrEmpty(node.Attributes.get("ovf:size").getValue())) {
            image.setsize(GigabyteToBytes(Long.parseLong(node.Attributes.get("ovf:size").getValue())));
        }
        if (!StringHelper.isNullOrEmpty(node.Attributes.get("ovf:actual_size").getValue())) {
            image.setactual_size(GigabyteToBytes(Long.parseLong(node.Attributes.get("ovf:actual_size").getValue())));
        }
        if (node.Attributes.get("ovf:volume-format") != null) {
            if (!StringHelper.isNullOrEmpty(node.Attributes.get("ovf:volume-format").getValue())) {
                image.setvolume_format(VolumeFormat.valueOf(node.Attributes.get("ovf:volume-format").getValue()));
            } else {
                image.setvolume_format(VolumeFormat.Unassigned);
            }
        } else {
            image.setvolume_format(VolumeFormat.Unassigned);
        }
        if (node.Attributes.get("ovf:volume-type") != null) {
            if (!StringHelper.isNullOrEmpty(node.Attributes.get("ovf:volume-type").getValue())) {
                image.setvolume_type(VolumeType.valueOf(node.Attributes.get("ovf:volume-type").getValue()));
            } else {
                image.setvolume_type(VolumeType.Unassigned);
            }
        } else {
            image.setvolume_type(VolumeType.Unassigned);
        }
        if (node.Attributes.get("ovf:disk-interface") != null) {
            if (!StringHelper.isNullOrEmpty(node.Attributes.get("ovf:disk-interface").getValue())) {
                image.setDiskInterface(DiskInterface.valueOf(node.Attributes.get("ovf:disk-interface").getValue()));
            }
        } else {
            image.setDiskInterface(DiskInterface.IDE);
        }
        if (node.Attributes.get("ovf:boot") != null) {
            if (!StringHelper.isNullOrEmpty(node.Attributes.get("ovf:boot").getValue())) {
                image.setBoot(Boolean.parseBoolean(node.Attributes.get("ovf:boot").getValue()));
            }
        }
        if (node.Attributes.get("ovf:wipe-after-delete") != null) {
            if (!StringHelper.isNullOrEmpty(node.Attributes.get("ovf:wipe-after-delete").getValue())) {
                image.setWipeAfterDelete(Boolean.parseBoolean(node.Attributes.get("ovf:wipe-after-delete").getValue()));
            }
        }
        if (node.Attributes.get("ovf:disk-alias") != null) {
            if (!StringHelper.isNullOrEmpty(node.Attributes.get("ovf:disk-alias").getValue())) {
                image.setDiskAlias(String.valueOf(node.Attributes.get("ovf:disk-alias").getValue()));
            }
        }
        if (node.Attributes.get("ovf:disk-description") != null) {
            if (!StringHelper.isNullOrEmpty(node.Attributes.get("ovf:disk-description").getValue())) {
                image.setDiskDescription(String.valueOf(node.Attributes.get("ovf:disk-description").getValue()));
            }
        }
    }
}
#method_after
@Override
public void BuildDisk() {
    XmlNodeList list = _document.SelectNodes("//*/Section/Disk");
    for (XmlNode node : list) {
        final Guid guid = new Guid(node.Attributes.get("ovf:diskId").getValue());
        DiskImage image = LinqUtils.firstOrNull(_images, new Predicate<DiskImage>() {

            @Override
            public boolean eval(DiskImage diskImage) {
                return diskImage.getImageId().equals(guid);
            }
        });
        if (node.Attributes.get("ovf:vm_snapshot_id") != null) {
            image.setvm_snapshot_id(new Guid(node.Attributes.get("ovf:vm_snapshot_id").getValue()));
        }
        if (!StringUtils.isEmpty(node.Attributes.get("ovf:size").getValue())) {
            image.setsize(GigabyteToBytes(Long.parseLong(node.Attributes.get("ovf:size").getValue())));
        }
        if (!StringUtils.isEmpty(node.Attributes.get("ovf:actual_size").getValue())) {
            image.setactual_size(GigabyteToBytes(Long.parseLong(node.Attributes.get("ovf:actual_size").getValue())));
        }
        if (node.Attributes.get("ovf:volume-format") != null) {
            if (!StringUtils.isEmpty(node.Attributes.get("ovf:volume-format").getValue())) {
                image.setvolume_format(VolumeFormat.valueOf(node.Attributes.get("ovf:volume-format").getValue()));
            } else {
                image.setvolume_format(VolumeFormat.Unassigned);
            }
        } else {
            image.setvolume_format(VolumeFormat.Unassigned);
        }
        if (node.Attributes.get("ovf:volume-type") != null) {
            if (!StringUtils.isEmpty(node.Attributes.get("ovf:volume-type").getValue())) {
                image.setvolume_type(VolumeType.valueOf(node.Attributes.get("ovf:volume-type").getValue()));
            } else {
                image.setvolume_type(VolumeType.Unassigned);
            }
        } else {
            image.setvolume_type(VolumeType.Unassigned);
        }
        if (node.Attributes.get("ovf:disk-interface") != null) {
            if (!StringUtils.isEmpty(node.Attributes.get("ovf:disk-interface").getValue())) {
                image.setDiskInterface(DiskInterface.valueOf(node.Attributes.get("ovf:disk-interface").getValue()));
            }
        } else {
            image.setDiskInterface(DiskInterface.IDE);
        }
        if (node.Attributes.get("ovf:boot") != null) {
            if (!StringUtils.isEmpty(node.Attributes.get("ovf:boot").getValue())) {
                image.setBoot(Boolean.parseBoolean(node.Attributes.get("ovf:boot").getValue()));
            }
        }
        if (node.Attributes.get("ovf:wipe-after-delete") != null) {
            if (!StringUtils.isEmpty(node.Attributes.get("ovf:wipe-after-delete").getValue())) {
                image.setWipeAfterDelete(Boolean.parseBoolean(node.Attributes.get("ovf:wipe-after-delete").getValue()));
            }
        }
        if (node.Attributes.get("ovf:disk-alias") != null) {
            if (!StringUtils.isEmpty(node.Attributes.get("ovf:disk-alias").getValue())) {
                image.setDiskAlias(String.valueOf(node.Attributes.get("ovf:disk-alias").getValue()));
            }
        }
        if (node.Attributes.get("ovf:disk-description") != null) {
            if (!StringUtils.isEmpty(node.Attributes.get("ovf:disk-description").getValue())) {
                image.setDiskDescription(String.valueOf(node.Attributes.get("ovf:disk-description").getValue()));
            }
        }
    }
}
#end_block

#method_before
public void readVmDevice(XmlNode node, VmBase vmBase, Guid deviceId, boolean isManaged) {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(deviceId, vmBase.getId()));
    if (node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).InnerText)) {
        vmDevice.setAddress(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).InnerText));
    } else {
        vmDevice.setAddress("");
    }
    if (node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).InnerText)) {
        vmDevice.setAlias(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).InnerText));
    } else {
        vmDevice.setAlias("");
    }
    XmlNode specParamsNode = node.SelectSingleNode(OvfProperties.VMD_SPEC_PARAMS, _xmlNS);
    if (specParamsNode != null && !StringHelper.isNullOrEmpty(specParamsNode.InnerText)) {
        vmDevice.setSpecParams(getMapNode(specParamsNode));
    } else {
        // Empty map
        vmDevice.setSpecParams(Collections.<String, Object>emptyMap());
    }
    if (node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText)) {
        vmDevice.setType(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText));
    } else {
        int resourceType = getResourceType(node, vmDevice, OvfProperties.VMD_RESOURCE_TYPE);
        vmDevice.setType(VmDeviceType.getoVirtDevice(resourceType).getName());
    }
    if (node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).InnerText)) {
        vmDevice.setDevice(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).InnerText));
    } else {
        setDeviceByResource(node, vmDevice);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).InnerText)) {
        vmDevice.setBootOrder(Integer.valueOf(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).InnerText));
    } else {
        vmDevice.setBootOrder(0);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).InnerText)) {
        vmDevice.setIsPlugged(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).InnerText));
    } else {
        vmDevice.setIsPlugged(Boolean.TRUE);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).InnerText)) {
        vmDevice.setIsReadOnly(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).InnerText));
    } else {
        vmDevice.setIsReadOnly(Boolean.FALSE);
    }
    if (isManaged) {
        vmBase.getManagedVmDeviceMap().put(vmDevice.getDeviceId(), vmDevice);
    } else {
        vmBase.getUnmanagedDeviceList().add(vmDevice);
    }
}
#method_after
public void readVmDevice(XmlNode node, VmBase vmBase, Guid deviceId, boolean isManaged) {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(deviceId, vmBase.getId()));
    if (node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).InnerText)) {
        vmDevice.setAddress(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).InnerText));
    } else {
        vmDevice.setAddress("");
    }
    if (node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).InnerText)) {
        vmDevice.setAlias(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).InnerText));
    } else {
        vmDevice.setAlias("");
    }
    XmlNode specParamsNode = node.SelectSingleNode(OvfProperties.VMD_SPEC_PARAMS, _xmlNS);
    if (specParamsNode != null && !StringUtils.isEmpty(specParamsNode.InnerText)) {
        vmDevice.setSpecParams(getMapNode(specParamsNode));
    } else {
        // Empty map
        vmDevice.setSpecParams(Collections.<String, Object>emptyMap());
    }
    if (node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText)) {
        vmDevice.setType(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText));
    } else {
        int resourceType = getResourceType(node, OvfProperties.VMD_RESOURCE_TYPE);
        vmDevice.setType(VmDeviceType.getoVirtDevice(resourceType).getName());
    }
    if (node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).InnerText)) {
        vmDevice.setDevice(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).InnerText));
    } else {
        setDeviceByResource(node, vmDevice);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).InnerText)) {
        vmDevice.setBootOrder(Integer.valueOf(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).InnerText));
    } else {
        vmDevice.setBootOrder(0);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).InnerText)) {
        vmDevice.setIsPlugged(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).InnerText));
    } else {
        vmDevice.setIsPlugged(Boolean.TRUE);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).InnerText)) {
        vmDevice.setIsReadOnly(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).InnerText));
    } else {
        vmDevice.setIsReadOnly(Boolean.FALSE);
    }
    if (isManaged) {
        vmBase.getManagedVmDeviceMap().put(vmDevice.getDeviceId(), vmDevice);
    } else {
        vmBase.getUnmanagedDeviceList().add(vmDevice);
    }
}
#end_block

#method_before
protected void readGeneralData() {
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node;
    node = content.SelectSingleNode("Description");
    if (node != null) {
        vmBase.setdescription(node.InnerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        vmBase.setdomain(node.InnerText);
    }
    node = content.SelectSingleNode("CreationDate");
    if (node != null) {
        Date creationDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
        if (creationDate != null) {
            vmBase.setcreation_date(creationDate);
        }
    }
    node = content.SelectSingleNode("ExportDate");
    if (node != null) {
        Date exportDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = content.SelectSingleNode("IsAutoSuspend");
    if (node != null) {
        vmBase.setis_auto_suspend(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        vmBase.settime_zone(node.InnerText);
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            vmBase.setdefault_boot_sequence(BootSequence.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            vmBase.setinitrd_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            vmBase.setkernel_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            vmBase.setkernel_params((node.InnerText));
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    for (XmlNode section : list) {
        String value = section.Attributes.get("xsi:type").getValue();
        if (StringHelper.EqOp(value, "ovf:OperatingSystemSection_Type")) {
            ReadOsSection(section);
        } else if (StringHelper.EqOp(value, "ovf:VirtualHardwareSection_Type")) {
            ReadHardwareSection(section);
        } else if (StringUtils.equals(value, "ovf:SnapshotsSection_Type")) {
            readSnapshotsSection(section);
        }
    }
    node = content.SelectSingleNode("Origin");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            vmBase.setorigin(OriginType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            vmBase.setvm_type(VmType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("IsSmartcardEnabled");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.InnerText));
        }
    }
    node = content.SelectSingleNode("PreventDeletion");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.InnerText));
        }
    }
    readGeneralData(content);
}
#method_after
protected void readGeneralData() {
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node;
    node = content.SelectSingleNode("Description");
    if (node != null) {
        vmBase.setdescription(node.InnerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        vmBase.setdomain(node.InnerText);
    }
    node = content.SelectSingleNode("CreationDate");
    if (node != null) {
        Date creationDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
        if (creationDate != null) {
            vmBase.setcreation_date(creationDate);
        }
    }
    node = content.SelectSingleNode("ExportDate");
    if (node != null) {
        Date exportDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = content.SelectSingleNode("IsAutoSuspend");
    if (node != null) {
        vmBase.setis_auto_suspend(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        vmBase.settime_zone(node.InnerText);
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setdefault_boot_sequence(BootSequence.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setinitrd_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setkernel_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setkernel_params((node.InnerText));
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    for (XmlNode section : list) {
        String value = section.Attributes.get("xsi:type").getValue();
        if ("ovf:OperatingSystemSection_Type".equals(value)) {
            ReadOsSection(section);
        } else if ("ovf:VirtualHardwareSection_Type".equals(value)) {
            ReadHardwareSection(section);
        } else if ("ovf:SnapshotsSection_Type".equals(value)) {
            readSnapshotsSection(section);
        }
    }
    node = content.SelectSingleNode("Origin");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setorigin(OriginType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setvm_type(VmType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("IsSmartcardEnabled");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.InnerText));
        }
    }
    node = content.SelectSingleNode("DeleteProtected");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.InnerText));
        }
    }
    readGeneralData(content);
}
#end_block

#method_before
protected void readSnapshotsSection(XmlNode section) {
}
#method_after
protected void readSnapshotsSection(@SuppressWarnings("unused") XmlNode section) {
// The snapshot section only has meaning for VMs, and is overridden in OvfVmReader.
}
#end_block

#method_before
private void buildImageReference() {
    XmlNodeList list = _document.SelectNodes("//*/File", _xmlNS);
    for (XmlNode node : list) {
        DiskImage image = new DiskImage();
        image.setImageId(new Guid(node.Attributes.get("ovf:id").getValue()));
        image.setimage_group_id(OvfParser.GetImageGrupIdFromImageFile(node.Attributes.get("ovf:href").getValue()));
        // Default values:
        image.setactive(true);
        image.setimageStatus(ImageStatus.OK);
        image.setdescription(node.Attributes.get("ovf:description").getValue());
        _images.add(image);
    }
}
#method_after
private void buildImageReference() {
    XmlNodeList list = _document.SelectNodes("//*/File", _xmlNS);
    for (XmlNode node : list) {
        DiskImage image = new DiskImage();
        image.setImageId(new Guid(node.Attributes.get("ovf:id").getValue()));
        image.setId(OvfParser.GetImageGrupIdFromImageFile(node.Attributes.get("ovf:href").getValue()));
        // Default values:
        image.setactive(true);
        image.setimageStatus(ImageStatus.OK);
        image.setdescription(node.Attributes.get("ovf:description").getValue());
        _images.add(image);
    }
}
#end_block

#method_before
private int getResourceType(XmlNode node, VmDevice vmDevice, String resource) {
    if (node.SelectSingleNode(resource, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(resource, _xmlNS).InnerText)) {
        return Integer.valueOf(node.SelectSingleNode(resource, _xmlNS).InnerText);
    }
    return -1;
}
#method_after
private int getResourceType(XmlNode node, String resource) {
    if (node.SelectSingleNode(resource, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(resource, _xmlNS).InnerText)) {
        return Integer.valueOf(node.SelectSingleNode(resource, _xmlNS).InnerText);
    }
    return -1;
}
#end_block

#method_before
private void setDeviceByResource(XmlNode node, VmDevice vmDevice) {
    int resourceType = getResourceType(node, vmDevice, OvfProperties.VMD_RESOURCE_TYPE);
    int resourceSubType = getResourceType(node, vmDevice, OvfProperties.VMD_SUB_RESOURCE_TYPE);
    if (resourceSubType == -1) {
        // we need special handling for Monitor to define it as vnc or spice
        if (Integer.valueOf(OvfHardware.Monitor) == resourceType) {
            // get number of monitors from VirtualQuantity in OVF
            if (node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS).InnerText)) {
                int virtualQuantity = Integer.valueOf(node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS).InnerText);
                if (virtualQuantity > 1) {
                    vmDevice.setDevice(VmDeviceType.QXL.getName());
                } else {
                    vmDevice.setDevice(VmDeviceType.CIRRUS.getName());
                }
            } else {
                // default to spice if quantity not found
                vmDevice.setDevice(VmDeviceType.QXL.getName());
            }
        } else {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(resourceType).getName());
        }
    } else if (Integer.valueOf(OvfHardware.Network) == resourceType) {
        // handle interfaces with different sub types : we have 0-3 as the VmInterfaceType enum
        boolean isKnownType = false;
        for (VmInterfaceType vmInterfaceType : VmInterfaceType.values()) {
            if ((Integer.valueOf(vmInterfaceType.getValue()) == resourceSubType)) {
                vmDevice.setDevice(VmDeviceType.BRIDGE.getName());
                isKnownType = true;
                break;
            }
        }
        if (!isKnownType) {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(resourceType).getName());
        }
    }
}
#method_after
private void setDeviceByResource(XmlNode node, VmDevice vmDevice) {
    int resourceType = getResourceType(node, OvfProperties.VMD_RESOURCE_TYPE);
    int resourceSubType = getResourceType(node, OvfProperties.VMD_SUB_RESOURCE_TYPE);
    if (resourceSubType == -1) {
        // we need special handling for Monitor to define it as vnc or spice
        if (Integer.valueOf(OvfHardware.Monitor) == resourceType) {
            // get number of monitors from VirtualQuantity in OVF
            if (node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS).InnerText)) {
                int virtualQuantity = Integer.valueOf(node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS).InnerText);
                if (virtualQuantity > 1) {
                    vmDevice.setDevice(VmDeviceType.QXL.getName());
                } else {
                    vmDevice.setDevice(VmDeviceType.CIRRUS.getName());
                }
            } else {
                // default to spice if quantity not found
                vmDevice.setDevice(VmDeviceType.QXL.getName());
            }
        } else {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(resourceType).getName());
        }
    } else if (Integer.valueOf(OvfHardware.Network) == resourceType) {
        // handle interfaces with different sub types : we have 0-3 as the VmInterfaceType enum
        boolean isKnownType = false;
        for (VmInterfaceType vmInterfaceType : VmInterfaceType.values()) {
            if ((Integer.valueOf(vmInterfaceType.getValue()) == resourceSubType)) {
                vmDevice.setDevice(VmDeviceType.BRIDGE.getName());
                isKnownType = true;
                break;
            }
        }
        if (!isKnownType) {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(resourceType).getName());
        }
    }
}
#end_block

#method_before
public static void Init() {
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(new String[] { "VM", "VmStatic", "VmDynamic" }), VMStatus.class);
    mUpdateVmsStatic.AddPermittedFields(new String[] { "vm_name", "description", "domain", "os", "osType", "creation_date", "num_of_monitors", "allowConsoleReconnect", "usb_policy", "is_auto_suspend", "auto_startup", "dedicated_vm_for_vds", "default_display_type", "priority", "default_boot_sequence", "initrd_url", "kernel_url", "kernel_params", "migrationSupport", "minAllocatedMem", "quotaId", "quotaName", "quotaEnforcementType", "cpuPinning", "vmPayload", "balloonEnabled", "smartcardEnabled", "preventDeletion", // images list is relational entity - ignore value changes
    "images", // interfaces is relational entity - ignore value changes
    "interfaces" });
    mUpdateVmsStatic.AddFields(Arrays.asList(new Enum<?>[] { VMStatus.Down }), Arrays.asList(new String[] { "vds_group_id", "time_zone", "is_stateless", "nice_level", "mem_size_mb", "num_of_sockets", "cpu_per_socket", "iso_path", "userDefinedProperties", "predefinedProperties", "customProperties" }));
}
#method_after
public static void Init() {
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(new String[] { "VM", "VmStatic", "VmDynamic" }), VMStatus.class);
    mUpdateVmsStatic.AddPermittedFields(new String[] { "vm_name", "description", "domain", "os", "osType", "creation_date", "num_of_monitors", "allowConsoleReconnect", "usb_policy", "is_auto_suspend", "auto_startup", "dedicated_vm_for_vds", "default_display_type", "priority", "default_boot_sequence", "initrd_url", "kernel_url", "kernel_params", "migrationSupport", "minAllocatedMem", "quotaId", "quotaName", "quotaEnforcementType", "cpuPinning", "vmPayload", "balloonEnabled", "smartcardEnabled", "deleteProtected", // images list is relational entity - ignore value changes
    "images", // interfaces is relational entity - ignore value changes
    "interfaces" });
    mUpdateVmsStatic.AddFields(Arrays.asList(new Enum<?>[] { VMStatus.Down }), Arrays.asList(new String[] { "vds_group_id", "time_zone", "is_stateless", "nice_level", "mem_size_mb", "num_of_sockets", "cpu_per_socket", "iso_path", "userDefinedProperties", "predefinedProperties", "customProperties" }));
}
#end_block

#method_before
@Override
public void save(VM vm) {
    getCallsHandler().executeModification("InsertVm", getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("prevent_deletion", vm.getPreventDeletion()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("cpu_pinning", vm.getCpuPinning()));
}
#method_after
@Override
public void save(VM vm) {
    getCallsHandler().executeModification("InsertVm", getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("cpu_pinning", vm.getCpuPinning()));
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setvm_name(rs.getString("vm_name"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setvm_mem_size_mb(rs.getInt("vm_mem_size_mb"));
    entity.setvmt_guid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setvm_os(VmOsType.forValue(rs.getInt("vm_os")));
    entity.setvm_description(rs.getString("vm_description"));
    entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvm_domain(rs.getString("vm_domain"));
    entity.setvm_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setvds_group_name(rs.getString("vds_group_name"));
    entity.setvds_group_description(rs.getString("vds_group_description"));
    entity.setvmt_name(rs.getString("vmt_name"));
    entity.setvmt_mem_size_mb(rs.getInt("vmt_mem_size_mb"));
    entity.setvmt_os(VmOsType.forValue(rs.getInt("vmt_os")));
    entity.setvmt_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setvmt_child_count(rs.getInt("vmt_child_count"));
    entity.setvmt_num_of_cpus(rs.getInt("vmt_num_of_cpus"));
    entity.setvmt_num_of_sockets(rs.getInt("vmt_num_of_sockets"));
    entity.setvmt_cpu_per_socket(rs.getInt("vmt_cpu_per_socket"));
    entity.setvmt_description(rs.getString("vmt_description"));
    entity.setstatus(VMStatus.forValue(rs.getInt("status")));
    entity.setvm_ip(rs.getString("vm_ip"));
    entity.setvm_host(rs.getString("vm_host"));
    entity.setvm_pid((Integer) rs.getObject("vm_pid"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setguest_cur_user_name(rs.getString("guest_cur_user_name"));
    entity.setguest_last_login_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setguest_cur_user_id(NGuid.createGuidFromString(rs.getString("guest_cur_user_id")));
    entity.setguest_last_logout_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
    entity.setguest_os(rs.getString("guest_os"));
    entity.setcpu_user(rs.getDouble("cpu_user"));
    entity.setcpu_sys(rs.getDouble("cpu_sys"));
    entity.setelapsed_time(rs.getDouble("elapsed_time"));
    entity.setusage_network_percent((Integer) rs.getObject("usage_network_percent"));
    entity.setusage_mem_percent((Integer) rs.getObject("usage_mem_percent"));
    entity.setusage_cpu_percent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setrun_on_vds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
    entity.setmigrating_to_vds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
    entity.setapp_list(rs.getString("app_list"));
    entity.setdisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(NGuid.createGuidFromString(rs.getString("vm_pool_id")));
    entity.setnum_of_monitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setis_initialized(rs.getBoolean("is_initialized"));
    entity.setis_auto_suspend(rs.getBoolean("is_auto_suspend"));
    entity.setnum_of_sockets(rs.getInt("num_of_sockets"));
    entity.setcpu_per_socket(rs.getInt("cpu_per_socket"));
    entity.setusb_policy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setacpi_enable((Boolean) rs.getObject("acpi_enable"));
    entity.setsession(SessionState.forValue(rs.getInt("session")));
    entity.setdisplay_ip(rs.getString("display_ip"));
    entity.setdisplay_type(DisplayType.forValue(rs.getInt("display_type")));
    entity.setkvm_enable((Boolean) rs.getObject("kvm_enable"));
    entity.setboot_sequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setrun_on_vds_name(rs.getString("run_on_vds_name"));
    entity.settime_zone(rs.getString("time_zone"));
    entity.setdisplay_secure_port((Integer) rs.getObject("display_secure_port"));
    entity.setutc_diff((Integer) rs.getObject("utc_diff"));
    entity.setauto_startup(rs.getBoolean("auto_startup"));
    entity.setis_stateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setPreventDeletion(rs.getBoolean("prevent_deletion"));
    entity.setdedicated_vm_for_vds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setfail_back(rs.getBoolean("fail_back"));
    entity.setlast_vds_run_on(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
    entity.setclient_ip(rs.getString("client_ip"));
    entity.setguest_requested_memory((Integer) rs.getObject("guest_requested_memory"));
    entity.setvds_group_cpu_name(rs.getString("vds_group_cpu_name"));
    entity.setvm_type(VmType.forValue(rs.getInt("vm_type")));
    entity.setstorage_pool_id(Guid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setstorage_pool_name(rs.getString("storage_pool_name"));
    entity.setselection_algorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setnice_level(rs.getInt("nice_level"));
    entity.sethibernation_vol_handle(rs.getString("hibernation_vol_handle"));
    entity.setdefault_boot_sequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setdefault_display_type(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setpriority(rs.getInt("priority"));
    entity.setiso_path(rs.getString("iso_path"));
    entity.setorigin(OriginType.forValue(rs.getInt("origin")));
    entity.setinitrd_url(rs.getString("initrd_url"));
    entity.setkernel_url(rs.getString("kernel_url"));
    entity.setkernel_params(rs.getString("kernel_params"));
    entity.setvds_group_compatibility_version(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setvm_name(rs.getString("vm_name"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setvm_mem_size_mb(rs.getInt("vm_mem_size_mb"));
    entity.setvmt_guid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setvm_os(VmOsType.forValue(rs.getInt("vm_os")));
    entity.setvm_description(rs.getString("vm_description"));
    entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvm_domain(rs.getString("vm_domain"));
    entity.setvm_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setvds_group_name(rs.getString("vds_group_name"));
    entity.setvds_group_description(rs.getString("vds_group_description"));
    entity.setvmt_name(rs.getString("vmt_name"));
    entity.setvmt_mem_size_mb(rs.getInt("vmt_mem_size_mb"));
    entity.setvmt_os(VmOsType.forValue(rs.getInt("vmt_os")));
    entity.setvmt_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setvmt_child_count(rs.getInt("vmt_child_count"));
    entity.setvmt_num_of_cpus(rs.getInt("vmt_num_of_cpus"));
    entity.setvmt_num_of_sockets(rs.getInt("vmt_num_of_sockets"));
    entity.setvmt_cpu_per_socket(rs.getInt("vmt_cpu_per_socket"));
    entity.setvmt_description(rs.getString("vmt_description"));
    entity.setstatus(VMStatus.forValue(rs.getInt("status")));
    entity.setvm_ip(rs.getString("vm_ip"));
    entity.setvm_host(rs.getString("vm_host"));
    entity.setvm_pid((Integer) rs.getObject("vm_pid"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setguest_cur_user_name(rs.getString("guest_cur_user_name"));
    entity.setguest_last_login_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setguest_cur_user_id(NGuid.createGuidFromString(rs.getString("guest_cur_user_id")));
    entity.setguest_last_logout_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
    entity.setguest_os(rs.getString("guest_os"));
    entity.setcpu_user(rs.getDouble("cpu_user"));
    entity.setcpu_sys(rs.getDouble("cpu_sys"));
    entity.setelapsed_time(rs.getDouble("elapsed_time"));
    entity.setusage_network_percent((Integer) rs.getObject("usage_network_percent"));
    entity.setusage_mem_percent((Integer) rs.getObject("usage_mem_percent"));
    entity.setusage_cpu_percent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setrun_on_vds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
    entity.setmigrating_to_vds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
    entity.setapp_list(rs.getString("app_list"));
    entity.setdisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(NGuid.createGuidFromString(rs.getString("vm_pool_id")));
    entity.setnum_of_monitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setis_initialized(rs.getBoolean("is_initialized"));
    entity.setis_auto_suspend(rs.getBoolean("is_auto_suspend"));
    entity.setnum_of_sockets(rs.getInt("num_of_sockets"));
    entity.setcpu_per_socket(rs.getInt("cpu_per_socket"));
    entity.setusb_policy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setacpi_enable((Boolean) rs.getObject("acpi_enable"));
    entity.setsession(SessionState.forValue(rs.getInt("session")));
    entity.setdisplay_ip(rs.getString("display_ip"));
    entity.setdisplay_type(DisplayType.forValue(rs.getInt("display_type")));
    entity.setkvm_enable((Boolean) rs.getObject("kvm_enable"));
    entity.setboot_sequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setrun_on_vds_name(rs.getString("run_on_vds_name"));
    entity.settime_zone(rs.getString("time_zone"));
    entity.setdisplay_secure_port((Integer) rs.getObject("display_secure_port"));
    entity.setutc_diff((Integer) rs.getObject("utc_diff"));
    entity.setauto_startup(rs.getBoolean("auto_startup"));
    entity.setis_stateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setdedicated_vm_for_vds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setfail_back(rs.getBoolean("fail_back"));
    entity.setlast_vds_run_on(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
    entity.setclient_ip(rs.getString("client_ip"));
    entity.setguest_requested_memory((Integer) rs.getObject("guest_requested_memory"));
    entity.setvds_group_cpu_name(rs.getString("vds_group_cpu_name"));
    entity.setvm_type(VmType.forValue(rs.getInt("vm_type")));
    entity.setstorage_pool_id(Guid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setstorage_pool_name(rs.getString("storage_pool_name"));
    entity.setselection_algorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setnice_level(rs.getInt("nice_level"));
    entity.sethibernation_vol_handle(rs.getString("hibernation_vol_handle"));
    entity.setdefault_boot_sequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setdefault_display_type(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setpriority(rs.getInt("priority"));
    entity.setiso_path(rs.getString("iso_path"));
    entity.setorigin(OriginType.forValue(rs.getInt("origin")));
    entity.setinitrd_url(rs.getString("initrd_url"));
    entity.setkernel_url(rs.getString("kernel_url"));
    entity.setkernel_params(rs.getString("kernel_params"));
    entity.setvds_group_compatibility_version(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    return entity;
}
#end_block

#method_before
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setos(VmOsType.forValue(rs.getInt("os")));
    entity.setdescription(rs.getString("description"));
    entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setnum_of_sockets(rs.getInt("num_of_sockets"));
    entity.setcpu_per_socket(rs.getInt("cpu_per_socket"));
    entity.settime_zone(rs.getString("time_zone"));
    entity.setvm_type(VmType.forValue(rs.getInt("vm_type")));
    entity.setusb_policy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setfail_back(rs.getBoolean("fail_back"));
    entity.setdefault_boot_sequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setnice_level(rs.getInt("nice_level"));
    entity.setis_auto_suspend(rs.getBoolean("is_auto_suspend"));
    entity.setpriority(rs.getInt("priority"));
    entity.setauto_startup(rs.getBoolean("auto_startup"));
    entity.setis_stateless(rs.getBoolean("is_stateless"));
    entity.setiso_path(rs.getString("iso_path"));
    entity.setorigin(OriginType.forValue(rs.getInt("origin")));
    entity.setkernel_url(rs.getString("kernel_url"));
    entity.setkernel_params(rs.getString("kernel_params"));
    entity.setinitrd_url(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setPreventDeletion(rs.getBoolean("prevent_deletion"));
}
#method_after
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setos(VmOsType.forValue(rs.getInt("os")));
    entity.setdescription(rs.getString("description"));
    entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setnum_of_sockets(rs.getInt("num_of_sockets"));
    entity.setcpu_per_socket(rs.getInt("cpu_per_socket"));
    entity.settime_zone(rs.getString("time_zone"));
    entity.setvm_type(VmType.forValue(rs.getInt("vm_type")));
    entity.setusb_policy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setfail_back(rs.getBoolean("fail_back"));
    entity.setdefault_boot_sequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setnice_level(rs.getInt("nice_level"));
    entity.setis_auto_suspend(rs.getBoolean("is_auto_suspend"));
    entity.setpriority(rs.getInt("priority"));
    entity.setauto_startup(rs.getBoolean("auto_startup"));
    entity.setis_stateless(rs.getBoolean("is_stateless"));
    entity.setiso_path(rs.getString("iso_path"));
    entity.setorigin(OriginType.forValue(rs.getInt("origin")));
    entity.setkernel_url(rs.getString("kernel_url"));
    entity.setkernel_params(rs.getString("kernel_params"));
    entity.setinitrd_url(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getchild_count()).addValue("creation_date", template.getcreation_date()).addValue("description", template.getdescription()).addValue("mem_size_mb", template.getmem_size_mb()).addValue("name", template.getname()).addValue("num_of_sockets", template.getnum_of_sockets()).addValue("cpu_per_socket", template.getcpu_per_socket()).addValue("os", template.getos()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getvds_group_id()).addValue("domain", template.getdomain()).addValue("num_of_monitors", template.getnum_of_monitors()).addValue("allow_console_reconnect", template.getAllowConsoleReconnect()).addValue("status", template.getstatus()).addValue("usb_policy", template.getusb_policy()).addValue("time_zone", template.gettime_zone()).addValue("fail_back", template.getfail_back()).addValue("is_auto_suspend", template.getis_auto_suspend()).addValue("vm_type", template.getvm_type()).addValue("nice_level", template.getnice_level()).addValue("default_boot_sequence", template.getdefault_boot_sequence()).addValue("default_display_type", template.getdefault_display_type()).addValue("priority", template.getpriority()).addValue("auto_startup", template.getauto_startup()).addValue("is_stateless", template.getis_stateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("prevent_deletion", template.getPreventDeletion()).addValue("iso_path", template.getiso_path()).addValue("origin", template.getorigin()).addValue("initrd_url", template.getinitrd_url()).addValue("kernel_url", template.getkernel_url()).addValue("kernel_params", template.getkernel_params()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getdedicated_vm_for_vds());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getchild_count()).addValue("creation_date", template.getcreation_date()).addValue("description", template.getdescription()).addValue("mem_size_mb", template.getmem_size_mb()).addValue("name", template.getname()).addValue("num_of_sockets", template.getnum_of_sockets()).addValue("cpu_per_socket", template.getcpu_per_socket()).addValue("os", template.getos()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getvds_group_id()).addValue("domain", template.getdomain()).addValue("num_of_monitors", template.getnum_of_monitors()).addValue("allow_console_reconnect", template.getAllowConsoleReconnect()).addValue("status", template.getstatus()).addValue("usb_policy", template.getusb_policy()).addValue("time_zone", template.gettime_zone()).addValue("fail_back", template.getfail_back()).addValue("is_auto_suspend", template.getis_auto_suspend()).addValue("vm_type", template.getvm_type()).addValue("nice_level", template.getnice_level()).addValue("default_boot_sequence", template.getdefault_boot_sequence()).addValue("default_display_type", template.getdefault_display_type()).addValue("priority", template.getpriority()).addValue("auto_startup", template.getauto_startup()).addValue("is_stateless", template.getis_stateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("iso_path", template.getiso_path()).addValue("origin", template.getorigin()).addValue("initrd_url", template.getinitrd_url()).addValue("kernel_url", template.getkernel_url()).addValue("kernel_params", template.getkernel_params()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getdedicated_vm_for_vds());
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    if (autoStartup != other.autoStartup) {
        return false;
    }
    if (autosuspend != other.autosuspend) {
        return false;
    }
    if (cpusPerSocket != other.cpusPerSocket) {
        return false;
    }
    if (creationDate == null) {
        if (other.creationDate != null) {
            return false;
        }
    } else if (!creationDate.equals(other.creationDate)) {
        return false;
    }
    if (defaultBootSequence != other.defaultBootSequence) {
        return false;
    }
    if (description == null) {
        if (other.description != null) {
            return false;
        }
    } else if (!description.equals(other.description)) {
        return false;
    }
    if (domain == null) {
        if (other.domain != null) {
            return false;
        }
    } else if (!domain.equals(other.domain)) {
        return false;
    }
    if (fail_back != other.fail_back) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (initrdUrl == null) {
        if (other.initrdUrl != null) {
            return false;
        }
    } else if (!initrdUrl.equals(other.initrdUrl)) {
        return false;
    }
    if (isoPath == null) {
        if (other.isoPath != null) {
            return false;
        }
    } else if (!isoPath.equals(other.isoPath)) {
        return false;
    }
    if (kernelParams == null) {
        if (other.kernelParams != null) {
            return false;
        }
    } else if (!kernelParams.equals(other.kernelParams)) {
        return false;
    }
    if (kernelUrl == null) {
        if (other.kernelUrl != null) {
            return false;
        }
    } else if (!kernelUrl.equals(other.kernelUrl)) {
        return false;
    }
    if (mOs != other.mOs) {
        return false;
    }
    if (memSizeMB != other.memSizeMB) {
        return false;
    }
    if (niceLevel != other.niceLevel) {
        return false;
    }
    if (numOfSockets != other.numOfSockets) {
        return false;
    }
    if (numOfMonitors != other.numOfMonitors) {
        return false;
    }
    if (origin != other.origin) {
        return false;
    }
    if (priority != other.priority) {
        return false;
    }
    if (stateless != other.stateless) {
        return false;
    }
    if (smartcardEnabled != other.smartcardEnabled) {
        return false;
    }
    if (preventDeletion != other.preventDeletion) {
        return false;
    }
    if (timezone == null) {
        if (other.timezone != null) {
            return false;
        }
    } else if (!timezone.equals(other.timezone)) {
        return false;
    }
    if (usbPolicy != other.usbPolicy) {
        return false;
    }
    if (vds_group_id == null) {
        if (other.vds_group_id != null) {
            return false;
        }
    } else if (!vds_group_id.equals(other.vds_group_id)) {
        return false;
    }
    if (vmType != other.vmType) {
        return false;
    }
    if (quotaId == null) {
        if (other.quotaId != null)
            return false;
    } else if (!quotaId.equals(other.quotaId))
        return false;
    if (allowConsoleReconnect != other.allowConsoleReconnect) {
        return false;
    }
    if (dedicated_vm_for_vds == null) {
        if (other.dedicated_vm_for_vds != null) {
            return false;
        }
    } else {
        if (!dedicated_vm_for_vds.equals(other.dedicated_vm_for_vds)) {
            return false;
        }
    }
    if (migrationSupport != other.migrationSupport) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    if (autoStartup != other.autoStartup) {
        return false;
    }
    if (autosuspend != other.autosuspend) {
        return false;
    }
    if (cpusPerSocket != other.cpusPerSocket) {
        return false;
    }
    if (creationDate == null) {
        if (other.creationDate != null) {
            return false;
        }
    } else if (!creationDate.equals(other.creationDate)) {
        return false;
    }
    if (defaultBootSequence != other.defaultBootSequence) {
        return false;
    }
    if (description == null) {
        if (other.description != null) {
            return false;
        }
    } else if (!description.equals(other.description)) {
        return false;
    }
    if (domain == null) {
        if (other.domain != null) {
            return false;
        }
    } else if (!domain.equals(other.domain)) {
        return false;
    }
    if (fail_back != other.fail_back) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (initrdUrl == null) {
        if (other.initrdUrl != null) {
            return false;
        }
    } else if (!initrdUrl.equals(other.initrdUrl)) {
        return false;
    }
    if (isoPath == null) {
        if (other.isoPath != null) {
            return false;
        }
    } else if (!isoPath.equals(other.isoPath)) {
        return false;
    }
    if (kernelParams == null) {
        if (other.kernelParams != null) {
            return false;
        }
    } else if (!kernelParams.equals(other.kernelParams)) {
        return false;
    }
    if (kernelUrl == null) {
        if (other.kernelUrl != null) {
            return false;
        }
    } else if (!kernelUrl.equals(other.kernelUrl)) {
        return false;
    }
    if (mOs != other.mOs) {
        return false;
    }
    if (memSizeMB != other.memSizeMB) {
        return false;
    }
    if (niceLevel != other.niceLevel) {
        return false;
    }
    if (numOfSockets != other.numOfSockets) {
        return false;
    }
    if (numOfMonitors != other.numOfMonitors) {
        return false;
    }
    if (origin != other.origin) {
        return false;
    }
    if (priority != other.priority) {
        return false;
    }
    if (stateless != other.stateless) {
        return false;
    }
    if (smartcardEnabled != other.smartcardEnabled) {
        return false;
    }
    if (deleteProtected != other.deleteProtected) {
        return false;
    }
    if (timezone == null) {
        if (other.timezone != null) {
            return false;
        }
    } else if (!timezone.equals(other.timezone)) {
        return false;
    }
    if (usbPolicy != other.usbPolicy) {
        return false;
    }
    if (vds_group_id == null) {
        if (other.vds_group_id != null) {
            return false;
        }
    } else if (!vds_group_id.equals(other.vds_group_id)) {
        return false;
    }
    if (vmType != other.vmType) {
        return false;
    }
    if (quotaId == null) {
        if (other.quotaId != null)
            return false;
    } else if (!quotaId.equals(other.quotaId))
        return false;
    if (allowConsoleReconnect != other.allowConsoleReconnect) {
        return false;
    }
    if (dedicated_vm_for_vds == null) {
        if (other.dedicated_vm_for_vds != null) {
            return false;
        }
    } else {
        if (!dedicated_vm_for_vds.equals(other.dedicated_vm_for_vds)) {
            return false;
        }
    }
    if (migrationSupport != other.migrationSupport) {
        return false;
    }
    return true;
}
#end_block

#method_before
@UiChild(tagname = "tab")
public void addTab(final DialogTab tab) {
    tabContainer.add(tab);
    tab.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            switchTab(tab);
        }
    });
    tab.addKeyUpHandler(new KeyUpHandler() {

        @Override
        public void onKeyUp(KeyUpEvent event) {
            // if space key was pressed
            if (32 == event.getNativeKeyCode()) {
                switchTab(tab);
            }
        }
    });
    // Switch to first tab automatically
    if (tabContainer.getWidgetCount() == 1) {
        switchTab(tab);
    }
}
#method_after
@UiChild(tagname = "tab")
public void addTab(final DialogTab tab) {
    tabContainer.add(tab);
    tab.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            switchTab(tab);
        }
    });
    tab.addKeyUpHandler(new KeyUpHandler() {

        @Override
        public void onKeyUp(KeyUpEvent event) {
            if (SPACE_KEY_CODE == event.getNativeKeyCode()) {
                switchTab(tab);
            }
        }
    });
    // Switch to first tab automatically
    if (tabContainer.getWidgetCount() == 1) {
        switchTab(tab);
    }
}
#end_block

#method_before
public boolean getCheckValue(Iterable<T> items, SelectionModel selectionModel) {
    if (!items.iterator().hasNext()) {
        return false;
    }
    boolean allSelected = true;
    for (T entity : items) {
        if (!selectionModel.isSelected(entity)) {
            allSelected = false;
        }
    }
    return allSelected;
}
#method_after
public boolean getCheckValue(Iterable<T> items, SelectionModel selectionModel) {
    if (!items.iterator().hasNext()) {
        return false;
    }
    boolean allSelected = true;
    for (T entity : items) {
        if (!selectionModel.isSelected(entity)) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public int setTabIndexes(int startTabIndex) {
    int nextTabIndex = startTabIndex;
    int nbWidgets = footerButtonPanel.getWidgetCount();
    for (int i = nbWidgets - 1; i >= 0; --i) {
        Widget iWidget = footerButtonPanel.getWidget(i);
        if (iWidget instanceof FocusableComponentsContainer)
            nextTabIndex = ((FocusableComponentsContainer) iWidget).setTabIndexes(nextTabIndex);
    }
    return nextTabIndex;
}
#method_after
public int setTabIndexes(int nextTabIndex) {
    int nbWidgets = footerButtonPanel.getWidgetCount();
    for (int i = nbWidgets - 1; i >= 0; --i) {
        Widget iWidget = footerButtonPanel.getWidget(i);
        if (iWidget instanceof FocusableComponentsContainer)
            nextTabIndex = ((FocusableComponentsContainer) iWidget).setTabIndexes(nextTabIndex);
    }
    return nextTabIndex;
}
#end_block

#method_before
public int setTabIndexes(int startTabIndex) {
    // default behavior, should be overridden by subclasses
    return startTabIndex;
}
#method_after
public int setTabIndexes(int nextTabIndex) {
    // default behavior, should be overridden by subclasses
    return nextTabIndex;
}
#end_block

#method_before
@Override
public int setTabIndexes(int startTabIndex) {
    int nextTabIndex = startTabIndex;
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    isTemplatePublicEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    isTemplatePublicEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#end_block

#method_before
public int setTabIndexes(int startTabIndex) {
    int nextTabIndex = startTabIndex;
    diskAliasEditor.setTabIndex(nextTabIndex++);
    storageListEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#method_after
public int setTabIndexes(int nextTabIndex) {
    diskAliasEditor.setTabIndex(nextTabIndex++);
    storageListEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#end_block

#method_before
public int setTabIndexes(int startTabIndex) {
    int nextTabIndex = startTabIndex;
    int nbWidgetsInDiskListPanel = diskListPanel.getWidgetCount();
    for (int i = 0; i < nbWidgetsInDiskListPanel; ++i) {
        Widget widget = diskListPanel.getWidget(i);
        if (widget instanceof FocusableComponentsContainer)
            nextTabIndex = ((FocusableComponentsContainer) widget).setTabIndexes(nextTabIndex);
    }
    return nextTabIndex;
}
#method_after
public int setTabIndexes(int nextTabIndex) {
    int nbWidgetsInDiskListPanel = diskListPanel.getWidgetCount();
    for (int i = 0; i < nbWidgetsInDiskListPanel; ++i) {
        Widget widget = diskListPanel.getWidget(i);
        if (widget instanceof FocusableComponentsContainer)
            nextTabIndex = ((FocusableComponentsContainer) widget).setTabIndexes(nextTabIndex);
    }
    return nextTabIndex;
}
#end_block

#method_before
public int setTabIndexes(int startTabIndex) {
    int nextTabIndex = startTabIndex;
    button.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#method_after
public int setTabIndexes(int nextTabIndex) {
    button.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        return AuditLogType.VDS_APPROVE;
    } else {
        return super.getAuditLogTypeValue();
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    if (!getSucceeded()) {
        if (_failureLogTypeValue == AuditLogType.VDS_INSTALL_FAILED) {
            AddCustomValue("FailedInstallMessage", getErrorMessage(_failureMessage));
        }
        return _failureLogTypeValue;
    } else {
        return AuditLogType.VDS_APPROVE;
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVds() != null && isOvirtReInstallOrUpgrade()) {
        OVirtNodeUpgrade upgrade = null;
        try {
            T parameters = getParameters();
            upgrade = new OVirtNodeUpgrade(getVds(), parameters.getoVirtIsoFile());
            log.infoFormat("Execute upgrade {0} host {0}, {1}", Thread.currentThread().getName(), getVds().getId(), getVds().getvds_name());
            upgrade.execute();
            log.infoFormat("After upgrade {0}, host {0}, {1}: success", Thread.currentThread().getName(), getVds().getId(), getVds().getvds_name());
            setSucceeded(true);
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (upgrade != null) {
                upgrade.close();
            }
        }
        return;
    }
    if (getVds() != null) {
        VdsBootstrap installer = null;
        try {
            T parameters = getParameters();
            installer = new VdsBootstrap(getVds());
            if (getVds().getvds_type() == VDSType.VDS) {
                installer.setUser("root");
                installer.setPassword(parameters.getRootPassword());
                installer.setFirewall(parameters.getOverrideFirewall());
            } else if (getVds().getvds_type() == VDSType.PowerClient || getVds().getvds_type() == VDSType.oVirtNode) {
                log.infoFormat("Before Installation {0}, Powerclient/oVirtNode case: setting status to installing", Thread.currentThread().getName());
                if (parameters.getOverrideFirewall()) {
                    log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getvds_name(), getVds().getvds_type().name());
                }
                installer.setUser("root");
                installer.useDefaultKeyPair();
            }
            log.infoFormat("Before Installation {0}", Thread.currentThread().getName());
            installer.execute();
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
            log.infoFormat("After Installation {0}", Thread.currentThread().getName());
            setSucceeded(true);
        } catch (Exception e) {
            setSucceeded(false);
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (installer != null) {
                installer.close();
            }
        }
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVds() != null && isOvirtReInstallOrUpgrade()) {
        OVirtNodeUpgrade upgrade = null;
        try {
            T parameters = getParameters();
            upgrade = new OVirtNodeUpgrade(getVds(), parameters.getoVirtIsoFile());
            log.infoFormat("Execute upgrade host {0}, {1}", getVds().getId(), getVds().getvds_name());
            upgrade.execute();
            log.infoFormat("After upgrade host {0}, {1}: success", getVds().getId(), getVds().getvds_name());
            setSucceeded(true);
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (upgrade != null) {
                upgrade.close();
            }
        }
        return;
    }
    if (getVds() != null) {
        VdsDeploy installer = null;
        try {
            log.infoFormat("Before Installation host {0}, {1}", getVds().getId(), getVds().getvds_name());
            T parameters = getParameters();
            installer = new VdsDeploy(getVds());
            installer.setReboot(parameters.isRebootAfterInstallation());
            switch(getVds().getvds_type()) {
                case VDS:
                    installer.setUser("root");
                    installer.setPassword(parameters.getRootPassword());
                    installer.setFirewall(parameters.getOverrideFirewall());
                    break;
                case PowerClient:
                case oVirtNode:
                    if (parameters.getOverrideFirewall()) {
                        log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getvds_name(), getVds().getvds_type().name());
                    }
                    installer.setUser("root");
                    installer.useDefaultKeyPair();
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getvds_type()));
            }
            installer.execute();
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
            log.infoFormat("After Installation host {0}, {1}", getVds().getvds_name(), getVds().getvds_type().name());
            setSucceeded(true);
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (installer != null) {
                installer.close();
            }
        }
        return;
    }
}
#end_block

#method_before
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    // if runAsStateless
    if (getVm().getis_stateless()) {
        for (DiskImage image : getVm().getDiskList()) {
            if (image.getQuotaId() != null) {
                list.add(new QuotaStorageConsumptionParameter(image.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, image.getstorage_ids().get(0), image.getActualSize()));
            }
        }
    }
    return list;
}
#method_after
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (!getVm().getis_stateless()) {
        return list;
    }
    // if runAsStateless
    for (DiskImage image : getVm().getDiskList()) {
        if (image.getQuotaId() != null) {
            list.add(new QuotaStorageConsumptionParameter(image.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, image.getstorage_ids().get(0), image.getActualSize()));
        }
    }
    return list;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVm().getstatus() != VMStatus.Down) {
        log.error("Cannot remove VM snapshot. Vm is not Down");
        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
    }
    // No need for locking, VDSM tasks, and all that jazz.
    if (!hasImages()) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
        setSucceeded(true);
        return;
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
            getCompensationContext().snapshotEntityStatus(snapshot, snapshot.getStatus());
            getSnapshotDao().updateStatus(getParameters().getSnapshotId(), SnapshotStatus.LOCKED);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    freeLock();
    getParameters().setEntityId(getVmId());
    for (final DiskImage source : getSourceImages()) {
        // The following line is ok because we have tested in the
        // candoaction that the vm
        // is not a template and the vm is not in preview mode and that
        // this is not the active snapshot.
        DiskImage dest = getDiskImageDao().getAllSnapshotsForParent(source.getImageId()).get(0);
        ImagesContainterParametersBase tempVar = new ImagesContainterParametersBase(source.getImageId(), getVmId());
        tempVar.setDestinationImageId(dest.getImageId());
        tempVar.setEntityId(getParameters().getEntityId());
        tempVar.setParentParameters(getParameters());
        tempVar.setParentCommand(getActionType());
        ImagesContainterParametersBase p = tempVar;
        VdcReturnValueBase vdcReturnValue = getBackend().runInternalAction(VdcActionType.RemoveSnapshotSingleDisk, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        getParameters().getImagesParameters().add(p);
        if (vdcReturnValue != null && vdcReturnValue.getInternalTaskIdList() != null) {
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
        }
        QuotaManager.getInstance().removeQuotaFromCache(getStoragePoolId().getValue(), source.getQuotaId());
        QuotaManager.getInstance().removeQuotaFromCache(getStoragePoolId().getValue(), dest.getQuotaId());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (getVm().getstatus() != VMStatus.Down) {
        log.error("Cannot remove VM snapshot. Vm is not Down");
        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
    }
    // No need for locking, VDSM tasks, and all that jazz.
    if (!hasImages()) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
        setSucceeded(true);
        return;
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
            getCompensationContext().snapshotEntityStatus(snapshot, snapshot.getStatus());
            getSnapshotDao().updateStatus(getParameters().getSnapshotId(), SnapshotStatus.LOCKED);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    freeLock();
    getParameters().setEntityId(getVmId());
    for (final DiskImage source : getSourceImages()) {
        // The following line is ok because we have tested in the
        // candoaction that the vm
        // is not a template and the vm is not in preview mode and that
        // this is not the active snapshot.
        DiskImage dest = getDiskImageDao().getAllSnapshotsForParent(source.getImageId()).get(0);
        ImagesContainterParametersBase tempVar = new ImagesContainterParametersBase(source.getImageId(), getVmId());
        tempVar.setDestinationImageId(dest.getImageId());
        tempVar.setEntityId(getParameters().getEntityId());
        tempVar.setParentParameters(getParameters());
        tempVar.setParentCommand(getActionType());
        ImagesContainterParametersBase p = tempVar;
        VdcReturnValueBase vdcReturnValue = getBackend().runInternalAction(VdcActionType.RemoveSnapshotSingleDisk, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        getParameters().getImagesParameters().add(p);
        if (vdcReturnValue != null && vdcReturnValue.getInternalTaskIdList() != null) {
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
        }
        List<Guid> quotasToRemoveFromCache = new ArrayList<Guid>();
        quotasToRemoveFromCache.add(source.getQuotaId());
        quotasToRemoveFromCache.add(dest.getQuotaId());
        QuotaManager.getInstance().removeQuotaFromCache(getStoragePoolId().getValue(), quotasToRemoveFromCache);
    }
    setSucceeded(true);
}
#end_block

#method_before
@Test
public void quotaDependencyTest() {
    for (VdcActionType vdcActionType : VdcActionType.values()) {
        if (vdcActionType.getQuotaDependency() != VdcActionType.QuotaDependency.NONE) {
            Class commandClass = CommandsFactory.getCommandClass(vdcActionType.name());
            // if command is deprecated or internal - skip it
            if (commandClass.getAnnotation(Deprecated.class) != null || commandClass.getAnnotation(InternalCommandAttribute.class) != null) {
                continue;
            }
            switch(vdcActionType.getQuotaDependency()) {
                case VDS_GROUP:
                    assertCommandIsQuotaVdsDependent(commandClass);
                    break;
                case STORAGE:
                    assertCommandIsQuotaStorageDependent(commandClass);
                    break;
                case BOTH:
                    assertCommandIsQuotaVdsDependent(commandClass);
                    assertCommandIsQuotaStorageDependent(commandClass);
                    break;
                default:
                    break;
            }
        }
    }
}
#method_after
@Theory
public void quotaDependencyTest(VdcActionType vdcActionType) {
    if (vdcActionType.getQuotaDependency() != VdcActionType.QuotaDependency.NONE) {
        Class commandClass = CommandsFactory.getCommandClass(vdcActionType.name());
        // if command is deprecated or internal - skip it
        if (commandClass.getAnnotation(Deprecated.class) != null || commandClass.getAnnotation(InternalCommandAttribute.class) != null) {
            return;
        }
        switch(vdcActionType.getQuotaDependency()) {
            case VDS_GROUP:
                assertCommandIsQuotaVdsDependent(commandClass);
                break;
            case STORAGE:
                assertCommandIsQuotaStorageDependent(commandClass);
                break;
            case BOTH:
                assertCommandIsQuotaVdsDependent(commandClass);
                assertCommandIsQuotaStorageDependent(commandClass);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
private boolean isImplementingRecursive(Class commandClass, Class interfaceClass) {
    if (Arrays.asList(commandClass.getInterfaces()).contains(interfaceClass)) {
        return true;
    } else {
        return commandClass.getSuperclass() != CommandBase.class && isImplementingRecursive(commandClass.getSuperclass(), interfaceClass);
    }
}
#method_after
private boolean isImplementingRecursive(Class commandClass, Class interfaceClass) {
    if (Arrays.asList(commandClass.getInterfaces()).contains(interfaceClass)) {
        return true;
    } else {
        return !commandClass.getSuperclass().equals(CommandBase.class) && isImplementingRecursive(commandClass.getSuperclass(), interfaceClass);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    return isImageExist() && checkOperationIsCorrect() && canFindVmOrTemplate() && acquireLockInternal() && isImageIsNotLocked() && isSourceAndDestTheSame() && validateSourceStorageDomain(canDoActionMessages) && validateDestStorage(canDoActionMessages) && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && checkImageConfiguration(canDoActionMessages) && checkCanBeMoveInVm() && checkIfNeedToBeOverride();
}
#method_after
@Override
protected boolean canDoAction() {
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    return isImageExist() && checkOperationIsCorrect() && canFindVmOrTemplate() && acquireLockInternal() && isImageNotLocked() && isSourceAndDestTheSame() && validateSourceStorageDomain(canDoActionMessages) && validateDestStorage(canDoActionMessages) && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && checkImageConfiguration(canDoActionMessages) && checkCanBeMoveInVm() && checkIfNeedToBeOverride();
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    List<storage_domains> storageDomains = getStorageDomainDAO().getAllForStorageDomain(getParameters().getSourceDomainId().getValue());
    String sourceSDName = StringUtils.EMPTY;
    if (storageDomains.size() > 0) {
        sourceSDName = storageDomains.get(0).getstorage_name();
    }
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put("sourcesd", sourceSDName);
        jobProperties.put("targetsd", getStorageDomainName());
        jobProperties.put("action", getParameters().getOperation().getAction());
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    List<storage_domains> storageDomains = getStorageDomainDAO().getAllForStorageDomain(getParameters().getSourceDomainId().getValue());
    String sourceSDName = StringUtils.EMPTY;
    if (storageDomains.size() > 0) {
        sourceSDName = storageDomains.get(0).getstorage_name();
    }
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put("sourcesd", sourceSDName);
        jobProperties.put("targetsd", getStorageDomainName());
        if (ImageOperation.Move == getParameters().getOperation()) {
            jobProperties.put("action", "Moving");
        } else {
            jobProperties.put("action", "Copying");
        }
    }
    return jobProperties;
}
#end_block

#method_before
@Override
public void storagePoolUpEvent(storage_pool storagePool, boolean isNewSpm) {
    if (isNewSpm) {
        AsyncTaskManager.getInstance().StopStoragePoolTasks(storagePool);
    }
    {
        AsyncTaskManager.getInstance().AddStoragePoolExistingTasks(storagePool);
    }
}
#method_after
@Override
public void storagePoolUpEvent(storage_pool storagePool, boolean isNewSpm) {
    if (isNewSpm) {
        AsyncTaskManager.getInstance().StopStoragePoolTasks(storagePool);
    } else {
        AsyncTaskManager.getInstance().AddStoragePoolExistingTasks(storagePool);
    }
}
#end_block

#method_before
@Override
public void runFailedAutoStartVM(Guid vmId) {
    // We will reuse this because we can generate more than one event:
    final AuditLogableBase event = new AuditLogableBase();
    event.setVmId(vmId);
    // Alert that the virtual machine failed:
    AuditLogDirector.log(event, AuditLogType.HA_VM_FAILED);
    log.infoFormat("Restart of the Highly Available VM was initiated due to failure. VM Name:{0}, VM Id:{1}", event.getVmName(), vmId);
    // Try to start it again:
    final VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.RunVm, new RunVmParams(vmId), ExecutionHandler.createInternalJobContext());
    // Alert if the restart fails:
    if (!result.getSucceeded()) {
        AuditLogDirector.log(event, AuditLogType.HA_VM_RESTART_FAILED);
    }
}
#method_after
@Override
public void runFailedAutoStartVM(Guid vmId) {
    // We will reuse this because we can generate more than one event:
    final AuditLogableBase event = new AuditLogableBase();
    event.setVmId(vmId);
    // Alert that the virtual machine failed:
    AuditLogDirector.log(event, AuditLogType.HA_VM_FAILED);
    log.infoFormat("Failed to start Highly Available VM. Attempting to restart. VM Name: {0}, VM Id:{1}", event.getVmName(), vmId);
    // Try to start it again:
    final VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.RunVm, new RunVmParams(vmId), ExecutionHandler.createInternalJobContext());
    // Alert if the restart fails:
    if (!result.getSucceeded()) {
        AuditLogDirector.log(event, AuditLogType.HA_VM_RESTART_FAILED);
    }
}
#end_block

#method_before
@Override
public void rerun(Guid vmId) {
    IVdsAsyncCommand command = Backend.getInstance().getResourceManager().GetAsyncCommandForVm(vmId);
    if (command != null) {
        command.rerun();
    }
}
#method_after
@Override
public void rerun(Guid vmId) {
    final IVdsAsyncCommand command = Backend.getInstance().getResourceManager().GetAsyncCommandForVm(vmId);
    if (command != null) {
        // The command will be invoked in a different VDS in its rerun method, so we're calling
        // its rerun method from a new thread so that it won't be executed within our current VDSM lock
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                command.rerun();
            }
        });
    }
}
#end_block

#method_before
private static void initGlusterVolumeSeverities() {
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_HOST_ADD_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_HOST_REMOVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_HOST_REMOVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
}
#method_after
private static void initGlusterVolumeSeverities() {
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_HOST_ADD_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static String ComposeObjectId(AuditLogableBase logable, AuditLogType logType) {
    final char DELIMITER = ',';
    StringBuilder sb = new StringBuilder();
    sb.append("type=");
    sb.append(logType);
    sb.append(DELIMITER);
    sb.append("sd=");
    sb.append(logable.getStorageDomainId() == null ? "" : logable.getStorageDomainId().toString());
    sb.append(DELIMITER);
    sb.append("dc=");
    sb.append(logable.getStoragePoolId() == null ? "" : logable.getStoragePoolId().toString());
    sb.append(DELIMITER);
    sb.append("user=");
    sb.append(logable.getUserId() == null ? "" : logable.getUserId().toString());
    sb.append(DELIMITER);
    sb.append("cluster=");
    sb.append(logable.getVdsGroupId().toString());
    sb.append(DELIMITER);
    sb.append("vds=");
    sb.append(logable.getVdsId().toString());
    sb.append(DELIMITER);
    sb.append("vm=");
    sb.append(logable.getVmId().equals(Guid.Empty) ? "" : logable.getVmId().toString());
    sb.append(DELIMITER);
    sb.append("template=");
    sb.append(logable.getVmTemplateId().equals(Guid.Empty) ? "" : logable.getVmTemplateId().toString());
    sb.append(DELIMITER);
    return sb.toString();
}
#method_after
private static String ComposeObjectId(AuditLogableBase logable, AuditLogType logType) {
    final char DELIMITER = ',';
    StringBuilder sb = new StringBuilder();
    sb.append("type=");
    sb.append(logType);
    sb.append(DELIMITER);
    sb.append("sd=");
    sb.append(logable.getStorageDomainId() == null ? "" : logable.getStorageDomainId().toString());
    sb.append(DELIMITER);
    sb.append("dc=");
    sb.append(logable.getStoragePoolId() == null ? "" : logable.getStoragePoolId().toString());
    sb.append(DELIMITER);
    sb.append("user=");
    sb.append(logable.getUserId() == null ? "" : logable.getUserId().toString());
    sb.append(DELIMITER);
    sb.append("cluster=");
    sb.append(logable.getVdsGroupId().toString());
    sb.append(DELIMITER);
    sb.append("vds=");
    sb.append(logable.getVdsId().toString());
    sb.append(DELIMITER);
    sb.append("vm=");
    sb.append(logable.getVmId().equals(Guid.Empty) ? "" : logable.getVmId().toString());
    sb.append(DELIMITER);
    sb.append("template=");
    sb.append(logable.getVmTemplateId().equals(Guid.Empty) ? "" : logable.getVmTemplateId().toString());
    sb.append(DELIMITER);
    sb.append("customId=");
    sb.append(logable.getCustomId() == null ? "" : logable.getCustomId().toString());
    sb.append(DELIMITER);
    return sb.toString();
}
#end_block

#method_before
@Test
public void testExecuteQueryCommnad() {
    when(getQueryParameters().getServer()).thenReturn(serverName);
    doReturn(fingerPrint).when(getQuery()).getServerFingerprint(serverName);
    getQuery().executeQueryCommand();
    String serverFingerprint = (String) getQuery().getQueryReturnValue().getReturnValue();
    assertNotNull(serverFingerprint);
    assertEquals(fingerPrint, serverFingerprint);
}
#method_after
@Test
public void testExecuteQueryCommnad() throws IOException {
    when(getQueryParameters().getServer()).thenReturn(serverName);
    doReturn(fingerPrint).when(mockEngineSSHDialog).getHostFingerprint();
    getQuery().executeQueryCommand();
    String serverFingerprint = (String) getQuery().getQueryReturnValue().getReturnValue();
    assertNotNull(serverFingerprint);
    assertEquals(fingerPrint, serverFingerprint);
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
protected void executeQueryCommand() {
    VDSReturnValue returnValue = getBackendInstance().RunVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(getClusterUtils().getUpServer(getParameters().getClusterId()).getId()));
    Map<String, String> glusterServers = getAddedGlusterServers((List<GlusterServerInfo>) returnValue.getReturnValue());
    getQueryReturnValue().setReturnValue(glusterServers);
}
#method_after
@Override
@SuppressWarnings("unchecked")
protected void executeQueryCommand() {
    Map<String, String> glusterServers = new HashMap<String, String>();
    VDS upServer = getClusterUtils().getUpServer(getParameters().getClusterId());
    if (upServer != null) {
        VDSReturnValue returnValue = getBackendInstance().RunVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(upServer.getId()));
        glusterServers = getAddedGlusterServers((List<GlusterServerInfo>) returnValue.getReturnValue());
    }
    getQueryReturnValue().setReturnValue(glusterServers);
}
#end_block

#method_before
public String getServerFingerprint(String serverName) {
    String fingerPrint = null;
    SSHClient client = null;
    try {
        long timeout = Config.<Integer>GetValue(ConfigValues.SSHInactivityTimoutSeconds) * 1000;
        client = new SSHClient();
        client.setHardTimeout(timeout);
        client.setSoftTimeout(timeout);
        client.setHost(serverName, 22);
        client.connect();
        PublicKey serverKey = client.getServerKey();
        if (serverKey == null) {
            throw new Exception("No server key");
        }
        fingerPrint = OpenSSHUtils.getKeyFingerprintString(serverKey);
    } catch (Throwable e) {
        log.errorFormat("Could not fetch fingerprint of host {0} with message: {1}", serverName, ExceptionUtils.getMessage(e));
    } finally {
        if (client != null) {
            client.disconnect();
        }
    }
    return fingerPrint;
}
#method_after
public String getServerFingerprint(String serverName) {
    String fingerPrint = null;
    EngineSSHDialog dialog = getEngineSSHDialog();
    try {
        dialog.setHost(serverName);
        dialog.connect();
        fingerPrint = dialog.getHostFingerprint();
    } catch (Throwable e) {
        log.errorFormat("Could not fetch fingerprint of host {0} with message: {1}", serverName, ExceptionUtils.getMessage(e));
    } finally {
        dialog.disconnect();
    }
    return fingerPrint;
}
#end_block

#method_before
private void setupMock() throws Exception {
    vdsBrokerFrontend = mock(VDSBrokerFrontend.class);
    clusterUtils = mock(ClusterUtils.class);
    vdsDaoMock = mock(VdsDAO.class);
    doReturn(vdsBrokerFrontend).when(getQuery()).getBackendInstance();
    doReturn(clusterUtils).when(getQuery()).getClusterUtils();
    doReturn(getVds(VDSStatus.Up)).when(clusterUtils).getUpServer(CLUSTER_ID);
    VDSReturnValue returnValue = getVDSReturnValue();
    when(vdsBrokerFrontend.RunVdsCommand(eq(VDSCommandType.GlusterServersList), any(VDSParametersBase.class))).thenReturn(returnValue);
    doReturn(params.getClusterId()).when(getQueryParameters()).getClusterId();
    doReturn(true).when(getQueryParameters()).isServerKeyFingerprintRequired();
    doReturn(vdsDaoMock).when(clusterUtils).getVdsDao();
    doReturn(serversList).when(vdsDaoMock).getAllForVdsGroup(CLUSTER_ID);
    doReturn(serverKeyFingerprint).when(getQuery()).getServerFingerprint("test_server3");
}
#method_after
private void setupMock() throws Exception {
    vdsBrokerFrontend = mock(VDSBrokerFrontend.class);
    clusterUtils = mock(ClusterUtils.class);
    vdsDaoMock = mock(VdsDAO.class);
    doReturn(vdsBrokerFrontend).when(getQuery()).getBackendInstance();
    doReturn(clusterUtils).when(getQuery()).getClusterUtils();
    doReturn(getVds(VDSStatus.Up)).when(clusterUtils).getUpServer(CLUSTER_ID);
    VDSReturnValue returnValue = getVDSReturnValue();
    when(vdsBrokerFrontend.RunVdsCommand(eq(VDSCommandType.GlusterServersList), any(VDSParametersBase.class))).thenReturn(returnValue);
    doReturn(params.getClusterId()).when(getQueryParameters()).getClusterId();
    doReturn(true).when(getQueryParameters()).isServerKeyFingerprintRequired();
    doReturn(vdsDaoMock).when(clusterUtils).getVdsDao();
    doReturn(serversList).when(vdsDaoMock).getAllForVdsGroup(CLUSTER_ID);
    mockEngineSSHDialog = mock(EngineSSHDialog.class);
    doNothing().when(mockEngineSSHDialog).connect();
    doNothing().when(mockEngineSSHDialog).authenticate();
    doReturn(mockEngineSSHDialog).when(getQuery()).getEngineSSHDialog();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testExecuteQueryCommand() {
    getQuery().executeQueryCommand();
    Map<String, String> servers = (Map<String, String>) getQuery().getQueryReturnValue().getReturnValue();
    assertNotNull(servers);
    assertEquals(getAddedServers(), servers);
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testExecuteQueryCommand() throws IOException {
    doReturn(serverKeyFingerprint).when(mockEngineSSHDialog).getHostFingerprint();
    getQuery().executeQueryCommand();
    Map<String, String> servers = (Map<String, String>) getQuery().getQueryReturnValue().getReturnValue();
    assertNotNull(servers);
    assertEquals(getAddedServers(), servers);
}
#end_block

#method_before
public String getServerFingerprint(String serverName) {
    String fingerPrint = null;
    SSHClient client = null;
    try {
        long timeout = Config.<Integer>GetValue(ConfigValues.SSHInactivityTimoutSeconds) * 1000;
        client = new SSHClient();
        client.setHardTimeout(timeout);
        client.setSoftTimeout(timeout);
        client.setHost(serverName, 22);
        client.connect();
        PublicKey serverKey = client.getServerKey();
        if (serverKey == null) {
            throw new Exception("No server key");
        }
        fingerPrint = OpenSSHUtils.getKeyFingerprintString(serverKey);
    } catch (Throwable e) {
        log.errorFormat("Could not fetch fingerprint of host {0} with message: {1}", serverName, ExceptionUtils.getMessage(e));
    } finally {
        if (client != null) {
            client.disconnect();
        }
    }
    return fingerPrint;
}
#method_after
public String getServerFingerprint(String serverName) {
    String fingerPrint = null;
    EngineSSHDialog dialog = getEngineSSHDialog();
    try {
        dialog.setHost(serverName);
        dialog.connect();
        fingerPrint = dialog.getHostFingerprint();
    } catch (Throwable e) {
        log.errorFormat("Could not fetch fingerprint of host {0} with message: {1}", serverName, ExceptionUtils.getMessage(e));
    } finally {
        dialog.disconnect();
    }
    return fingerPrint;
}
#end_block

#method_before
private boolean _doConnect(String server, String user, String userPassword, String keyStore, String keyStorePassword, long hardTimeout, long softTimeout) {
    log.debug(String.format("_doConnect enter (%1$s, %2$s, %3$s, %4$s, %5$s, %6$d, %7$d)", server, user, userPassword, keyStore, keyStorePassword, hardTimeout, softTimeout));
    boolean ret = false;
    try {
        _openSession(server, hardTimeout, softTimeout);
        this.client.setUser(user);
        if (keyStore == null) {
            log.debug("Using password authentication.");
            this.client.setPassword(userPassword);
        } else {
            log.debug("Using Public Key Authentication.");
            String alias = Config.<String>GetValue(ConfigValues.CertAlias);
            KeyStore.PrivateKeyEntry entry;
            InputStream in = null;
            try {
                in = new FileInputStream(keyStore);
                KeyStore ks = KeyStore.getInstance("PKCS12");
                ks.load(in, keyStorePassword.toCharArray());
                entry = (KeyStore.PrivateKeyEntry) ks.getEntry(alias, new KeyStore.PasswordProtection(keyStorePassword.toCharArray()));
            } catch (Exception e) {
                throw new KeyStoreException(String.format("Failed to get certificate entry from key store: %1$s/%2$s", keyStore, alias), e);
            } finally {
                if (in != null) {
                    try {
                        in.close();
                    } catch (IOException e) {
                        log.error("Cannot close key store", e);
                    }
                }
            }
            if (entry == null) {
                throw new KeyStoreException(String.format("Bad key store: %1$s/%2$s", keyStore, alias));
            }
            this.client.setKeyPair(new KeyPair(entry.getCertificate().getPublicKey(), entry.getPrivateKey()));
        }
        PublicKey serverKey = this.client.getServerKey();
        String fingerprint = "Unknown";
        if (serverKey == null) {
            log.error("Unable to get host key");
        } else {
            String tmpFingerprint = OpenSSHUtils.getKeyFingerprintString(serverKey);
            if (tmpFingerprint == null) {
                log.error("Unable to get host fingerprint");
            } else {
                fingerprint = tmpFingerprint;
            }
        }
        _callbackAddMessage(String.format("<BSTRAP component='RHEV_INSTALL' status='OK' message='Connected to Host %1$s with SSH key fingerprint: %2$s'/>", this.client.getDisplayHost(), fingerprint));
        this.client.authenticate();
        _callbackConnected();
        ret = true;
    } catch (Exception e) {
        String m = String.format("Could not connect to server %1$s", this.client.getDisplayHost());
        log.error(m, e);
        _callbackFailed(m);
        return false;
    }
    log.debug("_doConnect return " + ret);
    return ret;
}
#method_after
private boolean _doConnect(String server, String user, String userPassword, String keyStore, String keyStorePassword, long hardTimeout, long softTimeout) {
    log.debug(String.format("_doConnect enter (%1$s, %2$s, %3$s, %4$s, %5$s, %6$d, %7$d)", server, user, userPassword, keyStore, keyStorePassword, hardTimeout, softTimeout));
    boolean ret = false;
    try {
        _openSession(server, hardTimeout, softTimeout);
        this.client.setUser(user);
        if (keyStore == null) {
            log.debug("Using password authentication.");
            this.client.setPassword(userPassword);
        } else {
            log.debug("Using Public Key Authentication.");
            String alias = Config.<String>GetValue(ConfigValues.CertAlias);
            KeyStore.PrivateKeyEntry entry;
            InputStream in = null;
            try {
                in = new FileInputStream(keyStore);
                KeyStore ks = KeyStore.getInstance("PKCS12");
                ks.load(in, keyStorePassword.toCharArray());
                entry = (KeyStore.PrivateKeyEntry) ks.getEntry(alias, new KeyStore.PasswordProtection(keyStorePassword.toCharArray()));
            } catch (Exception e) {
                throw new KeyStoreException(String.format("Failed to get certificate entry from key store: %1$s/%2$s", keyStore, alias), e);
            } finally {
                if (in != null) {
                    try {
                        in.close();
                    } catch (IOException e) {
                        log.error("Cannot close key store", e);
                    }
                }
            }
            if (entry == null) {
                throw new KeyStoreException(String.format("Bad key store: %1$s/%2$s", keyStore, alias));
            }
            this.client.setKeyPair(new KeyPair(entry.getCertificate().getPublicKey(), entry.getPrivateKey()));
        }
        PublicKey serverKey = this.client.getHostKey();
        String fingerprint = "Unknown";
        if (serverKey == null) {
            log.error("Unable to get host key");
        } else {
            String tmpFingerprint = OpenSSHUtils.getKeyFingerprintString(serverKey);
            if (tmpFingerprint == null) {
                log.error("Unable to get host fingerprint");
            } else {
                fingerprint = tmpFingerprint;
            }
        }
        _callbackAddMessage(String.format("<BSTRAP component='RHEV_INSTALL' status='OK' message='Connected to Host %1$s with SSH key fingerprint: %2$s'/>", this.client.getDisplayHost(), fingerprint));
        this.client.authenticate();
        _callbackConnected();
        ret = true;
    } catch (Exception e) {
        String m = String.format("Could not connect to server %1$s", this.client.getDisplayHost());
        log.error(m, e);
        _callbackFailed(m);
        return false;
    }
    log.debug("_doConnect return " + ret);
    return ret;
}
#end_block

#method_before
@Before
public void setup() throws IOException {
    assumeTrue(SystemUtils.IS_OS_UNIX);
    IConfigUtilsInterface confInstance = new DefaultValuesConfigUtil();
    Config.setConfigUtils(confInstance);
    hostKstore = System.getProperty("ssh-test-p12", "src/test/resources/key.p12");
    hostKstorePassword = System.getProperty("ssh-test-p12-password", "NoSoup4U");
    host = System.getProperty("ssh-host");
    if (host == null) {
        host = "localhost";
        user = "root";
        password = "password";
        sshd = new SSHD();
        try {
            KeyStore ks = KeyStore.getInstance("PKCS12");
            ks.load(new FileInputStream(hostKstore), hostKstorePassword.toCharArray());
            sshd.setUser(user, password, ks.getCertificate(Config.<String>GetValue(ConfigValues.CertAlias)).getPublicKey());
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
        try {
            sshd.start();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        port = sshd.getPort();
    } else {
        port = Integer.parseInt(System.getProperty("ssh-test-port", "22"));
        user = System.getProperty("ssh-test-user", "root");
        password = System.getProperty("ssh-test-password", "password");
    }
}
#method_after
@Before
public void setup() throws IOException {
    assumeTrue(SystemUtils.IS_OS_UNIX);
    IConfigUtilsInterface confInstance = new DefaultValuesConfigUtil();
    Config.setConfigUtils(confInstance);
    hostKstore = System.getProperty("ssh-test-p12", "src/test/resources/key.p12");
    hostKstorePassword = System.getProperty("ssh-test-p12-password", "NoSoup4U");
    hostKstoreAlias = System.getProperty("ssh-test-p12-alias", "1");
    host = System.getProperty("ssh-host");
    if (host == null) {
        host = "localhost";
        user = "root";
        password = "password";
        sshd = new SSHD();
        try {
            KeyStore ks = KeyStore.getInstance("PKCS12");
            ks.load(new FileInputStream(hostKstore), hostKstorePassword.toCharArray());
            sshd.setUser(user, password, ks.getCertificate(hostKstoreAlias).getPublicKey());
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
        try {
            sshd.start();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        port = sshd.getPort();
    } else {
        port = Integer.parseInt(System.getProperty("ssh-test-port", "22"));
        user = System.getProperty("ssh-test-user", "root");
        password = System.getProperty("ssh-test-password", "password");
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVds() != null && isOvirtReInstallOrUpgrade()) {
        OVirtNodeUpgrade upgrade = null;
        try {
            T parameters = getParameters();
            upgrade = new OVirtNodeUpgrade(getVds(), parameters.getoVirtIsoFile());
            log.infoFormat("Execute upgrade {0} host {0}, {1}", Thread.currentThread().getName(), getVds().getId(), getVds().getvds_name());
            upgrade.execute();
            log.infoFormat("After upgrade {0}, host {0}, {1}: success", Thread.currentThread().getName(), getVds().getId(), getVds().getvds_name());
            setSucceeded(true);
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (upgrade != null) {
                upgrade.close();
            }
        }
        return;
    }
    if (getVds() != null) {
        T parameters = getParameters();
        VdsInstaller vdsInstaller = null;
        if (getVds().getvds_type() == VDSType.VDS) {
            vdsInstaller = new VdsInstaller(getVds(), parameters.getRootPassword(), parameters.getOverrideFirewall(), parameters.isRebootAfterInstallation());
        } else if (getVds().getvds_type() == VDSType.PowerClient || getVds().getvds_type() == VDSType.oVirtNode) {
            log.infoFormat("Before Installation {0}, Powerclient/oVirtNode case: setting status to installing", Thread.currentThread().getName());
            if (parameters.getOverrideFirewall()) {
                log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getvds_name(), getVds().getvds_type().name());
            }
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Installing));
            vdsInstaller = new OVirtInstaller(getVds());
        }
        log.infoFormat("Before Installation {0}", Thread.currentThread().getName());
        boolean installResult = false;
        try {
            installResult = vdsInstaller.Install();
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
        }
        setSucceeded(installResult);
        log.infoFormat("After Installation {0}", Thread.currentThread().getName());
        if (getSucceeded()) {
            if (vdsInstaller.isAddOvirtFlow()) {
                log.debugFormat("Add manual oVirt flow ended successfully for {0}.", getVds().getvds_name());
                return;
            }
            switch(getVds().getvds_type()) {
                case VDS:
                    if (getParameters().isRebootAfterInstallation()) {
                        setHostStatus(VDSStatus.Reboot);
                        RunSleepOnReboot();
                    } else {
                        setHostStatus(VDSStatus.NonResponsive);
                    }
                    break;
                case oVirtNode:
                    if (getParameters().getIsReinstallOrUpgrade()) {
                        setHostStatus(VDSStatus.Reboot);
                        RunSleepOnReboot();
                    } else {
                        setHostStatus(VDSStatus.NonResponsive);
                    }
                    break;
                case PowerClient:
                    setHostStatus(VDSStatus.NonResponsive);
                    break;
            }
        } else {
            _failureMessage = getErrorMessage(vdsInstaller.getErrorMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
            setHostStatus(VDSStatus.InstallFailed);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVds() != null && isOvirtReInstallOrUpgrade()) {
        OVirtNodeUpgrade upgrade = null;
        try {
            T parameters = getParameters();
            upgrade = new OVirtNodeUpgrade(getVds(), parameters.getoVirtIsoFile());
            log.infoFormat("Execute upgrade host {0}, {1}", getVds().getId(), getVds().getvds_name());
            upgrade.execute();
            log.infoFormat("After upgrade host {0}, {1}: success", getVds().getId(), getVds().getvds_name());
            setSucceeded(true);
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (upgrade != null) {
                upgrade.close();
            }
        }
        return;
    }
    if (getVds() != null) {
        T parameters = getParameters();
        VdsInstaller vdsInstaller = null;
        if (getVds().getvds_type() == VDSType.VDS) {
            vdsInstaller = new VdsInstaller(getVds(), parameters.getRootPassword(), parameters.getOverrideFirewall(), parameters.isRebootAfterInstallation());
        } else if (getVds().getvds_type() == VDSType.PowerClient || getVds().getvds_type() == VDSType.oVirtNode) {
            log.infoFormat("Before Installation {0}, Powerclient/oVirtNode case: setting status to installing", Thread.currentThread().getName());
            if (parameters.getOverrideFirewall()) {
                log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getvds_name(), getVds().getvds_type().name());
            }
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Installing));
            vdsInstaller = new OVirtInstaller(getVds());
        }
        log.infoFormat("Before Installation {0}", Thread.currentThread().getName());
        boolean installResult = false;
        try {
            installResult = vdsInstaller.Install();
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
        }
        setSucceeded(installResult);
        log.infoFormat("After Installation {0}", Thread.currentThread().getName());
        if (getSucceeded()) {
            if (vdsInstaller.isAddOvirtFlow()) {
                log.debugFormat("Add manual oVirt flow ended successfully for {0}.", getVds().getvds_name());
                return;
            }
            switch(getVds().getvds_type()) {
                case VDS:
                    if (getParameters().isRebootAfterInstallation()) {
                        setHostStatus(VDSStatus.Reboot);
                        RunSleepOnReboot();
                    } else {
                        setHostStatus(VDSStatus.NonResponsive);
                    }
                    break;
                case oVirtNode:
                    if (getParameters().getIsReinstallOrUpgrade()) {
                        setHostStatus(VDSStatus.Reboot);
                        RunSleepOnReboot();
                    } else {
                        setHostStatus(VDSStatus.NonResponsive);
                    }
                    break;
                case PowerClient:
                    setHostStatus(VDSStatus.NonResponsive);
                    break;
            }
        } else {
            _failureMessage = getErrorMessage(vdsInstaller.getErrorMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
            setHostStatus(VDSStatus.InstallFailed);
        }
    }
}
#end_block

#method_before
public void connect() throws Exception {
    log.debug(String.format("connect enter (%1$s:%2$s, %3$d, %4$d)", _host, _port, _hardTimeout, _softTimeout));
    try {
        if (_client != null) {
            throw new IOException("Already connected");
        }
        _client = _getSSHClient();
        _client.setHardTimeout(_hardTimeout);
        _client.setSoftTimeout(_softTimeout);
        _client.setHost(_host, _port);
        log.debug("connecting");
        _client.connect();
    } catch (Exception e) {
        log.debug(String.format("Could not connect to host %1$s", _client.getDisplayHost()), e);
        throw e;
    }
}
#method_after
public void connect() throws Exception {
    if (log.isDebugEnabled()) {
        log.debug(String.format("connect enter (%1$s:%2$s, %3$d, %4$d)", _host, _port, _hardTimeout, _softTimeout));
    }
    try {
        if (_client != null) {
            throw new IOException("Already connected");
        }
        _client = _getSSHClient();
        _client.setHardTimeout(_hardTimeout);
        _client.setSoftTimeout(_softTimeout);
        _client.setHost(_host, _port);
        log.debug("connecting");
        _client.connect();
    } catch (Exception e) {
        log.debug(String.format("Could not connect to host %1$s", _client.getDisplayHost()), e);
        throw e;
    }
}
#end_block

#method_before
public boolean postOldXmlFormat(String message) {
    boolean error = false;
    if (StringUtils.isEmpty(message)) {
        return error;
    }
    String[] msgs = message.split("[\\n]", -1);
    if (msgs.length > 1) {
        for (String msg : msgs) {
            error = postOldXmlFormat(msg) || error;
        }
        return error;
    }
    if (StringUtils.isNotEmpty(message)) {
        if (message.charAt(0) == '<') {
            try {
                error = _postOldXmlFormat(message);
            } catch (RuntimeException e) {
                log.errorFormat("Installation of Host. Received illegal XML from Host. Message: {1}, Exception: {2}", message, e.toString());
            }
        } else {
            log.info("VDS message: " + message);
        }
    }
    return error;
}
#method_after
public boolean postOldXmlFormat(String message) {
    boolean error = false;
    if (StringUtils.isEmpty(message)) {
        return error;
    }
    String[] msgs = message.split("[\\n]", -1);
    if (msgs.length > 1) {
        for (String msg : msgs) {
            error = postOldXmlFormat(msg) || error;
        }
        return error;
    }
    if (StringUtils.isNotEmpty(message)) {
        if (message.charAt(0) == '<') {
            try {
                error = _internalPostOldXmlFormat(message);
            } catch (RuntimeException e) {
                error = true;
                log.errorFormat("Installation of Host. Received illegal XML from Host. Message: {0}", message, e);
            }
        } else {
            log.info("VDS message: " + message);
        }
    }
    return error;
}
#end_block

#method_before
@Override
public void stop() {
    if (_thread != null) {
        _thread.interrupt();
        while (true) {
            try {
                _thread.join();
                break;
            } catch (InterruptedException e) {
            }
        }
        _thread = null;
    }
}
#method_after
@Override
public void stop() {
    if (_thread != null) {
        /*
             * We cannot just interrupt the thread as the
             * implementation of jboss connection pooling
             * drops the connection when interrupted.
             * As we may have log events pending to be written
             * to database, we wait for some time for thread
             * complete before interrupting.
             */
        try {
            _thread.join(THREAD_JOIN_TIMEOUT);
        } catch (InterruptedException e) {
            log.error("interrupted", e);
        }
        if (_thread.isAlive()) {
            _thread.interrupt();
            while (true) {
                try {
                    _thread.join();
                    break;
                } catch (InterruptedException e) {
                }
            }
        }
        _thread = null;
    }
}
#end_block

#method_before
public void useDefaultKeyPair() throws KeyStoreException {
    String alias = Config.<String>GetValue(ConfigValues.CertAlias);
    String p12 = Config.<String>GetValue(ConfigValues.keystoreUrl);
    String password = Config.<String>GetValue(ConfigValues.keystorePass);
    KeyStore.PrivateKeyEntry entry;
    InputStream in = null;
    try {
        in = new FileInputStream(p12);
        KeyStore ks = KeyStore.getInstance("PKCS12");
        ks.load(in, password.toCharArray());
        entry = (KeyStore.PrivateKeyEntry) ks.getEntry(alias, new KeyStore.PasswordProtection(password.toCharArray()));
    } catch (Exception e) {
        throw new KeyStoreException(String.format("Failed to get certificate entry from key store: %1$s/%2$s", p12, alias), e);
    } finally {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close key store", e);
            }
        }
    }
    if (entry == null) {
        throw new KeyStoreException(String.format("Bad key store: %1$s/%2$s", p12, alias));
    }
    setKeyPair(new KeyPair(entry.getCertificate().getPublicKey(), entry.getPrivateKey()));
}
#method_after
public void useDefaultKeyPair() throws KeyStoreException {
    final String alias = Config.<String>GetValue(ConfigValues.CertAlias);
    final String p12 = Config.<String>GetValue(ConfigValues.keystoreUrl);
    final char[] password = Config.<String>GetValue(ConfigValues.keystorePass).toCharArray();
    KeyStore.PrivateKeyEntry entry;
    InputStream in = null;
    try {
        in = new FileInputStream(p12);
        KeyStore ks = KeyStore.getInstance("PKCS12");
        ks.load(in, password);
        entry = (KeyStore.PrivateKeyEntry) ks.getEntry(alias, new KeyStore.PasswordProtection(password));
    } catch (Exception e) {
        throw new KeyStoreException(String.format("Failed to get certificate entry from key store: %1$s/%2$s", p12, alias), e);
    } finally {
        Arrays.fill(password, '*');
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close key store", e);
            }
        }
    }
    if (entry == null) {
        throw new KeyStoreException(String.format("Bad key store: %1$s/%2$s", p12, alias));
    }
    setKeyPair(new KeyPair(entry.getCertificate().getPublicKey(), entry.getPrivateKey()));
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
protected void executeQueryCommand() {
    Map<String, String> glusterServers = null;
    VDS upServer = getClusterUtils().getUpServer(getParameters().getClusterId());
    if (upServer != null) {
        VDSReturnValue returnValue = getBackendInstance().RunVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(upServer.getId()));
        glusterServers = getAddedGlusterServers((List<GlusterServerInfo>) returnValue.getReturnValue());
    } else {
        glusterServers = new HashMap<String, String>();
    }
    getQueryReturnValue().setReturnValue(glusterServers);
}
#method_after
@Override
@SuppressWarnings("unchecked")
protected void executeQueryCommand() {
    Map<String, String> glusterServers = new HashMap<String, String>();
    VDS upServer = getClusterUtils().getUpServer(getParameters().getClusterId());
    if (upServer != null) {
        VDSReturnValue returnValue = getBackendInstance().RunVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(upServer.getId()));
        glusterServers = getAddedGlusterServers((List<GlusterServerInfo>) returnValue.getReturnValue());
    }
    getQueryReturnValue().setReturnValue(glusterServers);
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                    throw e;
                default:
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#end_block

#method_before
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (statelessSnapshotExistsForVm()) {
        log.errorFormat("RunVmAsStateless - {0} - found existing vm images in stateless_vm_image_map table - skipped creating snapshots.", getVm().getvm_name());
        removeVmStatlessImages();
    } else {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getvm_name(), getVm().getId());
        CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVm().getId(), "stateless snapshot");
        tempVar.setShouldBeLogged(false);
        tempVar.setParentCommand(getActionType());
        tempVar.setParentParameters(getParameters());
        tempVar.setEntityId(getParameters().getEntityId());
        CreateAllSnapshotsFromVmParameters p = tempVar;
        p.setSnapshotType(SnapshotType.STATELESS);
        Map<String, String> values = getVmValuesForMsgResolving();
        // Creating snapshots as sub step of run stateless
        Step createSnapshotsStep = addSubStep(StepEnum.EXECUTING, StepEnum.CREATING_SNAPSHOTS, values);
        // Add the step as the first step of the new context
        ExecutionContext createSnapshotsCtx = new ExecutionContext();
        createSnapshotsCtx.setMonitored(true);
        createSnapshotsCtx.setStep(createSnapshotsStep);
        VdcReturnValueBase vdcReturnValue = getBackend().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, new CommandContext(createSnapshotsCtx, getCompensationContext(), getLock()));
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getParameters().getImagesParameters().add(p);
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getvm_name());
        }
    }
}
#method_after
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (statelessSnapshotExistsForVm()) {
        log.errorFormat("RunVmAsStateless - {0} - found existing vm images in stateless_vm_image_map table - skipped creating snapshots.", getVm().getvm_name());
        removeVmStatlessImages();
    } else {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getvm_name(), getVm().getId());
        CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVm().getId(), "stateless snapshot");
        tempVar.setShouldBeLogged(false);
        tempVar.setParentCommand(getActionType());
        tempVar.setParentParameters(getParameters());
        tempVar.setEntityId(getParameters().getEntityId());
        CreateAllSnapshotsFromVmParameters p = tempVar;
        p.setSnapshotType(SnapshotType.STATELESS);
        Map<String, String> values = getVmValuesForMsgResolving();
        // Creating snapshots as sub step of run stateless
        Step createSnapshotsStep = addSubStep(StepEnum.EXECUTING, StepEnum.CREATING_SNAPSHOTS, values);
        // Add the step as the first step of the new context
        ExecutionContext createSnapshotsCtx = new ExecutionContext();
        createSnapshotsCtx.setMonitored(true);
        createSnapshotsCtx.setStep(createSnapshotsStep);
        VdcReturnValueBase vdcReturnValue = getBackend().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, new CommandContext(createSnapshotsCtx, getCompensationContext(), getLock()));
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getParameters().getImagesParameters().add(p);
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (areDisksLocked(vdcReturnValue)) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getvm_name());
        }
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isFailedStatlessSnapshot) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (mResume) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (getParameters() != null && getParameters().getIsInternal()) {
                return getSucceeded() ? AuditLogType.VDS_INITIATED_RUN_VM : AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? (getParameters() != null && getParameters().getDestinationVdsId() == null && getVm().getdedicated_vm_for_vds() != null && !getVm().getrun_on_vds().equals(getVm().getdedicated_vm_for_vds())) ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : AuditLogType.USER_RUN_VM : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isFailedStatlessSnapshot) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (mResume) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (getParameters() != null && getParameters().getIsInternal()) {
                return getSucceeded() ? AuditLogType.VDS_INITIATED_RUN_VM : AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? getParameters() != null && getParameters().getDestinationVdsId() == null && getVm().getdedicated_vm_for_vds() != null && !getVm().getrun_on_vds().equals(getVm().getdedicated_vm_for_vds()) ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : AuditLogType.USER_RUN_VM : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
protected boolean getVdsToRunOn() {
    // use destination vds or default vds or none
    setVdsId(getVdsSelector().getVdsToRunOn());
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.errorFormat("Can't find VDS to run the VM {0} on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error(String.format("VmHandler::%1$s", getClass().getName()), outEx);
        return false;
    }
    return true;
}
#method_after
protected boolean getVdsToRunOn() {
    // use destination vds or default vds or none
    setVdsId(getVdsSelector().getVdsToRunOn(false));
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.errorFormat("Can't find VDS to run the VM {0} on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error(String.format("VmHandler::%1$s", getClass().getName()), outEx);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    setIsVmRunningStateless();
    rollbackQuota();
    if (_isVmRunningStateless) {
        VdcReturnValueBase vdcReturnValue = getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), new CommandContext(getCompensationContext()));
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snpashot.
    } else {
        super.endWithFailure();
    }
}
#method_after
@Override
protected void endWithFailure() {
    setIsVmRunningStateless();
    if (_isVmRunningStateless) {
        VdcReturnValueBase vdcReturnValue = getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), new CommandContext(getCompensationContext()));
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snpashot.
    } else {
        super.endWithFailure();
    }
}
#end_block

#method_before
public static boolean PerformImagesChecks(VM vm, List<String> messages, Guid storagePoolId, Guid storageDomainId, boolean diskSpaceCheck, boolean checkImagesLocked, boolean checkImagesIllegal, boolean checkImagesExist, boolean checkVmInPreview, boolean checkVmIsDown, boolean checkStorageDomain, boolean checkIsValid, Collection diskImageList) {
    boolean returnValue = true;
    boolean isValid = checkIsValid && ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(storagePoolId)).getReturnValue()).booleanValue();
    if (checkIsValid && !isValid) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND.toString());
    }
    List<DiskImage> images = getImages(vm, diskImageList);
    if (returnValue && checkImagesLocked) {
        returnValue = checkImagesLocked(vm, messages, images);
    }
    if (returnValue && checkVmIsDown && vm.getstatus() != VMStatus.Down) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN.toString());
    }
    if (returnValue && checkVmInPreview && isVmInPreview(vm.getId())) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW.toString());
    }
    if (returnValue && isValid) {
        if (images.size() > 0) {
            returnValue = returnValue && checkDiskImages(messages, storagePoolId, storageDomainId, diskSpaceCheck, checkImagesIllegal, checkImagesExist, checkStorageDomain, vm, images);
        } else if (checkImagesExist) {
            returnValue = false;
            ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS.toString());
        }
    }
    return returnValue;
}
#method_after
public static boolean PerformImagesChecks(VM vm, List<String> messages, Guid storagePoolId, Guid storageDomainId, boolean diskSpaceCheck, boolean checkImagesLocked, boolean checkImagesIllegal, boolean checkImagesExist, boolean checkVmInPreview, boolean checkVmIsDown, boolean checkStorageDomain, boolean checkIsValid, Collection diskImageList) {
    boolean returnValue = true;
    ;
    if (checkIsValid) {
        storage_pool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePoolId);
        if (pool == null || pool.getstatus() != StoragePoolStatus.Up) {
            returnValue = false;
            ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND.toString());
        }
    }
    List<DiskImage> images = getImages(vm, diskImageList);
    if (returnValue && checkImagesLocked) {
        returnValue = checkImagesLocked(vm, messages, images);
    }
    if (returnValue && checkVmIsDown && vm.getstatus() != VMStatus.Down) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN.toString());
    }
    if (returnValue && checkVmInPreview && isVmInPreview(vm.getId())) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW.toString());
    }
    if (returnValue && checkIsValid) {
        if (images.size() > 0) {
            returnValue = returnValue && checkDiskImages(messages, storagePoolId, storageDomainId, diskSpaceCheck, checkImagesIllegal, checkImagesExist, checkStorageDomain, vm, images);
        } else if (checkImagesExist) {
            returnValue = false;
            ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS.toString());
        }
    }
    return returnValue;
}
#end_block

#method_before
private static boolean checkImagesLocked(VM vm, List<String> messages, List<DiskImage> images) {
    boolean returnValue = true;
    List<String> lockedDisksAliases = new ArrayList<String>();
    for (DiskImage diskImage : images) {
        if (diskImage.getimageStatus() == ImageStatus.LOCKED) {
            lockedDisksAliases.add(diskImage.getDiskAlias());
            returnValue = false;
        }
    }
    addDiskLockedMessage(lockedDisksAliases, messages);
    if (returnValue && vm.getstatus() == VMStatus.ImageLocked) {
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_LOCKED.toString());
        returnValue = false;
    }
    return returnValue;
}
#method_after
private static boolean checkImagesLocked(VM vm, List<String> messages, List<DiskImage> images) {
    boolean returnValue = true;
    List<String> lockedDisksAliases = new ArrayList<String>();
    for (DiskImage diskImage : images) {
        if (diskImage.getimageStatus() == ImageStatus.LOCKED) {
            lockedDisksAliases.add(diskImage.getDiskAlias());
            returnValue = false;
        }
    }
    if (lockedDisksAliases.size() > 0) {
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED.toString());
        ListUtils.nullSafeAdd(messages, String.format("$%1$s %2$s", "diskAliases", StringUtils.join(lockedDisksAliases, ", ")));
    }
    if (returnValue && vm.getstatus() == VMStatus.ImageLocked) {
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_LOCKED.toString());
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    list.add(new QuotaVdsGroupConsumptionParameter(getParameters().getVmStaticData().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getParameters().getVmStaticData().getvds_group_id(), 0, 0));
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    // The cases must be persistent with the create_functions_sp
    if (getVm().getstatus() == VMStatus.Down || getVm().getstatus() == VMStatus.Suspended || getVm().getstatus() == VMStatus.ImageIllegal || getVm().getstatus() == VMStatus.ImageLocked || getVm().getstatus() == VMStatus.PoweringDown) {
        list.add(new QuotaSanityParameter(getParameters().getVmStaticData().getQuotaId(), null));
    } else {
        if (getParameters().getVmStaticData().getQuotaId() != null && !getParameters().getVmStaticData().getQuotaId().equals(getVm().getQuotaId())) {
            list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getVdsGroupId(), getVm().getvmt_cpu_per_socket() * getVm().getnum_of_sockets(), getVm().getmem_size_mb()));
            list.add(new QuotaVdsGroupConsumptionParameter(getParameters().getVmStaticData().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getParameters().getVmStaticData().getvds_group_id(), getParameters().getVmStaticData().getcpu_per_socket() * getParameters().getVmStaticData().getnum_of_sockets(), getParameters().getVmStaticData().getmem_size_mb()));
        }
    }
    return list;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    // if not runAsStateless
    if (!getParameters().getRunAsStateless()) {
        for (DiskImage image : getVm().getDiskList()) {
            list.add(new QuotaStorageConsumptionParameter(image.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, image.getstorage_ids().get(0), image.getActualSize()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    // if runAsStateless
    if (Boolean.TRUE.equals(getParameters().getRunAsStateless())) {
        for (DiskImage image : getVm().getDiskList()) {
            list.add(new QuotaStorageConsumptionParameter(image.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, image.getstorage_ids().get(0), image.getActualSize()));
        }
    }
    return list;
}
#end_block

#method_before
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getVm().getvds_group_id(), getVm().getcpu_per_socket() * getVm().getnum_of_sockets(), getVm().getmem_size_mb()));
    return list;
}
#method_after
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (getVm().getQuotaId() != null && !Guid.Empty.equals(getVm().getQuotaId()) && (getVm().getstatus() == VMStatus.Up || getVm().getstatus() == VMStatus.Paused || getVm().getstatus() == VMStatus.PoweringUp || getVm().getstatus() == VMStatus.RebootInProgress)) {
        list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getVm().getvds_group_id(), getVm().getcpu_per_socket() * getVm().getnum_of_sockets(), getVm().getmem_size_mb()));
    }
    return list;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    for (DiskImage disk : getVm().getDiskList()) {
        if (disk.getQuotaId() != null) {
            list.add(new QuotaStorageConsumptionParameter(disk.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, disk.getstorage_ids().get(0), (double) disk.getSizeInGigabytes()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    for (DiskImage disk : getVm().getDiskList()) {
        if (disk.getQuotaId() != null && !Guid.Empty.equals(disk.getQuotaId())) {
            list.add(new QuotaStorageConsumptionParameter(disk.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, disk.getstorage_ids().get(0), (double) disk.getSizeInGigabytes()));
        }
    }
    return list;
}
#end_block

#method_before
private void rollbackQuota(Guid storagePoolId, List<Guid> quotaList) {
    lock.writeLock().lock();
    try {
        if (!storagePoolQuotaMap.containsKey(storagePoolId)) {
            return;
        }
        synchronized (storagePoolQuotaMap.get(storagePoolId)) {
            Map<Guid, Quota> map = storagePoolQuotaMap.get(storagePoolId);
            for (Guid quotaId : quotaList) {
                map.remove(quotaId);
            }
        }
    } finally {
        lock.writeLock().unlock();
    }
}
#method_after
public void rollbackQuota(Guid storagePoolId, List<Guid> quotaList) {
    lock.writeLock().lock();
    try {
        if (!storagePoolQuotaMap.containsKey(storagePoolId)) {
            return;
        }
        synchronized (storagePoolQuotaMap.get(storagePoolId)) {
            Map<Guid, Quota> map = storagePoolQuotaMap.get(storagePoolId);
            for (Guid quotaId : quotaList) {
                map.remove(quotaId);
            }
        }
    } finally {
        lock.writeLock().unlock();
    }
}
#end_block

#method_before
public boolean consume(QuotaConsumptionParametersWrapper parameters) throws InvalidQuotaParametersException {
    Pair<AuditLogType, AuditLogableBase> auditLogPair = new Pair<AuditLogType, AuditLogableBase>();
    auditLogPair.setSecond(parameters.getAuditLogable());
    storage_pool storagePool = parameters.getAuditLogable().getStoragePool();
    if (storagePool == null) {
        throw new InvalidQuotaParametersException("Null storage pool passed to QuotaManager");
    }
    lock.writeLock().lock();
    try {
        if (!storagePoolQuotaMap.containsKey(storagePool.getId())) {
            storagePoolQuotaMap.put(storagePool.getId(), new HashMap<Guid, Quota>());
        }
    } finally {
        lock.writeLock().unlock();
    }
    lock.readLock().lock();
    try {
        synchronized (storagePoolQuotaMap.get(storagePool.getId())) {
            if (!validateAndCompleteParameters(parameters, auditLogPair)) {
                throw new InvalidQuotaParametersException();
            }
            return internalConsumeAndReleaseHandler(parameters, auditLogPair);
        }
    } finally {
        lock.readLock().unlock();
        getQuotaManagerAuditLogger().auditLog(auditLogPair.getFirst(), auditLogPair.getSecond());
    }
}
#method_after
public boolean consume(QuotaConsumptionParametersWrapper parameters) throws InvalidQuotaParametersException {
    Pair<AuditLogType, AuditLogableBase> auditLogPair = new Pair<AuditLogType, AuditLogableBase>();
    auditLogPair.setSecond(parameters.getAuditLogable());
    storage_pool storagePool = parameters.getAuditLogable().getStoragePool();
    if (storagePool == null) {
        throw new InvalidQuotaParametersException("Null storage pool passed to QuotaManager");
    }
    lock.writeLock().lock();
    try {
        if (!storagePoolQuotaMap.containsKey(storagePool.getId())) {
            storagePoolQuotaMap.put(storagePool.getId(), new HashMap<Guid, Quota>());
        }
    } finally {
        lock.writeLock().unlock();
    }
    lock.readLock().lock();
    try {
        synchronized (storagePoolQuotaMap.get(storagePool.getId())) {
            return validateAndCompleteParameters(parameters, auditLogPair) && (parameters.getStoragePool().getQuotaEnforcementType() == QuotaEnforcementTypeEnum.DISABLED || internalConsumeAndReleaseHandler(parameters, auditLogPair));
        }
    } finally {
        lock.readLock().unlock();
        getQuotaManagerAuditLogger().auditLog(auditLogPair.getFirst(), auditLogPair.getSecond());
    }
}
#end_block

#method_before
private boolean internalConsumeAndReleaseHandler(QuotaConsumptionParametersWrapper parameters, Pair<AuditLogType, AuditLogableBase> auditLogPair) {
    boolean result = validateAndSetStorageQuotaHelper(parameters, auditLogPair);
    if (result) {
        result = validateAndSetClusterQuota(parameters, auditLogPair);
        if (result) {
            return true;
        } else {
            QuotaConsumptionParametersWrapper revertedParams = revertParametersQuantities(parameters);
            validateAndSetStorageQuotaHelper(revertedParams, auditLogPair);
            validateAndSetClusterQuota(parameters, auditLogPair);
        }
    } else {
        // roll back storage request
        QuotaConsumptionParametersWrapper revertedParams = revertParametersQuantities(parameters);
        validateAndSetStorageQuotaHelper(revertedParams, auditLogPair);
    }
    return result;
}
#method_after
private boolean internalConsumeAndReleaseHandler(QuotaConsumptionParametersWrapper parameters, Pair<AuditLogType, AuditLogableBase> auditLogPair) {
    boolean result = validateAndSetStorageQuotaHelper(parameters, auditLogPair);
    if (result) {
        result = validateAndSetClusterQuota(parameters, auditLogPair);
        if (result) {
            return true;
        } else {
            QuotaConsumptionParametersWrapper revertedParams = revertParametersQuantities(parameters);
            validateAndSetStorageQuotaHelper(revertedParams, auditLogPair);
        }
    }
    return result;
}
#end_block

#method_before
/**
 * Validate parameters. Look for null pointers and missing data Complete the missing data in the parameters from DB
 * and cache all the needed entities.
 *
 * @param parameters
 *            - Quota consumption parameters
 */
private boolean validateAndCompleteParameters(QuotaConsumptionParametersWrapper parameters, Pair<AuditLogType, AuditLogableBase> auditLogPair) throws InvalidQuotaParametersException {
    if (QuotaEnforcementTypeEnum.DISABLED == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType()) {
        return true;
    }
    boolean hardEnforcement = QuotaEnforcementTypeEnum.HARD_ENFORCEMENT == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType();
    // for each parameter - check and complete
    for (QuotaConsumptionParameter param : parameters.getParameters()) {
        // check that quota id is valid and fetch the quota from db (or cache). add the quota to the param
        boolean validQuotaId = checkAndFetchQuota(parameters, param);
        // In case this param is a QuotaVdsConsumptionParameter - check that it has a valid
        // vds group id which is handled by this quota
        boolean validVdsGroup = true;
        if (param instanceof QuotaVdsGroupConsumptionParameter) {
            validVdsGroup = checkVdsGroupMatchQuota(parameters, param);
        }
        // In case this param is a QuotaStorageConsumptionParameter - check that it has a valid
        // storage domain id which is handled by this quota
        boolean validStorageDomain = true;
        if (param instanceof QuotaStorageConsumptionParameter) {
            validStorageDomain = checkStoragePoolMatchQuota(parameters, param);
        }
        if (!validQuotaId || !validVdsGroup || !validStorageDomain) {
            // if in hard enforcement - return false
            if (hardEnforcement) {
                return false;
            } else {
                // otherwise write to auditLog and return true
                auditLogPair.setFirst(AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE);
                // clear any messages written to the canDoActionMessages
                parameters.getCanDoActionMessages().clear();
                return true;
            }
        }
    }
    return true;
}
#method_after
/**
 * Validate parameters. Look for null pointers and missing data Complete the missing data in the parameters from DB
 * and cache all the needed entities.
 *
 * @param parameters
 *            - Quota consumption parameters
 */
private boolean validateAndCompleteParameters(QuotaConsumptionParametersWrapper parameters, Pair<AuditLogType, AuditLogableBase> auditLogPair) throws InvalidQuotaParametersException {
    if (QuotaEnforcementTypeEnum.DISABLED == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType()) {
        return true;
    }
    boolean hardEnforcement = QuotaEnforcementTypeEnum.HARD_ENFORCEMENT == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType();
    // for each parameter - check and complete
    for (QuotaConsumptionParameter param : parameters.getParameters()) {
        // check that quota id is valid and fetch the quota from db (or cache). add the quota to the param
        boolean validQuotaId = checkAndFetchQuota(parameters, param, auditLogPair);
        boolean validVdsGroup = true;
        boolean validStorageDomain = true;
        if (validQuotaId) {
            // vds group id which is handled by this quota
            if (param instanceof QuotaVdsGroupConsumptionParameter) {
                validVdsGroup = checkVdsGroupMatchQuota(parameters, param);
            }
            // storage domain id which is handled by this quota
            if (param instanceof QuotaStorageConsumptionParameter) {
                validStorageDomain = checkStoragePoolMatchQuota(parameters, param);
            }
        }
        if (!validQuotaId || !validVdsGroup || !validStorageDomain) {
            // if in hard enforcement - return false
            if (hardEnforcement) {
                return false;
            } else {
                // clear any messages written to the canDoActionMessages
                parameters.getCanDoActionMessages().clear();
                if (QuotaEnforcementTypeEnum.DISABLED == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType()) {
                    auditLogPair.setFirst(null);
                }
                return true;
            }
        }
    }
    return true;
}
#end_block

#method_before
private boolean checkAndFetchQuota(QuotaConsumptionParametersWrapper parameters, QuotaConsumptionParameter param) throws InvalidQuotaParametersException {
    if (param.getQuotaGuid() == null || Guid.Empty.equals(param.getQuotaGuid())) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
        log.errorFormat("No Quota id passed from command: {0}", parameters.getAuditLogable().getClass().getName());
        return false;
    }
    Quota quota = fetchQuotaFromCache(param.getQuotaGuid(), parameters.getStoragePool().getId());
    if (quota == null) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
        log.errorFormat("The quota id {0} is not found in backend and DB.", param.getQuotaGuid().toString());
        return false;
    } else {
        param.setQuota(quota);
    }
    if (!quota.getStoragePoolId().equals(parameters.getStoragePoolId())) {
        throw new InvalidQuotaParametersException("The Quota storage pool id does not match the passed storage pool");
    }
    return true;
}
#method_after
private boolean checkAndFetchQuota(QuotaConsumptionParametersWrapper parameters, QuotaConsumptionParameter param, Pair<AuditLogType, AuditLogableBase> auditLogPair) throws InvalidQuotaParametersException {
    if (param.getQuotaGuid() == null || Guid.Empty.equals(param.getQuotaGuid())) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        log.errorFormat("No Quota id passed from command: {0}", parameters.getAuditLogable().getClass().getName());
        return false;
    }
    Quota quota = fetchQuotaFromCache(param.getQuotaGuid(), parameters.getStoragePool().getId());
    if (quota == null) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
        auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        log.errorFormat("The quota id {0} is not found in backend and DB.", param.getQuotaGuid().toString());
        return false;
    } else {
        param.setQuota(quota);
    }
    if (!quota.getStoragePoolId().equals(parameters.getStoragePoolId())) {
        throw new InvalidQuotaParametersException("The Quota storage pool id does not match the passed storage pool");
    }
    return true;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (imageTemplates != null) {
        for (DiskImage disk : imageTemplates) {
            if (disk.getQuotaId() != null) {
                list.add(new QuotaStorageConsumptionParameter(disk.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, disk.getstorage_ids().get(0), (double) disk.getSizeInGigabytes()));
            }
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (imageTemplates != null) {
        for (DiskImage disk : imageTemplates) {
            if (disk.getQuotaId() != null && !Guid.Empty.equals(disk.getQuotaId())) {
                list.add(new QuotaStorageConsumptionParameter(disk.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, disk.getstorage_ids().get(0), (double) disk.getSizeInGigabytes()));
            }
        }
    }
    return list;
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollBackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getFactory().createDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getFactory().createDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#end_block

#method_before
private void internalEndWithFailure() {
    log.errorFormat("Ending command with failure: {0}", getClass().getName());
    if (hasTaskHandlers()) {
        getCurrentTaskHandler().endWithFailure();
        revertPreviousHandlers();
        startPollingAsyncTasks();
    } else {
        endWithFailure();
    }
    rollBackQuota();
}
#method_after
private void internalEndWithFailure() {
    log.errorFormat("Ending command with failure: {0}", getClass().getName());
    if (hasTaskHandlers()) {
        getCurrentTaskHandler().endWithFailure();
        revertPreviousHandlers();
        startPollingAsyncTasks();
    } else {
        endWithFailure();
    }
    rollbackQuota();
}
#end_block

#method_before
protected void endWithFailure() {
    setSucceeded(true);
}
#method_after
protected void endWithFailure() {
    setSucceeded(true);
    rollbackQuota();
}
#end_block

#method_before
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (!isInternalExecution() && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            for (QuotaConsumptionParameter parameter : getQuotaConsumptionParameters()) {
                quotaPermissionList.add(new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
            }
        }
    }
}
#method_after
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (!isInternalExecution() && getStoragePool() != null && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            for (QuotaConsumptionParameter parameter : getQuotaConsumptionParameters()) {
                quotaPermissionList.add(new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
            }
        }
    }
}
#end_block

#method_before
@Override
public void rollback() {
    log.errorFormat("Transaction rolled-back for command: {0}.", CommandBase.this.getClass().getName());
    try {
        if (isQuotaDependant()) {
            rollBackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    cancelTasks();
}
#method_after
@Override
public void rollback() {
    log.errorFormat("Transaction rolled-back for command: {0}.", CommandBase.this.getClass().getName());
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    cancelTasks();
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    // TODO: need to be fixed. sp id should be available
    setStoragePoolId(getImagesList().get(0).getstorage_pool_id());
    for (DiskImage image : getImagesList()) {
        if (!image.getImage().isActive()) {
            list.add(new QuotaStorageConsumptionParameter(image.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, image.getstorage_ids().get(0), image.getActualSize()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    // TODO: need to be fixed. sp id should be available
    setStoragePoolId(getImagesList().get(0).getstorage_pool_id());
    for (DiskImage image : getImagesList()) {
        if (!image.getImage().isActive() && image.getQuotaId() != null && !Guid.Empty.equals(image.getQuotaId())) {
            list.add(new QuotaStorageConsumptionParameter(image.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, image.getstorage_ids().get(0), image.getActualSize()));
        }
    }
    return list;
}
#end_block

#method_before
protected boolean validateShareableDisk() {
    if (DiskStorageType.LUN == _oldDisk.getDiskStorageType()) {
        return true;
    }
    boolean isDiskUpdatedToShareable = getParameters().getDiskInfo().isShareable();
    boolean isDiskShareable = _oldDisk.isShareable();
    // Check if VM is not during snapshot.
    if (getSnapshotDao().exists(getVmId(), SnapshotStatus.IN_PREVIEW)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        return false;
    }
    // If user want to update the disk to be shareable then update the vm snapshot id to be null.
    if (!isDiskShareable && isDiskUpdatedToShareable) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(_oldDisk.getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) _oldDisk).getit_guid())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
            return false;
        }
        if (!isVersionSupportedForShareable(_oldDisk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
            return false;
        }
        DiskImage diskImage = (DiskImage) getParameters().getDiskInfo();
        if (!isVolumeFormatSupportedForShareable(diskImage.getvolume_format())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
            return false;
        }
        diskImage.setvm_snapshot_id(null);
    } else if (isDiskShareable && !isDiskUpdatedToShareable) {
        if (getVmDAO().getVmsListForDisk(_oldDisk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
            return false;
        }
        // If disk is not floating, then update its vm snapshot id to the active VM snapshot.
        ((DiskImage) _oldDisk).setvm_snapshot_id(DbFacade.getInstance().getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE).getValue());
    }
    return true;
}
#method_after
protected boolean validateShareableDisk() {
    if (DiskStorageType.LUN == _oldDisk.getDiskStorageType()) {
        return true;
    }
    boolean isDiskUpdatedToShareable = getParameters().getDiskInfo().isShareable();
    boolean isDiskShareable = _oldDisk.isShareable();
    // Check if VM is not during snapshot.
    if (getSnapshotDao().exists(getVmId(), SnapshotStatus.IN_PREVIEW)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        return false;
    }
    if (!isDiskShareable && isDiskUpdatedToShareable) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(_oldDisk.getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) _oldDisk).getit_guid())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
            return false;
        }
        if (!isVersionSupportedForShareable(_oldDisk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
            return false;
        }
        DiskImage diskImage = (DiskImage) getParameters().getDiskInfo();
        if (!isVolumeFormatSupportedForShareable(diskImage.getvolume_format())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
            return false;
        }
        // If user want to update the disk to be shareable then update the vm snapshot id to be null.
        ((DiskImage) _oldDisk).setvm_snapshot_id(null);
    } else if (isDiskShareable && !isDiskUpdatedToShareable) {
        if (getVmDAO().getVmsListForDisk(_oldDisk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
            return false;
        }
        // If disk is not floating, then update its vm snapshot id to the active VM snapshot.
        ((DiskImage) _oldDisk).setvm_snapshot_id(DbFacade.getInstance().getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE).getValue());
    }
    return true;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (isQuotaValidationNeeded()) {
        DiskImage oldDiskImage = (DiskImage) _oldDisk;
        DiskImage newDiskImage = (DiskImage) getParameters().getDiskInfo();
        list.add(new QuotaStorageConsumptionParameter(oldDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, // TODO: Shared Disk?
        oldDiskImage.getstorage_ids().get(0), (double) oldDiskImage.getSizeInGigabytes()));
        list.add(new QuotaStorageConsumptionParameter(newDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, // TODO: Shared Disk?
        newDiskImage.getstorage_ids().get(0), (double) newDiskImage.getSizeInGigabytes()));
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (isQuotaValidationNeeded()) {
        DiskImage oldDiskImage = (DiskImage) _oldDisk;
        DiskImage newDiskImage = (DiskImage) getParameters().getDiskInfo();
        if (oldDiskImage.getQuotaId() == null || !oldDiskImage.getQuotaId().equals(newDiskImage.getQuotaId())) {
            if (oldDiskImage.getQuotaId() != null && !Guid.Empty.equals(oldDiskImage.getQuotaId())) {
                list.add(new QuotaStorageConsumptionParameter(oldDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, // TODO: Shared Disk?
                oldDiskImage.getstorage_ids().get(0), (double) oldDiskImage.getSizeInGigabytes()));
            }
            list.add(new QuotaStorageConsumptionParameter(newDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, // TODO: Shared Disk?
            newDiskImage.getstorage_ids().get(0), (double) newDiskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                    throw e;
                default:
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isFailedStatlessSnapshot) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (mResume) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (getParameters() != null && getParameters().getIsInternal()) {
                return getSucceeded() ? AuditLogType.VDS_INITIATED_RUN_VM : AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? (getParameters() != null && getParameters().getDestinationVdsId() == null && getVm().getdedicated_vm_for_vds() != null && !getVm().getrun_on_vds().equals(getVm().getdedicated_vm_for_vds())) ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : AuditLogType.USER_RUN_VM : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isFailedStatlessSnapshot) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (mResume) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (getParameters() != null && getParameters().getIsInternal()) {
                return getSucceeded() ? AuditLogType.VDS_INITIATED_RUN_VM : AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? getParameters() != null && getParameters().getDestinationVdsId() == null && getVm().getdedicated_vm_for_vds() != null && !getVm().getrun_on_vds().equals(getVm().getdedicated_vm_for_vds()) ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : AuditLogType.USER_RUN_VM : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
private boolean runBootstrapCommand(boolean doFinal) {
    boolean fRes = false;
    String command = _bootstrapCommand.replace("{RunFlag}", doFinal ? "True" : "False");
    if (!doFinal) {
        serverInstallationTime = DateTime.getUtcNow().toString("yyyy-MM-ddTHH:mm:ss");
    } else {
        if (!_rebootAfterInstallation) {
            command = command.replace(" -b ", " ");
        }
    }
    // NOTICE: the time is also used as ticket for registration
    // time will be correct only at !doFinal
    command = command.replace("{utc_time}", serverInstallationTime);
    log.infoFormat("Installation of {0}. Sending SSH Command {1} < {2}. (Stage: {3})", _serverName, command, s_bootstrapPackage.getFileNoUse(), getCurrentInstallStage());
    InputStream in = null;
    try {
        in = new FileInputStream(s_bootstrapPackage.getFile());
        fRes = _wrapper.executeCommand(command, in);
    } catch (Exception e) {
        log.error("Error during executing bootstrap", e);
    } finally {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close bootstrap file", e);
            }
        }
    }
    log.infoFormat("Script ended, result is {1}", fRes ? "Success" : "Failed");
    return fRes;
}
#method_after
private boolean runBootstrapCommand(boolean doFinal) {
    boolean fRes = false;
    String command = _bootstrapCommand.replace("{RunFlag}", doFinal ? "True" : "False");
    if (!doFinal) {
        serverInstallationTime = DateTime.getUtcNow().toString("yyyy-MM-ddTHH:mm:ss");
    } else {
        if (!_rebootAfterInstallation) {
            command = command.replace(" -b ", " ");
        }
    }
    // NOTICE: the time is also used as ticket for registration
    // time will be correct only at !doFinal
    command = command.replace("{utc_time}", serverInstallationTime);
    log.infoFormat("Installation of {0}. Sending SSH Command {1} < {2}. (Stage: {3})", _serverName, command, s_bootstrapPackage.getFileNoUse(), getCurrentInstallStage());
    InputStream in = null;
    try {
        in = new FileInputStream(s_bootstrapPackage.getFile());
        fRes = _wrapper.executeCommand(command, in);
    } catch (Exception e) {
        log.error("Error during executing bootstrap", e);
    } finally {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close bootstrap file", e);
            }
        }
    }
    log.infoFormat("Script ended, result is {0}", fRes ? "Success" : "Failed");
    return fRes;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    setVdsGroupId(getParameters().getVdsStaticData().getvds_group_id());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        returnValue = false;
    } else {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getvds_name();
        String hostName = vds.gethost_name();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
            returnValue = false;
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
            returnValue = false;
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
            returnValue = false;
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers) && !FileUtil.fileExists(Config.resolveCertificatePath())) {
                addCanDoActionMessage(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
                returnValue = false;
            } else if (!getParameters().getAddPending() && StringUtils.isEmpty(getParameters().getRootPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
                returnValue = false;
            } else if (!IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else if (getParameters().getVdsStaticData().getport() < 1 || getParameters().getVdsStaticData().getport() > 65536) {
                addCanDoActionMessage(VdcBllMessages.VDS_PORT_IS_NOT_LEGAL);
                returnValue = false;
            } else if (!validateHostUniqueNameAndAddress(getParameters().getVdsStaticData())) {
                returnValue = false;
            } else {
                returnValue = returnValue && canConnect(vds);
            }
        }
    }
    if (isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            upServer = ClusterUtils.getInstance().getUpServer(getVdsGroupId());
            if (upServer == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    setVdsGroupId(getParameters().getVdsStaticData().getvds_group_id());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        returnValue = false;
    } else {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getvds_name();
        String hostName = vds.gethost_name();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
            returnValue = false;
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
            returnValue = false;
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
            returnValue = false;
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers) && !FileUtil.fileExists(Config.resolveCertificatePath())) {
                addCanDoActionMessage(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
                returnValue = false;
            } else if (!getParameters().getAddPending() && StringUtils.isEmpty(getParameters().getRootPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
                returnValue = false;
            } else if (!IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else {
                returnValue = returnValue && canConnect(vds);
            }
        }
    }
    if (isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            upServer = ClusterUtils.getInstance().getUpServer(getVdsGroupId());
            if (upServer == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    }
    return returnValue;
}
#end_block

#method_before
private boolean canConnect(VDS vds) {
    boolean returnValue = true;
    // execute the connectivity and id uniqueness validation for VDS type hosts
    if (vds.getvds_type() == VDSType.VDS && Config.<Boolean>GetValue(ConfigValues.InstallVds)) {
        SSHClient sshclient = null;
        try {
            Long timeout = TimeUnit.SECONDS.toMillis(Config.<Integer>GetValue(ConfigValues.ConnectToServerTimeoutInSeconds));
            sshclient = getSSHClient();
            sshclient.setHardTimeout(timeout);
            sshclient.setSoftTimeout(timeout);
            sshclient.setHost(vds.gethost_name());
            sshclient.setUser("root");
            sshclient.setPassword(getParameters().getRootPassword());
            sshclient.connect();
            sshclient.authenticate();
        } catch (Exception e) {
            log.errorFormat("Failed to establish session with host {0}", vds.getvds_name(), e);
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_CONNECT_TO_SERVER);
            returnValue = false;
        } finally {
            if (sshclient != null) {
                sshclient.disconnect();
            }
        }
    }
    return returnValue;
}
#method_after
private boolean canConnect(VDS vds) {
    boolean returnValue = true;
    // execute the connectivity and id uniqueness validation for VDS type hosts
    if (vds.getvds_type() == VDSType.VDS && Config.<Boolean>GetValue(ConfigValues.InstallVds)) {
        SSHClient sshclient = null;
        try {
            Long timeout = TimeUnit.SECONDS.toMillis(Config.<Integer>GetValue(ConfigValues.ConnectToServerTimeoutInSeconds));
            sshclient = getSSHClient();
            sshclient.setHardTimeout(timeout);
            sshclient.setSoftTimeout(timeout);
            sshclient.setHost(vds.gethost_name());
            sshclient.setUser(USER_NAME);
            sshclient.setPassword(getParameters().getRootPassword());
            sshclient.connect();
            sshclient.authenticate();
        } catch (Exception e) {
            log.errorFormat("Failed to establish session with host {0}", vds.getvds_name(), e);
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_CONNECT_TO_SERVER);
            returnValue = false;
        } finally {
            if (sshclient != null) {
                sshclient.disconnect();
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
private void mockSSHClient() {
    try {
        doNothing().when(sshclient).connect();
        doNothing().when(sshclient).authenticate();
    } catch (Exception e) {
    }
}
#method_after
private void mockSSHClient() {
    try {
        doNothing().when(sshclient).connect();
        doNothing().when(sshclient).authenticate();
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
private boolean runBootstrapCommand(boolean doFinal) {
    boolean fRes = false;
    String command = _bootstrapCommand.replace("{RunFlag}", doFinal ? "True" : "False");
    if (!doFinal) {
        serverInstallationTime = DateTime.getUtcNow().toString("yyyy-MM-ddTHH:mm:ss");
    } else {
        if (!_rebootAfterInstallation) {
            command = command.replace(" -b ", " ");
        }
    }
    // NOTICE: the time is also used as ticket for registration
    // time will be correct only at !doFinal
    command = command.replace("{utc_time}", serverInstallationTime);
    log.infoFormat("Installation of {0}. Sending SSH Command {1} < {2}. (Stage: {3})", _serverName, command, s_bootstrapPackage.getFileNoUse(), getCurrentInstallStage());
    InputStream in = null;
    try {
        in = new FileInputStream(s_bootstrapPackage.getFile());
        fRes = _wrapper.executeCommand(command, in);
    } catch (Exception e) {
        log.error("Error during executing bootstrap", e);
    } finally {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close bootstrap file", e);
            }
        }
    }
    log.infoFormat("Script ended, result is {1}", fRes ? "Success" : "Failed");
    return fRes;
}
#method_after
private boolean runBootstrapCommand(boolean doFinal) {
    boolean fRes = false;
    String command = _bootstrapCommand.replace("{RunFlag}", doFinal ? "True" : "False");
    if (!doFinal) {
        serverInstallationTime = DateTime.getUtcNow().toString("yyyy-MM-ddTHH:mm:ss");
    } else {
        if (!_rebootAfterInstallation) {
            command = command.replace(" -b ", " ");
        }
    }
    // NOTICE: the time is also used as ticket for registration
    // time will be correct only at !doFinal
    command = command.replace("{utc_time}", serverInstallationTime);
    log.infoFormat("Installation of {0}. Sending SSH Command {1} < {2}. (Stage: {3})", _serverName, command, s_bootstrapPackage.getFileNoUse(), getCurrentInstallStage());
    InputStream in = null;
    try {
        in = new FileInputStream(s_bootstrapPackage.getFile());
        fRes = _wrapper.executeCommand(command, in);
    } catch (Exception e) {
        log.error("Error during executing bootstrap", e);
    } finally {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close bootstrap file", e);
            }
        }
    }
    log.infoFormat("Script ended, result is {0}", fRes ? "Success" : "Failed");
    return fRes;
}
#end_block

#method_before
public static String SignCertificateRequest(String request, String label) throws FileNotFoundException, UnsupportedEncodingException, IOException {
    File pkicertdir = new File(Config.resolveCABasePath(), "certs");
    File pkireqdir = new File(Config.resolveCABasePath(), "requests");
    String reqFileName = String.format("%1$sreq.pem", label);
    String certFileName = String.format("%1$scert.pem", label);
    OutputStream os = null;
    try {
        os = new FileOutputStream(new File(pkireqdir, reqFileName));
        os.write(request.getBytes("UTF-8"));
    } finally {
        if (os == null) {
            try {
                os.close();
            } catch (IOException e) {
                log.error("error during close", e);
            }
        }
    }
    if (!new OpenSslCAWrapper().SignCertificateRequest(reqFileName, Config.<Integer>GetValue(ConfigValues.VdsCertificateValidityInYears) * 365, certFileName)) {
        throw new RuntimeException("Certificate enrollment failed");
    }
    return FileUtil.readAllText(new File(pkicertdir, certFileName).getPath());
}
#method_after
public static String SignCertificateRequest(String request, String label) throws IOException {
    File pkicertdir = new File(Config.resolveCABasePath(), "certs");
    File pkireqdir = new File(Config.resolveCABasePath(), "requests");
    String reqFileName = String.format("%1$sreq.pem", label);
    String certFileName = String.format("%1$scert.pem", label);
    OutputStream os = null;
    try {
        os = new FileOutputStream(new File(pkireqdir, reqFileName));
        os.write(request.getBytes("UTF-8"));
    } finally {
        if (os != null) {
            try {
                os.close();
            } catch (IOException e) {
                log.error("error during close", e);
            }
        }
    }
    if (!new OpenSslCAWrapper().SignCertificateRequest(reqFileName, Config.<Integer>GetValue(ConfigValues.VdsCertificateValidityInYears) * 365, certFileName)) {
        throw new RuntimeException("Certificate enrollment failed");
    }
    return FileUtil.readAllText(new File(pkicertdir, certFileName).getPath());
}
#end_block

#method_before
private boolean runBootstrapCommand(boolean doFinal) {
    boolean fRes = false;
    String command = _bootstrapCommand.replace("{RunFlag}", doFinal ? "True" : "False");
    if (!doFinal) {
        serverInstallationTime = DateTime.getUtcNow().toString("yyyy-MM-ddTHH:mm:ss");
    } else {
        if (!_rebootAfterInstallation) {
            command = command.replace(" -b ", " ");
        }
    }
    // NOTICE: the time is also used as ticket for registration
    // time will be correct only at !doFinal
    command = command.replace("{utc_time}", serverInstallationTime);
    log.infoFormat("Installation of {0}. Sending SSH Command {1} < {2}. (Stage: {3})", _serverName, command, s_bootstrapPackage.getFileNoUse(), getCurrentInstallStage());
    InputStream in = null;
    try {
        in = new FileInputStream(s_bootstrapPackage.getFile());
        fRes = _wrapper.executeCommand(command, in);
    } catch (Exception e) {
        log.error("Error during executing bootstrap", e);
    } finally {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close bootstrap file", e);
            }
        }
    }
    log.infoFormat("Script ended, result is {1}", fRes ? "Success" : "Failed");
    return fRes;
}
#method_after
private boolean runBootstrapCommand(boolean doFinal) {
    boolean fRes = false;
    String command = _bootstrapCommand.replace("{RunFlag}", doFinal ? "True" : "False");
    if (!doFinal) {
        serverInstallationTime = DateTime.getUtcNow().toString("yyyy-MM-ddTHH:mm:ss");
    } else {
        if (!_rebootAfterInstallation) {
            command = command.replace(" -b ", " ");
        }
    }
    // NOTICE: the time is also used as ticket for registration
    // time will be correct only at !doFinal
    command = command.replace("{utc_time}", serverInstallationTime);
    log.infoFormat("Installation of {0}. Sending SSH Command {1} < {2}. (Stage: {3})", _serverName, command, s_bootstrapPackage.getFileNoUse(), getCurrentInstallStage());
    InputStream in = null;
    try {
        in = new FileInputStream(s_bootstrapPackage.getFile());
        fRes = _wrapper.executeCommand(command, in);
    } catch (Exception e) {
        log.error("Error during executing bootstrap", e);
    } finally {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close bootstrap file", e);
            }
        }
    }
    log.infoFormat("Script ended, result is {0}", fRes ? "Success" : "Failed");
    return fRes;
}
#end_block

#method_before
public static String SignCertificateRequest(String request, String label, String hostname) throws IOException {
    File pkicertdir = new File(Config.resolveCABasePath(), "certs");
    File pkireqdir = new File(Config.resolveCABasePath(), "requests");
    String reqFileName = String.format("%1$sreq.pem", label);
    String certFileName = String.format("%1$scert.pem", label);
    OutputStream os = null;
    try {
        os = new FileOutputStream(new File(pkireqdir, reqFileName));
        os.write(request.getBytes("UTF-8"));
    } finally {
        if (os == null) {
            try {
                os.close();
            } catch (IOException e) {
                log.error("error during close", e);
            }
        }
    }
    if (!new OpenSslCAWrapper().SignCertificateRequest(reqFileName, hostname, Config.<Integer>GetValue(ConfigValues.VdsCertificateValidityInYears) * 365, certFileName)) {
        throw new RuntimeException("Certificate enrollment failed");
    }
    return FileUtil.readAllText(new File(pkicertdir, certFileName).getPath());
}
#method_after
public static String SignCertificateRequest(String request, String label, String hostname) throws IOException {
    File pkicertdir = new File(Config.resolveCABasePath(), "certs");
    File pkireqdir = new File(Config.resolveCABasePath(), "requests");
    String reqFileName = String.format("%1$sreq.pem", label);
    String certFileName = String.format("%1$scert.pem", label);
    OutputStream os = null;
    try {
        os = new FileOutputStream(new File(pkireqdir, reqFileName));
        os.write(request.getBytes("UTF-8"));
    } finally {
        if (os != null) {
            try {
                os.close();
            } catch (IOException e) {
                log.error("error during close", e);
            }
        }
    }
    if (!new OpenSslCAWrapper().SignCertificateRequest(reqFileName, hostname, Config.<Integer>GetValue(ConfigValues.VdsCertificateValidityInYears) * 365, certFileName)) {
        throw new RuntimeException("Certificate enrollment failed");
    }
    return FileUtil.readAllText(new File(pkicertdir, certFileName).getPath());
}
#end_block

#method_before
public boolean AddMessage(String message) {
    boolean error = false;
    if (StringUtils.isEmpty(message)) {
        return error;
    }
    String[] msgs = message.split("[\\n]", -1);
    if (msgs.length > 1) {
        for (String msg : msgs) {
            error = AddMessage(msg) || error;
        }
        return error;
    }
    if (StringUtils.isNotEmpty(message)) {
        if (message.charAt(0) == '<') {
            try {
                error = parseMessage(message);
            } catch (RuntimeException e) {
                log.errorFormat("Installation of Host. Received illegal XML from Host. Message: {1}, Exception: {2}", message, e.toString());
            }
        } else {
            log.info("VDS message: " + message);
        }
    }
    return error;
}
#method_after
public boolean AddMessage(String message) {
    boolean error = false;
    if (StringUtils.isEmpty(message)) {
        return error;
    }
    String[] msgs = message.split("[\\n]", -1);
    if (msgs.length > 1) {
        for (String msg : msgs) {
            error = AddMessage(msg) || error;
        }
        return error;
    }
    if (StringUtils.isNotEmpty(message)) {
        if (message.charAt(0) == '<') {
            try {
                error = parseMessage(message);
            } catch (RuntimeException e) {
                error = true;
                log.errorFormat("Installation of Host. Received illegal XML from Host. Message: {0}", message, e);
            }
        } else {
            log.info("VDS message: " + message);
        }
    }
    return error;
}
#end_block

#method_before
private boolean parseMessage(String message) {
    boolean error = false;
    XmlDocument doc = new XmlDocument();
    doc.LoadXml(message);
    XmlNode node = doc.ChildNodes[0];
    if (node != null) {
        StringBuilder sb = new StringBuilder();
        // check status
        AuditLogType logType;
        if (node.Attributes.get("status") == null) {
            logType = AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING;
        } else if (node.Attributes.get("status").getValue().equals("OK")) {
            logType = AuditLogType.VDS_INSTALL_IN_PROGRESS;
        } else if (node.Attributes.get("status").getValue().equals("WARN")) {
            logType = AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING;
        } else {
            error = true;
            logType = AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR;
        }
        if ((node.Attributes.get("component") != null) && (StringUtils.isNotEmpty(node.Attributes.get("component").getValue()))) {
            sb.append("Step: " + node.Attributes.get("component").getValue());
        }
        if ((node.Attributes.get("message") != null) && (StringUtils.isNotEmpty(node.Attributes.get("message").getValue()))) {
            sb.append("; ");
            sb.append("Details: " + node.Attributes.get("message").getValue());
            sb.append(" ");
        }
        if ((node.Attributes.get("result") != null) && (StringUtils.isNotEmpty(node.Attributes.get("result").getValue()))) {
            sb.append(" (" + node.Attributes.get("result").getValue() + ")");
        }
        AuditLogableBase logable = new AuditLogableBase(_vdsId);
        logable.AddCustomValue("Message", StringUtils.stripEnd(sb.toString(), " "));
        AuditLogDirector.log(logable, logType);
        return error;
    }
    return error;
}
#method_after
private boolean parseMessage(String message) {
    boolean error = false;
    XmlDocument doc = new XmlDocument();
    doc.LoadXml(message);
    XmlNode node = doc.ChildNodes[0];
    if (node != null) {
        StringBuilder sb = new StringBuilder();
        // check status
        AuditLogType logType;
        if (node.Attributes.get("status") == null) {
            logType = AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING;
        } else if (node.Attributes.get("status").getValue().equals("OK")) {
            logType = AuditLogType.VDS_INSTALL_IN_PROGRESS;
        } else if (node.Attributes.get("status").getValue().equals("WARN")) {
            logType = AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING;
        } else {
            error = true;
            logType = AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR;
        }
        if ((node.Attributes.get("component") != null) && (StringUtils.isNotEmpty(node.Attributes.get("component").getValue()))) {
            sb.append("Step: " + node.Attributes.get("component").getValue());
        }
        if ((node.Attributes.get("message") != null) && (StringUtils.isNotEmpty(node.Attributes.get("message").getValue()))) {
            sb.append("; ");
            sb.append("Details: " + node.Attributes.get("message").getValue());
            sb.append(" ");
        }
        if ((node.Attributes.get("result") != null) && (StringUtils.isNotEmpty(node.Attributes.get("result").getValue()))) {
            sb.append(" (" + node.Attributes.get("result").getValue() + ")");
        }
        AuditLogableBase logable = new AuditLogableBase(_vdsId);
        logable.AddCustomValue("Message", StringUtils.stripEnd(sb.toString(), " "));
        AuditLogDirector.log(logable, logType);
    }
    return error;
}
#end_block

#method_before
private void SplitSearchString(String source, RefObject<String> prefix, RefObject<String> search) {
    ArrayList<TagModel> tags = (ArrayList<TagModel>) getTagList().getSelectedItems();
    SystemTreeItemModel model = (SystemTreeItemModel) getSystemTree().getSelectedItem();
    // $NON-NLS-1$
    prefix.argvalue = "";
    // Split for tags.
    if (tags != null && tags.size() > 0) {
        // $NON-NLS-1$
        Regex regex = new Regex("tag\\s*=\\s*(?:[\\w-]+)(?:\\sor\\s)?", RegexOptions.IgnoreCase);
        // $NON-NLS-1$
        String[] array = source.split("[:]", -1);
        String entityClause = array[0];
        String searchClause = array[1];
        // $NON-NLS-1$
        String tagsClause = "";
        for (TagModel tag : tags) {
            // $NON-NLS-1$
            tagsClause += ("tag=" + tag.getName().getEntity());
            if (tag != tags.get(tags.size() - 1)) {
                // $NON-NLS-1$
                tagsClause += " or ";
            }
        }
        // $NON-NLS-1$
        prefix.argvalue = StringFormat.format("%1$s: %2$s ", entityClause, tagsClause);
        // $NON-NLS-1$
        search.argvalue = regex.replace(searchClause, "").trim();
    } else // Split for system tree.
    if (model != null && model.getType() != SystemTreeItemType.System) {
        // $NON-NLS-1$ //$NON-NLS-2$
        getAutoCompleteModel().setFilter(new String[] { "or", "and" });
        switch(model.getType()) {
            case DataCenter:
                {
                    if (dataCenterList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("DataCenter: name = %1$s", model.getTitle());
                    } else if (clusterList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Cluster: datacenter.name = %1$s", model.getTitle());
                    } else if (hostList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Host: datacenter = %1$s", model.getTitle());
                    } else if (storageList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Storage: datacenter = %1$s", model.getTitle());
                    } else if (vmList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Vms: datacenter = %1$s", model.getTitle());
                    } else if (templateList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Template: datacenter = %1$s", model.getTitle());
                    } else if (eventList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Events: event_datacenter = %1$s", model.getTitle());
                    } else if (diskList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Disk: datacenter.name = %1$s and disk_type = image", model.getTitle());
                    } else if (quotaList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Quota: storagepoolname = %1$s", model.getTitle());
                    } else if (networkList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Network: datacenter = %1$s", model.getTitle());
                    }
                }
                break;
            case Clusters:
                {
                    if (clusterList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Cluster: datacenter.name = %1$s", model.getParent().getTitle());
                    }
                }
                break;
            case Cluster:
            case Cluster_Gluster:
                {
                    if (clusterList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Cluster: name = %1$s", model.getTitle());
                    } else if (hostList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Host: cluster = %1$s", model.getTitle());
                    } else if (volumeList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Volume: cluster = %1$s", model.getTitle());
                    } else if (storageList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Storage: cluster.name = %1$s", model.getTitle());
                    } else if (vmList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Vms: cluster = %1$s", model.getTitle());
                    } else if (templateList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Template: cluster = %1$s", model.getTitle());
                    } else if (eventList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Events: cluster = %1$s", model.getTitle());
                    } else if (networkList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Network: Cluster_network.cluster_name = %1$s", model.getTitle());
                    }
                }
                break;
            case Hosts:
                {
                    if (hostList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Host: cluster = %1$s", model.getParent().getTitle());
                    }
                }
                break;
            case Host:
                {
                    if (hostList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Host: name = %1$s", model.getTitle());
                    } else if (storageList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Storage: host.name = %1$s", model.getTitle());
                    } else if (vmList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Vms: Hosts.name = %1$s", model.getTitle());
                    } else if (templateList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Template: Hosts.name = %1$s", model.getTitle());
                    } else if (eventList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Events: host.name = %1$s", model.getTitle());
                    } else if (networkList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Network: host = %1$s", model.getTitle());
                    }
                }
                break;
            case Volumes:
                {
                    if (volumeList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Volume: cluster = %1$s", model.getParent().getTitle());
                    }
                }
                break;
            case Volume:
                {
                    if (volumeList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Volume: name = %1$s", model.getTitle());
                    } else if (clusterList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Cluster: volume.name = %1$s", model.getTitle());
                    } else if (dataCenterList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("DataCenter: volume.name = %1$s", model.getTitle());
                    } else if (templateList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Template: Volumes.name = %1$s", model.getTitle());
                    } else if (eventList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Events: volume.name = %1$s", model.getTitle());
                    }
                }
                break;
            case Storages:
                {
                    if (storageList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Storage: datacenter = %1$s", model.getParent().getTitle());
                    }
                }
                break;
            case Storage:
                {
                    if (dataCenterList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("DataCenter: storage.name = %1$s", model.getTitle());
                    } else if (clusterList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Cluster: storage.name = %1$s", model.getTitle());
                    } else if (hostList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Host: storage.name = %1$s", model.getTitle());
                    } else if (storageList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Storage: name = %1$s", model.getTitle());
                    } else if (vmList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Vms: storage.name = %1$s", model.getTitle());
                    } else if (templateList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Templates: storage.name = %1$s", model.getTitle());
                    } else if (eventList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Events: event_storage = %1$s", model.getTitle());
                    } else if (diskList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Disk: storages.name = %1$s", model.getTitle());
                    }
                }
                break;
            case Templates:
                {
                    if (templateList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Template: datacenter = %1$s", model.getParent().getTitle());
                    }
                }
                break;
            case VMs:
                {
                    if (vmList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Vms: cluster = %1$s", model.getParent().getTitle());
                    }
                }
                break;
            case Networks:
                {
                    if (networkList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Network: datacenter = %1$s", model.getParent().getTitle());
                    }
                }
                break;
            case Network:
                {
                    if (networkList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Network: name = %1$s datacenter = %2$s", model.getTitle(), model.getParent().getTitle());
                    } else if (clusterList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Cluster: Cluster_network.network_name = %1$s Datacenter.name = %2$s", model.getTitle(), model.getParent().getTitle());
                    } else if (hostList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Host : Nic.network_name = %1$s datacenter = %2$s", model.getTitle(), model.getParent().getTitle());
                    } else if (vmList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Vm : Vnic.network_name = %1$s datacenter = %2$s", model.getTitle(), model.getParent().getTitle());
                    } else if (templateList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Template : Vnic.network_name = %1$s datacenter = %2$s", model.getTitle(), model.getParent().getTitle());
                    }
                }
                break;
        }
        // $NON-NLS-1$
        prefix.argvalue = prefix.argvalue + " ";
        // $NON-NLS-1$
        search.argvalue = "";
    } else {
        search.argvalue = source;
        getAutoCompleteModel().setFilter(null);
    }
}
#method_after
private void SplitSearchString(String source, RefObject<String> prefix, RefObject<String> search) {
    ArrayList<TagModel> tags = (ArrayList<TagModel>) getTagList().getSelectedItems();
    SystemTreeItemModel model = (SystemTreeItemModel) getSystemTree().getSelectedItem();
    // $NON-NLS-1$
    prefix.argvalue = "";
    // Split for tags.
    if (tags != null && tags.size() > 0) {
        // $NON-NLS-1$
        Regex regex = new Regex("tag\\s*=\\s*(?:[\\w-]+)(?:\\sor\\s)?", RegexOptions.IgnoreCase);
        // $NON-NLS-1$
        String[] array = source.split("[:]", -1);
        String entityClause = array[0];
        String searchClause = array[1];
        // $NON-NLS-1$
        String tagsClause = "";
        for (TagModel tag : tags) {
            // $NON-NLS-1$
            tagsClause += ("tag=" + tag.getName().getEntity());
            if (tag != tags.get(tags.size() - 1)) {
                // $NON-NLS-1$
                tagsClause += " or ";
            }
        }
        // $NON-NLS-1$
        prefix.argvalue = StringFormat.format("%1$s: %2$s ", entityClause, tagsClause);
        // $NON-NLS-1$
        search.argvalue = regex.replace(searchClause, "").trim();
    } else // Split for system tree.
    if (model != null && model.getType() != SystemTreeItemType.System) {
        // $NON-NLS-1$ //$NON-NLS-2$
        getAutoCompleteModel().setFilter(new String[] { "or", "and" });
        switch(model.getType()) {
            case DataCenter:
                {
                    if (dataCenterList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("DataCenter: name = %1$s", model.getTitle());
                    } else if (clusterList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Cluster: datacenter.name = %1$s", model.getTitle());
                    } else if (hostList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Host: datacenter = %1$s", model.getTitle());
                    } else if (storageList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Storage: datacenter = %1$s", model.getTitle());
                    } else if (vmList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Vms: datacenter = %1$s", model.getTitle());
                    } else if (templateList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Template: datacenter = %1$s", model.getTitle());
                    } else if (eventList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Events: event_datacenter = %1$s", model.getTitle());
                    } else if (diskList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Disk: datacenter.name = %1$s and disk_type = image", model.getTitle());
                    } else if (quotaList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Quota: storagepoolname = %1$s", model.getTitle());
                    } else if (networkList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Network: datacenter = %1$s", model.getTitle());
                    }
                }
                break;
            case Clusters:
                {
                    if (clusterList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Cluster: datacenter.name = %1$s", model.getParent().getTitle());
                    }
                }
                break;
            case Cluster:
            case Cluster_Gluster:
                {
                    if (clusterList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Cluster: name = %1$s", model.getTitle());
                    } else if (hostList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Host: cluster = %1$s", model.getTitle());
                    } else if (volumeList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Volume: cluster = %1$s", model.getTitle());
                    } else if (storageList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Storage: cluster.name = %1$s", model.getTitle());
                    } else if (vmList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Vms: cluster = %1$s", model.getTitle());
                    } else if (templateList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Template: cluster = %1$s", model.getTitle());
                    } else if (eventList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Events: cluster = %1$s", model.getTitle());
                    } else if (networkList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Network: Cluster_network.cluster_name = %1$s", model.getTitle());
                    }
                }
                break;
            case Hosts:
                {
                    if (hostList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Host: cluster = %1$s", model.getParent().getTitle());
                    }
                }
                break;
            case Host:
                {
                    if (hostList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Host: name = %1$s", model.getTitle());
                    } else if (storageList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Storage: host.name = %1$s", model.getTitle());
                    } else if (vmList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Vms: Hosts.name = %1$s", model.getTitle());
                    } else if (templateList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Template: Hosts.name = %1$s", model.getTitle());
                    } else if (eventList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Events: host.name = %1$s", model.getTitle());
                    } else if (networkList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Network: Host_network.host_name = %1$s", model.getTitle());
                    }
                }
                break;
            case Volumes:
                {
                    if (volumeList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Volume: cluster = %1$s", model.getParent().getTitle());
                    }
                }
                break;
            case Volume:
                {
                    if (volumeList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Volume: name = %1$s", model.getTitle());
                    } else if (clusterList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Cluster: volume.name = %1$s", model.getTitle());
                    } else if (dataCenterList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("DataCenter: volume.name = %1$s", model.getTitle());
                    } else if (templateList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Template: Volumes.name = %1$s", model.getTitle());
                    } else if (eventList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Events: volume.name = %1$s", model.getTitle());
                    }
                }
                break;
            case Storages:
                {
                    if (storageList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Storage: datacenter = %1$s", model.getParent().getTitle());
                    }
                }
                break;
            case Storage:
                {
                    if (dataCenterList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("DataCenter: storage.name = %1$s", model.getTitle());
                    } else if (clusterList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Cluster: storage.name = %1$s", model.getTitle());
                    } else if (hostList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Host: storage.name = %1$s", model.getTitle());
                    } else if (storageList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Storage: name = %1$s", model.getTitle());
                    } else if (vmList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Vms: storage.name = %1$s", model.getTitle());
                    } else if (templateList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Templates: storage.name = %1$s", model.getTitle());
                    } else if (eventList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Events: event_storage = %1$s", model.getTitle());
                    } else if (diskList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Disk: storages.name = %1$s", model.getTitle());
                    }
                }
                break;
            case Templates:
                {
                    if (templateList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Template: datacenter = %1$s", model.getParent().getTitle());
                    }
                }
                break;
            case VMs:
                {
                    if (vmList.IsSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = StringFormat.format("Vms: cluster = %1$s", model.getParent().getTitle());
                    }
                }
                break;
            case Networks:
                {
                    if (networkList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Network: datacenter = %1$s", model.getParent().getTitle());
                    }
                }
                break;
            case Network:
                {
                    if (networkList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Network: name = %1$s datacenter = %2$s", model.getTitle(), model.getParent().getTitle());
                    } else if (clusterList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Cluster: Cluster_network.network_name = %1$s Datacenter.name = %2$s", model.getTitle(), model.getParent().getTitle());
                    } else if (hostList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Host : Nic.network_name = %1$s datacenter = %2$s", model.getTitle(), model.getParent().getTitle());
                    } else if (vmList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Vm : Vnic.network_name = %1$s datacenter = %2$s", model.getTitle(), model.getParent().getTitle());
                    } else if (templateList.IsSearchStringMatch(source)) {
                        prefix.argvalue = // $NON-NLS-1$
                        StringFormat.format("Template : Vnic.network_name = %1$s datacenter = %2$s", model.getTitle(), model.getParent().getTitle());
                    }
                }
                break;
        }
        // $NON-NLS-1$
        prefix.argvalue = prefix.argvalue + " ";
        // $NON-NLS-1$
        search.argvalue = "";
    } else {
        search.argvalue = source;
        getAutoCompleteModel().setFilter(null);
    }
}
#end_block

#method_before
@Override
public void rerun() {
    Guid vdsId = getDestinationVds() != null ? getDestinationVds().getId() : getCurrentVdsId();
    decreasePendingVms(vdsId);
    setSucceeded(false);
    setVm(null);
    // by default, if rerun is called then rerun process is about to start so log the result of the
    // previous run as if rerun is about to begin (and change it later in case rerun isn't going to happen)
    _isRerun = true;
    log();
    /**
     * Rerun VM only if not exceeded maximum rerun attempts. for example if there are 10 hosts that can run VM and
     * predefine maximum 3 attempts to rerun VM - on 4th turn vm will stop to run despite there are still available
     * hosts to run it DO NOT TRY TO RERUN IF RESUME FAILED.
     */
    if (getRunVdssList().size() < Config.<Integer>GetValue(ConfigValues.MaxRerunVmOnVdsCount) && getVm().getstatus() != VMStatus.Paused) {
        // restore CanDoAction value to false so CanDoAction checks will run again
        getReturnValue().setCanDoAction(false);
        if (getExecutionContext() != null) {
            Job job = getExecutionContext().getJob();
            if (job != null) {
                // mark previous steps as fail
                JobRepositoryFactory.getJobRepository().closeCompletedJobSteps(job.getId(), JobExecutionStatus.FAILED);
            }
        }
        // set the _isRerun flag to false before calling executeAction to that we'll know if
        // there is another rerun attempt within the method
        _isRerun = false;
        executeAction();
        // wasn't done because canDoAction check returned false..
        if (!_isRerun && !getReturnValue().getCanDoAction()) {
            log();
            failedToRunVm();
        }
        // signal the caller that a rerun was made
        _isRerun = true;
    } else {
        Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(getVmId());
        failedToRunVm();
        _isRerun = false;
        log();
    }
}
#method_after
@Override
public void rerun() {
    Guid vdsId = getDestinationVds() != null ? getDestinationVds().getId() : getCurrentVdsId();
    decreasePendingVms(vdsId);
    setSucceeded(false);
    setVm(null);
    // by default, if rerun is called then rerun process is about to start so log the result of the
    // previous run as if rerun is about to begin (and change it later in case rerun isn't going to happen)
    _isRerun = true;
    log();
    /**
     * Rerun VM only if not exceeded maximum rerun attempts. for example if there are 10 hosts that can run VM and
     * predefine maximum 3 attempts to rerun VM - on 4th turn vm will stop to run despite there are still available
     * hosts to run it DO NOT TRY TO RERUN IF RESUME FAILED.
     */
    if (getRunVdssList().size() < Config.<Integer>GetValue(ConfigValues.MaxRerunVmOnVdsCount) && getVm().getstatus() != VMStatus.Paused) {
        // restore CanDoAction value to false so CanDoAction checks will run again
        getReturnValue().setCanDoAction(false);
        if (getExecutionContext() != null) {
            Job job = getExecutionContext().getJob();
            if (job != null) {
                // mark previous steps as fail
                JobRepositoryFactory.getJobRepository().closeCompletedJobSteps(job.getId(), JobExecutionStatus.FAILED);
            }
        }
        // set the _isRerun flag to false before calling executeAction so that we'll know if
        // there is another rerun attempt within the method
        _isRerun = false;
        executeAction();
        // wasn't done because canDoAction check returned false..
        if (!_isRerun && !getReturnValue().getCanDoAction()) {
            log();
            failedToRunVm();
        }
        // signal the caller that a rerun was made
        _isRerun = true;
    } else {
        Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(getVmId());
        failedToRunVm();
        _isRerun = false;
        log();
    }
}
#end_block

#method_before
public static boolean VerifyAddVm(List<String> reasons, int nicsCount, VmTemplate vmTemplate, Guid storagePoolId, int vmPriority) {
    boolean returnValue = true;
    if (MacPoolManager.getInstance().getavailableMacsCount() < nicsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else {
        boolean isValid = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(storagePoolId)).getReturnValue()).booleanValue();
        if (isValid) {
            if (!VmTemplateCommand.IsVmPriorityValueLegal(vmPriority, reasons)) {
                returnValue = false;
            }
        } else {
            if (reasons != null) {
                reasons.add(VdcBllMessages.IMAGE_REPOSITORY_NOT_FOUND.toString());
            }
            returnValue = false;
        }
    }
    return returnValue;
}
#method_after
public static boolean VerifyAddVm(List<String> reasons, int nicsCount, int vmPriority) {
    boolean returnValue = true;
    if (MacPoolManager.getInstance().getavailableMacsCount() < nicsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else if (!VmTemplateCommand.IsVmPriorityValueLegal(vmPriority, reasons)) {
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().gethypervisor_type(), getParameters().getMasterVm().getoperation_mode(), getParameters().getMasterVm().isSmartcardEnabled()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    getVmTemplate().setQuotaId(getQuotaId());
    getVmTemplate().setdedicated_vm_for_vds(getParameters().getMasterVm().getdedicated_vm_for_vds());
    getVmTemplate().setMigrationSupport(getParameters().getMasterVm().getMigrationSupport());
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#method_after
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().isSmartcardEnabled()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    getVmTemplate().setQuotaId(getQuotaId());
    getVmTemplate().setdedicated_vm_for_vds(getParameters().getMasterVm().getdedicated_vm_for_vds());
    getVmTemplate().setMigrationSupport(getParameters().getMasterVm().getMigrationSupport());
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(((CreateImageTemplateParameters) getParameters().getImagesParameters().get(0)).getVmId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    rollbackQuota();
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        RemoveTemplateInSpm(getVmTemplate().getstorage_pool_id().getValue(), getVmTemplateId());
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVm());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    rollbackQuota();
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        RemoveTemplateInSpm(getVmTemplate().getstorage_pool_id().getValue(), getVmTemplateId());
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    endActionOnDisks();
    if (getVm() != null) {
        VmHandler.unlockVm(getVm(), getCompensationContext());
        // disks regardless if there was a failure during the initializtion of it.
        if (getSnapshotDao().get(((ImagesActionsParametersBase) getParameters().getImagesParameters().get(0)).getVmSnapshotId()) != null) {
            restoreVmConfigFromSnapshot();
        }
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VmCommand::EndVmCommand: Vm is null - not performing EndAction on Vm");
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    endActionOnDisks();
    if (getVm() != null) {
        VmHandler.unlockVm(getVm(), getCompensationContext());
        restoreVmConfigFromSnapshot();
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VmCommand::EndVmCommand: Vm is null - not performing EndAction on Vm");
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    final Guid newActiveSnapshotId = Guid.NewGuid();
    final List<DiskImage> images = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForVmSnapshot(getParameters().getDstSnapshotId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
            getCompensationContext().snapshotEntity(previousActiveSnapshot);
            Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
            getSnapshotDao().remove(previousActiveSnapshotId);
            snapshotsManager.addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), getCompensationContext());
            snapshotsManager.addActiveSnapshot(newActiveSnapshotId, getVm(), getCompensationContext());
            snapshotsManager.removeAllIllegalDisks(previousActiveSnapshotId, getVm().getId());
            // if there are no images we can should restore the config now so it'll be executed within the transaction.
            if (!images.isEmpty()) {
                getCompensationContext().stateChanged();
            } else {
                restoreVmConfigFromSnapshot();
            }
            return null;
        }
    });
    if (images.size() > 0) {
        VmHandler.LockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : images) {
                    ImagesContainterParametersBase tempVar = new ImagesContainterParametersBase(image.getImageId());
                    tempVar.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                    tempVar.setVmSnapshotId(newActiveSnapshotId);
                    tempVar.setEntityId(getParameters().getEntityId());
                    tempVar.setParentParameters(getParameters());
                    tempVar.setQuotaId(image.getQuotaId());
                    ImagesContainterParametersBase p = tempVar;
                    getParameters().getImagesParameters().add(p);
                    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.TryBackToSnapshot, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new VdcBLLException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                return null;
            }
        });
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    final Guid newActiveSnapshotId = Guid.NewGuid();
    final List<DiskImage> images = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForVmSnapshot(getParameters().getDstSnapshotId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
            getCompensationContext().snapshotEntity(previousActiveSnapshot);
            Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
            getSnapshotDao().remove(previousActiveSnapshotId);
            snapshotsManager.addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), getCompensationContext());
            snapshotsManager.addActiveSnapshot(newActiveSnapshotId, getVm(), getCompensationContext());
            snapshotsManager.removeAllIllegalDisks(previousActiveSnapshotId, getVm().getId());
            // the update is being executed in the same transaction so we can restore the vm config and end the command.
            if (!images.isEmpty()) {
                getCompensationContext().stateChanged();
            } else {
                restoreVmConfigFromSnapshot();
            }
            return null;
        }
    });
    if (images.size() > 0) {
        VmHandler.LockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : images) {
                    ImagesContainterParametersBase tempVar = new ImagesContainterParametersBase(image.getImageId());
                    tempVar.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                    tempVar.setVmSnapshotId(newActiveSnapshotId);
                    tempVar.setEntityId(getParameters().getEntityId());
                    tempVar.setParentParameters(getParameters());
                    tempVar.setQuotaId(image.getQuotaId());
                    ImagesContainterParametersBase p = tempVar;
                    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.TryBackToSnapshot, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                    getParameters().getImagesParameters().add(p);
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new VdcBLLException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                return null;
            }
        });
    }
    setSucceeded(true);
}
#end_block

#method_before
public static boolean VerifyAddVm(List<String> reasons, int nicsCount, VmTemplate vmTemplate, Guid storagePoolId, int vmPriority) {
    boolean returnValue = true;
    if (MacPoolManager.getInstance().getavailableMacsCount() < nicsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else {
        boolean isValid = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(storagePoolId)).getReturnValue()).booleanValue();
        if (isValid) {
            if (!VmTemplateCommand.IsVmPriorityValueLegal(vmPriority, reasons)) {
                returnValue = false;
            }
        } else {
            if (reasons != null) {
                reasons.add(VdcBllMessages.IMAGE_REPOSITORY_NOT_FOUND.toString());
            }
            returnValue = false;
        }
    }
    return returnValue;
}
#method_after
public static boolean VerifyAddVm(List<String> reasons, int nicsCount, int vmPriority) {
    boolean returnValue = true;
    if (MacPoolManager.getInstance().getavailableMacsCount() < nicsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else if (!VmTemplateCommand.IsVmPriorityValueLegal(vmPriority, reasons)) {
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                case Done:
                case exist:
                    throw e;
                default:
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                    throw e;
                default:
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#end_block

#method_before
@Override
public void save(tags tag) {
    Guid id = tag.gettag_id();
    if (Guid.isNullOrEmpty(id)) {
        id = Guid.NewGuid();
        tag.settag_id(id);
    }
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", tag.getdescription()).addValue("tag_id", id).addValue("tag_name", tag.gettag_name()).addValue("parent_id", tag.getparent_id()).addValue("readonly", tag.getIsReadonly()).addValue("type", tag.gettype());
    getCallsHandler().executeModification("Inserttags", parameterSource);
}
#method_after
@Override
public void save(tags tag) {
    Guid id = tag.gettag_id();
    if (Guid.isNullOrEmpty(id)) {
        id = Guid.NewGuid();
        tag.settag_id(id);
    }
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", tag.getdescription()).addValue("tag_id", tag.gettag_id()).addValue("tag_name", tag.gettag_name()).addValue("parent_id", tag.getparent_id()).addValue("readonly", tag.getIsReadonly()).addValue("type", tag.gettype());
    getCallsHandler().executeModification("Inserttags", parameterSource);
}
#end_block

#method_before
private MapSqlParameterSource getVdsGroupParamSource(VDSGroup group) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", group.getdescription()).addValue("name", group.getname()).addValue("vds_group_id", group.getId()).addValue("cpu_name", group.getcpu_name()).addValue("selection_algorithm", group.getselection_algorithm()).addValue("high_utilization", group.gethigh_utilization()).addValue("low_utilization", group.getlow_utilization()).addValue("cpu_over_commit_duration_minutes", group.getcpu_over_commit_duration_minutes()).addValue("hypervisor_type", group.gethypervisor_type()).addValue("storage_pool_id", group.getstorage_pool_id()).addValue("max_vds_memory_over_commit", group.getmax_vds_memory_over_commit()).addValue("transparent_hugepages", group.getTransparentHugepages()).addValue("compatibility_version", group.getcompatibility_version()).addValue("migrate_on_error", group.getMigrateOnError()).addValue("virt_service", group.supportsVirtService()).addValue("gluster_service", group.supportsGlusterService());
    return parameterSource;
}
#method_after
private MapSqlParameterSource getVdsGroupParamSource(VDSGroup group) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", group.getdescription()).addValue("name", group.getname()).addValue("vds_group_id", group.getId()).addValue("cpu_name", group.getcpu_name()).addValue("selection_algorithm", group.getselection_algorithm()).addValue("high_utilization", group.gethigh_utilization()).addValue("low_utilization", group.getlow_utilization()).addValue("cpu_over_commit_duration_minutes", group.getcpu_over_commit_duration_minutes()).addValue("storage_pool_id", group.getstorage_pool_id()).addValue("max_vds_memory_over_commit", group.getmax_vds_memory_over_commit()).addValue("transparent_hugepages", group.getTransparentHugepages()).addValue("compatibility_version", group.getcompatibility_version()).addValue("migrate_on_error", group.getMigrateOnError()).addValue("virt_service", group.supportsVirtService()).addValue("gluster_service", group.supportsGlusterService());
    return parameterSource;
}
#end_block

#method_before
@Override
public VDSGroup mapRow(ResultSet rs, int rowNum) throws SQLException {
    VDSGroup entity = new VDSGroup();
    entity.setdescription(rs.getString("description"));
    entity.setname(rs.getString("name"));
    entity.setId(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setcpu_name(rs.getString("cpu_name"));
    entity.setselection_algorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.sethigh_utilization(rs.getInt("high_utilization"));
    entity.setlow_utilization(rs.getInt("low_utilization"));
    entity.setcpu_over_commit_duration_minutes(rs.getInt("cpu_over_commit_duration_minutes"));
    entity.sethypervisor_type(HypervisorType.forValue(rs.getInt("hypervisor_type")));
    entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setmax_vds_memory_over_commit(rs.getInt("max_vds_memory_over_commit"));
    entity.setTransparentHugepages(rs.getBoolean("transparent_hugepages"));
    entity.setcompatibility_version(new Version(rs.getString("compatibility_version")));
    entity.setMigrateOnError(MigrateOnErrorOptions.forValue(rs.getInt("migrate_on_error")));
    entity.setVirtService(rs.getBoolean("virt_service"));
    entity.setGlusterService(rs.getBoolean("gluster_service"));
    return entity;
}
#method_after
@Override
public VDSGroup mapRow(ResultSet rs, int rowNum) throws SQLException {
    VDSGroup entity = new VDSGroup();
    entity.setdescription(rs.getString("description"));
    entity.setname(rs.getString("name"));
    entity.setId(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setcpu_name(rs.getString("cpu_name"));
    entity.setselection_algorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.sethigh_utilization(rs.getInt("high_utilization"));
    entity.setlow_utilization(rs.getInt("low_utilization"));
    entity.setcpu_over_commit_duration_minutes(rs.getInt("cpu_over_commit_duration_minutes"));
    entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setmax_vds_memory_over_commit(rs.getInt("max_vds_memory_over_commit"));
    entity.setTransparentHugepages(rs.getBoolean("transparent_hugepages"));
    entity.setcompatibility_version(new Version(rs.getString("compatibility_version")));
    entity.setMigrateOnError(MigrateOnErrorOptions.forValue(rs.getInt("migrate_on_error")));
    entity.setVirtService(rs.getBoolean("virt_service"));
    entity.setGlusterService(rs.getBoolean("gluster_service"));
    return entity;
}
#end_block

#method_before
@Override
public void save(vm_pools pool) {
    Guid id = pool.getvm_pool_id();
    if (Guid.isNullOrEmpty(id)) {
        id = Guid.NewGuid();
        pool.setvm_pool_id(id);
    }
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_description", pool.getvm_pool_description()).addValue("vm_pool_id", id).addValue("vm_pool_name", pool.getvm_pool_name()).addValue("vm_pool_type", pool.getvm_pool_type()).addValue("parameters", pool.getparameters()).addValue("prestarted_vms", pool.getPrestartedVms()).addValue("vds_group_id", pool.getvds_group_id());
    getCallsHandler().executeModification("InsertVm_pools", parameterSource);
}
#method_after
@Override
public void save(vm_pools pool) {
    Guid id = pool.getvm_pool_id();
    if (Guid.isNullOrEmpty(id)) {
        id = Guid.NewGuid();
        pool.setvm_pool_id(id);
    }
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_description", pool.getvm_pool_description()).addValue("vm_pool_id", pool.getvm_pool_id()).addValue("vm_pool_name", pool.getvm_pool_name()).addValue("vm_pool_type", pool.getvm_pool_type()).addValue("parameters", pool.getparameters()).addValue("prestarted_vms", pool.getPrestartedVms()).addValue("vds_group_id", pool.getvds_group_id());
    getCallsHandler().executeModification("InsertVm_pools", parameterSource);
}
#end_block

#method_before
@Override
protected StatusForXmlRpc getReturnStatus() {
    return result.getmStatus();
}
#method_after
@Override
protected StatusForXmlRpc getReturnStatus() {
    return result.getStatus();
}
#end_block

#method_before
private List<BrickProfileDetails> prepareBrickProfileDetails(GlusterVolumeEntity volume, Object[] brickProfileDetails) {
    List<BrickProfileDetails> brickProfileDetailsList = new ArrayList<BrickProfileDetails>();
    for (Object brickProfileObj : brickProfileDetails) {
        BrickProfileDetails brickProfileDetail = new BrickProfileDetails();
        Map<String, Object> brickProfile = (Map<String, Object>) brickProfileObj;
        brickProfileDetail.setBrickId(getBrickId(volume.getBricks(), (String) brickProfile.get(BRICK)));
        List<StatsInfo> statsInfo = new ArrayList<StatsInfo>();
        statsInfo.add(getStatInfo((Map<String, Object>) brickProfile.get(CUMULATIVE_STATS), CUMULATIVE_STATS));
        statsInfo.add(getStatInfo((Map<String, Object>) brickProfile.get(INTERVAL_STATS), INTERVAL_STATS));
        brickProfileDetail.setStatsInfo(statsInfo);
        brickProfileDetailsList.add(brickProfileDetail);
    }
    return brickProfileDetailsList;
}
#method_after
private List<BrickProfileDetails> prepareBrickProfileDetails(GlusterVolumeEntity volume, Object[] brickProfileDetails) {
    List<BrickProfileDetails> brickProfileDetailsList = new ArrayList<BrickProfileDetails>();
    for (Object brickProfileObj : brickProfileDetails) {
        BrickProfileDetails brickProfileDetail = new BrickProfileDetails();
        Map<String, Object> brickProfile = (Map<String, Object>) brickProfileObj;
        GlusterBrickEntity brick = GlusterCoreUtil.getBrickByQualifiedName(volume.getBricks(), (String) brickProfile.get(BRICK));
        if (brick != null) {
            brickProfileDetail.setBrickId(brick.getId());
        }
        List<StatsInfo> statsInfo = new ArrayList<StatsInfo>();
        statsInfo.add(getStatInfo((Map<String, Object>) brickProfile.get(CUMULATIVE_STATS), CUMULATIVE_STATS));
        statsInfo.add(getStatInfo((Map<String, Object>) brickProfile.get(INTERVAL_STATS), INTERVAL_STATS));
        brickProfileDetail.setStatsInfo(statsInfo);
        brickProfileDetailsList.add(brickProfileDetail);
    }
    return brickProfileDetailsList;
}
#end_block

#method_before
@Override
protected void ProceedProxyReturnValue() {
    VdcBllErrors returnStatus = GetReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterHostRemoveFailed:
        case GlusterAddHostFailed:
        case GlusterPeerListFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterVolumeProfileInfoFailed:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.ProceedProxyReturnValue();
            break;
    }
}
#method_after
@Override
protected void ProceedProxyReturnValue() {
    VdcBllErrors returnStatus = GetReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case GlusterHostRemoveFailed:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.ProceedProxyReturnValue();
            break;
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    if (volumeEntity.getVolumeType() == GlusterVolumeType.STRIPE || getSelectedItems() == null || getSelectedItems().size() == 0 || getSelectedItems().size() == volumeEntity.getBricks().size()) {
        getRemoveBricksCommand().setIsExecutionAllowed(false);
    } else if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE && volumeEntity.getBricks().size() == VolumeListModel.REPLICATE_COUNT_DEFAULT) {
        getRemoveBricksCommand().setIsExecutionAllowed(false);
    } else if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE && getSelectedItems() == null && getSelectedItems().size() > 1) {
        getRemoveBricksCommand().setIsExecutionAllowed(false);
    } else {
        getRemoveBricksCommand().setIsExecutionAllowed(true);
    }
    getReplaceBrickCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() == 1);
    getBrickAdvancedDetailsCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() == 1);
}
#method_after
private void updateActionAvailability() {
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    if (volumeEntity.getVolumeType() == GlusterVolumeType.STRIPE || getSelectedItems() == null || getSelectedItems().size() == 0 || getSelectedItems().size() == volumeEntity.getBricks().size()) {
        getRemoveBricksCommand().setIsExecutionAllowed(false);
    } else if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE && volumeEntity.getBricks().size() == VolumeListModel.REPLICATE_COUNT_DEFAULT) {
        getRemoveBricksCommand().setIsExecutionAllowed(false);
    } else if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE && getSelectedItems() == null && getSelectedItems().size() > 1) {
        getRemoveBricksCommand().setIsExecutionAllowed(false);
    } else {
        getRemoveBricksCommand().setIsExecutionAllowed(true);
    }
    getReplaceBrickCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() == 1);
    getBrickAdvancedDetailsCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() == 1 && ((GlusterVolumeEntity) getEntity()).isOnline());
}
#end_block

#method_before
private void showBrickAdvancedDetails() {
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    final GlusterBrickEntity brickEntity = (GlusterBrickEntity) getSelectedItem();
    final BrickAdvancedDetailsModel brickModel = new BrickAdvancedDetailsModel();
    setWindow(brickModel);
    brickModel.setTitle(ConstantsManager.getInstance().getConstants().advancedDetailsBrickTitle());
    // $NON-NLS-1$
    brickModel.setHashName("brick_advanced");
    brickModel.StartProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            brickModel.StopProgress();
            GlusterVolumeAdvancedDetails advDetails = (GlusterVolumeAdvancedDetails) result;
            brickModel.getBrick().setEntity(brickEntity.getQualifiedName());
            if (advDetails != null && advDetails.getBrickDetails() != null && advDetails.getBrickDetails().size() == 1) {
                BrickDetails brickDetails = advDetails.getBrickDetails().get(0);
                brickModel.getBrickProperties().setProperties(brickDetails.getBrickProperties());
                ArrayList<EntityModel> clients = new ArrayList<EntityModel>();
                for (GlusterClientInfo client : brickDetails.getClients()) {
                    clients.add(new EntityModel(client));
                }
                brickModel.getClients().setItems(clients);
                brickModel.getMemoryStatistics().updateMemoryStatistics(brickDetails.getMemoryStatus().getMallInfo());
                ArrayList<EntityModel> memoryPools = new ArrayList<EntityModel>();
                for (Mempool mempool : brickDetails.getMemoryStatus().getMemPools()) {
                    memoryPools.add(new EntityModel(mempool));
                }
                brickModel.getMemoryPools().setItems(memoryPools);
            }
        }
    };
    AsyncDataProvider.GetGlusterVolumeBrickDetails(aQuery, volumeEntity.getClusterId(), volumeEntity.getName(), brickEntity.getQualifiedName());
    // $NON-NLS-1$
    UICommand command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().close());
    command.setIsDefault(true);
    brickModel.getCommands().add(command);
}
#method_after
private void showBrickAdvancedDetails() {
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getEntity();
    final GlusterBrickEntity brickEntity = (GlusterBrickEntity) getSelectedItem();
    final BrickAdvancedDetailsModel brickModel = new BrickAdvancedDetailsModel();
    setWindow(brickModel);
    brickModel.setTitle(ConstantsManager.getInstance().getConstants().advancedDetailsBrickTitle());
    // $NON-NLS-1$
    brickModel.setHashName("brick_advanced");
    brickModel.StartProgress(null);
    AsyncDataProvider.GetGlusterVolumeBrickDetails(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            brickModel.StopProgress();
            GlusterVolumeAdvancedDetails advDetails = (GlusterVolumeAdvancedDetails) result;
            brickModel.getBrick().setEntity(brickEntity.getQualifiedName());
            if (advDetails != null && advDetails.getBrickDetails() != null && advDetails.getBrickDetails().size() == 1) {
                BrickDetails brickDetails = advDetails.getBrickDetails().get(0);
                brickModel.getBrickProperties().setProperties(brickDetails.getBrickProperties());
                ArrayList<EntityModel> clients = new ArrayList<EntityModel>();
                for (GlusterClientInfo client : brickDetails.getClients()) {
                    clients.add(new EntityModel(client));
                }
                brickModel.getClients().setItems(clients);
                brickModel.getMemoryStatistics().updateMemoryStatistics(brickDetails.getMemoryStatus().getMallInfo());
                ArrayList<EntityModel> memoryPools = new ArrayList<EntityModel>();
                for (Mempool mempool : brickDetails.getMemoryStatus().getMemPools()) {
                    memoryPools.add(new EntityModel(mempool));
                }
                brickModel.getMemoryPools().setItems(memoryPools);
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getName(), brickEntity.getQualifiedName());
    // $NON-NLS-1$
    UICommand command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().close());
    command.setIsDefault(true);
    brickModel.getCommands().add(command);
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(ClusterNetworkPopupPresenterWidget.class, ClusterNetworkPopupPresenterWidget.ViewDef.class, ClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmDesktopNewPopupPresenterWidget.class, VmDesktopNewPopupPresenterWidget.ViewDef.class, VmDesktopNewPopupView.class);
    bindPresenterWidget(VmServerNewPopupPresenterWidget.class, VmServerNewPopupPresenterWidget.ViewDef.class, VmServerNewPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmDesktopNewPopupPresenterWidget.class, VmDesktopNewPopupPresenterWidget.ViewDef.class, VmDesktopNewPopupView.class);
    bindPresenterWidget(VmServerNewPopupPresenterWidget.class, VmServerNewPopupPresenterWidget.ViewDef.class, VmServerNewPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
}
#end_block

#method_before
@Override
protected void InitDetailModels() {
    super.InitDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new ClusterGeneralModel());
    list.add(new ClusterNetworkListModel());
    list.add(new ClusterHostListModel());
    list.add(new ClusterVmListModel());
    list.add(new ClusterServiceModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void InitDetailModels() {
    super.InitDetailModels();
    setClusterServiceModel(new ClusterServiceModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new ClusterGeneralModel());
    list.add(new ClusterNetworkListModel());
    list.add(new ClusterHostListModel());
    list.add(new ClusterVmListModel());
    list.add(getClusterServiceModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
protected void UpdateDetailsAvailability() {
    super.UpdateDetailsAvailability();
    for (EntityModel detailModel : getDetailModels()) {
        if (detailModel instanceof ClusterServiceModel) {
            detailModel.setIsAvailable(((VDSGroup) getSelectedItem()).supportsGlusterService());
        }
    }
}
#method_after
@Override
protected void UpdateDetailsAvailability() {
    super.UpdateDetailsAvailability();
    getClusterServiceModel().setIsAvailable(((VDSGroup) getSelectedItem()).supportsGlusterService());
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<Network, ClusterListModel, ClusterNetworkListModel> getClusterNetworkListProvider(ClientGinjector ginjector, final Provider<ClusterNetworkPopupPresenterWidget> popupProvider, final Provider<ClusterManageNetworkPopupPresenterWidget> managePopupProvider) {
    return new SearchableDetailTabModelProvider<Network, ClusterListModel, ClusterNetworkListModel>(ginjector, ClusterListModel.class, ClusterNetworkListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterNetworkListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewNetworkCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getManageCommand()) {
                return managePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<Network, ClusterListModel, ClusterNetworkListModel> getClusterNetworkListProvider(ClientGinjector ginjector, final Provider<NewClusterNetworkPopupPresenterWidget> popupProvider, final Provider<ClusterManageNetworkPopupPresenterWidget> managePopupProvider) {
    return new SearchableDetailTabModelProvider<Network, ClusterListModel, ClusterNetworkListModel>(ginjector, ClusterListModel.class, ClusterNetworkListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterNetworkListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewNetworkCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getManageCommand()) {
                return managePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(ClusterNetworkPopupPresenterWidget.class, ClusterNetworkPopupPresenterWidget.ViewDef.class, ClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmDesktopNewPopupPresenterWidget.class, VmDesktopNewPopupPresenterWidget.ViewDef.class, VmDesktopNewPopupView.class);
    bindPresenterWidget(VmServerNewPopupPresenterWidget.class, VmServerNewPopupPresenterWidget.ViewDef.class, VmServerNewPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmDesktopNewPopupPresenterWidget.class, VmDesktopNewPopupPresenterWidget.ViewDef.class, VmDesktopNewPopupView.class);
    bindPresenterWidget(VmServerNewPopupPresenterWidget.class, VmServerNewPopupPresenterWidget.ViewDef.class, VmServerNewPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
}
#end_block

#method_before
private void runCommand(CLIParser parser) throws ManageDomainsResult {
    String action = parser.getArg(Arguments.action.name());
    ActionType actionType;
    try {
        actionType = ActionType.valueOf(action);
    } catch (IllegalArgumentException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
    }
    if (actionType.equals(ActionType.add)) {
        addDomain(parser.getArg(Arguments.domain.name()).toLowerCase(), parser.getArg(Arguments.user.name()), getPasswordInput(parser), REMOTE_LOCATION, getLdapProviderType(parser));
    } else if (actionType.equals(ActionType.edit)) {
        editDomain(parser.getArg(Arguments.domain.name()).toLowerCase(), parser.getArg(Arguments.user.name()), getPasswordInput(parser), null, parser.hasArg(Arguments.provider.name()) ? getLdapProviderType(parser) : null);
    } else if (actionType.equals(ActionType.delete)) {
        deleteDomain(parser.getArg(Arguments.domain.name()).toLowerCase());
    } else if (actionType.equals(ActionType.validate)) {
        validate();
    } else if (actionType.equals(ActionType.list)) {
        getConfiguration();
    } else {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
    }
}
#method_after
private void runCommand(CLIParser parser) throws ManageDomainsResult {
    String action = parser.getArg(Arguments.action.name());
    ActionType actionType;
    try {
        actionType = ActionType.valueOf(action);
    } catch (IllegalArgumentException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
    }
    if (actionType.equals(ActionType.add)) {
        addDomain(parser.getArg(Arguments.domain.name()).toLowerCase(), parser.getArg(Arguments.user.name()), getPasswordInput(parser), getLdapProviderType(parser));
    } else if (actionType.equals(ActionType.edit)) {
        editDomain(parser.getArg(Arguments.domain.name()).toLowerCase(), parser.getArg(Arguments.user.name()), getPasswordInput(parser), null, parser.hasArg(Arguments.provider.name()) ? getLdapProviderType(parser) : null);
    } else if (actionType.equals(ActionType.delete)) {
        deleteDomain(parser.getArg(Arguments.domain.name()).toLowerCase());
    } else if (actionType.equals(ActionType.validate)) {
        validate();
    } else if (actionType.equals(ActionType.list)) {
        getConfiguration();
    } else {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
    }
}
#end_block

#method_before
private String getPasswordInput(CLIParser parser) throws ManageDomainsResult {
    String pass = null;
    if (parser.hasArg(Arguments.passwordFile.name())) {
        try {
            String passwordFile = parser.getArg(Arguments.passwordFile.name());
            pass = readPasswordFile(passwordFile);
        } catch (Exception e) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_READING_PASSWORD_FILE, e.getMessage());
        }
    } else if (parser.hasArg(Arguments.interactive.name())) {
        pass = readPasswordInteractively();
    }
    validatePassword(pass);
    return pass;
}
#method_after
private String getPasswordInput(CLIParser parser) throws ManageDomainsResult {
    String pass = null;
    if (parser.hasArg(Arguments.passwordFile.name())) {
        try {
            String passwordFile = parser.getArg(Arguments.passwordFile.name());
            pass = readPasswordFile(passwordFile);
        } catch (Exception e) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_READING_PASSWORD_FILE, e.getMessage());
        }
        if (pass == null) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.EMPTY_PASSWORD_FILE);
        }
    } else if (parser.hasArg(Arguments.interactive.name())) {
        pass = readPasswordInteractively();
    }
    validatePassword(pass);
    return pass;
}
#end_block

#method_before
public void addDomain(String domainName, String userName, String password, String mode, LdapProviderType ldapProviderType) throws ManageDomainsResult {
    String authMode = DEFAULT_AUTH_MODE;
    if (mode.equalsIgnoreCase(LdapModeEnum.LOCAL.name())) {
        authMode = LdapAuthModeEnum.SIMPLE.name();
    } else if (mode.equalsIgnoreCase(LdapModeEnum.REMOTE.name())) {
        authMode = LdapAuthModeEnum.GSSAPI.name();
    }
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, password);
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    if (authMode.equalsIgnoreCase(LdapAuthModeEnum.SIMPLE.name())) {
        ldapServersEntry.setValueForDomain(domainName, utilityConfiguration.getLocalHostEntry());
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, true, false);
    handleAddPermissions(domainName, adUserNameEntry, adUserIdEntry);
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry);
    printSuccessMessage(domainName, "added");
}
#method_after
public void addDomain(String domainName, String userName, String password, LdapProviderType ldapProviderType) throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, password);
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    if (authMode.equalsIgnoreCase(LdapAuthModeEnum.SIMPLE.name())) {
        ldapServersEntry.setValueForDomain(domainName, utilityConfiguration.getLocalHostEntry());
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, true, false);
    handleAddPermissions(domainName, adUserNameEntry, adUserIdEntry);
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry);
    printSuccessMessage(domainName, "added");
}
#end_block

#method_before
private void validate(CLIParser parser) throws ManageDomainsResult {
    if (parser.hasArg(Arguments.propertiesFile.name())) {
        if (parser.hasArg(Arguments.action.name())) {
            String action = parser.getArg(Arguments.action.name());
            ActionType actionType;
            try {
                actionType = ActionType.valueOf(action);
            } catch (IllegalArgumentException ex) {
                throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
            }
            if (actionType.equals(ActionType.add)) {
                requireArgs(parser, Arguments.domain, Arguments.user, Arguments.provider);
                requireAtLeastOneArg(parser, Arguments.passwordFile, Arguments.interactive);
                checkInvalidArgs(parser, Arguments.location);
            } else if (actionType.equals(ActionType.edit)) {
                requireArgs(parser, Arguments.domain);
                checkInvalidArgs(parser, Arguments.location);
            } else if (actionType.equals(ActionType.delete)) {
                requireArgs(parser, Arguments.domain);
                checkInvalidArgs(parser, Arguments.location);
            } else if (actionType.equals(ActionType.validate)) {
                checkInvalidArgs(parser, Arguments.domain, Arguments.user, Arguments.passwordFile, Arguments.interactive, Arguments.location);
            } else if (actionType.equals(ActionType.list)) {
                checkInvalidArgs(parser, Arguments.domain, Arguments.user, Arguments.passwordFile, Arguments.interactive, Arguments.location);
            }
        } else {
            throw new ManageDomainsResult(ManageDomainsResultEnum.ACTION_IS_NOT_SPECIFIED);
        }
    } else {
        throw new ManageDomainsResult(ManageDomainsResultEnum.PROPERTIES_FILE_IS_NOT_SPECIFIED);
    }
    if (parser.getArgs().size() > Arguments.values().length) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.TOO_MANY_ARGUMENTS);
    }
}
#method_after
private void validate(CLIParser parser) throws ManageDomainsResult {
    if (parser.hasArg(Arguments.propertiesFile.name())) {
        if (parser.hasArg(Arguments.action.name())) {
            String action = parser.getArg(Arguments.action.name());
            ActionType actionType;
            try {
                actionType = ActionType.valueOf(action);
            } catch (IllegalArgumentException ex) {
                throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
            }
            if (actionType.equals(ActionType.add)) {
                requireArgs(parser, Arguments.domain, Arguments.user, Arguments.provider);
                requireAtLeastOneArg(parser, Arguments.passwordFile, Arguments.interactive);
                checkInvalidArgs(parser);
            } else if (actionType.equals(ActionType.edit)) {
                requireArgs(parser, Arguments.domain);
                checkInvalidArgs(parser);
            } else if (actionType.equals(ActionType.delete)) {
                requireArgs(parser, Arguments.domain);
                checkInvalidArgs(parser);
            } else if (actionType.equals(ActionType.validate)) {
                checkInvalidArgs(parser, Arguments.domain, Arguments.user, Arguments.passwordFile, Arguments.interactive);
            } else if (actionType.equals(ActionType.list)) {
                checkInvalidArgs(parser, Arguments.domain, Arguments.user, Arguments.passwordFile, Arguments.interactive);
            }
        } else {
            throw new ManageDomainsResult(ManageDomainsResultEnum.ACTION_IS_NOT_SPECIFIED);
        }
    } else {
        throw new ManageDomainsResult(ManageDomainsResultEnum.PROPERTIES_FILE_IS_NOT_SPECIFIED);
    }
    if (parser.getArgs().size() > Arguments.values().length) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.TOO_MANY_ARGUMENTS);
    }
}
#end_block

#method_before
private void checkInvalidArgs(CLIParser parser, Arguments... args) throws ManageDomainsResult {
    for (Arguments arg : args) {
        if (parser.hasArg(arg.name())) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_COMMAND, arg.name());
        }
    }
}
#method_after
private void checkInvalidArgs(CLIParser parser, Arguments... args) throws ManageDomainsResult {
    for (Arguments arg : args) {
        if (parser.hasArg(arg.name())) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_COMMAND, arg.name());
        }
    }
    // check if the user has provided undefined arguments
    Set<String> arguments = new TreeSet<String>(parser.getArgs());
    for (Arguments arg : Arguments.values()) {
        arguments.remove(arg.name().toLowerCase());
    }
    if (arguments.size() > 0) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_COMMAND, arguments.toString().replaceAll("\\[", "").replaceAll("\\]", ""));
    }
}
#end_block

#method_before
protected void createObjects() {
    existingDistVol = volumeDao.getById(EXISTING_VOL_DIST_ID);
    existingReplVol = volumeDao.getById(EXISTING_VOL_REPL_ID);
    existingServer1Static = vdsStaticDao.get(SERVER_ID_1);
    existingServer1 = vdsDao.get(SERVER_ID_1.getValue());
    existingServer2 = vdsDao.get(SERVER_ID_2.getValue());
}
#method_after
@Before
public void createObjects() {
    existingServer1 = createServer(SERVER_ID_1, SERVER_NAME_1);
    existingServer2 = createServer(SERVER_ID_2, SERVER_NAME_2);
    existingServers.add(existingServer1);
    existingServers.add(existingServer2);
    existingServers.add(createServer(SERVER_ID_3, SERVER_NAME_3));
    createCluster();
    existingDistVol = createDistVol(DIST_VOL_NAME, EXISTING_VOL_DIST_ID);
    existingReplVol = createReplVol();
}
#end_block

#method_before
private void setupMocks() {
    doReturn(existingServer1).when(clusterUtils).getUpServer(any(Guid.class));
    doReturn(volumeDao).when(glusterManager).getVolumeDao();
    doReturn(brickDao).when(glusterManager).getBrickDao();
    doReturn(optionDao).when(glusterManager).getOptionDao();
    doReturn(vdsDao).when(glusterManager).getVdsDao();
    doReturn(vdsStatisticsDao).when(glusterManager).getVdsStatisticsDao();
    doReturn(vdsStaticDao).when(glusterManager).getVdsStaticDao();
    doReturn(vdsDynamicDao).when(glusterManager).getVdsDynamicDAO();
    doReturn(clusterDao).when(glusterManager).getClusterDao();
    doReturn(clusterUtils).when(glusterManager).getClusterUtils();
    doReturn(serversListCommand).when(glusterManager).createServersListCommand(any(VDS.class));
    doReturn(volumesListCommand).when(glusterManager).createVolumesListCommand(any(VDS.class));
    doNothing().when(glusterManager).logVolumeMessage(any(GlusterVolumeEntity.class), any(AuditLogType.class));
    doReturn(getFetchedServersList()).when(serversListCommand).ExecuteWithReturnValue();
    doReturn(getFetchedVolumesList()).when(volumesListCommand).ExecuteWithReturnValue();
}
#method_after
private void setupMocks() throws Exception {
    glusterManager = Mockito.spy(GlusterManager.getInstance());
    mockTransactionManager();
    mockDaos();
    doReturn(clusterUtils).when(glusterManager).getClusterUtils();
    doReturn(existingServer1).when(clusterUtils).getUpServer(any(Guid.class));
    doNothing().when(glusterManager).logAuditMessage(any(Guid.class), any(GlusterVolumeEntity.class), any(VDS.class), any(AuditLogType.class), any(String.class), any(String.class));
    doReturn(getFetchedServersList()).when(glusterManager).fetchServers(any(VDS.class));
    doReturn(getFetchedVolumesList()).when(glusterManager).fetchVolumes(any(VDS.class));
    doReturn(getVolumeAdvancedDetails(existingDistVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingDistVol.getName());
    doReturn(getVolumeAdvancedDetails(existingReplVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingReplVol.getName());
    doReturn(new VDSReturnValue()).when(glusterManager).runVdsCommand(eq(VDSCommandType.RemoveVds), argThat(isRemovedServer()));
}
#end_block

#method_before
private Map<String, GlusterVolumeEntity> getFetchedVolumesList() {
    Map<String, GlusterVolumeEntity> volumes = new HashMap<String, GlusterVolumeEntity>();
    // add all existing volumes except one
    List<GlusterVolumeEntity> existingVolumes = volumeDao.getByClusterId(CLUSTER_ID);
    for (GlusterVolumeEntity existingVolume : existingVolumes) {
        // do not return the distributed volume to test volume deletion
        if (!existingVolume.getId().equals(EXISTING_VOL_DIST_ID)) {
            if (existingVolume.getId().equals(EXISTING_VOL_REPL_ID)) {
                // test volume option changes
                // remove
                existingVolume.removeOption(OPTION_AUTH_ALLOW);
                // add
                existingVolume.setOption(OPTION_AUTH_REJECT, AUTH_REJECT_IP);
                // change
                existingVolume.setOption(OPTION_NFS_DISABLE, OPTION_VALUE_ON);
                // test brick changes
                replaceBrick(GlusterCoreUtil.findBrick(existingVolume.getBricks(), SERVER_ID_1, REPL_BRICK_R2D1), SERVER_ID_1, REPL_BRICK_R2D1_NEW);
                replaceBrick(GlusterCoreUtil.findBrick(existingVolume.getBricks(), SERVER_ID_1, REPL_BRICK_R2D2), SERVER_ID_1, REPL_BRICK_R2D2_NEW);
            }
            volumes.put(existingVolume.getName(), existingVolume);
        }
    }
    // add a new volume
    newVolume = getNewVolume();
    volumes.put(newVolume.getName(), newVolume);
    return volumes;
}
#method_after
private Map<String, GlusterVolumeEntity> getFetchedVolumesList() {
    Map<String, GlusterVolumeEntity> volumes = new HashMap<String, GlusterVolumeEntity>();
    GlusterVolumeEntity fetchedReplVol = createReplVol();
    // option removed
    fetchedReplVol.removeOption(OPTION_AUTH_ALLOW);
    // added
    fetchedReplVol.setOption(OPTION_AUTH_REJECT, AUTH_REJECT_IP);
    // changed
    fetchedReplVol.setOption(OPTION_NFS_DISABLE, OPTION_VALUE_ON);
    // brick changes
    removedBrickIds.add(GlusterCoreUtil.findBrick(existingReplVol.getBricks(), SERVER_ID_1, REPL_BRICK_R1D1).getId());
    removedBrickIds.add(GlusterCoreUtil.findBrick(existingReplVol.getBricks(), SERVER_ID_1, REPL_BRICK_R2D1).getId());
    GlusterBrickEntity brickToReplace = GlusterCoreUtil.findBrick(fetchedReplVol.getBricks(), SERVER_ID_1, REPL_BRICK_R1D1);
    replaceBrick(brickToReplace, SERVER_ID_1, REPL_BRICK_R1D1_NEW);
    brickToReplace = GlusterCoreUtil.findBrick(fetchedReplVol.getBricks(), SERVER_ID_1, REPL_BRICK_R2D1);
    replaceBrick(brickToReplace, SERVER_ID_1, REPL_BRICK_R2D1_NEW);
    volumes.put(fetchedReplVol.getName(), fetchedReplVol);
    // add a new volume
    newVolume = getNewVolume();
    volumes.put(newVolume.getName(), newVolume);
    return volumes;
}
#end_block

#method_before
private void replaceBrick(GlusterBrickEntity brick, Guid newServerId, String newBrickDir) {
    brick.setId(Guid.NewGuid());
    brick.setServerId(newServerId);
    brick.setBrickDirectory(newBrickDir);
}
#method_after
private void replaceBrick(GlusterBrickEntity brick, Guid newServerId, String newBrickDir) {
    brick.setId(Guid.NewGuid());
    brick.setServerId(newServerId);
    brick.setBrickDirectory(newBrickDir);
    addedBrickIds.add(brick.getId());
}
#end_block

#method_before
private Set<GlusterServerInfo> getFetchedServersList() {
    Set<GlusterServerInfo> servers = new HashSet<GlusterServerInfo>();
    List<VDS> existingServers = vdsDao.getAllForVdsGroup(CLUSTER_ID);
    for (VDS existingServer : existingServers) {
        if (!existingServer.getId().equals(SERVER_ID_2)) {
            servers.add(new GlusterServerInfo(existingServer.getId(), existingServer.gethost_name(), PeerStatus.CONNECTED));
        }
    }
    return servers;
}
#method_after
private Set<GlusterServerInfo> getFetchedServersList() {
    Set<GlusterServerInfo> servers = new HashSet<GlusterServerInfo>();
    servers.add(new GlusterServerInfo(SERVER_ID_1, SERVER_NAME_1, PeerStatus.CONNECTED));
    servers.add(new GlusterServerInfo(SERVER_ID_2, SERVER_NAME_2, PeerStatus.CONNECTED));
    return servers;
}
#end_block

#method_before
private GlusterVolumeEntity getNewVolume() {
    Guid volumeId = Guid.NewGuid();
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setName(NEW_VOL_NAME);
    volume.setClusterId(CLUSTER_ID);
    volume.setId(volumeId);
    volume.setVolumeType(GlusterVolumeType.DISTRIBUTE);
    volume.addTransportType(TransportType.TCP);
    volume.setReplicaCount(0);
    volume.setStripeCount(0);
    volume.setStatus(GlusterStatus.UP);
    volume.setOption("auth.allow", "*");
    volume.addAccessProtocol(AccessProtocol.GLUSTER);
    volume.addAccessProtocol(AccessProtocol.NFS);
    GlusterBrickEntity brick = new GlusterBrickEntity(volumeId, existingServer1Static, "/export/testVol1", GlusterStatus.UP);
    brick.setBrickOrder(0);
    volume.addBrick(brick);
    return volume;
}
#method_after
private GlusterVolumeEntity getNewVolume() {
    Guid volumeId = Guid.NewGuid();
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setName(NEW_VOL_NAME);
    volume.setClusterId(CLUSTER_ID);
    volume.setId(volumeId);
    volume.setVolumeType(GlusterVolumeType.DISTRIBUTE);
    volume.addTransportType(TransportType.TCP);
    volume.setReplicaCount(0);
    volume.setStripeCount(0);
    volume.setStatus(GlusterStatus.UP);
    volume.setOption("auth.allow", "*");
    volume.addAccessProtocol(AccessProtocol.GLUSTER);
    volume.addAccessProtocol(AccessProtocol.NFS);
    GlusterBrickEntity brick = new GlusterBrickEntity(volumeId, existingServer1.getStaticData(), "/export/testVol1", GlusterStatus.UP);
    brick.setBrickOrder(0);
    volume.addBrick(brick);
    return volume;
}
#end_block

#method_before
public void enableCifs() {
    accessProtocols.add(AccessProtocol.CIFS);
    setOption(GlusterConstants.OPTION_CIFS_DISABLE, GlusterConstants.OFF);
}
#method_after
public void enableCifs() {
    accessProtocols.add(AccessProtocol.CIFS);
    setOption(GlusterConstants.OPTION_USER_CIFS, GlusterConstants.ON);
}
#end_block

#method_before
public void disableCifs() {
    accessProtocols.remove(AccessProtocol.CIFS);
    setOption(GlusterConstants.OPTION_CIFS_DISABLE, GlusterConstants.ON);
}
#method_after
public void disableCifs() {
    accessProtocols.remove(AccessProtocol.CIFS);
    setOption(GlusterConstants.OPTION_USER_CIFS, GlusterConstants.OFF);
}
#end_block

#method_before
public boolean isCifsEnabled() {
    String cifsEnabled = getOptionValue(GlusterConstants.OPTION_CIFS_DISABLE);
    return (cifsEnabled == null || cifsEnabled.equalsIgnoreCase(GlusterConstants.OFF));
}
#method_after
public boolean isCifsEnabled() {
    String cifsEnabled = getOptionValue(GlusterConstants.OPTION_USER_CIFS);
    return (cifsEnabled == null || cifsEnabled.equalsIgnoreCase(GlusterConstants.ON));
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterVolumeEntity)) {
        return false;
    }
    GlusterVolumeEntity volume = (GlusterVolumeEntity) obj;
    if (!(clusterId.equals(volume.getClusterId()))) {
        return false;
    }
    if (!(name.equals(volume.getName()) && volumeType == volume.getVolumeType() && status == volume.getStatus() && GlusterCoreUtil.objectsEqual(replicaCount, volume.getReplicaCount()) && GlusterCoreUtil.objectsEqual(stripeCount, volume.getStripeCount()))) {
        return false;
    }
    if (!GlusterCoreUtil.listsEqual(getOptions(), volume.getOptions())) {
        return false;
    }
    if (!GlusterCoreUtil.listsEqual(accessProtocols, volume.getAccessProtocols())) {
        return false;
    }
    if (!GlusterCoreUtil.listsEqual(transportTypes, volume.getTransportTypes())) {
        return false;
    }
    if (!GlusterCoreUtil.listsEqual(bricks, volume.getBricks())) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterVolumeEntity)) {
        return false;
    }
    GlusterVolumeEntity volume = (GlusterVolumeEntity) obj;
    if (!(clusterId.equals(volume.getClusterId()))) {
        return false;
    }
    if (!(name.equals(volume.getName()) && volumeType == volume.getVolumeType() && status == volume.getStatus() && ObjectUtils.objectsEqual(replicaCount, volume.getReplicaCount()) && ObjectUtils.objectsEqual(stripeCount, volume.getStripeCount()))) {
        return false;
    }
    if (!ListUtils.listsEqual(getOptions(), volume.getOptions())) {
        return false;
    }
    if (!ListUtils.listsEqual(accessProtocols, volume.getAccessProtocols())) {
        return false;
    }
    if (!ListUtils.listsEqual(transportTypes, volume.getTransportTypes())) {
        return false;
    }
    if (!ListUtils.listsEqual(bricks, volume.getBricks())) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void insertVolumeEntity(GlusterVolumeEntity volume) {
    getCallsHandler().executeModification("InsertGlusterVolume", getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()));
}
#method_after
private void insertVolumeEntity(GlusterVolumeEntity volume) {
    getCallsHandler().executeModification("InsertGlusterVolume", createFullParametersMapper(volume));
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterBrickEntity)) {
        return false;
    }
    GlusterBrickEntity brick = (GlusterBrickEntity) obj;
    return (getId().equals(brick.getId()) && GlusterCoreUtil.objectsEqual(volumeId, brick.getVolumeId()) && GlusterCoreUtil.objectsEqual(serverId, brick.getServerId()) && GlusterCoreUtil.objectsEqual(brickDirectory, brick.getBrickDirectory()) && GlusterCoreUtil.objectsEqual(brickOrder, brick.getBrickOrder()) && status == brick.getStatus());
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterBrickEntity)) {
        return false;
    }
    GlusterBrickEntity brick = (GlusterBrickEntity) obj;
    return (getId().equals(brick.getId()) && (ObjectUtils.objectsEqual(volumeId, brick.getVolumeId())) && (ObjectUtils.objectsEqual(serverId, brick.getServerId())) && (ObjectUtils.objectsEqual(brickDirectory, brick.getBrickDirectory())) && (ObjectUtils.objectsEqual(brickOrder, brick.getBrickOrder())) && status == brick.getStatus());
}
#end_block

#method_before
public Guid getId() {
    return getId(true);
}
#method_after
@Override
public Guid getId() {
    return getId(true);
}
#end_block

#method_before
public void setId(Guid id) {
    this.id = id;
}
#method_after
@Override
public void setId(Guid id) {
    this.id = id;
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    log.infoFormat("InitResourceManager: {0}", new Date());
    ResourceManager.getInstance().init();
    AsyncTaskManager.getInstance().InitAsyncTaskManager();
    log.infoFormat("AsyncTaskManager: {0}", new Date());
    if (Config.<Boolean>GetValue(ConfigValues.EnableVdsLoadBalancing)) {
        VdsLoadBalancer.EnableLoadBalancer();
    }
    log.infoFormat("VdsLoadBalancer: {0}", new Date());
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.infoFormat("MacPoolManager started: {0}", new Date());
            MacPoolManager.getInstance().initialize();
            log.infoFormat("MacPoolManager finished: {0}", new Date());
        }
    });
    StoragePoolStatusHandler.Init();
    GlusterManager.getInstance().init();
    log.infoFormat("GlusterManager: {0}", new Date());
}
#method_after
@Override
@PostConstruct
public void create() {
    log.infoFormat("InitResourceManager: {0}", new Date());
    ResourceManager.getInstance().init();
    AsyncTaskManager.getInstance().InitAsyncTaskManager();
    log.infoFormat("AsyncTaskManager: {0}", new Date());
    if (Config.<Boolean>GetValue(ConfigValues.EnableVdsLoadBalancing)) {
        VdsLoadBalancer.EnableLoadBalancer();
    }
    log.infoFormat("VdsLoadBalancer: {0}", new Date());
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.infoFormat("MacPoolManager started: {0}", new Date());
            MacPoolManager.getInstance().initialize();
            log.infoFormat("MacPoolManager finished: {0}", new Date());
        }
    });
    StoragePoolStatusHandler.Init();
    GlusterManager.getInstance().init();
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    VdsDAO vdsDAO = prepareDAO(dbFacade.getVdsDAO());
    existingVds = vdsDAO.get(FixturesTool.VDS_RHEL6_NFS_SPM);
    StoragePoolDAO storagePoolDAO = prepareDAO(dbFacade.getStoragePoolDAO());
    storagePool = storagePoolDAO.get(FixturesTool.STORAGE_POOL_RHEL6_ISCSI_OTHER);
    dao = prepareDAO(dbFacade.getVdsGroupDAO());
    existingVdsGroup = dao.get(existingVds.getvds_group_id());
    groupWithNoRunningVms = dbFacade.getVdsGroupDAO().get(FixturesTool.VDS_GROUP_NO_RUNNING_VMS);
    newGroup = new VDSGroup();
    newGroup.setname("New VDS Group");
    newGroup.setcompatibility_version(new Version("3.0"));
    newGroup.setVirtService(true);
    newGroup.setGlusterService(false);
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    VdsDAO vdsDAO = prepareDAO(dbFacade.getVdsDao());
    existingVds = vdsDAO.get(FixturesTool.VDS_RHEL6_NFS_SPM);
    StoragePoolDAO storagePoolDAO = prepareDAO(dbFacade.getStoragePoolDao());
    storagePool = storagePoolDAO.get(FixturesTool.STORAGE_POOL_RHEL6_ISCSI_OTHER);
    dao = prepareDAO(dbFacade.getVdsGroupDao());
    existingVdsGroup = dao.get(existingVds.getvds_group_id());
    groupWithNoRunningVms = dbFacade.getVdsGroupDao().get(FixturesTool.VDS_GROUP_NO_RUNNING_VMS);
    newGroup = new VDSGroup();
    newGroup.setname("New VDS Group");
    newGroup.setcompatibility_version(new Version("3.0"));
    newGroup.setVirtService(true);
    newGroup.setGlusterService(false);
}
#end_block

#method_before
public void init() {
    if (!glusterModeSupported()) {
        log.debug("Gluster mode not supported. Will not schedule jobs for refreshing Gluster data.");
        return;
    }
    log.debug("Initializing Gluster Manager");
    SchedulerUtil scheduler = SchedulerUtilQuartzImpl.getInstance();
    scheduler.scheduleAFixedDelayJob(this, "refreshLightWeightData", new Class[0], new Object[0], GLUSTER_REFRESH_RATE_LIGHT, GLUSTER_REFRESH_RATE_LIGHT, TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(this, "refreshHeavyWeightData", new Class[0], new Object[0], GLUSTER_REFRESH_RATE_HEAVY, GLUSTER_REFRESH_RATE_HEAVY, TimeUnit.SECONDS);
}
#method_after
public void init() {
    if (!glusterModeSupported()) {
        log.debug("Gluster mode not supported. Will not schedule jobs for refreshing Gluster data.");
        return;
    }
    log.debug("Initializing Gluster Manager");
    SchedulerUtil scheduler = SchedulerUtilQuartzImpl.getInstance();
    scheduler.scheduleAFixedDelayJob(this, "refreshLightWeightData", new Class[0], new Object[0], getGlusterRefreshRateLight(), getGlusterRefreshRateLight(), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(this, "refreshHeavyWeightData", new Class[0], new Object[0], getGlusterRefreshRateHeavy(), getGlusterRefreshRateHeavy(), TimeUnit.SECONDS);
}
#end_block

#method_before
private boolean glusterModeSupported() {
    VdcQueryReturnValue result = Backend.getInstance().RunPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.ApplicationMode, Config.DefaultConfigurationVersion));
    if (result.getSucceeded()) {
        Integer appMode = (Integer) result.getReturnValue();
        return ((appMode & ApplicationMode.GlusterOnly.getValue()) > 0);
    } else {
        log.errorFormat("Couldn't fetch configuration value ApplicationMode. " + "Aborting initialization of GlusterManager! Error: {0}", result.getExceptionString());
        return false;
    }
}
#method_after
private boolean glusterModeSupported() {
    Integer appMode = Config.<Integer>GetValue(ConfigValues.ApplicationMode);
    return ((appMode & ApplicationMode.GlusterOnly.getValue()) > 0);
}
#end_block

#method_before
@OnTimerMethodAnnotation("refreshLightWeightData")
public void refreshLightWeightData() {
    log.info("Refreshing Gluster Data [lightweight]");
    List<VDSGroup> clusters = getClusterDao().getAll();
    for (VDSGroup cluster : clusters) {
        if (cluster.supportsGlusterService()) {
            log.debugFormat("Refreshing Gluter Data for cluster {0}", cluster.getname());
            refreshClusterData(cluster);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("refreshLightWeightData")
public void refreshLightWeightData() {
    log.debug("Refreshing Gluster Data [lightweight]");
    List<VDSGroup> clusters = getClusterDao().getAll();
    for (VDSGroup cluster : clusters) {
        if (cluster.supportsGlusterService()) {
            try {
                refreshClusterData(cluster);
            } catch (Exception e) {
                log.errorFormat("Error while refreshing Gluster lightweight data of cluster {0}!", cluster.getname(), e);
                continue;
            }
        }
    }
}
#end_block

#method_before
private void refreshClusterData(VDSGroup cluster) {
    VDS upServer = getClusterUtils().getUpServer(cluster.getId());
    if (upServer == null) {
        log.warnFormat("No server UP in cluster {0}. Can't refresh it's data at this point.", cluster.getname());
        return;
    }
    refreshServerData(cluster, upServer);
    refreshVolumeData(cluster, upServer);
}
#method_after
private void refreshClusterData(VDSGroup cluster) {
    log.debugFormat("Refreshing Gluster lightweight Data for cluster {0}", cluster.getname());
    List<VDS> existingServers = getVdsDao().getAllForVdsGroup(cluster.getId());
    VDS upServer = getClusterUtils().getUpServer(cluster.getId());
    if (upServer == null) {
        log.debugFormat("No server UP in cluster {0}. Can't refresh it's data at this point.", cluster.getname());
        return;
    }
    refreshServerData(cluster, upServer, existingServers);
    refreshVolumeData(cluster, upServer, existingServers);
}
#end_block

#method_before
private void refreshServerData(VDSGroup cluster, VDS upServer) {
    if (cluster.supportsVirtService()) {
        // running VMs
        return;
    }
    List<VDS> existingServers = getVdsDao().getAllForVdsGroup(cluster.getId());
    Set<GlusterServerInfo> fetchedServers = fetchServers(cluster, upServer, existingServers);
    if (fetchedServers != null) {
        removeDetachedServers(existingServers, fetchedServers);
    }
}
#method_after
private void refreshServerData(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    if (cluster.supportsVirtService()) {
        // If the cluster supports virt service as well, we should not be removing any servers from it, even if they
        // have been removed from the Gluster cluster using the Gluster cli, as they could potentially be used for
        // running VMs
        log.debugFormat("As cluster {0} supports virt service as well, it's servers will not be synced with glusterfs", cluster.getname());
        return;
    }
    Set<GlusterServerInfo> fetchedServers = fetchServers(cluster, upServer, existingServers);
    if (fetchedServers != null) {
        removeDetachedServers(existingServers, fetchedServers);
    }
}
#end_block

#method_before
private void removeDetachedServers(List<VDS> existingServers, Set<GlusterServerInfo> fetchedServers) {
    for (VDS server : existingServers) {
        if (!findServer(server, fetchedServers)) {
            RemoveVdsStatisticsFromDb(server);
            RemoveVdsDynamicFromDb(server);
            RemoveVdsStaticFromDb(server);
            // remove the server from resource manager
            ResourceManager.getInstance().RemoveVds(server.getId());
        }
    }
}
#method_after
private void removeDetachedServers(List<VDS> existingServers, Set<GlusterServerInfo> fetchedServers) {
    for (VDS server : existingServers) {
        if (isRemovableStatus(server.getstatus()) && serverDetached(server, fetchedServers)) {
            log.debugFormat("Server {0} has been removed directly using the gluster CLI. Removing it from engine as well.", server.getvds_name());
            logServerMessage(server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI);
            try {
                removeServerFromDb(server);
            } catch (Exception e) {
                log.errorFormat("Error while removing server {0} from database!", server.getvds_name(), e);
                continue;
            }
            // remove the server from resource manager
            runVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId()));
        }
    }
}
#end_block

#method_before
private List<String> getVdsIps(VDS vds) {
    List<String> vdsIps = new ArrayList<String>();
    for (VdsNetworkInterface iface : vds.getInterfaces()) {
        vdsIps.add(iface.getAddress());
    }
    return vdsIps;
}
#method_after
private List<String> getVdsIps(VDS vds) {
    List<String> vdsIps = new ArrayList<String>();
    for (VdsNetworkInterface iface : getInterfaceDao().getAllInterfacesForVds(vds.getId())) {
        if (iface.getAddress() != null) {
            vdsIps.add(iface.getAddress());
        }
    }
    return vdsIps;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private Set<GlusterServerInfo> fetchServers(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    Set<GlusterServerInfo> fetchedServers;
    GlusterServersListVDSCommand<VdsIdVDSCommandParametersBase> serversListCommand = createServersListCommand(upServer);
    fetchedServers = (Set<GlusterServerInfo>) serversListCommand.ExecuteWithReturnValue();
    if (fetchedServers.size() == 1 && existingServers.size() > 2) {
        // It's possible that the server we are using to get list of servers itself has been removed from the
        // cluster, and hence is returning a single server (itself)
        GlusterServerInfo server = fetchedServers.iterator().next();
        if (server.getHostnameOrIp().equals(upServer.gethost_name()) || server.getHostnameOrIp().equals(upServer.getManagmentIp())) {
            // Find a different UP server, and get servers list from it
            upServer = getNewUpServer(existingServers, upServer);
            if (upServer == null) {
                log.warnFormat("The only UP server in cluster {0} seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getname());
                return null;
            }
            fetchedServers = (Set<GlusterServerInfo>) serversListCommand.ExecuteWithReturnValue();
        }
    }
    return fetchedServers;
}
#method_after
private Set<GlusterServerInfo> fetchServers(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    // Create a copy of the existing servers as the fetchServer method can potentially remove elements from it
    List<VDS> tempServers = new ArrayList<VDS>(existingServers);
    Set<GlusterServerInfo> fetchedServers = fetchServers(upServer, tempServers);
    if (fetchedServers == null) {
        log.errorFormat("gluster peer status command failed on all servers of the cluster {0}." + "Can't refresh it's data at this point.", cluster.getname());
        return null;
    }
    if (fetchedServers.size() == 1 && existingServers.size() > 2) {
        // It's possible that the server we are using to get list of servers itself has been removed from the
        // cluster, and hence is returning a single server (itself)
        GlusterServerInfo server = fetchedServers.iterator().next();
        if (server.getHostnameOrIp().equals(upServer.gethost_name()) || getVdsIps(upServer).contains(server.getHostnameOrIp())) {
            // Find a different UP server, and get servers list from it
            tempServers.remove(upServer);
            upServer = getNewUpServer(tempServers, upServer);
            if (upServer == null) {
                log.warnFormat("The only UP server in cluster {0} seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getname());
                return null;
            }
            fetchedServers = fetchServers(upServer, tempServers);
            if (fetchedServers == null) {
                log.warnFormat("The only UP server in cluster {0} (or the only one on which gluster peer status " + "command is working) seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getname());
                return null;
            }
        }
    }
    return fetchedServers;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private Set<GlusterServerInfo> fetchServers(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    Set<GlusterServerInfo> fetchedServers;
    GlusterServersListVDSCommand<VdsIdVDSCommandParametersBase> serversListCommand = createServersListCommand(upServer);
    fetchedServers = (Set<GlusterServerInfo>) serversListCommand.ExecuteWithReturnValue();
    if (fetchedServers.size() == 1 && existingServers.size() > 2) {
        // It's possible that the server we are using to get list of servers itself has been removed from the
        // cluster, and hence is returning a single server (itself)
        GlusterServerInfo server = fetchedServers.iterator().next();
        if (server.getHostnameOrIp().equals(upServer.gethost_name()) || server.getHostnameOrIp().equals(upServer.getManagmentIp())) {
            // Find a different UP server, and get servers list from it
            upServer = getNewUpServer(existingServers, upServer);
            if (upServer == null) {
                log.warnFormat("The only UP server in cluster {0} seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getname());
                return null;
            }
            fetchedServers = (Set<GlusterServerInfo>) serversListCommand.ExecuteWithReturnValue();
        }
    }
    return fetchedServers;
}
#method_after
private Set<GlusterServerInfo> fetchServers(VDS upServer, List<VDS> existingServers) {
    Set<GlusterServerInfo> fetchedServers = null;
    while (fetchedServers == null && !existingServers.isEmpty()) {
        fetchedServers = fetchServers(upServer);
        if (fetchedServers == null) {
            logServerMessage(upServer, AuditLogType.GLUSTER_SERVERS_LIST_FAILED);
            // Couldn't fetch servers from the up server. Mark it as non-operational
            setNonOperational(upServer);
            existingServers.remove(upServer);
            upServer = getNewUpServer(existingServers, upServer);
        }
    }
    return fetchedServers;
}
#end_block

#method_before
private void refreshVolumeData(VDSGroup cluster, VDS upServer) {
    GlusterVolumesListVDSCommand<GlusterVolumesListVDSParameters> volumesListCommand = createVolumesListCommand(upServer);
    @SuppressWarnings("unchecked")
    Map<String, GlusterVolumeEntity> volumesMap = (Map<String, GlusterVolumeEntity>) volumesListCommand.ExecuteWithReturnValue();
    updateExistingAndNewVolumes(cluster.getId(), volumesMap);
    removeDeletedVolumes(cluster.getId(), volumesMap);
}
#method_after
private void refreshVolumeData(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    // Pass a copy of the existing servers as the fetchVolumes method can potentially remove elements from it
    Map<String, GlusterVolumeEntity> volumesMap = fetchVolumes(upServer, new ArrayList<VDS>(existingServers));
    if (volumesMap == null) {
        log.errorFormat("gluster volume info command failed on all servers of the cluster {0}." + "Can't refresh it's data at this point.", cluster.getname());
        return;
    }
    updateExistingAndNewVolumes(cluster.getId(), volumesMap);
    removeDeletedVolumes(cluster.getId(), volumesMap);
}
#end_block

#method_before
private void removeDeletedVolumes(Guid clusterId, Map<String, GlusterVolumeEntity> volumesMap) {
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(clusterId)) {
        if (!volumesMap.containsKey(volume.getName())) {
            log.debugFormat("Volume {0} has been removed directly using the gluster CLI. Removing it from engine as well.", volume.getName());
            getVolumeDao().remove(volume.getId());
            logVolumeMessage(volume, AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI);
        }
    }
}
#method_after
private void removeDeletedVolumes(Guid clusterId, Map<String, GlusterVolumeEntity> volumesMap) {
    List<Guid> idsToRemove = new ArrayList<Guid>();
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(clusterId)) {
        if (!volumesMap.containsKey(volume.getName())) {
            idsToRemove.add(volume.getId());
            log.debugFormat("Volume {0} has been removed directly using the gluster CLI. Removing it from engine as well.", volume.getName());
            logVolumeMessage(volume, AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI);
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getVolumeDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.errorFormat("Error while removing volumes from database!", e);
        }
    }
}
#end_block

#method_before
private void updateExistingAndNewVolumes(Guid clusterId, Map<String, GlusterVolumeEntity> volumesMap) {
    for (Entry<String, GlusterVolumeEntity> entry : volumesMap.entrySet()) {
        GlusterVolumeEntity volume = entry.getValue();
        log.debugFormat("Analyzing volume {0}", volume.getName());
        GlusterVolumeEntity existingVolume = getVolumeDao().getByName(clusterId, volume.getName());
        if (existingVolume == null) {
            log.infoFormat("Volume {0} Not present in engine. Creating the same.", volume.getName());
            createVolume(volume);
        } else {
            log.debugFormat("Volume {0} exists in engine. Checking if it needs to be updated.", existingVolume.getName());
            updateVolume(existingVolume, volume);
        }
    }
}
#method_after
private void updateExistingAndNewVolumes(Guid clusterId, Map<String, GlusterVolumeEntity> volumesMap) {
    for (Entry<String, GlusterVolumeEntity> entry : volumesMap.entrySet()) {
        GlusterVolumeEntity volume = entry.getValue();
        log.debugFormat("Analyzing volume {0}", volume.getName());
        GlusterVolumeEntity existingVolume = getVolumeDao().getByName(clusterId, volume.getName());
        if (existingVolume == null) {
            try {
                createVolume(volume);
            } catch (Exception e) {
                log.errorFormat("Could not save volume {0} in database!", volume.getName(), e);
                continue;
            }
        } else {
            try {
                log.debugFormat("Volume {0} exists in engine. Checking if it needs to be updated.", existingVolume.getName());
                updateVolume(existingVolume, volume);
            } catch (Exception e) {
                log.errorFormat("Error while updating Volume {0}!", volume.getName(), e);
                continue;
            }
        }
    }
}
#end_block

#method_before
private void createVolume(final GlusterVolumeEntity volume) {
    for (GlusterBrickEntity brick : volume.getBricks()) {
        if (brick.getServerId() == null) {
            log.warnFormat("Volume {0} contains brick(s) from unknown hosts. Hence will not add it to engine at this point.", volume.getName());
            return;
        }
    }
    log.debugFormat("Volume {0} has been created directly using the gluster CLI. Creating it in engine as well.", volume.getName());
    getVolumeDao().save(volume);
    logVolumeMessage(volume, AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI);
}
#method_after
private void createVolume(final GlusterVolumeEntity volume) {
    if (volume.getBricks() == null) {
        log.warnFormat("Bricks of volume {0} were not fetched. " + "Hence will not add it to engine at this point.", volume.getName());
        return;
    }
    for (GlusterBrickEntity brick : volume.getBricks()) {
        if (brick.getServerId() == null) {
            log.warnFormat("Volume {0} contains brick(s) from unknown hosts. " + "Hence will not add it to engine at this point.", volume.getName());
            return;
        }
    }
    logVolumeMessage(volume, AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI);
    log.debugFormat("Volume {0} has been created directly using the gluster CLI. Creating it in engine as well.", volume.getName());
    getVolumeDao().save(volume);
}
#end_block

#method_before
@SuppressWarnings("serial")
protected void logVolumeMessage(final GlusterVolumeEntity volume, final AuditLogType logType) {
    AuditLogDirector.log(new AuditLogableBase() {

        @Override
        protected GlusterVolumeEntity getGlusterVolume() {
            return volume;
        }

        @Override
        public AuditLogType getAuditLogTypeValue() {
            return logType;
        }
    });
}
#method_after
private void logVolumeMessage(final GlusterVolumeEntity volume, final AuditLogType logType) {
    logAuditMessage(volume.getClusterId(), volume, null, logType, null, null);
}
#end_block

#method_before
private void updateTransportTypes(GlusterVolumeEntity existingVolume, GlusterVolumeEntity fetchedVolume) {
    Set<TransportType> existingTransportTypes = existingVolume.getTransportTypes();
    Set<TransportType> fetchedTransportTypes = fetchedVolume.getTransportTypes();
    if (GlusterCoreUtil.listsEqual(existingTransportTypes, fetchedTransportTypes)) {
        // transport types not changed. return without updating DB.
        return;
    }
    Collection<TransportType> addedTransportTypes = GlusterCoreUtil.getAddedElements(existingTransportTypes, fetchedTransportTypes);
    if (!addedTransportTypes.isEmpty()) {
        log.infoFormat("Adding transport type(s) {0} to volume {1}", addedTransportTypes, existingVolume.getName());
        getVolumeDao().addTransportTypes(existingVolume.getId(), addedTransportTypes);
    }
    Collection<TransportType> removedTransportTypes = GlusterCoreUtil.getAddedElements(fetchedTransportTypes, existingTransportTypes);
    if (!removedTransportTypes.isEmpty()) {
        log.infoFormat("Removing transport type(s) {0} from volume {1}", removedTransportTypes, existingVolume.getName());
        getVolumeDao().removeTransportTypes(existingVolume.getId(), removedTransportTypes);
    }
}
#method_after
private void updateTransportTypes(GlusterVolumeEntity existingVolume, GlusterVolumeEntity fetchedVolume) {
    Set<TransportType> existingTransportTypes = existingVolume.getTransportTypes();
    Set<TransportType> fetchedTransportTypes = fetchedVolume.getTransportTypes();
    if (ListUtils.listsEqual(existingTransportTypes, fetchedTransportTypes)) {
        // transport types not changed. return without updating DB.
        return;
    }
    Collection<TransportType> addedTransportTypes = ListUtils.getAddedElements(existingTransportTypes, fetchedTransportTypes);
    if (!addedTransportTypes.isEmpty()) {
        log.infoFormat("Adding transport type(s) {0} to volume {1}", addedTransportTypes, existingVolume.getName());
        getVolumeDao().addTransportTypes(existingVolume.getId(), addedTransportTypes);
    }
    Collection<TransportType> removedTransportTypes = ListUtils.getAddedElements(fetchedTransportTypes, existingTransportTypes);
    if (!removedTransportTypes.isEmpty()) {
        log.infoFormat("Removing transport type(s) {0} from volume {1}", removedTransportTypes, existingVolume.getName());
        getVolumeDao().removeTransportTypes(existingVolume.getId(), removedTransportTypes);
    }
}
#end_block

#method_before
private void updateBricks(GlusterVolumeEntity existingVolume, GlusterVolumeEntity fetchedVolume) {
    List<GlusterBrickEntity> fetchedBricks = fetchedVolume.getBricks();
    removeDeletedBricks(existingVolume, fetchedBricks);
    updateExistingAndNewBricks(existingVolume, fetchedBricks);
}
#method_after
private void updateBricks(GlusterVolumeEntity existingVolume, GlusterVolumeEntity fetchedVolume) {
    List<GlusterBrickEntity> fetchedBricks = fetchedVolume.getBricks();
    if (fetchedBricks == null) {
        log.warnFormat("Bricks of volume {0} were not fetched. " + "Hence will not try to update them in engine at this point.", fetchedVolume.getName());
        return;
    }
    removeDeletedBricks(existingVolume, fetchedBricks);
    updateExistingAndNewBricks(existingVolume, fetchedBricks);
}
#end_block

#method_before
private void removeDeletedBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    for (GlusterBrickEntity existingBrick : existingVolume.getBricks()) {
        if (!GlusterCoreUtil.containsBrick(fetchedBricks, existingBrick)) {
            log.infoFormat("Brick {0} removed from volume {1} from CLI. Removing it from engine DB as well.", existingBrick.getQualifiedName(), existingVolume.getName());
            getBrickDao().removeBrick(existingBrick.getId());
            logVolumeMessage(existingVolume, AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI);
        }
    }
}
#method_after
private void removeDeletedBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    List<Guid> idsToRemove = new ArrayList<Guid>();
    for (GlusterBrickEntity existingBrick : existingVolume.getBricks()) {
        if (!GlusterCoreUtil.containsBrick(fetchedBricks, existingBrick)) {
            idsToRemove.add(existingBrick.getId());
            log.infoFormat("Brick {0} removed from volume {1} from CLI. Removing it from engine DB as well.", existingBrick.getQualifiedName(), existingVolume.getName());
            logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, ENTITY_BRICK, existingBrick.getQualifiedName());
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getBrickDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.errorFormat("Error while removing bricks from database!", e);
        }
    }
}
#end_block

#method_before
private void updateExistingAndNewBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    for (GlusterBrickEntity fetchedBrick : fetchedBricks) {
        GlusterBrickEntity existingBrick = GlusterCoreUtil.findBrick(existingVolume.getBricks(), fetchedBrick);
        if (existingBrick == null) {
            // adding such servers to engine required manual approval by user, and hence can't be automated.
            if (fetchedBrick.getServerId() != null) {
                log.infoFormat("New brick {0} added to volume {1} from gluster CLI. Updating engine DB accordingly.", fetchedBrick.getQualifiedName(), existingVolume.getName());
                fetchedBrick.setStatus(existingVolume.isOnline() ? GlusterStatus.UP : GlusterStatus.DOWN);
                getBrickDao().save(fetchedBrick);
                logVolumeMessage(existingVolume, AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI);
            }
        } else {
            // brick found. update it if required. Only property that could be different is the brick order
            if (existingBrick.getBrickOrder() != fetchedBrick.getBrickOrder()) {
                log.infoFormat("Brick order for brick {0} changed from {1} to {2} because of direct CLI operations. Updating engine DB accordingly.", existingBrick.getQualifiedName(), existingBrick.getBrickOrder(), fetchedBrick.getBrickOrder());
                getBrickDao().updateBrickOrder(existingBrick.getId(), fetchedBrick.getBrickOrder());
            }
        }
    }
}
#method_after
private void updateExistingAndNewBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    for (GlusterBrickEntity fetchedBrick : fetchedBricks) {
        GlusterBrickEntity existingBrick = GlusterCoreUtil.findBrick(existingVolume.getBricks(), fetchedBrick);
        if (existingBrick == null) {
            // adding such servers to engine required manual approval by user, and hence can't be automated.
            if (fetchedBrick.getServerId() != null) {
                log.infoFormat("New brick {0} added to volume {1} from gluster CLI. Updating engine DB accordingly.", fetchedBrick.getQualifiedName(), existingVolume.getName());
                fetchedBrick.setStatus(existingVolume.isOnline() ? GlusterStatus.UP : GlusterStatus.DOWN);
                getBrickDao().save(fetchedBrick);
                logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, ENTITY_BRICK, fetchedBrick.getQualifiedName());
            }
        } else {
            // brick found. update it if required. Only property that could be different is the brick order
            if (existingBrick.getBrickOrder() != fetchedBrick.getBrickOrder()) {
                log.infoFormat("Brick order for brick {0} changed from {1} to {2} because of direct CLI operations. Updating engine DB accordingly.", existingBrick.getQualifiedName(), existingBrick.getBrickOrder(), fetchedBrick.getBrickOrder());
                getBrickDao().updateBrickOrder(existingBrick.getId(), fetchedBrick.getBrickOrder());
            }
        }
    }
}
#end_block

#method_before
private void removeDeletedOptions(GlusterVolumeEntity fetchedVolume, Collection<GlusterVolumeOptionEntity> existingOptions) {
    for (GlusterVolumeOptionEntity existingOption : existingOptions) {
        if (fetchedVolume.getOption(existingOption.getKey()) == null) {
            log.infoFormat("Option {0} unset on volume {1} from CLI. Removing it from engine DB as well.", existingOption.getKey(), fetchedVolume.getName());
            getOptionDao().removeVolumeOption(existingOption.getId());
            logVolumeMessage(fetchedVolume, AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI);
        }
    }
}
#method_after
private void removeDeletedOptions(GlusterVolumeEntity fetchedVolume, Collection<GlusterVolumeOptionEntity> existingOptions) {
    List<Guid> idsToRemove = new ArrayList<Guid>();
    for (GlusterVolumeOptionEntity existingOption : existingOptions) {
        if (fetchedVolume.getOption(existingOption.getKey()) == null) {
            idsToRemove.add(existingOption.getId());
            log.infoFormat("Option {0} unset on volume {1} from CLI. Removing it from engine DB as well.", existingOption.getKey(), fetchedVolume.getName());
            logAuditMessage(fetchedVolume.getClusterId(), fetchedVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, ENTITY_OPTION, existingOption.getKey());
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getOptionDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.errorFormat("Error while removing options of volume {0} from database!", fetchedVolume.getName(), e);
        }
    }
}
#end_block

#method_before
private void updateExistingAndNewOptions(GlusterVolumeEntity existingVolume, Collection<GlusterVolumeOptionEntity> fetchedOptions) {
    for (GlusterVolumeOptionEntity fetchedOption : fetchedOptions) {
        GlusterVolumeOptionEntity existingOption = existingVolume.getOption(fetchedOption.getKey());
        if (existingOption == null) {
            log.infoFormat("New option {0}={1} set on volume {2} from gluster CLI. Updating engine DB accordingly.", fetchedOption.getKey(), fetchedOption.getValue(), existingVolume.getName());
            getOptionDao().save(fetchedOption);
            logVolumeMessage(existingVolume, AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI);
        } else if (!existingOption.getValue().equals(fetchedOption.getValue())) {
            log.infoFormat("Value of option {0} changed from {1} to {2} from CLI. Updating engine DB accordingly.", existingOption.getKey(), existingOption.getValue(), fetchedOption.getValue());
            getOptionDao().updateVolumeOption(existingOption.getId(), fetchedOption.getValue());
            logVolumeMessage(existingVolume, AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI);
        }
    }
}
#method_after
private void updateExistingAndNewOptions(GlusterVolumeEntity existingVolume, Collection<GlusterVolumeOptionEntity> fetchedOptions) {
    for (GlusterVolumeOptionEntity fetchedOption : fetchedOptions) {
        GlusterVolumeOptionEntity existingOption = existingVolume.getOption(fetchedOption.getKey());
        if (existingOption == null) {
            logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, ENTITY_OPTION, fetchedOption.toString());
            log.infoFormat("New option {0}={1} set on volume {2} from gluster CLI. Updating engine DB accordingly.", fetchedOption.getKey(), fetchedOption.getValue(), existingVolume.getName());
            try {
                getOptionDao().save(fetchedOption);
            } catch (Exception e) {
                log.errorFormat("Could not save option {0} of volume {1) to database!", fetchedOption, existingVolume.getName(), e);
                continue;
            }
        } else if (!existingOption.getValue().equals(fetchedOption.getValue())) {
            logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, ENTITY_OPTION, fetchedOption.toString());
            log.infoFormat("Value of option {0} of volume {1} changed from {2} to {3} from CLI. Updating engine DB accordingly.", existingOption.getKey(), existingVolume.getName(), existingOption.getValue(), fetchedOption.getValue());
            try {
                getOptionDao().updateVolumeOption(existingOption.getId(), fetchedOption.getValue());
            } catch (Exception e) {
                log.errorFormat("Error while updating option {0} of volume {1} in database!", fetchedOption, existingVolume.getName(), e);
                continue;
            }
        }
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("refreshHeavyWeightData")
public void refreshHeavyWeightData() {
    log.debug("Refreshing Gluster Data [heavyweight]");
// TODO: Fetch and update brick statuses
}
#method_after
@OnTimerMethodAnnotation("refreshHeavyWeightData")
public void refreshHeavyWeightData() {
    log.debug("Refreshing Gluster Data [heavyweight]");
    for (VDSGroup cluster : getClusterDao().getAll()) {
        try {
            refreshClusterHeavyWeightData(cluster);
        } catch (Exception e) {
            log.errorFormat("Error while refreshing Gluster heavyweight data of cluster {0}!", cluster.getname(), e);
            continue;
        }
    }
}
#end_block

#method_before
protected VdsStatisticsDAO getVdsStatisticsDao() {
    return DbFacade.getInstance().getVdsStatisticsDAO();
}
#method_after
protected VdsStatisticsDAO getVdsStatisticsDao() {
    return DbFacade.getInstance().getVdsStatisticsDao();
}
#end_block

#method_before
protected VdsStaticDAO getVdsStaticDao() {
    return DbFacade.getInstance().getVdsStaticDAO();
}
#method_after
protected VdsStaticDAO getVdsStaticDao() {
    return DbFacade.getInstance().getVdsStaticDao();
}
#end_block

#method_before
protected VdsGroupDAO getClusterDao() {
    return DbFacade.getInstance().getVdsGroupDAO();
}
#method_after
protected VdsGroupDAO getClusterDao() {
    return DbFacade.getInstance().getVdsGroupDao();
}
#end_block

#method_before
protected VdsDAO getVdsDao() {
    return DbFacade.getInstance().getVdsDAO();
}
#method_after
protected VdsDAO getVdsDao() {
    return DbFacade.getInstance().getVdsDao();
}
#end_block

#method_before
private List<GlusterBrickEntity> getBricks(Guid volumeId, Object[] brickList) throws Exception {
    List<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    int brickOrder = 0;
    for (Object brick : brickList) {
        bricks.add(getBrick(clusterId, volumeId, (String) brick, brickOrder++));
    }
    return bricks;
}
#method_after
private List<GlusterBrickEntity> getBricks(Guid volumeId, Object[] brickList) throws Exception {
    List<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    int brickOrder = 0;
    try {
        for (Object brick : brickList) {
            bricks.add(getBrick(clusterId, volumeId, (String) brick, brickOrder++));
        }
    } catch (Exception e) {
        // We do not want the command to fail if bricks for one of the volumes could not be fetched. Hence log the
        // exception and return null. The client should have special handling if bricks list of any of the volumes
        // is null.
        log.errorFormat("Error while populating bricks of volume {0}.", volumeId, e);
        return null;
    }
    return bricks;
}
#end_block

#method_before
private GlusterBrickEntity getBrick(Guid clusterId, Guid volumeId, String brickInfo, int brickOrder) {
    String[] brickParts = brickInfo.split(":", -1);
    if (brickParts.length != 2) {
        throw new RuntimeException("Invalid brick representation [" + brickInfo + "]");
    }
    String hostnameOrIp = brickParts[0];
    String brickDir = brickParts[1];
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setVolumeId(volumeId);
    brick.setBrickOrder(brickOrder);
    brick.setBrickDirectory(brickDir);
    VDS server = getServer(clusterId, hostnameOrIp);
    if (server == null) {
        log.warnFormat("Could not find server {0} in cluster {1}", hostnameOrIp, clusterId);
    } else {
        brick.setServerId(server.getId());
    }
    return brick;
}
#method_after
private GlusterBrickEntity getBrick(Guid clusterId, Guid volumeId, String brickInfo, int brickOrder) {
    String[] brickParts = brickInfo.split(":", -1);
    if (brickParts.length != 2) {
        throw new RuntimeException("Invalid brick representation [" + brickInfo + "]");
    }
    String hostnameOrIp = brickParts[0];
    String brickDir = brickParts[1];
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setVolumeId(volumeId);
    brick.setBrickOrder(brickOrder);
    brick.setBrickDirectory(brickDir);
    VDS server = getServer(clusterId, hostnameOrIp);
    if (server == null) {
        log.warnFormat("Could not find server {0} in cluster {1}", hostnameOrIp, clusterId);
    } else {
        brick.setServerId(server.getId());
        brick.setServerName(server.gethost_name());
    }
    return brick;
}
#end_block

#method_before
private VdsDAO getVdsDao() {
    return DbFacade.getInstance().getVdsDAO();
}
#method_after
private VdsDAO getVdsDao() {
    return DbFacade.getInstance().getVdsDao();
}
#end_block

#method_before
private VDS getServer(Guid clusterId, String hostnameOrIp) {
    List<VDS> servers = getVdsDao().getAllWithIpAddress(hostnameOrIp);
    if (servers.size() > 0) {
        return getServerOfCluster(clusterId, servers);
    }
    servers = getVdsDao().getAllForHostname(hostnameOrIp);
    if (servers.size() > 0) {
        return getServerOfCluster(clusterId, servers);
    }
    return null;
}
#method_after
private VDS getServer(Guid clusterId, String hostnameOrIp) {
    List<VDS> servers = getVdsDao().getAllForHostname(hostnameOrIp);
    if (servers.size() > 0) {
        return getServerOfCluster(clusterId, servers);
    }
    List<VdsNetworkInterface> ifaces = getInterfaceDao().getAllInterfacesWithIpAddress(clusterId, hostnameOrIp);
    if (ifaces.size() == 1) {
        for (VdsNetworkInterface iface : ifaces) {
            VDS server = getVdsDao().get(iface.getVdsId());
            if (server.getvds_group_id().equals(clusterId)) {
                return server;
            }
        }
    } else if (ifaces.size() > 1) {
        // manager doesn't try to update/add bricks belonging to such servers
        throw new RuntimeException(String.format("There are multiple servers in DB having same IP address %1$s! " + "Cannot arrive at correct server id for bricks related to this ip address in cluster %2$s", hostnameOrIp, clusterId));
    }
    return null;
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getGlusterBrickDao();
    server = dbFacade.getVdsStaticDAO().get(SERVER_ID);
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getGlusterBrickDao();
    server = dbFacade.getVdsStaticDao().get(SERVER_ID);
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getGlusterVolumeDao();
    server = dbFacade.getVdsStaticDAO().get(SERVER_ID);
    existingDistVol = dao.getById(EXISTING_VOL_DIST_ID);
    existingReplVol = dao.getById(EXISTING_VOL_REPL_ID);
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getGlusterVolumeDao();
    server = dbFacade.getVdsStaticDao().get(SERVER_ID);
    existingDistVol = dao.getById(EXISTING_VOL_DIST_ID);
    existingReplVol = dao.getById(EXISTING_VOL_REPL_ID);
}
#end_block

#method_before
@Test
public void testContainsBrick() {
    List<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    bricks.add(brick1);
    bricks.add(brick2);
    assertTrue(GlusterCoreUtil.containsBrick(bricks, brick1));
    assertTrue(GlusterCoreUtil.containsBrick(bricks, brick2));
    assertFalse(GlusterCoreUtil.containsBrick(bricks, brick3));
}
#method_after
public void testContainsBrick() {
    List<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    bricks.add(brick1);
    bricks.add(brick2);
    assertTrue(GlusterCoreUtil.containsBrick(bricks, brick1));
    assertTrue(GlusterCoreUtil.containsBrick(bricks, brick2));
    assertFalse(GlusterCoreUtil.containsBrick(bricks, brick3));
}
#end_block

#method_before
private GlusterBrickEntity createBrick(Guid serverId, String serverName, String brickDir) {
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setServerId(serverId);
    brick.setServerName(serverName);
    brick.setBrickDirectory(brickDir);
    return brick;
}
#method_after
private GlusterBrickEntity createBrick(Guid serverId, String serverName, String brickDir) {
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setId(Guid.NewGuid());
    brick.setServerId(serverId);
    brick.setServerName(serverName);
    brick.setBrickDirectory(brickDir);
    return brick;
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setvmt_guid(entity.getId());
    staticVm.setdomain(entity.getdomain());
    staticVm.setvds_group_id(entity.getvds_group_id());
    staticVm.setmem_size_mb(entity.getmem_size_mb());
    staticVm.setos(entity.getos());
    staticVm.setnice_level(entity.getnice_level());
    staticVm.setfail_back(entity.getfail_back());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setis_stateless(entity.getis_stateless());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setdefault_boot_sequence(entity.getdefault_boot_sequence());
    staticVm.setvm_type(entity.getvm_type());
    entity.setdefault_display_type(entity.getdefault_display_type());
    staticVm.setiso_path(entity.getiso_path());
    staticVm.setnum_of_sockets(entity.getnum_of_sockets());
    staticVm.setcpu_per_socket(entity.getcpu_per_socket());
    staticVm.setkernel_url(entity.getkernel_url());
    staticVm.setkernel_params(entity.getkernel_params());
    staticVm.setinitrd_url(entity.getinitrd_url());
    staticVm.sethypervisor_type(entity.gethypervisor_type());
    staticVm.settime_zone(entity.gettime_zone());
    staticVm.setnum_of_monitors(entity.getnum_of_monitors());
    staticVm.setAllowConsoleReconnect(entity.getAllowConsoleReconnect());
    staticVm.setpriority(entity.getpriority());
    staticVm.setusb_policy(entity.getusb_policy());
    return staticVm;
}
#method_after
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setvmt_guid(entity.getId());
    staticVm.setdomain(entity.getdomain());
    staticVm.setvds_group_id(entity.getvds_group_id());
    staticVm.setmem_size_mb(entity.getmem_size_mb());
    staticVm.setos(entity.getos());
    staticVm.setnice_level(entity.getnice_level());
    staticVm.setfail_back(entity.getfail_back());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setis_stateless(entity.getis_stateless());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setdefault_boot_sequence(entity.getdefault_boot_sequence());
    staticVm.setvm_type(entity.getvm_type());
    entity.setdefault_display_type(entity.getdefault_display_type());
    staticVm.setiso_path(entity.getiso_path());
    staticVm.setnum_of_sockets(entity.getnum_of_sockets());
    staticVm.setcpu_per_socket(entity.getcpu_per_socket());
    staticVm.setkernel_url(entity.getkernel_url());
    staticVm.setkernel_params(entity.getkernel_params());
    staticVm.setinitrd_url(entity.getinitrd_url());
    staticVm.sethypervisor_type(entity.gethypervisor_type());
    staticVm.settime_zone(entity.gettime_zone());
    staticVm.setnum_of_monitors(entity.getnum_of_monitors());
    staticVm.setAllowConsoleReconnect(entity.getAllowConsoleReconnect());
    staticVm.setpriority(entity.getpriority());
    staticVm.setusb_policy(entity.getusb_policy());
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetUsb() && vm.getUsb().isSetEnabled()) {
        staticVm.setusb_policy(vm.getUsb().isEnabled() ? UsbPolicy.ENABLED_LEGACY : UsbPolicy.DISABLED);
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetUsb() && vm.getUsb().isSetEnabled()) {
        staticVm.setusb_policy(vm.getUsb().isEnabled() ? UsbPolicy.ENABLED_LEGACY : UsbPolicy.DISABLED);
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getvm_name());
    model.setDescription(entity.getvm_description());
    model.setMemory((long) entity.getmem_size_mb() * BYTES_PER_MB);
    if (entity.getvmt_guid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getvmt_guid().toString());
    }
    if (entity.getstatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getstatus(), null)));
        if (entity.getstatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getvm_os() != null || entity.getboot_sequence() != null || entity.getkernel_url() != null || entity.getinitrd_url() != null || entity.getkernel_params() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getvm_os() != null) {
            OsType osType = VmMapper.map(entity.getos(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getboot_sequence() != null) {
            for (Boot boot : map(entity.getdefault_boot_sequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getkernel_url());
        os.setInitrd(entity.getinitrd_url());
        os.setCmdline(entity.getkernel_params());
        model.setOs(os);
    }
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getnum_of_sockets());
    topology.setCores(entity.getnum_of_cpus() / entity.getnum_of_sockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getrun_on_vds() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getrun_on_vds().toString());
    }
    if (entity.getdefault_display_type() != null) {
        model.setDisplay(new Display());
        if (isValidSessionState(entity) && entity.getDynamicData() != null) {
            model.getDisplay().setType(map(entity.getDynamicData().getdisplay_type(), null));
        } else {
            model.getDisplay().setType(map(entity.getdefault_display_type(), null));
        }
        model.getDisplay().setAddress(entity.getdisplay_ip());
        Integer displayPort = entity.getdisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getdisplay_secure_port();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getnum_of_monitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
    }
    model.setType(map(entity.getvm_type(), null));
    model.setStateless(entity.getis_stateless());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.getauto_startup());
    model.getHighAvailability().setPriority(entity.getpriority());
    if (entity.getorigin() != null) {
        model.setOrigin(map(entity.getorigin(), null));
    }
    if (entity.getvm_creation_date() != null) {
        model.setCreationTime(DateMapper.map(entity.getvm_creation_date(), null));
    }
    if (entity.getDynamicData() != null && entity.getDynamicData().getLastStartTime() != null) {
        model.setStartTime(DateMapper.map(entity.getDynamicData().getLastStartTime(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getdedicated_vm_for_vds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getdedicated_vm_for_vds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getvm_domain() != null && !entity.getvm_domain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getvm_domain());
        model.setDomain(domain);
    }
    if (entity.getvm_ip() != null && !entity.getvm_ip().isEmpty()) {
        model.setGuestInfo(new GuestInfo());
        model.getGuestInfo().setIps(new IPs());
        for (String item : entity.getvm_ip().split(" ")) {
            if (!item.equals("")) {
                IP ip = new IP();
                ip.setAddress(item.trim());
                model.getGuestInfo().getIps().getIPs().add(ip);
            }
        }
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.gettime_zone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getusb_policy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getusb_policy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getusb_policy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getvm_name());
    model.setDescription(entity.getvm_description());
    model.setMemory((long) entity.getmem_size_mb() * BYTES_PER_MB);
    if (entity.getvmt_guid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getvmt_guid().toString());
    }
    if (entity.getstatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getstatus(), null)));
        if (entity.getstatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getvm_os() != null || entity.getboot_sequence() != null || entity.getkernel_url() != null || entity.getinitrd_url() != null || entity.getkernel_params() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getvm_os() != null) {
            OsType osType = VmMapper.map(entity.getos(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getboot_sequence() != null) {
            for (Boot boot : map(entity.getdefault_boot_sequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getkernel_url());
        os.setInitrd(entity.getinitrd_url());
        os.setCmdline(entity.getkernel_params());
        model.setOs(os);
    }
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getnum_of_sockets());
    topology.setCores(entity.getnum_of_cpus() / entity.getnum_of_sockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getrun_on_vds() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getrun_on_vds().toString());
    }
    if (entity.getdefault_display_type() != null) {
        model.setDisplay(new Display());
        if (getIsVmRunning(entity) && entity.getDynamicData() != null) {
            model.getDisplay().setType(map(entity.getDynamicData().getdisplay_type(), null));
        } else {
            model.getDisplay().setType(map(entity.getdefault_display_type(), null));
        }
        model.getDisplay().setAddress(entity.getdisplay_ip());
        Integer displayPort = entity.getdisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getdisplay_secure_port();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getnum_of_monitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    model.setType(map(entity.getvm_type(), null));
    model.setStateless(entity.getis_stateless());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.getauto_startup());
    model.getHighAvailability().setPriority(entity.getpriority());
    if (entity.getorigin() != null) {
        model.setOrigin(map(entity.getorigin(), null));
    }
    if (entity.getvm_creation_date() != null) {
        model.setCreationTime(DateMapper.map(entity.getvm_creation_date(), null));
    }
    if (entity.getDynamicData() != null && entity.getDynamicData().getLastStartTime() != null) {
        model.setStartTime(DateMapper.map(entity.getDynamicData().getLastStartTime(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getdedicated_vm_for_vds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getdedicated_vm_for_vds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getvm_domain() != null && !entity.getvm_domain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getvm_domain());
        model.setDomain(domain);
    }
    if (entity.getvm_ip() != null && !entity.getvm_ip().isEmpty()) {
        model.setGuestInfo(new GuestInfo());
        model.getGuestInfo().setIps(new IPs());
        for (String item : entity.getvm_ip().split(" ")) {
            if (!item.equals("")) {
                IP ip = new IP();
                ip.setAddress(item.trim());
                model.getGuestInfo().getIps().getIPs().add(ip);
            }
        }
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.gettime_zone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getusb_policy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getusb_policy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getusb_policy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    return model;
}
#end_block

#method_before
private List<GlusterMempool> prepareMemPool(Map<String, Object> memPool) {
    List<GlusterMempool> memPoolList = new ArrayList<GlusterMempool>();
    for (int i = 0; i < memPool.size(); i++) {
        GlusterMempool glusterMemoryPool = new GlusterMempool();
        glusterMemoryPool.setName((String) memPool.get(MEMORY_NAME));
        glusterMemoryPool.setHotCount(Integer.valueOf((String) memPool.get(MEMORY_HOTCOUNT)));
        glusterMemoryPool.setColdCount(Integer.valueOf((String) memPool.get(MEMORY_COLDCOUNT)));
        glusterMemoryPool.setPadddedSize(Integer.valueOf((String) memPool.get(MEMORY_PADDDEDSIZEOF)));
        glusterMemoryPool.setAllocCount(Integer.valueOf((String) memPool.get(MEMORY_ALLOCCOUNT)));
        glusterMemoryPool.setMaxAlloc(Integer.valueOf((String) memPool.get(MEMORY_MAXALLOC)));
        glusterMemoryPool.setPoolMisses(Integer.valueOf((String) memPool.get(MEMORY_POOLMISSES)));
        glusterMemoryPool.setMaxStdAlloc(Integer.valueOf((String) memPool.get(MEMORY_MAXSTDALLOC)));
        memPoolList.add(glusterMemoryPool);
    }
    return memPoolList;
}
#method_after
private List<Mempool> prepareMemPool(Object[] memoryPool) {
    List<Mempool> memPoolList = new ArrayList<Mempool>();
    for (Object memPoolObj : memoryPool) {
        Mempool glusterMemoryPool = new Mempool();
        Map<String, Object> memPool = (Map<String, Object>) memPoolObj;
        glusterMemoryPool.setName((String) memPool.get(MEMORY_NAME));
        glusterMemoryPool.setHotCount(Integer.valueOf((String) memPool.get(MEMORY_HOTCOUNT)));
        glusterMemoryPool.setColdCount(Integer.valueOf((String) memPool.get(MEMORY_COLDCOUNT)));
        glusterMemoryPool.setPadddedSize(Integer.valueOf((String) memPool.get(MEMORY_PADDDEDSIZEOF)));
        glusterMemoryPool.setAllocCount(Integer.valueOf((String) memPool.get(MEMORY_ALLOCCOUNT)));
        glusterMemoryPool.setMaxAlloc(Integer.valueOf((String) memPool.get(MEMORY_MAXALLOC)));
        glusterMemoryPool.setPoolMisses(Integer.valueOf((String) memPool.get(MEMORY_POOLMISSES)));
        glusterMemoryPool.setMaxStdAlloc(Integer.valueOf((String) memPool.get(MEMORY_MAXSTDALLOC)));
        memPoolList.add(glusterMemoryPool);
    }
    return memPoolList;
}
#end_block

#method_before
private GlusterMallInfo prepareMallInfo(Map<String, Object> mallInfo) {
    GlusterMallInfo glusterMallInfo = new GlusterMallInfo();
    glusterMallInfo.setArena(Integer.valueOf((String) mallInfo.get(MEMORY_ARENA)));
    glusterMallInfo.setOrdblks(Integer.valueOf((String) mallInfo.get(MEMORY_ORDBLKS)));
    glusterMallInfo.setSmblks(Integer.valueOf((String) mallInfo.get(MEMORY_SMBLKS)));
    glusterMallInfo.setHblks(Integer.valueOf((String) mallInfo.get(MEMORY_HBLKS)));
    glusterMallInfo.setHblkhd(Integer.valueOf((String) mallInfo.get(MEMORY_HBLKHD)));
    glusterMallInfo.setUsmblks(Integer.valueOf((String) mallInfo.get(MEMORY_USMBLKS)));
    glusterMallInfo.setFsmblks(Integer.valueOf((String) mallInfo.get(MEMORY_FSMBLKS)));
    glusterMallInfo.setUordblks(Integer.valueOf((String) mallInfo.get(MEMORY_UORDBLKS)));
    glusterMallInfo.setFordblks(Integer.valueOf((String) mallInfo.get(MEMORY_FORDBLKS)));
    glusterMallInfo.setKeepcost(Integer.valueOf((String) mallInfo.get(MEMORY_KEEPCOST)));
    return glusterMallInfo;
}
#method_after
private MallInfo prepareMallInfo(Map<String, Object> mallInfo) {
    MallInfo glusterMallInfo = new MallInfo();
    glusterMallInfo.setArena(Integer.valueOf((String) mallInfo.get(MEMORY_ARENA)));
    glusterMallInfo.setOrdblks(Integer.valueOf((String) mallInfo.get(MEMORY_ORDBLKS)));
    glusterMallInfo.setSmblks(Integer.valueOf((String) mallInfo.get(MEMORY_SMBLKS)));
    glusterMallInfo.setHblks(Integer.valueOf((String) mallInfo.get(MEMORY_HBLKS)));
    glusterMallInfo.setHblkhd(Integer.valueOf((String) mallInfo.get(MEMORY_HBLKHD)));
    glusterMallInfo.setUsmblks(Integer.valueOf((String) mallInfo.get(MEMORY_USMBLKS)));
    glusterMallInfo.setFsmblks(Integer.valueOf((String) mallInfo.get(MEMORY_FSMBLKS)));
    glusterMallInfo.setUordblks(Integer.valueOf((String) mallInfo.get(MEMORY_UORDBLKS)));
    glusterMallInfo.setFordblks(Integer.valueOf((String) mallInfo.get(MEMORY_FORDBLKS)));
    glusterMallInfo.setKeepcost(Integer.valueOf((String) mallInfo.get(MEMORY_KEEPCOST)));
    return glusterMallInfo;
}
#end_block

#method_before
private List<GlusterClientInfo> prepareClientInfo(Map<String, Object> clientsStatus) {
    List<GlusterClientInfo> clientInfoList = new ArrayList<GlusterClientInfo>();
    for (int i = 0; i < clientsStatus.size(); i++) {
        GlusterClientInfo clientInfo = new GlusterClientInfo();
        String hostName = (String) clientsStatus.get(CLIENTS_HOST_NAME);
        String[] hostNameArr = hostName.split(":", -1);
        clientInfo.setHostname(hostNameArr[0]);
        clientInfo.setClientPort(Integer.valueOf(hostNameArr[1]));
        clientInfo.setBytesRead(Integer.valueOf((String) clientsStatus.get(CLIENTS_BYTES_READ)));
        clientInfo.setBytesWrite(Integer.valueOf((String) clientsStatus.get(CLIENTS_BYTES_WRITE)));
        clientInfoList.add(clientInfo);
    }
    return clientInfoList;
}
#method_after
private List<GlusterClientInfo> prepareClientInfo(Object[] clientsStatus) {
    List<GlusterClientInfo> clientInfoList = new ArrayList<GlusterClientInfo>();
    for (Object clientStatusObj : clientsStatus) {
        GlusterClientInfo clientInfo = new GlusterClientInfo();
        Map<String, Object> client = (Map<String, Object>) clientStatusObj;
        String hostName = (String) client.get(CLIENTS_HOST_NAME);
        String[] hostNameArr = hostName.split(":", -1);
        clientInfo.setHostname(hostNameArr[0]);
        clientInfo.setClientPort(Integer.valueOf(hostNameArr[1]));
        clientInfo.setBytesRead(Integer.valueOf((String) client.get(CLIENTS_BYTES_READ)));
        clientInfo.setBytesWritten(Integer.valueOf((String) client.get(CLIENTS_BYTES_WRITE)));
        clientInfoList.add(clientInfo);
    }
    return clientInfoList;
}
#end_block

#method_before
public Integer getClientPort() {
    return clientPort;
}
#method_after
public int getClientPort() {
    return clientPort;
}
#end_block

#method_before
public void setClientPort(Integer clientPort) {
    this.clientPort = clientPort;
}
#method_after
public void setClientPort(int clientPort) {
    this.clientPort = clientPort;
}
#end_block

#method_before
public Integer getBytesRead() {
    return bytesRead;
}
#method_after
public int getBytesRead() {
    return bytesRead;
}
#end_block

#method_before
public void setBytesRead(Integer bytesRead) {
    this.bytesRead = bytesRead;
}
#method_after
public void setBytesRead(int bytesRead) {
    this.bytesRead = bytesRead;
}
#end_block

#method_before
public Integer getPort() {
    return port;
}
#method_after
public int getPort() {
    return port;
}
#end_block

#method_before
public void setPort(Integer port) {
    this.port = port;
}
#method_after
public void setPort(int port) {
    this.port = port;
}
#end_block

#method_before
public Integer getPid() {
    return pid;
}
#method_after
public int getPid() {
    return pid;
}
#end_block

#method_before
public void setPid(Integer pid) {
    this.pid = pid;
}
#method_after
public void setPid(int pid) {
    this.pid = pid;
}
#end_block

#method_before
public Double getTotalSize() {
    return totalSize;
}
#method_after
public double getTotalSize() {
    return totalSize;
}
#end_block

#method_before
public void setTotalSize(Double totalSize) {
    this.totalSize = totalSize;
}
#method_after
public void setTotalSize(double totalSize) {
    this.totalSize = totalSize;
}
#end_block

#method_before
public Double getFreeSize() {
    return freeSize;
}
#method_after
public double getFreeSize() {
    return freeSize;
}
#end_block

#method_before
public void setFreeSize(Double freeSize) {
    this.freeSize = freeSize;
}
#method_after
public void setFreeSize(double freeSize) {
    this.freeSize = freeSize;
}
#end_block

#method_before
public Integer getBlockSize() {
    return blockSize;
}
#method_after
public int getBlockSize() {
    return blockSize;
}
#end_block

#method_before
public void setBlockSize(Integer blockSize) {
    this.blockSize = blockSize;
}
#method_after
public void setBlockSize(int blockSize) {
    this.blockSize = blockSize;
}
#end_block

#method_before
public boolean Validate() {
    LongIntegerValidation longInterValidation = new LongIntegerValidation(1, Long.MAX_VALUE);
    getSpecificMemValue().setIsValid(true);
    getSpecificCpuValue().setIsValid(true);
    if ((Boolean) getSpecificMem().getEntity()) {
        getSpecificMemValue().ValidateEntity(new IValidation[] { longInterValidation, new NotEmptyValidation() });
    }
    if ((Boolean) getSpecificCpu().getEntity()) {
        getSpecificCpuValue().ValidateEntity(new IValidation[] { longInterValidation, new NotEmptyValidation() });
    }
    return getSpecificMemValue().getIsValid() && getSpecificCpuValue().getIsValid();
}
#method_after
public boolean Validate() {
    IntegerValidation intValidation = new IntegerValidation();
    intValidation.setMinimum(1);
    getSpecificMemValue().setIsValid(true);
    getSpecificCpuValue().setIsValid(true);
    if ((Boolean) getSpecificMem().getEntity()) {
        getSpecificMemValue().ValidateEntity(new IValidation[] { intValidation, new NotEmptyValidation() });
    }
    if ((Boolean) getSpecificCpu().getEntity()) {
        getSpecificCpuValue().ValidateEntity(new IValidation[] { intValidation, new NotEmptyValidation() });
    }
    return getSpecificMemValue().getIsValid() && getSpecificCpuValue().getIsValid();
}
#end_block

#method_before
@Override
public Response add(VM vm) {
    validateParameters(vm, "name", "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (isCreateFromSnapshot(vm)) {
        response = createVmFromSnapshot(vm);
    } else {
        validateParameters(vm, "template.id|name");
        Guid templateId = getTemplateId(vm);
        VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
        if (namedCluster(vm)) {
            staticVm.setvds_group_id(getClusterId(vm));
        }
        UsbPolicy usbPolicy = UsbResourceUtils.getUsbPolicy(vm.getUsb(), lookupCluster(staticVm.getvds_group_id()));
        if (usbPolicy != null) {
            staticVm.setusb_policy(usbPolicy);
        }
        if (!isFiltered()) {
            // resolve the host's ID, because it will be needed down the line
            if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                staticVm.setdedicated_vm_for_vds(createGuidFromString(getHostId(vm.getPlacementPolicy().getHost().getName())));
            }
        } else {
            vm.setPlacementPolicy(null);
        }
        Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
        if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
            response = cloneVmFromTemplate(staticVm, vm, templateId);
        } else if (Guid.Empty.equals(templateId)) {
            response = addVmFromScratch(staticVm, vm, storageDomainId);
        } else {
            response = addVm(staticVm, vm, storageDomainId, templateId);
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#method_after
@Override
public Response add(VM vm) {
    validateParameters(vm, "name", "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (isCreateFromSnapshot(vm)) {
        response = createVmFromSnapshot(vm);
    } else {
        validateParameters(vm, "template.id|name");
        Guid templateId = getTemplateId(vm);
        VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
        if (namedCluster(vm)) {
            staticVm.setvds_group_id(getClusterId(vm));
        }
        UsbPolicy usbPolicy = UsbResourceUtils.getUsbPolicy(vm.getUsb(), lookupCluster(staticVm.getvds_group_id()));
        if (usbPolicy != null) {
            staticVm.setusb_policy(usbPolicy);
        }
        if (!isFiltered()) {
            // resolve the host's ID, because it will be needed down the line
            if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                staticVm.setdedicated_vm_for_vds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
            }
        } else {
            vm.setPlacementPolicy(null);
        }
        Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
        if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
            response = cloneVmFromTemplate(staticVm, vm, templateId);
        } else if (Guid.Empty.equals(templateId)) {
            response = addVmFromScratch(staticVm, vm, storageDomainId);
        } else {
            response = addVm(staticVm, vm, storageDomainId, templateId);
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#end_block

#method_before
protected VM getVmWithoutConfiguration() {
    VM vm = getVmDao().get(snapshot.getVmId());
    List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDao().getAllForVm(vm.getId());
    vm.setInterfaces(interfaces);
    List<DiskImage> disks = getDiskImageDao().getAllSnapshotsForVmSnapshot(snapshot.getId());
    vm.setImages(new ArrayList<DiskImage>(disks));
    // OvfReader sets disks as active during import which is required by VmHandler.updateDisksForVm to prepare the VM disks.
    for (DiskImage currDisk : disks) {
        currDisk.setactive(true);
    }
    return vm;
}
#method_after
protected VM getVmWithoutConfiguration() {
    VM vm = getVmDao().get(snapshot.getVmId());
    List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDao().getAllForVm(vm.getId());
    vm.setInterfaces(interfaces);
    List<DiskImage> disks = getDiskImageDao().getAllSnapshotsForVmSnapshot(snapshot.getId());
    vm.setImages(new ArrayList<DiskImage>(disks));
    // VM disks.
    for (DiskImage currDisk : disks) {
        currDisk.setactive(true);
    }
    return vm;
}
#end_block

#method_before
protected String addToAuditLogErrorMessage(String connection, String errorCode, List<storage_server_connections> connections, LUNs lun) {
    AuditLogableBase logable = new AuditLogableBase();
    String connectionField = getConnectionDescription(connections, connection) + (lun == null ? "" : " (LUN " + lun.getLUN_id() + ")");
    logable.AddCustomValue("Connection", connectionField);
    // Get translated error by error code ,if no translation found (should not happened) ,
    // will set the error code instead.
    String translatedError = getTranslatedStorageError(errorCode);
    logable.AddCustomValue("ErrorCode", translatedError);
    AuditLogDirector.log(logable, AuditLogType.STORAGE_DOMAIN_ERROR);
    return connectionField;
}
#method_after
protected String addToAuditLogErrorMessage(String connection, String errorCode, List<storage_server_connections> connections, LUNs lun) {
    AuditLogableBase logable = new AuditLogableBase();
    String connectionField = getConnectionDescription(connections, connection) + (lun == null ? "" : " (LUN " + lun.getLUN_id() + ")");
    logable.AddCustomValue("Connection", connectionField);
    // Get translated error by error code ,if no translation found (should not happened) ,
    // will set the error code instead.
    String translatedError = getTranslatedStorageError(errorCode);
    logable.AddCustomValue("ErrorMessage", translatedError);
    AuditLogDirector.log(logable, AuditLogType.STORAGE_DOMAIN_ERROR);
    return connectionField;
}
#end_block

#method_before
private void prepareMocks(StopGlusterVolumeProfileCommand command) {
    doReturn(volumeDao).when(command).getGlusterVolumeDao();
    doReturn(getVds(VDSStatus.Up)).when(command).getUpServer();
    doReturn(getGlusterVolume(stoppedVolumeId)).when(volumeDao).getById(stoppedVolumeId);
    doReturn(getGlusterVolume(startedVolumeId)).when(volumeDao).getById(startedVolumeId);
    doReturn(null).when(volumeDao).getById(null);
}
#method_after
private void prepareMocks(StopGlusterVolumeProfileCommand command) {
    doReturn(volumeDao).when(command).getGlusterVolumeDao();
    doReturn(getVds(VDSStatus.Up)).when(command).getUpServer();
    doReturn(getGlusterVolume(STOPPED_VOLUME_ID)).when(volumeDao).getById(STOPPED_VOLUME_ID);
    doReturn(getGlusterVolume(STARTED_VOLUME_ID)).when(volumeDao).getById(STARTED_VOLUME_ID);
    doReturn(null).when(volumeDao).getById(null);
}
#end_block

#method_before
private GlusterVolumeEntity getGlusterVolume(Guid volumeId) {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.setId(volumeId);
    volumeEntity.setName("test-vol");
    volumeEntity.addAccessProtocol(AccessProtocol.GLUSTER);
    volumeEntity.addTransportType(TransportType.TCP);
    volumeEntity.setVolumeType(GlusterVolumeType.DISTRIBUTE);
    volumeEntity.setStatus((volumeId.equals(startedVolumeId)) ? GlusterStatus.UP : GlusterStatus.DOWN);
    volumeEntity.setClusterId(CLUSTER_ID);
    return volumeEntity;
}
#method_after
private GlusterVolumeEntity getGlusterVolume(Guid volumeId) {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.setId(volumeId);
    volumeEntity.setName("test-vol");
    volumeEntity.addAccessProtocol(AccessProtocol.GLUSTER);
    volumeEntity.addTransportType(TransportType.TCP);
    volumeEntity.setVolumeType(GlusterVolumeType.DISTRIBUTE);
    volumeEntity.setStatus((volumeId.equals(STARTED_VOLUME_ID)) ? GlusterStatus.UP : GlusterStatus.DOWN);
    volumeEntity.setClusterId(CLUSTER_ID);
    return volumeEntity;
}
#end_block

#method_before
@Test
public void canDoActionSucceedsOnStoppedVolume() {
    cmd = spy(new StopGlusterVolumeProfileCommand(new GlusterVolumeParameters(stoppedVolumeId)));
    prepareMocks(cmd);
    assertTrue(cmd.canDoAction());
}
#method_after
@Test
public void canDoActionSucceedsOnStoppedVolume() {
    cmd = spy(new StopGlusterVolumeProfileCommand(new GlusterVolumeParameters(STOPPED_VOLUME_ID)));
    prepareMocks(cmd);
    assertTrue(cmd.canDoAction());
}
#end_block

#method_before
@Test
public void canDoActionSucceedsOnStartedVolume() {
    cmd = spy(new StopGlusterVolumeProfileCommand(new GlusterVolumeParameters(startedVolumeId)));
    prepareMocks(cmd);
    assertTrue(cmd.canDoAction());
}
#method_after
@Test
public void canDoActionSucceedsOnStartedVolume() {
    cmd = spy(new StopGlusterVolumeProfileCommand(new GlusterVolumeParameters(STARTED_VOLUME_ID)));
    prepareMocks(cmd);
    assertTrue(cmd.canDoAction());
}
#end_block

#method_before
private static void initHostSeverities() {
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_TEST_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#method_after
private static void initHostSeverities() {
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_TEST_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initQuotaSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_QUOTA, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_QUOTA, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_QUOTA, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_QUOTA, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DELETE_QUOTA, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_DELETE_QUOTA, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_GRACE_LIMIT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_LIMIT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_THRESHOLD, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_GRACE_LIMIT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_LIMIT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_THRESHOLD, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.QUOTA_STORAGE_RESIZE_LOWER_THEN_CONSUMPTION, AuditLogSeverity.WARNING);
}
#method_after
private static void initQuotaSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_QUOTA, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_QUOTA, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_QUOTA, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_QUOTA, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DELETE_QUOTA, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_DELETE_QUOTA, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_GRACE_LIMIT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_LIMIT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_THRESHOLD, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_GRACE_LIMIT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_LIMIT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_THRESHOLD, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.QUOTA_STORAGE_RESIZE_LOWER_THEN_CONSUMPTION, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__STOP_VOLUME_PROFILE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_VOLUME);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__STOP_PROFILE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_VOLUME);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StopGlusterVolumeProfile, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StopGlusterVolumeProfile, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, returnValue.getVdsError().getMessage());
    }
}
#end_block

#method_before
private void prepareMocks(StartGlusterVolumeProfileCommand command) {
    doReturn(volumeDao).when(command).getGlusterVolumeDao();
    doReturn(getVds(VDSStatus.Up)).when(command).getUpServer();
    doReturn(getGlusterVolume(stoppedVolumeId)).when(volumeDao).getById(stoppedVolumeId);
    doReturn(getGlusterVolume(startedVolumeId)).when(volumeDao).getById(startedVolumeId);
    doReturn(null).when(volumeDao).getById(null);
}
#method_after
private void prepareMocks(StartGlusterVolumeProfileCommand command) {
    doReturn(volumeDao).when(command).getGlusterVolumeDao();
    doReturn(getVds(VDSStatus.Up)).when(command).getUpServer();
    doReturn(getGlusterVolume(STOPPED_VOLUME_ID)).when(volumeDao).getById(STOPPED_VOLUME_ID);
    doReturn(getGlusterVolume(STARTED_VOLUME_ID)).when(volumeDao).getById(STARTED_VOLUME_ID);
    doReturn(null).when(volumeDao).getById(null);
}
#end_block

#method_before
private GlusterVolumeEntity getGlusterVolume(Guid volumeId) {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.setId(volumeId);
    volumeEntity.setName("test-vol");
    volumeEntity.addAccessProtocol(AccessProtocol.GLUSTER);
    volumeEntity.addTransportType(TransportType.TCP);
    volumeEntity.setVolumeType(GlusterVolumeType.DISTRIBUTE);
    volumeEntity.setStatus((volumeId.equals(startedVolumeId)) ? GlusterStatus.UP : GlusterStatus.DOWN);
    volumeEntity.setClusterId(CLUSTER_ID);
    return volumeEntity;
}
#method_after
private GlusterVolumeEntity getGlusterVolume(Guid volumeId) {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.setId(volumeId);
    volumeEntity.setName("test-vol");
    volumeEntity.addAccessProtocol(AccessProtocol.GLUSTER);
    volumeEntity.addTransportType(TransportType.TCP);
    volumeEntity.setVolumeType(GlusterVolumeType.DISTRIBUTE);
    volumeEntity.setStatus((volumeId.equals(STARTED_VOLUME_ID)) ? GlusterStatus.UP : GlusterStatus.DOWN);
    volumeEntity.setClusterId(CLUSTER_ID);
    return volumeEntity;
}
#end_block

#method_before
@Test
public void canDoActionSucceedsOnStoppedVolume() {
    cmd = spy(new StartGlusterVolumeProfileCommand(new GlusterVolumeParameters(stoppedVolumeId)));
    prepareMocks(cmd);
    assertTrue(cmd.canDoAction());
}
#method_after
@Test
public void canDoActionSucceedsOnStoppedVolume() {
    cmd = spy(new StartGlusterVolumeProfileCommand(new GlusterVolumeParameters(STOPPED_VOLUME_ID)));
    prepareMocks(cmd);
    assertTrue(cmd.canDoAction());
}
#end_block

#method_before
@Test
public void canDoActionSucceedsOnStartedVolume() {
    cmd = spy(new StartGlusterVolumeProfileCommand(new GlusterVolumeParameters(startedVolumeId)));
    prepareMocks(cmd);
    assertTrue(cmd.canDoAction());
}
#method_after
@Test
public void canDoActionSucceedsOnStartedVolume() {
    cmd = spy(new StartGlusterVolumeProfileCommand(new GlusterVolumeParameters(STARTED_VOLUME_ID)));
    prepareMocks(cmd);
    assertTrue(cmd.canDoAction());
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__START_VOLUME_PROFILE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_VOLUME);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__START_PROFILE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_VOLUME);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StartGlusterVolumeProfile, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StartGlusterVolumeProfile, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, returnValue.getVdsError().getMessage());
    }
}
#end_block

#method_before
private static void initHostSeverities() {
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_TEST_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#method_after
private static void initHostSeverities() {
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_TEST_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initQuotaSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_QUOTA, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_QUOTA, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_QUOTA, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_QUOTA, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DELETE_QUOTA, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_DELETE_QUOTA, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_GRACE_LIMIT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_LIMIT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_THRESHOLD, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_GRACE_LIMIT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_LIMIT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_THRESHOLD, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.QUOTA_STORAGE_RESIZE_LOWER_THEN_CONSUMPTION, AuditLogSeverity.WARNING);
}
#method_after
private static void initQuotaSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_QUOTA, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_QUOTA, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_QUOTA, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_QUOTA, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DELETE_QUOTA, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_DELETE_QUOTA, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_GRACE_LIMIT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_LIMIT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_THRESHOLD, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_GRACE_LIMIT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_LIMIT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_THRESHOLD, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.QUOTA_STORAGE_RESIZE_LOWER_THEN_CONSUMPTION, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private void UpdateAlerts() {
    setHasAnyAlert(false);
    setHasUpgradeAlert(false);
    setHasManualFenceAlert(false);
    setHasNoPowerManagementAlert(false);
    setHasReinstallAlertNonResponsive(false);
    setHasReinstallAlertInstallFailed(false);
    setHasReinstallAlertMaintenance(false);
    setHasNICsAlert(false);
    getInstallCommand().setIsExecutionAllowed(true);
    getEditHostCommand().setIsExecutionAllowed(VdcActionUtils.CanExecute(new ArrayList<VDS>(Arrays.asList(new VDS[] { getEntity() })), VDS.class, VdcActionType.UpdateVds));
    // Check the network alert presense.
    setHasNICsAlert((getEntity().getnet_config_dirty() == null ? false : getEntity().getnet_config_dirty()));
    // Check manual fence alert presense.
    if (getEntity().getstatus() == VDSStatus.NonResponsive && !getEntity().getpm_enabled() && ((getEntity().getvm_active() == null ? 0 : getEntity().getvm_active()) > 0 || getEntity().getspm_status() == VdsSpmStatus.SPM)) {
        setHasManualFenceAlert(true);
    } else if (!getEntity().getpm_enabled()) {
        setHasNoPowerManagementAlert(true);
    }
    // Check the reinstall alert presense.
    if (getEntity().getstatus() == VDSStatus.NonResponsive) {
        setHasReinstallAlertNonResponsive(true);
    } else if (getEntity().getstatus() == VDSStatus.InstallFailed) {
        setHasReinstallAlertInstallFailed(true);
    } else if (getEntity().getstatus() == VDSStatus.Maintenance) {
        setHasReinstallAlertMaintenance(true);
    } else // available oVirt ISOs that are returned by the backend's GetoVirtISOs query.
    if (getEntity().getvds_type() == VDSType.oVirtNode && isEntityChanged) {
        AsyncDataProvider.GetoVirtISOsList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object target, Object returnValue) {
                HostGeneralModel hostGeneralModel = (HostGeneralModel) target;
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                if (isos.size() > 0) {
                    VDS vds = hostGeneralModel.getEntity();
                    hostGeneralModel.setHasUpgradeAlert(true);
                    hostGeneralModel.getInstallCommand().setIsExecutionAllowed(vds.getstatus() != VDSStatus.Up && vds.getstatus() != VDSStatus.Installing && vds.getstatus() != VDSStatus.PreparingForMaintenance && vds.getstatus() != VDSStatus.Reboot && vds.getstatus() != VDSStatus.PendingApproval);
                    if (!hostGeneralModel.getInstallCommand().getIsExecutionAllowed()) {
                        hostGeneralModel.getInstallCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().switchToMaintenanceModeToEnableUpgradeReason());
                    }
                }
            }
        }), getEntity().getId());
    }
    setNonOperationalReasonEntity((getEntity().getNonOperationalReason() == NonOperationalReason.NONE ? null : (NonOperationalReason) getEntity().getNonOperationalReason()));
    setHasAnyAlert(getHasNICsAlert() || getHasUpgradeAlert() || getHasManualFenceAlert() || getHasNoPowerManagementAlert() || getHasReinstallAlertNonResponsive() || getHasReinstallAlertInstallFailed() || getHasReinstallAlertMaintenance());
}
#method_after
private void UpdateAlerts() {
    setHasAnyAlert(false);
    setHasUpgradeAlert(false);
    setHasManualFenceAlert(false);
    setHasNoPowerManagementAlert(false);
    setHasReinstallAlertNonResponsive(false);
    setHasReinstallAlertInstallFailed(false);
    setHasReinstallAlertMaintenance(false);
    setHasNICsAlert(false);
    getInstallCommand().setIsExecutionAllowed(true);
    getEditHostCommand().setIsExecutionAllowed(VdcActionUtils.CanExecute(new ArrayList<VDS>(Arrays.asList(new VDS[] { getEntity() })), VDS.class, VdcActionType.UpdateVds));
    // Check the network alert presense.
    setHasNICsAlert((getEntity().getnet_config_dirty() == null ? false : getEntity().getnet_config_dirty()));
    // Check manual fence alert presense.
    if (getEntity().getstatus() == VDSStatus.NonResponsive && !getEntity().getpm_enabled() && ((getEntity().getvm_active() == null ? 0 : getEntity().getvm_active()) > 0 || getEntity().getspm_status() == VdsSpmStatus.SPM)) {
        setHasManualFenceAlert(true);
    } else if (!getEntity().getpm_enabled()) {
        setHasNoPowerManagementAlert(true);
    }
    // Check the reinstall alert presense.
    if (getEntity().getstatus() == VDSStatus.NonResponsive) {
        setHasReinstallAlertNonResponsive(true);
    } else if (getEntity().getstatus() == VDSStatus.InstallFailed) {
        setHasReinstallAlertInstallFailed(true);
    } else if (getEntity().getstatus() == VDSStatus.Maintenance) {
        setHasReinstallAlertMaintenance(true);
    } else // available oVirt ISOs that are returned by the backend's GetoVirtISOs query.
    if (getEntity().getvds_type() == VDSType.oVirtNode && isEntityChanged) {
        AsyncDataProvider.GetoVirtISOsList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object target, Object returnValue) {
                HostGeneralModel hostGeneralModel = (HostGeneralModel) target;
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                if (isos.size() > 0) {
                    VDS vds = hostGeneralModel.getEntity();
                    hostGeneralModel.setHasUpgradeAlert(true);
                    boolean executionAllowed = vds.getstatus() != VDSStatus.Up && vds.getstatus() != VDSStatus.Installing && vds.getstatus() != VDSStatus.PreparingForMaintenance && vds.getstatus() != VDSStatus.Reboot && vds.getstatus() != VDSStatus.PendingApproval;
                    if (!executionAllowed) {
                        hostGeneralModel.getInstallCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().switchToMaintenanceModeToEnableUpgradeReason());
                    }
                    hostGeneralModel.getInstallCommand().setIsExecutionAllowed(executionAllowed);
                }
            }
        }), getEntity().getId());
    }
    setNonOperationalReasonEntity((getEntity().getNonOperationalReason() == NonOperationalReason.NONE ? null : (NonOperationalReason) getEntity().getNonOperationalReason()));
    setHasAnyAlert(getHasNICsAlert() || getHasUpgradeAlert() || getHasManualFenceAlert() || getHasNoPowerManagementAlert() || getHasReinstallAlertNonResponsive() || getHasReinstallAlertInstallFailed() || getHasReinstallAlertMaintenance());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = isVmExist() && acquireLockInternal();
    VM vm = getVm();
    if (returnValue && (vm != null && vm.getstatus() == VMStatus.ImageLocked)) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_ARE_LOCKED);
    } else {
        // if user sent drive check that its not in use
        returnValue = returnValue && (vm == null || isDiskCanBeAddedToVm(getParameters().getDiskInfo()));
        if (returnValue && DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
            returnValue = checkIfImageDiskCanBeAdded(vm);
        }
        if (returnValue && DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
            returnValue = checkIfLunDiskCanBeAdded();
        }
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = isVmExist() && acquireLockInternal();
    VM vm = getVm();
    // if user sent drive check that its not in use
    returnValue = returnValue && (vm == null || isDiskCanBeAddedToVm(getParameters().getDiskInfo()));
    if (returnValue && DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        returnValue = checkIfImageDiskCanBeAdded(vm);
    }
    if (returnValue && DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        returnValue = checkIfLunDiskCanBeAdded();
    }
    return returnValue;
}
#end_block

#method_before
protected boolean performImagesChecks(VM vm) {
    return ImagesHandler.PerformImagesChecks(vm, getReturnValue().getCanDoActionMessages(), vm.getstorage_pool_id(), getStorageDomainId().getValue(), false, false, false, false, true, false, false, true, Collections.emptyList());
}
#method_after
protected boolean performImagesChecks(VM vm) {
    return ImagesHandler.PerformImagesChecks(vm, getReturnValue().getCanDoActionMessages(), vm.getstorage_pool_id(), getStorageDomainId().getValue(), false, true, false, false, true, false, false, true, null);
}
#end_block

#method_before
public Pair<T, K> getPair() {
    return pair == null ? new Pair<T, K>(null, null) : pair;
}
#method_after
private Pair<T, K> getPair() {
    if (pair == null) {
        pair = new Pair<T, K>(null, null);
    }
    return pair;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    PairQueryable other = (PairQueryable) obj;
    if (getPair() == null) {
        if (other.getPair() != null)
            return false;
    } else if (!getPair().equals(other.getPair()))
        return false;
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof PairQueryable)) {
        return false;
    }
    PairQueryable other = (PairQueryable) obj;
    if (getPair() == null) {
        if (other.getPair() != null) {
            return false;
        }
    } else if (!getPair().equals(other.getPair())) {
        return false;
    }
    return true;
}
#end_block

#method_before
/* Overridden CommandBase Methods */
@Override
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    return Arrays.<SPMAsyncTaskHandler>asList(new CreateImagePlaceholderTaskHandler(this), new VmMigrationDiskStartTaskHandler(this), new VmMigrationDiskCompleteTaskHandler(this));
}
#method_after
/* Overridden CommandBase Methods */
@Override
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    return Arrays.<SPMAsyncTaskHandler>asList(new LiveSnapshotTaskHandler(this), new CreateImagePlaceholderTaskHandler(this), new VmReplicateDiskStartTaskHandler(this), new VmReplicateDiskFinishTaskHandler(this));
}
#end_block

#method_before
@Override
protected T getParameters() {
    return super.getParameters();
}
#method_after
/* Overridden stubs declared as public in order to implement ITaskHandlerCommand */
@Override
public T getParameters() {
    return super.getParameters();
}
#end_block

#method_before
@Override
protected Guid createTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, VdcObjectType entityType, Guid... entityIds) {
    return super.createTask(asyncTaskCreationInfo, parentCommand, entityType, entityIds);
}
#method_after
@Override
public Guid createTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, VdcObjectType entityType, Guid... entityIds) {
    return super.createTask(asyncTaskCreationInfo, parentCommand, entityType, entityIds);
}
#end_block

#method_before
@Override
protected VDSCommandType getVDSCommandType() {
    return VDSCommandType.SyncImageGroup;
}
#method_after
@Override
protected VDSCommandType getVDSCommandType() {
    return VDSCommandType.CloneImageGroupStructure;
}
#end_block

#method_before
@Override
public AsyncTaskType getTaskType() {
    return AsyncTaskType.syncImage;
}
#method_after
@Override
public AsyncTaskType getTaskType() {
    return AsyncTaskType.cloneImageStructure;
}
#end_block

#method_before
@Override
protected VDSParametersBase getVDSParameters() {
    return new SyncImageGroupVDSCommandParameters(getStoragePoolID(), getEnclosingCommand().getParameters().getSourceDomainId().getValue(), getImageGroupID(), getStorageDomainID(), SyncOptions.PREPARE | SyncOptions.MIRROR_EXTEND_START);
}
#method_after
@Override
protected VDSParametersBase getVDSParameters() {
    return new TargetDomainImageGroupVDSCommandParameters(getEnclosingCommand().getParameters().getStoragePoolId().getValue(), getEnclosingCommand().getParameters().getSourceStorageDomainId(), getEnclosingCommand().getParameters().getImageGroupID(), getEnclosingCommand().getParameters().getTargetStorageDomainId());
}
#end_block

#method_before
@Override
protected VdcObjectType getTaskObjectType() {
    return VdcObjectType.Disk;
}
#method_after
@Override
protected VdcObjectType getTaskObjectType() {
    return VdcObjectType.VM;
}
#end_block

#method_before
@Override
protected Guid[] getTaskObjects() {
    return new Guid[] { getEnclosingCommand().getDiskImage().getId() };
}
#method_after
@Override
protected Guid[] getTaskObjects() {
    return new Guid[] { getEnclosingCommand().getParameters().getVmId() };
}
#end_block

#method_before
@Override
protected VDSCommandType getRevertVDSCommandType() {
    return VDSCommandType.DeleteImageGroup;
}
#method_after
@Override
protected VDSCommandType getRevertVDSCommandType() {
    // VDSM handles the failed cloneImageGroupStructure, so no action required here.
    return null;
}
#end_block

#method_before
@Override
public AsyncTaskType getRevertTaskType() {
    return AsyncTaskType.deleteImage;
}
#method_after
@Override
public AsyncTaskType getRevertTaskType() {
    // VDSM handles the failed cloneImageGroupStructure, so no action required here.
    return null;
}
#end_block

#method_before
@Override
protected VDSParametersBase getRevertVDSParameters() {
    return new DeleteImageGroupVDSCommandParameters(getStoragePoolID(), getStorageDomainID(), getImageGroupID(), false, false, getEnclosingCommand().getStoragePool().getcompatibility_version().getValue());
}
#method_after
@Override
protected VDSParametersBase getRevertVDSParameters() {
    // VDSM handles the failed cloneImageGroupStructure, so no action required here.
    return null;
}
#end_block

#method_before
private static Class<CommandBase<? extends VdcActionParametersBase>> getCommandClass(String name, String suffix) {
    // try the cache first
    String key = name + suffix;
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = commandsCache.get(key);
    if (clazz != null) {
        return clazz;
    }
    for (String commandPackage : COMMAND_PACKAGES) {
        String className = String.format(CLASS_NAME_FORMAT, commandPackage, name, suffix);
        Class<CommandBase<?>> type = loadClass(className);
        if (type != null) {
            // update cache
            Class<CommandBase<?>> cachedType = commandsCache.putIfAbsent(key, type);
            return cachedType == null ? type : cachedType;
        }
    }
    // nothing found
    log.warn("Unable to find class for action: " + key);
    return null;
}
#method_after
public static Class<CommandBase<? extends VdcActionParametersBase>> getCommandClass(String name) {
    return getCommandClass(name, CommandSuffix);
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    getBroker().diskReplicateFinsih(getParameters().getVmId().toString(), getSrcDiskXmlRpc(), getDstDiskXmlRpc());
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    getBroker().diskReplicateFinish(getParameters().getVmId().toString(), getSrcDiskXmlRpc(), getDstDiskXmlRpc());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    storage_pool_iso_map domainPoolMap = TransactionSupport.executeInNewTransaction(new TransactionMethod<storage_pool_iso_map>() {

        @Override
        public storage_pool_iso_map runInTransaction() {
            storage_pool_iso_map domainPoolMap = new storage_pool_iso_map(getRecoveryStoragePoolParametersData().getNewMasterDomainId(), getRecoveryStoragePoolParametersData().getStoragePoolId(), StorageDomainStatus.Active);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(domainPoolMap);
            return domainPoolMap;
        }
    });
    getStoragePool().setstatus(StoragePoolStatus.Problematic);
    try {
        if (StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).ConnectStorageToDomainByVdsId(getNewMaster(false), getVds().getId())) {
            super.executeCommand();
        } else {
            getReturnValue().setFault(new VdcFault(new VdcBLLException(VdcBllErrors.StorageServerConnectionError, "Failed to connect storage"), VdcBllErrors.StorageServerConnectionError));
        }
    } finally {
        if (!reconstructOpsSucceeded) {
            getCompensationContext().snapshotNewEntity(domainPoolMap);
            getCompensationContext().stateChanged();
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    storage_pool_iso_map domainPoolMap = TransactionSupport.executeInNewTransaction(new TransactionMethod<storage_pool_iso_map>() {

        @Override
        public storage_pool_iso_map runInTransaction() {
            storage_pool_iso_map domainPoolMap = new storage_pool_iso_map(getRecoveryStoragePoolParametersData().getNewMasterDomainId(), getRecoveryStoragePoolParametersData().getStoragePoolId(), StorageDomainStatus.Active);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(domainPoolMap);
            return domainPoolMap;
        }
    });
    getStoragePool().setstatus(StoragePoolStatus.Problematic);
    try {
        if (StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).ConnectStorageToDomainByVdsId(getNewMaster(false), getVds().getId())) {
            super.executeCommand();
        } else {
            getReturnValue().setFault(new VdcFault(new VdcBLLException(VdcBllErrors.StorageServerConnectionError, "Failed to connect storage"), VdcBllErrors.StorageServerConnectionError));
        }
    } finally {
        if (!reconstructOpSucceeded) {
            getStoragePoolIsoMapDAO().remove(new StoragePoolIsoMapId(getRecoveryStoragePoolParametersData().getNewMasterDomainId(), getRecoveryStoragePoolParametersData().getStoragePoolId()));
        }
    }
}
#end_block

#method_before
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                SetStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<storage_pool_iso_map> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#method_after
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<storage_pool_iso_map> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    reconstructOpSucceeded = true;
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        reconstructOpsSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpsSucceeded);
        if (!_isLastMaster && reconstructOpsSucceeded) {
            SearchParameters p = new SearchParameters(MessageFormat.format(DesktopsInStoragePoolQuery, getStoragePool().getname()), SearchType.VM);
            p.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            List<VM> vmsInPool = (List<VM>) Backend.getInstance().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
            VmCommand.updateVmInSpm(getStoragePool().getId(), vmsInPool);
        }
        setSucceeded(reconstructOpsSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#method_after
@Override
protected void executeCommand() {
    try {
        reconstructOpSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpSucceeded);
        if (!_isLastMaster && reconstructOpSucceeded) {
            SearchParameters p = new SearchParameters(MessageFormat.format(DesktopsInStoragePoolQuery, getStoragePool().getname()), SearchType.VM);
            p.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            List<VM> vmsInPool = (List<VM>) Backend.getInstance().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
            VmCommand.updateVmInSpm(getStoragePool().getId(), vmsInPool);
        }
        setSucceeded(reconstructOpSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    for (VDS vds : getAllRunningVdssInPool()) {
        try {
            if (!_isLastMaster && commandSucceeded) {
                VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                if (returnValue.getSucceeded()) {
                    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                } else {
                    log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnValue.getVdsError().getMessage());
                }
            }
            // only if we deactivate the storage domain we want to disconnect from it.
            if (!getParameters().isInactive()) {
                StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
            }
        } catch (Exception e) {
            log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
        }
    }
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    for (VDS vds : getAllRunningVdssInPool()) {
        try {
            if (!_isLastMaster && commandSucceeded) {
                try {
                    runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                } catch (VdcBLLException ex) {
                    if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                        VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                        if (!returnVal.getSucceeded()) {
                            log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                        }
                    } else {
                        log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                    }
                }
            }
            // only if we deactivate the storage domain we want to disconnect from it.
            if (!getParameters().isInactive()) {
                StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
            }
        } catch (Exception e) {
            log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
        }
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((imagesParameters == null) ? 0 : imagesParameters.hashCode());
    result = prime * result + (shouldbelogged ? 1231 : 1237);
    result = prime * result + (int) (taskStartTime ^ (taskStartTime >>> 32));
    result = prime * result + ((transctionOption == null) ? 0 : transctionOption.hashCode());
    result = prime * result + ((entityId == null) ? 0 : entityId.hashCode());
    result = prime * result + ((httpSessionId == null) ? 0 : httpSessionId.hashCode());
    result = prime * result + (multipleAction ? 1231 : 1237);
    result = prime * result + ((parametersCurrentUser == null) ? 0 : parametersCurrentUser.hashCode());
    result = prime * result + ((parentCommand == null) ? 0 : parentCommand.hashCode());
    result = prime * result + ((taskIds == null) ? 0 : taskIds.hashCode());
    result = prime * result + ((correlationId == null) ? 0 : correlationId.hashCode());
    result = prime * result + executionIndex;
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((imagesParameters == null) ? 0 : imagesParameters.hashCode());
    result = prime * result + (shouldbelogged ? 1231 : 1237);
    result = prime * result + ((transctionOption == null) ? 0 : transctionOption.hashCode());
    result = prime * result + ((entityId == null) ? 0 : entityId.hashCode());
    result = prime * result + ((httpSessionId == null) ? 0 : httpSessionId.hashCode());
    result = prime * result + (multipleAction ? 1231 : 1237);
    result = prime * result + ((parametersCurrentUser == null) ? 0 : parametersCurrentUser.hashCode());
    result = prime * result + ((parentCommand == null) ? 0 : parentCommand.hashCode());
    result = prime * result + ((taskIds == null) ? 0 : taskIds.hashCode());
    result = prime * result + ((correlationId == null) ? 0 : correlationId.hashCode());
    result = prime * result + executionIndex;
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    VdcActionParametersBase other = (VdcActionParametersBase) obj;
    if (imagesParameters == null) {
        if (other.imagesParameters != null)
            return false;
    } else if (!imagesParameters.equals(other.imagesParameters))
        return false;
    if (shouldbelogged != other.shouldbelogged)
        return false;
    if (taskStartTime != other.taskStartTime)
        return false;
    if (transctionOption != other.transctionOption)
        return false;
    if (entityId == null) {
        if (other.entityId != null)
            return false;
    } else if (!entityId.equals(other.entityId))
        return false;
    if (httpSessionId == null) {
        if (other.httpSessionId != null)
            return false;
    } else if (!httpSessionId.equals(other.httpSessionId))
        return false;
    if (multipleAction != other.multipleAction)
        return false;
    if (parametersCurrentUser == null) {
        if (other.parametersCurrentUser != null)
            return false;
    } else if (!parametersCurrentUser.equals(other.parametersCurrentUser))
        return false;
    if (parentCommand != other.parentCommand)
        return false;
    if (taskIds == null) {
        if (other.taskIds != null)
            return false;
    } else if (!taskIds.equals(other.taskIds))
        return false;
    if (correlationId == null) {
        if (other.correlationId != null)
            return false;
    } else if (!correlationId.equals(other.correlationId))
        return false;
    if (executionIndex != other.executionIndex)
        return false;
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    VdcActionParametersBase other = (VdcActionParametersBase) obj;
    if (imagesParameters == null) {
        if (other.imagesParameters != null)
            return false;
    } else if (!imagesParameters.equals(other.imagesParameters))
        return false;
    if (shouldbelogged != other.shouldbelogged)
        return false;
    if (transctionOption != other.transctionOption)
        return false;
    if (entityId == null) {
        if (other.entityId != null)
            return false;
    } else if (!entityId.equals(other.entityId))
        return false;
    if (httpSessionId == null) {
        if (other.httpSessionId != null)
            return false;
    } else if (!httpSessionId.equals(other.httpSessionId))
        return false;
    if (multipleAction != other.multipleAction)
        return false;
    if (parametersCurrentUser == null) {
        if (other.parametersCurrentUser != null)
            return false;
    } else if (!parametersCurrentUser.equals(other.parametersCurrentUser))
        return false;
    if (parentCommand != other.parentCommand)
        return false;
    if (taskIds == null) {
        if (other.taskIds != null)
            return false;
    } else if (!taskIds.equals(other.taskIds))
        return false;
    if (correlationId == null) {
        if (other.correlationId != null)
            return false;
    } else if (!correlationId.equals(other.correlationId))
        return false;
    if (executionIndex != other.executionIndex)
        return false;
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
// Do nothing
}
#method_after
@Override
protected void executeCommand() {
    setSucceeded(true);
}
#end_block

#method_before
@Test
public void testHandlersInEndSuccessful() {
    SPMAsyncTaskHandler handler1 = mock(SPMAsyncTaskHandler.class);
    SPMAsyncTaskHandler handler2 = mock(SPMAsyncTaskHandler.class);
    CommandBase<VdcActionParametersBase> command = spy(new CommandBaseDummy(new VdcActionParametersBase()));
    when(command.getTaskHandlers()).thenReturn(Arrays.<SPMAsyncTaskHandler>asList(handler1, handler2));
    command.getReturnValue().setSucceeded(true);
    command.endActionInTransactionScope();
    verify(handler1).endSuccessfully();
    verify(handler2).beforeTask();
    verifyNoMoreInteractions(handler1, handler2);
}
#method_after
@Test
public void testHandlersInEndSuccessful() {
    SPMAsyncTaskHandler handler1 = mock(SPMAsyncTaskHandler.class);
    SPMAsyncTaskHandler handler2 = mock(SPMAsyncTaskHandler.class);
    CommandBase<VdcActionParametersBase> command = spy(new CommandBaseDummy(new VdcActionParametersBase()));
    when(command.getTaskHandlers()).thenReturn(Arrays.<SPMAsyncTaskHandler>asList(handler1, handler2));
    command.getReturnValue().setSucceeded(true);
    command.endActionInTransactionScope();
    verify(handler1).endSuccessfully();
    verify(handler2).execute();
    verifyNoMoreInteractions(handler1, handler2);
}
#end_block

#method_before
@Test
public void testHandlersInEndWithFailure() {
    SPMAsyncTaskHandler handler1 = mock(SPMAsyncTaskHandler.class);
    SPMAsyncTaskHandler handler2 = mock(SPMAsyncTaskHandler.class);
    CommandBase<VdcActionParametersBase> command = spy(new CommandBaseDummy(new VdcActionParametersBase()));
    when(command.getTaskHandlers()).thenReturn(Arrays.<SPMAsyncTaskHandler>asList(handler1, handler2));
    command.getParameters().setTaskGroupSuccess(false);
    command.getParameters().setExecutionIndex(1);
    command.getReturnValue().setSucceeded(false);
    command.endActionInTransactionScope();
    verify(handler2).endWithFailure();
    verify(handler1).compensate();
    verifyNoMoreInteractions(handler2, handler1);
}
#method_after
@Test
public void testHandlersInEndWithFailure() {
    SPMAsyncTaskHandler handler1 = mock(SPMAsyncTaskHandler.class);
    SPMAsyncTaskHandler handler2 = mock(SPMAsyncTaskHandler.class);
    CommandBase<VdcActionParametersBase> command = spy(new CommandBaseDummy(new VdcActionParametersBase()));
    when(command.getTaskHandlers()).thenReturn(Arrays.<SPMAsyncTaskHandler>asList(handler1, handler2));
    command.getParameters().setTaskGroupSuccess(false);
    command.getParameters().setExecutionIndex(1);
    command.getReturnValue().setSucceeded(false);
    command.endActionInTransactionScope();
    verify(handler2).endWithFailure();
    verify(handler1).compensate();
    verify(handler1).getRevertTaskType();
    verifyNoMoreInteractions(handler2, handler1);
}
#end_block

#method_before
protected List<? extends SPMAsyncTaskHandler> initTaskHandlers() {
    return Collections.singletonList(new CompleteCommandSPMAsyncTaskHandler(this));
}
#method_after
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    return null;
}
#end_block

#method_before
protected BusinessEntitySnapshotDAO getBusinessEntitySnapshotDAO() {
    return DbFacade.getInstance().getBusinessEntitySnapshotDAO();
}
#method_after
protected BusinessEntitySnapshotDAO getBusinessEntitySnapshotDAO() {
    return DbFacade.getInstance().getBusinessEntitySnapshotDao();
}
#end_block

#method_before
protected void compensate() {
    getCurrentTaskHandler().compensate();
}
#method_after
protected void compensate() {
    if (hasTaskHandlers()) {
        getCurrentTaskHandler().compensate();
        revertPreviousHandlers();
    } else {
        internalCompensate();
    }
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            InternalEndSuccessfully();
        } else {
            InternalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
        } else {
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#end_block

#method_before
protected VdcActionParametersBase getParametersForTask(VdcActionType parentCommandType, VdcActionParametersBase parameters) {
    // will be stored in the DB for thr task is the one creating the command
    if (parentCommandType == VdcActionType.Unknown) {
        return parameters;
    }
    VdcActionParametersBase parentParameters = parameters.getParentParameters();
    if (parentParameters == null) {
        String msg = "No parameters exist for " + parentCommandType;
        log.error(msg);
        throw new VdcBLLException(VdcBllErrors.NO_PARAMETERS_FOR_TASK, msg);
    }
    // The parent parameters are the ones that are kept for the task.
    // In order to make sure that in case of rollback-by-command, the ROLLBACK
    // flow will be called, the execution reason of the child command is set
    // to the one of the parent command (if its REGULAR_FLOW, the execution
    // reason of the parent command remains REGULAR_FLOW).
    parentParameters.setExecutionReason(parameters.getExecutionReason());
    return parentParameters;
}
#method_after
protected VdcActionParametersBase getParametersForTask(VdcActionType parentCommandType, VdcActionParametersBase parameters) {
    // If there is no parent command, the command that its type
    // will be stored in the DB for thr task is the one creating the command
    VdcActionParametersBase parentParameters = parameters.getParentParameters();
    if (parentCommandType == VdcActionType.Unknown || parentParameters == null) {
        return parameters;
    }
    // The parent parameters are the ones that are kept for the task.
    // In order to make sure that in case of rollback-by-command, the ROLLBACK
    // flow will be called, the execution reason of the child command is set
    // to the one of the parent command (if its REGULAR_FLOW, the execution
    // reason of the parent command remains REGULAR_FLOW).
    parentParameters.setExecutionReason(parameters.getExecutionReason());
    return parentParameters;
}
#end_block

#method_before
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName()).append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#method_after
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (hasTaskHandlers()) {
        logInfo.append("Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#end_block

#method_before
private void executeActionInTransactionScope() {
    if (TransactionSupport.current() != null) {
        TransactionSupport.registerRollbackHandler(CommandBase.this);
    }
    // rollback the transaction.
    if (!ExecuteWithoutTransaction()) {
        if (TransactionSupport.current() == null) {
            cancelTasks();
        }
        // we don't want to commit transaction here
        TransactionSupport.setRollbackOnly();
    }
}
#method_after
private void executeActionInTransactionScope() {
    if (TransactionSupport.current() != null) {
        TransactionSupport.registerRollbackHandler(CommandBase.this);
    }
    // rollback the transaction.
    if (!executeWithoutTransaction()) {
        if (TransactionSupport.current() == null) {
            cancelTasks();
        }
        // we don't want to commit transaction here
        TransactionSupport.setRollbackOnly();
    }
}
#end_block

#method_before
public VdcReturnValueBase getReturnValue() {
    if (_returnValue == null) {
        _returnValue = CreateReturnValue();
    }
    return _returnValue;
}
#method_after
public VdcReturnValueBase getReturnValue() {
    if (_returnValue == null) {
        _returnValue = createReturnValue();
    }
    return _returnValue;
}
#end_block

#method_before
protected void startPollingAsyncTasks(Collection<Guid> taskIds) {
    for (Guid taskID : taskIds) {
        getAsyncTaskManager().StartPollingTask(taskID);
    }
}
#method_after
protected void startPollingAsyncTasks() {
    startPollingAsyncTasks(getReturnValue().getTaskIdList());
}
#end_block

#method_before
protected List<SPMAsyncTaskHandler> getTaskHandlers() {
    return Collections.unmodifiableList(taskHandlers);
}
#method_after
protected List<SPMAsyncTaskHandler> getTaskHandlers() {
    return taskHandlers;
}
#end_block

#method_before
@Override
public VdcReturnValueBase RunAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, false, null);
}
#method_after
@Override
public VdcReturnValueBase RunAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    VdcReturnValueBase returnValue = notAllowToRunAction(actionType);
    if (returnValue != null) {
        return returnValue;
    }
    return runActionImpl(actionType, parameters, false, null);
}
#end_block

#method_before
private VdcReturnValueBase runActionImpl(VdcActionType actionType, VdcActionParametersBase parameters, boolean runAsInternal, CommandContext context) {
    VdcReturnValueBase returnValue = null;
    switch(actionType) {
        case AutoLogin:
            return getErrorReturnValue(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        default:
            {
                // used mainly for safe upgrade and proper handling of left async tasks and compensation.
                if (Config.<Boolean>GetValue(ConfigValues.EngineMaintenanceMode)) {
                    return getErrorReturnValue(VdcBllMessages.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
                }
                // Evaluate and set the correlationId on the parameters, fails on invalid correlation id
                boolean hasCorrelationId = parameters == null ? false : StringUtils.isNotEmpty(parameters.getCorrelationId());
                returnValue = ExecutionHandler.evaluateCorrelationId(parameters);
                if (returnValue != null) {
                    return returnValue;
                }
                CommandBase<?> command = CommandsFactory.CreateCommand(actionType, parameters);
                command.setInternalExecution(runAsInternal);
                command.setContext(context);
                ExecutionHandler.prepareCommandForMonitoring(command, actionType, runAsInternal, hasCorrelationId);
                returnValue = command.executeAction();
                returnValue.setCorrelationId(parameters.getCorrelationId());
                returnValue.setJobId(command.getJobId());
                return returnValue;
            }
    }
}
#method_after
private VdcReturnValueBase runActionImpl(VdcActionType actionType, VdcActionParametersBase parameters, boolean runAsInternal, CommandContext context) {
    VdcReturnValueBase returnValue = null;
    switch(actionType) {
        case AutoLogin:
            return getErrorCommandReturnValue(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        default:
            // Evaluate and set the correlationId on the parameters, fails on invalid correlation id
            boolean hasCorrelationId = parameters == null ? false : StringUtils.isNotEmpty(parameters.getCorrelationId());
            returnValue = ExecutionHandler.evaluateCorrelationId(parameters);
            if (returnValue != null) {
                return returnValue;
            }
            CommandBase<?> command = CommandsFactory.CreateCommand(actionType, parameters);
            command.setInternalExecution(runAsInternal);
            command.setContext(context);
            ExecutionHandler.prepareCommandForMonitoring(command, actionType, runAsInternal, hasCorrelationId);
            returnValue = command.executeAction();
            returnValue.setCorrelationId(parameters.getCorrelationId());
            returnValue.setJobId(command.getJobId());
            return returnValue;
    }
}
#end_block

#method_before
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = addSessionToContext(parameters);
        if (StringUtils.isEmpty(sessionId) || SessionDataContainer.getInstance().getUser(sessionId, parameters.getRefresh()) == null) {
            VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
            returnValue.setSucceeded(false);
            returnValue.setExceptionString(VdcBllMessages.USER_IS_NOT_LOGGED_IN.toString());
            return returnValue;
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters);
    command.setInternalExecution(!isPerformUserCheck);
    command.Execute();
    return command.getQueryReturnValue();
}
#method_after
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = addSessionToContext(parameters);
        if (StringUtils.isEmpty(sessionId) || SessionDataContainer.getInstance().getUser(sessionId, parameters.getRefresh()) == null) {
            return getErrorQueryReturnValue(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        }
    }
    if (EngineWorkingMode.MAINTENANCE == Config.<EngineWorkingMode>GetValue(ConfigValues.EngineMode)) {
        Class<CommandBase<? extends VdcActionParametersBase>> clazz = CommandsFactory.getQueryClass(actionType.name());
        if (clazz.isAnnotationPresent(DisableInMaintenanceMode.class)) {
            return getErrorQueryReturnValue(VdcBllMessages.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters);
    command.setInternalExecution(!isPerformUserCheck);
    command.Execute();
    return command.getQueryReturnValue();
}
#end_block

#method_before
@Override
public ArrayList<VdcReturnValueBase> RunMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isRunOnlyIfAllCanDoPass) {
    return runMultipleActionsImpl(actionType, parameters, false, isRunOnlyIfAllCanDoPass);
}
#method_after
@Override
public ArrayList<VdcReturnValueBase> RunMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isRunOnlyIfAllCanDoPass) {
    VdcReturnValueBase returnValue = notAllowToRunAction(actionType);
    if (returnValue != null) {
        ArrayList<VdcReturnValueBase> list = new ArrayList<VdcReturnValueBase>();
        list.add(returnValue);
        return list;
    } else {
        return runMultipleActionsImpl(actionType, parameters, false, isRunOnlyIfAllCanDoPass);
    }
}
#end_block

#method_before
private static VdcReturnValueBase NotAutorizedError() {
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setCanDoAction(false);
    returnValue.getCanDoActionMessages().add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.toString());
    return returnValue;
}
#method_after
private VdcReturnValueBase NotAutorizedError() {
    return getErrorCommandReturnValue(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
}
#end_block

#method_before
@Override
public VdcQueryReturnValue RunPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    switch(actionType) {
        case GetDomainList:
        case GetLicenseProperties:
        case RegisterVds:
        case CheckDBConnection:
        case ValidateSession:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            {
                GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
                if (configParameters.getConfigValue() == ConfigurationValues.VdcVersion || configParameters.getConfigValue() == ConfigurationValues.ProductRPMVersion || configParameters.getConfigValue() == ConfigurationValues.ApplicationMode) {
                    return runQueryImpl(actionType, parameters, false);
                }
                VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                returnValue.setSucceeded(false);
                returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                return returnValue;
            }
        default:
            {
                VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                returnValue.setSucceeded(false);
                returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                return returnValue;
            }
    }
}
#method_after
@Override
public VdcQueryReturnValue RunPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    switch(actionType) {
        case GetDomainList:
        case GetLicenseProperties:
        case RegisterVds:
        case CheckDBConnection:
        case ValidateSession:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
            if (configParameters.getConfigValue() == ConfigurationValues.VdcVersion || configParameters.getConfigValue() == ConfigurationValues.ProductRPMVersion || configParameters.getConfigValue() == ConfigurationValues.ApplicationMode) {
                return runQueryImpl(actionType, parameters, false);
            }
            return getErrorQueryReturnValue(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC);
        default:
            return getErrorQueryReturnValue(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC);
    }
}
#end_block

#method_before
private VDSExceptionBase createException() {
    VDSExceptionBase outEx;
    final String errorMessage = String.format("Failed to %1$s, error = %2$s", getCommandName(), getReturnStatus().mMessage);
    outEx = createDefaultConcreteException(errorMessage);
    return outEx;
}
#method_after
private VDSExceptionBase createException() {
    final String errorMessage = String.format("Failed to %1$s, error = %2$s", getCommandName(), getReturnStatus().mMessage);
    return createDefaultConcreteException(errorMessage);
}
#end_block

#method_before
@Override
protected VDSExceptionBase createDefaultConcreteException(String errorMessage) {
    VDSExceptionBase outEx = new IrsOperationFailedNoFailoverException(errorMessage);
    return outEx;
}
#method_after
@Override
protected VDSExceptionBase createDefaultConcreteException(String errorMessage) {
    return new IrsOperationFailedNoFailoverException(errorMessage);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = isVmExist() && acquireLockInternal();
    VM vm = getVm();
    if (returnValue && (vm != null && vm.getstatus() == VMStatus.ImageLocked)) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_LOCKED);
    } else {
        // if user sent drive check that its not in use
        returnValue = returnValue && (vm == null || isDiskCanBeAddedToVm(getParameters().getDiskInfo()));
        if (returnValue && DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
            returnValue = checkIfImageDiskCanBeAdded(vm);
        }
        if (returnValue && DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
            returnValue = checkIfLunDiskCanBeAdded();
        }
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = isVmExist() && acquireLockInternal();
    VM vm = getVm();
    // if user sent drive check that its not in use
    returnValue = returnValue && (vm == null || isDiskCanBeAddedToVm(getParameters().getDiskInfo()));
    if (returnValue && DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        returnValue = checkIfImageDiskCanBeAdded(vm);
    }
    if (returnValue && DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        returnValue = checkIfLunDiskCanBeAdded();
    }
    return returnValue;
}
#end_block

#method_before
protected boolean performImagesChecks(VM vm) {
    return ImagesHandler.PerformImagesChecks(vm, getReturnValue().getCanDoActionMessages(), vm.getstorage_pool_id(), getStorageDomainId().getValue(), false, false, false, false, true, false, false, true, Collections.emptyList());
}
#method_after
protected boolean performImagesChecks(VM vm) {
    return ImagesHandler.PerformImagesChecks(vm, getReturnValue().getCanDoActionMessages(), vm.getstorage_pool_id(), getStorageDomainId().getValue(), false, true, false, false, true, false, false, true, null);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDS spmVds = LinqUtils.first(LinqUtils.filter(getAllRunningVdssInPool(), new Predicate<VDS>() {

        @Override
        public boolean eval(VDS vds) {
            return vds.getspm_status() == VdsSpmStatus.SPM;
        }
    }));
    final List<LUNs> luns = getHostLuns(spmVds);
    final Map<String, LUNs> lunsMap = new HashMap<String, LUNs>();
    for (LUNs lun : luns) {
        lunsMap.put(lun.getLUN_id(), lun);
    }
    final List<LUNs> processedLunsList = new ArrayList<LUNs>();
    for (String lunId : getParameters().getLunIds()) {
        LUNs lun = lunsMap.get(lunId);
        if (lun == null) {
            // fail
            ((ConnectAllHostsToLunCommandReturnValue) getReturnValue()).setFailedVds(spmVds);
            ((ConnectAllHostsToLunCommandReturnValue) getReturnValue()).setFailedLun(getDbFacade().getLunDao().get(lunId));
            return;
        }
        lun.setvolume_group_id(getStorageDomain().getstorage());
        processedLunsList.add(lun);
    }
    // connect all vds in pool (except spm) to lun and getDeviceList
    Pair<Boolean, Map<String, List<Guid>>> result = ConnectVdsToLun(processedLunsList);
    if (result.getFirst()) {
        getReturnValue().setActionReturnValue(processedLunsList);
        setCommandShouldBeLogged(false);
        setSucceeded(true);
    } else {
        // disconnect all hosts if connection is not in use by other luns
        Map<String, List<Guid>> processed = result.getSecond();
        for (String lunId : processed.keySet()) {
            for (Guid vdsId : processed.get(lunId)) {
                LUNs lun = lunsMap.get(lunId);
                StorageHelperDirector.getInstance().getItem(getStoragePool().getstorage_pool_type()).DisconnectStorageFromLunByVdsId(getStorageDomain(), vdsId, lun);
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    VDS spmVds = LinqUtils.first(LinqUtils.filter(getAllRunningVdssInPool(), new Predicate<VDS>() {

        @Override
        public boolean eval(VDS vds) {
            return vds.getspm_status() == VdsSpmStatus.SPM;
        }
    }));
    final List<LUNs> luns = getHostLuns(spmVds);
    final Map<String, LUNs> lunsMap = new HashMap<String, LUNs>();
    for (LUNs lun : luns) {
        lunsMap.put(lun.getLUN_id(), lun);
    }
    final List<LUNs> processedLunsList = new ArrayList<LUNs>();
    for (String lunId : getParameters().getLunIds()) {
        LUNs lun = lunsMap.get(lunId);
        if (lun == null) {
            // fail
            final ConnectAllHostsToLunCommandReturnValue result = getResult();
            result.setFailedVds(spmVds);
            result.setFailedLun(getDbFacade().getLunDao().get(lunId));
            return;
        }
        lun.setvolume_group_id(getStorageDomain().getstorage());
        processedLunsList.add(lun);
    }
    // connect all vds in pool (except spm) to lun and getDeviceList
    Pair<Boolean, Map<String, List<Guid>>> result = ConnectVdsToLun(processedLunsList);
    if (result.getFirst()) {
        getReturnValue().setActionReturnValue(processedLunsList);
        setCommandShouldBeLogged(false);
        setSucceeded(true);
    } else {
        // disconnect all hosts if connection is not in use by other luns
        Map<String, List<Guid>> processed = result.getSecond();
        for (String lunId : processed.keySet()) {
            for (Guid vdsId : processed.get(lunId)) {
                LUNs lun = lunsMap.get(lunId);
                StorageHelperDirector.getInstance().getItem(getStoragePool().getstorage_pool_type()).DisconnectStorageFromLunByVdsId(getStorageDomain(), vdsId, lun);
            }
        }
    }
}
#end_block

#method_before
private Pair<Boolean, Map<String, List<Guid>>> ConnectVdsToLun(List<LUNs> luns) {
    Map<String, List<Guid>> resultMap = new HashMap<String, List<Guid>>();
    for (VDS vds : getAllRunningVdssInPool()) {
        // try to connect vds to luns and getDeviceList in order to refresh them
        for (LUNs lun : luns) {
            if (!connectStorageToLunByVdsId(vds, lun)) {
                log.errorFormat("Could not connect host {0} to lun {1}", vds.getvds_name(), lun.getLUN_id());
                setVds(vds);
                ((ConnectAllHostsToLunCommandReturnValue) getReturnValue()).setFailedVds(vds);
                ((ConnectAllHostsToLunCommandReturnValue) getReturnValue()).setFailedLun(lun);
                return new Pair<Boolean, Map<String, List<Guid>>>(Boolean.FALSE, resultMap);
            } else {
                List<Guid> hosts = resultMap.get(lun.getLUN_id());
                if (hosts == null) {
                    hosts = new ArrayList<Guid>();
                    resultMap.put(lun.getLUN_id(), hosts);
                }
                hosts.add(vds.getId());
            }
        }
        // Refresh all connected luns to host
        if (!Config.<Boolean>GetValue(ConfigValues.SupportGetDevicesVisibility, vds.getvds_group_compatibility_version().getValue())) {
            Set<String> hostsLunsIds = new HashSet<String>();
            List<LUNs> hostLuns = getHostLuns(vds);
            for (LUNs lun : hostLuns) {
                hostsLunsIds.add(lun.getLUN_id());
            }
            for (LUNs lun : luns) {
                if (!hostsLunsIds.contains(lun.getLUN_id())) {
                    return new Pair<Boolean, Map<String, List<Guid>>>(Boolean.FALSE, resultMap);
                }
            }
        } else if (!validateConnectedLuns(vds, getParameters().getLunIds())) {
            return new Pair<Boolean, Map<String, List<Guid>>>(Boolean.FALSE, resultMap);
        }
    }
    return new Pair<Boolean, Map<String, List<Guid>>>(Boolean.TRUE, resultMap);
}
#method_after
private Pair<Boolean, Map<String, List<Guid>>> ConnectVdsToLun(List<LUNs> luns) {
    Map<String, List<Guid>> resultMap = new HashMap<String, List<Guid>>();
    for (VDS vds : getAllRunningVdssInPool()) {
        // try to connect vds to luns and getDeviceList in order to refresh them
        for (LUNs lun : luns) {
            if (!connectStorageToLunByVdsId(vds, lun)) {
                log.errorFormat("Could not connect host {0} to lun {1}", vds.getvds_name(), lun.getLUN_id());
                setVds(vds);
                final ConnectAllHostsToLunCommandReturnValue result = getResult();
                result.setFailedVds(vds);
                result.setFailedLun(lun);
                return new Pair<Boolean, Map<String, List<Guid>>>(Boolean.FALSE, resultMap);
            } else {
                List<Guid> hosts = resultMap.get(lun.getLUN_id());
                if (hosts == null) {
                    hosts = new ArrayList<Guid>();
                    resultMap.put(lun.getLUN_id(), hosts);
                }
                hosts.add(vds.getId());
            }
        }
        // Refresh all connected luns to host
        if (!Config.<Boolean>GetValue(ConfigValues.SupportGetDevicesVisibility, vds.getvds_group_compatibility_version().getValue())) {
            Set<String> hostsLunsIds = new HashSet<String>();
            List<LUNs> hostLuns = getHostLuns(vds);
            for (LUNs lun : hostLuns) {
                hostsLunsIds.add(lun.getLUN_id());
            }
            for (LUNs lun : luns) {
                if (!hostsLunsIds.contains(lun.getLUN_id())) {
                    return new Pair<Boolean, Map<String, List<Guid>>>(Boolean.FALSE, resultMap);
                }
            }
        } else if (!validateConnectedLuns(vds, getParameters().getLunIds())) {
            return new Pair<Boolean, Map<String, List<Guid>>>(Boolean.FALSE, resultMap);
        }
    }
    return new Pair<Boolean, Map<String, List<Guid>>>(Boolean.TRUE, resultMap);
}
#end_block

#method_before
private boolean connectStorageToLunByVdsId(VDS vds, LUNs lun) {
    try {
        return StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).ConnectStorageToLunByVdsId(getStorageDomain(), vds.getId(), lun, Guid.Empty);
    } catch (VdcBLLException e) {
        ((ConnectAllHostsToLunCommandReturnValue) getReturnValue()).setFailedVds(vds);
        ((ConnectAllHostsToLunCommandReturnValue) getReturnValue()).setFailedLun(lun);
        throw e;
    }
}
#method_after
private boolean connectStorageToLunByVdsId(VDS vds, LUNs lun) {
    try {
        return StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).ConnectStorageToLunByVdsId(getStorageDomain(), vds.getId(), lun, Guid.Empty);
    } catch (VdcBLLException e) {
        final ConnectAllHostsToLunCommandReturnValue result = getResult();
        result.setFailedVds(vds);
        result.setFailedLun(lun);
        throw e;
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private List<LUNs> getHostLuns(VDS vds) {
    try {
        return (List<LUNs>) runVdsCommand(VDSCommandType.GetDeviceList, new GetDeviceListVDSCommandParameters(vds.getId(), getStorageDomain().getstorage_type())).getReturnValue();
    } catch (VdcBLLException e) {
        ((ConnectAllHostsToLunCommandReturnValue) getReturnValue()).setFailedVds(vds);
        throw e;
    }
}
#method_after
@SuppressWarnings("unchecked")
private List<LUNs> getHostLuns(VDS vds) {
    try {
        return (List<LUNs>) runVdsCommand(VDSCommandType.GetDeviceList, new GetDeviceListVDSCommandParameters(vds.getId(), getStorageDomain().getstorage_type())).getReturnValue();
    } catch (VdcBLLException e) {
        getResult().setFailedVds(vds);
        throw e;
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<storage_pool_iso_map> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    for (storage_pool_iso_map poolDomain : poolDomains) {
        if (poolDomain.getstatus() == StorageDomainStatus.Locked) {
            addInvalidSDStatusMessage(poolDomain.getstatus());
            return false;
        }
    }
    return InitializeVds();
}
#method_after
@Override
protected boolean canDoAction() {
    List<storage_pool_iso_map> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
    for (storage_pool_iso_map poolDomain : poolDomains) {
        if (poolDomain.getstatus() == StorageDomainStatus.Locked) {
            addInvalidSDStatusMessage(poolDomain.getstatus());
            return false;
        }
    }
    return InitializeVds();
}
#end_block

#method_before
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                SetStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    if (!commandSucceeded) {
        return false;
    }
    List<storage_pool_iso_map> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    for (storage_pool_iso_map domain : domains) {
        if (domain.getstatus() == null || domain.getstatus() == StorageDomainStatus.Unknown) {
            domain.setstatus(StorageDomainStatus.Active);
        } else if (domain.getstatus() == StorageDomainStatus.Maintenance) {
            domain.setstatus(StorageDomainStatus.InActive);
        } else if (domain.getstatus() == StorageDomainStatus.Locked) {
            throw new VdcBLLException(VdcBllErrors.CANT_RECONSTRUCT_WHEN_A_DOMAIN_IN_POOL_IS_LOCKED, "Cannot reconstruct master domain when a domain in the " + "pool is locked.");
        }
    }
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#method_after
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<storage_pool_iso_map> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        boolean commandSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(commandSucceeded);
        if (!_isLastMaster && commandSucceeded) {
            SearchParameters p = new SearchParameters(MessageFormat.format(DesktopsInStoragePoolQuery, getStoragePool().getname()), SearchType.VM);
            p.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            List<VM> vmsInPool = (List<VM>) Backend.getInstance().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
            VmCommand.UpdateVmInSpm(getStoragePool().getId(), vmsInPool);
        }
        setSucceeded(commandSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#method_after
@Override
protected void executeCommand() {
    try {
        boolean commandSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(commandSucceeded);
        if (!_isLastMaster && commandSucceeded) {
            SearchParameters p = new SearchParameters(MessageFormat.format(DesktopsInStoragePoolQuery, getStoragePool().getname()), SearchType.VM);
            p.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            List<VM> vmsInPool = (List<VM>) Backend.getInstance().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
            VmCommand.updateVmInSpm(getStoragePool().getId(), vmsInPool);
        }
        setSucceeded(commandSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#end_block

#method_before
protected boolean stopSpm() {
    boolean commandSucceeded = true;
    if (getStoragePool().getspm_vds_id() != null) {
        // if spm host id is different from selected host get the spm
        // in order to try and perform stop spm
        VDS spm = null;
        if (getStoragePool().getspm_vds_id().equals(getVds().getId())) {
            spm = getVds();
        } else {
            spm = DbFacade.getInstance().getVdsDAO().get(getStoragePool().getspm_vds_id());
        }
        if (spm != null) {
            ResetIrsVDSCommandParameters tempVar2 = new ResetIrsVDSCommandParameters(getStoragePool().getId(), spm.gethost_name(), spm.getId());
            tempVar2.setIgnoreStopFailed(true);
            commandSucceeded = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ResetIrs, tempVar2).getSucceeded();
            // if spm host is up switch to use it in the following logic
            if (spm.getstatus() == VDSStatus.Up) {
                setVdsId(spm.getId());
                setVds(spm);
            }
        }
    }
    return commandSucceeded;
}
#method_after
protected boolean stopSpm() {
    boolean commandSucceeded = true;
    if (getStoragePool().getspm_vds_id() != null) {
        // if spm host id is different from selected host get the spm
        // in order to try and perform stop spm
        VDS spm = null;
        if (getStoragePool().getspm_vds_id().equals(getVds().getId())) {
            spm = getVds();
        } else {
            spm = DbFacade.getInstance().getVdsDao().get(getStoragePool().getspm_vds_id());
        }
        if (spm != null) {
            ResetIrsVDSCommandParameters tempVar2 = new ResetIrsVDSCommandParameters(getStoragePool().getId(), spm.gethost_name(), spm.getId());
            tempVar2.setIgnoreStopFailed(true);
            commandSucceeded = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ResetIrs, tempVar2).getSucceeded();
            // if spm host is up switch to use it in the following logic
            if (spm.getstatus() == VDSStatus.Up) {
                setVdsId(spm.getId());
                setVds(spm);
            }
        }
    }
    return commandSucceeded;
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    try {
        for (VDS vds : getAllRunningVdssInPool()) {
            try {
                VDSReturnValue returnValue = null;
                // refresh command shouldn't be executed for the reconstruct initiating host
                if (!_isLastMaster && commandSucceeded && !getVds().equals(vds)) {
                    returnValue = executeRefreshStoragePoolCommand(vds);
                    if (!returnValue.getSucceeded()) {
                        log.errorFormat("Post reconstruct actions (refreshPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnValue.getVdsError().getMessage());
                    }
                }
                // connect to the storage pool.
                if (returnValue == null || returnValue.getSucceeded()) {
                    returnValue = executeConnectStoragePoolCommand(vds);
                    if (!returnValue.getSucceeded()) {
                        log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnValue.getVdsError().getMessage());
                    }
                }
                // only if we deactivate the storage domain we want to disconnect from it.
                if (getParameters().isInactive()) {
                    StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
                }
            } catch (Exception e) {
                log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
            }
        }
    } catch (Exception ex) {
        log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on all up hosts in the pool. error {0}", ex.getMessage());
    }
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    for (VDS vds : getAllRunningVdssInPool()) {
        try {
            if (!_isLastMaster && commandSucceeded) {
                try {
                    runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                } catch (VdcBLLException ex) {
                    if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                        VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                        if (!returnVal.getSucceeded()) {
                            log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                        }
                    } else {
                        log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                    }
                }
            }
            // only if we deactivate the storage domain we want to disconnect from it.
            if (!getParameters().isInactive()) {
                StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
            }
        } catch (Exception e) {
            log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
        }
    }
}
#end_block

#method_before
private boolean checkIfLunDiskCanBeAdded() {
    LUNs lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    if (lun.getLunType() == StorageType.UNKNOWN) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        return false;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUN_id()) != null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
        return false;
    }
    return true;
}
#method_after
protected boolean checkIfLunDiskCanBeAdded() {
    LUNs lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (storage_server_connections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getiqn()) || StringUtils.isEmpty(conn.getconnection()) || StringUtils.isEmpty(conn.getport())) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUN_id()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    return true;
}
#end_block

#method_before
private void createDiskBasedOnImage() {
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setStorageDomainId(getStorageDomainId().getValue());
    parameters.setParentCommand(VdcActionType.AddDisk);
    parameters.setEntityId(getParameters().getEntityId());
    parameters.setStoragePoolId(getStorageDomain().getstorage_pool_id().getValue());
    getParameters().getImagesParameters().add(parameters);
    parameters.setParentParameters(getParameters());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
        getCompensationContext().snapshotNewEntity(VmDeviceUtils.addManagedDevice(new VmDeviceId(getParameters().getDiskInfo().getId(), getVmId()), VmDeviceType.DISK, VmDeviceType.DISK, null, getVm().getstatus() == VMStatus.Down, false));
        getCompensationContext().stateChanged();
    }
    VdcReturnValueBase tmpRetValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, parameters, ExecutionHandler.createDefaultContexForTasks(getExecutionContext(), getLock()));
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getReturnValue().getTaskIdList().addAll(tmpRetValue.getInternalTaskIdList());
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
private void createDiskBasedOnImage() {
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setStorageDomainId(getStorageDomainId().getValue());
    parameters.setParentCommand(VdcActionType.AddDisk);
    parameters.setEntityId(getParameters().getEntityId());
    parameters.setStoragePoolId(getStorageDomain().getstorage_pool_id().getValue());
    getParameters().getImagesParameters().add(parameters);
    parameters.setParentParameters(getParameters());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
        getCompensationContext().snapshotNewEntity(VmDeviceUtils.addManagedDevice(new VmDeviceId(getParameters().getDiskInfo().getId(), getVmId()), VmDeviceType.DISK, VmDeviceType.DISK, null, getVm().getstatus() == VMStatus.Down, false));
        getCompensationContext().stateChanged();
    }
    VdcReturnValueBase tmpRetValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, parameters, ExecutionHandler.createDefaultContexForTasks(getExecutionContext(), getLock()));
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getReturnValue().getTaskIdList().addAll(tmpRetValue.getInternalTaskIdList());
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
@Override
public Response add(Disk disk) {
    validateEnums(Disk.class, disk);
    if (disk.isSetId()) {
        return Response.fromResponse(attachDiskToVm(disk)).entity(getDeviceSubResource(disk.getId()).get()).build();
    } else {
        return super.add(disk);
    }
}
#method_after
@Override
public Response add(Disk disk) {
    validateEnums(Disk.class, disk);
    if (disk.isSetId()) {
        return Response.fromResponse(attachDiskToVm(disk)).entity(lookupEntity(asGuid(disk.getId()))).build();
    } else {
        validateParameters(disk, "format", "interface");
        if (!disk.isSetLunStorage() || disk.getLunStorage().getLogicalUnits().isEmpty()) {
            // lun-disk does not
            // require
            // size
            validateParameters(disk, "provisionedSize|size");
        }
        return performCreation(addAction, getAddParameters(map(disk), disk), getEntityIdResolver(disk.getName()));
    }
}
#end_block

#method_before
@Test
public void testAddDisk() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpEntityQueryExpectations(VdcQueryType.GetAllDisksByVmId, GetAllDisksByVmIdParameters.class, new String[] { "VmId" }, new Object[] { PARENT_ID }, asList(getEntity(0)));
    setUpCreationExpectations(VdcActionType.AddDisk, AddDiskParameters.class, new String[] { "VmId", "StorageDomainId" }, new Object[] { PARENT_ID, GUIDS[2] }, true, true, GUIDS[0], asList(GUIDS[3]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetAllDisksByVmId, GetAllDisksByVmIdParameters.class, new String[] { "VmId" }, new Object[] { PARENT_ID }, asList(getEntity(0)));
    Disk model = getModel(0);
    model.setSize(1024 * 1024L);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Disk);
    verifyModel((Disk) response.getEntity(), 0);
    assertNull(((Disk) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddDisk() throws Exception {
    testAddDiskImpl(getModel(0));
}
#end_block

#method_before
@Test
public void testAddIncompleteParameters() throws Exception {
    Disk model = new Disk();
    model.setName(NAMES[0]);
    setUriInfo(setUpBasicUriExpectations());
    control.replay();
    try {
        collection.add(model);
        fail("expected WebApplicationException on incomplete parameters");
    } catch (WebApplicationException wae) {
        verifyIncompleteException(wae, "Disk", "add", "provisionedSize|size", "format", "interface");
    }
}
#method_after
@Test
public void testAddIncompleteParameters() throws Exception {
    Disk model = new Disk();
    model.setName(NAMES[0]);
    setUriInfo(setUpBasicUriExpectations());
    control.replay();
    try {
        collection.add(model);
        fail("expected WebApplicationException on incomplete parameters");
    } catch (WebApplicationException wae) {
        verifyIncompleteException(wae, "Disk", "add", "format", "interface");
    }
}
#end_block

#method_before
public static QuotaDAO getQuotaDAO() {
    return DbFacade.getInstance().getQuotaDao();
}
#method_after
protected QuotaDAO getQuotaDAO() {
    return DbFacade.getInstance().getQuotaDao();
}
#end_block

#method_before
private boolean validateAndSetStorageQuotaHelper(storage_pool storagePool, List<StorageQuotaValidationParameter> parameters, ArrayList<String> canDoActionMessages, boolean isIncrease) {
    Pair<AuditLogType, AuditLogableBase> logPair = new Pair<AuditLogType, AuditLogableBase>();
    lock.readLock().lock();
    try {
        if (storagePool == null) {
            log.debug("Null storage pool was passed to 'QuotaManager.validateAndSetStorageQuota()'");
            if (parameters.isEmpty() || parameters.get(0).getQuotaId() == null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            }
            storagePool = extractStoragePoolFromQuota(parameters.get(0).getQuotaId());
        }
        if (QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) {
            return true;
        }
        for (StorageQuotaValidationParameter param : parameters) {
            if (param.getQuotaId() == null || param.getStorageDomainId() == null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            }
        }
        if (!storagePoolQuotaMap.containsKey(storagePool.getId())) {
            storagePoolQuotaMap.putIfAbsent(storagePool.getId(), new HashMap<Guid, Quota>());
        }
        synchronized (storagePoolQuotaMap.get(storagePool.getId())) {
            if (storagePoolQuotaMap.get(storagePool.getId()) == null) {
                return false;
            }
            Map<Guid, Quota> quotaMap = storagePoolQuotaMap.get(storagePool.getId());
            Map<Guid, Map<Guid, Double>> desiredStorageSizeQuotaMap = new HashMap<Guid, Map<Guid, Double>>();
            Map<Guid, Double> newUsedGlobalStorageSize = new HashMap<Guid, Double>();
            Map<Guid, Map<Guid, Double>> newUsedSpecificStorageSize = new HashMap<Guid, Map<Guid, Double>>();
            for (StorageQuotaValidationParameter param : parameters) {
                Quota quota;
                if (!quotaMap.containsKey(param.getQuotaId())) {
                    quota = getQuotaDAO().getById(param.getQuotaId());
                    if (quota == null) {
                        canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                        return false;
                    }
                    quotaMap.put(quota.getId(), quota);
                } else {
                    quota = quotaMap.get(param.getQuotaId());
                }
                if (!desiredStorageSizeQuotaMap.containsKey(quota.getId())) {
                    desiredStorageSizeQuotaMap.put(quota.getId(), new HashMap<Guid, Double>());
                }
                Map<Guid, Double> quotaStorageMap = desiredStorageSizeQuotaMap.get(quota.getId());
                if (!quotaStorageMap.containsKey(param.getStorageDomainId())) {
                    quotaStorageMap.put(param.getStorageDomainId(), 0.0);
                }
                quotaStorageMap.put(param.getStorageDomainId(), quotaStorageMap.get(param.getStorageDomainId()) + param.getSize());
            }
            for (Guid quotaId : desiredStorageSizeQuotaMap.keySet()) {
                Quota quota = quotaMap.get(quotaId);
                if (quota.getGlobalQuotaStorage() != null) {
                    // global storage quota
                    if (quota.getGlobalQuotaStorage().getStorageSizeGB() != UNLIMITED) {
                        double sum = 0.0;
                        for (Double size : desiredStorageSizeQuotaMap.get(quotaId).values()) {
                            sum += size;
                        }
                        double storageUsagePercentage = quota.getGlobalQuotaStorage().getStorageSizeGBUsage() / quota.getGlobalQuotaStorage().getStorageSizeGB() * 100;
                        double storageRequestPercentage = sum / quota.getGlobalQuotaStorage().getStorageSizeGB() * 100;
                        if (!checkQuotaStorageLimits(storagePool.getQuotaEnforcementType(), quota, quota.getGlobalQuotaStorage().getStorageSizeGB(), storageUsagePercentage, storageRequestPercentage, canDoActionMessages, logPair)) {
                            return false;
                        }
                        newUsedGlobalStorageSize.put(quotaId, sum + quota.getGlobalQuotaStorage().getStorageSizeGBUsage());
                    }
                } else {
                    newUsedSpecificStorageSize.put(quotaId, new HashMap<Guid, Double>());
                    for (Guid storageId : desiredStorageSizeQuotaMap.get(quotaId).keySet()) {
                        boolean hasStorageId = false;
                        for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
                            if (quotaStorage.getStorageId().equals(storageId)) {
                                hasStorageId = true;
                                if (quotaStorage.getStorageSizeGB() != UNLIMITED) {
                                    double storageUsagePercentage = quotaStorage.getStorageSizeGBUsage() / quotaStorage.getStorageSizeGB() * 100;
                                    double storageRequestPercentage = desiredStorageSizeQuotaMap.get(quotaId).get(storageId) / quotaStorage.getStorageSizeGB() * 100;
                                    if (!checkQuotaStorageLimits(storagePool.getQuotaEnforcementType(), quota, quotaStorage.getStorageSizeGB(), storageUsagePercentage, storageRequestPercentage, canDoActionMessages, logPair)) {
                                        return false;
                                    }
                                    newUsedSpecificStorageSize.get(quotaId).put(storageId, quotaStorage.getStorageSizeGBUsage() + desiredStorageSizeQuotaMap.get(quotaId).get(storageId));
                                    break;
                                }
                            }
                        }
                        if (!hasStorageId) {
                            canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_NO_QUOTA_SET_FOR_DOMAIN.toString());
                            return false;
                        }
                    }
                }
            }
            // cache new storage size.
            for (Guid quotaId : newUsedGlobalStorageSize.keySet()) {
                Quota quota = quotaMap.get(quotaId);
                double value = newUsedGlobalStorageSize.get(quotaId);
                if (value < 0) {
                    log.errorFormat("Quota id {0} cached storage size is negative, removing from cache", quotaId);
                    quotaMap.remove(quotaId);
                    continue;
                }
                quota.getGlobalQuotaStorage().setStorageSizeGBUsage(value);
            }
            for (Guid quotaId : newUsedSpecificStorageSize.keySet()) {
                Quota quota = quotaMap.get(quotaId);
                for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
                    if (newUsedSpecificStorageSize.get(quotaId).containsKey(quotaStorage.getStorageId())) {
                        double value = newUsedSpecificStorageSize.get(quotaId).get(quotaStorage.getStorageId());
                        if (value < 0) {
                            log.errorFormat("Quota id {0} cached storage size is negative, removing from cache", quotaId);
                            quotaMap.remove(quotaId);
                            continue;
                        }
                        quotaStorage.setStorageSizeGBUsage(value);
                    }
                }
            }
        }
        return true;
    } finally {
        lock.readLock().unlock();
        if (logPair.getFirst() != null) {
            AuditLogDirector.log(logPair.getSecond(), logPair.getFirst());
        }
    }
}
#method_after
private boolean validateAndSetStorageQuotaHelper(storage_pool storagePool, List<StorageQuotaValidationParameter> parameters, ArrayList<String> canDoActionMessages, boolean isIncrease) {
    Pair<AuditLogType, AuditLogableBase> logPair = new Pair<AuditLogType, AuditLogableBase>();
    lock.readLock().lock();
    try {
        if (storagePool == null) {
            log.debug("Null storage pool was passed to 'QuotaManager.validateAndSetStorageQuota()'");
            if (parameters.isEmpty() || parameters.get(0).getQuotaId() == null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            }
            storagePool = extractStoragePoolFromQuota(parameters.get(0).getQuotaId());
        }
        if (QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) {
            return true;
        }
        for (StorageQuotaValidationParameter param : parameters) {
            if (param.getQuotaId() == null || Guid.Empty.equals(param.getQuotaId()) || param.getStorageDomainId() == null) {
                if (QuotaEnforcementTypeEnum.HARD_ENFORCEMENT.equals(storagePool.getQuotaEnforcementType())) {
                    canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                    return false;
                } else {
                    logPair.setFirst(AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE);
                    logPair.setSecond(new AuditLogableBase());
                    return true;
                }
            }
        }
        if (!storagePoolQuotaMap.containsKey(storagePool.getId())) {
            storagePoolQuotaMap.putIfAbsent(storagePool.getId(), new HashMap<Guid, Quota>());
        }
        synchronized (storagePoolQuotaMap.get(storagePool.getId())) {
            if (storagePoolQuotaMap.get(storagePool.getId()) == null) {
                return false;
            }
            Map<Guid, Quota> quotaMap = storagePoolQuotaMap.get(storagePool.getId());
            Map<Guid, Map<Guid, Double>> desiredStorageSizeQuotaMap = new HashMap<Guid, Map<Guid, Double>>();
            Map<Guid, Double> newUsedGlobalStorageSize = new HashMap<Guid, Double>();
            Map<Guid, Map<Guid, Double>> newUsedSpecificStorageSize = new HashMap<Guid, Map<Guid, Double>>();
            for (StorageQuotaValidationParameter param : parameters) {
                Quota quota;
                if (!quotaMap.containsKey(param.getQuotaId())) {
                    quota = getQuotaDAO().getById(param.getQuotaId());
                    if (quota == null) {
                        canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                        return false;
                    }
                    quotaMap.put(quota.getId(), quota);
                } else {
                    quota = quotaMap.get(param.getQuotaId());
                }
                if (!desiredStorageSizeQuotaMap.containsKey(quota.getId())) {
                    desiredStorageSizeQuotaMap.put(quota.getId(), new HashMap<Guid, Double>());
                }
                Map<Guid, Double> quotaStorageMap = desiredStorageSizeQuotaMap.get(quota.getId());
                if (!quotaStorageMap.containsKey(param.getStorageDomainId())) {
                    quotaStorageMap.put(param.getStorageDomainId(), 0.0);
                }
                quotaStorageMap.put(param.getStorageDomainId(), quotaStorageMap.get(param.getStorageDomainId()) + param.getSize());
            }
            for (Guid quotaId : desiredStorageSizeQuotaMap.keySet()) {
                Quota quota = quotaMap.get(quotaId);
                if (quota.getGlobalQuotaStorage() != null) {
                    // global storage quota
                    if (quota.getGlobalQuotaStorage().getStorageSizeGB() != UNLIMITED) {
                        double sum = 0.0;
                        for (Double size : desiredStorageSizeQuotaMap.get(quotaId).values()) {
                            sum += size;
                        }
                        double storageUsagePercentage = quota.getGlobalQuotaStorage().getStorageSizeGBUsage() / quota.getGlobalQuotaStorage().getStorageSizeGB() * 100;
                        double storageRequestPercentage = sum / quota.getGlobalQuotaStorage().getStorageSizeGB() * 100;
                        if (!checkQuotaStorageLimits(storagePool.getQuotaEnforcementType(), quota, quota.getGlobalQuotaStorage().getStorageSizeGB(), storageUsagePercentage, storageRequestPercentage, canDoActionMessages, logPair)) {
                            return false;
                        }
                        newUsedGlobalStorageSize.put(quotaId, sum + quota.getGlobalQuotaStorage().getStorageSizeGBUsage());
                    }
                } else {
                    newUsedSpecificStorageSize.put(quotaId, new HashMap<Guid, Double>());
                    for (Guid storageId : desiredStorageSizeQuotaMap.get(quotaId).keySet()) {
                        boolean hasStorageId = false;
                        for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
                            if (quotaStorage.getStorageId().equals(storageId)) {
                                hasStorageId = true;
                                if (quotaStorage.getStorageSizeGB() != UNLIMITED) {
                                    double storageUsagePercentage = quotaStorage.getStorageSizeGBUsage() / quotaStorage.getStorageSizeGB() * 100;
                                    double storageRequestPercentage = desiredStorageSizeQuotaMap.get(quotaId).get(storageId) / quotaStorage.getStorageSizeGB() * 100;
                                    if (!checkQuotaStorageLimits(storagePool.getQuotaEnforcementType(), quota, quotaStorage.getStorageSizeGB(), storageUsagePercentage, storageRequestPercentage, canDoActionMessages, logPair)) {
                                        return false;
                                    }
                                    newUsedSpecificStorageSize.get(quotaId).put(storageId, quotaStorage.getStorageSizeGBUsage() + desiredStorageSizeQuotaMap.get(quotaId).get(storageId));
                                    break;
                                }
                            }
                        }
                        if (!hasStorageId) {
                            canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_NO_QUOTA_SET_FOR_DOMAIN.toString());
                            return false;
                        }
                    }
                }
            }
            // cache new storage size.
            for (Guid quotaId : newUsedGlobalStorageSize.keySet()) {
                Quota quota = quotaMap.get(quotaId);
                double value = newUsedGlobalStorageSize.get(quotaId);
                if (value < 0) {
                    log.errorFormat("Quota id {0} cached storage size is negative, removing from cache", quotaId);
                    quotaMap.remove(quotaId);
                    continue;
                }
                quota.getGlobalQuotaStorage().setStorageSizeGBUsage(value);
            }
            for (Guid quotaId : newUsedSpecificStorageSize.keySet()) {
                Quota quota = quotaMap.get(quotaId);
                for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
                    if (newUsedSpecificStorageSize.get(quotaId).containsKey(quotaStorage.getStorageId())) {
                        double value = newUsedSpecificStorageSize.get(quotaId).get(quotaStorage.getStorageId());
                        if (value < 0) {
                            log.errorFormat("Quota id {0} cached storage size is negative, removing from cache", quotaId);
                            quotaMap.remove(quotaId);
                            continue;
                        }
                        quotaStorage.setStorageSizeGBUsage(value);
                    }
                }
            }
        }
        return true;
    } finally {
        lock.readLock().unlock();
        auditLog(logPair);
    }
}
#end_block

#method_before
public boolean validateQuotaForStoragePool(storage_pool storagePool, Guid vdsGroupId, Guid quotaId, ArrayList<String> canDoActionMessages) {
    lock.readLock().lock();
    try {
        if (QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) {
            return true;
        }
        if (vdsGroupId == null || vdsGroupId.equals(Guid.Empty) || quotaId == null) {
            canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
            return false;
        }
        if (!storagePoolQuotaMap.containsKey(storagePool.getId())) {
            storagePoolQuotaMap.putIfAbsent(storagePool.getId(), new HashMap<Guid, Quota>());
        }
        synchronized (storagePoolQuotaMap.get(storagePool.getId())) {
            Map<Guid, Quota> quotaMap = storagePoolQuotaMap.get(storagePool.getId());
            if (quotaMap == null) {
                return false;
            }
            Quota quota = null;
            if (!quotaMap.containsKey(quotaId)) {
                quota = getQuotaDAO().getById(quotaId);
                if (quota == null) {
                    canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
                    log.errorFormat("The quota id {0} is not found in backend and DB.", quotaId.toString());
                    return false;
                }
                quotaMap.put(quota.getId(), quota);
            } else {
                quota = quotaMap.get(quotaId);
            }
            if (quota.getGlobalQuotaVdsGroup() != null) {
                // global cluster quota
                return true;
            } else {
                boolean hasVdsGroup = false;
                for (QuotaVdsGroup vdsGroup : quota.getQuotaVdsGroups()) {
                    if (vdsGroup.getVdsGroupId().equals(vdsGroupId)) {
                        hasVdsGroup = true;
                        break;
                    }
                }
                if (hasVdsGroup) {
                    return true;
                }
            }
        }
        canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        return false;
    } finally {
        lock.readLock().unlock();
    }
}
#method_after
public boolean validateQuotaForStoragePool(storage_pool storagePool, Guid vdsGroupId, Guid quotaId, ArrayList<String> canDoActionMessages) {
    Pair<AuditLogType, AuditLogableBase> logPair = new Pair<AuditLogType, AuditLogableBase>();
    lock.readLock().lock();
    try {
        if (QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) {
            return true;
        }
        if (vdsGroupId == null || Guid.Empty.equals(vdsGroupId) || quotaId == null || Guid.Empty.equals(quotaId)) {
            if (QuotaEnforcementTypeEnum.HARD_ENFORCEMENT.equals(storagePool.getQuotaEnforcementType())) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            } else {
                logPair.setFirst(AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
                logPair.setSecond(new AuditLogableBase());
                return true;
            }
        }
        if (!storagePoolQuotaMap.containsKey(storagePool.getId())) {
            storagePoolQuotaMap.putIfAbsent(storagePool.getId(), new HashMap<Guid, Quota>());
        }
        synchronized (storagePoolQuotaMap.get(storagePool.getId())) {
            Map<Guid, Quota> quotaMap = storagePoolQuotaMap.get(storagePool.getId());
            if (quotaMap == null) {
                return false;
            }
            Quota quota = null;
            if (!quotaMap.containsKey(quotaId)) {
                quota = getQuotaDAO().getById(quotaId);
                if (quota == null) {
                    canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
                    log.errorFormat("The quota id {0} is not found in backend and DB.", quotaId.toString());
                    return false;
                }
                quotaMap.put(quota.getId(), quota);
            } else {
                quota = quotaMap.get(quotaId);
            }
            if (quota.getGlobalQuotaVdsGroup() != null) {
                // global cluster quota
                return true;
            } else {
                boolean hasVdsGroup = false;
                for (QuotaVdsGroup vdsGroup : quota.getQuotaVdsGroups()) {
                    if (vdsGroup.getVdsGroupId().equals(vdsGroupId)) {
                        hasVdsGroup = true;
                        break;
                    }
                }
                if (hasVdsGroup) {
                    return true;
                }
            }
        }
        canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        return false;
    } finally {
        lock.readLock().unlock();
        if (logPair.getFirst() != null) {
            AuditLogDirector.log(logPair.getSecond(), logPair.getFirst());
        }
    }
}
#end_block

#method_before
public boolean validateAndSetClusterQuota(storage_pool storagePool, Guid vdsGroupId, Guid quotaId, int vcpu, long mem, ArrayList<String> canDoActionMessages) {
    Pair<AuditLogType, AuditLogableBase> logPair = new Pair<AuditLogType, AuditLogableBase>();
    try {
        if (storagePool == null) {
            log.debug("Null storage pool was passed to 'QuotaManager.validateAndSetStorageQuota()'");
            if (quotaId == null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            }
            storagePool = extractStoragePoolFromQuota(quotaId);
        }
        if (QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) {
            return true;
        }
        if (!storagePoolQuotaMap.containsKey(storagePool.getId())) {
            storagePoolQuotaMap.putIfAbsent(storagePool.getId(), new HashMap<Guid, Quota>());
        }
        synchronized (storagePoolQuotaMap.get(storagePool.getId())) {
            if (!validateQuotaForStoragePool(storagePool, vdsGroupId, quotaId, canDoActionMessages)) {
                return false;
            }
            Quota quota = storagePoolQuotaMap.get(storagePool.getId()).get(quotaId);
            if (quota == null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            }
            QuotaVdsGroup quotaVdsGroup = null;
            if (quota.getGlobalQuotaVdsGroup() != null) {
                // global cluster quota
                quotaVdsGroup = quota.getGlobalQuotaVdsGroup();
            } else {
                for (QuotaVdsGroup vdsGroup : quota.getQuotaVdsGroups()) {
                    if (vdsGroup.getVdsGroupId().equals(vdsGroupId)) {
                        quotaVdsGroup = vdsGroup;
                        break;
                    }
                }
            }
            if (quotaVdsGroup == null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            }
            boolean success = checkQuotaClusterLimits(storagePool.getQuotaEnforcementType(), quota, quotaVdsGroup, mem, vcpu, canDoActionMessages, logPair);
            if (!success) {
                return false;
            }
        }
        return true;
    } finally {
        if (logPair.getFirst() != null) {
            AuditLogDirector.log(logPair.getSecond(), logPair.getFirst());
        }
    }
}
#method_after
public boolean validateAndSetClusterQuota(storage_pool storagePool, Guid vdsGroupId, Guid quotaId, int vcpu, long mem, ArrayList<String> canDoActionMessages) {
    Pair<AuditLogType, AuditLogableBase> logPair = new Pair<AuditLogType, AuditLogableBase>();
    try {
        if (storagePool == null) {
            log.debug("Null storage pool was passed to 'QuotaManager.validateAndSetStorageQuota()'");
            if (quotaId == null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            }
            storagePool = extractStoragePoolFromQuota(quotaId);
        }
        if (QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) {
            return true;
        }
        if (!storagePoolQuotaMap.containsKey(storagePool.getId())) {
            storagePoolQuotaMap.putIfAbsent(storagePool.getId(), new HashMap<Guid, Quota>());
        }
        synchronized (storagePoolQuotaMap.get(storagePool.getId())) {
            if (!validateQuotaForStoragePool(storagePool, vdsGroupId, quotaId, canDoActionMessages)) {
                return false;
            }
            Quota quota = storagePoolQuotaMap.get(storagePool.getId()).get(quotaId);
            if (quota == null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            }
            QuotaVdsGroup quotaVdsGroup = null;
            if (quota.getGlobalQuotaVdsGroup() != null) {
                // global cluster quota
                quotaVdsGroup = quota.getGlobalQuotaVdsGroup();
            } else {
                for (QuotaVdsGroup vdsGroup : quota.getQuotaVdsGroups()) {
                    if (vdsGroup.getVdsGroupId().equals(vdsGroupId)) {
                        quotaVdsGroup = vdsGroup;
                        break;
                    }
                }
            }
            if (quotaVdsGroup == null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            }
            boolean success = checkQuotaClusterLimits(storagePool.getQuotaEnforcementType(), quota, quotaVdsGroup, mem, vcpu, canDoActionMessages, logPair);
            if (!success) {
                return false;
            }
        }
        return true;
    } finally {
        auditLog(logPair);
    }
}
#end_block

#method_before
@Override
protected void buildVmVideoCards() {
    createInfo.add(VdsProperties.display, vm.getdisplay_type().toString());
    // check if display type was changed in given parameters
    if (vm.getdisplay_type() != vm.getdefault_display_type()) {
        if (vm.getdisplay_type() == DisplayType.vnc) {
            // check spice to vnc change
            XmlRpcStruct struct = new XmlRpcStruct();
            // create a monitor as an unmanaged device
            struct.add(VdsProperties.Type, VmDeviceType.VIDEO.getName());
            struct.add(VdsProperties.Device, VmDeviceType.CIRRUS.getName());
            struct.add(VdsProperties.SpecParams, getNewMonitorSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(Guid.NewGuid()));
            devices.add(struct);
        }
    } else {
        // get vm device for Video Cards from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(vm.getId(), VmDeviceType.VIDEO.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            addAddress(vmDevice, struct);
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            addToManagedDevices(vmDevice);
            devices.add(struct);
        }
    }
}
#method_after
@Override
protected void buildVmVideoCards() {
    createInfo.add(VdsProperties.display, vm.getdisplay_type().toString());
    // check if display type was changed in given parameters
    if (vm.getdisplay_type() != vm.getdefault_display_type()) {
        if (vm.getdisplay_type() == DisplayType.vnc) {
            // check spice to vnc change
            XmlRpcStruct struct = new XmlRpcStruct();
            // create a monitor as an unmanaged device
            struct.add(VdsProperties.Type, VmDeviceType.VIDEO.getName());
            struct.add(VdsProperties.Device, VmDeviceType.CIRRUS.getName());
            struct.add(VdsProperties.SpecParams, getNewMonitorSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(Guid.NewGuid()));
            devices.add(struct);
        }
    } else {
        // get vm device for Video Cards from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vm.getId(), VmDeviceType.VIDEO.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            addAddress(vmDevice, struct);
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            addToManagedDevices(vmDevice);
            devices.add(struct);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmCD() {
    XmlRpcStruct struct;
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.CDROM) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.NewGuid(), vm.getId()), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "");
        struct = new XmlRpcStruct();
        addCdDetails(vmDevice, struct);
        addDevice(struct, vmDevice, "");
    } else // check first if CD was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.NewGuid(), vm.getId()), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "");
        struct = new XmlRpcStruct();
        addCdDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            struct = new XmlRpcStruct();
            String cdPath = vm.getCdPath();
            addCdDetails(vmDevice, struct);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
            // currently only one is supported, may change in future releases
            break;
        }
    }
}
#method_after
@Override
protected void buildVmCD() {
    XmlRpcStruct struct;
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.CDROM) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.NewGuid(), vm.getId()), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "");
        struct = new XmlRpcStruct();
        addCdDetails(vmDevice, struct);
        addDevice(struct, vmDevice, "");
    } else // check first if CD was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.NewGuid(), vm.getId()), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "");
        struct = new XmlRpcStruct();
        addCdDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            struct = new XmlRpcStruct();
            String cdPath = vm.getCdPath();
            addCdDetails(vmDevice, struct);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
            // currently only one is supported, may change in future releases
            break;
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmFloppy() {
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.FLOPPY) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.NewGuid(), vm.getId()), VmDeviceType.DISK.getName(), VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "");
        XmlRpcStruct struct = new XmlRpcStruct();
        addCdDetails(vmDevice, struct);
        addDevice(struct, vmDevice, "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.NewGuid(), vm.getId()), VmDeviceType.DISK.getName(), VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "");
        XmlRpcStruct struct = new XmlRpcStruct();
        addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.DISK.getName(), VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            XmlRpcStruct struct = new XmlRpcStruct();
            String file = vm.getFloppyPath();
            addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#method_after
@Override
protected void buildVmFloppy() {
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.FLOPPY) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.NewGuid(), vm.getId()), VmDeviceType.DISK.getName(), VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "");
        XmlRpcStruct struct = new XmlRpcStruct();
        addCdDetails(vmDevice, struct);
        addDevice(struct, vmDevice, "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.NewGuid(), vm.getId()), VmDeviceType.DISK.getName(), VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "");
        XmlRpcStruct struct = new XmlRpcStruct();
        addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.DISK.getName(), VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            XmlRpcStruct struct = new XmlRpcStruct();
            String file = vm.getFloppyPath();
            addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    // \\int ideCount = 0, pciCount = 0;
    List<Disk> disks = getSortedDisks();
    for (Disk disk : disks) {
        XmlRpcStruct struct = new XmlRpcStruct();
        // get vm device for this disk from DB
        VmDevice vmDevice = DbFacade.getInstance().getVmDeviceDAO().get(new VmDeviceId(disk.getId(), vm.getId()));
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.add(VdsProperties.Iface, "ide");
                    // \\ideCount++;
                    break;
                case VirtIO:
                    struct.add(VdsProperties.Iface, VdsProperties.Virtio);
                    // \\pciCount++;
                    break;
                default:
                    // ISCI not supported
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first.
            if (disk.isBoot()) {
                struct.add(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.add(VdsProperties.PoolId, diskImage.getstorage_pool_id().toString());
                struct.add(VdsProperties.DomainId, diskImage.getstorage_ids().get(0).toString());
                struct.add(VdsProperties.ImageId, diskImage.getId().toString());
                struct.add(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.add(VdsProperties.Format, diskImage.getvolume_format().toString().toLowerCase());
                struct.add(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.add(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.add(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.add(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.add(VdsProperties.Shareable, String.valueOf(disk.isShareable()));
            struct.add(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.add(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#method_after
@Override
protected void buildVmDrives() {
    // \\int ideCount = 0, pciCount = 0;
    List<Disk> disks = getSortedDisks();
    for (Disk disk : disks) {
        XmlRpcStruct struct = new XmlRpcStruct();
        // get vm device for this disk from DB
        VmDevice vmDevice = DbFacade.getInstance().getVmDeviceDao().get(new VmDeviceId(disk.getId(), vm.getId()));
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.add(VdsProperties.Iface, "ide");
                    // \\ideCount++;
                    break;
                case VirtIO:
                    struct.add(VdsProperties.Iface, VdsProperties.Virtio);
                    // \\pciCount++;
                    break;
                default:
                    // ISCI not supported
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first.
            if (disk.isBoot()) {
                struct.add(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.add(VdsProperties.PoolId, diskImage.getstorage_pool_id().toString());
                struct.add(VdsProperties.DomainId, diskImage.getstorage_ids().get(0).toString());
                struct.add(VdsProperties.ImageId, diskImage.getId().toString());
                struct.add(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.add(VdsProperties.Format, diskImage.getvolume_format().toString().toLowerCase());
                struct.add(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.add(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.add(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.add(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.add(VdsProperties.Shareable, String.valueOf(disk.isShareable()));
            struct.add(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.add(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmNetworkInterfaces() {
    Boolean useRtl8139_pv = Config.<Boolean>GetValue(ConfigValues.UseRtl8139_pv, vm.getvds_group_compatibility_version().toString());
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.INTERFACE.getName(), VmDeviceType.BRIDGE.getName()));
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        // get vm device for this disk from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId().getValue()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            XmlRpcStruct struct = new XmlRpcStruct();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (ifaceType == VmInterfaceType.rtl8139_pv) {
                if (!useRtl8139_pv) {
                    if (vm.getHasAgent()) {
                        addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.pv.name(), vm.getvds_group_compatibility_version());
                    } else {
                        addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.rtl8139.name(), vm.getvds_group_compatibility_version());
                    }
                } else {
                    addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.pv.name(), vm.getvds_group_compatibility_version());
                    // Doual Mode: in this case we have to insert 2 interfaces with the same entries except nicModel
                    XmlRpcStruct rtl8139Struct = new XmlRpcStruct();
                    addNetworkInterfaceProperties(rtl8139Struct, vmInterface, vmDevice, VmInterfaceType.rtl8139.name(), vm.getvds_group_compatibility_version());
                    devices.add(rtl8139Struct);
                }
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, ifaceType.toString(), vm.getvds_group_compatibility_version());
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#method_after
@Override
protected void buildVmNetworkInterfaces() {
    Boolean useRtl8139_pv = Config.<Boolean>GetValue(ConfigValues.UseRtl8139_pv, vm.getvds_group_compatibility_version().toString());
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.INTERFACE.getName(), VmDeviceType.BRIDGE.getName()));
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        // get vm device for this disk from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId().getValue()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            XmlRpcStruct struct = new XmlRpcStruct();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (ifaceType == VmInterfaceType.rtl8139_pv) {
                if (!useRtl8139_pv) {
                    if (vm.getHasAgent()) {
                        addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.pv.name(), vm.getvds_group_compatibility_version());
                    } else {
                        addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.rtl8139.name(), vm.getvds_group_compatibility_version());
                    }
                } else {
                    addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.pv.name(), vm.getvds_group_compatibility_version());
                    // Doual Mode: in this case we have to insert 2 interfaces with the same entries except nicModel
                    XmlRpcStruct rtl8139Struct = new XmlRpcStruct();
                    addNetworkInterfaceProperties(rtl8139Struct, vmInterface, vmDevice, VmInterfaceType.rtl8139.name(), vm.getvds_group_compatibility_version());
                    devices.add(rtl8139Struct);
                }
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, ifaceType.toString(), vm.getvds_group_compatibility_version());
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmSoundDevices() {
    if (vm.getvm_type() == VmType.Desktop) {
        // get vm device for Sound device from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(vm.getId(), VmDeviceType.SOUND.getName());
        for (VmDevice vmDevice : vmDevices) {
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            addAddress(vmDevice, struct);
            devices.add(struct);
        }
    }
}
#method_after
@Override
protected void buildVmSoundDevices() {
    if (vm.getvm_type() == VmType.Desktop) {
        // get vm device for Sound device from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vm.getId(), VmDeviceType.SOUND.getName());
        for (VmDevice vmDevice : vmDevices) {
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            addAddress(vmDevice, struct);
            devices.add(struct);
        }
    }
}
#end_block

#method_before
@Override
protected void buildUnmanagedDevices() {
    @SuppressWarnings("unchecked")
    Map<String, String> customMap = (createInfo.containsKey(VdsProperties.Custom)) ? (Map<String, String>) createInfo.getItem(VdsProperties.Custom) : new HashMap<String, String>();
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDAO().getUnmanagedDevicesByVmId(vm.getId());
    if (vmDevices.size() > 0) {
        StringBuilder id = new StringBuilder();
        for (VmDevice vmDevice : vmDevices) {
            XmlRpcStruct struct = new XmlRpcStruct();
            id.append(VdsProperties.Device);
            id.append("_");
            id.append(vmDevice.getDeviceId());
            if (VmDeviceCommonUtils.isInWhiteList(vmDevice.getType(), vmDevice.getDevice())) {
                struct.add(VdsProperties.Type, vmDevice.getType());
                struct.add(VdsProperties.Device, vmDevice.getDevice());
                addAddress(vmDevice, struct);
                struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
                struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
                devices.add(struct);
            } else {
                customMap.put(id.toString(), vmDevice.toString());
            }
        }
    }
    createInfo.add(VdsProperties.Custom, customMap);
    XmlRpcStruct[] devArray = new XmlRpcStruct[devices.size()];
    createInfo.add(DEVICES, devices.toArray(devArray));
}
#method_after
@Override
protected void buildUnmanagedDevices() {
    @SuppressWarnings("unchecked")
    Map<String, String> customMap = (createInfo.containsKey(VdsProperties.Custom)) ? (Map<String, String>) createInfo.getItem(VdsProperties.Custom) : new HashMap<String, String>();
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getUnmanagedDevicesByVmId(vm.getId());
    if (vmDevices.size() > 0) {
        StringBuilder id = new StringBuilder();
        for (VmDevice vmDevice : vmDevices) {
            XmlRpcStruct struct = new XmlRpcStruct();
            id.append(VdsProperties.Device);
            id.append("_");
            id.append(vmDevice.getDeviceId());
            if (VmDeviceCommonUtils.isInWhiteList(vmDevice.getType(), vmDevice.getDevice())) {
                struct.add(VdsProperties.Type, vmDevice.getType());
                struct.add(VdsProperties.Device, vmDevice.getDevice());
                addAddress(vmDevice, struct);
                struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
                struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
                devices.add(struct);
            } else {
                customMap.put(id.toString(), vmDevice.toString());
            }
        }
    }
    createInfo.add(VdsProperties.Custom, customMap);
    XmlRpcStruct[] devArray = new XmlRpcStruct[devices.size()];
    createInfo.add(DEVICES, devices.toArray(devArray));
}
#end_block

#method_before
private void buildVmUsbControllers() {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.CONTROLLER.getName(), VmDeviceType.USB.getName());
    for (VmDevice vmDevice : vmDevices) {
        XmlRpcStruct struct = new XmlRpcStruct();
        struct.add(VdsProperties.Type, vmDevice.getType());
        struct.add(VdsProperties.Device, vmDevice.getDevice());
        setVdsPropertiesFromSpecParams(vmDevice.getSpecParams(), struct);
        struct.add(VdsProperties.SpecParams, new HashMap<String, Object>());
        struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
        addAddress(vmDevice, struct);
        String model = (String) struct.getItem(VdsProperties.Model);
        // This is a workaround until libvirt will fix the requirement to order these controllers
        if (model != null && isFirstMasterController(model)) {
            devices.add(0, struct);
        } else {
            devices.add(struct);
        }
    }
}
#method_after
private void buildVmUsbControllers() {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.CONTROLLER.getName(), VmDeviceType.USB.getName());
    for (VmDevice vmDevice : vmDevices) {
        XmlRpcStruct struct = new XmlRpcStruct();
        struct.add(VdsProperties.Type, vmDevice.getType());
        struct.add(VdsProperties.Device, vmDevice.getDevice());
        setVdsPropertiesFromSpecParams(vmDevice.getSpecParams(), struct);
        struct.add(VdsProperties.SpecParams, new HashMap<String, Object>());
        struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
        addAddress(vmDevice, struct);
        String model = (String) struct.getItem(VdsProperties.Model);
        // This is a workaround until libvirt will fix the requirement to order these controllers
        if (model != null && isFirstMasterController(model)) {
            devices.add(0, struct);
        } else {
            devices.add(struct);
        }
    }
}
#end_block

#method_before
private void buildVmUsbSlots() {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.REDIR.getName(), VmDeviceType.SPICEVMC.getName());
    for (VmDevice vmDevice : vmDevices) {
        XmlRpcStruct struct = new XmlRpcStruct();
        struct.add(VdsProperties.Type, vmDevice.getType());
        struct.add(VdsProperties.Device, vmDevice.getDevice());
        struct.add(VdsProperties.Bus, USB_BUS);
        struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
        struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
        addAddress(vmDevice, struct);
        devices.add(struct);
    }
}
#method_after
private void buildVmUsbSlots() {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.REDIR.getName(), VmDeviceType.SPICEVMC.getName());
    for (VmDevice vmDevice : vmDevices) {
        XmlRpcStruct struct = new XmlRpcStruct();
        struct.add(VdsProperties.Type, vmDevice.getType());
        struct.add(VdsProperties.Device, vmDevice.getDevice());
        struct.add(VdsProperties.Bus, USB_BUS);
        struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
        struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
        addAddress(vmDevice, struct);
        devices.add(struct);
    }
}
#end_block

#method_before
@Override
protected void buildVmMemoryBalloon() {
    if (vm.isRunOnce() && vm.isBalloonEnabled()) {
        Map<String, Object> specParams = new HashMap<String, Object>();
        specParams.put(VdsProperties.Model, VdsProperties.Virtio);
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.NewGuid(), vm.getId()), VmDeviceType.BALLOON.getName(), VmDeviceType.MEMBALLOON.getName(), "", 0, specParams, true, true, true, "");
        addMemBalloonDevice(vmDevice);
    } else {
        // get vm device for this Balloon from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.BALLOON.getName(), VmDeviceType.MEMBALLOON.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            addMemBalloonDevice(vmDevice);
            // only one memory balloon should exist
            break;
        }
    }
}
#method_after
@Override
protected void buildVmMemoryBalloon() {
    if (vm.isRunOnce() && vm.isBalloonEnabled()) {
        Map<String, Object> specParams = new HashMap<String, Object>();
        specParams.put(VdsProperties.Model, VdsProperties.Virtio);
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.NewGuid(), vm.getId()), VmDeviceType.BALLOON.getName(), VmDeviceType.MEMBALLOON.getName(), "", 0, specParams, true, true, true, "");
        addMemBalloonDevice(vmDevice);
    } else {
        // get vm device for this Balloon from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.BALLOON.getName(), VmDeviceType.MEMBALLOON.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            addMemBalloonDevice(vmDevice);
            // only one memory balloon should exist
            break;
        }
    }
}
#end_block

#method_before
protected void connectAllHostToPoolAndDomain(final storage_domains masterDomain) {
    final List<VDS> vdsList = getAllRunningVdssInPool();
    final storage_pool storagePool = getStoragePool();
    SyncronizeNumberOfAsyncOperations sync = new SyncronizeNumberOfAsyncOperations(vdsList.size(), null, new ActivateDeactivateSingleAsyncOperationFactory() {

        @Override
        public ISingleAsyncOperation CreateSingleAsyncOperation() {
            return new ConntectVDSToPoolAndDomains((ArrayList<VDS>) vdsList, masterDomain, storagePool);
        }

        @Override
        public void Initialize(ArrayList parameters) {
        // no need to initilalize params
        }
    });
    sync.Execute();
}
#method_after
protected void connectAllHostToPoolAndDomain(final storage_domains masterDomain) {
    final List<VDS> vdsList = getAllRunningVdssInPool();
    final storage_pool storagePool = getStoragePool();
    SyncronizeNumberOfAsyncOperations sync = new SyncronizeNumberOfAsyncOperations(vdsList.size(), null, new ActivateDeactivateSingleAsyncOperationFactory() {

        @Override
        public ISingleAsyncOperation createSingleAsyncOperation() {
            return new ConntectVDSToPoolAndDomains((ArrayList<VDS>) vdsList, masterDomain, storagePool);
        }

        @Override
        public void initialize(ArrayList parameters) {
        // no need to initilalize params
        }
    });
    sync.Execute();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setvds_group_id(targetClusterId);
            DbFacade.getInstance().getVdsStaticDao().update(staticData);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    VdsSpmIdParameters vdsSpmIdParameters = new VdsSpmIdParameters();
    vdsSpmIdParameters.setCompensationEnabled(true);
    vdsSpmIdParameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    vdsSpmIdParameters.setVdsId(getVds().getId());
    if (targetStoragePool != null && (getSourceCluster().getstorage_pool_id() == null || !targetStoragePool.getId().equals(getSourceCluster().getstorage_pool_id().getValue()))) {
        vdsSpmIdParameters.setStoragePoolId(targetStoragePool.getId());
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, vdsSpmIdParameters, new CommandContext(getCompensationContext()));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            return;
        }
    }
    if (getSourceCluster().getstorage_pool_id() != null && (targetStoragePool == null || !getSourceCluster().getstorage_pool_id().getValue().equals(targetStoragePool.getId()))) {
        vdsSpmIdParameters.setStoragePoolId(getSourceCluster().getstorage_pool_id().getValue());
        VdcReturnValueBase removeVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.RemoveVdsSpmId, vdsSpmIdParameters, new CommandContext(getCompensationContext()));
        if (!removeVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(removeVdsSpmIdReturn.getFault());
            return;
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setvds_group_id(targetClusterId);
            DbFacade.getInstance().getVdsStaticDao().update(staticData);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    getParameters().setCompensationEnabled(true);
    getParameters().setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    if (targetStoragePool != null && (getSourceCluster().getstorage_pool_id() == null || !targetStoragePool.getId().equals(getSourceCluster().getstorage_pool_id().getValue()))) {
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, getParameters(), new CommandContext(getCompensationContext()));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            return;
        }
    }
    if (getSourceCluster().getstorage_pool_id() != null && (targetStoragePool == null || !getSourceCluster().getstorage_pool_id().getValue().equals(targetStoragePool.getId()))) {
        getVdsSpmIdMapDAO().removeByVdsAndStoragePool(getVds().getId(), getSourceCluster().getstorage_pool_id().getValue());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // according to shaharf the first id is 1
    int selectedId = 1;
    List<Integer> map = LinqUtils.foreach(vds_spm_id_mapList, new Function<vds_spm_id_map, Integer>() {

        @Override
        public Integer eval(vds_spm_id_map vds_spm_id_map) {
            return vds_spm_id_map.getvds_spm_id();
        }
    });
    Collections.sort(map);
    for (int id : map) {
        if (selectedId == id) {
            selectedId++;
        } else {
            break;
        }
    }
    vds_spm_id_map newMap = new vds_spm_id_map(getVds().getstorage_pool_id(), getVdsId(), selectedId);
    DbFacade.getInstance().getVdsSpmIdMapDao().save(newMap);
    if (getParameters().isCompensationEnabled()) {
        getCompensationContext().snapshotNewEntity(newMap);
        getCompensationContext().stateChanged();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // according to shaharf the first id is 1
    int selectedId = 1;
    List<Integer> list = LinqUtils.foreach(vds_spm_id_mapList, new Function<vds_spm_id_map, Integer>() {

        @Override
        public Integer eval(vds_spm_id_map vds_spm_id_map) {
            return vds_spm_id_map.getvds_spm_id();
        }
    });
    Collections.sort(list);
    for (int id : list) {
        if (selectedId == id) {
            selectedId++;
        } else {
            break;
        }
    }
    vds_spm_id_map newMap = new vds_spm_id_map(getVds().getstorage_pool_id(), getVdsId(), selectedId);
    DbFacade.getInstance().getVdsSpmIdMapDao().save(newMap);
    if (getParameters().isCompensationEnabled()) {
        getCompensationContext().snapshotNewEntity(newMap);
        getCompensationContext().stateChanged();
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public void removeByVdsAndStoragePool(Guid vdsId, Guid storagePoolId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_id", vdsId).addValue("storage_pool_id", storagePoolId);
    getCallsHandler().executeModification("Deletevds_spm_id_map", parameterSource);
}
#method_after
@Override
public void removeByVdsAndStoragePool(Guid vdsId, Guid storagePoolId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_id", vdsId).addValue("storage_pool_id", storagePoolId);
    getCallsHandler().executeModification("DeleteByPoolvds_spm_id_map", parameterSource);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    VDSGroup oldGroup = getVdsGroupDAO().get(getParameters().getVdsGroup().getId());
    CheckMaxMemoryOverCommitValue();
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if (oldGroup.getstorage_pool_id() != null && !oldGroup.getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id()) || oldGroup.getstorage_pool_id() == null && getVdsGroup().getstorage_pool_id() != null) {
        for (VdsStatic vds : getVdsStaticDAO().getAllForVdsGroup(oldGroup.getId())) {
            VdsSpmIdParameters parameters = new VdsSpmIdParameters(vds.getId(), getVdsGroup().getstorage_pool_id().getValue());
            if (getVdsGroup().getstorage_pool_id() != null) {
                VdcReturnValueBase addVdsSpmIdReturn = getBackend().runInternalAction(VdcActionType.AddVdsSpmId, parameters);
                if (!addVdsSpmIdReturn.getSucceeded()) {
                    setSucceeded(false);
                    getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                    return;
                }
            }
            parameters.setStoragePoolId(oldGroup.getstorage_pool_id().getValue());
            if (oldGroup.getstorage_pool_id() != null) {
                VdcReturnValueBase removeVdsSpmIdReturn = getBackend().runInternalAction(VdcActionType.RemoveVdsSpmId, parameters);
                if (!removeVdsSpmIdReturn.getSucceeded()) {
                    setSucceeded(false);
                    getReturnValue().setFault(removeVdsSpmIdReturn.getFault());
                    return;
                }
            }
        }
    }
    // when changing data center we check that default networks exists in
    // cluster
    List<Network> networks = getNetworkDAO().getAllForCluster(getVdsGroup().getId());
    boolean exists = false;
    String managementNetwork = Config.<String>GetValue(ConfigValues.ManagementNetwork);
    for (Network net : networks) {
        if (StringUtils.equals(net.getname(), managementNetwork)) {
            exists = true;
        }
    }
    if (!exists) {
        if (getVdsGroup().getstorage_pool_id() != null) {
            List<Network> storagePoolNets = getNetworkDAO().getAllForDataCenter(getVdsGroup().getstorage_pool_id().getValue());
            for (Network net : storagePoolNets) {
                if (StringUtils.equals(net.getname(), managementNetwork)) {
                    getNetworkClusterDAO().save(new network_cluster(getVdsGroup().getId(), net.getId(), NetworkStatus.Operational, true, true));
                }
            }
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    CheckMaxMemoryOverCommitValue();
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if ((oldGroup.getstorage_pool_id() != null && !oldGroup.getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id())) || (oldGroup.getstorage_pool_id() == null && getVdsGroup().getstorage_pool_id() != null)) {
        VdsActionParameters parameters = new VdsActionParameters();
        for (VDS vds : allForVdsGroup) {
            parameters.setVdsId(vds.getId());
            if (getVdsGroup().getstorage_pool_id() != null) {
                VdcReturnValueBase addVdsSpmIdReturn = getBackend().runInternalAction(VdcActionType.AddVdsSpmId, parameters);
                if (!addVdsSpmIdReturn.getSucceeded()) {
                    setSucceeded(false);
                    getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                    return;
                }
            }
        }
        if (oldGroup.getstorage_pool_id() != null) {
            for (VDS vds : allForVdsGroup) {
                getVdsSpmIdMapDAO().removeByVdsAndStoragePool(vds.getId(), oldGroup.getstorage_pool_id().getValue());
            }
        }
    }
    // when changing data center we check that default networks exists in
    // cluster
    List<Network> networks = getNetworkDAO().getAllForCluster(getVdsGroup().getId());
    boolean exists = false;
    String managementNetwork = Config.<String>GetValue(ConfigValues.ManagementNetwork);
    for (Network net : networks) {
        if (StringUtils.equals(net.getname(), managementNetwork)) {
            exists = true;
        }
    }
    if (!exists) {
        if (getVdsGroup().getstorage_pool_id() != null) {
            List<Network> storagePoolNets = getNetworkDAO().getAllForDataCenter(getVdsGroup().getstorage_pool_id().getValue());
            for (Network net : storagePoolNets) {
                if (StringUtils.equals(net.getname(), managementNetwork)) {
                    getNetworkClusterDAO().save(new network_cluster(getVdsGroup().getId(), net.getId(), NetworkStatus.Operational, true, true));
                }
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@SuppressWarnings("null")
@Override
protected boolean canDoAction() {
    boolean result = super.canDoAction();
    boolean hasVms = false;
    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VAR__ACTION__UPDATE.toString());
    VDSGroup oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    // check that if name was changed, it was done to the same cluster
    VDSGroup groupWithName = getVdsGroupDAO().getByName(getVdsGroup().getname());
    if (oldGroup != null && !StringUtils.equals(oldGroup.getname(), getVdsGroup().getname())) {
        if (groupWithName != null && !groupWithName.getId().equals(getVdsGroup().getId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result && (oldGroup.getcpu_name() != null || getVdsGroup().getcpu_name() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getcpu_name()) && !checkIfCpusSameManufacture(oldGroup) && getVdsStaticDAO().getAllForVdsGroup(getVdsGroup().getId()).size() > 0) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    // decreasing of compatibility version is not allowed
    if (result && getVdsGroup().getcompatibility_version().compareTo(oldGroup.getcompatibility_version()) < 0) {
        result = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION.toString());
    }
    if (result) {
        SearchParameters p = new SearchParameters(MessageFormat.format(StorageHandlingCommandBase.UpVdssInCluster, oldGroup.getname()), SearchType.VDS);
        p.setMaxCount(Integer.MAX_VALUE);
        @SuppressWarnings("unchecked")
        Iterable<VDS> clusterUpVdss = (Iterable<VDS>) getBackend().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
        for (VDS vds : clusterUpVdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getcompatibility_version(), vds)) {
                result = false;
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS.toString());
                break;
            } else if (missingServerCpuFlags(vds) != null) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS.toString());
                result = false;
                break;
            }
        }
    }
    if (result && (oldGroup.getstorage_pool_id() != null && !oldGroup.getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id()))) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    if (result) {
        SearchParameters searchParams = new SearchParameters("vms: cluster = " + oldGroup.getname(), SearchType.VM);
        searchParams.setMaxCount(Integer.MAX_VALUE);
        @SuppressWarnings("unchecked")
        List<VM> vmList = (List<VM>) getBackend().runInternalQuery(VdcQueryType.Search, searchParams).getReturnValue();
        if (vmList.size() > 0) {
            hasVms = true;
        }
        int notDownVms = 0;
        int suspendedVms = 0;
        for (VM vm : vmList) {
            // the vm cluster id is the same as the cluster.id
            if (!vm.getvds_group_id().equals(oldGroup.getId())) {
                continue;
            }
            VMStatus vmStatus = vm.getstatus();
            if (vmStatus == VMStatus.Suspended) {
                suspendedVms++;
            }
            if (vmStatus != VMStatus.Down) {
                notDownVms++;
            }
        }
        boolean sameCpuNames = StringUtils.equals(oldGroup.getcpu_name(), getVdsGroup().getcpu_name());
        if (result && !sameCpuNames) {
            if (suspendedVms > 0) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                result = false;
            } else if (notDownVms > 0) {
                int compareResult = compareCpuLevels(oldGroup);
                if (compareResult < 0) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_LOWER_CPU_LEVEL);
                    result = false;
                } else if (compareResult > 0) {
                    // Upgrade of CPU in same compability level is allowed if there
                    // are running VMs - but we should warn they
                    // cannot not be hibernated
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.AddCustomValue("VdsGroup", getParameters().getVdsGroup().getname());
                    AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                }
            }
        }
    }
    if (result && getVdsGroup().getstorage_pool_id() != null) {
        storage_pool storagePool = getStoragePoolDAO().get(getVdsGroup().getstorage_pool_id().getValue());
        if (oldGroup.getstorage_pool_id() == null && storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getstorage_pool_id().getValue()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else // selection algorithm must be set to none in localfs
            if (getVdsGroup().getselection_algorithm() != VdsSelectionAlgorithm.None) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_SELECTION_ALGORITHM_MUST_BE_SET_TO_NONE_ON_LOCAL_STORAGE.toString());
                result = false;
            } else if (VDSGroup.DEFAULT_VDS_GROUP_ID.equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        result = validateMetrics();
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // check that if name was changed, it was done to the same cluster
    if (result && !StringUtils.equals(oldGroup.getname(), getVdsGroup().getname())) {
        VDSGroup groupWithName = getVdsGroupDAO().getByName(getVdsGroup().getname());
        if (groupWithName != null && !groupWithName.getId().equals(getVdsGroup().getId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    // decreasing of compatibility version is not allowed
    if (result && getVdsGroup().getcompatibility_version().compareTo(oldGroup.getcompatibility_version()) < 0) {
        result = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION.toString());
    }
    if (result && oldGroup.getstorage_pool_id() != null && !oldGroup.getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    if (result && (oldGroup.getcpu_name() != null || getVdsGroup().getcpu_name() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getcpu_name()) && !checkIfCpusSameManufacture(oldGroup) && !allForVdsGroup.isEmpty()) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        boolean isAddedToStoragePool = oldGroup.getstorage_pool_id() == null && getVdsGroup().getstorage_pool_id() != null;
        for (VDS vds : allForVdsGroup) {
            if (vds.getstatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getcompatibility_version(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            SearchParameters searchParams = new SearchParameters("vms: cluster = " + oldGroup.getname(), SearchType.VM);
            searchParams.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            List<VM> vmList = (List<VM>) getBackend().runInternalQuery(VdcQueryType.Search, searchParams).getReturnValue();
            boolean notDownVms = false;
            boolean suspendedVms = false;
            for (VM vm : vmList) {
                // the vm cluster id is the same as the cluster.id
                if (!vm.getvds_group_id().equals(oldGroup.getId())) {
                    continue;
                } else {
                    hasVms = true;
                }
                if (vm.getstatus() == VMStatus.Suspended) {
                    suspendedVms = true;
                } else if (vm.getstatus() != VMStatus.Down) {
                    notDownVms = true;
                }
            }
            boolean sameCpuNames = StringUtils.equals(oldGroup.getcpu_name(), getVdsGroup().getcpu_name());
            if (!sameCpuNames) {
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult < 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_LOWER_CPU_LEVEL);
                        result = false;
                    } else if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.AddCustomValue("VdsGroup", getParameters().getVdsGroup().getname());
                        AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getstorage_pool_id() != null) {
        storage_pool storagePool = getStoragePoolDAO().get(getVdsGroup().getstorage_pool_id().getValue());
        if (oldGroup.getstorage_pool_id() == null && storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getstorage_pool_id().getValue()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else // selection algorithm must be set to none in localfs
            if (getVdsGroup().getselection_algorithm() != VdsSelectionAlgorithm.None) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_SELECTION_ALGORITHM_MUST_BE_SET_TO_NONE_ON_LOCAL_STORAGE.toString());
                result = false;
            } else if (VDSGroup.DEFAULT_VDS_GROUP_ID.equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        result = validateMetrics();
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    return result;
}
#end_block

#method_before
private List<VdsNetworkInterface> nicsToInterfaces(List<HostNIC> hostNics) {
    List<VdsNetworkInterface> ifaces = new ArrayList<VdsNetworkInterface>(hostNics.size());
    for (HostNIC nic : hostNics) {
        VdsNetworkInterface iface = map(nic, null);
        ifaces.add(iface);
        if (nic.isSetBonding() && nic.getBonding().isSetSlaves()) {
            for (HostNIC slave : nic.getBonding().getSlaves().getSlaves()) {
                VdsNetworkInterface slaveIface = map(lookupNic(slave.getId()), null);
                slaveIface.setBondName(nic.getName());
                ifaces.add(slaveIface);
            }
        }
    }
    return ifaces;
}
#method_after
private List<VdsNetworkInterface> nicsToInterfaces(List<HostNIC> hostNics) {
    List<VdsNetworkInterface> ifaces = new ArrayList<VdsNetworkInterface>(hostNics.size());
    for (HostNIC nic : hostNics) {
        VdsNetworkInterface iface = map(nic, null);
        ifaces.add(iface);
        if (nic.isSetBonding() && nic.getBonding().isSetSlaves()) {
            for (HostNIC slave : nic.getBonding().getSlaves().getSlaves()) {
                VdsNetworkInterface slaveIface = map(slave, lookupInterface(slave.getId()));
                slaveIface.setBondName(nic.getName());
                ifaces.add(slaveIface);
            }
        }
    }
    return ifaces;
}
#end_block

#method_before
public static boolean PerformImagesChecks(VM vm, List<String> messages, Guid storagePoolId, Guid storageDomainId, boolean diskSpaceCheck, boolean checkImagesLocked, boolean checkImagesIllegal, boolean checkImagesExist, boolean checkVmInPreview, boolean checkVmIsDown, boolean checkStorageDomain, boolean checkIsValid, Collection diskImageList) {
    boolean returnValue = true;
    boolean isValid = checkIsValid && ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(storagePoolId)).getReturnValue()).booleanValue();
    if (checkIsValid && !isValid) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND.toString());
    }
    if (returnValue && checkImagesLocked) {
        List<String> lockedDisksAliases = new ArrayList<String>();
        if (vm.getstatus() == VMStatus.ImageLocked) {
            ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_IS_LOCKED.toString());
            returnValue = false;
        } else if (diskImageList != null) {
            for (Object object : diskImageList) {
                Disk disk = (Disk) object;
                if (DiskStorageType.IMAGE == disk.getDiskStorageType() && ((DiskImage) disk).getimageStatus() == ImageStatus.LOCKED) {
                    lockedDisksAliases.add(disk.getDiskAlias());
                    returnValue = false;
                }
            }
            if (lockedDisksAliases.size() > 0) {
                ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_DISKS_IMAGES_ARE_LOCKED.toString());
                messages.add(String.format("$%1$s %2$s", "diskAliases", StringUtils.join(lockedDisksAliases, ", ")));
            }
        }
    }
    if (returnValue && checkVmIsDown && vm.getstatus() != VMStatus.Down) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN.toString());
    }
    if (returnValue && checkVmInPreview && isVmInPreview(vm.getId())) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW.toString());
    }
    if (returnValue && isValid) {
        List<DiskImage> images = getImages(vm, diskImageList);
        if (images.size() > 0) {
            returnValue = returnValue && checkDiskImages(messages, storagePoolId, storageDomainId, diskSpaceCheck, checkImagesIllegal, checkImagesExist, checkStorageDomain, vm, images);
        } else if (checkImagesExist) {
            returnValue = false;
            ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS.toString());
        }
    }
    return returnValue;
}
#method_after
public static boolean PerformImagesChecks(VM vm, List<String> messages, Guid storagePoolId, Guid storageDomainId, boolean diskSpaceCheck, boolean checkImagesLocked, boolean checkImagesIllegal, boolean checkImagesExist, boolean checkVmInPreview, boolean checkVmIsDown, boolean checkStorageDomain, boolean checkIsValid, Collection diskImageList) {
    boolean returnValue = true;
    boolean isValid = checkIsValid && ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(storagePoolId)).getReturnValue()).booleanValue();
    if (checkIsValid && !isValid) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND.toString());
    }
    if (returnValue && checkImagesLocked) {
        List<String> lockedDisksAliases = new ArrayList<String>();
        if (diskImageList != null) {
            for (Object object : diskImageList) {
                Disk disk = (Disk) object;
                if (DiskStorageType.IMAGE == disk.getDiskStorageType() && ((DiskImage) disk).getimageStatus() == ImageStatus.LOCKED) {
                    lockedDisksAliases.add(disk.getDiskAlias());
                    returnValue = false;
                }
            }
            if (lockedDisksAliases.size() > 0) {
                ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_DISKS_ARE_LOCKED.toString());
                messages.add(String.format("$%1$s %2$s", "diskAliases", StringUtils.join(lockedDisksAliases, ", ")));
            }
        }
        if (returnValue && vm.getstatus() == VMStatus.ImageLocked) {
            ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_LOCKED.toString());
            returnValue = false;
        }
    }
    if (returnValue && checkVmIsDown && vm.getstatus() != VMStatus.Down) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN.toString());
    }
    if (returnValue && checkVmInPreview && isVmInPreview(vm.getId())) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW.toString());
    }
    if (returnValue && isValid) {
        List<DiskImage> images = getImages(vm, diskImageList);
        if (images.size() > 0) {
            returnValue = returnValue && checkDiskImages(messages, storagePoolId, storageDomainId, diskSpaceCheck, checkImagesIllegal, checkImagesExist, checkStorageDomain, vm, images);
        } else if (checkImagesExist) {
            returnValue = false;
            ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS.toString());
        }
    }
    return returnValue;
}
#end_block

#method_before
private void selectedKeyChanged() {
    String key = (String) getSelectedKey().getEntity();
    List<GlusterVolumeOptionInfo> options = (List<GlusterVolumeOptionInfo>) getKeyList().getItems();
    GlusterVolumeOptionInfo selectedOption = null;
    for (GlusterVolumeOptionInfo option : options) {
        if (option.getKey().equals(key.trim())) {
            selectedOption = option;
            break;
        }
    }
    if (selectedOption != null) {
        if (// $NON-NLS-1$
        selectedOption.getDescription().equals("(null)")) {
            getDescription().setEntity(null);
        } else {
            getDescription().setEntity(selectedOption.getDescription());
        }
        if (getIsNew()) {
            if (// $NON-NLS-1$
            selectedOption.getDefaultValue().equals("(null)")) {
                getValue().setEntity(null);
            } else {
                getValue().setEntity(selectedOption.getDefaultValue());
            }
        }
    } else if (getIsNew()) {
        getDescription().setEntity(null);
        getValue().setEntity(null);
    }
}
#method_after
private void selectedKeyChanged() {
    String key = (String) getSelectedKey().getEntity();
    List<GlusterVolumeOptionInfo> options = (List<GlusterVolumeOptionInfo>) getKeyList().getItems();
    GlusterVolumeOptionInfo selectedOption = null;
    for (GlusterVolumeOptionInfo option : options) {
        if (option.getKey().equals(key.trim())) {
            selectedOption = option;
            break;
        }
    }
    if (selectedOption != null) {
        if (selectedOption.getDescription() == null || selectedOption.getDescription().equals(NULL_CONST)) {
            getDescription().setEntity(null);
        } else {
            getDescription().setEntity(selectedOption.getDescription());
        }
        if (getIsNew()) {
            if (selectedOption.getDefaultValue() == null || selectedOption.getDefaultValue().equals(NULL_CONST)) {
                getValue().setEntity(null);
            } else {
                getValue().setEntity(selectedOption.getDefaultValue());
            }
        }
    } else if (getIsNew()) {
        getDescription().setEntity(null);
        getValue().setEntity(null);
    }
}
#end_block

#method_before
public static void GetRoleList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<roles>) source : new ArrayList<roles>();
        }
    };
    Frontend.RunQuery(VdcQueryType.GetAllRoles, new MultilevelAdministrationsQueriesParameters(), aQuery);
}
#method_after
public static void GetRoleList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Role>) source : new ArrayList<Role>();
        }
    };
    Frontend.RunQuery(VdcQueryType.GetAllRoles, new MultilevelAdministrationsQueriesParameters(), aQuery);
}
#end_block

#method_before
public static void Init() {
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(new String[] { "VM", "VmStatic", "VmDynamic" }), VMStatus.class);
    mUpdateVmsStatic.AddPermittedFields(new String[] { "vm_name", "description", "domain", "os", "osType", "creation_date", "num_of_monitors", "allowConsoleReconnect", "usb_policy", "is_auto_suspend", "auto_startup", "dedicated_vm_for_vds", "default_display_type", "priority", "default_boot_sequence", "initrd_url", "kernel_url", "kernel_params", "migrationSupport", "minAllocatedMem", "quotaId", "quotaName", "quotaEnforcementType", "cpuPinning", "vmPayload", "balloonEnabled" });
    mUpdateVmsStatic.AddFields(Arrays.asList(new Enum<?>[] { VMStatus.Down }), Arrays.asList(new String[] { "vds_group_id", "time_zone", "is_stateless", "nice_level", "mem_size_mb", "num_of_sockets", "cpu_per_socket", "iso_path", "userDefinedProperties", "predefinedProperties", "customProperties" }));
    mUpdateVmsStatic.AddIgnoredFields(Arrays.asList(new String[] { "images", "interfaces" }));
}
#method_after
public static void Init() {
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(new String[] { "VM", "VmStatic", "VmDynamic" }), VMStatus.class);
    mUpdateVmsStatic.AddPermittedFields(new String[] { "vm_name", "description", "domain", "os", "osType", "creation_date", "num_of_monitors", "allowConsoleReconnect", "usb_policy", "is_auto_suspend", "auto_startup", "dedicated_vm_for_vds", "default_display_type", "priority", "default_boot_sequence", "initrd_url", "kernel_url", "kernel_params", "migrationSupport", "minAllocatedMem", "quotaId", "quotaName", "quotaEnforcementType", "cpuPinning", "vmPayload", "balloonEnabled", // images list is relational entity - ignore value changes
    "images", // interfaces is relational entity - ignore value changes
    "interfaces" });
    mUpdateVmsStatic.AddFields(Arrays.asList(new Enum<?>[] { VMStatus.Down }), Arrays.asList(new String[] { "vds_group_id", "time_zone", "is_stateless", "nice_level", "mem_size_mb", "num_of_sockets", "cpu_per_socket", "iso_path", "userDefinedProperties", "predefinedProperties", "customProperties" }));
}
#end_block

#method_before
@Override
public String render(Boolean valueToRender) {
    if (valueToRender == null)
        return "";
    if (trueText == null || falseText == null) {
        return valueToRender.toString();
    }
    return valueToRender.booleanValue() ? trueText : falseText;
}
#method_after
@Override
public String render(Boolean valueToRender) {
    if (valueToRender == null) {
        return "";
    }
    if (trueText == null || falseText == null) {
        return valueToRender.toString();
    }
    return valueToRender.booleanValue() ? trueText : falseText;
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    if (!Config.<Boolean>GetValue(ConfigValues.SupportStorageFormat, getVds().getvds_group_compatibility_version().toString())) {
        _result = getBroker().spmStart(getParameters().getStoragePoolId().toString(), getParameters().getPrevId(), getParameters().getPrevLVER(), getParameters().getRecoveryMode().getValue(), (new Boolean(getParameters().getSCSIFencing())).toString().toLowerCase(), Config.<Integer>GetValue(ConfigValues.MaxNumberOfHostsInStoragePool));
    } else {
        _result = getBroker().spmStart(getParameters().getStoragePoolId().toString(), getParameters().getPrevId(), getParameters().getPrevLVER(), getParameters().getRecoveryMode().getValue(), (new Boolean(getParameters().getSCSIFencing())).toString().toLowerCase(), Config.<Integer>GetValue(ConfigValues.MaxNumberOfHostsInStoragePool), getParameters().getStoragePoolFormatType().getValue());
    }
    ProceedProxyReturnValue();
    Guid taskId = new Guid(_result.mUuid);
    AsyncTaskStatus taskStatus;
    log.infoFormat("spmStart polling started: taskId = {0}", taskId);
    do {
        // TODO: make configurable
        ThreadUtils.sleep(1000);
        taskStatus = (AsyncTaskStatus) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetTaskStatus, new HSMTaskGuidBaseVDSCommandParameters(getVds().getId(), taskId)).getReturnValue();
        log.debugFormat("spmStart polling - task status: {0}", taskStatus.getStatus().toString());
    } while (taskStatus.getStatus() != AsyncTaskStatusEnum.finished && taskStatus.getStatus() != AsyncTaskStatusEnum.unknown);
    log.infoFormat("spmStart polling ended: taskId = {0}, result = {1}, status = {2}, message = {3}", taskId, taskStatus.getResult().toString(), taskStatus.getStatus(), taskStatus.getMessage());
    setReturnValue(taskStatus.getTaskEndedSuccessfully() ? SpmStatus.SPM : SpmStatus.Free);
    try {
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMClearTask, new HSMTaskGuidBaseVDSCommandParameters(getVds().getId(), taskId));
    } catch (java.lang.Exception e) {
        log.errorFormat("Could not clear spmStart task (id - {0}), continuing with SPM selection.", taskId);
    }
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    if (!Config.<Boolean>GetValue(ConfigValues.SupportStorageFormat, getVds().getvds_group_compatibility_version().toString())) {
        _result = getBroker().spmStart(getParameters().getStoragePoolId().toString(), getParameters().getPrevId(), getParameters().getPrevLVER(), getParameters().getRecoveryMode().getValue(), (new Boolean(getParameters().getSCSIFencing())).toString().toLowerCase(), Config.<Integer>GetValue(ConfigValues.MaxNumberOfHostsInStoragePool));
    } else {
        _result = getBroker().spmStart(getParameters().getStoragePoolId().toString(), getParameters().getPrevId(), getParameters().getPrevLVER(), getParameters().getRecoveryMode().getValue(), (new Boolean(getParameters().getSCSIFencing())).toString().toLowerCase(), Config.<Integer>GetValue(ConfigValues.MaxNumberOfHostsInStoragePool), getParameters().getStoragePoolFormatType().getValue());
    }
    ProceedProxyReturnValue();
    Guid taskId = new Guid(_result.mUuid);
    AsyncTaskStatus taskStatus;
    log.infoFormat("spmStart polling started: taskId = {0}", taskId);
    do {
        // TODO: make configurable
        ThreadUtils.sleep(1000);
        taskStatus = (AsyncTaskStatus) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetTaskStatus, new HSMTaskGuidBaseVDSCommandParameters(getVds().getId(), taskId)).getReturnValue();
        log.debugFormat("spmStart polling - task status: {0}", taskStatus.getStatus().toString());
    } while (taskStatus.getStatus() != AsyncTaskStatusEnum.finished && taskStatus.getStatus() != AsyncTaskStatusEnum.unknown);
    log.infoFormat("spmStart polling ended: taskId = {0} task status = {1}", taskId, taskStatus.getStatus());
    if (!taskStatus.getTaskEndedSuccessfully()) {
        log.errorFormat("Start SPM Task failed - result: {0}, message: {1}", taskStatus.getResult().toString(), taskStatus.getMessage());
    }
    SpmStatusResult spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(getVds().getId(), getParameters().getStoragePoolId())).getReturnValue();
    if (spmStatus != null) {
        log.infoFormat("spmStart polling ended, spm status: {0}", spmStatus.getSpmStatus().toString());
    } else {
        log.errorFormat("spmStart polling ended, failed to get the spm status");
    }
    try {
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMClearTask, new HSMTaskGuidBaseVDSCommandParameters(getVds().getId(), taskId));
    } catch (java.lang.Exception e) {
        log.errorFormat("Could not clear spmStart task (id - {0}), continuing with SPM selection.", taskId);
    }
    setReturnValue(spmStatus);
}
#end_block

#method_before
private void initServerUrl() throws NotificationServiceException {
    String serverAddressProp = prop.get(NotificationProperties.ENGINE_ADDRESS);
    String protocol = isHttpsProtocol ? "https" : "http";
    serverUrl = String.format(HEALTH_SERVLET_URL, protocol, StringUtils.isEmpty(serverAddressProp) ? DEFAULT_SERVER_ADDRESS : serverAddressProp);
    try {
        new URL(serverUrl);
    } catch (MalformedURLException e) {
        throw new NotificationServiceException(String.format("Invalid engine server address format: [%s]. " + "Please verify the format of [%s]. Should be ip:port or hostname:port whereas [%s])", serverUrl, NotificationProperties.ENGINE_ADDRESS, serverAddressProp), e);
    }
}
#method_after
private void initServerUrl() throws NotificationServiceException {
    LocalConfig config = LocalConfig.getInstance();
    try {
        if (isHttpsProtocol) {
            serverUrl = config.getExternalHttpsUrl(HEALTH_SERVLET_PATH);
        } else {
            serverUrl = config.getExternalHttpUrl(HEALTH_SERVLET_PATH);
        }
        log.info("Engine health servlet URL is \"" + serverUrl + "\".");
    } catch (MalformedURLException exception) {
        throw new NotificationServiceException("Can't get engine health servlet URL.", exception);
    }
}
#end_block

#method_before
private void monitorEngineServerStatus() {
    boolean isResponsive = false;
    Set<String> errors = new HashSet<String>();
    int retries = serverMonitorRetries;
    while (retries > 0) {
        retries--;
        try {
            isResponsive = checkServerStatus(serverUrl, errors);
            if (!isResponsive) {
                if (retries > 0) {
                    Thread.sleep(serverMonitorTimeout);
                }
            } else {
                // server is up and health servlet returned HTTP_OK
                break;
            }
        } catch (InterruptedException e) {
        // ignore this error
        } catch (Exception e) {
            errors.add(e.getMessage());
        }
    }
    // errors should contain distinct list of errors while trying to obtain server status
    if (errors.size() > 0) {
        log.error("Failed to get server status with:" + errors);
        errors.clear();
    }
    // analyzes server status and report if needed
    reportServerStatus(isResponsive);
}
#method_after
private void monitorEngineServerStatus() {
    boolean isResponsive = false;
    Set<String> errors = new HashSet<String>();
    int retries = serverMonitorRetries;
    while (retries > 0) {
        retries--;
        try {
            isResponsive = checkServerStatus(errors);
            if (!isResponsive) {
                if (retries > 0) {
                    Thread.sleep(serverMonitorTimeout);
                }
            } else {
                // server is up and health servlet returned HTTP_OK
                break;
            }
        } catch (InterruptedException e) {
        // ignore this error
        } catch (Exception e) {
            errors.add(e.getMessage());
        }
    }
    // errors should contain distinct list of errors while trying to obtain server status
    if (errors.size() > 0) {
        log.error("Failed to get server status with:" + errors);
        errors.clear();
    }
    // analyzes server status and report if needed
    reportServerStatus(isResponsive);
}
#end_block

#method_before
private boolean checkServerStatus(String serverUrl, Set<String> errors) {
    boolean isResponsive = true;
    HttpURLConnection engineConn = null;
    URL engine;
    try {
        engine = new URL(serverUrl);
        if (isHttpsProtocol) {
            engineConn = (HttpsURLConnection) engine.openConnection();
            ((HttpsURLConnection) engineConn).setSSLSocketFactory(sslFactory);
            if (sslIgnoreHostVerification) {
                ((HttpsURLConnection) engineConn).setHostnameVerifier(IgnoredHostnameVerifier);
            }
        } else {
            engineConn = (HttpURLConnection) engine.openConnection();
        }
    } catch (IOException e) {
        errors.add(e.getMessage());
        isResponsive = false;
    }
    if (isResponsive) {
        try {
            int responseCode = engineConn.getResponseCode();
            if (responseCode != HttpURLConnection.HTTP_OK) {
                isResponsive = false;
                log.debug(MessageFormat.format("Server is non responsive with response code: {0}", responseCode));
            }
        } catch (Exception e) {
            errors.add(e.getMessage());
            isResponsive = false;
        } finally {
            if (engineConn != null) {
                engineConn.disconnect();
                engineConn = null;
            }
        }
    }
    log.debug("checkServerStatus return: " + isResponsive);
    return isResponsive;
}
#method_after
private boolean checkServerStatus(Set<String> errors) {
    boolean isResponsive = true;
    HttpURLConnection engineConn = null;
    try {
        engineConn = (HttpURLConnection) serverUrl.openConnection();
        if (isHttpsProtocol) {
            ((HttpsURLConnection) engineConn).setSSLSocketFactory(sslFactory);
            if (sslIgnoreHostVerification) {
                ((HttpsURLConnection) engineConn).setHostnameVerifier(IgnoredHostnameVerifier);
            }
        }
    } catch (IOException e) {
        errors.add(e.getMessage());
        isResponsive = false;
    }
    if (isResponsive) {
        try {
            int responseCode = engineConn.getResponseCode();
            if (responseCode != HttpURLConnection.HTTP_OK) {
                isResponsive = false;
                log.debug(MessageFormat.format("Server is non responsive with response code: {0}", responseCode));
            }
        } catch (Exception e) {
            errors.add(e.getMessage());
            isResponsive = false;
        } finally {
            if (engineConn != null) {
                engineConn.disconnect();
                engineConn = null;
            }
        }
    }
    log.debug("checkServerStatus return: " + isResponsive);
    return isResponsive;
}
#end_block

#method_before
@Test
public void testPasswordDomainMap() throws Exception {
    String keyStorePassword = "NoSoup4U";
    String clearTextPassword = keyStorePassword;
    String keyStorePath = ClassLoader.getSystemResource("key.p12").getPath();
    String encryptedPassword = EncryptionUtils.encrypt(clearTextPassword, keyStorePath, keyStorePassword);
    DomainsPasswordMap map = new DomainsPasswordMap("redhat.com:" + encryptedPassword + ",jboss.com:" + encryptedPassword, keyStorePath, keyStorePassword);
    assertEquals(clearTextPassword, map.get("redhat.com"));
    assertEquals(clearTextPassword, map.get("jboss.com"));
}
#method_after
@Test
public void testPasswordDomainMap() throws Exception {
    String keyStorePassword = "NoSoup4U";
    String clearTextPassword = keyStorePassword;
    String keyStorePath = URLDecoder.decode(ClassLoader.getSystemResource("key.p12").getPath(), "UTF-8");
    String alias = "1";
    String encryptedPassword = EncryptionUtils.encrypt(clearTextPassword, keyStorePath, keyStorePassword, alias);
    DomainsPasswordMap map = new DomainsPasswordMap("redhat.com:" + encryptedPassword + ",jboss.com:" + encryptedPassword, keyStorePath, keyStorePassword, alias);
    assertEquals(clearTextPassword, map.get("redhat.com"));
    assertEquals(clearTextPassword, map.get("jboss.com"));
}
#end_block

#method_before
public final static String encrypt(String source, String certificateFile, String passwd) throws Exception {
    String result = "";
    if (!StringHelper.isNullOrEmpty(source.trim())) {
        try {
            KeyStore store = EncryptionUtils.getKeyStore(certificateFile, passwd, certType);
            Certificate cert = store.getCertificate("1");
            result = encrypt(source, cert);
        } catch (Exception e) {
            log.error("Error doing the encryption", e);
            throw e;
        }
    }
    return result;
}
#method_after
public final static String encrypt(String source, String certificateFile, String passwd, String alias) throws Exception {
    String result = "";
    if (!StringHelper.isNullOrEmpty(source.trim())) {
        try {
            KeyStore store = EncryptionUtils.getKeyStore(certificateFile, passwd, certType);
            Certificate cert = store.getCertificate(alias);
            result = encrypt(source, cert);
        } catch (Exception e) {
            log.error("Error doing the encryption", e);
            throw e;
        }
    }
    return result;
}
#end_block

#method_before
private static String decrypt(String source, Key key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
    String result = "";
    byte[] cipherbytes = Encoding.Base64.getBytes(source);
    Cipher rsa = Cipher.getInstance(algo);
    rsa.init(Cipher.DECRYPT_MODE, key);
    byte[] plainbytes = rsa.doFinal(cipherbytes);
    result = Encoding.UTF8.getString(plainbytes);
    return result;
}
#method_after
public static String decrypt(String source, String keyFile, String passwd, String alias) throws Exception {
    String result = source;
    try {
        if (!StringHelper.isNullOrEmpty(source.trim())) {
            KeyStore store = EncryptionUtils.getKeyStore(keyFile, passwd, certType);
            Key key = store.getKey(alias, passwd.toCharArray());
            result = decrypt(source, key);
        }
    } catch (Exception e) {
        log.error("Failed to decrypt " + e.getMessage());
        log.debug("Failed to decrypt", e);
        throw e;
    }
    return result;
}
#end_block

#method_before
public static final String Decrypt(String source, String keyFile, String passwd, RefObject<String> error) {
    error.argvalue = "";
    String result = source;
    if (!StringHelper.isNullOrEmpty(source.trim())) {
        try {
            KeyStore store = EncryptionUtils.getKeyStore(keyFile, passwd, certType);
            Key key = store.getKey("1", passwd.toCharArray());
            result = Decrypt(source, key, error);
        } catch (Exception e) {
            log.error("Error doing the decryption", e);
            error.argvalue = e.getMessage();
        }
    }
    return result;
}
#method_after
public static final String Decrypt(String source, String keyFile, String passwd, RefObject<String> error) {
    error.argvalue = "";
    String result = source;
    if (!StringHelper.isNullOrEmpty(source.trim())) {
        try {
            KeyStore store = EncryptionUtils.getKeyStore(keyFile, passwd, certType);
            // Get the first one.
            String alias = "None";
            Enumeration<String> aliases = store.aliases();
            while (aliases.hasMoreElements()) {
                alias = aliases.nextElement();
                break;
            }
            Key key = store.getKey(alias, passwd.toCharArray());
            result = Decrypt(source, key, error);
        } catch (Exception e) {
            log.error("Error doing the decryption", e);
            error.argvalue = e.getMessage();
        }
    }
    return result;
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getGlusterVolumeDao();
    server = dbFacade.getVdsStaticDAO().get(SERVER_ID);
    existingDistVol = dao.getById(EXISTING_VOL_DIST_ID);
    existingReplVol = dao.getById(EXISTING_VOL_REPL_ID);
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getGlusterVolumeDao();
    server = dbFacade.getVdsStaticDao().get(SERVER_ID);
    existingDistVol = dao.getById(EXISTING_VOL_DIST_ID);
    existingReplVol = dao.getById(EXISTING_VOL_REPL_ID);
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getGlusterBrickDao();
    server = dbFacade.getVdsStaticDAO().get(SERVER_ID);
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getGlusterBrickDao();
    server = dbFacade.getVdsStaticDao().get(SERVER_ID);
}
#end_block

#method_before
private void SaveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.UpdateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.UpdateStatisticsData(stat);
        CheckVdsMemoryThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDAO().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    updateAllInTransaction(_vmDynamicToSave.values(), getDbFacade().getVmDynamicDAO());
    updateAllInTransaction(_vmStatisticsToSave.values(), getDbFacade().getVmStatisticsDAO());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    updateAllInTransaction(allVmInterfaceStatistics, getDbFacade().getVmNetworkStatisticsDAO());
    updateAllInTransaction(_vmDiskImageDynamicToSave.values(), getDbFacade().getDiskImageDynamicDAO());
    saveVmDevicesToDb();
}
#method_after
private void SaveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.UpdateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.UpdateStatisticsData(stat);
        CheckVdsMemoryThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    updateAllInTransaction(_vmDynamicToSave.values(), getDbFacade().getVmDynamicDao());
    updateAllInTransaction(_vmStatisticsToSave.values(), getDbFacade().getVmStatisticsDao());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    updateAllInTransaction(allVmInterfaceStatistics, getDbFacade().getVmNetworkStatisticsDao());
    updateAllInTransaction(_vmDiskImageDynamicToSave.values(), getDbFacade().getDiskImageDynamicDao());
    saveVmDevicesToDb();
}
#end_block

#method_before
private void saveVmDevicesToDb() {
    List<VmDevice> list = new ArrayList<VmDevice>(vmDeviceToSave.values());
    Collections.sort(list);
    updateAllInTransaction("UpdateVmDeviceRuntimeInfo", list, getDbFacade().getVmDeviceDAO());
    if (!removedDeviceIds.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getDbFacade().getVmDeviceDAO().removeAll(removedDeviceIds);
                return null;
            }
        });
    }
    if (!newVmDevices.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getDbFacade().getVmDeviceDAO().saveAll(newVmDevices);
                return null;
            }
        });
    }
}
#method_after
private void saveVmDevicesToDb() {
    List<VmDevice> list = new ArrayList<VmDevice>(vmDeviceToSave.values());
    Collections.sort(list);
    updateAllInTransaction("UpdateVmDeviceRuntimeInfo", list, getDbFacade().getVmDeviceDao());
    if (!removedDeviceIds.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getDbFacade().getVmDeviceDao().removeAll(removedDeviceIds);
                return null;
            }
        });
    }
    if (!newVmDevices.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getDbFacade().getVmDeviceDao().saveAll(newVmDevices);
                return null;
            }
        });
    }
}
#end_block

#method_before
private void markIsSetNonOperationalExecuted() {
    if (!_vdsManager.isSetNonOperationalExecuted()) {
        VdsDynamic vdsDynamic = getDbFacade().getVdsDynamicDAO().get(_vds.getId());
        if (vdsDynamic.getstatus() == VDSStatus.NonOperational) {
            _vdsManager.setIsSetNonOperationalExecuted(true);
        }
    }
}
#method_after
private void markIsSetNonOperationalExecuted() {
    if (!_vdsManager.isSetNonOperationalExecuted()) {
        VdsDynamic vdsDynamic = getDbFacade().getVdsDynamicDao().get(_vds.getId());
        if (vdsDynamic.getstatus() == VDSStatus.NonOperational) {
            _vdsManager.setIsSetNonOperationalExecuted(true);
        }
    }
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getstatus() != VDSStatus.Up) {
        return;
    }
    Map<String, Boolean> bondsWithStatus = new HashMap<String, Boolean>();
    List<Network> clusterNetworks = getDbFacade().getNetworkDAO().getAllForCluster(_vds.getvds_group_id());
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    Map<String, List<String>> bondsWithListOfNics = new HashMap<String, List<String>>();
    List<VdsNetworkInterface> interfaces = _vds.getInterfaces();
    Map<String, Network> networksByName = NetworkUtils.networksByName(clusterNetworks);
    try {
        for (VdsNetworkInterface iface : interfaces) {
            // Handle nics that are non bonded and not vlan over bond
            if (isRequiredInterfaceDown(networksByName, iface)) {
                brokenNics.add(iface.getName());
                networks.add(iface.getNetworkName());
            }
            // Handle bond nics
            if (iface.getBondName() != null) {
                populate(bondsWithStatus, clusterNetworks, networks, bondsWithListOfNics, iface);
            }
        }
        // only if we didn't already set the host to down
        if (brokenNics.isEmpty()) {
            for (String key : bondsWithStatus.keySet()) {
                if (!bondsWithStatus.get(key)) {
                    // add the nics name for audit log
                    for (String name : bondsWithListOfNics.get(key)) {
                        brokenNics.add(name);
                    }
                }
            }
        }
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getvds_name()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>GetValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retreive it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                StringBuilder sNics = new StringBuilder();
                StringBuilder sNetworks = new StringBuilder();
                for (String nic : brokenNics) {
                    sNics.append(nic).append(", ");
                }
                for (String net : networks) {
                    sNetworks.append(net).append(", ");
                }
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getvds_name(), sNics.toString(), sNetworks.toString());
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.AddCustomValue("Networks", StringHelper.trimEnd(sNetworks.toString(), ',', ' '));
                logable.AddCustomValue("Interfaces", StringHelper.trimEnd(sNics.toString(), ',', ' '));
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getvds_name()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getstatus() != VDSStatus.Up) {
        return;
    }
    Map<String, Boolean> bondsWithStatus = new HashMap<String, Boolean>();
    List<Network> clusterNetworks = getDbFacade().getNetworkDao().getAllForCluster(_vds.getvds_group_id());
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    Map<String, List<String>> bondsWithListOfNics = new HashMap<String, List<String>>();
    List<VdsNetworkInterface> interfaces = _vds.getInterfaces();
    Map<String, Network> networksByName = NetworkUtils.networksByName(clusterNetworks);
    try {
        for (VdsNetworkInterface iface : interfaces) {
            // Handle nics that are non bonded and not vlan over bond
            if (isRequiredInterfaceDown(networksByName, iface)) {
                brokenNics.add(iface.getName());
                networks.add(iface.getNetworkName());
            }
            // Handle bond nics
            if (iface.getBondName() != null) {
                populate(bondsWithStatus, clusterNetworks, networks, bondsWithListOfNics, iface);
            }
        }
        // only if we didn't already set the host to down
        if (brokenNics.isEmpty()) {
            for (String key : bondsWithStatus.keySet()) {
                if (!bondsWithStatus.get(key)) {
                    // add the nics name for audit log
                    for (String name : bondsWithListOfNics.get(key)) {
                        brokenNics.add(name);
                    }
                }
            }
        }
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getvds_name()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>GetValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retreive it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                StringBuilder sNics = new StringBuilder();
                StringBuilder sNetworks = new StringBuilder();
                for (String nic : brokenNics) {
                    sNics.append(nic).append(", ");
                }
                for (String net : networks) {
                    sNetworks.append(net).append(", ");
                }
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getvds_name(), sNics.toString(), sNetworks.toString());
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.AddCustomValue("Networks", StringHelper.trimEnd(sNetworks.toString(), ',', ' '));
                logable.AddCustomValue("Interfaces", StringHelper.trimEnd(sNics.toString(), ',', ' '));
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getvds_name()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#end_block

#method_before
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.errorFormat("Recieved NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = getDbFacade().getVmDeviceDAO().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            String alias = StringUtils.defaultIfEmpty((String) device.getItem(VdsProperties.Alias), "");
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            vmDevice.setAlias(alias);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.errorFormat("Recieved NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            String alias = StringUtils.defaultIfEmpty((String) device.getItem(VdsProperties.Alias), "");
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            vmDevice.setAlias(alias);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private void proceedDownVms() {
    for (Entry<VmDynamic, VmStatistics> vm_helper : _runningVms.values()) {
        VmDynamic vm = vm_helper.getKey();
        if (vm.getstatus() != VMStatus.Down) {
            continue;
        }
        VM vmTo = null;
        // _vdsManager.getVm(vm.getvm_guid());
        vmTo = _vmDict.get(vm.getId());
        VMStatus status = VMStatus.Unassigned;
        if (vmTo != null) {
            status = vmTo.getstatus();
            proceedVmBeforeDeletion(vmTo, vm);
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                ResourceManager.getInstance().InternalSetVmStatus(vmTo, VMStatus.Suspended);
            }
            clearVm(vmTo);
        }
        VmStatistics vmStatistics = getDbFacade().getVmStatisticsDAO().get(vm.getId());
        if (vmStatistics != null) {
            DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(_vds.getId(), vm.getId(), false, false, 0));
            vdsBrokerCommand.Execute();
            if (vmTo != null && status == VMStatus.SavingState) {
                AfterSuspendTreatment(vm);
            } else if (status != VMStatus.MigratingFrom) {
                HandleVmOnDown(vmTo, vm, vmStatistics);
            }
        }
    }
}
#method_after
private void proceedDownVms() {
    for (Entry<VmDynamic, VmStatistics> vm_helper : _runningVms.values()) {
        VmDynamic vm = vm_helper.getKey();
        if (vm.getstatus() != VMStatus.Down) {
            continue;
        }
        VM vmTo = null;
        // _vdsManager.getVm(vm.getvm_guid());
        vmTo = _vmDict.get(vm.getId());
        VMStatus status = VMStatus.Unassigned;
        if (vmTo != null) {
            status = vmTo.getstatus();
            proceedVmBeforeDeletion(vmTo, vm);
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                ResourceManager.getInstance().InternalSetVmStatus(vmTo, VMStatus.Suspended);
            }
            clearVm(vmTo);
        }
        VmStatistics vmStatistics = getDbFacade().getVmStatisticsDao().get(vm.getId());
        if (vmStatistics != null) {
            DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(_vds.getId(), vm.getId(), false, false, 0));
            vdsBrokerCommand.Execute();
            if (vmTo != null && status == VMStatus.SavingState) {
                AfterSuspendTreatment(vm);
            } else if (status != VMStatus.MigratingFrom) {
                HandleVmOnDown(vmTo, vm, vmStatistics);
            }
        }
    }
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (Entry<VmDynamic, VmStatistics> vm_helper : _runningVms.values()) {
        VmDynamic runningVm = vm_helper.getKey();
        VM vmToUpdate = null;
        vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getclient_ip())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getstatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getstatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.errorFormat("VdsBroker.VdsUpdateRunTimeInfo.updateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getstatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getstatus() != VMStatus.Up && vmToUpdate.getstatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getstatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else /**
                 * check if vm is suspended and remove it from async list
                 */
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getstatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = UpdateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    AddVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                UpdateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDAO().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<VM> running) {
    for (Entry<VmDynamic, VmStatistics> vm_helper : _runningVms.values()) {
        VmDynamic runningVm = vm_helper.getKey();
        VM vmToUpdate = null;
        vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getclient_ip())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getstatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getstatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.errorFormat("VdsBroker.VdsUpdateRunTimeInfo.updateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getstatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getstatus() != VMStatus.Up && vmToUpdate.getstatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getstatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else /**
                 * check if vm is suspended and remove it from async list
                 */
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getstatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = UpdateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    AddVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                UpdateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#end_block

#method_before
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getstatus() == VMStatus.MigratingTo) {
        /**
         * inMigration
         */
        log.infoFormat("vds::refreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh till migration is done", runningVm.getId(), _vds.getvds_name());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getstatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDAO().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getrun_on_vds() != null && !vmDynamic.getrun_on_vds().equals(_vds.getId()) && runningVm.getstatus() != VMStatus.Up) {
            log.infoFormat("vds::refreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh till migration is done", runningVm.getId(), runningVm.getstatus(), _vds.getvds_name());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getstatus() == VMStatus.MigratingTo) {
        /**
         * inMigration
         */
        log.infoFormat("vds::refreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh till migration is done", runningVm.getId(), _vds.getvds_name());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getstatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getrun_on_vds() != null && !vmDynamic.getrun_on_vds().equals(_vds.getId()) && runningVm.getstatus() != VMStatus.Up) {
            log.infoFormat("vds::refreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh till migration is done", runningVm.getId(), runningVm.getstatus(), _vds.getvds_name());
            returnValue = true;
        }
    }
    return returnValue;
}
#end_block

#method_before
private boolean UpdateVmRunTimeInfo(RefObject<VM> vmToUpdate, VmDynamic vmNewDynamicData) {
    boolean returnValue = false;
    if (vmToUpdate.argvalue == null) {
        vmToUpdate.argvalue = getDbFacade().getVmDAO().get(vmNewDynamicData.getId());
        // if vm exists in db update info
        if (vmToUpdate.argvalue != null) {
            // TODO: This is done to keep consistency with VmDAO.getById(Guid).
            // It should probably be removed, but some research is required.
            vmToUpdate.argvalue.setInterfaces(getDbFacade().getVmNetworkInterfaceDAO().getAllForVm(vmToUpdate.argvalue.getId()));
            _vmDict.put(vmToUpdate.argvalue.getId(), vmToUpdate.argvalue);
            if (vmNewDynamicData.getstatus() == VMStatus.Up) {
                if (!_succededToRunVms.contains(vmToUpdate.argvalue.getId())) {
                    _succededToRunVms.add(vmToUpdate.argvalue.getId());
                }
            }
        }
    }
    if (vmToUpdate.argvalue != null) {
        // check if dynamic data changed - update cache and DB
        List<String> props = ObjectIdentityChecker.GetChangedFields(vmToUpdate.argvalue.getDynamicData(), vmNewDynamicData);
        // dont check fields:
        props.remove("vm_host");
        props.remove("guest_cur_user_name");
        props.remove("run_on_vds");
        props.remove("disks");
        props.remove("boot_sequence");
        props.remove("last_vds_run_on");
        props.remove("hibernation_vol_handle");
        props.remove("exitMessage");
        if (vmNewDynamicData.getstatus() != VMStatus.Up) {
            props.remove("app_list");
            vmNewDynamicData.setapp_list(vmToUpdate.argvalue.getapp_list());
        } else if (props.contains("status") && vmToUpdate.argvalue.getDynamicData().getstatus() == VMStatus.SavingState) {
            vmNewDynamicData.setstatus(VMStatus.SavingState);
            props.remove("status");
        }
        // if anything else changed
        if (props.size() > 0) {
            vmToUpdate.argvalue.updateRunTimeDynamicData(vmNewDynamicData, _vds.getId(), _vds.getvds_name());
            returnValue = true;
        }
    } else {
        // line.
        if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
            log.info("VDS::UpdateVmRunTimeInfo Error: found VM on a VDS that is not in the database!");
        }
    }
    return returnValue;
}
#method_after
private boolean UpdateVmRunTimeInfo(RefObject<VM> vmToUpdate, VmDynamic vmNewDynamicData) {
    boolean returnValue = false;
    if (vmToUpdate.argvalue == null) {
        vmToUpdate.argvalue = getDbFacade().getVmDao().get(vmNewDynamicData.getId());
        // if vm exists in db update info
        if (vmToUpdate.argvalue != null) {
            // TODO: This is done to keep consistency with VmDAO.getById(Guid).
            // It should probably be removed, but some research is required.
            vmToUpdate.argvalue.setInterfaces(getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vmToUpdate.argvalue.getId()));
            _vmDict.put(vmToUpdate.argvalue.getId(), vmToUpdate.argvalue);
            if (vmNewDynamicData.getstatus() == VMStatus.Up) {
                if (!_succededToRunVms.contains(vmToUpdate.argvalue.getId())) {
                    _succededToRunVms.add(vmToUpdate.argvalue.getId());
                }
            }
        }
    }
    if (vmToUpdate.argvalue != null) {
        // check if dynamic data changed - update cache and DB
        List<String> props = ObjectIdentityChecker.GetChangedFields(vmToUpdate.argvalue.getDynamicData(), vmNewDynamicData);
        // dont check fields:
        props.remove("vm_host");
        props.remove("guest_cur_user_name");
        props.remove("run_on_vds");
        props.remove("disks");
        props.remove("boot_sequence");
        props.remove("last_vds_run_on");
        props.remove("hibernation_vol_handle");
        props.remove("exitMessage");
        if (vmNewDynamicData.getstatus() != VMStatus.Up) {
            props.remove("app_list");
            vmNewDynamicData.setapp_list(vmToUpdate.argvalue.getapp_list());
        } else if (props.contains("status") && vmToUpdate.argvalue.getDynamicData().getstatus() == VMStatus.SavingState) {
            vmNewDynamicData.setstatus(VMStatus.SavingState);
            props.remove("status");
        }
        // if anything else changed
        if (props.size() > 0) {
            vmToUpdate.argvalue.updateRunTimeDynamicData(vmNewDynamicData, _vds.getId(), _vds.getvds_name());
            returnValue = true;
        }
    } else {
        // line.
        if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
            log.info("VDS::UpdateVmRunTimeInfo Error: found VM on a VDS that is not in the database!");
        }
    }
    return returnValue;
}
#end_block

#method_before
private void UpdateInterfaceStatistics(VM vm, VmStatistics statistics) {
    if (statistics.getInterfaceStatistics() == null) {
        return;
    }
    if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
        vm.setInterfaces(getDbFacade().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()));
    }
    List<String> macs = new ArrayList<String>();
    vm.setusage_network_percent(0);
    for (VmNetworkInterface ifStats : statistics.getInterfaceStatistics()) {
        boolean firstTime = !macs.contains(ifStats.getMacAddress());
        VmNetworkInterface vmIface = null;
        for (VmNetworkInterface tempIf : vm.getInterfaces()) {
            if (tempIf.getMacAddress().equals(ifStats.getMacAddress())) {
                vmIface = tempIf;
                break;
            }
        }
        if (vmIface == null) {
            continue;
        }
        // if rtl+pv it will get here 2 times (we take the max one)
        if (firstTime) {
            vmIface.getStatistics().setReceiveRate(ifStats.getStatistics().getReceiveRate());
            vmIface.getStatistics().setReceiveDropRate(ifStats.getStatistics().getReceiveDropRate());
            vmIface.getStatistics().setTransmitRate(ifStats.getStatistics().getTransmitRate());
            vmIface.getStatistics().setTransmitDropRate(ifStats.getStatistics().getTransmitDropRate());
        } else {
            vmIface.getStatistics().setReceiveRate(Math.max(vmIface.getStatistics().getReceiveRate(), ifStats.getStatistics().getReceiveRate()));
            vmIface.getStatistics().setReceiveDropRate(Math.max(vmIface.getStatistics().getReceiveDropRate(), ifStats.getStatistics().getReceiveDropRate()));
            vmIface.getStatistics().setTransmitRate(Math.max(vmIface.getStatistics().getTransmitRate(), ifStats.getStatistics().getTransmitRate()));
            vmIface.getStatistics().setTransmitDropRate(Math.max(vmIface.getStatistics().getTransmitDropRate(), ifStats.getStatistics().getTransmitDropRate()));
        }
        vmIface.setVmId(vm.getId());
        if (ifStats.getSpeed() != null && vmIface.getStatistics().getReceiveRate() != null && vmIface.getStatistics().getReceiveRate() > 0) {
            double rx_percent = vmIface.getStatistics().getReceiveRate();
            double tx_percent = vmIface.getStatistics().getTransmitRate();
            vm.setusage_network_percent(Math.max(vm.getusage_network_percent(), (int) Math.max(rx_percent, tx_percent)));
        }
        if (firstTime) {
            macs.add(ifStats.getMacAddress());
        }
    }
    vm.setusage_network_percent((vm.getusage_network_percent() > 100) ? 100 : vm.getusage_network_percent());
    AddVmInterfaceStatisticsToList(vm.getInterfaces());
}
#method_after
private void UpdateInterfaceStatistics(VM vm, VmStatistics statistics) {
    if (statistics.getInterfaceStatistics() == null) {
        return;
    }
    if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
        vm.setInterfaces(getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
    }
    List<String> macs = new ArrayList<String>();
    vm.setusage_network_percent(0);
    for (VmNetworkInterface ifStats : statistics.getInterfaceStatistics()) {
        boolean firstTime = !macs.contains(ifStats.getMacAddress());
        VmNetworkInterface vmIface = null;
        for (VmNetworkInterface tempIf : vm.getInterfaces()) {
            if (tempIf.getMacAddress().equals(ifStats.getMacAddress())) {
                vmIface = tempIf;
                break;
            }
        }
        if (vmIface == null) {
            continue;
        }
        // if rtl+pv it will get here 2 times (we take the max one)
        if (firstTime) {
            vmIface.getStatistics().setReceiveRate(ifStats.getStatistics().getReceiveRate());
            vmIface.getStatistics().setReceiveDropRate(ifStats.getStatistics().getReceiveDropRate());
            vmIface.getStatistics().setTransmitRate(ifStats.getStatistics().getTransmitRate());
            vmIface.getStatistics().setTransmitDropRate(ifStats.getStatistics().getTransmitDropRate());
        } else {
            vmIface.getStatistics().setReceiveRate(Math.max(vmIface.getStatistics().getReceiveRate(), ifStats.getStatistics().getReceiveRate()));
            vmIface.getStatistics().setReceiveDropRate(Math.max(vmIface.getStatistics().getReceiveDropRate(), ifStats.getStatistics().getReceiveDropRate()));
            vmIface.getStatistics().setTransmitRate(Math.max(vmIface.getStatistics().getTransmitRate(), ifStats.getStatistics().getTransmitRate()));
            vmIface.getStatistics().setTransmitDropRate(Math.max(vmIface.getStatistics().getTransmitDropRate(), ifStats.getStatistics().getTransmitDropRate()));
        }
        vmIface.setVmId(vm.getId());
        if (ifStats.getSpeed() != null && vmIface.getStatistics().getReceiveRate() != null && vmIface.getStatistics().getReceiveRate() > 0) {
            double rx_percent = vmIface.getStatistics().getReceiveRate();
            double tx_percent = vmIface.getStatistics().getTransmitRate();
            vm.setusage_network_percent(Math.max(vm.getusage_network_percent(), (int) Math.max(rx_percent, tx_percent)));
        }
        if (firstTime) {
            macs.add(ifStats.getMacAddress());
        }
    }
    vm.setusage_network_percent((vm.getusage_network_percent() > 100) ? 100 : vm.getusage_network_percent());
    AddVmInterfaceStatisticsToList(vm.getInterfaces());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.CanUpdateField(vds, "vds_group_id", vds.getstatus())) {
        addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    VDSGroup targetCluster = DbFacade.getInstance().getVdsGroupDAO().get(getParameters().getClusterId());
    if (targetCluster == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (getVdsGroup().getstorage_pool_id() != null && isNumberOfVdsInStoragePoolExceed(getVdsGroup().getstorage_pool_id().getValue())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_EXCEEDED_MAXIMUM_NUMBER_OF_HOSTS_IN_DATA_CENTER);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDAO().getForVdsGroup(targetCluster.getId());
    if (targetStoragePool != null && targetStoragePool.getstorage_pool_type() == StorageType.LOCALFS) {
        if (!DbFacade.getInstance().getVdsStaticDAO().getAllForVdsGroup(getParameters().getClusterId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.CanUpdateField(vds, "vds_group_id", vds.getstatus())) {
        addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDao().getForVdsGroup(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.getstorage_pool_type() == StorageType.LOCALFS) {
        if (!DbFacade.getInstance().getVdsStaticDao().getAllForVdsGroup(getParameters().getClusterId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (getGlusterUtils().hasBricks(getVdsId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServer(getTargetCluster())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSGroup sourceCluster = getVdsGroup();
    final Guid targetClusterId = getParameters().getClusterId();
    if (sourceCluster.getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setvds_group_id(targetClusterId);
            DbFacade.getInstance().getVdsStaticDAO().update(staticData);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // handle spm
    getParameters().setCompensationEnabled(true);
    getParameters().setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    if (sourceCluster.getstorage_pool_id() != null) {
        VdcReturnValueBase removeVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.RemoveVdsSpmId, getParameters(), new CommandContext(getCompensationContext()));
        if (!removeVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(removeVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (targetStoragePool != null) {
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, getParameters(), new CommandContext(getCompensationContext()));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    if (targetStoragePool != null) {
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, getParameters(), new CommandContext(getCompensationContext()));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setvds_group_id(targetClusterId);
            DbFacade.getInstance().getVdsStaticDao().update(staticData);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            return;
        }
    }
    // handle spm
    getParameters().setCompensationEnabled(true);
    getParameters().setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    if (getSourceCluster().getstorage_pool_id() != null) {
        VdcReturnValueBase removeVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.RemoveVdsSpmId, getParameters(), new CommandContext(getCompensationContext()));
        if (!removeVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(removeVdsSpmIdReturn.getFault());
            return;
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.USER_UPDATE_VDS : AuditLogType.USER_FAILED_UPDATE_VDS;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.USER_UPDATE_VDS : errorType;
}
#end_block

#method_before
public static void Init() {
    TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            for (storage_pool sp : DbFacade.getInstance().getStoragePoolDAO().getAll()) {
                if (!_irsProxyData.containsKey(sp.getId())) {
                    _irsProxyData.put(sp.getId(), new IrsProxyData(sp.getId()));
                }
            }
            return null;
        }
    });
}
#method_after
public static void Init() {
    TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            for (storage_pool sp : DbFacade.getInstance().getStoragePoolDao().getAll()) {
                if (!_irsProxyData.containsKey(sp.getId())) {
                    _irsProxyData.put(sp.getId(), new IrsProxyData(sp.getId()));
                }
            }
            return null;
        }
    });
}
#end_block

#method_before
@OnTimerMethodAnnotation("_updatingTimer_Elapsed")
public void _updatingTimer_Elapsed() {
    try {
        synchronized (syncObj) {
            if (!_disposed) {
                TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        storage_pool storagePool = DbFacade.getInstance().getStoragePoolDAO().get(_storagePoolId);
                        if (storagePool != null && (storagePool.getstatus() == StoragePoolStatus.Up || storagePool.getstatus() == StoragePoolStatus.Problematic || storagePool.getstatus() == StoragePoolStatus.Contend)) {
                            ProceedStoragePoolStats();
                        }
                        return null;
                    }
                });
            }
        }
    } catch (java.lang.Exception ex) {
    }
}
#method_after
@OnTimerMethodAnnotation("_updatingTimer_Elapsed")
public void _updatingTimer_Elapsed() {
    try {
        synchronized (syncObj) {
            if (!_disposed) {
                TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
                        if (storagePool != null && (storagePool.getstatus() == StoragePoolStatus.Up || storagePool.getstatus() == StoragePoolStatus.Problematic || storagePool.getstatus() == StoragePoolStatus.Contend)) {
                            ProceedStoragePoolStats();
                        }
                        return null;
                    }
                });
            }
        }
    } catch (java.lang.Exception ex) {
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void ProceedStoragePoolStats() {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    if (mCurrentVdsId != null) {
        result = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(mCurrentVdsId, _storagePoolId));
    }
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDAO().get(_storagePoolId);
    if (storagePool != null) {
        if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
            // update pool status to problematic until fence will happen
            if (storagePool.getstatus() != StoragePoolStatus.Problematic && storagePool.getstatus() != StoragePoolStatus.NotOperational) {
                if (result != null && result.getVdsError() != null) {
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
                } else {
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
                }
            }
            // then cause failover with attempts
            if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
                java.util.HashMap<Guid, AsyncTaskStatus> tasksList = (java.util.HashMap<Guid, AsyncTaskStatus>) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(mCurrentVdsId)).getReturnValue();
                boolean allTasksFinished = true;
                if (tasksList != null) {
                    for (AsyncTaskStatus taskStatus : tasksList.values()) {
                        if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                            allTasksFinished = false;
                            break;
                        }
                    }
                }
                if ((tasksList == null) || allTasksFinished) {
                    setmIrsProxy(null);
                    setmCurrentIrsHost(null);
                } else {
                    if (_errorAttempts < Config.<Integer>GetValue(ConfigValues.SPMFailOverAttempts)) {
                        _errorAttempts++;
                        log.warnFormat("failed getting spm status for pool {0}:{1}, attempt number {2}", _storagePoolId, storagePool.getname(), _errorAttempts);
                    } else {
                        setmIrsProxy(null);
                        setmCurrentIrsHost(null);
                        _errorAttempts = 0;
                    }
                }
            }
        } else if (result != null && result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getstatus() == StoragePoolStatus.Problematic || storagePool.getstatus() == StoragePoolStatus.Contend)) {
            // if recovered from network exception set back to up
            DbFacade.getInstance().getStoragePoolDAO().updateStatus(storagePool.getId(), StoragePoolStatus.Up);
            storagePool.setstatus(StoragePoolStatus.Up);
            ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getstatus());
        }
        GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
        tempVar.setIgnoreFailoverLimit(true);
        VDSReturnValue storagePoolInfoResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
        if (storagePoolInfoResult.getSucceeded()) {
            KeyValuePairCompat<storage_pool, java.util.List<storage_domains>> data = (KeyValuePairCompat<storage_pool, java.util.List<storage_domains>>) storagePoolInfoResult.getReturnValue();
            int masterVersion = data.getKey().getmaster_domain_version();
            java.util.HashSet<Guid> domainsInVds = new java.util.HashSet<Guid>();
            for (storage_domains domainData : data.getValue()) {
                domainsInVds.add(domainData.getId());
                ProceedStorageDomain(domainData, masterVersion, storagePool);
            }
            List<storage_domains> domainsInDb = DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(_storagePoolId);
            for (final storage_domains domainInDb : domainsInDb) {
                if (domainInDb.getstorage_domain_type() != StorageDomainType.Master && domainInDb.getstatus() != StorageDomainStatus.Locked && !domainsInVds.contains(domainInDb.getId())) {
                    // domain not attached to pool anymore
                    TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            DbFacade.getInstance().getStoragePoolIsoMapDAO().remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
                            return null;
                        }
                    });
                }
            }
        }
    }
}
#method_after
@SuppressWarnings("unchecked")
private void ProceedStoragePoolStats() {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    if (mCurrentVdsId != null) {
        result = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(mCurrentVdsId, _storagePoolId));
    }
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null) {
        if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
            // update pool status to problematic until fence will happen
            if (storagePool.getstatus() != StoragePoolStatus.Problematic && storagePool.getstatus() != StoragePoolStatus.NotOperational) {
                if (result != null && result.getVdsError() != null) {
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
                } else {
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
                }
            }
            // then cause failover with attempts
            if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
                java.util.HashMap<Guid, AsyncTaskStatus> tasksList = (java.util.HashMap<Guid, AsyncTaskStatus>) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(mCurrentVdsId)).getReturnValue();
                boolean allTasksFinished = true;
                if (tasksList != null) {
                    for (AsyncTaskStatus taskStatus : tasksList.values()) {
                        if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                            allTasksFinished = false;
                            break;
                        }
                    }
                }
                if ((tasksList == null) || allTasksFinished) {
                    setmIrsProxy(null);
                    setmCurrentIrsHost(null);
                } else {
                    if (_errorAttempts < Config.<Integer>GetValue(ConfigValues.SPMFailOverAttempts)) {
                        _errorAttempts++;
                        log.warnFormat("failed getting spm status for pool {0}:{1}, attempt number {2}", _storagePoolId, storagePool.getname(), _errorAttempts);
                    } else {
                        setmIrsProxy(null);
                        setmCurrentIrsHost(null);
                        _errorAttempts = 0;
                    }
                }
            }
        } else if (result != null && result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getstatus() == StoragePoolStatus.Problematic || storagePool.getstatus() == StoragePoolStatus.Contend)) {
            // if recovered from network exception set back to up
            DbFacade.getInstance().getStoragePoolDao().updateStatus(storagePool.getId(), StoragePoolStatus.Up);
            storagePool.setstatus(StoragePoolStatus.Up);
            ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getstatus());
        }
        GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
        tempVar.setIgnoreFailoverLimit(true);
        VDSReturnValue storagePoolInfoResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
        if (storagePoolInfoResult.getSucceeded()) {
            KeyValuePairCompat<storage_pool, java.util.List<storage_domains>> data = (KeyValuePairCompat<storage_pool, java.util.List<storage_domains>>) storagePoolInfoResult.getReturnValue();
            int masterVersion = data.getKey().getmaster_domain_version();
            java.util.HashSet<Guid> domainsInVds = new java.util.HashSet<Guid>();
            for (storage_domains domainData : data.getValue()) {
                domainsInVds.add(domainData.getId());
                ProceedStorageDomain(domainData, masterVersion, storagePool);
            }
            List<storage_domains> domainsInDb = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(_storagePoolId);
            for (final storage_domains domainInDb : domainsInDb) {
                if (domainInDb.getstorage_domain_type() != StorageDomainType.Master && domainInDb.getstatus() != StorageDomainStatus.Locked && !domainsInVds.contains(domainInDb.getId())) {
                    // domain not attached to pool anymore
                    TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
                            return null;
                        }
                    });
                }
            }
        }
    }
}
#end_block

#method_before
private void ProceedStorageDomain(storage_domains data, int dataMasterVersion, storage_pool storagePool) {
    storage_domains storage_domain = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(data.getId(), _storagePoolId);
    storage_domain_static domainFromDb = null;
    storage_pool_iso_map domainPoolMap = null;
    if (storage_domain != null) {
        domainFromDb = storage_domain.getStorageStaticData();
        domainPoolMap = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getstorage_domain_type() == StorageDomainType.Master && domainPoolMap != null && domainPoolMap.getstatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((data.getstorage_domain_type() == StorageDomainType.Master) || (data.getstorage_domain_type() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(data.getstorage_pool_id().getValue(), domainFromDb.getId(), "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getstorage_name()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getmaster_domain_version()) {
                reconstructMasterDomainNotInSync(data.getstorage_pool_id().getValue(), domainFromDb.getId(), "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getstorage_name(), storagePool.getmaster_domain_version(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMap == null) {
            data.setstorage_pool_id(_storagePoolId);
            DbFacade.getInstance().getStoragePoolIsoMapDAO().save(data.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (domainPoolMap.getstatus() != StorageDomainStatus.Locked && domainPoolMap.getstatus() != data.getstatus()) {
            if (domainPoolMap.getstatus() != StorageDomainStatus.Maintenance || data.getstatus() != StorageDomainStatus.InActive) {
                DbFacade.getInstance().getStoragePoolIsoMapDAO().update(data.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (data.getstatus() != null && (data.getstatus() == StorageDomainStatus.InActive || data.getstatus() == StorageDomainStatus.Maintenance) && domainFromDb.getstorage_domain_type() == StorageDomainType.Master) {
                storage_pool pool = DbFacade.getInstance().getStoragePoolDAO().get(domainPoolMap.getstorage_pool_id().getValue());
                if (pool != null) {
                    DbFacade.getInstance().getStoragePoolDAO().updateStatus(pool.getId(), StoragePoolStatus.Maintanance);
                    pool.setstatus(StoragePoolStatus.Maintanance);
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintanance);
                }
            }
        }
        // update dynamic data
        if (statusChanged || data.getstatus() == StorageDomainStatus.Active) {
            DbFacade.getInstance().getStorageDomainDynamicDAO().update(data.getStorageDynamicData());
            if (data.getavailable_disk_size() != null && data.getused_disk_size() != null) {
                int freePercent = data.getStorageDynamicData().getfreeDiskPercent();
                int freeDiskInGB = data.getStorageDynamicData().getfreeDiskInGB();
                AuditLogType type = AuditLogType.UNASSIGNED;
                boolean spaceThresholdMet = freeDiskInGB <= Config.<Integer>GetValue(ConfigValues.FreeSpaceCriticalLowInGB);
                boolean percentThresholdMet = freePercent <= Config.<Integer>GetValue(ConfigValues.FreeSpaceLow);
                if (spaceThresholdMet && percentThresholdMet) {
                    type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                } else {
                    if (spaceThresholdMet || percentThresholdMet) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setStorageDomain(data);
                    logable.setStoragePoolId(_storagePoolId);
                    logable.AddCustomValue("DiskSpace", (data.getavailable_disk_size()).toString());
                    data.setstorage_name(domainFromDb.getstorage_name());
                    AuditLogDirector.log(logable, type);
                }
            }
            Set<VdcBllErrors> alerts = data.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.setStorageDomain(data);
                data.setstorage_name(domainFromDb.getstorage_name());
                logable.setStoragePoolId(_storagePoolId);
                for (VdcBllErrors alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.errorFormat("Unrecognized alert for domain {0}(id = {1}): {2}", data.getstorage_name(), data.getId(), alert);
                            break;
                    }
                }
            }
        }
    } else {
        log.debugFormat("The domain with id {0} was not found in DB", data.getId());
    }
}
#method_after
private void ProceedStorageDomain(storage_domains data, int dataMasterVersion, storage_pool storagePool) {
    storage_domains storage_domain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(data.getId(), _storagePoolId);
    storage_domain_static domainFromDb = null;
    storage_pool_iso_map domainPoolMap = null;
    if (storage_domain != null) {
        domainFromDb = storage_domain.getStorageStaticData();
        domainPoolMap = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getstorage_domain_type() == StorageDomainType.Master && domainPoolMap != null && domainPoolMap.getstatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((data.getstorage_domain_type() == StorageDomainType.Master) || (data.getstorage_domain_type() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(data.getstorage_pool_id().getValue(), domainFromDb.getId(), "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getstorage_name()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getmaster_domain_version()) {
                reconstructMasterDomainNotInSync(data.getstorage_pool_id().getValue(), domainFromDb.getId(), "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getstorage_name(), storagePool.getmaster_domain_version(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMap == null) {
            data.setstorage_pool_id(_storagePoolId);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(data.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (domainPoolMap.getstatus() != StorageDomainStatus.Locked && domainPoolMap.getstatus() != data.getstatus()) {
            if (domainPoolMap.getstatus() != StorageDomainStatus.InActive && data.getstatus() != StorageDomainStatus.InActive) {
                DbFacade.getInstance().getStoragePoolIsoMapDao().update(data.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (data.getstatus() != null && data.getstatus() == StorageDomainStatus.InActive && domainFromDb.getstorage_domain_type() == StorageDomainType.Master) {
                storage_pool pool = DbFacade.getInstance().getStoragePoolDao().get(domainPoolMap.getstorage_pool_id().getValue());
                if (pool != null) {
                    DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), StoragePoolStatus.Maintanance);
                    pool.setstatus(StoragePoolStatus.Maintanance);
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintanance);
                }
            }
        }
        // update dynamic data
        if (statusChanged || (domainPoolMap.getstatus() != StorageDomainStatus.InActive && data.getstatus() == StorageDomainStatus.Active)) {
            DbFacade.getInstance().getStorageDomainDynamicDao().update(data.getStorageDynamicData());
            if (data.getavailable_disk_size() != null && data.getused_disk_size() != null) {
                int freePercent = data.getStorageDynamicData().getfreeDiskPercent();
                int freeDiskInGB = data.getStorageDynamicData().getfreeDiskInGB();
                AuditLogType type = AuditLogType.UNASSIGNED;
                boolean spaceThresholdMet = freeDiskInGB <= Config.<Integer>GetValue(ConfigValues.FreeSpaceCriticalLowInGB);
                boolean percentThresholdMet = freePercent <= Config.<Integer>GetValue(ConfigValues.FreeSpaceLow);
                if (spaceThresholdMet && percentThresholdMet) {
                    type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                } else {
                    if (spaceThresholdMet || percentThresholdMet) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setStorageDomain(data);
                    logable.setStoragePoolId(_storagePoolId);
                    logable.AddCustomValue("DiskSpace", (data.getavailable_disk_size()).toString());
                    data.setstorage_name(domainFromDb.getstorage_name());
                    AuditLogDirector.log(logable, type);
                }
            }
            Set<VdcBllErrors> alerts = data.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.setStorageDomain(data);
                data.setstorage_name(domainFromDb.getstorage_name());
                logable.setStoragePoolId(_storagePoolId);
                for (VdcBllErrors alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.errorFormat("Unrecognized alert for domain {0}(id = {1}): {2}", data.getstorage_name(), data.getId(), alert);
                            break;
                    }
                }
            }
        }
    } else {
        log.debugFormat("The domain with id {0} was not found in DB", data.getId());
    }
}
#end_block

#method_before
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        storage_pool storagePool = DbFacade.getInstance().getStoragePoolDAO().get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getstatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<String>() {

                @Override
                public String runInTransaction() {
                    return gethostFromVds();
                }
            });
            if (host != null) {
                int clientTimeOut = Config.<Integer>GetValue(ConfigValues.vdsTimeout) * 1000;
                KeyValuePairCompat<IrsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(host, getmIrsPort(), clientTimeOut, IrsServerConnector.class, Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers));
                setmIrsProxy(new IrsServerWrapper(returnValue.getKey(), returnValue.getValue()));
                Class[] inputTypes = new Class[] { storage_pool.class, boolean.class };
                Object[] inputParams = new Object[] { storagePool, _isSpmStartCalled };
                // TODO use thread pool
                SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "StorageEventOnTimer", inputTypes, inputParams, 0, TimeUnit.MILLISECONDS);
            }
        }
    }
    return getmIrsProxy();
}
#method_after
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getstatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<String>() {

                @Override
                public String runInTransaction() {
                    return gethostFromVds();
                }
            });
            if (host != null) {
                int clientTimeOut = Config.<Integer>GetValue(ConfigValues.vdsTimeout) * 1000;
                KeyValuePairCompat<IrsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(host, getmIrsPort(), clientTimeOut, IrsServerConnector.class, Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers));
                setmIrsProxy(new IrsServerWrapper(returnValue.getKey(), returnValue.getValue()));
                Class[] inputTypes = new Class[] { storage_pool.class, boolean.class };
                Object[] inputParams = new Object[] { storagePool, _isSpmStartCalled };
                // TODO use thread pool
                SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "StorageEventOnTimer", inputTypes, inputParams, 0, TimeUnit.MILLISECONDS);
            }
        }
    }
    return getmIrsProxy();
}
#end_block

#method_before
private List<VDS> GetNonOperationalVdssInPool() {
    List<VDS> allVds = DbFacade.getInstance().getVdsDAO().getAll();
    List<VDS> nonOperationalvdsInPool = new ArrayList<VDS>();
    for (VDS vds : allVds) {
        if (VDSStatus.NonOperational == vds.getstatus() && _storagePoolId.equals(vds.getstorage_pool_id())) {
            nonOperationalvdsInPool.add(vds);
        }
    }
    return nonOperationalvdsInPool;
}
#method_after
private List<VDS> GetNonOperationalVdssInPool() {
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAll();
    List<VDS> nonOperationalvdsInPool = new ArrayList<VDS>();
    for (VDS vds : allVds) {
        if (VDSStatus.NonOperational == vds.getstatus() && _storagePoolId.equals(vds.getstorage_pool_id())) {
            nonOperationalvdsInPool.add(vds);
        }
    }
    return nonOperationalvdsInPool;
}
#end_block

#method_before
private String gethostFromVds() {
    _isSpmStartCalled = false;
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDAO().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = GetPrioritizedVdsInPool();
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    WaitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getstatus();
    if (prevStatus != StoragePoolStatus.Problematic) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!curVdsId.equals(Guid.Empty) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDAO().get(curVdsId);
        if (selectedVds.getstatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        mCurrentVdsId = selectedVds.getId();
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getvds_spm_id();
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        if (spmStatus != null) {
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getvds_name(), spmStatus.getSpmStatus().toString(), storagePool.getname());
            if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                Guid masterId = DbFacade.getInstance().getStorageDomainDAO().getMasterStorageDomainIdForPool(_storagePoolId);
                VDSReturnValue connectResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(selectedVds.getId(), _storagePoolId, selectedVds.getvds_spm_id(), masterId, storagePool.getmaster_domain_version()));
                if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
                    throw connectResult.getExceptionObject();
                } else if (!connectResult.getSucceeded()) {
                    // failover
                    throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
                }
                performedPoolConnect = true;
                // refresh spmStatus result
                spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getvds_name(), spmStatus.getSpmStatus().toString(), storagePool.getname());
            }
            RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
            spmStatus = HandleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
            selectedVds = tempRefObject.argvalue;
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = HandleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getvds_name());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#method_after
private String gethostFromVds() {
    _isSpmStartCalled = false;
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = GetPrioritizedVdsInPool();
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    WaitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getstatus();
    if (prevStatus != StoragePoolStatus.Problematic) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!curVdsId.equals(Guid.Empty) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getstatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        mCurrentVdsId = selectedVds.getId();
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getvds_spm_id();
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        if (spmStatus != null) {
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getvds_name(), spmStatus.getSpmStatus().toString(), storagePool.getname());
            if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                Guid masterId = DbFacade.getInstance().getStorageDomainDao().getMasterStorageDomainIdForPool(_storagePoolId);
                VDSReturnValue connectResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(selectedVds.getId(), _storagePoolId, selectedVds.getvds_spm_id(), masterId, storagePool.getmaster_domain_version()));
                if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
                    throw connectResult.getExceptionObject();
                } else if (!connectResult.getSucceeded()) {
                    // failover
                    throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
                }
                performedPoolConnect = true;
                // refresh spmStatus result
                spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getvds_name(), spmStatus.getSpmStatus().toString(), storagePool.getname());
            }
            RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
            spmStatus = HandleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
            selectedVds = tempRefObject.argvalue;
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = HandleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getvds_name());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
private List<VDS> GetPrioritizedVdsInPool() {
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    // Gets a list of the hosts in the storagePool, that are "UP", ordered
    // by vds_spm_priority (not including -1) and secondly ordered by RANDOM(), to
    // deal with the case that there are several hosts with the same priority.
    List<VDS> allVds = DbFacade.getInstance().getVdsDAO().getListForSpmSelection(_storagePoolId);
    List<VDS> vdsRelevantForSpmSelection = new ArrayList<VDS>();
    for (VDS vds : allVds) {
        if (!mTriedVdssList.contains(vds.getId()) && !vds.getId().equals(curVdsId)) {
            vdsRelevantForSpmSelection.add(vds);
        }
    }
    return vdsRelevantForSpmSelection;
}
#method_after
private List<VDS> GetPrioritizedVdsInPool() {
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    // Gets a list of the hosts in the storagePool, that are "UP", ordered
    // by vds_spm_priority (not including -1) and secondly ordered by RANDOM(), to
    // deal with the case that there are several hosts with the same priority.
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getListForSpmSelection(_storagePoolId);
    List<VDS> vdsRelevantForSpmSelection = new ArrayList<VDS>();
    for (VDS vds : allVds) {
        if (!mTriedVdssList.contains(vds.getId()) && !vds.getId().equals(curVdsId)) {
            vdsRelevantForSpmSelection.add(vds);
        }
    }
    return vdsRelevantForSpmSelection;
}
#end_block

#method_before
private String HandleSelectedVdsForSPM(storage_pool storagePool, RefObject<VDS> selectedVds, RefObject<SpmStatusResult> spmStatus, StoragePoolStatus prevStatus) {
    String returnValue = null;
    if (spmStatus.argvalue == null || spmStatus.argvalue.getSpmStatus() != SpmStatus.SPM) {
        MovePoolToProblematicInDB(storagePool, true);
        selectedVds.argvalue = null;
        log.infoFormat("spm start treatment ended and status is not SPM!!! status: {0} - setting selectedVds to null!", spmStatus.argvalue.getSpmStatus().toString());
    } else {
        Init(selectedVds.argvalue);
        storagePool.setLVER(spmStatus.argvalue.getSpmLVER());
        storagePool.setspm_vds_id(selectedVds.argvalue.getId());
        // host move pool to up
        if (prevStatus != StoragePoolStatus.NotOperational && prevStatus != StoragePoolStatus.Problematic) {
            storagePool.setstatus(prevStatus);
        } else {
            storagePool.setstatus(StoragePoolStatus.Up);
        }
        DbFacade.getInstance().getStoragePoolDAO().update(storagePool);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getstatus());
        returnValue = selectedVds.argvalue.gethost_name();
        log.infoFormat("Initialize Irs proxy from vds: {0}", returnValue);
        AuditLogableBase logable = new AuditLogableBase(selectedVds.argvalue.getId());
        logable.AddCustomValue("ServerIp", returnValue);
        AuditLogDirector.log(logable, AuditLogType.IRS_HOSTED_ON_VDS);
    }
    return returnValue;
}
#method_after
private String HandleSelectedVdsForSPM(storage_pool storagePool, RefObject<VDS> selectedVds, RefObject<SpmStatusResult> spmStatus, StoragePoolStatus prevStatus) {
    String returnValue = null;
    if (spmStatus.argvalue == null || spmStatus.argvalue.getSpmStatus() != SpmStatus.SPM) {
        MovePoolToProblematicInDB(storagePool, true);
        selectedVds.argvalue = null;
        log.infoFormat("spm start treatment ended and status is not SPM!!! status: {0} - setting selectedVds to null!", spmStatus.argvalue.getSpmStatus().toString());
    } else {
        Init(selectedVds.argvalue);
        storagePool.setLVER(spmStatus.argvalue.getSpmLVER());
        storagePool.setspm_vds_id(selectedVds.argvalue.getId());
        // host move pool to up
        if (prevStatus != StoragePoolStatus.NotOperational && prevStatus != StoragePoolStatus.Problematic) {
            storagePool.setstatus(prevStatus);
        } else {
            storagePool.setstatus(StoragePoolStatus.Up);
        }
        DbFacade.getInstance().getStoragePoolDao().update(storagePool);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getstatus());
        returnValue = selectedVds.argvalue.gethost_name();
        log.infoFormat("Initialize Irs proxy from vds: {0}", returnValue);
        AuditLogableBase logable = new AuditLogableBase(selectedVds.argvalue.getId());
        logable.AddCustomValue("ServerIp", returnValue);
        AuditLogDirector.log(logable, AuditLogType.IRS_HOSTED_ON_VDS);
    }
    return returnValue;
}
#end_block

#method_before
private void WaitForVdsIfIsInitializing(Guid curVdsId) {
    if (curVdsId != Guid.Empty && DbFacade.getInstance().getVdsDAO().get(curVdsId).getstatus() == VDSStatus.Initializing) {
        // 5 Sec
        final int DELAY = 5;
        int total = 0;
        Integer maxSecToWait = Config.GetValue(ConfigValues.WaitForVdsInitInSec);
        String vdsName = DbFacade.getInstance().getVdsDAO().get(curVdsId).getvds_name();
        while (total <= maxSecToWait && DbFacade.getInstance().getVdsDAO().get(curVdsId).getstatus() == VDSStatus.Initializing) {
            try {
                Thread.sleep(DELAY * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
                // exit the while block
                break;
            }
            total += DELAY;
            log.infoFormat("Waiting to Host {0} to finish initialization for {1} Sec.", vdsName, total);
        }
    }
}
#method_after
private void WaitForVdsIfIsInitializing(Guid curVdsId) {
    if (curVdsId != Guid.Empty && DbFacade.getInstance().getVdsDao().get(curVdsId).getstatus() == VDSStatus.Initializing) {
        // 5 Sec
        final int DELAY = 5;
        int total = 0;
        Integer maxSecToWait = Config.GetValue(ConfigValues.WaitForVdsInitInSec);
        String vdsName = DbFacade.getInstance().getVdsDao().get(curVdsId).getvds_name();
        while (total <= maxSecToWait && DbFacade.getInstance().getVdsDao().get(curVdsId).getstatus() == VDSStatus.Initializing) {
            try {
                Thread.sleep(DELAY * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
                // exit the while block
                break;
            }
            total += DELAY;
            log.infoFormat("Waiting to Host {0} to finish initialization for {1} Sec.", vdsName, total);
        }
    }
}
#end_block

#method_before
private static void MovePoolToProblematicInDB(storage_pool storagePool, boolean resetSpmInDB) {
    ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
    if (resetSpmInDB) {
        storagePool.setspm_vds_id(null);
        DbFacade.getInstance().getStoragePoolDAO().update(storagePool);
    }
}
#method_after
private static void MovePoolToProblematicInDB(storage_pool storagePool, boolean resetSpmInDB) {
    ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
    if (resetSpmInDB) {
        storagePool.setspm_vds_id(null);
        DbFacade.getInstance().getStoragePoolDao().update(storagePool);
    }
}
#end_block

#method_before
private SpmStatusResult HandleSpmStatusResult(Guid curVdsId, List<VDS> vdsByPool, final storage_pool storagePool, RefObject<VDS> selectedVds, SpmStatusResult spmStatus) {
    if (spmStatus.getSpmStatus() == SpmStatus.Free) {
        int vdsSpmIdToFence = -1;
        boolean startSpm = true;
        if (spmStatus.getSpmId() != -1) {
            int spmId = spmStatus.getSpmId();
            Guid spmVdsId = Guid.Empty;
            VDS spmVds = null;
            if (selectedVds.argvalue.getvds_spm_id() == spmId) {
                spmVdsId = selectedVds.argvalue.getId();
            } else {
                for (VDS tempVds : vdsByPool) {
                    if (tempVds.getvds_spm_id() == spmId) {
                        log.infoFormat("Found spm host {0}, host name: {1}, according to spmId: {2}.", tempVds.getId(), tempVds.getvds_name(), spmId);
                        spmVds = tempVds;
                        break;
                    }
                }
                // non operational we want to find it as well
                if (spmVds == null) {
                    List<VDS> nonOperationalVds = GetNonOperationalVdssInPool();
                    for (VDS tempVds : nonOperationalVds) {
                        if (tempVds.getvds_spm_id() == spmId) {
                            spmVds = tempVds;
                            break;
                        }
                    }
                }
                if (spmVds != null) {
                    spmVdsId = spmVds.getId();
                } else if (!curVdsId.equals(Guid.Empty)) {
                    VDS currentVds = DbFacade.getInstance().getVdsDAO().get(curVdsId);
                    if (currentVds != null && currentVds.getstatus() == VDSStatus.Up && currentVds.getvds_spm_id() != null && currentVds.getvds_spm_id().equals(spmId)) {
                        spmVdsId = curVdsId;
                        spmVds = currentVds;
                    }
                }
            }
            try {
                if (!spmVdsId.equals(Guid.Empty)) {
                    SpmStatusResult destSpmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(spmVdsId, _storagePoolId)).getReturnValue();
                    log.infoFormat("SpmStatus on vds {0}: {1}", spmVdsId, destSpmStatus == null ? "NULL" : destSpmStatus.getSpmStatus().toString());
                    /**
                     * intentional unreachable code
                     */
                    if (destSpmStatus != null && destSpmStatus.getSpmStatus() == SpmStatus.SPM) {
                        if (spmVdsId != selectedVds.argvalue.getId() && spmVds != null && spmVds.getstatus() == VDSStatus.Up) {
                            selectedVds.argvalue = spmVds;
                            startSpm = false;
                            log.infoFormat("Using old spm server: {0}, no start needed", spmVds.getvds_name());
                            return destSpmStatus;
                        } else // VDS is non-operational and SPM
                        {
                            log.warn("Host reports to be SPM but is not up. " + spmVdsId);
                            vdsSpmIdToFence = spmStatus.getSpmId();
                        }
                    } else // it is not SPM and continue.
                    if (destSpmStatus == null || (destSpmStatus.getSpmStatus() != SpmStatus.Free && destSpmStatus.getSpmStatus() != SpmStatus.Unknown_Pool)) {
                        vdsSpmIdToFence = spmStatus.getSpmId();
                    }
                } else {
                    log.errorFormat("SPM Init: could not find reported vds or not up - pool:{0} vds_spm_id: {1}", storagePool.getname(), spmStatus.getSpmId());
                    vdsSpmIdToFence = spmStatus.getSpmId();
                }
            } catch (java.lang.Exception ex) {
                vdsSpmIdToFence = spmStatus.getSpmId();
            }
        }
        if (startSpm) {
            vds_spm_id_map map = DbFacade.getInstance().getVdsSpmIdMapDAO().get(_storagePoolId, vdsSpmIdToFence);
            if (map != null) {
                VDS vdsToFenceObject = DbFacade.getInstance().getVdsDAO().get(map.getId());
                if (vdsToFenceObject != null) {
                    log.infoFormat("SPM selection - vds seems as spm {0}", vdsToFenceObject.getvds_name());
                    if (vdsToFenceObject.getstatus() == VDSStatus.NonResponsive) {
                        log.warn("spm vds is non responsive, stopping spm selection.");
                        selectedVds.argvalue = null;
                        return spmStatus;
                    } else {
                        // try to stop spm
                        VDSReturnValue spmStopReturnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsToFenceObject.getId(), _storagePoolId));
                        // continue with spm selection
                        if (spmStopReturnValue != null && spmStopReturnValue.getSucceeded()) {
                            log.info("spm stop succeeded, continuing with spm selection");
                        } else // if spm stop failed for any reason we stop spm
                        // selection
                        {
                            log.warn("spm stop on spm failed, stopping spm selection!");
                            selectedVds.argvalue = null;
                            return spmStatus;
                        }
                    }
                }
            }
            storagePool.setstatus(StoragePoolStatus.Contend);
            storagePool.setspm_vds_id(selectedVds.argvalue.getId());
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    DbFacade.getInstance().getStoragePoolDAO().update(storagePool);
                    return null;
                }
            });
            log.infoFormat("starting spm on vds {0}, storage pool {1}, prevId {2}, LVER {3}", selectedVds.argvalue.getvds_name(), storagePool.getname(), spmStatus.getSpmId(), spmStatus.getSpmLVER());
            spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.argvalue.getId(), _storagePoolId, spmStatus.getSpmId(), spmStatus.getSpmLVER(), storagePool.getrecovery_mode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
            if (spmStatus != null && spmStatus.getSpmStatus() == SpmStatus.SPM) {
                _isSpmStartCalled = true;
            } else {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
                if (spmStatus != null) {
                    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            storage_pool pool = DbFacade.getInstance().getStoragePoolDAO().get(storagePool.getId());
                            pool.setspm_vds_id(null);
                            DbFacade.getInstance().getStoragePoolDAO().update(pool);
                            return null;
                        }
                    });
                }
                throw new IrsSpmStartFailedException();
            }
        }
    }
    return spmStatus;
}
#method_after
private SpmStatusResult HandleSpmStatusResult(Guid curVdsId, List<VDS> vdsByPool, final storage_pool storagePool, RefObject<VDS> selectedVds, SpmStatusResult spmStatus) {
    if (spmStatus.getSpmStatus() == SpmStatus.Free) {
        int vdsSpmIdToFence = -1;
        boolean startSpm = true;
        if (spmStatus.getSpmId() != -1) {
            int spmId = spmStatus.getSpmId();
            Guid spmVdsId = Guid.Empty;
            VDS spmVds = null;
            if (selectedVds.argvalue.getvds_spm_id() == spmId) {
                spmVdsId = selectedVds.argvalue.getId();
            } else {
                for (VDS tempVds : vdsByPool) {
                    if (tempVds.getvds_spm_id() == spmId) {
                        log.infoFormat("Found spm host {0}, host name: {1}, according to spmId: {2}.", tempVds.getId(), tempVds.getvds_name(), spmId);
                        spmVds = tempVds;
                        break;
                    }
                }
                // non operational we want to find it as well
                if (spmVds == null) {
                    List<VDS> nonOperationalVds = GetNonOperationalVdssInPool();
                    for (VDS tempVds : nonOperationalVds) {
                        if (tempVds.getvds_spm_id() == spmId) {
                            spmVds = tempVds;
                            break;
                        }
                    }
                }
                if (spmVds != null) {
                    spmVdsId = spmVds.getId();
                } else if (!curVdsId.equals(Guid.Empty)) {
                    VDS currentVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
                    if (currentVds != null && currentVds.getstatus() == VDSStatus.Up && currentVds.getvds_spm_id() != null && currentVds.getvds_spm_id().equals(spmId)) {
                        spmVdsId = curVdsId;
                        spmVds = currentVds;
                    }
                }
            }
            try {
                if (!spmVdsId.equals(Guid.Empty)) {
                    SpmStatusResult destSpmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(spmVdsId, _storagePoolId)).getReturnValue();
                    log.infoFormat("SpmStatus on vds {0}: {1}", spmVdsId, destSpmStatus == null ? "NULL" : destSpmStatus.getSpmStatus().toString());
                    /**
                     * intentional unreachable code
                     */
                    if (destSpmStatus != null && destSpmStatus.getSpmStatus() == SpmStatus.SPM) {
                        if (spmVdsId != selectedVds.argvalue.getId() && spmVds != null && spmVds.getstatus() == VDSStatus.Up) {
                            selectedVds.argvalue = spmVds;
                            startSpm = false;
                            log.infoFormat("Using old spm server: {0}, no start needed", spmVds.getvds_name());
                            return destSpmStatus;
                        } else // VDS is non-operational and SPM
                        {
                            log.warn("Host reports to be SPM but is not up. " + spmVdsId);
                            vdsSpmIdToFence = spmStatus.getSpmId();
                        }
                    } else // it is not SPM and continue.
                    if (destSpmStatus == null || (destSpmStatus.getSpmStatus() != SpmStatus.Free && destSpmStatus.getSpmStatus() != SpmStatus.Unknown_Pool)) {
                        vdsSpmIdToFence = spmStatus.getSpmId();
                    }
                } else {
                    log.errorFormat("SPM Init: could not find reported vds or not up - pool:{0} vds_spm_id: {1}", storagePool.getname(), spmStatus.getSpmId());
                    vdsSpmIdToFence = spmStatus.getSpmId();
                }
            } catch (java.lang.Exception ex) {
                vdsSpmIdToFence = spmStatus.getSpmId();
            }
        }
        if (startSpm) {
            vds_spm_id_map map = DbFacade.getInstance().getVdsSpmIdMapDao().get(_storagePoolId, vdsSpmIdToFence);
            if (map != null) {
                VDS vdsToFenceObject = DbFacade.getInstance().getVdsDao().get(map.getId());
                if (vdsToFenceObject != null) {
                    log.infoFormat("SPM selection - vds seems as spm {0}", vdsToFenceObject.getvds_name());
                    if (vdsToFenceObject.getstatus() == VDSStatus.NonResponsive) {
                        log.warn("spm vds is non responsive, stopping spm selection.");
                        selectedVds.argvalue = null;
                        return spmStatus;
                    } else {
                        // try to stop spm
                        VDSReturnValue spmStopReturnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsToFenceObject.getId(), _storagePoolId));
                        // continue with spm selection
                        if (spmStopReturnValue != null && spmStopReturnValue.getSucceeded()) {
                            log.info("spm stop succeeded, continuing with spm selection");
                        } else // if spm stop failed for any reason we stop spm
                        // selection
                        {
                            log.warn("spm stop on spm failed, stopping spm selection!");
                            selectedVds.argvalue = null;
                            return spmStatus;
                        }
                    }
                }
            }
            storagePool.setstatus(StoragePoolStatus.Contend);
            storagePool.setspm_vds_id(selectedVds.argvalue.getId());
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    DbFacade.getInstance().getStoragePoolDao().update(storagePool);
                    return null;
                }
            });
            log.infoFormat("starting spm on vds {0}, storage pool {1}, prevId {2}, LVER {3}", selectedVds.argvalue.getvds_name(), storagePool.getname(), spmStatus.getSpmId(), spmStatus.getSpmLVER());
            spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.argvalue.getId(), _storagePoolId, spmStatus.getSpmId(), spmStatus.getSpmLVER(), storagePool.getrecovery_mode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
            if (spmStatus != null && spmStatus.getSpmStatus() == SpmStatus.SPM) {
                _isSpmStartCalled = true;
            } else {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
                if (spmStatus != null) {
                    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            storage_pool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePool.getId());
                            pool.setspm_vds_id(null);
                            DbFacade.getInstance().getStoragePoolDao().update(pool);
                            return null;
                        }
                    });
                }
                throw new IrsSpmStartFailedException();
            }
        }
    }
    return spmStatus;
}
#end_block

#method_before
public void ResetIrs() {
    setmCurrentIrsHost(null);
    setmIrsProxy(null);
    mCurrentVdsId = null;
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDAO().get(_storagePoolId);
    if (storagePool != null) {
        storagePool.setspm_vds_id(null);
        DbFacade.getInstance().getStoragePoolDAO().update(storagePool);
    }
}
#method_after
public void ResetIrs() {
    setmCurrentIrsHost(null);
    setmIrsProxy(null);
    mCurrentVdsId = null;
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null) {
        storagePool.setspm_vds_id(null);
        DbFacade.getInstance().getStoragePoolDao().update(storagePool);
    }
}
#end_block

#method_before
public void UpdateVdsDomainsData(final Guid vdsId, final String vdsName, final java.util.ArrayList<VDSDomainsData> data) {
    Set<Guid> domainsInProblems = (Set<Guid>) TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Set<Guid>>() {

        @Override
        public Set<Guid> runInTransaction() {
            Set<Guid> domainsInProblems = null;
            storage_pool storagePool = DbFacade.getInstance().getStoragePoolDAO().get(_storagePoolId);
            if (storagePool != null && (storagePool.getstatus() == StoragePoolStatus.Up || storagePool.getstatus() == StoragePoolStatus.Problematic)) {
                try {
                    // build a list of all domains in pool
                    // which are in status Active or Unknown
                    Set<Guid> domainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDAO().getAllIds(_storagePoolId, StorageDomainStatus.Active));
                    domainsInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDAO().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
                    // build a list of all the domains in
                    // pool (domainsInPool) that are not
                    // visible by the host.
                    List<Guid> domainsInPoolThatNonVisibleByVds = new ArrayList<Guid>();
                    Set<Guid> dataDomainIds = new HashSet<Guid>();
                    for (VDSDomainsData tempData : data) {
                        dataDomainIds.add(tempData.getDomainId());
                    }
                    for (Guid tempDomainId : domainsInPool) {
                        if (!dataDomainIds.contains(tempDomainId)) {
                            domainsInPoolThatNonVisibleByVds.add(tempDomainId);
                        }
                    }
                    // build a list of domains that the host
                    // reports as in problem (code!=0) or (code==0
                    // && lastChecl >
                    // ConfigValues.MaxStorageVdsTimeoutCheckSec)
                    // and are contained in the Active or
                    // Unknown domains in pool
                    List<Guid> domainsSeenByVdsInProblem = new ArrayList<Guid>();
                    for (VDSDomainsData tempData : data) {
                        if (domainsInPool.contains(tempData.getDomainId())) {
                            if (tempData.getCode() != 0) {
                                domainsSeenByVdsInProblem.add(tempData.getDomainId());
                            } else if (tempData.getLastCheck() > Config.<Double>GetValue(ConfigValues.MaxStorageVdsTimeoutCheckSec)) {
                                domainsSeenByVdsInProblem.add(tempData.getDomainId());
                            } else if (tempData.getDelay() > Config.<Double>GetValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                                AuditLogableBase logable = new AuditLogableBase();
                                logable.setVdsId(vdsId);
                                logable.setStorageDomainId(tempData.getDomainId());
                                logable.AddCustomValue("Delay", Double.toString(tempData.getDelay()));
                                AuditLogDirector.log(logable, AuditLogType.VDS_DOMAIN_DELAY_INTERVAL);
                            }
                        }
                    }
                    // build a list of all potential domains
                    // in problem
                    domainsInProblems = new HashSet<Guid>();
                    domainsInProblems.addAll(domainsInPoolThatNonVisibleByVds);
                    domainsInProblems.addAll(domainsSeenByVdsInProblem);
                } catch (RuntimeException ex) {
                    log.error("error in UpdateVdsDomainsData", ex);
                }
            }
            return domainsInProblems;
        }
    });
    if (domainsInProblems != null) {
        synchronized (_lockObject) {
            // domains status
            if (duringReconstructMaster.get()) {
                log.debug("The pool is during reconstruct master, skipping handling problematic domains " + _storagePoolId);
                return;
            }
            updateProblematicVdsData(vdsId, vdsName, domainsInProblems);
        }
    }
}
#method_after
public void UpdateVdsDomainsData(final Guid vdsId, final String vdsName, final ArrayList<VDSDomainsData> data) {
    Set<Guid> domainsInProblems = null;
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null && (storagePool.getstatus() == StoragePoolStatus.Up || storagePool.getstatus() == StoragePoolStatus.Problematic)) {
        try {
            // build a list of all domains in pool
            // which are in status Active or Unknown
            Set<Guid> domainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Active));
            domainsInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
            Set<Guid> inActiveDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.InActive));
            // build a list of all the domains in
            // pool (domainsInPool) that are not
            // visible by the host.
            List<Guid> domainsInPoolThatNonVisibleByVds = new ArrayList<Guid>();
            Set<Guid> dataDomainIds = new HashSet<Guid>();
            for (VDSDomainsData tempData : data) {
                dataDomainIds.add(tempData.getDomainId());
            }
            for (Guid tempDomainId : domainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsInPoolThatNonVisibleByVds.add(tempDomainId);
                }
            }
            // build a list of domains that the host
            // reports as in problem (code!=0) or (code==0
            // && lastChecl >
            // ConfigValues.MaxStorageVdsTimeoutCheckSec)
            // and are contained in the Active or
            // Unknown domains in pool
            List<Guid> domainsSeenByVdsInProblem = new ArrayList<Guid>();
            for (VDSDomainsData tempData : data) {
                if (domainsInPool.contains(tempData.getDomainId())) {
                    if (isDomainReportedAsProblematic(tempData, false)) {
                        domainsSeenByVdsInProblem.add(tempData.getDomainId());
                    } else if (tempData.getDelay() > Config.<Double>GetValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                        logDelayedDomain(vdsId, tempData);
                    }
                } else if (inActiveDomainsInPool.contains(tempData.getDomainId()) && !isDomainReportedAsProblematic(tempData, false)) {
                    log.warnFormat("Storage Domain {0} was reported by Host {1} as Active in Pool {2}, moving to active status", getDomainIdTuple(tempData.getDomainId()), vdsName, _storagePoolId);
                    storage_pool_iso_map map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(tempData.getDomainId(), _storagePoolId));
                    map.setstatus(StorageDomainStatus.Active);
                    DbFacade.getInstance().getStoragePoolIsoMapDao().update(map);
                }
            }
            // build a list of all potential domains
            // in problem
            domainsInProblems = new HashSet<Guid>();
            domainsInProblems.addAll(domainsInPoolThatNonVisibleByVds);
            domainsInProblems.addAll(domainsSeenByVdsInProblem);
        } catch (RuntimeException ex) {
            log.error("error in UpdateVdsDomainsData", ex);
        }
    }
    if (domainsInProblems != null) {
        synchronized (_lockObject) {
            // domains status
            if (duringReconstructMaster.get()) {
                log.debug("The pool is during reconstruct master, skipping handling problematic domains " + _storagePoolId);
                return;
            }
            updateProblematicVdsData(vdsId, vdsName, domainsInProblems);
        }
    }
}
#end_block

#method_before
private void ProcessDomainRecovery(final Guid domainId) {
    TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            // build a list of all the hosts in status UP in
            // Pool.
            List<Guid> vdssInPool = new ArrayList<Guid>();
            List<VDS> allVds = DbFacade.getInstance().getVdsDAO().getAll();
            for (VDS tempVDS : allVds) {
                if (tempVDS.getstatus() == VDSStatus.Up && tempVDS.getstorage_pool_id().equals(_storagePoolId)) {
                    vdssInPool.add(tempVDS.getId());
                }
            }
            // build a list of all the hosts that did not report
            // on this domain as in problem.
            // Mark the above list as hosts we suspect are in
            // problem.
            java.util.Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
            List<Guid> vdssInProblem = new ArrayList<Guid>();
            for (Guid tempVDSId : vdssInPool) {
                if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
                    vdssInProblem.add(tempVDSId);
                }
            }
            // If not All the hosts in status UP reported on
            // this domain as in problem. We assume the problem
            // is with the hosts
            // that did report on a problem with this domain.
            // (and not a problem with the domain itself).
            storage_domain_static storageDomain = DbFacade.getInstance().getStorageDomainStaticDAO().get(domainId);
            String domainIdTuple = getDomainIdTuple(domainId);
            if (vdssInProblem.size() > 0) {
                if (storageDomain.getstorage_domain_type() != StorageDomainType.ImportExport && storageDomain.getstorage_domain_type() != StorageDomainType.ISO) {
                    // operational.
                    for (Guid vdsId : _domainsInProblem.get(domainId)) {
                        VDS vds = DbFacade.getInstance().getVdsDAO().get(vdsId);
                        if (vds == null) {
                            log.warnFormat("vds {0} reported domain {1} - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                        } else if (vds.getstatus() != VDSStatus.Maintenance && vds.getstatus() != VDSStatus.NonOperational) {
                            log.warnFormat("vds {0} reported domain {1} as in problem, moving the vds to status NonOperational", vds.getvds_name(), domainIdTuple);
                            ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, true, domainId);
                            clearVdsFromCache(vdsId, vds.getvds_name());
                        } else {
                            log.warnFormat("vds {0} reported domain {1} as in problem, vds is in status {2}, no need to move to nonoperational", vds.getvds_name(), domainIdTuple, vds.getstatus());
                        }
                    }
                } else {
                    log.warnFormat("Storage domain {0} is not visible to one or more hosts. " + "Since the domain's type is {1}, hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getstorage_domain_type());
                }
            } else {
                // Domain.
                if (storageDomain.getstorage_domain_type() != StorageDomainType.Master) {
                    log.warnFormat("domain {0} was reported by all hosts in status UP as problematic. Moving the Domain to NonOperational.", domainIdTuple);
                    ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
                } else if (duringReconstructMaster.compareAndSet(false, true)) {
                    try {
                        ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
                    } finally {
                        duringReconstructMaster.set(false);
                    }
                } else {
                    log.warnFormat("domain {0} was reported by all hosts in status UP as problematic. But not moving the Domain to NonOperational. Because of is reconstract now", domainIdTuple);
                    return null;
                }
            }
            // clear from cache of _vdssInProblem and
            // _domainsInProblem
            clearDomainFromCache(domainId);
            ClearTimer(domainId);
            return null;
        }
    });
}
#method_after
private void ProcessDomainRecovery(final Guid domainId) {
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePool(_storagePoolId);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getstatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    storage_domain_static storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getstorage_domain_type() != StorageDomainType.ImportExport && storageDomain.getstorage_domain_type() != StorageDomainType.ISO) {
            // operational.
            for (Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warnFormat("vds {0} reported domain {1} - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getstatus() != VDSStatus.Maintenance && vds.getstatus() != VDSStatus.NonOperational) {
                    log.warnFormat("vds {0} reported domain {1} as in problem, moving the vds to status NonOperational", vds.getvds_name(), domainIdTuple);
                    ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, true, domainId);
                    clearVdsFromCache(vdsId, vds.getvds_name());
                } else {
                    log.warnFormat("vds {0} reported domain {1} as in problem, vds is in status {3}, no need to move to nonoperational", vds.getvds_name(), domainIdTuple, vds.getstatus());
                }
            }
        } else {
            log.warnFormat("Storage domain {0} is not visible to one or more hosts. " + "Since the domain's type is {1}, hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getstorage_domain_type());
        }
    } else {
        // Domain.
        if (storageDomain.getstorage_domain_type() != StorageDomainType.Master) {
            log.warnFormat("domain {0} was reported by all hosts in status UP as problematic. Moving the Domain to NonOperational.", domainIdTuple);
            ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else if (duringReconstructMaster.compareAndSet(false, true)) {
            try {
                ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId);
            } finally {
                duringReconstructMaster.set(false);
            }
        } else {
            log.warnFormat("domain {0} was reported by all hosts in status UP as problematic. But not moving the Domain to NonOperational. Because of is reconstract now", domainIdTuple);
            return;
        }
    }
    // clear from cache of _vdssInProblem and
    // _domainsInProblem
    clearDomainFromCache(domainId);
    ClearTimer(domainId);
}
#end_block

#method_before
private String getDomainIdTuple(Guid domainId) {
    storage_domain_static storage_domain = DbFacade.getInstance().getStorageDomainStaticDAO().get(domainId);
    if (storage_domain != null) {
        return domainId + ":" + storage_domain.getstorage_name();
    } else {
        return domainId.toString();
    }
}
#method_after
private static String getDomainIdTuple(Guid domainId) {
    storage_domain_static storage_domain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    if (storage_domain != null) {
        return domainId + ":" + storage_domain.getstorage_name();
    } else {
        return domainId.toString();
    }
}
#end_block

#method_before
private void startReconstruct() {
    storage_domain_static masterDomain = null;
    List<storage_domain_static> storageDomainStaticList = DbFacade.getInstance().getStorageDomainStaticDAO().getAllForStoragePool(getParameters().getStoragePoolId());
    for (storage_domain_static storageDomainStatic : storageDomainStaticList) {
        if (storageDomainStatic.getstorage_domain_type() == StorageDomainType.Master) {
            masterDomain = storageDomainStatic;
            break;
        }
    }
    if (masterDomain != null) {
        if (getCurrentIrsProxyData().duringReconstructMaster.compareAndSet(false, true)) {
            try {
                ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomain.getId(), getParameters().getStoragePoolId());
            } finally {
                getCurrentIrsProxyData().duringReconstructMaster.set(false);
            }
        } else {
            log.debug("The pool is during reconstruct master, skipping handling problematic domains " + getParameters().getStoragePoolId());
        }
    } else {
        log.errorFormat("IrsBroker::IRSNoMasterDomainException:: Could not find master domain for pool {0} !!!", getParameters().getStoragePoolId());
    }
}
#method_after
private void startReconstruct() {
    storage_domain_static masterDomain = null;
    List<storage_domain_static> storageDomainStaticList = DbFacade.getInstance().getStorageDomainStaticDao().getAllForStoragePool(getParameters().getStoragePoolId());
    for (storage_domain_static storageDomainStatic : storageDomainStaticList) {
        if (storageDomainStatic.getstorage_domain_type() == StorageDomainType.Master) {
            masterDomain = storageDomainStatic;
            break;
        }
    }
    if (masterDomain != null) {
        if (getCurrentIrsProxyData().duringReconstructMaster.compareAndSet(false, true)) {
            try {
                ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomain.getId(), getParameters().getStoragePoolId());
            } finally {
                getCurrentIrsProxyData().duringReconstructMaster.set(false);
            }
        } else {
            log.debug("The pool is during reconstruct master, skipping handling problematic domains " + getParameters().getStoragePoolId());
        }
    } else {
        log.errorFormat("IrsBroker::IRSNoMasterDomainException:: Could not find master domain for pool {0} !!!", getParameters().getStoragePoolId());
    }
}
#end_block

#method_before
private static void SetVmTemplateStatus(Guid vmTemplateGuid, VmTemplateStatus status, CompensationContext compensationContext) {
    VmTemplate vmTemplate = DbFacade.getInstance().getVmTemplateDAO().get(vmTemplateGuid);
    if (vmTemplate != null) {
        if (compensationContext != null) {
            compensationContext.snapshotEntityStatus(vmTemplate, vmTemplate.getstatus());
        }
        vmTemplate.setstatus(status);
        DbFacade.getInstance().getVmTemplateDAO().update(vmTemplate);
    } else {
        log.warnFormat("VmTemplateHandler::SetVmTemplateStatus: vmTemplate is null, not setting status '{0}' to vmTemplate", status);
    }
}
#method_after
private static void SetVmTemplateStatus(Guid vmTemplateGuid, VmTemplateStatus status, CompensationContext compensationContext) {
    VmTemplate vmTemplate = DbFacade.getInstance().getVmTemplateDao().get(vmTemplateGuid);
    if (vmTemplate != null) {
        if (compensationContext != null) {
            compensationContext.snapshotEntityStatus(vmTemplate, vmTemplate.getstatus());
        }
        vmTemplate.setstatus(status);
        DbFacade.getInstance().getVmTemplateDao().update(vmTemplate);
    } else {
        log.warnFormat("VmTemplateHandler::SetVmTemplateStatus: vmTemplate is null, not setting status '{0}' to vmTemplate", status);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVmTemplate() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    } else if (getTemplateDisks() != null && !getTemplateDisks().isEmpty()) {
        ensureDomainMap(getTemplateDisks(), getParameters().getStorageDomainId());
        // check that images are ok
        ImagesHandler.fillImagesMapBasedOnTemplate(getVmTemplate(), imageFromSourceDomainMap, null, true);
        if (getVmTemplate().getDiskMap().values().size() != imageFromSourceDomainMap.size()) {
            log.errorFormat("Can not found any default active domain for one of the disks of template with id : {0}", getVmTemplate().getId());
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
            retValue = false;
        }
        retValue = retValue && VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), null, getReturnValue().getCanDoActionMessages(), true, true, true, false, getTemplateDisks());
        if (retValue) {
            setStoragePoolId(getVmTemplate().getstorage_pool_id());
            retValue = CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && checkIfDisksExist(getTemplateDisks()) && checkFreeSpaceOnDestinationDomain(getStorageDomain(), (int) getVmTemplate().getActualDiskSize());
        }
        if (retValue && DbFacade.getInstance().getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVmTemplate().getstorage_pool_id().getValue())) == null) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        }
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVmTemplate() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    } else if (getTemplateDisks() != null && !getTemplateDisks().isEmpty()) {
        ensureDomainMap(getTemplateDisks(), getParameters().getStorageDomainId());
        // check that images are ok
        ImagesHandler.fillImagesMapBasedOnTemplate(getVmTemplate(), imageFromSourceDomainMap, null, true);
        if (getVmTemplate().getDiskMap().values().size() != imageFromSourceDomainMap.size()) {
            log.errorFormat("Can not found any default active domain for one of the disks of template with id : {0}", getVmTemplate().getId());
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
            retValue = false;
        }
        retValue = retValue && VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), null, getReturnValue().getCanDoActionMessages(), true, true, true, false, getTemplateDisks());
        if (retValue) {
            setStoragePoolId(getVmTemplate().getstorage_pool_id());
            retValue = CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && checkIfDisksExist(getTemplateDisks()) && checkFreeSpaceOnDestinationDomain(getStorageDomain(), (int) getVmTemplate().getActualDiskSize());
        }
        if (retValue && DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVmTemplate().getstorage_pool_id().getValue())) == null) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    if (!getTemplateDisks().isEmpty()) {
        MoveOrCopyAllImageGroups();
    } else {
        endVmTemplateRelatedOps();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    freeLock();
    if (!getTemplateDisks().isEmpty()) {
        moveOrCopyAllImageGroups();
    } else {
        endVmTemplateRelatedOps();
    }
    setSucceeded(true);
}
#end_block

#method_before
private void endVmTemplateRelatedOps() {
    if (getVmTemplate() != null) {
        VmTemplateHandler.UnLockVmTemplate(getVmTemplateId());
        VmDeviceUtils.setVmDevices(getVmTemplate());
        UpdateTemplateInSpm();
    } else {
        setCommandShouldBeLogged(false);
        log.warn("MoveOrCopyTemplateCommand::EndMoveOrCopyCommand: VmTemplate is null, not performing full EndAction");
    }
}
#method_after
private void endVmTemplateRelatedOps() {
    if (getVmTemplate() != null) {
        VmTemplateHandler.UnLockVmTemplate(getVmTemplateId());
        VmDeviceUtils.setVmDevices(getVmTemplate());
        updateTemplateInSpm();
    } else {
        setCommandShouldBeLogged(false);
        log.warn("MoveOrCopyTemplateCommand::EndMoveOrCopyCommand: VmTemplate is null, not performing full EndAction");
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVmTemplate() != null) {
        setDescription(getVmTemplateName());
    }
    if (!VmTemplateHandler.verifyVmTemplateStatusForUse(getVmTemplateId(), false)) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED.toString());
    }
    StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomain());
    boolean retVal = storageDomainValidator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages());
    if (retVal) {
        // export must be to export domain
        if (getStorageDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN);
            retVal = false;
        }
    }
    retVal = retVal && super.canDoAction();
    // check if template (with no override option)
    if (retVal && !getParameters().getForceOverride()) {
        retVal = !ExportVmCommand.CheckTemplateInStorageDomain(getVmTemplate().getstorage_pool_id().getValue(), getParameters().getStorageDomainId(), getVmTemplateId());
        if (!retVal) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NAME_ALREADY_EXISTS);
        }
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVmTemplate() != null) {
        setDescription(getVmTemplateName());
    }
    StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomain());
    boolean retVal = storageDomainValidator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages());
    if (retVal) {
        // export must be to export domain
        if (getStorageDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN);
            retVal = false;
        }
    }
    retVal = retVal && super.canDoAction();
    // check if template (with no override option)
    if (retVal && !getParameters().getForceOverride()) {
        retVal = !ExportVmCommand.CheckTemplateInStorageDomain(getVmTemplate().getstorage_pool_id().getValue(), getParameters().getStorageDomainId(), getVmTemplateId());
        if (!retVal) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NAME_ALREADY_EXISTS);
        }
    }
    return retVal;
}
#end_block

#method_before
@Override
protected Map<String, String> getExclusiveLocks() {
    Map<String, String> locks = new HashMap<String, String>();
    locks.putAll(super.getExclusiveLocks());
    locks.put(getVmTemplateId().toString(), LockingGroup.TEMPLATE.name());
    return locks;
}
#method_after
@Override
protected Map<String, String> getExclusiveLocks() {
    Map<String, String> locks = new HashMap<String, String>();
    Map<String, String> parentLocks = super.getExclusiveLocks();
    if (parentLocks != null) {
        locks.putAll(parentLocks);
    }
    locks.put(getVmTemplateId().toString(), LockingGroup.TEMPLATE.name());
    return locks;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Guid vmTemplateId = getVmTemplateId();
    VmTemplate template = getVmTemplate();
    // add command specific can do action variables
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
    // check template exists
    if (template == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    // check not blank template
    if (VmTemplateHandler.BlankVmTemplateId.equals(vmTemplateId)) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_BLANK_TEMPLATE);
        return false;
    }
    if (!VmTemplateHandler.verifyVmTemplateStatusForUse(getVmTemplateId(), false)) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED.toString());
    }
    // check storage pool valid
    if (template.getstorage_pool_id() != null && !Guid.Empty.equals(template.getstorage_pool_id()) && !((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(template.getstorage_pool_id().getValue())).getReturnValue()).booleanValue()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
        return false;
    }
    imageTemplates = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(getVmTemplateId()), false, false);
    List<Guid> storageDomainsList = getParameters().getStorageDomainsList();
    Set<Guid> allDomainsList = getStorageDoaminsByDisks(imageTemplates, true);
    // if null or empty list sent, get all template domains for deletion
    if (storageDomainsList == null || storageDomainsList.isEmpty()) {
        // populate all the domains of the template
        getParameters().setStorageDomainsList(new ArrayList<Guid>(allDomainsList));
        getParameters().setRemoveTemplateFromDb(true);
    } else {
        // if some domains sent, check that the sent domains are part of all domains
        List<String> problematicDomains = new ArrayList<String>();
        for (Guid domainId : storageDomainsList) {
            if (!allDomainsList.contains(domainId)) {
                storage_domain_static domain = DbFacade.getInstance().getStorageDomainStaticDAO().get(domainId);
                if (domain == null) {
                    problematicDomains.add(domainId.toString());
                } else {
                    problematicDomains.add(domain.getstorage_name());
                }
            }
        }
        if (!problematicDomains.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DOMAINS_LIST_MISMATCH);
            addCanDoActionMessage(String.format("$domainsList %1$s", StringUtils.join(problematicDomains, ",")));
            return false;
        }
        getParameters().setRemoveTemplateFromDb(allDomainsList.size() == storageDomainsList.size());
    }
    // check template images for selected domains
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    for (Guid domainId : getParameters().getStorageDomainsList()) {
        if (!isVmTemplateImagesReady(getVmTemplate(), domainId, canDoActionMessages, getParameters().getCheckDisksExists(), true, false, true, storageToDisksMap.get(domainId))) {
            return false;
        }
    }
    // check no vms from this template on selected domains
    List<VM> vms = DbFacade.getInstance().getVmDAO().getAllWithTemplate(vmTemplateId);
    List<String> problematicVmNames = new ArrayList<String>();
    for (VM vm : vms) {
        if (getParameters().isRemoveTemplateFromDb()) {
            problematicVmNames.add(vm.getvm_name());
        } else {
            List<DiskImage> vmDIsks = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId()), false, false);
            Set<Guid> domainsIds = getStorageDoaminsByDisks(vmDIsks, false);
            for (Guid domainId : domainsIds) {
                if (!getParameters().getStorageDomainsList().contains(domainId)) {
                    problematicVmNames.add(vm.getvm_name());
                }
            }
        }
    }
    if (!problematicVmNames.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM);
        addCanDoActionMessage(String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    Guid vmTemplateId = getVmTemplateId();
    VmTemplate template = getVmTemplate();
    // check template exists
    if (template == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    // check not blank template
    if (VmTemplateHandler.BlankVmTemplateId.equals(vmTemplateId)) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_BLANK_TEMPLATE);
        return false;
    }
    // check storage pool valid
    if (template.getstorage_pool_id() != null && !Guid.Empty.equals(template.getstorage_pool_id()) && !((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(template.getstorage_pool_id().getValue())).getReturnValue()).booleanValue()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
        return false;
    }
    imageTemplates = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(getVmTemplateId()), false, false);
    List<Guid> storageDomainsList = getParameters().getStorageDomainsList();
    Set<Guid> allDomainsList = getStorageDoaminsByDisks(imageTemplates, true);
    // if null or empty list sent, get all template domains for deletion
    if (storageDomainsList == null || storageDomainsList.isEmpty()) {
        // populate all the domains of the template
        getParameters().setStorageDomainsList(new ArrayList<Guid>(allDomainsList));
        getParameters().setRemoveTemplateFromDb(true);
    } else {
        // if some domains sent, check that the sent domains are part of all domains
        List<String> problematicDomains = new ArrayList<String>();
        for (Guid domainId : storageDomainsList) {
            if (!allDomainsList.contains(domainId)) {
                storage_domain_static domain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
                if (domain == null) {
                    problematicDomains.add(domainId.toString());
                } else {
                    problematicDomains.add(domain.getstorage_name());
                }
            }
        }
        if (!problematicDomains.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DOMAINS_LIST_MISMATCH);
            addCanDoActionMessage(String.format("$domainsList %1$s", StringUtils.join(problematicDomains, ",")));
            return false;
        }
        getParameters().setRemoveTemplateFromDb(allDomainsList.size() == storageDomainsList.size());
    }
    // check template images for selected domains
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    for (Guid domainId : getParameters().getStorageDomainsList()) {
        if (!isVmTemplateImagesReady(getVmTemplate(), domainId, canDoActionMessages, getParameters().getCheckDisksExists(), true, false, true, storageToDisksMap.get(domainId))) {
            return false;
        }
    }
    // check no vms from this template on selected domains
    List<VM> vms = DbFacade.getInstance().getVmDao().getAllWithTemplate(vmTemplateId);
    List<String> problematicVmNames = new ArrayList<String>();
    for (VM vm : vms) {
        if (getParameters().isRemoveTemplateFromDb()) {
            problematicVmNames.add(vm.getvm_name());
        } else {
            List<DiskImage> vmDIsks = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId()), false, false);
            Set<Guid> domainsIds = getStorageDoaminsByDisks(vmDIsks, false);
            for (Guid domainId : domainsIds) {
                if (!getParameters().getStorageDomainsList().contains(domainId)) {
                    problematicVmNames.add(vm.getvm_name());
                }
            }
        }
    }
    if (!problematicVmNames.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM);
        addCanDoActionMessage(String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    // if for some reason template doesn't have images, remove it now and not in end action
    final boolean hasImages = imageTemplates.size() > 0;
    if (RemoveTemplateInSpm(getVmTemplate().getstorage_pool_id().getValue(), getVmTemplateId())) {
        if (hasImages) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    if (RemoveVmTemplateImages()) {
                        setSucceeded(true);
                    }
                    return null;
                }
            });
        } else {
            HandleEndAction();
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    freeLock();
    // if for some reason template doesn't have images, remove it now and not in end action
    final boolean hasImages = imageTemplates.size() > 0;
    if (RemoveTemplateInSpm(getVmTemplate().getstorage_pool_id().getValue(), getVmTemplateId())) {
        if (hasImages) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    if (RemoveVmTemplateImages()) {
                        setSucceeded(true);
                    }
                    return null;
                }
            });
        } else {
            HandleEndAction();
        }
    }
}
#end_block

#method_before
private void RemoveTemplateFromDb() {
    RemoveNetwork();
    DbFacade.getInstance().getVmTemplateDAO().remove(getVmTemplate().getId());
}
#method_after
private void RemoveTemplateFromDb() {
    RemoveNetwork();
    DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplate().getId());
}
#end_block

#method_before
protected boolean RemoveVmTemplateImages() {
    getParameters().setEntityId(getParameters().getEntityId());
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RemoveAllVmTemplateImageTemplates, getParameters(), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    if (!vdcReturnValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcReturnValue.getFault());
        return false;
    }
    getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
    return true;
}
#method_after
protected boolean RemoveVmTemplateImages() {
    getParameters().setEntityId(getParameters().getEntityId());
    getParameters().setParentCommand(getActionType());
    getParameters().setParentParameters(getParameters());
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RemoveAllVmTemplateImageTemplates, getParameters(), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    if (!vdcReturnValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcReturnValue.getFault());
        return false;
    }
    getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
    return true;
}
#end_block

#method_before
public static <T> ArrayList<T> Intersection(ArrayList<ArrayList<T>> lists) {
    ArrayList<T> result = new ArrayList<T>();
    if (lists != null) {
        for (ArrayList<T> list : lists) {
            result.retainAll(list);
        }
    }
    return result;
}
#method_after
public static <T> ArrayList<T> Intersection(ArrayList<ArrayList<T>> lists) {
    ArrayList<T> result = new ArrayList<T>();
    if (lists != null && !lists.isEmpty()) {
        result.addAll(lists.get(0));
        for (ArrayList<T> list : lists) {
            result.retainAll(list);
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void InitDetailModels() {
    super.InitDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new ClusterPolicyModel());
    list.add(new ClusterNetworkListModel());
    list.add(new ClusterHostListModel());
    list.add(new ClusterVmListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void InitDetailModels() {
    super.InitDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new ClusterGeneralModel());
    list.add(new ClusterNetworkListModel());
    list.add(new ClusterHostListModel());
    list.add(new ClusterVmListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#end_block

#method_before
private void OnSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setname((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setstorage_pool_id(((storage_pool) model.getDataCenter().getSelectedItem()).getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService((Boolean) model.getEnableOvirtService().getEntity());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    model.StartProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if ((Boolean) model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.PostOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void OnSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setname((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setstorage_pool_id(((storage_pool) model.getDataCenter().getSelectedItem()).getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService((Boolean) model.getEnableOvirtService().getEntity());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    model.StartProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if ((Boolean) model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().StartProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            getWindow().StopProgress();
            Map<String, String> hostMap = (Map<String, String>) result;
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (// $NON-NLS-1$
            hostMap.containsValue("")) {
                onGlusterHostsDown(clusterModel);
                return;
            }
            ArrayList<EntityModel> list = new ArrayList<EntityModel>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel entityModel = new EntityModel(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.GetGlusterHosts(aQuery, (String) clusterModel.getGlusterHostAddress().getEntity(), (String) clusterModel.getGlusterHostPassword().getEntity());
}
#method_after
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().StartProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            getWindow().StopProgress();
            Map<String, String> hostMap = (Map<String, String>) result;
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (// $NON-NLS-1$
            hostMap.containsValue(null) || hostMap.containsValue("")) {
                onGlusterHostsWithoutFingerprint(hostMap, clusterModel);
                return;
            }
            ArrayList<EntityModel> list = new ArrayList<EntityModel>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel entityModel = new EntityModel(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.GetGlusterHosts(aQuery, (String) clusterModel.getGlusterHostAddress().getEntity(), (String) clusterModel.getGlusterHostPassword().getEntity(), (String) clusterModel.getGlusterHostFingerprint().getEntity());
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewCommand()) {
        New();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternal")) {
        OnSaveInternal();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveHosts")) {
        OnSaveHosts();
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewCommand()) {
        New();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternal")) {
        OnSaveInternal();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveHosts")) {
        onSaveHosts();
    }
}
#end_block

#method_before
public static void GetRoleList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<roles>) source : new ArrayList<roles>();
        }
    };
    Frontend.RunQuery(VdcQueryType.GetAllRoles, new MultilevelAdministrationsQueriesParameters(), aQuery);
}
#method_after
public static void GetRoleList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Role>) source : new ArrayList<Role>();
        }
    };
    Frontend.RunQuery(VdcQueryType.GetAllRoles, new MultilevelAdministrationsQueriesParameters(), aQuery);
}
#end_block

#method_before
public static void GetGlusterHosts(AsyncQuery aQuery, String hostAddress, String rootPassword) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.RunQuery(VdcQueryType.GetGlusterServers, new GlusterServersQueryParameters(hostAddress, rootPassword), aQuery);
}
#method_after
public static void GetGlusterHosts(AsyncQuery aQuery, String hostAddress, String rootPassword, String fingerprint) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    GlusterServersQueryParameters parameters = new GlusterServersQueryParameters(hostAddress, rootPassword);
    parameters.setFingerprint(fingerprint);
    Frontend.RunQuery(VdcQueryType.GetGlusterServers, parameters, aQuery);
}
#end_block

#method_before
// Form Detail Models
@Provides
@Singleton
public DetailModelProvider<ClusterListModel, ClusterPolicyModel> getClusterPolicyProvider(ClientGinjector ginjector, final Provider<ClusterPolicyPopupPresenterWidget> popupProvider) {
    return new DetailTabModelProvider<ClusterListModel, ClusterPolicyModel>(ginjector, ClusterListModel.class, ClusterPolicyModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterPolicyModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
}
#method_after
// Form Detail Models
@Provides
@Singleton
public DetailModelProvider<ClusterListModel, ClusterGeneralModel> getClusterPolicyProvider(ClientGinjector ginjector, final Provider<ClusterPolicyPopupPresenterWidget> popupProvider) {
    return new DetailTabModelProvider<ClusterListModel, ClusterGeneralModel>(ginjector, ClusterListModel.class, ClusterGeneralModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterGeneralModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getEditPolicyCommand()) {
                return popupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
}
#end_block

#method_before
@Override
protected void executeCommand() {
    super.executeCommand();
    Guid storagePoolId = getDiskImage().getstorage_pool_id() != null ? getDiskImage().getstorage_pool_id().getValue() : Guid.Empty;
    Guid imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
    Guid snapshotId = getDiskImage().getImageId();
    // Create new image group id and image id:
    Guid destinationImageGroupID = Guid.NewGuid();
    setDestinationImageId(Guid.NewGuid());
    getDiskImage().getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(getDiskImage().getImageId(), getDiskImage().getit_guid()));
    setDiskImage(getDiskImage().getSnapshots().get(getDiskImage().getSnapshots().size() - 1));
    DiskImage newImage = cloneDiskImage(getDestinationImageId());
    fillVolumeInformation(newImage);
    VDSReturnValue vdsReturnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(storagePoolId, getParameters().getStorageDomainId(), getParameters().getVmId(), imageGroupId, snapshotId, destinationImageGroupID, getDestinationImageId(), StringUtils.defaultString(newImage.getdescription()), getParameters().getDestinationStorageDomainId(), CopyVolumeType.SharedVol, newImage.getvolume_format(), newImage.getvolume_type(), getDiskImage().isWipeAfterDelete(), false, getStoragePool().getcompatibility_version().toString()));
    getReturnValue().getInternalTaskIdList().add(CreateTask(vdsReturnValue.getCreationInfo(), VdcActionType.AddVmTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationStorageDomainId()));
    newImage.setId(destinationImageGroupID);
    newImage.setvm_snapshot_id(getParameters().getVmSnapshotId());
    newImage.setQuotaId(getParameters().getQuotaId());
    newImage.setParentId(ImagesHandler.BlankImageTemplateId);
    newImage.setit_guid(ImagesHandler.BlankImageTemplateId);
    newImage.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getDestinationStorageDomainId())));
    newImage.setactive(true);
    saveImage(newImage);
    newImage.setDiskAlias(getDiskImage().getDiskAlias());
    getBaseDiskDao().save(newImage);
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(newImage.getImageId());
    diskDynamic.setactual_size(getDiskImage().getactual_size());
    DbFacade.getInstance().getDiskImageDynamicDAO().save(diskDynamic);
    setActionReturnValue(newImage);
    // set source image as locked:
    lockImage();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    super.executeCommand();
    Guid storagePoolId = getDiskImage().getstorage_pool_id() != null ? getDiskImage().getstorage_pool_id().getValue() : Guid.Empty;
    Guid imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
    Guid snapshotId = getDiskImage().getImageId();
    // Create new image group id and image id:
    Guid destinationImageGroupID = Guid.NewGuid();
    setDestinationImageId(Guid.NewGuid());
    getDiskImage().getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(getDiskImage().getImageId(), getDiskImage().getit_guid()));
    setDiskImage(getDiskImage().getSnapshots().get(getDiskImage().getSnapshots().size() - 1));
    DiskImage newImage = cloneDiskImage(getDestinationImageId());
    fillVolumeInformation(newImage);
    VDSReturnValue vdsReturnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(storagePoolId, getParameters().getStorageDomainId(), getParameters().getVmId(), imageGroupId, snapshotId, destinationImageGroupID, getDestinationImageId(), StringUtils.defaultString(newImage.getdescription()), getParameters().getDestinationStorageDomainId(), CopyVolumeType.SharedVol, newImage.getvolume_format(), newImage.getvolume_type(), getDiskImage().isWipeAfterDelete(), false, getStoragePool().getcompatibility_version().toString()));
    getReturnValue().getInternalTaskIdList().add(createTask(vdsReturnValue.getCreationInfo(), VdcActionType.AddVmTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationStorageDomainId()));
    newImage.setId(destinationImageGroupID);
    newImage.setvm_snapshot_id(getParameters().getVmSnapshotId());
    newImage.setQuotaId(getParameters().getQuotaId());
    newImage.setParentId(ImagesHandler.BlankImageTemplateId);
    newImage.setit_guid(ImagesHandler.BlankImageTemplateId);
    newImage.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getDestinationStorageDomainId())));
    newImage.setactive(true);
    saveImage(newImage);
    newImage.setDiskAlias(getDiskImage().getDiskAlias());
    getBaseDiskDao().save(newImage);
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(newImage.getImageId());
    diskDynamic.setactual_size(getDiskImage().getactual_size());
    DbFacade.getInstance().getDiskImageDynamicDAO().save(diskDynamic);
    setActionReturnValue(newImage);
    // set source image as locked:
    lockImage();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getDiskImage() != null) {
        VDSReturnValue vdsReturnValue = performImageVdsmOperation();
        getReturnValue().getInternalTaskIdList().add(CreateTask(vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
        if (getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveDisk) {
            removeImageFromDB(false);
        }
    } else {
        log.warn("DiskImage is null, nothing to remove");
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (getDiskImage() != null) {
        VDSReturnValue vdsReturnValue = performImageVdsmOperation();
        getReturnValue().getInternalTaskIdList().add(createTask(vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
        if (getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveDisk) {
            removeImageFromDB(false);
        }
    } else {
        log.warn("DiskImage is null, nothing to remove");
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public void storageDomainNotOperational(Guid storageDomainId, Guid storagePoolId) {
    Backend.getInstance().runInternalAction(VdcActionType.HandleFailedStorageDomain, new StorageDomainPoolParametersBase(storageDomainId, storagePoolId), ExecutionHandler.createInternalJobContext());
}
#method_after
@Override
public void storageDomainNotOperational(Guid storageDomainId, Guid storagePoolId) {
    StorageDomainPoolParametersBase parameters = new StorageDomainPoolParametersBase(storageDomainId, storagePoolId);
    parameters.setIsInternal(true);
    parameters.setInactive(true);
    Backend.getInstance().runInternalAction(VdcActionType.DeactivateStorageDomain, parameters, ExecutionHandler.createInternalJobContext());
}
#end_block

#method_before
@Override
public void masterDomainNotOperational(Guid storageDomainId, Guid storagePoolId) {
    VdcActionParametersBase parameters = new ReconstructMasterParameters(storagePoolId, storageDomainId, false);
    parameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    Backend.getInstance().runInternalAction(VdcActionType.ReconstructMasterDomain, parameters, ExecutionHandler.createInternalJobContext());
}
#method_after
@Override
public void masterDomainNotOperational(Guid storageDomainId, Guid storagePoolId) {
    VdcActionParametersBase parameters = new ReconstructMasterParameters(storagePoolId, storageDomainId, true);
    Backend.getInstance().runInternalAction(VdcActionType.ReconstructMasterDomain, parameters, ExecutionHandler.createInternalJobContext());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getvm_name())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getvm_name(), vmFromParams.getvm_name())) {
        boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(vmFromParams.getvm_name())).getReturnValue();
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmHandler.handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (vmFromParams.getauto_startup() && vmFromParams.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(vmFromParams.getos(), vmFromParams.getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getvds_group_id().equals(vmFromParams.getvds_group_id())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getdefault_display_type(), vmFromParams.getnum_of_monitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // if number of monitors has increased, check PCI and IDE limits are ok
    if (vmFromDB.getnum_of_monitors() < vmFromParams.getnum_of_monitors()) {
        List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
        List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDAO().getAllForVm(getVmId());
        if (!checkPciAndIDeLimit(vmFromParams.getnum_of_monitors(), interfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (!VmTemplateCommand.IsVmPriorityValueLegal(vmFromParams.getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.getis_stateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.CheckCpuSockets(vmFromParams.getnum_of_sockets(), vmFromParams.getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getiso_path())) {
            return false;
        }
        // we save the content in base64 string
        getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getusb_policy(), vmFromParams.getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
        return false;
    }
    if (!isPinningAndMigrationValid(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_AND_MIGRATABLE);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getvm_name())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getvm_name(), vmFromParams.getvm_name())) {
        boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(vmFromParams.getvm_name())).getReturnValue();
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmHandler.handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (vmFromParams.getauto_startup() && vmFromParams.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(vmFromParams.getos(), vmFromParams.getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getvds_group_id().equals(vmFromParams.getvds_group_id())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getdefault_display_type(), vmFromParams.getnum_of_monitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // if number of monitors has increased, check PCI and IDE limits are ok
    if (vmFromDB.getnum_of_monitors() < vmFromParams.getnum_of_monitors()) {
        List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
        List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDAO().getAllForVm(getVmId());
        if (!checkPciAndIdeLimit(vmFromParams.getnum_of_monitors(), interfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (!VmTemplateCommand.IsVmPriorityValueLegal(vmFromParams.getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.getis_stateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.CheckCpuSockets(vmFromParams.getnum_of_sockets(), vmFromParams.getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getiso_path())) {
            return false;
        }
        // we save the content in base64 string
        getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getusb_policy(), vmFromParams.getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
        return false;
    }
    if (!isPinningAndMigrationValid(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_AND_MIGRATABLE);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.NewGuid());
    mNewCreatedDiskImage = cloneDiskImage(getDestinationImageId());
    mNewCreatedDiskImage.setimage_group_id(Guid.NewGuid());
    Guid storagePoolID = mNewCreatedDiskImage.getstorage_pool_id() != null ? mNewCreatedDiskImage.getstorage_pool_id().getValue() : Guid.Empty;
    VDSReturnValue vdsReturnValue = null;
    try {
        vdsReturnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(storagePoolID, getDiskImage().getstorage_ids().get(0), getVmTemplateId(), getDiskImage().getimage_group_id().getValue(), getImage().getImageId(), mNewCreatedDiskImage.getimage_group_id(), getDestinationImageId(), "", getDestinationStorageDomainId(), CopyVolumeType.LeafVol, mNewCreatedDiskImage.getvolume_format(), mNewCreatedDiskImage.getvolume_type(), getDiskImage().isWipeAfterDelete(), false, getStoragePool().getcompatibility_version().toString()));
        if (vdsReturnValue.getSucceeded()) {
            getReturnValue().getInternalTaskIdList().add(CreateTask(vdsReturnValue.getCreationInfo(), VdcActionType.AddVmFromTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getDestinationStorageDomainId()));
        }
    } catch (Exception e) {
        log.errorFormat("CreateCloneOfTemplateCommand::CreateSnapshotInIrsServer::Failed creating snapshot from image id -'{0}'", getImage().getImageId());
        throw new VdcBLLException(VdcBllErrors.VolumeCreationError);
    }
    return vdsReturnValue;
}
#method_after
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.NewGuid());
    mNewCreatedDiskImage = cloneDiskImage(getDestinationImageId());
    mNewCreatedDiskImage.setimage_group_id(Guid.NewGuid());
    Guid storagePoolID = mNewCreatedDiskImage.getstorage_pool_id() != null ? mNewCreatedDiskImage.getstorage_pool_id().getValue() : Guid.Empty;
    VDSReturnValue vdsReturnValue = null;
    try {
        vdsReturnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(storagePoolID, getDiskImage().getstorage_ids().get(0), getVmTemplateId(), getDiskImage().getimage_group_id().getValue(), getImage().getImageId(), mNewCreatedDiskImage.getimage_group_id(), getDestinationImageId(), "", getDestinationStorageDomainId(), CopyVolumeType.LeafVol, mNewCreatedDiskImage.getvolume_format(), mNewCreatedDiskImage.getvolume_type(), getDiskImage().isWipeAfterDelete(), false, getStoragePool().getcompatibility_version().toString()));
        if (vdsReturnValue.getSucceeded()) {
            getReturnValue().getInternalTaskIdList().add(createTask(vdsReturnValue.getCreationInfo(), VdcActionType.AddVmFromTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getDestinationStorageDomainId()));
        }
    } catch (Exception e) {
        log.errorFormat("CreateCloneOfTemplateCommand::CreateSnapshotInIrsServer::Failed creating snapshot from image id -'{0}'", getImage().getImageId());
        throw new VdcBLLException(VdcBllErrors.VolumeCreationError);
    }
    return vdsReturnValue;
}
#end_block

#method_before
protected boolean handleHibernatedVm(VdcActionType parentCommand, boolean startPollingTasks) {
    // this is temp code until it will be implemented in SPM
    String[] strings = getVm().gethibernation_vol_handle().split(",");
    List<Guid> guids = new LinkedList<Guid>();
    for (String string : strings) {
        guids.add(new Guid(string));
    }
    Guid[] imagesList = guids.toArray(new Guid[0]);
    if (imagesList.length == 6) {
        // get all vm disks in order to check post zero - if one of the
        // disks is marked with wipe_after_delete
        boolean postZero = LinqUtils.filter(getDiskDAO().getAllForVm(getVm().getId()), new Predicate<Disk>() {

            @Override
            public boolean eval(Disk disk) {
                return disk.isWipeAfterDelete();
            }
        }).size() > 0;
        // delete first image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue1 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[2], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue1.getSucceeded()) {
            return false;
        }
        Guid guid1 = CreateTask(vdsRetValue1.getCreationInfo(), parentCommand, VdcObjectType.Storage, imagesList[0]);
        getTaskIdList().add(guid1);
        // delete second image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue2 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[4], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue2.getSucceeded()) {
            if (startPollingTasks) {
                UpdateTasksWithActionParameters();
                AsyncTaskManager.getInstance().StartPollingTask(guid1);
            }
            return false;
        }
        Guid guid2 = CreateTask(vdsRetValue2.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid2);
        if (startPollingTasks) {
            UpdateTasksWithActionParameters();
            AsyncTaskManager.getInstance().StartPollingTask(guid1);
            AsyncTaskManager.getInstance().StartPollingTask(guid2);
        }
    }
    return true;
}
#method_after
protected boolean handleHibernatedVm(VdcActionType parentCommand, boolean startPollingTasks) {
    // this is temp code until it will be implemented in SPM
    String[] strings = getVm().gethibernation_vol_handle().split(",");
    List<Guid> guids = new LinkedList<Guid>();
    for (String string : strings) {
        guids.add(new Guid(string));
    }
    Guid[] imagesList = guids.toArray(new Guid[0]);
    if (imagesList.length == 6) {
        // get all vm disks in order to check post zero - if one of the
        // disks is marked with wipe_after_delete
        boolean postZero = LinqUtils.filter(getDiskDAO().getAllForVm(getVm().getId()), new Predicate<Disk>() {

            @Override
            public boolean eval(Disk disk) {
                return disk.isWipeAfterDelete();
            }
        }).size() > 0;
        // delete first image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue1 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[2], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue1.getSucceeded()) {
            return false;
        }
        Guid guid1 = createTask(vdsRetValue1.getCreationInfo(), parentCommand, VdcObjectType.Storage, imagesList[0]);
        getTaskIdList().add(guid1);
        // delete second image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue2 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[4], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue2.getSucceeded()) {
            if (startPollingTasks) {
                updateTasksWithActionParameters();
                AsyncTaskManager.getInstance().StartPollingTask(guid1);
            }
            return false;
        }
        Guid guid2 = createTask(vdsRetValue2.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid2);
        if (startPollingTasks) {
            updateTasksWithActionParameters();
            AsyncTaskManager.getInstance().StartPollingTask(guid1);
            AsyncTaskManager.getInstance().StartPollingTask(guid2);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    switch(DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId()).getstatus()) {
        case Up:
        case Down:
        case ImageLocked:
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
            return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNetworkInterface> allInterfaces = new ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId());
    if (!checkPciAndIDeLimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for version 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    // check that the exists in current cluster
    List<Network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    Network interfaceNetwork = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

        @Override
        public boolean eval(Network network) {
            return network.getname().equals(getParameters().getInterface().getNetworkName());
        }
    });
    if (interfaceNetwork == null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    } else if (!interfaceNetwork.isVmNetwork()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
        addCanDoActionMessage(String.format("$networks %1$s", interfaceNetwork.getname()));
        return false;
    }
    if (!StringUtils.isEmpty(getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    } else if (// check
    MacPoolManager.getInstance().getavailableMacsCount() <= 0) // if
    // we
    // have
    // mac
    // address
    // in
    // pool
    {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    switch(DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId()).getstatus()) {
        case Up:
        case Down:
        case ImageLocked:
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
            return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNetworkInterface> allInterfaces = new ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId());
    if (!checkPciAndIdeLimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for version 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    // check that the exists in current cluster
    List<Network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    Network interfaceNetwork = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

        @Override
        public boolean eval(Network network) {
            return network.getname().equals(getParameters().getInterface().getNetworkName());
        }
    });
    if (interfaceNetwork == null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    } else if (!interfaceNetwork.isVmNetwork()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
        addCanDoActionMessage(String.format("$networks %1$s", interfaceNetwork.getname()));
        return false;
    }
    if (!StringUtils.isEmpty(getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    } else if (// check
    MacPoolManager.getInstance().getavailableMacsCount() <= 0) // if
    // we
    // have
    // mac
    // address
    // in
    // pool
    {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected VDSReturnValue performImageVdsmOperation() {
    VDSReturnValue vdsReturnValue = null;
    try {
        Guid storagePoolId = getDiskImage().getstorage_pool_id() != null ? getDiskImage().getstorage_pool_id().getValue() : Guid.Empty;
        Guid storageDomainId = getDiskImage().getstorage_ids() != null && !getDiskImage().getstorage_ids().isEmpty() ? getDiskImage().getstorage_ids().get(0) : Guid.Empty;
        Guid imageGroupId = getDiskImage().getimage_group_id() != null ? getDiskImage().getimage_group_id().getValue() : Guid.Empty;
        vdsReturnValue = runVdsCommand(VDSCommandType.DestroyImage, new DestroyImageVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, _imagesToDelete, getDiskImage().isWipeAfterDelete(), true, getStoragePool().getcompatibility_version().toString()));
        if (vdsReturnValue.getSucceeded()) {
            getReturnValue().getInternalTaskIdList().add(CreateTask(vdsReturnValue.getCreationInfo(), VdcActionType.RestoreAllSnapshots, VdcObjectType.Storage, storageDomainId));
        }
    }// Don't throw an exception when cannot destroy image in the VDSM.
     catch (VdcBLLException e) {
        // Set fault for parent command RestoreAllSnapshotCommand to use, if decided to fail the command.
        getReturnValue().setFault(new VdcFault(e, e.getVdsError().getCode()));
        log.info(String.format("%1$s Image not exist in Irs", getDiskImage().getImageId()));
    }
    return vdsReturnValue;
}
#method_after
@Override
protected VDSReturnValue performImageVdsmOperation() {
    VDSReturnValue vdsReturnValue = null;
    try {
        Guid storagePoolId = getDiskImage().getstorage_pool_id() != null ? getDiskImage().getstorage_pool_id().getValue() : Guid.Empty;
        Guid storageDomainId = getDiskImage().getstorage_ids() != null && !getDiskImage().getstorage_ids().isEmpty() ? getDiskImage().getstorage_ids().get(0) : Guid.Empty;
        Guid imageGroupId = getDiskImage().getimage_group_id() != null ? getDiskImage().getimage_group_id().getValue() : Guid.Empty;
        vdsReturnValue = runVdsCommand(VDSCommandType.DestroyImage, new DestroyImageVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, _imagesToDelete, getDiskImage().isWipeAfterDelete(), true, getStoragePool().getcompatibility_version().toString()));
        if (vdsReturnValue.getSucceeded()) {
            getReturnValue().getInternalTaskIdList().add(createTask(vdsReturnValue.getCreationInfo(), VdcActionType.RestoreAllSnapshots, VdcObjectType.Storage, storageDomainId));
        }
    }// Don't throw an exception when cannot destroy image in the VDSM.
     catch (VdcBLLException e) {
        // Set fault for parent command RestoreAllSnapshotCommand to use, if decided to fail the command.
        getReturnValue().setFault(new VdcFault(e, e.getVdsError().getCode()));
        log.info(String.format("%1$s Image not exist in Irs", getDiskImage().getImageId()));
    }
    return vdsReturnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    returnValue = buildAndCheckDestStorageDomains();
    if (returnValue) {
        storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
        returnValue = CanDoAddVmCommand();
    }
    String vmName = getParameters().getVm().getvm_name();
    if (vmName == null || vmName.isEmpty()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        }
    }
    if (returnValue && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // check that we have no more then 8 interfaces (kvm limitation in version 2.x)
        if (!validateNumberOfNics(getVmInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            returnValue = false;
        }
    }
    // check for Vm Payload
    if (returnValue && getParameters().getVmPayload() != null) {
        returnValue = checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getiso_path());
        if (returnValue) {
            // we save the content in base64 string
            getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getusb_policy(), getParameters().getVm().getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        returnValue = false;
    }
    // check cpuPinning
    if (returnValue && !isCpuPinningValid(getParameters().getVm().getCpuPinning())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    }
    return returnValue && checkCpuSockets();
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    returnValue = buildAndCheckDestStorageDomains();
    if (returnValue) {
        storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
        returnValue = canDoAddVmCommand();
    }
    String vmName = getParameters().getVm().getvm_name();
    if (vmName == null || vmName.isEmpty()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        }
    }
    if (returnValue && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // check that we have no more then 8 interfaces (kvm limitation in version 2.x)
        if (!validateNumberOfNics(getVmInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            returnValue = false;
        }
    }
    // check for Vm Payload
    if (returnValue && getParameters().getVmPayload() != null) {
        returnValue = checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getiso_path());
        if (returnValue) {
            // we save the content in base64 string
            getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getusb_policy(), getParameters().getVm().getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        returnValue = false;
    }
    // check cpuPinning
    if (returnValue && !isCpuPinningValid(getParameters().getVm().getCpuPinning())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    }
    return returnValue && checkCpuSockets();
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                AddVmStatic();
                addVmDynamic();
                AddVmNetwork();
                AddVmStatistics();
                addActiveSnapshot();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        freeLock();
        addVmPermission();
        if (AddVmImages()) {
            copyVmDevices();
            addDiskPermissions(newDiskImages);
            addVmPayload();
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        freeLock();
        addVmPermission();
        if (addVmImages()) {
            copyVmDevices();
            addDiskPermissions(newDiskImages);
            addVmPayload();
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                SetStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<storage_pool_iso_map> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    for (storage_pool_iso_map domain : domains) {
        if (domain.getstatus() == null || domain.getstatus() == StorageDomainStatus.Unknown) {
            domain.setstatus(StorageDomainStatus.Active);
        } else if (domain.getstatus() == StorageDomainStatus.Maintenance) {
            domain.setstatus(StorageDomainStatus.InActive);
        } else if (domain.getstatus() == StorageDomainStatus.Locked) {
            throw new VdcBLLException(VdcBllErrors.CANT_RECONSTRUCT_WHEN_A_DOMAIN_IN_POOL_IS_LOCKED, "Cannot reconstruct master domain when a domain in the " + "pool is locked.");
        }
    }
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#method_after
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                SetStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<storage_pool_iso_map> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    try {
        for (VDS vds : getAllRunningVdssInPool()) {
            try {
                if (!_isLastMaster && commandSucceeded) {
                    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                    if (returnValue.getSucceeded()) {
                        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                    } else {
                        log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnValue.getVdsError().getMessage());
                    }
                }
                // only if we deactivate the storage domain we want to disconnect from it.
                if (getParameters().isInactive()) {
                    StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
                }
            } catch (Exception e) {
                log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
            }
        }
    } catch (Exception ex) {
        log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on all up hosts in the pool. error {0}", ex.getMessage());
    }
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    for (VDS vds : getAllRunningVdssInPool()) {
        try {
            if (!_isLastMaster && commandSucceeded) {
                VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                if (returnValue.getSucceeded()) {
                    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                } else {
                    log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnValue.getVdsError().getMessage());
                }
            }
            // only if we deactivate the storage domain we want to disconnect from it.
            if (!getParameters().isInactive()) {
                StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
            }
        } catch (Exception e) {
            log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
        }
    }
}
#end_block

#method_before
protected void rerunInternal() {
    Guid vdsId = getDestinationVds() != null ? getDestinationVds().getId() : getCurrentVdsId();
    decreasePendingVms(vdsId);
    setSucceeded(false);
    setVm(null);
    /**
     * Rerun VM only if not exceeded maximum rerun attempts. for example if there are 10 hosts that can run VM and
     * predefine maximum 3 attempts to rerun VM - on 4th turn vm will stop to run despite there are still available
     * hosts to run it DO NOT TRY TO RERUN IF RESUME FAILED.
     */
    if (getRunVdssList().size() < Config.<Integer>GetValue(ConfigValues.MaxRerunVmOnVdsCount) && getVm().getstatus() != VMStatus.Paused) {
        _isRerun = true;
        // restore CanDoAction value to false so CanDoAction checks will run again
        getReturnValue().setCanDoAction(false);
        log();
        if (getExecutionContext() != null) {
            Job job = getExecutionContext().getJob();
            if (job != null) {
                // mark previous steps as fail
                JobRepositoryFactory.getJobRepository().closeCompletedJobSteps(job.getId(), JobExecutionStatus.FAILED);
            }
        }
        ExecuteAction();
        if (!getReturnValue().getCanDoAction()) {
            _isRerun = false;
            log();
            failedToRunVm();
        }
    } else {
        Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(getVmId());
        failedToRunVm();
        _isRerun = false;
    }
}
#method_after
protected void rerunInternal() {
    Guid vdsId = getDestinationVds() != null ? getDestinationVds().getId() : getCurrentVdsId();
    decreasePendingVms(vdsId);
    setSucceeded(false);
    setVm(null);
    /**
     * Rerun VM only if not exceeded maximum rerun attempts. for example if there are 10 hosts that can run VM and
     * predefine maximum 3 attempts to rerun VM - on 4th turn vm will stop to run despite there are still available
     * hosts to run it DO NOT TRY TO RERUN IF RESUME FAILED.
     */
    if (getRunVdssList().size() < Config.<Integer>GetValue(ConfigValues.MaxRerunVmOnVdsCount) && getVm().getstatus() != VMStatus.Paused) {
        _isRerun = true;
        // restore CanDoAction value to false so CanDoAction checks will run again
        getReturnValue().setCanDoAction(false);
        log();
        if (getExecutionContext() != null) {
            Job job = getExecutionContext().getJob();
            if (job != null) {
                // mark previous steps as fail
                JobRepositoryFactory.getJobRepository().closeCompletedJobSteps(job.getId(), JobExecutionStatus.FAILED);
            }
        }
        executeAction();
        if (!getReturnValue().getCanDoAction()) {
            _isRerun = false;
            log();
            failedToRunVm();
        }
    } else {
        Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(getVmId());
        failedToRunVm();
        _isRerun = false;
    }
}
#end_block

#method_before
protected boolean processImageInIrs() {
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getImageGroupId(), getParameters().getDiskInfo().getsize(), getParameters().getDiskInfo().getvolume_type(), getParameters().getDiskInfo().getvolume_format(), getDestinationImageId(), "", getStoragePool().getcompatibility_version().toString()));
    if (vdsReturnValue.getSucceeded()) {
        getParameters().setTaskIds(new ArrayList<Guid>());
        getParameters().getTaskIds().add(CreateTask(vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
        getReturnValue().getInternalTaskIdList().add(getParameters().getTaskIds().get(0));
        return true;
    }
    return false;
}
#method_after
protected boolean processImageInIrs() {
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getImageGroupId(), getParameters().getDiskInfo().getsize(), getParameters().getDiskInfo().getvolume_type(), getParameters().getDiskInfo().getvolume_format(), getDestinationImageId(), "", getStoragePool().getcompatibility_version().toString()));
    if (vdsReturnValue.getSucceeded()) {
        getParameters().setTaskIds(new ArrayList<Guid>());
        getParameters().getTaskIds().add(createTask(vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
        getReturnValue().getInternalTaskIdList().add(getParameters().getTaskIds().get(0));
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(getParameters().getVmTemplateId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    if (getParameters().getInterface().getVmId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_VM_CANNOT_BE_SET);
        return false;
    }
    VmTemplateHandler.UpdateDisksFromDb(getVmTemplate());
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    if (!VmCommand.checkPciAndIDeLimit(getVmTemplate().getnum_of_monitors(), allInterfaces, new ArrayList<DiskImageBase>(getVmTemplate().getDiskList()), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check that the network exists in current cluster
    List<Network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(getVmTemplate().getvds_group_id());
    if (null == LinqUtils.firstOrNull(networks, new Predicate<Network>() {

        @Override
        public boolean eval(Network network) {
            return network.getname().equals(getParameters().getInterface().getNetworkName());
        }
    })) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(getParameters().getVmTemplateId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    if (getParameters().getInterface().getVmId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_VM_CANNOT_BE_SET);
        return false;
    }
    VmTemplateHandler.UpdateDisksFromDb(getVmTemplate());
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    if (!VmCommand.checkPciAndIdeLimit(getVmTemplate().getnum_of_monitors(), allInterfaces, new ArrayList<DiskImageBase>(getVmTemplate().getDiskList()), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check that the network exists in current cluster
    List<Network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(getVmTemplate().getvds_group_id());
    if (null == LinqUtils.firstOrNull(networks, new Predicate<Network>() {

        @Override
        public boolean eval(Network network) {
            return network.getname().equals(getParameters().getInterface().getNetworkName());
        }
    })) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId());
    if (vmDynamic.getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN);
        return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getId().equals(getParameters().getInterface().getId());
        }
    });
    if (oldIface == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getParameters().getInterface().getName())) {
        if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    // check that not exceeded PCI and IDE limit
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getParameters().getInterface());
    VmStatic vm = DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId());
    List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId());
    if (!checkPciAndIDeLimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__INTERFACE);
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for versions 2.1, 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        interfaces.remove(oldIface);
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        interfaces.add(oldIface);
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that the exists in current cluster
    List<Network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    if (null == LinqUtils.firstOrNull(networks, new Predicate<Network>() {

        @Override
        public boolean eval(Network n) {
            return n.getname().equals(getParameters().getInterface().getNetworkName());
        }
    })) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    }
    macAddressChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macAddressChanged) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId());
    if (vmDynamic.getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN);
        return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getId().equals(getParameters().getInterface().getId());
        }
    });
    if (oldIface == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getParameters().getInterface().getName())) {
        if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    // check that not exceeded PCI and IDE limit
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getParameters().getInterface());
    VmStatic vm = DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId());
    List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId());
    if (!checkPciAndIdeLimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__INTERFACE);
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for versions 2.1, 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        interfaces.remove(oldIface);
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        interfaces.add(oldIface);
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that the exists in current cluster
    List<Network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    if (null == LinqUtils.firstOrNull(networks, new Predicate<Network>() {

        @Override
        public boolean eval(Network n) {
            return n.getname().equals(getParameters().getInterface().getNetworkName());
        }
    })) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    }
    macAddressChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macAddressChanged) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean checkCanPerformRegularUpdate() {
    boolean retValue = true;
    if (_oldDisk.getDiskInterface() != getParameters().getDiskInfo().getDiskInterface()) {
        List<VmNetworkInterface> allVmInterfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getVmId());
        List<Disk> allVmDisks = getDiskDao().getAllForVm(getVmId());
        allVmDisks.removeAll(LinqUtils.filter(allVmDisks, new Predicate<Disk>() {

            @Override
            public boolean eval(Disk o) {
                return o.getId().equals(_oldDisk.getId());
            }
        }));
        allVmDisks.add(getParameters().getDiskInfo());
        if (!checkPciAndIDeLimit(getVm().getnum_of_monitors(), allVmInterfaces, allVmDisks, getReturnValue().getCanDoActionMessages())) {
            retValue = false;
        }
    }
    // Validate update boot disk.
    if (retValue && getParameters().getDiskInfo().isBoot()) {
        VmHandler.updateDisksFromDb(getVm());
        for (Disk disk : getVm().getDiskMap().values()) {
            if (disk.isBoot() && !disk.getId().equals(_oldDisk.getId())) {
                retValue = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_BOOT_IN_USE);
                getReturnValue().getCanDoActionMessages().add(String.format("$DiskName %1$s", disk.getDiskAlias()));
                break;
            }
        }
    }
    // Set disk alias name in the disk retrieved from the parameters.
    ImagesHandler.setDiskAlias(getParameters().getDiskInfo(), getVm());
    return retValue && validateShareableDisk();
}
#method_after
private boolean checkCanPerformRegularUpdate() {
    boolean retValue = true;
    if (_oldDisk.getDiskInterface() != getParameters().getDiskInfo().getDiskInterface()) {
        List<VmNetworkInterface> allVmInterfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getVmId());
        List<Disk> allVmDisks = getDiskDao().getAllForVm(getVmId());
        allVmDisks.removeAll(LinqUtils.filter(allVmDisks, new Predicate<Disk>() {

            @Override
            public boolean eval(Disk o) {
                return o.getId().equals(_oldDisk.getId());
            }
        }));
        allVmDisks.add(getParameters().getDiskInfo());
        if (!checkPciAndIdeLimit(getVm().getnum_of_monitors(), allVmInterfaces, allVmDisks, getReturnValue().getCanDoActionMessages())) {
            retValue = false;
        }
    }
    // Validate update boot disk.
    if (retValue && getParameters().getDiskInfo().isBoot()) {
        VmHandler.updateDisksFromDb(getVm());
        for (Disk disk : getVm().getDiskMap().values()) {
            if (disk.isBoot() && !disk.getId().equals(_oldDisk.getId())) {
                retValue = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_BOOT_IN_USE);
                getReturnValue().getCanDoActionMessages().add(String.format("$DiskName %1$s", disk.getDiskAlias()));
                break;
            }
        }
    }
    // Set disk alias name in the disk retrieved from the parameters.
    ImagesHandler.setDiskAlias(getParameters().getDiskInfo(), getVm());
    return retValue && validateShareableDisk();
}
#end_block

#method_before
private void performDiskUpdate() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            clearAddressOnInterfaceChange();
            _oldDisk.setBoot(getParameters().getDiskInfo().isBoot());
            _oldDisk.setDiskInterface(getParameters().getDiskInfo().getDiskInterface());
            _oldDisk.setPropagateErrors(getParameters().getDiskInfo().getPropagateErrors());
            _oldDisk.setWipeAfterDelete(getParameters().getDiskInfo().isWipeAfterDelete());
            _oldDisk.setDiskAlias(getParameters().getDiskInfo().getDiskAlias());
            _oldDisk.setDiskDescription(getParameters().getDiskInfo().getDiskDescription());
            _oldDisk.setShareable(getParameters().getDiskInfo().isShareable());
            DbFacade.getInstance().getBaseDiskDao().update(_oldDisk);
            if (_oldDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) _oldDisk;
                diskImage.setQuotaId(getQuotaId());
                getImageDao().update(diskImage.getImage());
            }
            // update cached image
            VmHandler.updateDisksFromDb(getVm());
            // update vm device boot order
            VmDeviceUtils.updateBootOrderInVmDevice(getVm().getStaticData());
            setSucceeded(updateVmInSpm(getVm().getstorage_pool_id(), Arrays.asList(getVm())));
            return null;
        }

        private void clearAddressOnInterfaceChange() {
            // clear the disk address if the type has changed
            if (_oldDisk.getDiskInterface() != getParameters().getDiskInfo().getDiskInterface()) {
                getVmDeviceDao().clearDeviceAddress(getVmDeviceDao().get(new VmDeviceId(_oldDisk.getId(), getVmId())).getDeviceId());
            }
        }
    });
}
#method_after
private void performDiskUpdate() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            clearAddressOnInterfaceChange();
            _oldDisk.setBoot(getParameters().getDiskInfo().isBoot());
            _oldDisk.setDiskInterface(getParameters().getDiskInfo().getDiskInterface());
            _oldDisk.setPropagateErrors(getParameters().getDiskInfo().getPropagateErrors());
            _oldDisk.setWipeAfterDelete(getParameters().getDiskInfo().isWipeAfterDelete());
            _oldDisk.setDiskAlias(getParameters().getDiskInfo().getDiskAlias());
            _oldDisk.setDiskDescription(getParameters().getDiskInfo().getDiskDescription());
            _oldDisk.setShareable(getParameters().getDiskInfo().isShareable());
            DbFacade.getInstance().getBaseDiskDao().update(_oldDisk);
            if (_oldDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) _oldDisk;
                diskImage.setQuotaId(getQuotaId());
                getImageDao().update(diskImage.getImage());
            }
            // update cached image
            VmHandler.updateDisksFromDb(getVm());
            // update vm device boot order
            VmDeviceUtils.updateBootOrderInVmDeviceAndStoreToDB(getVm().getStaticData());
            setSucceeded(updateVmInSpm(getVm().getstorage_pool_id(), Arrays.asList(getVm())));
            return null;
        }

        private void clearAddressOnInterfaceChange() {
            // clear the disk address if the type has changed
            if (_oldDisk.getDiskInterface() != getParameters().getDiskInfo().getDiskInterface()) {
                getVmDeviceDao().clearDeviceAddress(getVmDeviceDao().get(new VmDeviceId(_oldDisk.getId(), getVmId())).getDeviceId());
            }
        }
    });
}
#end_block

#method_before
@Override
protected void executeCommand() {
    lockImage();
    VDSReturnValue vdsReturnValue = null;
    Guid sourceDomainId = getParameters().getSourceDomainId() != null ? getParameters().getSourceDomainId().getValue() : getDiskImage().getstorage_ids().get(0);
    if (getParameters().getUseCopyCollapse()) {
        vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(getStorageDomain().getstorage_pool_id().getValue(), sourceDomainId, getParameters().getContainerId(), getParameters().getImageGroupID(), getParameters().getImageId(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), "", getParameters().getStorageDomainId(), getParameters().getCopyVolumeType(), getParameters().getVolumeFormat(), getParameters().getVolumeType(), getParameters().getPostZero(), getParameters().getForceOverride(), getStoragePool().getcompatibility_version().toString()));
    } else {
        vdsReturnValue = runVdsCommand(VDSCommandType.MoveImageGroup, new MoveImageGroupVDSCommandParameters(getDiskImage().getstorage_pool_id().getValue(), sourceDomainId, getDiskImage().getId(), getParameters().getStorageDomainId(), getParameters().getContainerId(), getParameters().getOperation(), getParameters().getPostZero(), getParameters().getForceOverride(), getStoragePool().getcompatibility_version().toString()));
    }
    if (vdsReturnValue.getSucceeded()) {
        AsyncTaskCreationInfo taskCreationInfo = vdsReturnValue.getCreationInfo();
        getReturnValue().getInternalTaskIdList().add(CreateTask(taskCreationInfo, getParameters().getParentCommand(), VdcObjectType.Storage, sourceDomainId, getParameters().getStorageDomainId()));
        // change storage domain in db only if object moved
        if (getParameters().getOperation() == ImageOperation.Move || getParameters().getParentCommand() == VdcActionType.ImportVm || getParameters().getParentCommand() == VdcActionType.ImportVmTemplate) {
            List<DiskImage> snapshots = getDiskImageDao().getAllSnapshotsForImageGroup(getParameters().getDestImageGroupId());
            setSnapshotForShareableDisk(snapshots);
            for (DiskImage snapshot : snapshots) {
                getImageStorageDomainMapDao().remove(new image_storage_domain_map_id(snapshot.getImageId(), snapshot.getstorage_ids().get(0)));
                getImageStorageDomainMapDao().save(new image_storage_domain_map(snapshot.getImageId(), getParameters().getStorageDomainId()));
            }
        } else if (getParameters().getAddImageDomainMapping()) {
            getImageStorageDomainMapDao().save(new image_storage_domain_map(getParameters().getImageId(), getParameters().getStorageDomainId()));
        }
        // update qutoa
        if (getParameters().getQuotaId() != null) {
            getImage().setQuotaId(getParameters().getQuotaId());
            getImageDao().updateQuotaForImageAndSnapshots(getParameters().getDestImageGroupId(), getParameters().getQuotaId());
        }
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    lockImage();
    VDSReturnValue vdsReturnValue = null;
    Guid sourceDomainId = getParameters().getSourceDomainId() != null ? getParameters().getSourceDomainId().getValue() : getDiskImage().getstorage_ids().get(0);
    if (getParameters().getUseCopyCollapse()) {
        vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(getStorageDomain().getstorage_pool_id().getValue(), sourceDomainId, getParameters().getContainerId(), getParameters().getImageGroupID(), getParameters().getImageId(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), "", getParameters().getStorageDomainId(), getParameters().getCopyVolumeType(), getParameters().getVolumeFormat(), getParameters().getVolumeType(), getParameters().getPostZero(), getParameters().getForceOverride(), getStoragePool().getcompatibility_version().toString()));
    } else {
        vdsReturnValue = runVdsCommand(VDSCommandType.MoveImageGroup, new MoveImageGroupVDSCommandParameters(getDiskImage().getstorage_pool_id().getValue(), sourceDomainId, getDiskImage().getId(), getParameters().getStorageDomainId(), getParameters().getContainerId(), getParameters().getOperation(), getParameters().getPostZero(), getParameters().getForceOverride(), getStoragePool().getcompatibility_version().toString()));
    }
    if (vdsReturnValue.getSucceeded()) {
        AsyncTaskCreationInfo taskCreationInfo = vdsReturnValue.getCreationInfo();
        getReturnValue().getInternalTaskIdList().add(createTask(taskCreationInfo, getParameters().getParentCommand(), VdcObjectType.Storage, sourceDomainId, getParameters().getStorageDomainId()));
        // change storage domain in db only if object moved
        if (getParameters().getOperation() == ImageOperation.Move || getParameters().getParentCommand() == VdcActionType.ImportVm || getParameters().getParentCommand() == VdcActionType.ImportVmTemplate) {
            List<DiskImage> snapshots = getDiskImageDao().getAllSnapshotsForImageGroup(getParameters().getDestImageGroupId());
            setSnapshotForShareableDisk(snapshots);
            for (DiskImage snapshot : snapshots) {
                getImageStorageDomainMapDao().remove(new image_storage_domain_map_id(snapshot.getImageId(), snapshot.getstorage_ids().get(0)));
                getImageStorageDomainMapDao().save(new image_storage_domain_map(snapshot.getImageId(), getParameters().getStorageDomainId()));
            }
        } else if (getParameters().getAddImageDomainMapping()) {
            getImageStorageDomainMapDao().save(new image_storage_domain_map(getParameters().getImageId(), getParameters().getStorageDomainId()));
        }
        // update qutoa
        if (getParameters().getQuotaId() != null) {
            getImage().setQuotaId(getParameters().getQuotaId());
            getImageDao().updateQuotaForImageAndSnapshots(getParameters().getDestImageGroupId(), getParameters().getQuotaId());
        }
        setSucceeded(true);
    }
}
#end_block

#method_before
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.NewGuid());
    mNewCreatedDiskImage = cloneDiskImage(getDestinationImageId());
    mNewCreatedDiskImage.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getDestinationStorageDomainId())));
    setStoragePoolId(mNewCreatedDiskImage.getstorage_pool_id() != null ? mNewCreatedDiskImage.getstorage_pool_id().getValue() : Guid.Empty);
    getParameters().setStoragePoolId(getStoragePoolId().getValue());
    // override volume type and volume format to sparse and cow according to
    // storage team request
    mNewCreatedDiskImage.setvolume_type(VolumeType.Sparse);
    mNewCreatedDiskImage.setvolume_format(VolumeFormat.COW);
    VDSReturnValue vdsReturnValue = null;
    try {
        vdsReturnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CreateSnapshot, new CreateSnapshotVDSCommandParameters(getStoragePoolId().getValue(), getDestinationStorageDomainId(), getImageGroupId(), getImage().getImageId(), getDiskImage().getsize(), mNewCreatedDiskImage.getvolume_type(), mNewCreatedDiskImage.getvolume_format(), getDiskImage().getimage_group_id().getValue(), getDestinationImageId(), "", getStoragePool().getcompatibility_version().toString()));
        if (vdsReturnValue.getSucceeded()) {
            getParameters().setTaskIds(new java.util.ArrayList<Guid>());
            getParameters().getTaskIds().add(CreateTask(vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationImageId()));
            getReturnValue().getInternalTaskIdList().add(getParameters().getTaskIds().get(0));
            // Shouldn't happen anymore:
            if (getDestinationImageId().equals(Guid.Empty)) {
                throw new RuntimeException();
            }
        }
    } catch (java.lang.Exception e) {
        log.errorFormat("CreateSnapshotCommand::CreateSnapshotInIrsServer::Failed creating snapshot from image id -'{0}'", getImage().getImageId());
        throw new VdcBLLException(VdcBllErrors.VolumeCreationError);
    }
    return vdsReturnValue;
}
#method_after
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.NewGuid());
    mNewCreatedDiskImage = cloneDiskImage(getDestinationImageId());
    mNewCreatedDiskImage.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getDestinationStorageDomainId())));
    setStoragePoolId(mNewCreatedDiskImage.getstorage_pool_id() != null ? mNewCreatedDiskImage.getstorage_pool_id().getValue() : Guid.Empty);
    getParameters().setStoragePoolId(getStoragePoolId().getValue());
    // override volume type and volume format to sparse and cow according to
    // storage team request
    mNewCreatedDiskImage.setvolume_type(VolumeType.Sparse);
    mNewCreatedDiskImage.setvolume_format(VolumeFormat.COW);
    VDSReturnValue vdsReturnValue = null;
    try {
        vdsReturnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CreateSnapshot, new CreateSnapshotVDSCommandParameters(getStoragePoolId().getValue(), getDestinationStorageDomainId(), getImageGroupId(), getImage().getImageId(), getDiskImage().getsize(), mNewCreatedDiskImage.getvolume_type(), mNewCreatedDiskImage.getvolume_format(), getDiskImage().getimage_group_id().getValue(), getDestinationImageId(), "", getStoragePool().getcompatibility_version().toString()));
        if (vdsReturnValue.getSucceeded()) {
            getParameters().setTaskIds(new java.util.ArrayList<Guid>());
            getParameters().getTaskIds().add(createTask(vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationImageId()));
            getReturnValue().getInternalTaskIdList().add(getParameters().getTaskIds().get(0));
            // Shouldn't happen anymore:
            if (getDestinationImageId().equals(Guid.Empty)) {
                throw new RuntimeException();
            }
        }
    } catch (java.lang.Exception e) {
        log.errorFormat("CreateSnapshotCommand::CreateSnapshotInIrsServer::Failed creating snapshot from image id -'{0}'", getImage().getImageId());
        throw new VdcBLLException(VdcBllErrors.VolumeCreationError);
    }
    return vdsReturnValue;
}
#end_block

#method_before
private void _openSession(String server, long hardTimeout, long softTimeout) throws Exception {
    log.debug(String.format("_openSession enter (%1$s, %2$d, %3$d)", server, hardTimeout, softTimeout));
    try {
        if (this.client != null) {
            log.debug("_openSession already has client");
        } else {
            this.client = new SSHClient();
            this.client.setHardTimeout(hardTimeout);
            this.client.setSoftTimeout(softTimeout);
            // port until API supports port
            this.client.setHost(server, this.port);
            log.debug("connecting");
            this.client.connect();
        }
    } catch (Exception e) {
        log.debug(String.format("Could not connect to server %1$s: %2$s", this.client.getDisplayHost(), e.getMessage()), e);
        throw e;
    }
    log.debug("_openSession return");
}
#method_after
private void _openSession(String server, long hardTimeout, long softTimeout) throws Exception {
    log.debug(String.format("_openSession enter (%1$s, %2$d, %3$d)", server, hardTimeout, softTimeout));
    try {
        if (this.client != null) {
            log.debug("_openSession already has client");
        } else {
            this.client = new SSHClient();
            this.client.setHardTimeout(hardTimeout);
            this.client.setSoftTimeout(softTimeout);
            // port until API supports port
            this.client.setHost(server, this.port);
            log.debug("connecting");
            this.client.connect();
        }
    } catch (Exception e) {
        log.debug(String.format("Could not connect to server %1$s", this.client.getDisplayHost()), e);
        throw e;
    }
    log.debug("_openSession return");
}
#end_block

#method_before
@Before
@Override
public void setUp() throws Exception {
    super.setUp();
    setupMock();
    setupExpectedGlusterServers();
}
#method_after
@Before
@Override
public void setUp() throws Exception {
    super.setUp();
    setupMock();
    setupExpectedFingerPrint();
}
#end_block

#method_before
private void setupMock() {
    vdsInstallerMock = mock(VdsInstallerSSH.class);
    callback = mock(SimpleCallback.class);
    doReturn(vdsInstallerMock).when(getQuery()).getVdsInstallerSSHInstance();
    doReturn(callback).when(getQuery()).getCallBack();
    doReturn(outputXml).when(getQuery()).getCliOutput();
}
#method_after
private void setupMock() {
    clientMock = mock(SSHClient.class);
    doReturn(clientMock).when(getQuery()).createSSHClient();
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    wrapper = getVdsInstallerSSHInstance();
    if (connect()) {
        if (executeCommand()) {
            String glusterServers = getCliOutput();
            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder docBuilder;
            try {
                docBuilder = docBuilderFactory.newDocumentBuilder();
                Document doc = docBuilder.parse(glusterServers);
                // normalize text representation
                doc.getDocumentElement().normalize();
                NodeList listOfPeers = doc.getElementsByTagName(PEER);
                parseHostName(listOfPeers);
            } catch (ParserConfigurationException e1) {
                log.errorFormat("There is problem in parsing xml." + e1.getMessage());
            } catch (SAXException e2) {
                log.errorFormat("Error in parsing xml." + e2.getMessage());
            } catch (IOException e3) {
                log.errorFormat("There is problem in reading the file." + e3.getMessage());
            }
            // Add current server also in the list
            hostNamesOrIp.add(getParameters().getServerName());
            getQueryReturnValue().setReturnValue(getServerFingerPrintMap());
        } else {
            log.error("Could not get the peer list form the host: " + getParameters().getServerName());
        }
    } else {
        log.error("Could not connect to host: " + getParameters().getServerName());
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    SSHClient client = null;
    try {
        client = connect(getParameters().getServerName());
        validateFingerprint(client, getParameters().getFingerprint());
        authenticate(client, ROOT, getParameters().getPassword());
        String serversXml = executeCommand(client);
        getQueryReturnValue().setReturnValue(extractServers(serversXml));
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        if (client != null) {
            client.disconnect();
        }
    }
}
#end_block

#method_before
public boolean connect() {
    return wrapper.connect(getParameters().getServerName(), getParameters().getRootPassword());
}
#method_after
protected SSHClient connect(String serverName) {
    SSHClient client = createSSHClient();
    Integer timeout = Config.<Integer>GetValue(ConfigValues.ConnectToServerTimeoutInSeconds) * 1000;
    client.setHardTimeout(timeout);
    client.setSoftTimeout(timeout);
    client.setHost(serverName, PORT);
    try {
        client.connect();
        return client;
    } catch (Exception e) {
        log.debug(String.format("Could not connect to server %1$s: %2$s", serverName, e.getMessage()));
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public boolean executeCommand() {
    callback = getCallBack();
    wrapper.setCallback(callback);
    return wrapper.executeCommand(SSH_COMMAND);
}
#method_after
protected String executeCommand(SSHClient client) throws Exception {
    ByteArrayOutputStream out = new ConstraintByteArrayOutputStream(500);
    String command = Config.<String>GetValue(ConfigValues.GlusterPeerStatusCommand);
    client.executeCommand(command, null, out, null);
    return new String(out.toByteArray(), "UTF-8");
}
#end_block

#method_before
private String getFingerprint(String hostName) {
    String fingerPrint = "";
    try {
        fingerPrint = wrapper.getServerKeyFingerprint(hostName);
    } catch (Throwable e) {
        log.errorFormat("Could not fetch fingerprint of server {0} with message: {1}", hostName, ExceptionUtils.getMessage(e));
    } finally {
        wrapper.shutdown();
    }
    return fingerPrint;
}
#method_after
private String getFingerprint(String hostName) {
    SSHClient client = null;
    try {
        client = connect(hostName);
        return getFingerprint(client);
    } finally {
        if (client != null) {
            client.disconnect();
        }
    }
}
#end_block

#method_before
private String getFingerprint(String hostName) {
    String fingerPrint = "";
    try {
        fingerPrint = wrapper.getServerKeyFingerprint(hostName);
    } catch (Throwable e) {
        log.errorFormat("Could not fetch fingerprint of server {0} with message: {1}", hostName, ExceptionUtils.getMessage(e));
    } finally {
        wrapper.shutdown();
    }
    return fingerPrint;
}
#method_after
private String getFingerprint(SSHClient client) {
    PublicKey serverKey = client.getServerKey();
    if (serverKey == null) {
        log.error("Could not get server key");
        return null;
    }
    return OpenSSHUtils.getKeyFingerprintString(serverKey);
}
#end_block

#method_before
private boolean _doConnect(String server, String user, String userPassword, String keyStore, String keyStorePassword) {
    return _doConnect(server, user, userPassword, keyStore, keyStorePassword, Config.<Integer>GetValue(ConfigValues.SSHInactivityTimoutSeconds) * 1000);
}
#method_after
private boolean _doConnect(String server, String user, String userPassword, String keyStore, String keyStorePassword) {
    return _doConnect(server, user, userPassword, keyStore, keyStorePassword, Config.<Integer>GetValue(ConfigValues.SSHInactivityHardTimoutSeconds) * 1000, Config.<Integer>GetValue(ConfigValues.SSHInactivityTimoutSeconds) * 1000);
}
#end_block

#method_before
private void _openSession(String server, long timeout) throws Exception {
    log.debug(String.format("_openSession enter (%1$s, %2$d)", server, timeout));
    try {
        if (this.client != null) {
            log.debug("_openSession already has client");
        } else {
            this.host = server;
            this.client = new SSHClient();
            this.client.setHardTimeout(timeout);
            this.client.setSoftTimeout(timeout);
            this.client.setHost(this.host, this.port);
            log.debug("connecting");
            this.client.connect();
        }
    } catch (Exception e) {
        log.debug(String.format("Could not connect to server %1$s: %2$s", this.host, e.getMessage()));
        throw e;
    }
    log.debug("_openSession return");
}
#method_after
private void _openSession(String server, long hardTimeout, long softTimeout) throws Exception {
    log.debug(String.format("_openSession enter (%1$s, %2$d, %3$d)", server, hardTimeout, softTimeout));
    try {
        if (this.client != null) {
            log.debug("_openSession already has client");
        } else {
            this.client = new SSHClient();
            this.client.setHardTimeout(hardTimeout);
            this.client.setSoftTimeout(softTimeout);
            // port until API supports port
            this.client.setHost(server, this.port);
            log.debug("connecting");
            this.client.connect();
        }
    } catch (Exception e) {
        log.debug(String.format("Could not connect to server %1$s: %2$s", this.client.getDisplayHost()), e);
        throw e;
    }
    log.debug("_openSession return");
}
#end_block

#method_before
private boolean _doConnect(String server, String user, String userPassword, String keyStore, String keyStorePassword, long timeout) {
    log.debug(String.format("_doConnect enter (%1$s, %2$s, %3$s, %4$s, %5$s, %6$d)", server, user, userPassword, keyStore, keyStorePassword, timeout));
    boolean ret = false;
    try {
        _openSession(server, timeout);
        this.client.setUser(user);
        if (keyStore == null) {
            log.debug("Using password authentication.");
            this.client.setPassword(userPassword);
        } else {
            log.debug("Using Public Key Authentication.");
            String alias = Config.<String>GetValue(ConfigValues.CertAlias);
            KeyStore.PrivateKeyEntry entry;
            InputStream in = null;
            try {
                in = new FileInputStream(keyStore);
                KeyStore ks = KeyStore.getInstance("JKS");
                ks.load(in, null);
                entry = (KeyStore.PrivateKeyEntry) ks.getEntry(alias, new KeyStore.PasswordProtection(keyStorePassword.toCharArray()));
            } catch (Exception e) {
                throw new KeyStoreException(String.format("Failed to get certificate entry from key store: %1$s/%2$s", keyStore, alias), e);
            } finally {
                if (in != null) {
                    try {
                        in.close();
                    } catch (IOException e) {
                        log.error("Cannot close key store", e);
                    }
                }
            }
            if (entry == null) {
                throw new KeyStoreException(String.format("Bad key store: %1$s/%2$s", keyStore, alias));
            }
            this.client.setKeyPair(new KeyPair(entry.getCertificate().getPublicKey(), entry.getPrivateKey()));
        }
        PublicKey serverKey = this.client.getServerKey();
        String fingerprint = "Unknown";
        if (serverKey == null) {
            log.error("Unable to get host key");
        } else {
            String tmpFingerprint = OpenSSHUtils.getKeyFingerprintString(serverKey);
            if (tmpFingerprint == null) {
                log.error("Unable to get host fingerprint");
            } else {
                fingerprint = tmpFingerprint;
            }
        }
        _callbackAddMessage(String.format("<BSTRAP component='RHEV_INSTALL' status='OK' message='Connected to Host %1$s with SSH key fingerprint: %2$s'/>", this.host, fingerprint));
        this.client.authenticate();
        _callbackConnected();
        ret = true;
    } catch (Exception e) {
        String m = String.format("Could not connect to server %1$s: %2$s", this.host, e.getMessage());
        log.error(m, e);
        _callbackFailed(m);
        return false;
    }
    log.debug("_doConnect return " + ret);
    return ret;
}
#method_after
private boolean _doConnect(String server, String user, String userPassword, String keyStore, String keyStorePassword, long hardTimeout, long softTimeout) {
    log.debug(String.format("_doConnect enter (%1$s, %2$s, %3$s, %4$s, %5$s, %6$d, %7$d)", server, user, userPassword, keyStore, keyStorePassword, hardTimeout, softTimeout));
    boolean ret = false;
    try {
        _openSession(server, hardTimeout, softTimeout);
        this.client.setUser(user);
        if (keyStore == null) {
            log.debug("Using password authentication.");
            this.client.setPassword(userPassword);
        } else {
            log.debug("Using Public Key Authentication.");
            String alias = Config.<String>GetValue(ConfigValues.CertAlias);
            KeyStore.PrivateKeyEntry entry;
            InputStream in = null;
            try {
                in = new FileInputStream(keyStore);
                KeyStore ks = KeyStore.getInstance("JKS");
                ks.load(in, null);
                entry = (KeyStore.PrivateKeyEntry) ks.getEntry(alias, new KeyStore.PasswordProtection(keyStorePassword.toCharArray()));
            } catch (Exception e) {
                throw new KeyStoreException(String.format("Failed to get certificate entry from key store: %1$s/%2$s", keyStore, alias), e);
            } finally {
                if (in != null) {
                    try {
                        in.close();
                    } catch (IOException e) {
                        log.error("Cannot close key store", e);
                    }
                }
            }
            if (entry == null) {
                throw new KeyStoreException(String.format("Bad key store: %1$s/%2$s", keyStore, alias));
            }
            this.client.setKeyPair(new KeyPair(entry.getCertificate().getPublicKey(), entry.getPrivateKey()));
        }
        PublicKey serverKey = this.client.getServerKey();
        String fingerprint = "Unknown";
        if (serverKey == null) {
            log.error("Unable to get host key");
        } else {
            String tmpFingerprint = OpenSSHUtils.getKeyFingerprintString(serverKey);
            if (tmpFingerprint == null) {
                log.error("Unable to get host fingerprint");
            } else {
                fingerprint = tmpFingerprint;
            }
        }
        _callbackAddMessage(String.format("<BSTRAP component='RHEV_INSTALL' status='OK' message='Connected to Host %1$s with SSH key fingerprint: %2$s'/>", this.client.getDisplayHost(), fingerprint));
        this.client.authenticate();
        _callbackConnected();
        ret = true;
    } catch (Exception e) {
        String m = String.format("Could not connect to server %1$s", this.client.getDisplayHost());
        log.error(m, e);
        _callbackFailed(m);
        return false;
    }
    log.debug("_doConnect return " + ret);
    return ret;
}
#end_block

#method_before
public final boolean connect(String server, String rootPassword, long timeout) {
    return _doConnect(server, "root", rootPassword, null, null, timeout);
}
#method_after
public final boolean connect(String server, String rootPassword, long hardTimeout) {
    return _doConnect(server, "root", rootPassword, null, null, hardTimeout, hardTimeout);
}
#end_block

#method_before
public final boolean connect(String server, String keyStore, String keyStorePassword) {
    return _doConnect(server, "root", null, keyStore, keyStorePassword);
}
#method_after
public final boolean connect(String server, String rootPassword, long hardTimeout, long softTimeout) {
    return _doConnect(server, "root", rootPassword, null, null, hardTimeout, softTimeout);
}
#end_block

#method_before
public final boolean executeCommand(String command) {
    /**
     * Send status per line recieved from stdout of command.
     */
    class MessageOutputStream extends OutputStream {

        byte[] buffer;

        ByteBuffer bbuffer;

        void _send() {
            int n;
            do {
                n = -1;
                for (int i = 0; i < bbuffer.position(); i++) {
                    if (buffer[i] == (byte) '\n') {
                        n = i;
                        break;
                    }
                }
                if (n != -1) {
                    String message;
                    try {
                        message = new String(buffer, 0, n, "UTF-8");
                    } catch (UnsupportedEncodingException e) {
                        log.error("Cannot decode message", e);
                        message = "[unable to decode message]";
                    }
                    bbuffer.position(bbuffer.position() - n - 1);
                    System.arraycopy(buffer, n + 1, buffer, 0, bbuffer.position());
                    log.debug(message);
                    _callbackAddMessage(message);
                }
            } while (n != -1);
        }

        public MessageOutputStream() {
            buffer = new byte[2048];
            bbuffer = ByteBuffer.wrap(buffer);
        }

        @Override
        public void finalize() {
            close();
        }

        @Override
        public void close() {
            if (bbuffer.position() != 0) {
                String message;
                try {
                    message = new String(buffer, 0, bbuffer.position(), "UTF-8");
                } catch (UnsupportedEncodingException e) {
                    log.error("Cannot decode message", e);
                    message = "[unable to decode message]";
                }
                bbuffer.clear();
                log.debug(message);
                _callbackAddMessage(message);
            }
        }

        @Override
        public void write(byte[] b, int off, int len) {
            bbuffer.put(b, off, len);
            _send();
        }

        @Override
        public void write(int b) {
            bbuffer.put((byte) b);
            _send();
        }
    }
    log.info(String.format("SSH execute %1$s '%2$s'", this.host, command));
    boolean ret = false;
    try {
        ByteArrayOutputStream stderr = new ConstraintByteArrayOutputStream(1024);
        try {
            this.client.executeCommand(command, new ByteArrayInputStream(new byte[0]), new MessageOutputStream(), stderr);
        } finally {
            if (stderr.size() > 0) {
                _callbackAddError(new String(stderr.toByteArray(), "UTF-8"));
            }
        }
        if (stderr.size() == 0) {
            ret = true;
        }
    } catch (Exception e) {
        String m = String.format("SSH error running command %1$s '%2$s': %3$s", this.host, command, e.getMessage());
        log.error(m, e);
        _callbackFailed(m);
    }
    log.debug("executeCommand leave " + ret);
    return ret;
}
#method_after
public final boolean executeCommand(String command, InputStream stdin) {
    /**
     * Send status per line recieved from stdout of command.
     */
    class MessageOutputStream extends OutputStream {

        byte[] buffer;

        ByteBuffer bbuffer;

        void _send() {
            int n;
            do {
                n = -1;
                for (int i = 0; i < bbuffer.position(); i++) {
                    if (buffer[i] == (byte) '\n') {
                        n = i;
                        break;
                    }
                }
                if (n != -1) {
                    String message;
                    try {
                        message = new String(buffer, 0, n, "UTF-8");
                    } catch (UnsupportedEncodingException e) {
                        log.error("Cannot decode message", e);
                        message = "[unable to decode message]";
                    }
                    bbuffer.position(bbuffer.position() - n - 1);
                    System.arraycopy(buffer, n + 1, buffer, 0, bbuffer.position());
                    log.debug(message);
                    _callbackAddMessage(message);
                }
            } while (n != -1);
        }

        public MessageOutputStream() {
            buffer = new byte[2048];
            bbuffer = ByteBuffer.wrap(buffer);
        }

        @Override
        public void finalize() {
            close();
        }

        @Override
        public void close() {
            if (bbuffer.position() != 0) {
                String message;
                try {
                    message = new String(buffer, 0, bbuffer.position(), "UTF-8");
                } catch (UnsupportedEncodingException e) {
                    log.error("Cannot decode message", e);
                    message = "[unable to decode message]";
                }
                bbuffer.clear();
                log.debug(message);
                _callbackAddMessage(message);
            }
        }

        @Override
        public void write(byte[] b, int off, int len) {
            bbuffer.put(b, off, len);
            _send();
        }

        @Override
        public void write(int b) {
            bbuffer.put((byte) b);
            _send();
        }
    }
    log.info(String.format("SSH execute %1$s '%2$s'", this.client.getDisplayHost(), command));
    boolean ret = false;
    try {
        ByteArrayOutputStream stderr = new ConstraintByteArrayOutputStream(1024);
        try {
            this.client.executeCommand(command, stdin, new MessageOutputStream(), stderr);
        } finally {
            if (stderr.size() > 0) {
                _callbackAddError(new String(stderr.toByteArray(), "UTF-8"));
            }
        }
        if (stderr.size() == 0) {
            ret = true;
        }
    } catch (Exception e) {
        log.error(String.format("SSH error running command %1$s:'%2$s'", this.client.getDisplayHost(), command), e);
        _callbackFailed(String.format("SSH command failed while executing at host '%1$s', refer to logs for further information", this.client.getDisplayHost()));
    }
    log.debug("executeCommand leave " + ret);
    return ret;
}
#end_block

#method_before
public final boolean executeCommand(String command) {
    /**
     * Send status per line recieved from stdout of command.
     */
    class MessageOutputStream extends OutputStream {

        byte[] buffer;

        ByteBuffer bbuffer;

        void _send() {
            int n;
            do {
                n = -1;
                for (int i = 0; i < bbuffer.position(); i++) {
                    if (buffer[i] == (byte) '\n') {
                        n = i;
                        break;
                    }
                }
                if (n != -1) {
                    String message;
                    try {
                        message = new String(buffer, 0, n, "UTF-8");
                    } catch (UnsupportedEncodingException e) {
                        log.error("Cannot decode message", e);
                        message = "[unable to decode message]";
                    }
                    bbuffer.position(bbuffer.position() - n - 1);
                    System.arraycopy(buffer, n + 1, buffer, 0, bbuffer.position());
                    log.debug(message);
                    _callbackAddMessage(message);
                }
            } while (n != -1);
        }

        public MessageOutputStream() {
            buffer = new byte[2048];
            bbuffer = ByteBuffer.wrap(buffer);
        }

        @Override
        public void finalize() {
            close();
        }

        @Override
        public void close() {
            if (bbuffer.position() != 0) {
                String message;
                try {
                    message = new String(buffer, 0, bbuffer.position(), "UTF-8");
                } catch (UnsupportedEncodingException e) {
                    log.error("Cannot decode message", e);
                    message = "[unable to decode message]";
                }
                bbuffer.clear();
                log.debug(message);
                _callbackAddMessage(message);
            }
        }

        @Override
        public void write(byte[] b, int off, int len) {
            bbuffer.put(b, off, len);
            _send();
        }

        @Override
        public void write(int b) {
            bbuffer.put((byte) b);
            _send();
        }
    }
    log.info(String.format("SSH execute %1$s '%2$s'", this.host, command));
    boolean ret = false;
    try {
        ByteArrayOutputStream stderr = new ConstraintByteArrayOutputStream(1024);
        try {
            this.client.executeCommand(command, new ByteArrayInputStream(new byte[0]), new MessageOutputStream(), stderr);
        } finally {
            if (stderr.size() > 0) {
                _callbackAddError(new String(stderr.toByteArray(), "UTF-8"));
            }
        }
        if (stderr.size() == 0) {
            ret = true;
        }
    } catch (Exception e) {
        String m = String.format("SSH error running command %1$s '%2$s': %3$s", this.host, command, e.getMessage());
        log.error(m, e);
        _callbackFailed(m);
    }
    log.debug("executeCommand leave " + ret);
    return ret;
}
#method_after
public final boolean executeCommand(String command) {
    return executeCommand(command, new ByteArrayInputStream(new byte[0]));
}
#end_block

#method_before
public final boolean receiveFile(String source, String destination) {
    log.info(String.format("SSH receive %1$s:'%2$s' '%3$s')", this.host, source, destination));
    boolean ret = false;
    try {
        this.client.receiveFile(source, destination);
        _callbackEndTransfer();
        ret = true;
    } catch (FileNotFoundException e) {
        String m = String.format("SSH could not receive file %1$s:'%2$s': '%3$s': %4$s", this.host, source, destination, e.getMessage());
        log.error(m, e);
        _callbackFailed(m);
    } catch (Exception e) {
        String m = String.format("SSH could not receive file %1$s:'%2$s': '%3$s': %4$s", this.host, source, destination, e.getMessage());
        log.error(m, e);
        _callbackAddError(m);
    }
    log.debug("receiveFile leave " + ret);
    return ret;
}
#method_after
public final boolean receiveFile(String source, String destination) {
    log.info(String.format("SSH receive %1$s:'%2$s' '%3$s')", this.client.getDisplayHost(), source, destination));
    boolean ret = false;
    try {
        this.client.receiveFile(source, destination);
        _callbackEndTransfer();
        ret = true;
    } catch (FileNotFoundException e) {
        String m = String.format("SSH could not receive file %1$s:'%2$s': '%3$s'", this.client.getDisplayHost(), source, destination);
        log.error(m, e);
        _callbackFailed(m);
    } catch (Exception e) {
        String m = String.format("SSH could not receive file %1$s:'%2$s': '%3$s'", this.client.getDisplayHost(), source, destination);
        log.error(m, e);
        _callbackAddError(m);
    }
    log.debug("receiveFile leave " + ret);
    return ret;
}
#end_block

#method_before
public final boolean sendFile(String source, String destination) {
    log.debug(String.format("SSH send %1$s:'%2$s' '%3$s'", this.host, source, destination));
    boolean ret = false;
    try {
        this.client.sendFile(source, destination);
        _callbackEndTransfer();
        ret = true;
    } catch (FileNotFoundException e) {
        log.error(String.format("SSH could not send file %2$s %1$s:%3$s", this.host, source, destination), e);
        _callbackFailed(e.getMessage());
    } catch (Exception e) {
        String m = String.format("SSH could not send file %2$s %1$s:%3$s: %4$s", this.host, source, destination, e.getMessage());
        log.error(m, e);
        _callbackAddError(m);
    }
    log.debug("sendFile leave " + ret);
    return ret;
}
#method_after
public final boolean sendFile(String source, String destination) {
    log.debug(String.format("SSH send %1$s:'%2$s' '%3$s'", this.client.getDisplayHost(), source, destination));
    boolean ret = false;
    try {
        this.client.sendFile(source, destination);
        _callbackEndTransfer();
        ret = true;
    } catch (FileNotFoundException e) {
        log.error(String.format("SSH could not send file %2$s %1$s:%3$s", this.client.getDisplayHost(), source, destination), e);
        _callbackFailed(e.getMessage());
    } catch (Exception e) {
        String m = String.format("SSH could not send file %2$s %1$s:%3$s", this.client.getDisplayHost(), source, destination);
        log.error(m, e);
        _callbackAddError(m);
    }
    log.debug("sendFile leave " + ret);
    return ret;
}
#end_block

#method_before
public String getServerKeyFingerprint(String server, long timeout) throws Exception {
    String fingerprint = null;
    _openSession(server, timeout);
    PublicKey serverKey = this.client.getServerKey();
    if (serverKey != null) {
        fingerprint = OpenSSHUtils.getKeyFingerprintString(serverKey);
    }
    return fingerprint;
}
#method_after
public String getServerKeyFingerprint(String server, long timeout) throws Exception {
    String fingerprint = null;
    _openSession(server, timeout, timeout);
    PublicKey serverKey = this.client.getServerKey();
    if (serverKey != null) {
        fingerprint = OpenSSHUtils.getKeyFingerprintString(serverKey);
    }
    return fingerprint;
}
#end_block

#method_before
@Before
public void setup() throws IOException {
    IConfigUtilsInterface confInstance = new DefaultValuesConfigUtil();
    Config.setConfigUtils(confInstance);
    sshd = new SSHD();
    try {
        KeyStore ks = KeyStore.getInstance("JKS");
        ks.load(new FileInputStream(hostKstore), /*hostKstorePassword.toCharArray()*/
        null);
        sshd.setUser(user, password, ks.getCertificate(Config.<String>GetValue(ConfigValues.CertAlias)).getPublicKey());
    } catch (Throwable e) {
        throw new RuntimeException(e);
    }
    try {
        sshd.start();
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
    port = sshd.getPort();
}
#method_after
@Before
public void setup() throws IOException {
    IConfigUtilsInterface confInstance = new DefaultValuesConfigUtil();
    Config.setConfigUtils(confInstance);
    host = System.getProperty("ssh-host");
    if (host == null) {
        host = "localhost";
        user = "root";
        password = "password";
        sshd = new SSHD();
        try {
            KeyStore ks = KeyStore.getInstance("JKS");
            ks.load(new FileInputStream(hostKstore), /*hostKstorePassword.toCharArray()*/
            null);
            sshd.setUser(user, password, ks.getCertificate(Config.<String>GetValue(ConfigValues.CertAlias)).getPublicKey());
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
        try {
            sshd.start();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        port = sshd.getPort();
    } else {
        port = Integer.parseInt(System.getProperty("ssh-test-port", "22"));
        user = System.getProperty("ssh-test-user", "root");
        password = System.getProperty("ssh-test-password", "password");
    }
}
#end_block

#method_before
@Test
public void testInvalidCommand() throws Exception {
    MyVdsInstallerCallback callbacks = new MyVdsInstallerCallback();
    VdsInstallerSSH vssh = new VdsInstallerSSH();
    vssh.setPort(port);
    vssh.setCallback(callbacks);
    try {
        assertTrue(vssh.connect(host, password));
        callbacks.reset();
        assertFalse(vssh.executeCommand("xxxx"));
        assertFalse(callbacks.connected);
        assertFalse(callbacks.endTransfer);
        assertNull(callbacks.message);
        assertNotNull(callbacks.error);
        assertNotNull(callbacks.fail);
    } finally {
        vssh.shutdown();
        vssh = null;
    }
}
#method_after
@Test
public void testInvalidCommand() throws Exception {
    MyVdsInstallerCallback callbacks = new MyVdsInstallerCallback();
    VdsInstallerSSH vssh = new VdsInstallerSSH();
    vssh.setPort(port);
    vssh.setCallback(callbacks);
    try {
        assertTrue(vssh.connect(host, password));
        callbacks.reset();
        assertFalse(vssh.executeCommand("/xxxx"));
        assertFalse(callbacks.connected);
        assertFalse(callbacks.endTransfer);
        assertNull(callbacks.message);
        assertNotNull(callbacks.error);
        assertNotNull(callbacks.fail);
    } finally {
        vssh.shutdown();
        vssh = null;
    }
}
#end_block

#method_before
@Test
public void testFingerprint() throws Exception {
    VdsInstallerSSH mina = new VdsInstallerSSH();
    mina.setPort(port);
    try {
        assertEquals(OpenSSHUtils.getKeyFingerprintString(sshd.getKey()), mina.getServerKeyFingerprint(host, 5000));
    } finally {
        mina.shutdown();
        mina = null;
    }
}
#method_after
@Test
public void testFingerprint() throws Exception {
    Assume.assumeNotNull(sshd);
    VdsInstallerSSH vdsi = new VdsInstallerSSH();
    vdsi.setPort(port);
    try {
        assertEquals(OpenSSHUtils.getKeyFingerprintString(sshd.getKey()), vdsi.getServerKeyFingerprint(host, 5000));
    } finally {
        vdsi.shutdown();
        vdsi = null;
    }
}
#end_block

#method_before
public static List<VmDevice> updateBootOrderInVmDevice(VmBase vmBase) {
    if (vmBase instanceof VmStatic) {
        // Returns the devices sorted in ascending manner
        List<VmDevice> devices = dao.getVmDeviceByVmId(vmBase.getId());
        // reset current boot order
        for (VmDevice device : devices) {
            device.setBootOrder(0);
        }
        VM vm = DbFacade.getInstance().getVmDAO().get(vmBase.getId());
        VmHandler.updateDisksForVm(vm, DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId()));
        boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version());
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, devices, isOldCluster);
        return devices;
    }
    return Collections.emptyList();
}
#method_after
public static List<VmDevice> updateBootOrderInVmDevice(VmBase vmBase) {
    if (vmBase instanceof VmStatic) {
        // Returns the devices sorted in ascending order
        List<VmDevice> devices = dao.getVmDeviceByVmId(vmBase.getId());
        // reset current boot order
        for (VmDevice device : devices) {
            device.setBootOrder(0);
        }
        VM vm = DbFacade.getInstance().getVmDAO().get(vmBase.getId());
        VmHandler.updateDisksForVm(vm, DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId()));
        boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version());
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, devices, isOldCluster);
        return devices;
    }
    return Collections.emptyList();
}
#end_block

#method_before
private void saveVmDevicesToDb() {
    // Sort VM devices in ascending order
    List<VmDevice> sortedVmDevices = new ArrayList<VmDevice>();
    sortedVmDevices.addAll(vmDeviceToSave.values());
    sortVmDeviceList(sortedVmDevices);
    updateAllInTransaction(sortedVmDevices, getDbFacade().getVmDeviceDAO());
    if (!removedDeviceIds.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getDbFacade().getVmDeviceDAO().removeAll(removedDeviceIds);
                return null;
            }
        });
    }
    if (!newVmDevices.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getDbFacade().getVmDeviceDAO().saveAll(newVmDevices);
                return null;
            }
        });
    }
}
#method_after
private void saveVmDevicesToDb() {
    List<VmDevice> list = new ArrayList<VmDevice>(vmDeviceToSave.values());
    Collections.sort(list);
    updateAllInTransaction("UpdateVmDeviceRuntimeInfo", list, getDbFacade().getVmDeviceDAO());
    if (!removedDeviceIds.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getDbFacade().getVmDeviceDAO().removeAll(removedDeviceIds);
                return null;
            }
        });
    }
    if (!newVmDevices.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getDbFacade().getVmDeviceDAO().saveAll(newVmDevices);
                return null;
            }
        });
    }
}
#end_block

#method_before
/**
 * Update all the given entities in a transaction, so that a new connection/transaction won't be opened for each
 * entity update.
 *
 * @param <T>
 *            The type of entity.
 * @param procieudreName
 *            The name of stored procedure to use for update
 * @param entities
 *            The entities to update.
 * @param dao
 *            The DAO used for updating.
 */
private static <T extends BusinessEntity<?>> void updateAllInTransaction(final String procedureName, final Collection<T> entities, final MassOperationsDao<T> dao) {
    if (!entities.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                dao.updateAll(procedureName, entities);
                return null;
            }
        });
    }
}
#method_after
/**
 * Update all the given entities in a transaction, so that a new connection/transaction won't be opened for each
 * entity update.
 *
 * @param <T>
 *            The type of entity.
 * @param procedureName
 *            The name of stored procedure to use for update
 * @param entities
 *            The entities to update.
 * @param dao
 *            The DAO used for updating.
 */
private static <T extends BusinessEntity<?>> void updateAllInTransaction(final String procedureName, final Collection<T> entities, final MassOperationsDao<T> dao) {
    if (!entities.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                dao.updateAll(procedureName, entities);
                return null;
            }
        });
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (disk == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk && ((DiskImage) disk).getimageStatus() == ImageStatus.ILLEGAL) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        return false;
    }
    retValue = retValue && acquireLockInternal() && isVmExist() && isVmUpOrDown() && isDiskCanBeAddedToVm(disk) && isDiskPassPCIAndIDELimit(disk);
    if (retValue && getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (retValue && disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (retValue && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (retValue && isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getstorage_ids().get(0), getVm().getstorage_pool_id())) == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (retValue && isImageDisk) {
        retValue = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVm().getId()));
    }
    if (retValue && getParameters().isPlugUnPlug() && getVm().getstatus() != VMStatus.Down) {
        retValue = isOSSupportingHotPlug() && isHotPlugSupported() && isInterfaceSupportedForPlugUnPlug(disk);
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (disk == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
        return false;
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk && ((DiskImage) disk).getimageStatus() == ImageStatus.ILLEGAL) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        return false;
    }
    retValue = acquireLockInternal() && isVmExist() && isVmUpOrDown() && isDiskCanBeAddedToVm(disk) && isDiskPassPCIAndIDELimit(disk);
    if (retValue && getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (retValue && disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (retValue && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (retValue && isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getstorage_ids().get(0), getVm().getstorage_pool_id())) == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (retValue && isImageDisk) {
        retValue = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVm().getId()));
    }
    if (retValue && getParameters().isPlugUnPlug() && getVm().getstatus() != VMStatus.Down) {
        retValue = isOSSupportingHotPlug() && isHotPlugSupported() && isInterfaceSupportedForPlugUnPlug(disk);
    }
    return retValue;
}
#end_block

#method_before
@Override
public void updateAll(String procedureName, Collection<T> entities) {
    if (procedureName == null) {
        procedureName = getProcedureNameForUpdate();
    }
    for (T entity : entities) {
        getCallsHandler().executeModification(procedureName, createFullParametersMapper(entity));
    }
}
#method_after
@Override
public /**
 * Enables to send update procedure name as a parameter that overrides the default
 * one.
 * In case this parameter is null the default procedure is used.
 */
void updateAll(String procedureName, Collection<T> entities) {
    if (procedureName == null) {
        procedureName = getProcedureNameForUpdate();
    }
    for (T entity : entities) {
        getCallsHandler().executeModification(procedureName, createFullParametersMapper(entity));
    }
}
#end_block

#method_before
@Override
protected DiskImage getImage() {
    switch(getActionState()) {
        case END_SUCCESS:
        case END_FAILURE:
            if (_diskImage == null) {
                List<DiskImage> diskImages = getDiskImageDAO().getAllSnapshotsForImageGroup(getParameters().getImageGroupID());
                _diskImage = (diskImages.isEmpty()) ? null : diskImages.get(0);
            }
            return _diskImage;
        default:
            return super.getImage();
    }
}
#method_after
@Override
protected DiskImage getImage() {
    switch(getActionState()) {
        case END_SUCCESS:
        case END_FAILURE:
            if (_diskImage == null) {
                List<DiskImage> diskImages = getDiskImageDao().getAllSnapshotsForImageGroup(getParameters().getImageGroupID());
                _diskImage = (diskImages.isEmpty()) ? null : diskImages.get(0);
            }
            return _diskImage;
        default:
            return super.getImage();
    }
}
#end_block

#method_before
@Override
protected boolean canPerformRollbackUsingCommand(VdcActionType commandType, VdcActionParametersBase params) {
    return getDiskImageDAO().get(getParameters().getDestinationImageId()) != null;
}
#method_after
@Override
protected boolean canPerformRollbackUsingCommand(VdcActionType commandType, VdcActionParametersBase params) {
    return getDiskImageDao().get(getParameters().getDestinationImageId()) != null;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    ExecuteVmCommand();
}
#method_after
@Override
protected void executeCommand() {
    executeVmCommand();
}
#end_block

#method_before
private void GetImageChildren(Guid snapshot, List<Guid> children) {
    List<Guid> list = new ArrayList<Guid>();
    for (DiskImage image : getDiskImageDAO().getAllSnapshotsForParent(snapshot)) {
        list.add(image.getImageId());
    }
    children.addAll(list);
    for (Guid snapshotId : list) {
        GetImageChildren(snapshotId, children);
    }
}
#method_after
private void GetImageChildren(Guid snapshot, List<Guid> children) {
    List<Guid> list = new ArrayList<Guid>();
    for (DiskImage image : getDiskImageDao().getAllSnapshotsForParent(snapshot)) {
        list.add(image.getImageId());
    }
    children.addAll(list);
    for (Guid snapshotId : list) {
        GetImageChildren(snapshotId, children);
    }
}
#end_block

#method_before
private DiskImage getDiskForVolumeInfo(DiskImage disk) {
    if (getParameters().getCopyCollapse()) {
        DiskImage ancestor = DbFacade.getInstance().getDiskImageDAO().getAncestor(disk.getImageId());
        if (ancestor == null) {
            log.warnFormat("Can't find ancestor of Disk with ID {0}, using original disk for volume info.", disk.getImageId());
            ancestor = disk;
        }
        return ancestor;
    } else {
        return disk;
    }
}
#method_after
private DiskImage getDiskForVolumeInfo(DiskImage disk) {
    if (getParameters().getCopyCollapse()) {
        DiskImage ancestor = getDiskImageDao().getAncestor(disk.getImageId());
        if (ancestor == null) {
            log.warnFormat("Can't find ancestor of Disk with ID {0}, using original disk for volume info.", disk.getImageId());
            ancestor = disk;
        }
        return ancestor;
    } else {
        return disk;
    }
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // Going to try and refresh the VM by re-loading
    setVm(null);
    // it form DB
    VM vmFromParams = getParameters().getVm();
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
        for (DiskImage disk : imageList) {
            DbFacade.getInstance().getDiskImageDynamicDAO().remove(disk.getImageId());
            DbFacade.getInstance().getImageDao().remove(disk.getImageId());
            List<DiskImage> imagesForDisk = DbFacade.getInstance().getDiskImageDAO().getAllSnapshotsForImageGroup(disk.getId());
            if (imagesForDisk == null || imagesForDisk.isEmpty()) {
                DbFacade.getInstance().getBaseDiskDao().remove(disk.getId());
            }
        }
        RemoveVmNetwork();
        new SnapshotsManager().removeSnapshots(getVm().getId());
        DbFacade.getInstance().getVmDynamicDAO().remove(getVmId());
        DbFacade.getInstance().getVmStatisticsDAO().remove(getVmId());
        new SnapshotsManager().removeSnapshots(getVmId());
        DbFacade.getInstance().getVmStaticDAO().remove(getVmId());
        setSucceeded(true);
    } else {
        // Setting VM from params, for logging purposes
        setVm(vmFromParams);
        // No point in trying to end action again, as the imported VM does not exist in the DB.
        getReturnValue().setEndActionTryAgain(false);
    }
    rollbackQuota();
}
#method_after
@Override
protected void endWithFailure() {
    // Going to try and refresh the VM by re-loading
    setVm(null);
    // it form DB
    VM vmFromParams = getParameters().getVm();
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
        for (DiskImage disk : imageList) {
            DbFacade.getInstance().getDiskImageDynamicDAO().remove(disk.getImageId());
            DbFacade.getInstance().getImageDao().remove(disk.getImageId());
            List<DiskImage> imagesForDisk = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForImageGroup(disk.getId());
            if (imagesForDisk == null || imagesForDisk.isEmpty()) {
                DbFacade.getInstance().getBaseDiskDao().remove(disk.getId());
            }
        }
        RemoveVmNetwork();
        new SnapshotsManager().removeSnapshots(getVm().getId());
        DbFacade.getInstance().getVmDynamicDAO().remove(getVmId());
        DbFacade.getInstance().getVmStatisticsDAO().remove(getVmId());
        new SnapshotsManager().removeSnapshots(getVmId());
        DbFacade.getInstance().getVmStaticDAO().remove(getVmId());
        setSucceeded(true);
    } else {
        // Setting VM from params, for logging purposes
        setVm(vmFromParams);
        // No point in trying to end action again, as the imported VM does not exist in the DB.
        getReturnValue().setEndActionTryAgain(false);
    }
    rollbackQuota();
}
#end_block

#method_before
private boolean canRemoveDiskBasedOnImageStorageCheck() {
    boolean retValue = true;
    DiskImage diskImage = (DiskImage) disk;
    if (diskImage.getVmEntityType() == VmEntityType.TEMPLATE) {
        // Temporary fix until re factoring vm_images_view and image_storage_domain_view
        diskImage.setstorage_ids(getDiskImageDAO().get(diskImage.getImageId()).getstorage_ids());
    } else if ((getParameters().getStorageDomainId() == null) || (Guid.Empty.equals(getParameters().getStorageDomainId()))) {
        getParameters().setStorageDomainId(diskImage.getstorage_ids().get(0));
        setStorageDomainId(diskImage.getstorage_ids().get(0));
    }
    if (!diskImage.getstorage_ids().contains(getParameters().getStorageDomainId())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STOARGE_DOMAIN_IS_WRONG);
    }
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    retValue = retValue && validator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages()) && validator.domainIsValidDestination(getReturnValue().getCanDoActionMessages());
    if (retValue && diskImage.getimageStatus() == ImageStatus.LOCKED) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED);
    }
    if (retValue) {
        if (disk.getVmEntityType() == VmEntityType.VM) {
            retValue = canRemoveVmImageDisk();
        } else if (disk.getVmEntityType() == VmEntityType.TEMPLATE) {
            retValue = canRemoveTemplateDisk();
        }
    }
    return retValue;
}
#method_after
private boolean canRemoveDiskBasedOnImageStorageCheck() {
    boolean retValue = true;
    DiskImage diskImage = (DiskImage) disk;
    if (diskImage.getVmEntityType() == VmEntityType.TEMPLATE) {
        // Temporary fix until re factoring vm_images_view and image_storage_domain_view
        diskImage.setstorage_ids(getDiskImageDao().get(diskImage.getImageId()).getstorage_ids());
    } else if ((getParameters().getStorageDomainId() == null) || (Guid.Empty.equals(getParameters().getStorageDomainId()))) {
        getParameters().setStorageDomainId(diskImage.getstorage_ids().get(0));
        setStorageDomainId(diskImage.getstorage_ids().get(0));
    }
    if (!diskImage.getstorage_ids().contains(getParameters().getStorageDomainId())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STOARGE_DOMAIN_IS_WRONG);
    }
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    retValue = retValue && validator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages()) && validator.domainIsValidDestination(getReturnValue().getCanDoActionMessages());
    if (retValue && diskImage.getimageStatus() == ImageStatus.LOCKED) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED);
    }
    if (retValue) {
        if (disk.getVmEntityType() == VmEntityType.VM) {
            retValue = canRemoveVmImageDisk();
        } else if (disk.getVmEntityType() == VmEntityType.TEMPLATE) {
            retValue = canRemoveTemplateDisk();
        }
    }
    return retValue;
}
#end_block

#method_before
protected boolean RemoveVmTemplateImages() {
    getParameters().setEntityId(getParameters().getEntityId());
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RemoveAllVmTemplateImageTemplates, getParameters(), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    if (!vdcReturnValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcReturnValue.getFault());
        return false;
    }
    getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
    return true;
}
#method_after
protected boolean RemoveVmTemplateImages() {
    getParameters().setEntityId(getParameters().getEntityId());
    getParameters().setParentCommand(getActionType());
    getParameters().setParentParemeters(getParameters());
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RemoveAllVmTemplateImageTemplates, getParameters(), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    if (!vdcReturnValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcReturnValue.getFault());
        return false;
    }
    getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
    return true;
}
#end_block

#method_before
protected Guid findImageForSameDrive(Guid snapshotId) {
    List<DiskImage> imagesFromSanpshot = getDiskImageDAO().getAllSnapshotsForVmSnapshot(snapshotId);
    for (DiskImage diskImage : imagesFromSanpshot) {
        if (getDiskImage().getId().equals(diskImage.getId())) {
            return diskImage.getImageId();
        }
    }
    return null;
}
#method_after
protected Guid findImageForSameDrive(Guid snapshotId) {
    List<DiskImage> imagesFromSanpshot = getDiskImageDao().getAllSnapshotsForVmSnapshot(snapshotId);
    for (DiskImage diskImage : imagesFromSanpshot) {
        if (getDiskImage().getId().equals(diskImage.getId())) {
            return diskImage.getImageId();
        }
    }
    return null;
}
#end_block

#method_before
private void initializeObjectState() {
    Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
    if (snapshot != null) {
        setSnapshotName(snapshot.getDescription());
    }
}
#method_after
private void initializeObjectState() {
    if (StringUtils.isEmpty(getSnapshotName())) {
        Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
        if (snapshot != null) {
            setSnapshotName(snapshot.getDescription());
        }
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<DiskImage> disks = DbFacade.getInstance().getDiskImageDao().getAllForQuotaId(getParameters().getQuotaId());
    for (DiskImage diskImage : disks) {
        diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getImageId(), diskImage.getit_guid()));
    }
    getQueryReturnValue().setReturnValue(disks);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<DiskImage> disks = getDbFacade().getDiskImageDao().getAllForQuotaId(getParameters().getQuotaId());
    for (DiskImage diskImage : disks) {
        diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getImageId(), diskImage.getit_guid()));
    }
    getQueryReturnValue().setReturnValue(disks);
}
#end_block

#method_before
private boolean canDoAction_beforeCloneVm(boolean retVal, List<String> canDoActionMessages, Map<Guid, storage_domains> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    retVal = checkStoragePool();
    if (retVal) {
        Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
        for (Guid destGuid : destGuids) {
            storage_domains storageDomain = getStorageDomain(destGuid);
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validator.isDomainExistAndActive(canDoActionMessages) || !validator.domainIsValidDestination(canDoActionMessages)) {
                retVal = false;
                break;
            } else {
                domainsMap.put(destGuid, storageDomain);
            }
        }
    }
    if (retVal && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
        retVal = false;
    }
    if (retVal) {
        SetSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        retVal = validator.isDomainExistAndActive(canDoActionMessages);
        if (retVal && getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        // Load images from Import/Export domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            List<VM> vms = (List<VM>) qretVal.getReturnValue();
            VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

                @Override
                public boolean eval(VM vm) {
                    return vm.getId().equals(getParameters().getVm().getId());
                }
            });
            if (vm != null) {
                // At this point we should work with the VM that was read from
                // the OVF
                setVm(vm);
                for (DiskImage image : getVm().getImages()) {
                    if (getParameters().getCopyCollapse()) {
                        for (DiskImage p : imageList) {
                            // only if requested by the user
                            if (p.getImageId().equals(image.getImageId())) {
                                if (p.getvolume_format() != null) {
                                    image.setvolume_format(p.getvolume_format());
                                }
                                if (p.getvolume_type() != null) {
                                    image.setvolume_type(p.getvolume_type());
                                }
                            }
                        }
                    }
                    retVal = ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(image.getId())).getStorageStaticData(), image, canDoActionMessages);
                    if (!retVal) {
                        break;
                    } else {
                        image.setstorage_pool_id(getParameters().getStoragePoolId());
                        // we put the source domain id in order that copy will
                        // work
                        // ok
                        // we fix it to DestDomainId in
                        // MoveOrCopyAllImageGroups();
                        image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
                    }
                }
                if (retVal) {
                    Map<Guid, List<DiskImage>> images = GetImagesLeaf(getVm().getImages());
                    for (Guid id : images.keySet()) {
                        List<DiskImage> list = images.get(id);
                        getVm().getDiskMap().put(id, list.get(list.size() - 1));
                    }
                }
            } else {
                retVal = false;
            }
        }
    }
    return retVal;
}
#method_after
private boolean canDoAction_beforeCloneVm(boolean retVal, List<String> canDoActionMessages, Map<Guid, storage_domains> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    retVal = checkStoragePool();
    if (retVal) {
        Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
        for (Guid destGuid : destGuids) {
            storage_domains storageDomain = getStorageDomain(destGuid);
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validator.isDomainExistAndActive(canDoActionMessages) || !validator.domainIsValidDestination(canDoActionMessages)) {
                retVal = false;
                break;
            } else {
                domainsMap.put(destGuid, storageDomain);
            }
        }
    }
    if (retVal && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
        retVal = false;
    }
    if (retVal) {
        SetSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        retVal = validator.isDomainExistAndActive(canDoActionMessages);
        if (retVal && getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        // Load images from Import/Export domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            List<VM> vms = (List<VM>) qretVal.getReturnValue();
            VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

                @Override
                public boolean eval(VM vm) {
                    return vm.getId().equals(getParameters().getVm().getId());
                }
            });
            if (vm != null) {
                // At this point we should work with the VM that was read from
                // the OVF
                setVm(vm);
                // Iterate over all the VM images (active image and snapshots)
                for (DiskImage image : getVm().getImages()) {
                    if (getParameters().getCopyCollapse()) {
                        // a match with the image from the VM.
                        for (DiskImage p : imageList) {
                            // only if requested by the user
                            if (p.getImageId().equals(image.getImageId())) {
                                if (p.getvolume_format() != null) {
                                    image.setvolume_format(p.getvolume_format());
                                }
                                if (p.getvolume_type() != null) {
                                    image.setvolume_type(p.getvolume_type());
                                }
                                // Validate the configuration of the image got from the parameters.
                                retVal = validateImageConfig(canDoActionMessages, domainsMap, image);
                                break;
                            }
                        }
                    } else {
                        // If no copy collapse sent, validate each image configuration (snapshot or active image).
                        retVal = validateImageConfig(canDoActionMessages, domainsMap, image);
                    }
                    if (!retVal) {
                        break;
                    } else {
                        image.setstorage_pool_id(getParameters().getStoragePoolId());
                        // we put the source domain id in order that copy will
                        // work
                        // ok
                        // we fix it to DestDomainId in
                        // MoveOrCopyAllImageGroups();
                        image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
                    }
                }
                if (retVal) {
                    Map<Guid, List<DiskImage>> images = GetImagesLeaf(getVm().getImages());
                    for (Guid id : images.keySet()) {
                        List<DiskImage> list = images.get(id);
                        getVm().getDiskMap().put(id, list.get(list.size() - 1));
                    }
                }
            } else {
                retVal = false;
            }
        }
    }
    return retVal;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    ExecuteVmCommand();
}
#method_after
@Override
protected void executeCommand() {
    executeVmCommand();
}
#end_block

#method_before
private DiskImage getDiskForVolumeInfo(DiskImage disk) {
    if (getParameters().getCopyCollapse()) {
        DiskImage ancestor = DbFacade.getInstance().getDiskImageDao().getAncestor(disk.getImageId());
        if (ancestor == null) {
            log.warnFormat("Can't find ancestor of Disk with ID {0}, using original disk for volume info.", disk.getImageId());
            ancestor = disk;
        }
        return ancestor;
    } else {
        return disk;
    }
}
#method_after
private DiskImage getDiskForVolumeInfo(DiskImage disk) {
    if (getParameters().getCopyCollapse()) {
        DiskImage ancestor = getDiskImageDao().getAncestor(disk.getImageId());
        if (ancestor == null) {
            log.warnFormat("Can't find ancestor of Disk with ID {0}, using original disk for volume info.", disk.getImageId());
            ancestor = disk;
        }
        return ancestor;
    } else {
        return disk;
    }
}
#end_block

#method_before
public String getDisplayHost() {
    StringBuffer ret = new StringBuffer(100);
    if (this.host == null) {
        ret.append("N/A");
    } else {
        if (this.user != null) {
            ret.append(this.user);
            ret.append("@");
        }
        ret.append(this.host);
        if (this.port != DEFAULT_SSH_PORT) {
            ret.append(":");
            ret.append(this.port);
        }
    }
    return ret.toString();
}
#method_after
public String getDisplayHost() {
    StringBuilder ret = new StringBuilder(100);
    if (this.host == null) {
        ret.append("N/A");
    } else {
        if (this.user != null) {
            ret.append(this.user);
            ret.append("@");
        }
        ret.append(this.host);
        if (this.port != DEFAULT_SSH_PORT) {
            ret.append(":");
            ret.append(this.port);
        }
    }
    return ret.toString();
}
#end_block

#method_before
protected boolean canAddVm(List<String> reasons, String name, Guid storagePoolId, int vmPriority) {
    boolean returnValue;
    // Checking if a desktop with same name already exists
    boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(name)).getReturnValue();
    if (exists) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST.toString());
        }
        return false;
    }
    boolean checkTemplateLock = getParameters().getParentCommand() == VdcActionType.AddVmPoolWithVms ? false : true;
    returnValue = verifyAddVM(reasons, storagePoolId, vmPriority);
    if (returnValue && !getParameters().getDontCheckTemplateImages()) {
        for (storage_domains storage : destStorages.values()) {
            if (!VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), storage.getId(), reasons, false, checkTemplateLock, true, true, storageToDisksMap.get(storage.getId()))) {
                return false;
            }
        }
    }
    return returnValue;
}
#method_after
protected boolean canAddVm(ArrayList<String> reasons, Collection<storage_domains> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    boolean returnValue = canAddVm(reasons, vmStaticFromParams.getvm_name(), getStoragePoolId().getValue(), vmStaticFromParams.getpriority());
    if (returnValue) {
        List<ValidationError> validationErrors = validateCustomProperties(vmStaticFromParams);
        if (!validationErrors.isEmpty()) {
            VmHandler.handleCustomPropertiesError(validationErrors, reasons);
            returnValue = false;
        }
    }
    // check that template image and vm are on the same storage pool
    if (returnValue && shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            returnValue = false;
        } else {
            for (storage_domains domain : destStorages) {
                if (!StorageDomainSpaceChecker.isBelowThresholds(domain)) {
                    returnValue = false;
                    reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.toString());
                    break;
                } else if (!StorageDomainSpaceChecker.hasSpaceForRequest(domain, getNeededDiskSize(domain.getId()))) {
                    returnValue = false;
                    reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.toString());
                    break;
                }
            }
        }
    }
    if (returnValue) {
        returnValue = isDedicatedVdsOnSameCluster(vmStaticFromParams);
    }
    return returnValue;
}
#end_block

#method_before
protected boolean CanDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors();
    returnValue = returnValue && CheckPCIAndIDELimit(getParameters().getVmStaticData().getnum_of_monitors(), getVmInterfaces(), getVmDisks(), getReturnValue().getCanDoActionMessages()) && CanAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean CanDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors();
    returnValue = returnValue && CheckPCIAndIDELimit(getParameters().getVmStaticData().getnum_of_monitors(), getVmInterfaces(), getVmDisks(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (CanAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                AddVmStatic();
                addVmDynamic();
                AddVmNetwork();
                AddVmStatistics();
                addActiveSnapshot();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        freeLock();
        addVmPermission();
        if (AddVmImages()) {
            copyVmDevices();
            addDiskPermissions(newDiskImages);
            addVmPayload();
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void ExecuteVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                AddVmStatic();
                addVmDynamic();
                AddVmNetwork();
                AddVmStatistics();
                addActiveSnapshot();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        freeLock();
        addVmPermission();
        if (AddVmImages()) {
            copyVmDevices();
            addDiskPermissions(newDiskImages);
            addVmPayload();
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
protected String InitInitialCommand(VDS vds, String initialCommand) {
    initialCommand = initialCommand.replace("{vdsInstaller}", _remoteBootstrapRunningScriptPath);
    initialCommand = initialCommand.replace("{vds-server}", vds.gethost_name());
    initialCommand = initialCommand.replace("{URL1}", Config.<String>GetValue(ConfigValues.VdcBootStrapUrl));
    initialCommand = initialCommand.replace("{GUID}", _fileGuid.toString());
    initialCommand = initialCommand.replace("{server_SSL_enabled}", Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers).toString());
    initialCommand = initialCommand.replace("{OrganizationName}", HandleOrganizationNameString(Config.<String>GetValue(ConfigValues.OrganizationName)));
    DateTime utcNow = DateTime.getUtcNow();
    serverInstallationTime = utcNow.toString("yyyy-MM-ddTHH:mm:ss");
    initialCommand = initialCommand.replace("{utc_time}", serverInstallationTime);
    initialCommand = initialCommand.replace("{management_port}", (Integer.toString(vds.getport())));
    String publicUrlPort = Config.<String>GetValue(ConfigValues.PublicURLPort);
    if (StringHelper.isNullOrEmpty(publicUrlPort)) {
        initialCommand = initialCommand.replace("{EnginePort}", "");
    } else {
        initialCommand = initialCommand.replace("{EnginePort}", String.format("-p %1$s", publicUrlPort));
    }
    initialCommand = initialCommand.replace("{OverrideFirewall}", isOverrideFirewallAllowed() ? "-f " + remoteFwRulesFilePath : "");
    return initialCommand;
}
#method_after
protected String InitInitialCommand(VDS vds, String initialCommand) {
    initialCommand = initialCommand.replace("{vds-server}", vds.gethost_name());
    initialCommand = initialCommand.replace("{URL1}", Config.<String>GetValue(ConfigValues.VdcBootStrapUrl));
    initialCommand = initialCommand.replace("{GUID}", _fileGuid.toString());
    initialCommand = initialCommand.replace("{server_SSL_enabled}", Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers).toString());
    initialCommand = initialCommand.replace("{OrganizationName}", HandleOrganizationNameString(Config.<String>GetValue(ConfigValues.OrganizationName)));
    initialCommand = initialCommand.replace("{management_port}", (Integer.toString(vds.getport())));
    String publicUrlPort = Config.<String>GetValue(ConfigValues.PublicURLPort);
    if (StringUtils.isEmpty(publicUrlPort)) {
        initialCommand = initialCommand.replace("{EnginePort}", "");
    } else {
        initialCommand = initialCommand.replace("{EnginePort}", String.format("-p %1$s", publicUrlPort));
    }
    initialCommand = initialCommand.replace("{SSHKey}", _remoteSSHKey);
    initialCommand = initialCommand.replace("{OverrideFirewall}", isOverrideFirewallAllowed() ? "-f " + remoteFwRulesFilePath : "");
    return initialCommand;
}
#end_block

#method_before
protected void RunStage() {
    if (this.getClass() == VdsInstaller.class) {
        log.infoFormat("Installation of {0}. Executing installation stage. (Stage: {1})", _serverName, getCurrentInstallStage());
    }
    switch(_currentInstallStage) {
        case Start:
            {
                _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                _executionSucceded = true;
                break;
            }
        case ConnectToServer:
            {
                _executionSucceded = _wrapper.connect(_serverName, _rootPassword);
                break;
            }
        case CheckUniqueVds:
            {
                _wrapper.executeCommand(Config.<String>GetValue(ConfigValues.BootstrapNodeIDCommand));
                break;
            }
        case UploadScript:
            {
                String path = Config.resolveBootstrapInstallerPath();
                _executionSucceded = _wrapper.sendFile(path, _remoteBootstrapRunningScriptPath);
                if (isOverrideFirewallAllowed() && _executionSucceded) {
                    _currentInstallStage = VdsInstallStages.UploadScript;
                    _executionSucceded = uploadFirewallRulesConfFile(getIpTableConfig());
                }
                break;
            }
        case RunScript:
            {
                log.infoFormat("Installation of {0}. Sending SSH Command {1}. (Stage: {2})", _serverName, _bootStrapInitialCommand, getCurrentInstallStage());
                Boolean fRes = _wrapper.executeCommand(_bootStrapInitialCommand);
                log.infoFormat(" RunScript ended:" + fRes.toString());
                break;
            }
        case DownloadCertificateRequest:
            {
                // First parameter will always run on Linux, so use path.combine
                // just for the second param.
                Boolean fRes = _wrapper.receiveFile(_remoteDirectory + "/" + _certRequestFileName, buildCAPath(_requestsDirectory, _certRequestFileName));
                log.infoFormat(" DownloadCertificateRequest ended:" + fRes.toString());
                break;
            }
        case SignCertificateRequest:
            {
                _executionSucceded = _caWrapper.SignCertificateRequest(_certRequestFileName, Config.<Integer>GetValue(ConfigValues.VdsCertificateValidityInYears) * 365, _certFileNameLocal);
                log.infoFormat(" SignCertificateRequest ended:" + _executionSucceded);
                if (_executionSucceded) {
                    String currRequest = buildCAPath(_requestsDirectory, _certRequestFileName);
                    try {
                        FileUtil.deleteFile(currRequest);
                    } catch (RuntimeException exp) {
                        log.errorFormat("Installation of {0}. Could not delete certificate request file from: {1}. error: {2}. (Stage: {3}", _serverName, currRequest, exp.getMessage(), getCurrentInstallStage());
                    }
                    _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                } else {
                    log.error("Error signing certificate request");
                }
                break;
            }
        case UploadSignedCertificate:
            {
                // Second parameter will always run on Linux, so use
                // path.combine just for the first param.
                Boolean fRes = _wrapper.sendFile(buildCAPath(_certificatesDirectory, _certFileNameLocal), _remoteDirectory + "/" + _certFileName);
                log.infoFormat(" UploadSignedCertificate ended:" + fRes.toString());
                break;
            }
        case UploadCA:
            {
                String path = String.format("%1$s/%2$s", _remoteDirectory, _caFileName);
                _wrapper.sendFile(Config.resolveCACertificatePath(), path);
                break;
            }
        case FinishCommand:
            {
                log.infoFormat("Installation of {0}. Sending SSH Command {1}. (Stage: {2})", _serverName, _finishCommand, getCurrentInstallStage());
                Boolean fRes = _wrapper.executeCommand(_finishCommand);
                log.infoFormat(" FinishCommand ended:" + fRes.toString());
                break;
            }
    }
}
#method_after
protected void RunStage() {
    if (this.getClass() == VdsInstaller.class) {
        log.infoFormat("Installation of {0}. Executing installation stage. (Stage: {1})", _serverName, getCurrentInstallStage());
    }
    switch(_currentInstallStage) {
        case Start:
            {
                _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                _executionSucceded = true;
                break;
            }
        case ConnectToServer:
            {
                _executionSucceded = _wrapper.connect(_serverName, _rootPassword);
                break;
            }
        case CheckUniqueVds:
            {
                _wrapper.executeCommand(Config.<String>GetValue(ConfigValues.BootstrapNodeIDCommand));
                break;
            }
        case UploadScript:
            {
                String thumbprint = VdsInstallerSSH.getEngineSSHKeyFingerprint();
                if (thumbprint == null) {
                    _executionSucceded = false;
                } else {
                    _executionSucceded = uploadStringAsFile(thumbprint, _remoteSSHKey);
                }
                if (_executionSucceded && isOverrideFirewallAllowed()) {
                    String ipTablesConfig = getIpTableConfig();
                    if (StringUtils.isNotEmpty(ipTablesConfig)) {
                        _executionSucceded = uploadStringAsFile(ipTablesConfig, remoteFwRulesFilePath);
                    }
                }
                if (_executionSucceded) {
                    _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                }
                break;
            }
        case RunScript:
            {
                runBootstrapCommand(false);
                break;
            }
        case DownloadCertificateRequest:
            {
                // First parameter will always run on Linux, so use path.combine
                // just for the second param.
                Boolean fRes = _wrapper.receiveFile(_remoteDirectory + "/" + _certRequestFileName, buildCAPath(_requestsDirectory, _certRequestFileName));
                log.infoFormat(" DownloadCertificateRequest ended:" + fRes.toString());
                break;
            }
        case SignCertificateRequest:
            {
                _executionSucceded = _caWrapper.SignCertificateRequest(_certRequestFileName, Config.<Integer>GetValue(ConfigValues.VdsCertificateValidityInYears) * 365, _certFileNameLocal);
                log.infoFormat(" SignCertificateRequest ended:" + _executionSucceded);
                if (_executionSucceded) {
                    String currRequest = buildCAPath(_requestsDirectory, _certRequestFileName);
                    try {
                        FileUtil.deleteFile(currRequest);
                    } catch (RuntimeException exp) {
                        log.errorFormat("Installation of {0}. Could not delete certificate request file from: {1}. error: {2}. (Stage: {3}", _serverName, currRequest, exp.getMessage(), getCurrentInstallStage());
                    }
                    _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                } else {
                    log.error("Error signing certificate request");
                }
                break;
            }
        case UploadSignedCertificate:
            {
                // Second parameter will always run on Linux, so use
                // path.combine just for the first param.
                Boolean fRes = _wrapper.sendFile(buildCAPath(_certificatesDirectory, _certFileNameLocal), _remoteDirectory + "/" + _certFileName);
                log.infoFormat(" UploadSignedCertificate ended:" + fRes.toString());
                break;
            }
        case UploadCA:
            {
                String path = String.format("%1$s/%2$s", _remoteDirectory, _caFileName);
                _wrapper.sendFile(Config.resolveCACertificatePath(), path);
                break;
            }
        case FinishCommand:
            {
                runBootstrapCommand(true);
                break;
            }
    }
}
#end_block

#method_before
private String getIpTableConfig() {
    String ipTableConfig = Config.<String>GetValue(ConfigValues.IPTablesConfig);
    if (supportGluster) {
        int i = 0;
        String glusterIpTableConfig = Config.<String>GetValue(ConfigValues.GlusterIPTablesConfig);
        if (glusterIpTableConfig == null) {
            glusterIpTableConfig = "";
        }
        String[] ipTables = ipTableConfig.split("\n");
        while (i < ipTables.length) {
            if (ipTables[i].toLowerCase().indexOf("reject") >= 0) {
                ipTableConfig = StringUtils.join(ipTables, "\n", 0, i) + "\n" + glusterIpTableConfig + "\n" + StringUtils.join(ipTables, "\n", i, ipTables.length - 1);
                break;
            }
            i++;
        }
    }
    return ipTableConfig;
}
#method_after
private String getIpTableConfig() {
    String ipTablesConfig = Config.<String>GetValue(ConfigValues.IPTablesConfig);
    String serviceIPTablesConfig = "";
    if (supportVirt) {
        serviceIPTablesConfig += Config.<String>GetValue(ConfigValues.IPTablesConfigForVirt);
    }
    if (supportGluster) {
        serviceIPTablesConfig += Config.<String>GetValue(ConfigValues.IPTablesConfigForGluster);
    }
    ipTablesConfig.replace(IP_TABLE_CUSTOM_RULES_PLACE_HOLDER, serviceIPTablesConfig);
    return ipTablesConfig;
}
#end_block

#method_before
@Override
public void endTransfer() {
    if (_currentInstallStage == VdsInstallStages.UploadScript || _currentInstallStage == VdsInstallStages.DownloadCertificateRequest || _currentInstallStage == VdsInstallStages.UploadSignedCertificate || _currentInstallStage == VdsInstallStages.UploadCA) {
        log.infoFormat("Installation of {0}. successfully done sftp operation ( Stage: {1})", _serverName, _translatedMessages.get(_currentInstallStage));
        _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
        _executionSucceded = true;
    } else if (_currentInstallStage != VdsInstallStages.Error) {
        log.warnFormat("Installation of {0}. Illegal stage for sftp operation. (Stage: {1})", _serverName, getCurrentInstallStage());
        _currentInstallStage = VdsInstallStages.Error;
    }
}
#method_after
@Override
public void endTransfer() {
    if (// iso upload
    _currentInstallStage == VdsInstallStages.UploadScript || _currentInstallStage == VdsInstallStages.DownloadCertificateRequest || _currentInstallStage == VdsInstallStages.UploadSignedCertificate || _currentInstallStage == VdsInstallStages.UploadCA) {
        log.infoFormat("Installation of {0}. successfully done sftp operation ( Stage: {1})", _serverName, _translatedMessages.get(_currentInstallStage));
        _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
        _executionSucceded = true;
    } else if (_currentInstallStage != VdsInstallStages.Error) {
        log.warnFormat("Installation of {0}. Illegal stage for sftp operation. (Stage: {1})", _serverName, getCurrentInstallStage());
        _currentInstallStage = VdsInstallStages.Error;
    }
}
#end_block

#method_before
private void setNonOperational(NonOperationalReason reason) {
    SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(getVds().getId(), reason);
    tempVar.setSaveToDb(true);
    Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar);
}
#method_after
private void setNonOperational(NonOperationalReason reason) {
    SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(getVds().getId(), reason);
    tempVar.setSaveToDb(true);
    Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar, ExecutionHandler.createInternalJobContext());
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    if (!getVdsGroup().supportsVirtService()) {
        return type;
    }
    if (!_connectStorageSucceeded) {
        type = AuditLogType.CONNECT_STORAGE_SERVERS_FAILED;
    } else if (!_connectPoolSucceeded) {
        type = AuditLogType.CONNECT_STORAGE_POOL_FAILED;
    } else if (getVds().getpm_enabled() && _fencingSucceeded) {
        type = AuditLogType.VDS_FENCE_STATUS;
    } else if (getVds().getpm_enabled() && !_fencingSucceeded) {
        type = AuditLogType.VDS_FENCE_STATUS_FAILED;
    }
    // PM alerts
    AuditLogableBase logable = new AuditLogableBase(getVds().getId());
    if (getVds().getpm_enabled()) {
        if (!_vdsProxyFound) {
            logable.AddCustomValue("Reason", AuditLogDirector.GetMessage(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST));
            AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_TEST_FAILED);
        } else if (!_fenceStatusReturnValue.getIsSucceeded()) {
            logable.AddCustomValue("Reason", _fenceStatusReturnValue.getMessage());
            AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_TEST_FAILED);
        }
    } else {
        AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED);
    }
    return type;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    if (!getVdsGroup().supportsVirtService()) {
        if (getVdsGroup().supportsGlusterService()) {
            if (!_glusterPeerListSucceeded) {
                type = AuditLogType.GLUSTER_SERVERS_LIST_FAILED;
            } else if (!_glusterPeerProbeSucceeded) {
                type = AuditLogType.GLUSTER_HOST_ADD_FAILED;
            }
        }
        return type;
    }
    if (!_connectStorageSucceeded) {
        type = AuditLogType.CONNECT_STORAGE_SERVERS_FAILED;
    } else if (!_connectPoolSucceeded) {
        type = AuditLogType.CONNECT_STORAGE_POOL_FAILED;
    } else if (getVds().getpm_enabled() && _fencingSucceeded) {
        type = AuditLogType.VDS_FENCE_STATUS;
    } else if (getVds().getpm_enabled() && !_fencingSucceeded) {
        type = AuditLogType.VDS_FENCE_STATUS_FAILED;
    }
    // PM alerts
    AuditLogableBase logable = new AuditLogableBase(getVds().getId());
    if (getVds().getpm_enabled()) {
        if (!_vdsProxyFound) {
            logable.AddCustomValue("Reason", AuditLogDirector.GetMessage(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST));
            AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_TEST_FAILED);
        } else if (!_fenceStatusReturnValue.getIsSucceeded()) {
            logable.AddCustomValue("Reason", _fenceStatusReturnValue.getMessage());
            AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_TEST_FAILED);
        }
    } else {
        AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED);
    }
    return type;
}
#end_block

#method_before
private void initGlusterPeerProcess() {
    List<VDS> vdsList = DbFacade.getInstance().getVdsDAO().getAllForVdsGroup(getVdsGroupId());
    // If the cluster already having Gluster servers, get an up server
    if (vdsList != null && vdsList.size() > 1) {
        VDS upServer = null;
        for (int i = 0; i < vdsList.size(); i++) {
            if (!Guid.OpEquality(getVdsId(), vdsList.get(i).getId()) && vdsList.get(i).getstatus() == VDSStatus.Up) {
                upServer = vdsList.get(i);
                break;
            }
        }
        // If new server is not part of the existing gluster peers, add into peer group
        if (upServer != null) {
            if (!hostExists(getGlusterPeers(upServer.getId()), upServer.getId())) {
                String newServerName = getVds().gethost_name().isEmpty() ? getVds().getManagmentIp() : getVds().gethost_name();
                glusterPeerProbe(upServer.getId(), newServerName);
            }
        }
    }
}
#method_after
private void initGlusterPeerProcess() {
    _glusterPeerListSucceeded = true;
    _glusterPeerProbeSucceeded = true;
    List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
    // If the cluster already having Gluster servers, get an up server
    if (vdsList != null && vdsList.size() > 0) {
        VDS upServer = null;
        for (VDS vds : vdsList) {
            if (!getVdsId().equals(vds.getId())) {
                upServer = vds;
                break;
            }
        }
        // If new server is not part of the existing gluster peers, add into peer group
        if (upServer != null) {
            List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
            if (glusterServers.size() == 0) {
                setNonOperational(NonOperationalReason.GLUSTER_PEER_LIST_FAILED);
            } else if (!hostExists(glusterServers, getVds())) {
                if (!glusterPeerProbe(upServer.getId(), getVds().gethost_name())) {
                    setNonOperational(NonOperationalReason.GLUSTER_PEER_PROBE_FAILED);
                }
            }
        }
    }
}
#end_block

#method_before
private boolean hostExists(List<VDS> glusterServers, Guid serverId) {
    for (VDS vds : glusterServers) {
        if (vds.getId().equals(serverId)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean hostExists(List<GlusterServerInfo> glusterServers, VDS server) {
    for (GlusterServerInfo glusterServer : glusterServers) {
        if (glusterServer.getHostnameOrIp().equals(server.gethost_name())) {
            return true;
        }
        for (VdsNetworkInterface vdsNwInterface : getVdsInterfaces(server.getId())) {
            if (glusterServer.getHostnameOrIp().equals(vdsNwInterface.getAddress())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
private List<VDS> getGlusterPeers(Guid upServerId) {
    List<VDS> glusterServers = new ArrayList<VDS>();
    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GlusterHostsList, new VdsIdVDSCommandParametersBase(upServerId));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        glusterServers = (List<VDS>) returnValue.getReturnValue();
    } else {
        getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
        getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
        AuditLogDirector.log(new AuditLogableBase(upServerId), AuditLogType.GLUSTER_HOST_LIST_FAILED);
    }
    return glusterServers;
}
#method_after
@SuppressWarnings("unchecked")
private List<GlusterServerInfo> getGlusterPeers(Guid upServerId) {
    List<GlusterServerInfo> glusterServers = new ArrayList<GlusterServerInfo>();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(upServerId));
    if (!returnValue.getSucceeded()) {
        getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
        getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
        AuditLogDirector.log(new AuditLogableBase(upServerId), AuditLogType.GLUSTER_SERVERS_LIST_FAILED);
        _glusterPeerListSucceeded = false;
    } else {
        glusterServers = (List<GlusterServerInfo>) returnValue.getReturnValue();
    }
    return glusterServers;
}
#end_block

#method_before
private void glusterPeerProbe(Guid upServerId, String newServerName) {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostAdd, new GlusterHostAddVDSParameters(upServerId, newServerName));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
        getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
        AuditLogDirector.log(new AuditLogableBase(upServerId), AuditLogType.GLUSTER_HOST_ADD_FAILED);
        return;
    }
}
#method_after
private boolean glusterPeerProbe(Guid upServerId, String newServerName) {
    try {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostAdd, new GlusterHostAddVDSParameters(upServerId, newServerName));
        if (!returnValue.getSucceeded()) {
            getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
            getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.GLUSTER_HOST_ADD_FAILED);
            _glusterPeerProbeSucceeded = false;
        }
        return returnValue.getSucceeded();
    } catch (Exception e) {
        log.errorFormat("Could not peer probe the gluster server {0}. Error: {1}", getVds().gethost_name(), e.getMessage());
        _glusterPeerProbeSucceeded = false;
        return false;
    }
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParams(final VdsStatic vds) {
    return getCustomMapSqlParameterSource().addValue("host_name", vds.gethost_name()).addValue("ip", vds.getManagmentIp()).addValue("vds_unique_id", vds.getUniqueID()).addValue("port", vds.getport()).addValue("vds_group_id", vds.getvds_group_id()).addValue("vds_id", vds.getId()).addValue("vds_name", vds.getvds_name()).addValue("server_SSL_enabled", vds.getserver_SSL_enabled()).addValue("vds_type", vds.getvds_type()).addValue("vds_strength", vds.getvds_strength()).addValue("pm_type", vds.getpm_type()).addValue("pm_user", vds.getpm_user()).addValue("pm_password", encryptPassword(vds.getpm_password())).addValue("pm_port", vds.getpm_port()).addValue("pm_options", vds.getpm_options()).addValue("pm_enabled", vds.getpm_enabled()).addValue("otp_validity", vds.getOtpValidity()).addValue("vds_spm_priority", vds.getVdsSpmPriority()).addValue("fingerprint", vds.getFingerprint());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParams(final VdsStatic vds) {
    return getCustomMapSqlParameterSource().addValue("host_name", vds.gethost_name()).addValue("ip", vds.getManagmentIp()).addValue("vds_unique_id", vds.getUniqueID()).addValue("port", vds.getport()).addValue("vds_group_id", vds.getvds_group_id()).addValue("vds_id", vds.getId()).addValue("vds_name", vds.getvds_name()).addValue("server_SSL_enabled", vds.getserver_SSL_enabled()).addValue("vds_type", vds.getvds_type()).addValue("vds_strength", vds.getvds_strength()).addValue("pm_type", vds.getpm_type()).addValue("pm_user", vds.getpm_user()).addValue("pm_password", encryptPassword(vds.getpm_password())).addValue("pm_port", vds.getpm_port()).addValue("pm_options", vds.getpm_options()).addValue("pm_enabled", vds.getpm_enabled()).addValue("otp_validity", vds.getOtpValidity()).addValue("vds_spm_priority", vds.getVdsSpmPriority()).addValue("sshKeyFingerprint", vds.getSSHKeyFingerprint());
}
#end_block

#method_before
public static String encryptPassword(String password) {
    if (StringUtils.isEmpty(password)) {
        return password;
    }
    String keyFile = Config.resolveKeyStorePath();
    String passwd = Config.<String>GetValue(ConfigValues.keystorePass, Config.DefaultConfigurationVersion);
    String alias = Config.<String>GetValue(ConfigValues.CertAlias, Config.DefaultConfigurationVersion);
    try {
        return EncryptionUtils.encrypt((String) password, keyFile, passwd, alias);
    } catch (Exception e) {
        throw new SecurityException(e);
    }
}
#method_after
public static String encryptPassword(String password) {
    if (StringUtils.isEmpty(password)) {
        return password;
    }
    String keyFile = Config.resolveKeyStorePath();
    String passwd = Config.<String>GetValue(ConfigValues.keystorePass, Config.DefaultConfigurationVersion);
    String alias = Config.<String>GetValue(ConfigValues.CertAlias, Config.DefaultConfigurationVersion);
    try {
        return EncryptionUtils.encrypt(password, keyFile, passwd, alias);
    } catch (Exception e) {
        throw new SecurityException(e);
    }
}
#end_block

#method_before
public static String decryptPassword(String password) {
    if (StringUtils.isEmpty(password)) {
        return password;
    }
    String keyFile = Config.resolveKeyStorePath();
    String passwd = Config.<String>GetValue(ConfigValues.keystorePass, Config.DefaultConfigurationVersion);
    String alias = Config.<String>GetValue(ConfigValues.CertAlias, Config.DefaultConfigurationVersion);
    try {
        return EncryptionUtils.decrypt((String) password, keyFile, passwd, alias);
    } catch (Exception e) {
        log.debugFormat("Failed to decrypt password, error message: {0}", e.getMessage());
        return password;
    }
}
#method_after
public static String decryptPassword(String password) {
    if (StringUtils.isEmpty(password)) {
        return password;
    }
    String keyFile = Config.resolveKeyStorePath();
    String passwd = Config.<String>GetValue(ConfigValues.keystorePass, Config.DefaultConfigurationVersion);
    String alias = Config.<String>GetValue(ConfigValues.CertAlias, Config.DefaultConfigurationVersion);
    try {
        return EncryptionUtils.decrypt(password, keyFile, passwd, alias);
    } catch (Exception e) {
        log.debugFormat("Failed to decrypt password, error message: {0}", e.getMessage());
        return password;
    }
}
#end_block

#method_before
@Override
public VdsStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VdsStatic entity = new VdsStatic();
    entity.sethost_name(rs.getString("host_name"));
    entity.setManagmentIp(rs.getString("ip"));
    entity.setUniqueID(rs.getString("vds_unique_id"));
    entity.setport(rs.getInt("port"));
    entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setId(Guid.createGuidFromString(rs.getString("vds_id")));
    entity.setvds_name(rs.getString("vds_name"));
    entity.setserver_SSL_enabled(rs.getBoolean("server_SSL_enabled"));
    entity.setvds_type(VDSType.forValue(rs.getInt("vds_type")));
    entity.setvds_strength(rs.getInt("vds_strength"));
    entity.setpm_type(rs.getString("pm_type"));
    entity.setpm_user(rs.getString("pm_user"));
    entity.setpm_password(decryptPassword(rs.getString("pm_password")));
    entity.setpm_port((Integer) rs.getObject("pm_port"));
    entity.setpm_options(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setFingerprint(rs.getString("fingerprint"));
    return entity;
}
#method_after
@Override
public VdsStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VdsStatic entity = new VdsStatic();
    entity.sethost_name(rs.getString("host_name"));
    entity.setManagmentIp(rs.getString("ip"));
    entity.setUniqueID(rs.getString("vds_unique_id"));
    entity.setport(rs.getInt("port"));
    entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setId(Guid.createGuidFromString(rs.getString("vds_id")));
    entity.setvds_name(rs.getString("vds_name"));
    entity.setserver_SSL_enabled(rs.getBoolean("server_SSL_enabled"));
    entity.setvds_type(VDSType.forValue(rs.getInt("vds_type")));
    entity.setvds_strength(rs.getInt("vds_strength"));
    entity.setpm_type(rs.getString("pm_type"));
    entity.setpm_user(rs.getString("pm_user"));
    entity.setpm_password(decryptPassword(rs.getString("pm_password")));
    entity.setpm_port((Integer) rs.getObject("pm_port"));
    entity.setpm_options(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setSSHKeyFingerprint(rs.getString("sshKeyFingerprint"));
    return entity;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    VdsStatic other = (VdsStatic) obj;
    if (hostname == null) {
        if (other.hostname != null)
            return false;
    } else if (!hostname.equals(other.hostname))
        return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (ip == null) {
        if (other.ip != null)
            return false;
    } else if (!ip.equals(other.ip))
        return false;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    if (otpValidity != other.otpValidity)
        return false;
    if (pmEnabled != other.pmEnabled)
        return false;
    if (pmOptions == null) {
        if (other.pmOptions != null)
            return false;
    } else if (!pmOptions.equals(other.pmOptions))
        return false;
    if (pmOptionsMap == null) {
        if (other.pmOptionsMap != null)
            return false;
    } else if (!pmOptionsMap.equals(other.pmOptionsMap))
        return false;
    if (pmPassword == null) {
        if (other.pmPassword != null)
            return false;
    } else if (!pmPassword.equals(other.pmPassword))
        return false;
    if (pmPort == null) {
        if (other.pmPort != null)
            return false;
    } else if (!pmPort.equals(other.pmPort))
        return false;
    if (pmType == null) {
        if (other.pmType != null)
            return false;
    } else if (!pmType.equals(other.pmType))
        return false;
    if (pmUser == null) {
        if (other.pmUser != null)
            return false;
    } else if (!pmUser.equals(other.pmUser))
        return false;
    if (port != other.port)
        return false;
    if (serverSslEnabled == null) {
        if (other.serverSslEnabled != null)
            return false;
    } else if (!serverSslEnabled.equals(other.serverSslEnabled))
        return false;
    if (uniqueId == null) {
        if (other.uniqueId != null)
            return false;
    } else if (!uniqueId.equals(other.uniqueId))
        return false;
    if (vdsGroupId == null) {
        if (other.vdsGroupId != null)
            return false;
    } else if (!vdsGroupId.equals(other.vdsGroupId))
        return false;
    if (vdsStrength == null) {
        if (other.vdsStrength != null)
            return false;
    } else if (!vdsStrength.equals(other.vdsStrength))
        return false;
    if (vdsType != other.vdsType)
        return false;
    if (fingerprint == null) {
        if (other.fingerprint != null)
            return false;
    } else if (!fingerprint.equals(other.fingerprint))
        return false;
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    VdsStatic other = (VdsStatic) obj;
    if (hostname == null) {
        if (other.hostname != null)
            return false;
    } else if (!hostname.equals(other.hostname))
        return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (ip == null) {
        if (other.ip != null)
            return false;
    } else if (!ip.equals(other.ip))
        return false;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    if (otpValidity != other.otpValidity)
        return false;
    if (pmEnabled != other.pmEnabled)
        return false;
    if (pmOptions == null) {
        if (other.pmOptions != null)
            return false;
    } else if (!pmOptions.equals(other.pmOptions))
        return false;
    if (pmOptionsMap == null) {
        if (other.pmOptionsMap != null)
            return false;
    } else if (!pmOptionsMap.equals(other.pmOptionsMap))
        return false;
    if (pmPassword == null) {
        if (other.pmPassword != null)
            return false;
    } else if (!pmPassword.equals(other.pmPassword))
        return false;
    if (pmPort == null) {
        if (other.pmPort != null)
            return false;
    } else if (!pmPort.equals(other.pmPort))
        return false;
    if (pmType == null) {
        if (other.pmType != null)
            return false;
    } else if (!pmType.equals(other.pmType))
        return false;
    if (pmUser == null) {
        if (other.pmUser != null)
            return false;
    } else if (!pmUser.equals(other.pmUser))
        return false;
    if (port != other.port)
        return false;
    if (serverSslEnabled == null) {
        if (other.serverSslEnabled != null)
            return false;
    } else if (!serverSslEnabled.equals(other.serverSslEnabled))
        return false;
    if (uniqueId == null) {
        if (other.uniqueId != null)
            return false;
    } else if (!uniqueId.equals(other.uniqueId))
        return false;
    if (vdsGroupId == null) {
        if (other.vdsGroupId != null)
            return false;
    } else if (!vdsGroupId.equals(other.vdsGroupId))
        return false;
    if (vdsStrength == null) {
        if (other.vdsStrength != null)
            return false;
    } else if (!vdsStrength.equals(other.vdsStrength))
        return false;
    if (vdsType != other.vdsType)
        return false;
    if (sshKeyFingerprint == null) {
        if (other.sshKeyFingerprint != null)
            return false;
    } else if (!sshKeyFingerprint.equals(other.sshKeyFingerprint))
        return false;
    return true;
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = prepareDAO(dbFacade.getVdsStaticDAO());
    dynamicDao = prepareDAO(dbFacade.getVdsDynamicDAO());
    statisticsDao = prepareDAO(dbFacade.getVdsStatisticsDAO());
    existingVds = dao.get(EXISTING_VDS_ID);
    newStaticVds = new VdsStatic();
    newStaticVds.sethost_name("farkle.redhat.com");
    newStaticVds.setvds_group_id(existingVds.getvds_group_id());
    newStaticVds.setFingerprint("b5:ad:16:19:06:9f:b3:41:69:eb:1c:42:1d:12:b5:31");
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = prepareDAO(dbFacade.getVdsStaticDAO());
    dynamicDao = prepareDAO(dbFacade.getVdsDynamicDAO());
    statisticsDao = prepareDAO(dbFacade.getVdsStatisticsDAO());
    existingVds = dao.get(EXISTING_VDS_ID);
    newStaticVds = new VdsStatic();
    newStaticVds.sethost_name("farkle.redhat.com");
    newStaticVds.setvds_group_id(existingVds.getvds_group_id());
    newStaticVds.setSSHKeyFingerprint("b5:ad:16:19:06:9f:b3:41:69:eb:1c:42:1d:12:b5:31");
}
#end_block

#method_before
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    dao = prepareDAO(dbFacade.getAsyncTaskDAO());
    params = new VdcActionParametersBase();
    params.setSessionId("ASESSIONID");
    params.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    // create some test data
    newAsyncTask = new async_tasks();
    newAsyncTask.settask_id(Guid.NewGuid());
    newAsyncTask.setaction_type(VdcActionType.AddDisk);
    newAsyncTask.setstatus(AsyncTaskStatusEnum.running);
    newAsyncTask.setresult(AsyncTaskResultEnum.success);
    newAsyncTask.setaction_parameters(params);
    newAsyncTask.setCommandId(Guid.NewGuid());
    existingAsyncTask = dao.get(FixturesTool.EXISTING_TASK);
}
#method_after
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    dao = prepareDAO(dbFacade.getAsyncTaskDAO());
    params = new VdcActionParametersBase();
    params.setSessionId("ASESSIONID");
    params.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    // create some test data
    newAsyncTask = new async_tasks();
    newAsyncTask.settask_id(Guid.NewGuid());
    newAsyncTask.setaction_type(VdcActionType.AddDisk);
    newAsyncTask.setstatus(AsyncTaskStatusEnum.running);
    newAsyncTask.setresult(AsyncTaskResultEnum.success);
    newAsyncTask.setaction_parameters(params);
    newAsyncTask.setCommandId(Guid.NewGuid());
    existingAsyncTask = dao.get(FixturesTool.EXISTING_TASK_ID);
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        Snapshot snapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
        if (snapshot != null) {
            jobProperties.put(VdcObjectType.SnapshotName.name().toLowerCase(), snapshot.getDescription());
        }
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        Snapshot snapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
        if (snapshot != null) {
            jobProperties.put(VdcObjectType.Snapshot.name().toLowerCase(), snapshot.getDescription());
        }
    }
    return jobProperties;
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put(VdcObjectType.SnapshotName.name().toLowerCase(), getParameters().getDescription());
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put(VdcObjectType.Snapshot.name().toLowerCase(), getParameters().getDescription());
    }
    return jobProperties;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    List<DiskImage> disksList = getDisksList();
    if (disksList.size() > 0) {
        result = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && validate(vmNotDuringMigration()) && validate(vmNotRunningStateless()) && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, true, true, true, true, true, checkVmIsDown(), true, true, disksList);
    }
    if (!result) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CREATE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__SNAPSHOT);
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    List<DiskImage> disksList = getDisksList();
    if (disksList.size() > 0) {
        result = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && validate(vmNotDuringMigration()) && validate(vmNotRunningStateless()) && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, true, true, true, true, true, checkVmIsDown(), true, true, disksList);
    }
    return result;
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        initializeObjectState();
        jobProperties.put(VdcObjectType.SnapshotName.name().toLowerCase(), getSnapshotName());
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        initializeObjectState();
        jobProperties.put(VdcObjectType.Snapshot.name().toLowerCase(), getSnapshotName());
    }
    return jobProperties;
}
#end_block

#method_before
// TODO: this is a temporary method used until ImagesHandler.PerformImagesChecks will get decoupeld to several tests
// Until then, this method is called and passes hasImages() onwards so the VM validations are done even for diskless
protected boolean validateImagesAndVMStates() {
    return ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, hasImages(), hasImages(), hasImages(), hasImages(), true, true, true, true, null);
}
#method_after
// TODO: this is a temporary method used until ImagesHandler.PerformImagesChecks will get decoupeld to several tests
protected boolean validateImagesAndVMStates() {
    return ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, hasImages(), hasImages(), hasImages(), hasImages(), true, true, true, true, null);
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        Snapshot snapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
        if (snapshot != null) {
            jobProperties.put(VdcObjectType.SnapshotName.name().toLowerCase(), snapshot.getDescription());
        }
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        Snapshot snapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
        if (snapshot != null) {
            jobProperties.put(VdcObjectType.Snapshot.name().toLowerCase(), snapshot.getDescription());
        }
    }
    return jobProperties;
}
#end_block

#method_before
@Override
public void rollbackQuota() {
    for (DiskImage image : getImagesList()) {
        Guid quotaId = image.getQuotaId();
        if (quotaId != null) {
            // Uncache the details of this quota. next time the quota will be called, a new calculation
            // would be done base on the DB.
            QuotaManager.getInstance().rollbackQuota(getStoragePool(), Arrays.asList(quotaId));
        }
    }
}
#method_after
@Override
public void rollbackQuota() {
    if (getImagesList().isEmpty()) {
        return;
    }
    setStoragePoolId(getImagesList().get(0).getstorage_pool_id());
    for (DiskImage image : getImagesList()) {
        Guid quotaId = image.getQuotaId();
        if (quotaId != null) {
            // Uncache the details of this quota. next time the quota will be called, a new calculation
            // would be done base on the DB.
            QuotaManager.getInstance().rollbackQuota(getStoragePool(), Arrays.asList(quotaId));
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // get vm status from db to check its really down before locking
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(getVmId());
    if (vmDynamic.getstatus() != VMStatus.Down) {
        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
    }
    VmHandler.LockVm(vmDynamic, getCompensationContext());
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.NewGuid());
    getParameters().setVmTemplateID(getVmTemplateId());
    getParameters().setEntityId(getVmTemplateId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            AddVmTemplateImages();
            List<VmNetworkInterface> vmInterfaces = addVmInterfaces();
            VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), newDiskImages, vmInterfaces);
            setSucceeded(true);
            return null;
        }
    });
    // end the command synchronously
    if (getReturnValue().getTaskIdList().isEmpty()) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // get vm status from db to check its really down before locking
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(getVmId());
    if (vmDynamic.getstatus() != VMStatus.Down) {
        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
    }
    VmHandler.LockVm(vmDynamic, getCompensationContext());
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.NewGuid());
    getParameters().setVmTemplateID(getVmTemplateId());
    getParameters().setEntityId(getVmTemplateId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            AddVmTemplateImages();
            List<VmNetworkInterface> vmInterfaces = addVmInterfaces();
            VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), newDiskImages, vmInterfaces);
            setSucceeded(true);
            return null;
        }
    });
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null || !getVm().getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getos(), getParameters().getMasterVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (getVm().getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_DUPLICATE_NAME);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getusb_policy(), getParameters().getVm().getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Map<Guid, List<DiskImage>> sourceImageDomainsImageMap = new HashMap<Guid, List<DiskImage>>();
    for (DiskImage image : mImages) {
        MultiValueMapUtils.addToMap(image.getstorage_ids().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            Guid destStorageId = getParameters().getDestinationStorageDomainId() != null ? getParameters().getDestinationStorageDomainId() : image.getstorage_ids().get(0);
            ArrayList<Guid> storageIds = new ArrayList<Guid>();
            storageIds.add(destStorageId);
            image.setstorage_ids(storageIds);
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
    for (Guid srcStorageDomainId : sourceImageDomainsImageMap.keySet()) {
        boolean checkIsValid = true;
        if (!ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), srcStorageDomainId, false, true, true, true, true, false, true, checkIsValid, sourceImageDomainsImageMap.get(srcStorageDomainId))) {
            return false;
        }
        checkIsValid = false;
    }
    Map<Guid, storage_domains> storageDomains = new HashMap<Guid, storage_domains>();
    Set<Guid> destImageDomains = getStorageGuidSet();
    destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
    for (Guid destImageDomain : destImageDomains) {
        storage_domains storage = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(destImageDomain, getVm().getstorage_pool_id());
        if (storage == null) {
            // domain is not in the same storage pool as the vm
            if (DbFacade.getInstance().getStorageDomainStaticDAO().get(destImageDomain) == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
            } else {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
            }
            return false;
        }
        if (storage.getstatus() == null || storage.getstatus() != StorageDomainStatus.Active) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
            return false;
        }
        if (storage.getstorage_domain_type() == StorageDomainType.ImportExport || storage.getstorage_domain_type() == StorageDomainType.ISO) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            return false;
        }
        storageDomains.put(destImageDomain, storage);
    }
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    Map<storage_domains, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(getVmTemplate().getDiskImageMap().values(), storageDomains, diskInfoDestinationMap);
    for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
        if (!StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
            return false;
        }
    }
    return AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null || !getVm().getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getos(), getParameters().getMasterVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (getVm().getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_DUPLICATE_NAME);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getusb_policy(), getParameters().getVm().getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Map<Guid, List<DiskImage>> sourceImageDomainsImageMap = new HashMap<Guid, List<DiskImage>>();
    for (DiskImage image : mImages) {
        MultiValueMapUtils.addToMap(image.getstorage_ids().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            Guid destStorageId = getParameters().getDestinationStorageDomainId() != null ? getParameters().getDestinationStorageDomainId() : image.getstorage_ids().get(0);
            ArrayList<Guid> storageIds = new ArrayList<Guid>();
            storageIds.add(destStorageId);
            image.setstorage_ids(storageIds);
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
    for (Guid srcStorageDomainId : sourceImageDomainsImageMap.keySet()) {
        boolean checkIsValid = true;
        if (!ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), srcStorageDomainId, false, true, true, true, true, false, true, checkIsValid, sourceImageDomainsImageMap.get(srcStorageDomainId))) {
            return false;
        }
        checkIsValid = false;
    }
    Map<Guid, storage_domains> storageDomains = new HashMap<Guid, storage_domains>();
    Set<Guid> destImageDomains = getStorageGuidSet();
    destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
    for (Guid destImageDomain : destImageDomains) {
        storage_domains storage = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(destImageDomain, getVm().getstorage_pool_id());
        if (storage == null) {
            // domain is not in the same storage pool as the vm
            if (DbFacade.getInstance().getStorageDomainStaticDAO().get(destImageDomain) == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
            } else {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
            }
            return false;
        }
        if (storage.getstatus() == null || storage.getstatus() != StorageDomainStatus.Active) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
            return false;
        }
        if (storage.getstorage_domain_type() == StorageDomainType.ImportExport || storage.getstorage_domain_type() == StorageDomainType.ISO) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            return false;
        }
        storageDomains.put(destImageDomain, storage);
    }
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    Map<storage_domains, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false), storageDomains, diskInfoDestinationMap);
    for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
        if (!StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
            return false;
        }
    }
    return AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().gethypervisor_type(), getParameters().getMasterVm().getoperation_mode()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    getVmTemplate().setQuotaId(getQuotaId());
    DbFacade.getInstance().getVmTemplateDAO().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#method_after
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().gethypervisor_type(), getParameters().getMasterVm().getoperation_mode()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    getVmTemplate().setQuotaId(getQuotaId());
    getVmTemplate().setdedicated_vm_for_vds(getParameters().getMasterVm().getdedicated_vm_for_vds());
    getVmTemplate().setMigrationSupport(getParameters().getMasterVm().getMigrationSupport());
    DbFacade.getInstance().getVmTemplateDAO().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#end_block

#method_before
@Override
protected void EndSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    endDefaultOperations();
    setSucceeded(true);
}
#method_after
@Override
protected void EndSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    setSucceeded(true);
}
#end_block

#method_before
protected void endSuccessfullySynchronous() {
    endDefaultOperations();
    setSucceeded(true);
}
#method_after
private void endSuccessfullySynchronous() {
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    setSucceeded(true);
}
#end_block

#method_before
private void endDefaultOperations() {
    endTemplateRelatedOperations();
    endUnlockRelatedOperations();
}
#method_after
private void endDefaultOperations() {
    endTemplateRelatedOperations();
    endUnlockOps();
}
#end_block

#method_before
@Override
protected void EndWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    rollbackQuota();
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        RemoveTemplateInSpm(getVmTemplate().getstorage_pool_id().getValue(), getVmTemplateId());
        DbFacade.getInstance().getVmTemplateDAO().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVmId());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void EndWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    rollbackQuota();
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        RemoveTemplateInSpm(getVmTemplate().getstorage_pool_id().getValue(), getVmTemplateId());
        DbFacade.getInstance().getVmTemplateDAO().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
private List<StorageQuotaValidationParameter> getStorageQuotaListParameters() {
    List<StorageQuotaValidationParameter> list = new ArrayList<StorageQuotaValidationParameter>();
    for (DiskImage diskImage : mImages) {
        DiskImage disk = diskInfoDestinationMap.get(diskImage.getId());
        list.add(new StorageQuotaValidationParameter(disk.getQuotaId() != null ? disk.getQuotaId() : getParameters().getMasterVm().getQuotaId(), disk.getstorage_ids().get(0), // TODO: not sure if this is good
        disk.getSizeInGigabytes()));
    }
    return list;
}
#method_after
private List<StorageQuotaValidationParameter> getStorageQuotaListParameters() {
    List<StorageQuotaValidationParameter> list = new ArrayList<StorageQuotaValidationParameter>();
    for (DiskImage disk : diskInfoDestinationMap.values()) {
        list.add(new StorageQuotaValidationParameter(disk.getQuotaId() != null ? disk.getQuotaId() : getParameters().getMasterVm().getQuotaId(), disk.getstorage_ids().get(0), // TODO: not sure if this is good
        disk.getSizeInGigabytes()));
    }
    return list;
}
#end_block

#method_before
@Override
public void Cluster_SelectedItemChanged() {
    updateQuotaByCluster(vm.getQuotaId());
}
#method_after
@Override
public void Cluster_SelectedItemChanged() {
    updateQuotaByCluster(null, null);
}
#end_block

#method_before
private void InitTemplate() {
    // Update model state according to VM properties.
    getModel().getMemSize().setEntity(this.vm.getvm_mem_size_mb());
    getModel().getOSType().setSelectedItem(this.vm.getvm_os());
    getModel().getDomain().setSelectedItem(this.vm.getvm_domain());
    getModel().getUsbPolicy().setSelectedItem(this.vm.getusb_policy());
    getModel().getNumOfMonitors().setSelectedItem(this.vm.getnum_of_monitors());
    getModel().getAllowConsoleReconnect().setEntity(this.vm.getAllowConsoleReconnect());
    getModel().setBootSequence(this.vm.getdefault_boot_sequence());
    getModel().getNumOfSockets().setEntity(this.vm.getnum_of_sockets());
    getModel().getTotalCPUCores().setEntity(this.vm.getnum_of_cpus());
    getModel().getIsStateless().setEntity(this.vm.getis_stateless());
    if (!StringHelper.isNullOrEmpty(this.vm.gettime_zone())) {
        getModel().getTimeZone().setSelectedItem(// $NON-NLS-1$
        new KeyValuePairCompat<String, String>(this.vm.gettime_zone(), ""));
        UpdateTimeZone();
    } else {
        UpdateDefaultTimeZone();
    }
    // Update domain list
    UpdateDomain();
    getModel().getStorageDomain().setIsChangable(true);
    getModel().getProvisioning().setIsAvailable(false);
    // Select display protocol.
    for (Object item : getModel().getDisplayProtocol().getItems()) {
        EntityModel model = (EntityModel) item;
        DisplayType displayType = (DisplayType) model.getEntity();
        if (displayType == this.vm.getdefault_display_type()) {
            getModel().getDisplayProtocol().setSelectedItem(item);
            break;
        }
    }
    InitPriority(this.vm.getpriority());
}
#method_after
private void InitTemplate() {
    // Update model state according to VM properties.
    getModel().getMemSize().setEntity(this.vm.getvm_mem_size_mb());
    getModel().getOSType().setSelectedItem(this.vm.getvm_os());
    getModel().getDomain().setSelectedItem(this.vm.getvm_domain());
    getModel().getUsbPolicy().setSelectedItem(this.vm.getusb_policy());
    getModel().getNumOfMonitors().setSelectedItem(this.vm.getnum_of_monitors());
    getModel().getAllowConsoleReconnect().setEntity(this.vm.getAllowConsoleReconnect());
    getModel().setBootSequence(this.vm.getdefault_boot_sequence());
    getModel().getTotalCPUCores().setEntity(Integer.toString(this.vm.getnum_of_cpus()));
    getModel().getNumOfSockets().setSelectedItem(this.vm.getnum_of_sockets());
    getModel().getIsStateless().setEntity(this.vm.getis_stateless());
    if (!StringHelper.isNullOrEmpty(this.vm.gettime_zone())) {
        getModel().getTimeZone().setSelectedItem(// $NON-NLS-1$
        new KeyValuePairCompat<String, String>(this.vm.gettime_zone(), ""));
        UpdateTimeZone();
    } else {
        UpdateDefaultTimeZone();
    }
    // Update domain list
    UpdateDomain();
    getModel().getStorageDomain().setIsChangable(true);
    getModel().getProvisioning().setIsAvailable(false);
    // Select display protocol.
    for (Object item : getModel().getDisplayProtocol().getItems()) {
        EntityModel model = (EntityModel) item;
        DisplayType displayType = (DisplayType) model.getEntity();
        if (displayType == this.vm.getdefault_display_type()) {
            getModel().getDisplayProtocol().setSelectedItem(item);
            break;
        }
    }
    InitPriority(this.vm.getpriority());
}
#end_block

#method_before
private void DisableNewTemplateModel(String errMessage) {
    getModel().setIsValid(false);
    getModel().setMessage(errMessage);
    getModel().getName().setIsChangable(false);
    getModel().getDescription().setIsChangable(false);
    getModel().getCluster().setIsChangable(false);
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getIsTemplatePublic().setIsChangable(false);
    getModel().getIsTemplatePrivate().setIsChangable(false);
    getModel().getDefaultCommand().setIsAvailable(false);
}
#method_after
private void DisableNewTemplateModel(String errMessage) {
    getModel().setIsValid(false);
    getModel().setMessage(errMessage);
    getModel().getName().setIsChangable(false);
    getModel().getDescription().setIsChangable(false);
    getModel().getCluster().setIsChangable(false);
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getIsTemplatePublic().setIsChangable(false);
    getModel().getDefaultCommand().setIsAvailable(false);
}
#end_block

#method_before
@Override
public ImageResource getValue(IVdcQueryable quota) {
    boolean quotaExceeded = false;
    if (quota instanceof QuotaStorage) {
        quotaExceeded = getQuotaExceeded((QuotaStorage) quota);
    } else if (quota instanceof QuotaVdsGroup) {
        quotaExceeded = getQuotaExceeded((QuotaVdsGroup) quota);
    } else {
        return null;
    }
    if (quotaExceeded) {
        // $NON-NLS-1$
        setTitle("Quota exceeded");
    }
    return quotaExceeded ? getResources().alertImage() : null;
}
#method_after
@Override
public ImageResource getValue(IVdcQueryable quota) {
    boolean quotaExceeded = false;
    if (quota instanceof QuotaStorage) {
        quotaExceeded = getQuotaExceeded((QuotaStorage) quota);
    } else if (quota instanceof QuotaVdsGroup) {
        quotaExceeded = getQuotaExceeded((QuotaVdsGroup) quota);
    } else {
        return null;
    }
    if (quotaExceeded) {
        setTitle(applicationConstants.quotaExceeded());
    }
    return quotaExceeded ? getResources().alertImage() : null;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    removeQuotaFromCache();
    setQuotaParameter();
    QuotaDAO dao = getQuotaDAO();
    dao.update(getParameters().getQuota());
    getReturnValue().setSucceeded(true);
    afterEdit();
}
#method_after
@Override
protected void executeCommand() {
    removeQuotaFromCache();
    setQuotaParameter();
    QuotaDAO dao = getQuotaDAO();
    dao.update(getParameters().getQuota());
    getReturnValue().setSucceeded(true);
    afterUpdate();
}
#end_block

#method_before
public boolean isGlusterPeerProbeNeeded() {
    return this.isGlusterPeerProbeNeeded;
}
#method_after
public boolean isGlusterPeerProbeNeeded() {
    return this.glusterPeerProbeNeeded;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // set vds spm id
    if (getVdsGroup().getstorage_pool_id() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef().getValue());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        CompensationContext compensationContext = getCompensationContext();
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, tempVar, new CommandContext(compensationContext));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            InitializeVds();
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process
    if (Config.<Boolean>GetValue(ConfigValues.InstallVds) && !getParameters().getAddPending()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getRootPassword());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getvds_name());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.InstallVds, installVdsParameters, new CommandContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    } else {
        // Also gluster peer probe is not needed when importing an existing gluster cluster
        if (getVdsGroup().supportsGlusterService() && getParameters().isGlusterPeerProbeNeeded() && getAllVds(getVdsGroupId()).size() > 1) {
            String hostName = (getParameters().getvds().gethost_name().isEmpty()) ? getParameters().getvds().getManagmentIp() : getParameters().getvds().gethost_name();
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostAdd, new GlusterHostAddVDSParameters(upServer.getId(), hostName));
            setSucceeded(returnValue.getSucceeded());
            if (!getSucceeded()) {
                getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
                getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
                errorType = AuditLogType.GLUSTER_HOST_ADD_FAILED;
                return;
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // set vds spm id
    if (getVdsGroup().getstorage_pool_id() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef().getValue());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        CompensationContext compensationContext = getCompensationContext();
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, tempVar, new CommandContext(compensationContext));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            InitializeVds();
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process
    if (Config.<Boolean>GetValue(ConfigValues.InstallVds) && !getParameters().getAddPending()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getRootPassword());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getvds_name());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.InstallVds, installVdsParameters, new CommandContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    } else {
        // Also gluster peer probe is not needed when importing an existing gluster cluster
        if (isGlusterSupportEnabled() && getAllVds(getVdsGroupId()).size() > 1) {
            String hostName = (getParameters().getvds().gethost_name().isEmpty()) ? getParameters().getvds().getManagmentIp() : getParameters().getvds().gethost_name();
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostAdd, new GlusterHostAddVDSParameters(upServer.getId(), hostName));
            setSucceeded(returnValue.getSucceeded());
            if (!getSucceeded()) {
                getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
                getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
                errorType = AuditLogType.GLUSTER_HOST_ADD_FAILED;
                return;
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    setVdsGroupId(getParameters().getVdsStaticData().getvds_group_id());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        returnValue = false;
    } else {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getvds_name();
        String hostName = vds.gethost_name();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
            returnValue = false;
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
            returnValue = false;
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
            returnValue = false;
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers) && !FileUtil.fileExists(Config.resolveCertificatePath())) {
                addCanDoActionMessage(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
                returnValue = false;
            } else if (!getParameters().getAddPending() && StringUtils.isEmpty(getParameters().getRootPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
                returnValue = false;
            } else if (!IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else if (getParameters().getVdsStaticData().getport() < 1 || getParameters().getVdsStaticData().getport() > 65536) {
                addCanDoActionMessage(VdcBllMessages.VDS_PORT_IS_NOT_LEGAL);
                returnValue = false;
            } else {
                returnValue = returnValue && validateHostUniqueness(vds);
            }
        }
    }
    if (getVdsGroup().supportsGlusterService() && getParameters().isGlusterPeerProbeNeeded()) {
        if (clusterHasServers()) {
            upServer = ClusterUtils.getInstance().getUpServer(getVdsGroupId());
            if (upServer == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    setVdsGroupId(getParameters().getVdsStaticData().getvds_group_id());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        returnValue = false;
    } else {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getvds_name();
        String hostName = vds.gethost_name();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
            returnValue = false;
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
            returnValue = false;
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
            returnValue = false;
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers) && !FileUtil.fileExists(Config.resolveCertificatePath())) {
                addCanDoActionMessage(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
                returnValue = false;
            } else if (!getParameters().getAddPending() && StringUtils.isEmpty(getParameters().getRootPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
                returnValue = false;
            } else if (!IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else if (getParameters().getVdsStaticData().getport() < 1 || getParameters().getVdsStaticData().getport() > 65536) {
                addCanDoActionMessage(VdcBllMessages.VDS_PORT_IS_NOT_LEGAL);
                returnValue = false;
            } else {
                returnValue = returnValue && validateHostUniqueness(vds);
            }
        }
    }
    if (isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            upServer = ClusterUtils.getInstance().getUpServer(getVdsGroupId());
            if (upServer == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    }
    return returnValue;
}
#end_block

#method_before
@Override
public String toString() {
    String AddInfo = getAdditionalInformation();
    return String.format("%s(%s %s)", super.toString(), (!StringUtils.isEmpty(AddInfo) ? AddInfo + "," : ""), (getParameters() != null ? getParameters().toString() : "null"));
}
#method_after
@Override
public String toString() {
    String AddInfo = getAdditionalInformation();
    return String.format("%s(%s %s)", super.toString(), (!AddInfo.isEmpty() ? AddInfo + "," : ""), (getParameters() != null ? getParameters().toString() : "null"));
}
#end_block

#method_before
@Override
protected String getAdditionalInformation() {
    if (getVds() != null) {
        return String.format("Vds=%1$s", getVds().getvds_name());
    } else {
        return super.getAdditionalInformation();
    }
}
#method_after
@Override
protected String getAdditionalInformation() {
    if (getVds() != null) {
        return String.format("Vds = %1$s", getVds().getvds_name());
    } else {
        return super.getAdditionalInformation();
    }
}
#end_block

#method_before
public static void DoCompressionCheck(VDS vds, VmDynamic vm) {
    if (Config.<Boolean>GetValue(ConfigValues.PowerClientSpiceDynamicCompressionManagement)) {
        // compression always enabled on VDS
        if (vds.getvds_type() != VDSType.PowerClient) {
            return;
        } else {
            String compression_enabled = "on";
            if (StringHelper.EqOp(vds.gethost_name(), vm.getclient_ip())) {
                compression_enabled = "off";
            }
            log.infoFormat("VdcBLL.VmHandler.DoCompressionCheck - sending monitor command for vmid: {0} - set_red_image_compression and set_red_streaming_video to {1}", vm.getId(), compression_enabled);
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.VmMonitorCommand, new VmMonitorCommandVDSCommandParameters(vds.getId(), vm.getId(), "set_red_image_compression " + compression_enabled));
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.VmMonitorCommand, new VmMonitorCommandVDSCommandParameters(vds.getId(), vm.getId(), "set_red_streaming_video " + compression_enabled));
        }
    }
}
#method_after
public static void DoCompressionCheck(VDS vds, VmDynamic vm) {
    if (Config.<Boolean>GetValue(ConfigValues.PowerClientSpiceDynamicCompressionManagement)) {
        // compression always enabled on VDS
        if (vds.getvds_type() != VDSType.PowerClient) {
            return;
        } else {
            String compression_enabled = "on";
            if (StringUtils.equals(vds.gethost_name(), vm.getclient_ip())) {
                compression_enabled = "off";
            }
            log.infoFormat("VdcBLL.VmHandler.DoCompressionCheck - sending monitor command for vmid: {0} - set_red_image_compression and set_red_streaming_video to {1}", vm.getId(), compression_enabled);
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.VmMonitorCommand, new VmMonitorCommandVDSCommandParameters(vds.getId(), vm.getId(), "set_red_image_compression " + compression_enabled));
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.VmMonitorCommand, new VmMonitorCommandVDSCommandParameters(vds.getId(), vm.getId(), "set_red_streaming_video " + compression_enabled));
        }
    }
}
#end_block

#method_before
@Override
public void RunningSucceded() {
    DecreasePendingVms(getCurrentVdsId());
    setSucceeded(true);
    setActionReturnValue(VMStatus.Up);
    log();
    ExecutionHandler.setAsyncJob(getExecutionContext(), false);
    ExecutionHandler.endJob(getExecutionContext(), true);
    for (Guid vdsId : getRunVdssList()) {
        if (!getCurrentVdsId().equals(vdsId)) {
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FailedToRunVm, new FailedToRunVmVDSCommandParameters(vdsId));
        }
    }
    if (getVm().getlast_vds_run_on() == null || !getVm().getlast_vds_run_on().equals(getCurrentVdsId())) {
        getVm().setlast_vds_run_on(getCurrentVdsId());
    }
    if (!StringHelper.isNullOrEmpty(getVm().gethibernation_vol_handle())) {
        HandleHibernatedVm(getActionType(), true);
        // In order to prevent a race where VdsUpdateRuntimeInfo saves the Vm Dynamic as UP prior to execution of
        // this method (which is a part of the cached VM command,
        // so the state this method is aware to is RESTORING, in case of RunVmCommand after the VM got suspended.
        // In addition, as the boolean return value of HandleHIbernateVm is ignored here, it is safe to set the
        // status to up.
        getVm().setstatus(VMStatus.Up);
        getVm().sethibernation_vol_handle(null);
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getCurrentVdsId(), getVm().getDynamicData()));
    }
}
#method_after
@Override
public void RunningSucceded() {
    DecreasePendingVms(getCurrentVdsId());
    setSucceeded(true);
    setActionReturnValue(VMStatus.Up);
    log();
    ExecutionHandler.setAsyncJob(getExecutionContext(), false);
    ExecutionHandler.endJob(getExecutionContext(), true);
    for (Guid vdsId : getRunVdssList()) {
        if (!getCurrentVdsId().equals(vdsId)) {
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FailedToRunVm, new FailedToRunVmVDSCommandParameters(vdsId));
        }
    }
    if (getVm().getlast_vds_run_on() == null || !getVm().getlast_vds_run_on().equals(getCurrentVdsId())) {
        getVm().setlast_vds_run_on(getCurrentVdsId());
    }
    if (StringUtils.isNotEmpty(getVm().gethibernation_vol_handle())) {
        HandleHibernatedVm(getActionType(), true);
        // In order to prevent a race where VdsUpdateRuntimeInfo saves the Vm Dynamic as UP prior to execution of
        // this method (which is a part of the cached VM command,
        // so the state this method is aware to is RESTORING, in case of RunVmCommand after the VM got suspended.
        // In addition, as the boolean return value of HandleHIbernateVm is ignored here, it is safe to set the
        // status to up.
        getVm().setstatus(VMStatus.Up);
        getVm().sethibernation_vol_handle(null);
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getCurrentVdsId(), getVm().getDynamicData()));
    }
}
#end_block

#method_before
protected boolean connectLunDisks(Guid hostId) {
    if (getVm().getDiskMap().isEmpty()) {
        VmHandler.updateDisksFromDb(getVm());
    }
    List<LunDisk> lunDisks = ImagesHandler.filterDiskBasedOnLuns(getVm().getDiskMap().values());
    for (LunDisk lunDisk : lunDisks) {
        LUNs lun = lunDisk.getLun();
        lun.setLunConnections(new ArrayList<storage_server_connections>(DbFacade.getInstance().getStorageServerConnectionDAO().getAllForLun(lun.getLUN_id())));
        if (!lun.getLunConnections().isEmpty()) {
            if (!StorageHelperDirector.getInstance().getItem(lun.getLunConnections().get(0).getstorage_type()).ConnectStorageToLunByVdsId(null, hostId, lun, getVm().getstorage_pool_id())) {
                log.infoFormat("Failed to connect  a lun disk to vdsm {0} skiping it", hostId);
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean connectLunDisks(Guid hostId) {
    if (getVm().getDiskMap().isEmpty()) {
        VmHandler.updateDisksFromDb(getVm());
    }
    List<LunDisk> lunDisks = ImagesHandler.filterDiskBasedOnLuns(getVm().getDiskMap().values());
    for (LunDisk lunDisk : lunDisks) {
        LUNs lun = lunDisk.getLun();
        lun.setLunConnections(new ArrayList<storage_server_connections>(DbFacade.getInstance().getStorageServerConnectionDAO().getAllForLun(lun.getLUN_id())));
        if (!lun.getLunConnections().isEmpty() && !StorageHelperDirector.getInstance().getItem(lun.getLunConnections().get(0).getstorage_type()).ConnectStorageToLunByVdsId(null, hostId, lun, getVm().getstorage_pool_id())) {
            log.infoFormat("Failed to connect  a lun disk to vdsm {0} skiping it", hostId);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean ConcreteCheckExistingStorageDomain(Pair<storage_domain_static, SANState> domainFromIrs) {
    boolean returnValue = false;
    if (!StringUtils.isEmpty(getStorageDomain().getStorageStaticData().getstorage()) && !StringUtils.isEmpty(domainFromIrs.getFirst().getstorage())) {
        returnValue = (StringUtils.equals(domainFromIrs.getFirst().getstorage(), getStorageDomain().getStorageStaticData().getstorage()));
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_ADD_EXISTING_STORAGE_DOMAIN_CONNECTION_DATA_ILLEGAL);
    } else if (domainFromIrs.getSecond() != null && SANState.OK != domainFromIrs.getSecond()) {
        returnValue = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_ADD_EXISTING_STORAGE_DOMAIN_LUNS_PROBLEM.toString());
    }
    return returnValue;
}
#method_after
@Override
protected boolean ConcreteCheckExistingStorageDomain(Pair<storage_domain_static, SANState> domainFromIrs) {
    boolean returnValue = false;
    if (StringUtils.isNotEmpty(getStorageDomain().getStorageStaticData().getstorage()) && StringUtils.isNotEmpty(domainFromIrs.getFirst().getstorage())) {
        returnValue = (StringUtils.equals(domainFromIrs.getFirst().getstorage(), getStorageDomain().getStorageStaticData().getstorage()));
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_ADD_EXISTING_STORAGE_DOMAIN_CONNECTION_DATA_ILLEGAL);
    } else if (domainFromIrs.getSecond() != null && SANState.OK != domainFromIrs.getSecond()) {
        returnValue = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_ADD_EXISTING_STORAGE_DOMAIN_LUNS_PROBLEM.toString());
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getstatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), new java.util.ArrayList<Guid>(java.util.Arrays.asList(new Guid[] { getStorageDomain().getId() })), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            setSucceeded(getBackend().runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters, new CommandContext(getCompensationContext())).getSucceeded());
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new storage_pool_iso_map(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                ConnectAllHostsToPool();
                VDSReturnValue returnValue = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                DiconnectAllHostsInPool();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getstorage_domain_type();
                        getCompensationContext().snapshotEntityStatus(map, map.getstatus());
                        map.setstatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getstatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            final StorageDomainStaticDAO sdStatDao = DbFacade.getInstance().getStorageDomainStaticDAO();
                            final storage_domain_static domain = sdStatDao.get(getStorageDomain().getId());
                            final StorageFormatType targetFormat = getStoragePool().getStoragePoolFormatType();
                            if (domain.getStorageFormat() != targetFormat) {
                                log.infoFormat("Updating storage domain {0} (type {1}) to format {2}", getStorageDomain().getId(), sdType, targetFormat);
                                domain.setStorageFormat(targetFormat);
                                sdStatDao.update(domain);
                            }
                        }
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                setSucceeded(returnValue.getSucceeded());
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getstatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), new java.util.ArrayList<Guid>(java.util.Arrays.asList(new Guid[] { getStorageDomain().getId() })), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            setSucceeded(getBackend().runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters, new CommandContext(getCompensationContext())).getSucceeded());
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new storage_pool_iso_map(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                ConnectAllHostsToPool();
                VDSReturnValue returnValue = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                DiconnectAllHostsInPool();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getstorage_domain_type();
                        map.setstatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getstatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            final storage_domain_static domain = getStorageDomain().getStorageStaticData();
                            final StorageFormatType targetFormat = getStoragePool().getStoragePoolFormatType();
                            if (domain.getStorageFormat() != targetFormat) {
                                log.infoFormat("Updating storage domain {0} (type {1}) to format {2}", getStorageDomain().getId(), sdType, targetFormat);
                                domain.setStorageFormat(targetFormat);
                                getStorageDomainStaticDAO().update(domain);
                            }
                        }
                        return null;
                    }
                });
                setSucceeded(returnValue.getSucceeded());
            }
        }
    }
}
#end_block

#method_before
@Override
protected void ExecuteVDSCommand() {
    boolean isStartReconstruct = false;
    synchronized (getCurrentIrsProxyData().syncObj) {
        try {
            if (getIrsProxy() != null) {
                ExecuteIrsBrokerCommand();
            } else {
                if (getVDSReturnValue().getVdsError() == null) {
                    getVDSReturnValue().setExceptionString("Cannot allocate IRS server");
                    VDSError tempVar = new VDSError();
                    tempVar.setCode(VdcBllErrors.IRS_REPOSITORY_NOT_FOUND);
                    tempVar.setMessage("Cannot allocate IRS server");
                    getVDSReturnValue().setVdsError(tempVar);
                }
                getVDSReturnValue().setSucceeded(false);
            }
        } catch (UndeclaredThrowableException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(new VDSError(VdcBllErrors.VDS_NETWORK_ERROR, ex.getMessage()));
            if (ExceptionUtils.getRootCause(ex) != null) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (XmlRpcRunTimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex.isNetworkError()) {
                log.errorFormat("IrsBroker::Failed::{0} - network exception.", getCommandName());
                getVDSReturnValue().setSucceeded(false);
            } else {
                log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
                throw new IRSProtocolException(ex);
            }
        } catch (IrsErrorIrsDbMissing ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
            LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            failover();
        } catch (IRSNoMasterDomainException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
            log.errorFormat("Exception: {0}", ex.getMessage());
            if (getCurrentIrsProxyData().getHasVdssForSpmSelection()) {
                failover();
            } else {
                isStartReconstruct = true;
            }
        } catch (IRSNetworkException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            throw new IRSGenericException("Storage Domain server not found", ex);
        } catch (IRSUnicodeArgumentException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            throw new IRSGenericException("UNICODE characters are not supported.", ex);
        } catch (IRSStoragePoolStatusException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            throw ex;
        } catch (IRSNonOperationalException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (ex.getVdsError() != null && VdcBllErrors.SpmStatusError.equals(ex.getVdsError().getCode())) {
                getCurrentIrsProxyData().setCurrentVdsId(Guid.Empty);
            }
            failover();
        } catch (IrsOperationFailedNoFailoverException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            getVDSReturnValue().setSucceeded(false);
        } catch (IRSErrorException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (log.isDebugEnabled()) {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (RuntimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex instanceof VDSExceptionBase) {
                getVDSReturnValue().setVdsError(((VDSExceptionBase) ex).getVdsError());
            }
            if (ExceptionUtils.getRootCause(ex) != null && ExceptionUtils.getRootCause(ex) instanceof SocketException) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            // always failover because of changes in vdsm error, until we
            // realize what to do in each case:
            failover();
        } finally {
            if (_irsProxyData.containsKey(getParameters().getStoragePoolId())) {
                getCurrentIrsProxyData().getTriedVdssList().clear();
            }
            if (!getCurrentIrsProxyData().getIsValidWithoutSpmStart()) {
                getCurrentIrsProxyData().setCurrentVdsId(Guid.Empty);
            }
        }
    }
    if (isStartReconstruct) {
        startReconstruct();
    }
}
#method_after
@Override
protected void ExecuteVDSCommand() {
    boolean isStartReconstruct = false;
    synchronized (getCurrentIrsProxyData().syncObj) {
        try {
            if (getIrsProxy() != null) {
                ExecuteIrsBrokerCommand();
            } else {
                if (getVDSReturnValue().getVdsError() == null) {
                    getVDSReturnValue().setExceptionString("Cannot allocate IRS server");
                    VDSError tempVar = new VDSError();
                    tempVar.setCode(VdcBllErrors.IRS_REPOSITORY_NOT_FOUND);
                    tempVar.setMessage("Cannot allocate IRS server");
                    getVDSReturnValue().setVdsError(tempVar);
                }
                getVDSReturnValue().setSucceeded(false);
            }
        } catch (UndeclaredThrowableException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(new VDSError(VdcBllErrors.VDS_NETWORK_ERROR, ex.getMessage()));
            if (ExceptionUtils.getRootCause(ex) != null) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (XmlRpcRunTimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex.isNetworkError()) {
                log.errorFormat("IrsBroker::Failed::{0} - network exception.", getCommandName());
                getVDSReturnValue().setSucceeded(false);
            } else {
                log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
                throw new IRSProtocolException(ex);
            }
        } catch (IrsErrorIrsDbMissing ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
            LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            failover();
        } catch (IRSNoMasterDomainException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
            log.errorFormat("Exception: {0}", ex.getMessage());
            if (getCurrentIrsProxyData().getHasVdssForSpmSelection()) {
                failover();
            } else {
                isStartReconstruct = true;
            }
        } catch (IRSNetworkException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            throw new IRSGenericException("Storage Domain server not found", ex);
        } catch (IRSUnicodeArgumentException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            throw new IRSGenericException("UNICODE characters are not supported.", ex);
        } catch (IRSStoragePoolStatusException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            throw ex;
        } catch (IRSNonOperationalException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (ex.getVdsError() != null && VdcBllErrors.SpmStatusError == ex.getVdsError().getCode()) {
                getCurrentIrsProxyData().setCurrentVdsId(Guid.Empty);
            }
            failover();
        } catch (IrsOperationFailedNoFailoverException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            getVDSReturnValue().setSucceeded(false);
        } catch (IRSErrorException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (log.isDebugEnabled()) {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (RuntimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex instanceof VDSExceptionBase) {
                getVDSReturnValue().setVdsError(((VDSExceptionBase) ex).getVdsError());
            }
            if (ExceptionUtils.getRootCause(ex) != null && ExceptionUtils.getRootCause(ex) instanceof SocketException) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            // always failover because of changes in vdsm error, until we
            // realize what to do in each case:
            failover();
        } finally {
            if (_irsProxyData.containsKey(getParameters().getStoragePoolId())) {
                getCurrentIrsProxyData().getTriedVdssList().clear();
            }
            if (!getCurrentIrsProxyData().getIsValidWithoutSpmStart()) {
                getCurrentIrsProxyData().setCurrentVdsId(Guid.Empty);
            }
        }
    }
    if (isStartReconstruct) {
        startReconstruct();
    }
}
#end_block

#method_before
@Override
public IConditionValueAutoCompleter getFieldValueAutoCompleter(String fieldName) {
    IConditionValueAutoCompleter retval = null;
    if (StringHelper.EqOp(fieldName, "TYPE")) {
        retval = new EnumValueAutoCompleter(VmPoolType.class);
    } else {
    }
    return retval;
}
#method_after
@Override
public IConditionValueAutoCompleter getFieldValueAutoCompleter(String fieldName) {
    IConditionValueAutoCompleter retval = null;
    if ("TYPE".equals(fieldName)) {
        retval = new EnumValueAutoCompleter(VmPoolType.class);
    }
    return retval;
}
#end_block

#method_before
@Test
public void networkWithTheSameMTUAddedToNic() {
    Network net = createNetwork("nonVmMtu9000");
    net.setVmNetwork(false);
    net.setMtu(9000);
    Network newNet = createNetwork("vLanVmMtu9000");
    newNet.setMtu(9000);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNic("nic0", net.getName());
    nic.setBridged(false);
    mockExistingIfaces(nic);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, createVlan(nic.getName(), 100, newNet.getName())));
    validateAndExpectNoViolations(helper);
}
#method_after
@Test
public void networkWithTheSameMTUAddedToNic() {
    Network net = createNetwork("nonVmMtu9000");
    net.setVmNetwork(false);
    net.setMtu(9000);
    Network newNet = createNetwork("vlanVmMtu9000");
    newNet.setMtu(9000);
    newNet.setvlan_id(100);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    mockExistingIfaces(nic);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, createVlan(nic.getName(), newNet.getvlan_id(), newNet.getName())));
    validateAndExpectNoViolations(helper);
}
#end_block

#method_before
private void validateMTU() {
    Map<String, VdsNetworkInterface> ifacesByNetworkName = Entities.interfacesByNetworkName(params.getInterfaces());
    Set<String> checkedNetworks = new HashSet<String>(getNetworks().size());
    for (Network network : getNetworks()) {
        if (!checkedNetworks.contains(network.getName())) {
            List<Network> networksOnInterface = findNetworksOnInterface(ifacesByNetworkName.get(network.getName()));
            boolean mtuDifferenceExists = false;
            for (Network net : networksOnInterface) {
                checkedNetworks.add(net.getName());
                if (net.getMtu() != network.getMtu() && (!network.isVmNetwork() || !net.isVmNetwork())) {
                    mtuDifferenceExists = true;
                }
            }
            if (mtuDifferenceExists) {
                reportMTUDifferences(networksOnInterface);
            }
        }
    }
}
#method_after
private void validateMTU() {
    Map<String, VdsNetworkInterface> ifacesByNetworkName = Entities.interfacesByNetworkName(params.getInterfaces());
    Set<String> checkedNetworks = new HashSet<String>(getNetworks().size());
    for (Network network : getNetworks()) {
        if (!checkedNetworks.contains(network.getName())) {
            List<Network> networksOnInterface = findNetworksOnInterface(ifacesByNetworkName.get(network.getName()));
            boolean mtuMismatched = false;
            for (Network net : networksOnInterface) {
                checkedNetworks.add(net.getName());
                if (net.getMtu() != network.getMtu() && (NetworkUtils.isNonVmNetworkWithNoVlan(network) || NetworkUtils.isNonVmNetworkWithNoVlan(net))) {
                    mtuMismatched = true;
                }
            }
            if (mtuMismatched) {
                reportMTUDifferences(networksOnInterface);
            }
        }
    }
}
#end_block

#method_before
private void reportMTUDifferences(List<Network> ifaceNetworks) {
    List<String> mtuDiffNetworks = new ArrayList<String>();
    for (Network net : ifaceNetworks) {
        mtuDiffNetworks.add(String.format("%s(%d)", net.getName(), net.getMtu()));
    }
    addViolation(VdcBllMessages.NETWORK_MTU_DIFFERENCES, String.format("[%s]", StringUtils.join(mtuDiffNetworks, ", ")));
}
#method_after
private void reportMTUDifferences(List<Network> ifaceNetworks) {
    List<String> mtuDiffNetworks = new ArrayList<String>();
    for (Network net : ifaceNetworks) {
        mtuDiffNetworks.add(String.format("%s(%s)", net.getName(), net.getMtu() == 0 ? "default" : String.valueOf(net.getMtu())));
    }
    addViolation(VdcBllMessages.NETWORK_MTU_DIFFERENCES, String.format("[%s]", StringUtils.join(mtuDiffNetworks, ", ")));
}
#end_block

#method_before
private List<Network> findNetworksOnInterface(VdsNetworkInterface iface) {
    String nameWithoutVlanId = NetworkUtils.StripVlan(iface.getName());
    List<Network> networks = new ArrayList<Network>();
    for (VdsNetworkInterface tmp : params.getInterfaces()) {
        if (NetworkUtils.StripVlan(tmp.getName()).equals(nameWithoutVlanId) && tmp.getNetworkName() != null) {
            if (existingClusterNetworks.containsKey(tmp.getNetworkName())) {
                networks.add(existingClusterNetworks.get(tmp.getNetworkName()));
            }
        }
    }
    return networks;
}
#method_after
private List<Network> findNetworksOnInterface(VdsNetworkInterface iface) {
    String nameWithoutVlanId = NetworkUtils.StripVlan(iface.getName());
    List<Network> networks = new ArrayList<Network>();
    for (VdsNetworkInterface tmp : params.getInterfaces()) {
        if (NetworkUtils.StripVlan(tmp.getName()).equals(nameWithoutVlanId) && tmp.getNetworkName() != null) {
            if (getExistingClusterNetworks().containsKey(tmp.getNetworkName())) {
                networks.add(getExistingClusterNetworks().get(tmp.getNetworkName()));
            }
        }
    }
    return networks;
}
#end_block

#method_before
private void extractNetwork(VdsNetworkInterface iface) {
    String networkName = iface.getNetworkName();
    // prevent attaching 2 interfaces to 1 network
    if (attachedNetworksNames.contains(networkName)) {
        addViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName);
    } else {
        attachedNetworksNames.add(networkName);
        // check if network exists on cluster
        if (getExistingClusterNetworks().containsKey(networkName)) {
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            if (existingIface != null && !networkName.equals(existingIface.getNetworkName())) {
                existingIface = getExistingIfaceByNetwork(networkName);
            }
            if (existingIface != null && existingIface.getNetworkImplementationDetails() != null && !existingIface.getNetworkImplementationDetails().isInSync()) {
                if (networkShouldBeSynced(networkName)) {
                    modifiedNetworks.add(getExistingClusterNetworks().get(networkName));
                } else if (networkWasModified(iface)) {
                    addViolation(VdcBllMessages.NETWORKS_NOT_IN_SYNC, networkName);
                }
            } else if (networkWasModified(iface)) {
                modifiedNetworks.add(getExistingClusterNetworks().get(networkName));
            }
        } else if (unmanagedNetworkChanged(iface)) {
            addViolation(VdcBllMessages.NETWORKS_DONT_EXIST_IN_CLUSTER, networkName);
        }
    }
}
#method_after
private void extractNetwork(VdsNetworkInterface iface) {
    String networkName = iface.getNetworkName();
    // prevent attaching 2 interfaces to 1 network
    if (attachedNetworksNames.contains(networkName)) {
        addViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName);
    } else {
        attachedNetworksNames.add(networkName);
        // check if network exists on cluster
        if (getExistingClusterNetworks().containsKey(networkName)) {
            Network network = getExistingClusterNetworks().get(networkName);
            validateNetworkExclusiveOnIface(iface, determineNetworkType(network.getvlan_id(), network.isVmNetwork()));
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            if (existingIface != null && !networkName.equals(existingIface.getNetworkName())) {
                existingIface = getExistingIfaceByNetwork(networkName);
            }
            if (existingIface != null && existingIface.getNetworkImplementationDetails() != null && !existingIface.getNetworkImplementationDetails().isInSync()) {
                if (networkShouldBeSynced(networkName)) {
                    modifiedNetworks.add(network);
                } else if (networkWasModified(iface)) {
                    addViolation(VdcBllMessages.NETWORKS_NOT_IN_SYNC, networkName);
                }
            } else if (networkWasModified(iface)) {
                modifiedNetworks.add(network);
            }
        } else {
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            existingIface = (existingIface == null ? iface : existingIface);
            validateNetworkExclusiveOnIface(iface, determineNetworkType(existingIface.getVlanId(), existingIface.isBridged()));
            if (unmanagedNetworkChanged(iface)) {
                addViolation(VdcBllMessages.NETWORKS_DONT_EXIST_IN_CLUSTER, networkName);
            }
        }
    }
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getParameters().getInterface().getType()).getInterfaceTranslation()).toString());
    this.setVmName(DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId()).getvm_name());
    if (StringUtils.isEmpty(getMacAddress())) {
        getParameters().getInterface().setMacAddress(MacPoolManager.getInstance().allocateNewMac());
    }
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getParameters().getInterface().setId(Guid.NewGuid());
    getParameters().getInterface().setVmId(getParameters().getVmId());
    DbFacade dbFacade = DbFacade.getInstance();
    dbFacade.getVmNetworkInterfaceDAO().save(getParameters().getInterface());
    dbFacade.getVmNetworkStatisticsDAO().save(getParameters().getInterface().getStatistics());
    VmDevice vmDevice = VmDeviceUtils.addNetworkInterfaceDevice(new VmDeviceId(getParameters().getInterface().getId(), getParameters().getVmId()), getParameters().getInterface().isActive());
    boolean succeded = true;
    VmDynamic vmDynamic = getVm().getDynamicData();
    if (getParameters().getInterface().isActive() && VmHandler.isHotPlugNicAllowedForVmStatus(vmDynamic.getstatus())) {
        succeded = hotPlugNic(vmDevice, vmDynamic);
        if (!succeded) {
            getReturnValue().getExecuteFailedMessages().add("Failed hot-plugging nic to VM");
        }
    }
    setSucceeded(succeded);
}
#method_after
@Override
protected void ExecuteVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getParameters().getInterface().getType()).getInterfaceTranslation()).toString());
    this.setVmName(DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId()).getvm_name());
    if (StringUtils.isEmpty(getMacAddress())) {
        getParameters().getInterface().setMacAddress(MacPoolManager.getInstance().allocateNewMac());
    }
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getParameters().getInterface().setId(Guid.NewGuid());
    getParameters().getInterface().setVmId(getParameters().getVmId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addInterfaceToDb(getParameters().getInterface());
            addInterfaceDeviceToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    boolean succeeded = true;
    if (getParameters().getInterface().isActive()) {
        succeeded = activateNic();
    }
    setSucceeded(succeeded);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    switch(DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId()).getstatus()) {
        case Up:
        case Down:
        case ImageLocked:
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
            return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNetworkInterface> allInterfaces = new ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId());
    if (!CheckPCIAndIDELimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for version 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    // check that the exists in current cluster
    List<Network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    Network interfaceNetwork = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

        @Override
        public boolean eval(Network network) {
            return network.getname().equals(getParameters().getInterface().getNetworkName());
        }
    });
    if (interfaceNetwork == null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    } else if (!interfaceNetwork.isVmNetwork()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
        addCanDoActionMessage(String.format("$networks %1$s", interfaceNetwork.getname()));
        return false;
    }
    if (getParameters().getInterface().isActive()) {
        if (getVm().getstatus() == VMStatus.Up && !canPerformHotPlug()) {
            return false;
        }
    }
    if (!StringUtils.isEmpty(getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    } else if (// check
    MacPoolManager.getInstance().getavailableMacsCount() <= 0) // if
    // we
    // have
    // mac
    // address
    // in
    // pool
    {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    switch(DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId()).getstatus()) {
        case Up:
        case Down:
        case ImageLocked:
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
            return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNetworkInterface> allInterfaces = new ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId());
    if (!CheckPCIAndIDELimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for version 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    // check that the exists in current cluster
    List<Network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    Network interfaceNetwork = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

        @Override
        public boolean eval(Network network) {
            return network.getname().equals(getParameters().getInterface().getNetworkName());
        }
    });
    if (interfaceNetwork == null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    } else if (!interfaceNetwork.isVmNetwork()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
        addCanDoActionMessage(String.format("$networks %1$s", interfaceNetwork.getname()));
        return false;
    }
    if (!StringUtils.isEmpty(getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    } else if (// check
    MacPoolManager.getInstance().getavailableMacsCount() <= 0) // if
    // we
    // have
    // mac
    // address
    // in
    // pool
    {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean validateShareableDisk() {
    if (DiskStorageType.LUN == _oldDisk.getDiskStorageType()) {
        return true;
    }
    boolean isDiskUpdatedToShareable = getParameters().getDiskInfo().isShareable();
    boolean isDiskShareable = _oldDisk.isShareable();
    // Check if VM is not during snapshot.
    if (ImagesHandler.isVmInPreview(getVmId())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        return false;
    }
    // If user want to update the disk to be shareable then update the vm snapshot id to be null.
    if (!isDiskShareable && isDiskUpdatedToShareable) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(_oldDisk.getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) _oldDisk).getit_guid())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
            return false;
        }
        if (!isVersionSupportedForShareable(_oldDisk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
            return false;
        }
        ((DiskImage) _oldDisk).setvm_snapshot_id(null);
    } else if (isDiskShareable && !isDiskUpdatedToShareable) {
        if (getVmDAO().getVmsListForDisk(_oldDisk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
            return false;
        }
        // If disk is not floating, then update its vm snapshot id to the active VM snapshot.
        ((DiskImage) _oldDisk).setvm_snapshot_id(DbFacade.getInstance().getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE).getValue());
    }
    return true;
}
#method_after
protected boolean validateShareableDisk() {
    if (DiskStorageType.LUN == _oldDisk.getDiskStorageType()) {
        return true;
    }
    boolean isDiskUpdatedToShareable = getParameters().getDiskInfo().isShareable();
    boolean isDiskShareable = _oldDisk.isShareable();
    // Check if VM is not during snapshot.
    if (getSnapshotDao().exists(getVmId(), SnapshotStatus.IN_PREVIEW)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        return false;
    }
    // If user want to update the disk to be shareable then update the vm snapshot id to be null.
    if (!isDiskShareable && isDiskUpdatedToShareable) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(_oldDisk.getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) _oldDisk).getit_guid())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
            return false;
        }
        if (!isVersionSupportedForShareable(_oldDisk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
            return false;
        }
        DiskImage diskImage = (DiskImage) getParameters().getDiskInfo();
        if (!isVolumeFormatSupportedForShareable(diskImage.getvolume_format())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
            return false;
        }
        diskImage.setvm_snapshot_id(null);
    } else if (isDiskShareable && !isDiskUpdatedToShareable) {
        if (getVmDAO().getVmsListForDisk(_oldDisk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
            return false;
        }
        // If disk is not floating, then update its vm snapshot id to the active VM snapshot.
        ((DiskImage) _oldDisk).setvm_snapshot_id(DbFacade.getInstance().getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE).getValue());
    }
    return true;
}
#end_block

#method_before
private void rollbackDisksQuota() {
    List<Guid> quotaList = new ArrayList<Guid>();
    for (DiskImage image : imageTemplates) {
        quotaList.add(image.getQuotaId());
    }
    getQuotaManager().rollbackQuota(getStoragePool(), quotaList);
}
#method_after
private void rollbackDisksQuota() {
    List<Guid> quotaList = new ArrayList<Guid>();
    if (imageTemplates != null) {
        for (DiskImage image : imageTemplates) {
            quotaList.add(image.getQuotaId());
        }
        getQuotaManager().rollbackQuota(getStoragePool(), quotaList);
    }
}
#end_block

#method_before
private List<StorageQuotaValidationParameter> getStorageQuotaListParameters() {
    List<StorageQuotaValidationParameter> list = new ArrayList<StorageQuotaValidationParameter>();
    for (Disk disk : getVm().getDiskMap().values()) {
        if (disk instanceof DiskImage) {
            DiskImage diskImage = (DiskImage) disk;
            list.add(new StorageQuotaValidationParameter(diskImage.getQuotaId(), // TODO: handle import more than once;
            imageToDestinationDomainMap.get(diskImage.getId()), diskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#method_after
private List<StorageQuotaValidationParameter> getStorageQuotaListParameters() {
    List<StorageQuotaValidationParameter> list = new ArrayList<StorageQuotaValidationParameter>();
    for (Disk disk : getParameters().getVm().getDiskMap().values()) {
        if (disk instanceof DiskImage) {
            DiskImage diskImage = (DiskImage) disk;
            list.add(new StorageQuotaValidationParameter(diskImage.getQuotaId(), // TODO: handle import more than once;
            imageToDestinationDomainMap.get(diskImage.getId()), diskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#end_block

#method_before
@Override
protected void MoveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            int i = 0;
            for (DiskImage disk : disks) {
                Guid destinationDomain = imageToDestinationDomainMap.get(diskGuidList.get(i));
                MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, diskGuidList.get(i), imageGuidList.get(i), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
                tempVar.setParentCommand(getActionType());
                tempVar.setUseCopyCollapse(true);
                tempVar.setVolumeType(disk.getvolume_type());
                tempVar.setVolumeFormat(disk.getvolume_format());
                tempVar.setCopyVolumeType(CopyVolumeType.SharedVol);
                tempVar.setPostZero(disk.isWipeAfterDelete());
                tempVar.setSourceDomainId(getParameters().getSourceDomainId());
                tempVar.setForceOverride(true);
                tempVar.setImportEntity(true);
                tempVar.setEntityId(disk.getImageId());
                tempVar.setQuotaId(disk.getQuotaId());
                MoveOrCopyImageGroupParameters p = tempVar;
                p.setParentParemeters(getParameters());
                VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.MoveOrCopyImageGroup, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                if (!vdcRetValue.getSucceeded()) {
                    throw ((vdcRetValue.getFault() != null) ? new VdcBLLException(vdcRetValue.getFault().getError()) : new VdcBLLException(VdcBllErrors.ENGINE));
                }
                getParameters().getImagesParameters().add(p);
                getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
                i++;
            }
            return null;
        }
    });
}
#method_after
@Override
protected void MoveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            int i = 0;
            for (DiskImage disk : disks) {
                Guid destinationDomain = imageToDestinationDomainMap.get(diskGuidList.get(i));
                MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, diskGuidList.get(i), imageGuidList.get(i), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
                tempVar.setParentCommand(getActionType());
                tempVar.setUseCopyCollapse(true);
                tempVar.setVolumeType(disk.getvolume_type());
                tempVar.setVolumeFormat(disk.getvolume_format());
                tempVar.setCopyVolumeType(CopyVolumeType.SharedVol);
                tempVar.setPostZero(disk.isWipeAfterDelete());
                tempVar.setSourceDomainId(getParameters().getSourceDomainId());
                tempVar.setForceOverride(true);
                tempVar.setImportEntity(true);
                tempVar.setEntityId(disk.getImageId());
                for (DiskImage diskImage : getParameters().getVmTemplate().getDiskList()) {
                    if (diskGuidList.get(i).equals(diskImage.getId())) {
                        tempVar.setQuotaId(diskImage.getQuotaId());
                        break;
                    }
                }
                MoveOrCopyImageGroupParameters p = tempVar;
                p.setParentParemeters(getParameters());
                VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.MoveOrCopyImageGroup, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                if (!vdcRetValue.getSucceeded()) {
                    throw ((vdcRetValue.getFault() != null) ? new VdcBLLException(vdcRetValue.getFault().getError()) : new VdcBLLException(VdcBllErrors.ENGINE));
                }
                getParameters().getImagesParameters().add(p);
                getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
                i++;
            }
            return null;
        }
    });
}
#end_block

#method_before
private List<StorageQuotaValidationParameter> getStorageQuotaListParameters() {
    List<StorageQuotaValidationParameter> list = new ArrayList<StorageQuotaValidationParameter>();
    for (DiskImage disk : getParameters().getImages()) {
        list.add(new StorageQuotaValidationParameter(disk.getQuotaId(), // TODO: handle import more than once;
        imageToDestinationDomainMap.get(disk.getId()), disk.getSizeInGigabytes()));
    }
    return list;
}
#method_after
private List<StorageQuotaValidationParameter> getStorageQuotaListParameters() {
    List<StorageQuotaValidationParameter> list = new ArrayList<StorageQuotaValidationParameter>();
    for (DiskImage disk : getParameters().getVmTemplate().getDiskList()) {
        list.add(new StorageQuotaValidationParameter(disk.getQuotaId(), // TODO: handle import more than once;
        imageToDestinationDomainMap.get(disk.getId()), disk.getSizeInGigabytes()));
    }
    return list;
}
#end_block

#method_before
@Override
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (getStoragePool() != null && getQuotaId() != null && !getStoragePool().getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED)) {
        quotaPermissionList.add(new PermissionSubject(getQuotaId(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
        Map<Guid, Guid> quotaMap = new HashMap<Guid, Guid>();
        quotaMap.put(getQuotaId(), getQuotaId());
        for (DiskImage disk : getParameters().getImages()) {
            if (disk.getQuotaId() != null && !quotaMap.containsKey(disk.getQuotaId())) {
                quotaPermissionList.add(new PermissionSubject(disk.getQuotaId(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
                quotaMap.put(disk.getQuotaId(), disk.getQuotaId());
            }
        }
    }
}
#method_after
@Override
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (getStoragePool() != null && getQuotaId() != null && !getStoragePool().getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED)) {
        quotaPermissionList.add(new PermissionSubject(getQuotaId(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
        Map<Guid, Guid> quotaMap = new HashMap<Guid, Guid>();
        quotaMap.put(getQuotaId(), getQuotaId());
        for (DiskImage disk : getParameters().getVmTemplate().getDiskList()) {
            if (disk.getQuotaId() != null && !quotaMap.containsKey(disk.getQuotaId())) {
                quotaPermissionList.add(new PermissionSubject(disk.getQuotaId(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
                quotaMap.put(disk.getQuotaId(), disk.getQuotaId());
            }
        }
    }
}
#end_block

#method_before
@Override
public boolean validateAndSetQuota() {
    return getQuotaManager().validateAndSetStorageQuota(getStoragePool(), getStorageQuotaListParameters(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
public boolean validateAndSetQuota() {
    if (isInternalExecution()) {
        return true;
    }
    return getQuotaManager().validateAndSetStorageQuota(getStoragePool(), getStorageQuotaListParameters(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
public void rollbackQuota() {
    getQuotaManager().rollbackQuota(getStoragePool(), getQuotaManager().getQuotaListFromParameters(getStorageQuotaListParameters()));
}
#method_after
@Override
public void rollbackQuota() {
    if (isInternalExecution()) {
        return;
    }
    getQuotaManager().rollbackQuota(getStoragePool(), getQuotaManager().getQuotaListFromParameters(getStorageQuotaListParameters()));
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    // Before running the VM we update its devices, as they may need to be changed due to configuration option
    // change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    setActionReturnValue(VMStatus.Down);
    if (InitVm()) {
        if (getVm().getstatus() == VMStatus.Paused) {
            // resume
            ResumeVm();
        } else {
            // run vm
            if (!_isRerun && Boolean.TRUE.equals(getParameters().getRunAsStateless()) && !getVm().getDiskList().isEmpty() && getVm().getstatus() != VMStatus.Suspended) {
                StatelessVmTreatment();
            } else if (!getParameters().getIsInternal() && !_isRerun && getVm().getstatus() != VMStatus.Suspended && statelessSnapshotExistsForVm()) {
                removeVmStatlessImages();
            } else {
                RunVm();
            }
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#method_after
@Override
protected void ExecuteVmCommand() {
    // Before running the VM we update its devices, as they may need to be changed due to configuration option
    // change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    setActionReturnValue(VMStatus.Down);
    if (InitVm()) {
        if (getVm().getstatus() == VMStatus.Paused) {
            // resume
            ResumeVm();
        } else {
            // run vm
            if (!_isRerun && Boolean.TRUE.equals(getParameters().getRunAsStateless()) && getVm().getstatus() != VMStatus.Suspended) {
                if (getVm().getDiskList().isEmpty()) {
                    // If there are no snappable disks, there is no meaning for
                    // running as stateless, log a warning and run normally
                    warnIfNotAllDisksPermitSnapshots();
                    RunVm();
                } else {
                    StatelessVmTreatment();
                }
            } else if (!getParameters().getIsInternal() && !_isRerun && getVm().getstatus() != VMStatus.Suspended && statelessSnapshotExistsForVm()) {
                removeVmStatlessImages();
            } else {
                RunVm();
            }
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#end_block

#method_before
@Override
protected void EndSuccessfully() {
    SetIsVmRunningStateless();
    if (_isVmRunningStateless) {
        VdcActionParametersBase createSnapshotParameters = getParameters().getImagesParameters().get(0);
        if (createSnapshotParameters != null) {
            createSnapshotParameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        }
        getBackend().EndAction(VdcActionType.CreateAllSnapshotsFromVm, createSnapshotParameters);
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        ExecutionContext runStatelessVmCtx = new ExecutionContext();
        Step step = getExecutionContext().getStep();
        // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
        // at this is a new instance of the command is used
        // (comparing with the execution state) so all information on the job and steps should be retrieved.
        Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
        Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
        // We would like to to set the run stateless step as substep of executing step
        getParameters().setIsInternal(true);
        // The iternal command should be monitored for tasks
        runStatelessVmCtx.setMonitored(true);
        Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
        // This is needed in order to end the job upon exextuion of the steps of the child command
        runStatelessVmCtx.setShouldEndJob(true);
        // Since run stateless step involves invocation of command, we should set the run stateless vm step as
        // the "beginning step" of the child command.
        runStatelessVmCtx.setStep(runStatelessStep);
        setSucceeded(getBackend().runInternalAction(VdcActionType.RunVm, getParameters(), new CommandContext(runStatelessVmCtx)).getSucceeded());
        if (!getSucceeded()) {
            // could not run the vm don't try to run the end action
            // again
            log.warnFormat("Could not run the vm {0} on RunVm.EndSuccessfully", getVm().getvm_name());
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.EndSuccessfully();
    }
}
#method_after
@Override
protected void EndSuccessfully() {
    SetIsVmRunningStateless();
    if (_isVmRunningStateless) {
        VdcActionParametersBase createSnapshotParameters = getParameters().getImagesParameters().get(0);
        if (createSnapshotParameters != null) {
            createSnapshotParameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        }
        getBackend().EndAction(VdcActionType.CreateAllSnapshotsFromVm, createSnapshotParameters);
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        ExecutionContext runStatelessVmCtx = new ExecutionContext();
        Step step = getExecutionContext().getStep();
        // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
        // at this is a new instance of the command is used
        // (comparing with the execution state) so all information on the job and steps should be retrieved.
        Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
        Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
        // We would like to to set the run stateless step as substep of executing step
        getParameters().setIsInternal(true);
        // The iternal command should be monitored for tasks
        runStatelessVmCtx.setMonitored(true);
        Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
        // This is needed in order to end the job upon exextuion of the steps of the child command
        runStatelessVmCtx.setShouldEndJob(true);
        // Since run stateless step involves invocation of command, we should set the run stateless vm step as
        // the "beginning step" of the child command.
        runStatelessVmCtx.setStep(runStatelessStep);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), new CommandContext(runStatelessVmCtx)).getSucceeded());
        if (!getSucceeded()) {
            // could not run the vm don't try to run the end action
            // again
            log.warnFormat("Could not run the vm {0} on RunVm.EndSuccessfully", getVm().getvm_name());
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.EndSuccessfully();
    }
}
#end_block

#method_before
@Override
public boolean validateAndSetQuota() {
    return getQuotaManager().validateAndSetClusterQuota(getStoragePool(), getVm().getvds_group_id(), getQuotaId(), getVm().getcpu_per_socket() * getVm().getnum_of_sockets(), getVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
public boolean validateAndSetQuota() {
    boolean canDoAction = getQuotaManager().validateAndSetClusterQuota(getStoragePool(), getVm().getvds_group_id(), getQuotaId(), getVm().getcpu_per_socket() * getVm().getnum_of_sockets(), getVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages());
    getReturnValue().getCanDoActionMessages().add(String.format("$VmName %1$s", getVm().getvm_name()));
    return canDoAction;
}
#end_block

#method_before
@Override
public NGuid getStorageDomainId() {
    return getParameters() != null ? !getParameters().getStorageDomainId().equals(Guid.Empty) ? getParameters().getStorageDomainId() : super.getStorageDomainId() : super.getStorageDomainId();
}
#method_after
@Override
public NGuid getStorageDomainId() {
    return getParameters() != null ? !Guid.Empty.equals(getParameters().getStorageDomainId()) ? getParameters().getStorageDomainId() : super.getStorageDomainId() : super.getStorageDomainId();
}
#end_block

#method_before
protected void RefreshAllVdssInPool(boolean connect) {
    java.util.ArrayList<Guid> vdsIdsToSetNonOperational = new java.util.ArrayList<Guid>();
    runSynchronizeOperation(new RefreshPoolSingleAsyncOperationFactory(), vdsIdsToSetNonOperational);
    for (Guid vdsId : vdsIdsToSetNonOperational) {
        SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(vdsId, STORAGE_DOMAIN_UNREACHABLE);
        tempVar.setSaveToDb(true);
        tempVar.setStorageDomainId(getStorageDomain().getId());
        tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        getBackend().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar);
    }
}
#method_after
protected void RefreshAllVdssInPool(boolean connect) {
    java.util.ArrayList<Guid> vdsIdsToSetNonOperational = new java.util.ArrayList<Guid>();
    runSynchronizeOperation(new RefreshPoolSingleAsyncOperationFactory(), vdsIdsToSetNonOperational);
    for (Guid vdsId : vdsIdsToSetNonOperational) {
        SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(vdsId, STORAGE_DOMAIN_UNREACHABLE);
        tempVar.setSaveToDb(true);
        tempVar.setStorageDomainId(getStorageDomain().getId());
        tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        getBackend().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar, ExecutionHandler.createInternalJobContext());
    }
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected void compensate() {
    if (this instanceof Quotable) {
        ((Quotable) this).rollbackQuota();
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getFactory().createDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected void compensate() {
    try {
        if (this instanceof Quotable) {
            ((Quotable) this).rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getFactory().createDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#end_block

#method_before
private boolean InternalCanDoAction() {
    boolean returnValue = false;
    try {
        Transaction transaction = TransactionSupport.suspend();
        try {
            returnValue = IsUserAutorizedToRunAction() && IsBackwardsCompatible() && validateInputs() && acquireLock() && canDoAction();
            if (this instanceof Quotable) {
                returnValue &= ((Quotable) this).validateAndSetQuota();
            }
            if (!returnValue && getReturnValue().getCanDoActionMessages().size() > 0) {
                log.warnFormat("CanDoAction of action {0} failed. Reasons:{1}", getActionType(), StringUtils.join(getReturnValue().getCanDoActionMessages(), ','));
            }
        } finally {
            TransactionSupport.resume(transaction);
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during CanDoActionFailure.", dataAccessEx);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during CanDoActionFailure.", ex);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            freeLock();
        }
    }
    return returnValue;
}
#method_after
private boolean InternalCanDoAction() {
    boolean returnValue = false;
    try {
        Transaction transaction = TransactionSupport.suspend();
        try {
            returnValue = IsUserAutorizedToRunAction() && IsBackwardsCompatible() && validateInputs() && acquireLock() && canDoAction();
            if (returnValue && this instanceof Quotable) {
                returnValue &= ((Quotable) this).validateAndSetQuota();
            }
            if (!returnValue && getReturnValue().getCanDoActionMessages().size() > 0) {
                log.warnFormat("CanDoAction of action {0} failed. Reasons:{1}", getActionType(), StringUtils.join(getReturnValue().getCanDoActionMessages(), ','));
            }
        } finally {
            TransactionSupport.resume(transaction);
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during CanDoActionFailure.", dataAccessEx);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during CanDoActionFailure.", ex);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            freeLock();
        }
    }
    return returnValue;
}
#end_block

#method_before
protected boolean IsUserAutorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check skipped for internal action {0}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!MultiLevelAdministrationHandler.isMultilevelAdministrationOn()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check for action {0} skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The set of objects to check is null or empty for action {0}.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    if (this instanceof Quotable) {
        ((Quotable) this).addQuotaPermissionSubject(permSubjects);
    }
    for (PermissionSubject permSubject : permSubjects) {
        final Guid objectId = permSubject.getObjectId();
        final VdcObjectType objectType = permSubject.getObjectType();
        final ActionGroup objectActionGroup = permSubject.getActionGroup();
        // if objectId is null we can't check permission
        if (objectId == null) {
            if (log.isDebugEnabled()) {
                log.debugFormat("The object to check is null for action {0}.", getActionType());
            }
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
        // Check that an action group is defined for this action;
        if (objectActionGroup == null) {
            if (log.isDebugEnabled()) {
                log.debugFormat("No action group is defined for action {0}.", getActionType());
            }
            return false;
        }
        // Check the authorization:
        if (!checkUserAuthorization(getCurrentUser().getUserId(), objectActionGroup, objectId, objectType)) {
            if (permSubject.getMessage() != null) {
                addCanDoActionMessage(permSubject.getMessage());
            } else {
                addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            }
            return false;
        }
    }
    // If we are here then we should grant the permission:
    return true;
}
#method_after
protected boolean IsUserAutorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check skipped for internal action {0}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!MultiLevelAdministrationHandler.isMultilevelAdministrationOn()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check for action {0} skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The set of objects to check is null or empty for action {0}.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    if (this instanceof Quotable) {
        ((Quotable) this).addQuotaPermissionSubject(permSubjects);
    }
    for (PermissionSubject permSubject : permSubjects) {
        final Guid objectId = permSubject.getObjectId();
        final VdcObjectType objectType = permSubject.getObjectType();
        final ActionGroup objectActionGroup = permSubject.getActionGroup();
        // if objectId is null we can't check permission
        if (objectId == null) {
            if (log.isDebugEnabled()) {
                log.debugFormat("The object to check is null for action {0}.", getActionType());
            }
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
        // Check that an action group is defined for this action;
        if (objectActionGroup == null) {
            if (log.isDebugEnabled()) {
                log.debugFormat("No action group is defined for action {0}.", getActionType());
            }
            return false;
        }
        // Check the authorization:
        if (!checkUserAuthorization(getCurrentUser().getUserId(), objectActionGroup, objectId, objectType)) {
            addCanDoActionMessage(permSubject.getMessage());
            return false;
        }
    }
    // If we are here then we should grant the permission:
    return true;
}
#end_block

#method_before
@Override
public void Rollback() {
    log.errorFormat("Transaction rolled-back for command: {0}.", CommandBase.this.getClass().getName());
    if (this instanceof Quotable) {
        ((Quotable) this).rollbackQuota();
    }
    cancelTasks();
}
#method_after
@Override
public void Rollback() {
    log.errorFormat("Transaction rolled-back for command: {0}.", CommandBase.this.getClass().getName());
    try {
        if (this instanceof Quotable) {
            ((Quotable) this).rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    cancelTasks();
}
#end_block

#method_before
private boolean checkIfImageDiskCanBeAdded(VM vm) {
    boolean returnValue;
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    returnValue = validator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages());
    if (returnValue && vm != null && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomainId().getValue(), vm.getstorage_pool_id())) == null) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    returnValue = returnValue && checkImageConfiguration() && (vm == null || isDiskPassPCIAndIDELimit(getParameters().getDiskInfo()));
    returnValue = returnValue && (vm == null || performImagesChecks(vm));
    if (returnValue && !hasFreeSpace(getStorageDomain())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
    }
    if (returnValue && isExceedMaxBlockDiskSize()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_MAX_SIZE_EXCEEDED);
        getReturnValue().getCanDoActionMessages().add(String.format("$max_disk_size %1$s", Config.<Integer>GetValue(ConfigValues.MaxBlockDiskSize)));
        returnValue = false;
    }
    if (returnValue && getParameters().getDiskInfo().isShareable() && !Config.<Boolean>GetValue(ConfigValues.ShareableDiskEnabled, getStoragePool().getcompatibility_version().getValue())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    return returnValue && (vm == null || validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId())));
}
#method_after
private boolean checkIfImageDiskCanBeAdded(VM vm) {
    boolean returnValue;
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    returnValue = validator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages());
    if (returnValue && vm != null && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomainId().getValue(), vm.getstorage_pool_id())) == null) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    returnValue = returnValue && checkImageConfiguration() && (vm == null || isDiskPassPCIAndIDELimit(getParameters().getDiskInfo()));
    returnValue = returnValue && (vm == null || performImagesChecks(vm));
    if (returnValue && !hasFreeSpace(getStorageDomain())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
    }
    if (returnValue && isExceedMaxBlockDiskSize()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_MAX_SIZE_EXCEEDED);
        getReturnValue().getCanDoActionMessages().add(String.format("$max_disk_size %1$s", Config.<Integer>GetValue(ConfigValues.MaxBlockDiskSize)));
        returnValue = false;
    }
    if (returnValue && getParameters().getDiskInfo().isShareable()) {
        if (!Config.<Boolean>GetValue(ConfigValues.ShareableDiskEnabled, getStoragePool().getcompatibility_version().getValue())) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
        } else if (!isVolumeFormatSupportedForShareable(((DiskImage) getParameters().getDiskInfo()).getvolume_format())) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
        }
    }
    return returnValue && (vm == null || validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId())));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = super.canDoAction();
    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VAR__ACTION__CREATE.toString());
    if (DbFacade.getInstance().getVdsGroupDAO().getByName(getVdsGroup().getname()) != null) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
        result = false;
    } else if (getVdsGroup().supportsVirtService() && !CpuFlagsManagerHandler.CheckIfCpusExist(getVdsGroup().getcpu_name(), getVdsGroup().getcompatibility_version())) {
        // cpu check required only if the cluster supports Virt service
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
        result = false;
    } else if (!VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    } else if (getVdsGroup().getstorage_pool_id() != null) {
        setStoragePoolId(getVdsGroup().getstorage_pool_id());
        if (getStoragePool() != null && getStoragePool().getcompatibility_version().compareTo(getVdsGroup().getcompatibility_version()) > 0) {
            getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_COMPATIBILITY_VERSION_WITH_LOWER_STORAGE_POOL.toString());
            result = false;
        }
    }
    if (result && getVdsGroup().getstorage_pool_id() != null) {
        storage_pool storagePool = DbFacade.getInstance().getStoragePoolDAO().get(getVdsGroup().getstorage_pool_id().getValue());
        // breaking Fk_vds_groups_storage_pool_id
        if (storagePool == null) {
            getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST.toString());
            result = false;
        } else if (storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
            // we allow only one cluster in localfs data center
            if (!DbFacade.getInstance().getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getstorage_pool_id().getValue()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else // selection algorithm must be set to none in localfs
            if (getVdsGroup().getselection_algorithm() != VdsSelectionAlgorithm.None) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_SELECTION_ALGORITHM_MUST_BE_SET_TO_NONE_ON_LOCAL_STORAGE.toString());
                result = false;
            }
        }
    }
    if (result) {
        result = validateMetrics();
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        }
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = super.canDoAction();
    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VAR__ACTION__CREATE.toString());
    if (DbFacade.getInstance().getVdsGroupDAO().getByName(getVdsGroup().getname()) != null) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
        result = false;
    } else if (getVdsGroup().supportsVirtService() && !CpuFlagsManagerHandler.CheckIfCpusExist(getVdsGroup().getcpu_name(), getVdsGroup().getcompatibility_version())) {
        // cpu check required only if the cluster supports Virt service
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
        result = false;
    } else if (!VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    } else if (getVdsGroup().getstorage_pool_id() != null) {
        setStoragePoolId(getVdsGroup().getstorage_pool_id());
        if (getStoragePool() != null && getStoragePool().getcompatibility_version().compareTo(getVdsGroup().getcompatibility_version()) > 0) {
            getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_COMPATIBILITY_VERSION_WITH_LOWER_STORAGE_POOL.toString());
            result = false;
        }
    }
    if (result && getVdsGroup().getstorage_pool_id() != null) {
        storage_pool storagePool = DbFacade.getInstance().getStoragePoolDAO().get(getVdsGroup().getstorage_pool_id().getValue());
        // breaking Fk_vds_groups_storage_pool_id
        if (storagePool == null) {
            getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST.toString());
            result = false;
        } else if (storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
            // we allow only one cluster in localfs data center
            if (!DbFacade.getInstance().getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getstorage_pool_id().getValue()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else // selection algorithm must be set to none in localfs
            if (getVdsGroup().getselection_algorithm() != VdsSelectionAlgorithm.None) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_SELECTION_ALGORITHM_MUST_BE_SET_TO_NONE_ON_LOCAL_STORAGE.toString());
                result = false;
            }
        }
    }
    if (result) {
        result = validateMetrics();
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    return result;
}
#end_block

#method_before
private XmlRpcStruct initNicStructure() {
    XmlRpcStruct map = new XmlRpcStruct();
    VmNetworkInterface nic = getParameters().getNic();
    VmDevice vmDevice = getParameters().getVmDevice();
    map.add("type", "interface");
    map.add("device", "bridge");
    map.add("macAddr", nic.getMacAddress());
    map.add("network", nic.getNetworkName());
    addAddress(map, vmDevice.getAddress());
    map.add("specParams", vmDevice.getSpecParams());
    map.add("nicModel", VmInterfaceType.forValue(nic.getType()).name());
    if (vmDevice.getBootOrder() > 0) {
        map.add("bootOrder", String.valueOf(vmDevice.getBootOrder()));
    }
    if (nic.isPortMirroring()) {
        struct.add(VdsProperties.portMirroring, Collections.singletonList(nic.getNetworkName()));
    }
    return map;
}
#method_after
private XmlRpcStruct initNicStructure() {
    XmlRpcStruct map = new XmlRpcStruct();
    VmNetworkInterface nic = getParameters().getNic();
    VmDevice vmDevice = getParameters().getVmDevice();
    map.add("type", "interface");
    map.add("device", "bridge");
    map.add("macAddr", nic.getMacAddress());
    map.add("network", nic.getNetworkName());
    addAddress(map, vmDevice.getAddress());
    map.add("specParams", vmDevice.getSpecParams());
    map.add("nicModel", VmInterfaceType.forValue(nic.getType()).name());
    if (vmDevice.getBootOrder() > 0) {
        map.add("bootOrder", String.valueOf(vmDevice.getBootOrder()));
    }
    if (nic.isPortMirroring()) {
        map.add(VdsProperties.portMirroring, Collections.singletonList(nic.getNetworkName()));
    }
    return map;
}
#end_block

#method_before
private void validateEnumParameters(GlusterVolume volume) {
    validateEnum(GlusterVolumeType.class, volume.getVolumeType().toUpperCase());
    if (volume.isSetTransportTypes()) {
        validateEnums(TransportType.class, convertToUppercase(volume.getTransportTypes().getTransportTypes()));
    }
    if (volume.isSetAccessProtocols()) {
        validateEnums(AccessProtocol.class, convertToUppercase(volume.getAccessProtocols().getAccessProtocols()));
    }
}
#method_after
private void validateEnumParameters(GlusterVolume volume) {
    validateEnum(GlusterVolumeType.class, volume.getVolumeType().toUpperCase());
    if (volume.isSetTransportTypes()) {
        validateEnumValues(TransportType.class, convertToUppercase(volume.getTransportTypes().getTransportTypes()));
    }
    if (volume.isSetAccessProtocols()) {
        validateEnumValues(AccessProtocol.class, convertToUppercase(volume.getAccessProtocols().getAccessProtocols()));
    }
}
#end_block

#method_before
@Mapping(from = GlusterBrickEntity.class, to = GlusterBrick.class)
public static GlusterBrick map(GlusterBrickEntity fromBrick, GlusterBrick toBrick) {
    GlusterBrick brick = (toBrick == null) ? new GlusterBrick() : toBrick;
    if (fromBrick.getId() != null) {
        brick.setId(fromBrick.getId().toString());
    }
    if (fromBrick.getServerId() != null) {
        brick.setServerId(fromBrick.getServerId().toString());
    }
    if (fromBrick.getBrickDirectory() != null) {
        brick.setBrickDir(fromBrick.getBrickDirectory());
    }
    if (fromBrick.getStatus() != null) {
        brick.setState(fromBrick.getStatus().name().toLowerCase());
    }
    if (fromBrick.getVolumeId() != null) {
        brick.setGlusterVolume(new GlusterVolume());
        brick.getGlusterVolume().setId(fromBrick.getVolumeId().toString());
    }
    return brick;
}
#method_after
@Mapping(from = GlusterBrickEntity.class, to = GlusterBrick.class)
public static GlusterBrick map(GlusterBrickEntity fromBrick, GlusterBrick toBrick) {
    GlusterBrick brick = (toBrick == null) ? new GlusterBrick() : toBrick;
    if (fromBrick.getId() != null) {
        brick.setId(fromBrick.getId().toString());
    }
    if (fromBrick.getServerId() != null) {
        brick.setServerId(fromBrick.getServerId().toString());
    }
    if (fromBrick.getBrickDirectory() != null) {
        brick.setBrickDir(fromBrick.getBrickDirectory());
    }
    if (fromBrick.getStatus() != null) {
        brick.setStatus(StatusUtils.create(map(fromBrick.getStatus(), null)));
    }
    if (fromBrick.getVolumeId() != null) {
        brick.setGlusterVolume(new GlusterVolume());
        brick.getGlusterVolume().setId(fromBrick.getVolumeId().toString());
    }
    return brick;
}
#end_block

#method_before
@Mapping(from = GlusterBrickEntity.class, to = GlusterBrick.class)
public static GlusterBrick map(GlusterBrickEntity fromBrick, GlusterBrick toBrick) {
    GlusterBrick brick = (toBrick == null) ? new GlusterBrick() : toBrick;
    if (fromBrick.getId() != null) {
        brick.setId(fromBrick.getId().toString());
    }
    if (fromBrick.getServerId() != null) {
        brick.setServerId(fromBrick.getServerId().toString());
    }
    if (fromBrick.getBrickDirectory() != null) {
        brick.setBrickDir(fromBrick.getBrickDirectory());
    }
    if (fromBrick.getStatus() != null) {
        brick.setState(fromBrick.getStatus().name().toLowerCase());
    }
    if (fromBrick.getVolumeId() != null) {
        brick.setGlusterVolume(new GlusterVolume());
        brick.getGlusterVolume().setId(fromBrick.getVolumeId().toString());
    }
    return brick;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.GlusterStatus.class, to = GlusterState.class)
public static GlusterState map(org.ovirt.engine.core.common.businessentities.gluster.GlusterStatus glusterVolumeStatus, String template) {
    switch(glusterVolumeStatus) {
        case UP:
            return GlusterState.UP;
        case DOWN:
            return GlusterState.DOWN;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = GlusterVolumeEntity.class, to = GlusterVolume.class)
public static GlusterVolume map(GlusterVolumeEntity fromVolume, GlusterVolume toVolume) {
    GlusterVolume volume = toVolume != null ? toVolume : new GlusterVolume();
    if (fromVolume.getId() != null) {
        volume.setId(fromVolume.getId().toString());
    }
    if (fromVolume.getName() != null) {
        volume.setName(fromVolume.getName());
    }
    if (fromVolume.getVolumeType() != null) {
        volume.setVolumeType(map(fromVolume.getVolumeType(), null).toLowerCase());
    }
    if (fromVolume.getTransportTypes() != null) {
        ArrayList<String> transportTypeList = new ArrayList<String>();
        for (org.ovirt.engine.core.common.businessentities.gluster.TransportType transportType : fromVolume.getTransportTypes()) {
            transportTypeList.add(map(transportType, null).toLowerCase());
        }
        volume.setTransportTypes(new TransportTypes());
        volume.getTransportTypes().getTransportTypes().addAll(transportTypeList);
    }
    if (fromVolume.getAccessProtocols() != null) {
        ArrayList<String> accessProtocolList = new ArrayList<String>();
        for (org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol accessProtocol : fromVolume.getAccessProtocols()) {
            accessProtocolList.add(map(accessProtocol, null).toLowerCase());
        }
        volume.setAccessProtocols(new AccessProtocols());
        volume.getAccessProtocols().getAccessProtocols().addAll(accessProtocolList);
    }
    if (fromVolume.getAccessControlList() != null) {
        volume.setAccessControlList(new AccessControlList());
        volume.getAccessControlList().getAccessControlList().addAll(Arrays.asList(fromVolume.getAccessControlList().split(",")));
    }
    volume.setReplicaCount(fromVolume.getReplicaCount());
    volume.setStripeCount(fromVolume.getStripeCount());
    if (fromVolume.getStatus() != null) {
        volume.setState(fromVolume.getStatus().name().toLowerCase());
    }
    if (fromVolume.getOptions() != null) {
        Options glusterOptions = new Options();
        List<Option> options = glusterOptions.getOptions();
        for (GlusterVolumeOptionEntity option : fromVolume.getOptions()) {
            options.add(mapOption(option));
        }
        volume.setOptions(glusterOptions);
    }
    return volume;
}
#method_after
@Mapping(from = GlusterVolumeEntity.class, to = GlusterVolume.class)
public static GlusterVolume map(GlusterVolumeEntity fromVolume, GlusterVolume toVolume) {
    GlusterVolume volume = toVolume != null ? toVolume : new GlusterVolume();
    if (fromVolume.getId() != null) {
        volume.setId(fromVolume.getId().toString());
    }
    if (fromVolume.getName() != null) {
        volume.setName(fromVolume.getName());
    }
    if (fromVolume.getVolumeType() != null) {
        volume.setVolumeType(map(fromVolume.getVolumeType(), null));
    }
    if (fromVolume.getTransportTypes() != null) {
        ArrayList<String> transportTypeList = new ArrayList<String>();
        for (org.ovirt.engine.core.common.businessentities.gluster.TransportType transportType : fromVolume.getTransportTypes()) {
            transportTypeList.add(map(transportType, null));
        }
        volume.setTransportTypes(new TransportTypes());
        volume.getTransportTypes().getTransportTypes().addAll(transportTypeList);
    }
    if (fromVolume.getAccessProtocols() != null) {
        ArrayList<String> accessProtocolList = new ArrayList<String>();
        for (org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol accessProtocol : fromVolume.getAccessProtocols()) {
            accessProtocolList.add(map(accessProtocol, null));
        }
        volume.setAccessProtocols(new AccessProtocols());
        volume.getAccessProtocols().getAccessProtocols().addAll(accessProtocolList);
    }
    if (fromVolume.getAccessControlList() != null) {
        volume.setAccessControlList(new AccessControlList());
        volume.getAccessControlList().getAccessControlList().addAll(Arrays.asList(fromVolume.getAccessControlList().split(",")));
    }
    volume.setReplicaCount(fromVolume.getReplicaCount());
    volume.setStripeCount(fromVolume.getStripeCount());
    if (fromVolume.getStatus() != null) {
        volume.setStatus(StatusUtils.create(map(fromVolume.getStatus(), null)));
    }
    if (fromVolume.getOptions() != null) {
        Options glusterOptions = new Options();
        List<Option> options = glusterOptions.getOptions();
        for (GlusterVolumeOptionEntity option : fromVolume.getOptions()) {
            options.add(mapOption(option));
        }
        volume.setOptions(glusterOptions);
    }
    return volume;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.GlusterVolumeType.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.GlusterVolumeType glusterVolumeType, String template) {
    switch(glusterVolumeType) {
        case DISTRIBUTE:
            return GlusterVolumeType.DISTRIBUTE.name();
        case REPLICATE:
            return GlusterVolumeType.REPLICATE.name();
        case DISTRIBUTED_REPLICATE:
            return GlusterVolumeType.DISTRIBUTED_REPLICATE.name();
        case STRIPE:
            return GlusterVolumeType.STRIPE.name();
        case DISTRIBUTED_STRIPE:
            return GlusterVolumeType.DISTRIBUTED_STRIPE.name();
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.GlusterVolumeType.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.GlusterVolumeType glusterVolumeType, String template) {
    switch(glusterVolumeType) {
        case DISTRIBUTE:
            return GlusterVolumeType.DISTRIBUTE.value();
        case REPLICATE:
            return GlusterVolumeType.REPLICATE.value();
        case DISTRIBUTED_REPLICATE:
            return GlusterVolumeType.DISTRIBUTED_REPLICATE.value();
        case STRIPE:
            return GlusterVolumeType.STRIPE.value();
        case DISTRIBUTED_STRIPE:
            return GlusterVolumeType.DISTRIBUTED_STRIPE.value();
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.TransportType.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.TransportType transportType, String template) {
    switch(transportType) {
        case TCP:
            return TransportType.TCP.name();
        case RDMA:
            return TransportType.RDMA.name();
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.TransportType.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.TransportType transportType, String template) {
    switch(transportType) {
        case TCP:
            return TransportType.TCP.value();
        case RDMA:
            return TransportType.RDMA.value();
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol accessProtocol, String template) {
    switch(accessProtocol) {
        case GLUSTER:
            return AccessProtocol.GLUSTER.name();
        case NFS:
            return AccessProtocol.NFS.name();
        case CIFS:
            return AccessProtocol.CIFS.name();
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol accessProtocol, String template) {
    switch(accessProtocol) {
        case GLUSTER:
            return AccessProtocol.GLUSTER.value();
        case NFS:
            return AccessProtocol.NFS.value();
        case CIFS:
            return AccessProtocol.CIFS.value();
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol accessProtocol, String template) {
    switch(accessProtocol) {
        case GLUSTER:
            return AccessProtocol.GLUSTER.name();
        case NFS:
            return AccessProtocol.NFS.name();
        case CIFS:
            return AccessProtocol.CIFS.name();
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.GlusterStatus.class, to = GlusterState.class)
public static GlusterState map(org.ovirt.engine.core.common.businessentities.gluster.GlusterStatus glusterVolumeStatus, String template) {
    switch(glusterVolumeStatus) {
        case UP:
            return GlusterState.UP;
        case DOWN:
            return GlusterState.DOWN;
        default:
            return null;
    }
}
#end_block

#method_before
@Test
public void testFromBackendToRest() {
    testStatusMapping(GlusterVolumeStatus.UP, GlusterState.UP);
    testStatusMapping(GlusterVolumeStatus.DOWN, GlusterState.DOWN);
}
#method_after
@Test
public void testFromBackendToRest() {
    testStatusMapping(GlusterStatus.UP, GlusterState.UP);
    testStatusMapping(GlusterStatus.DOWN, GlusterState.DOWN);
}
#end_block

#method_before
private void testStatusMapping(GlusterVolumeStatus backendStatus, GlusterState restStatus) {
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setStatus(backendStatus);
    GlusterVolume restVolume = GlusterVolumeMapper.map(volume, null);
    assertEquals(restVolume.getState(), restStatus.value());
}
#method_after
private void testStatusMapping(GlusterStatus backendStatus, GlusterState restStatus) {
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setStatus(backendStatus);
    GlusterVolume restVolume = GlusterVolumeMapper.map(volume, null);
    assertEquals(restVolume.getStatus().getState(), restStatus.value());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (isActivateDeactivateAllowedForVmStatus(getVm().getstatus())) {
        // Hot activation in the host needs to be called only if the Vm is UP
        if (VmHandler.isHotPlugNicAllowedForVmStatus(getVm().getstatus())) {
            setVdsId(getVm().getrun_on_vds().getValue());
            returnValue = canPerformHotPlug();
            if (returnValue && !networkAttachedToVds(getNetworkName(), getVdsId())) {
                addCanDoActionMessage(VdcBllMessages.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
                returnValue = false;
            }
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        returnValue = false;
    }
    if (returnValue) {
        vmDevice = getVmDeviceDao().get(new VmDeviceId(getParameters().getNicId(), getParameters().getVmId()));
        if (vmDevice == null) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        }
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (isActivateDeactivateAllowedForVmStatus(getVm().getstatus())) {
        // HotPlug in the host needs to be called only if the Vm is UP
        if (VmHandler.isHotPlugNicAllowedForVmStatus(getVm().getstatus())) {
            setVdsId(getVm().getrun_on_vds().getValue());
            returnValue = canPerformHotPlug();
            if (returnValue && !networkAttachedToVds(getNetworkName(), getVdsId())) {
                addCanDoActionMessage(VdcBllMessages.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
                returnValue = false;
            }
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        returnValue = false;
    }
    if (returnValue) {
        vmDevice = getVmDeviceDao().get(new VmDeviceId(getParameters().getNicId(), getParameters().getVmId()));
        if (vmDevice == null) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        }
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getDiskImage() != null) {
        VDSReturnValue vdsReturnValue = performImageVdsmOperation();
        getReturnValue().getInternalTaskIdList().add(CreateTask(vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
        if (getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveDisk) {
            removeImageFromDB();
        }
    } else {
        log.warn("DiskImage is null, nothing to remove");
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (getDiskImage() != null) {
        VDSReturnValue vdsReturnValue = performImageVdsmOperation();
        getReturnValue().getInternalTaskIdList().add(CreateTask(vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
        if (getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveDisk) {
            removeImageFromDB(false);
        }
    } else {
        log.warn("DiskImage is null, nothing to remove");
    }
    setSucceeded(true);
}
#end_block

#method_before
private void removeImageFromDB() {
    final DiskImage diskImage = getDiskImage();
    updateSnapshotConfigWithoutImage(diskImage.getId());
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getDiskImageDynamicDAO().remove(diskImage.getImageId());
            Guid imageTemplate = diskImage.getit_guid();
            Guid currentGuid = diskImage.getImageId();
            // the storage).
            while (!currentGuid.equals(imageTemplate) && !currentGuid.equals(Guid.Empty)) {
                RemoveChildren(currentGuid);
                DiskImage image = getDiskImageDao().getSnapshotById(currentGuid);
                if (image != null) {
                    RemoveSnapshot(image);
                    currentGuid = image.getParentId();
                } else {
                    currentGuid = Guid.Empty;
                    log.warnFormat("'image' (snapshot of image '{0}') is null, cannot remove it.", diskImage.getImageId());
                }
            }
            getBaseDiskDao().remove(diskImage.getId());
            getVmDeviceDAO().remove(new VmDeviceId(diskImage.getId(), null));
            return null;
        }
    });
}
#method_after
private void removeImageFromDB(boolean isLockOnSnapshotsNeeded) {
    final DiskImage diskImage = getDiskImage();
    final List<Snapshot> updatedSnapshots;
    final boolean shouldPerformOpOnVmSnapshots = isLockOnSnapshotsNeeded && !diskImage.isShareable();
    try {
        if (shouldPerformOpOnVmSnapshots) {
            VM vm = getVmForNonShareableDiskImage(diskImage);
            lockVmSnapshotsWithWait(vm);
            updatedSnapshots = prepareSnapshotConfigWithoutImage(diskImage.getId());
        } else {
            updatedSnapshots = Collections.emptyList();
        }
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getDiskImageDynamicDAO().remove(diskImage.getImageId());
                Guid imageTemplate = diskImage.getit_guid();
                Guid currentGuid = diskImage.getImageId();
                // the storage).
                while (!currentGuid.equals(imageTemplate) && !currentGuid.equals(Guid.Empty)) {
                    RemoveChildren(currentGuid);
                    DiskImage image = getDiskImageDao().getSnapshotById(currentGuid);
                    if (image != null) {
                        RemoveSnapshot(image);
                        currentGuid = image.getParentId();
                    } else {
                        currentGuid = Guid.Empty;
                        log.warnFormat("'image' (snapshot of image '{0}') is null, cannot remove it.", diskImage.getImageId());
                    }
                }
                getBaseDiskDao().remove(diskImage.getId());
                getVmDeviceDAO().remove(new VmDeviceId(diskImage.getId(), null));
                for (Snapshot s : updatedSnapshots) {
                    getSnapshotDao().update(s);
                }
                return null;
            }
        });
    } finally {
        if (snapshotsEngineLock != null) {
            getLockManager().releaseLock(snapshotsEngineLock);
        }
    }
}
#end_block

#method_before
private void endCommand() {
    if (getParameters().getRemoveFromDB()) {
        removeImageFromDB();
    } else {
        getImageStorageDomainMapDao().remove(new image_storage_domain_map_id(getParameters().getImageId(), getParameters().getStorageDomainId()));
        UnLockImage();
    }
    setSucceeded(true);
}
#method_after
private void endCommand() {
    if (getParameters().getRemoveFromDB()) {
        removeImageFromDB(true);
    } else {
        getImageStorageDomainMapDao().remove(new image_storage_domain_map_id(getParameters().getImageId(), getParameters().getStorageDomainId()));
        UnLockImage();
    }
    setSucceeded(true);
}
#end_block

#method_before
protected boolean isAllowClusterWithVirtGluster() {
    Boolean allowVirGluster = Config.<Boolean>GetValue(ConfigValues.AllowClusterWithVirtGlusterEnabled);
    if (allowVirGluster == null) {
        allowVirGluster = Boolean.TRUE;
    }
    return allowVirGluster;
}
#method_after
protected boolean isAllowClusterWithVirtGluster() {
    Boolean allowVirGluster = Config.<Boolean>GetValue(ConfigValues.AllowClusterWithVirtGlusterEnabled);
    return allowVirGluster;
}
#end_block

#method_before
@Test
public void vdsGroupWithVirtGlusterServicesNotAllowed() {
    createCommandWithVirtGlusterEnabled();
    when(vdsGroupDAO.get(any(Guid.class))).thenReturn(createVdsGroupWithNoCpuName());
    when(vdsGroupDAO.getByName(anyString())).thenReturn(createVdsGroupWithNoCpuName());
    when(cmd.isAllowClusterWithVirtGluster()).thenReturn(false);
    cpuExists();
    allQueriesEmpty();
    canDoActionFailedWithReason(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
}
#method_after
@Test
public void vdsGroupWithVirtGlusterServicesNotAllowed() {
    createCommandWithVirtGlusterEnabled();
    when(vdsGroupDAO.get(any(Guid.class))).thenReturn(createVdsGroupWithNoCpuName());
    when(vdsGroupDAO.getByName(anyString())).thenReturn(createVdsGroupWithNoCpuName());
    mcr.mockConfigValue(ConfigValues.AllowClusterWithVirtGlusterEnabled, Boolean.FALSE);
    cpuExists();
    allQueriesEmpty();
    canDoActionFailedWithReason(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    boolean returnValue = super.canDoAction() && CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && CheckStorageDomainNameLengthValid();
    storage_domain_static oldDomain = DbFacade.getInstance().getStorageDomainStaticDAO().get(getStorageDomain().getId());
    // storage domain which is about to be updated.
    if (returnValue) {
        getStorageDomain().setLastTimeUsedAsMaster(oldDomain.getLastTimeUsedAsMaster());
    }
    // Collect changed fields to update in a list.
    List<String> props = ObjectIdentityChecker.GetChangedFields(oldDomain, getStorageDomain().getStorageStaticData());
    // Allow change only to name field
    props.remove("storage_name");
    if (returnValue && props.size() > 0) {
        log.errorFormat("There was an attempt to update the following fields although they are not allowed to be updated: {0}", StringUtils.join(props, ","));
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_DOMAIN_FIELDS);
        returnValue = false;
    }
    _storageDomainNameChanged = !StringHelper.EqOp(oldDomain.getstorage_name(), getStorageDomain().getstorage_name());
    // order to change description in spm
    if (returnValue && _storageDomainNameChanged && getStoragePool() != null && !((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(getStoragePool().getId())).getReturnValue()).booleanValue()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
        returnValue = false;
    }
    if (returnValue && _storageDomainNameChanged && IsStorageWithSameNameExists()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
        returnValue = false;
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    boolean returnValue = super.canDoAction() && CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && CheckStorageDomainNameLengthValid();
    storage_domain_static oldDomain = DbFacade.getInstance().getStorageDomainStaticDAO().get(getStorageDomain().getId());
    // storage domain which is about to be updated.
    if (returnValue) {
        getStorageDomain().setLastTimeUsedAsMaster(oldDomain.getLastTimeUsedAsMaster());
    }
    // Collect changed fields to update in a list.
    List<String> props = ObjectIdentityChecker.GetChangedFields(oldDomain, getStorageDomain().getStorageStaticData());
    // Allow change only to name field
    props.remove("storage_name");
    if (returnValue && props.size() > 0) {
        log.warnFormat("There was an attempt to update the following fields although they are not allowed to be updated: {0}", StringUtils.join(props, ","));
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_DOMAIN_FIELDS);
        returnValue = false;
    }
    _storageDomainNameChanged = !StringHelper.EqOp(oldDomain.getstorage_name(), getStorageDomain().getstorage_name());
    // order to change description in spm
    if (returnValue && _storageDomainNameChanged && getStoragePool() != null && !((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(getStoragePool().getId())).getReturnValue()).booleanValue()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
        returnValue = false;
    }
    if (returnValue && _storageDomainNameChanged && IsStorageWithSameNameExists()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
private void execute(LdapProviderType ldapProviderType, String domain) {
    Hashtable<String, String> env = new Hashtable<String, String>();
    LdapBrokerUtils.addLdapConfigValues(env);
    initContextVariables(env);
    Attributes results = null;
    DirContext ctx = null;
    try {
        ctx = createContext(env);
        LdapQueryData ldapQueryData = new LdapQueryDataImpl();
        ldapQueryData.setLdapQueryType(LdapQueryType.rootDSE);
        ldapQueryData.setDomain(domain);
        LdapQueryExecution queryExecution = LdapQueryExecutionBuilderImpl.getInstance().build(ldapProviderType, ldapQueryData);
        SearchControls searchControls = new SearchControls();
        searchControls.setReturningAttributes(queryExecution.getReturningAttributes());
        searchControls.setSearchScope(queryExecution.getSearchScope());
        // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
        searchControls.setReturningObjFlag(true);
        searchControls.setTimeLimit(Config.<Integer>GetValue(ConfigValues.LDAPOperationTimeout) * 1000);
        NamingEnumeration<SearchResult> search = ctx.search(queryExecution.getBaseDN(), queryExecution.getFilter(), searchControls);
        try {
            // build a map of attributes and their string values
            results = search.next().getAttributes();
        } finally {
            // make sure we close this search, otherwise the ldap connection will stick until GC kills it
            search.close();
        }
    } catch (NamingException e) {
        log.errorFormat("Failed to query rootDSE for LDAP server {0} due to {1}", ldapURI, e.getMessage());
        throw new RuntimeException(e);
    } finally {
        closeContext(ctx);
    }
    attributes = results;
}
#method_after
private void execute(LdapProviderType ldapProviderType, String domain) {
    Hashtable<String, String> env = new Hashtable<String, String>();
    LdapBrokerUtils.addLdapConfigValues(env);
    initContextVariables(env);
    Attributes results = null;
    DirContext ctx = null;
    try {
        ctx = createContext(env);
        LdapQueryData ldapQueryData = new LdapQueryDataImpl();
        ldapQueryData.setLdapQueryType(LdapQueryType.rootDSE);
        ldapQueryData.setDomain(domain);
        LdapQueryExecution queryExecution = LdapQueryExecutionBuilderImpl.getInstance().build(ldapProviderType, ldapQueryData);
        SearchControls searchControls = new SearchControls();
        searchControls.setReturningAttributes(queryExecution.getReturningAttributes());
        searchControls.setSearchScope(queryExecution.getSearchScope());
        // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
        searchControls.setReturningObjFlag(true);
        searchControls.setTimeLimit(Config.<Integer>GetValue(ConfigValues.LDAPOperationTimeout) * 1000);
        NamingEnumeration<SearchResult> search = ctx.search(queryExecution.getBaseDN(), queryExecution.getFilter(), searchControls);
        try {
            // build a map of attributes and their string values
            results = search.next().getAttributes();
        } finally {
            // make sure we close this search, otherwise the ldap connection will stick until GC kills it
            search.close();
        }
    } catch (NamingException e) {
        log.errorFormat("Failed to query rootDSE for LDAP server {0} due to {1}", ldapURI, e.getMessage());
        throw new DirectoryServiceException(e);
    } finally {
        closeContext(ctx);
    }
    attributes = results;
}
#end_block

#method_before
private void execute(LdapProviderType ldapProviderType, String domain) {
    Hashtable<String, String> env = new Hashtable<String, String>();
    int timeLimit = Config.<Integer>GetValue(ConfigValues.LDAPQueryTimeout) * 1000;
    env.put("com.sun.jndi.ldap.connect.timeout", Long.toString(timeLimit));
    initContextVariables(env);
    Attributes results = null;
    DirContext ctx = null;
    try {
        ctx = createContext(env);
        LdapQueryData ldapQueryData = new LdapQueryDataImpl();
        ldapQueryData.setLdapQueryType(LdapQueryType.rootDSE);
        ldapQueryData.setDomain(domain);
        LdapQueryExecution queryExecution = LdapQueryExecutionBuilderImpl.getInstance().build(ldapProviderType, ldapQueryData);
        SearchControls searchControls = new SearchControls();
        searchControls.setReturningAttributes(queryExecution.getReturningAttributes());
        searchControls.setSearchScope(queryExecution.getSearchScope());
        // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
        searchControls.setReturningObjFlag(true);
        searchControls.setTimeLimit(timeLimit);
        NamingEnumeration<SearchResult> search = ctx.search(queryExecution.getBaseDN(), queryExecution.getFilter(), searchControls);
        try {
            // build a map of attributes and their string values
            results = search.next().getAttributes();
        } finally {
            // make sure we close this search, otherwise the ldap connection will stick until GC kills it
            search.close();
        }
    } catch (NamingException e) {
        log.errorFormat("Failed to query rootDSE for LDAP server {0} due to {1}", ldapURI, e.getMessage());
    } finally {
        closeContext(ctx);
    }
    attributes = results;
}
#method_after
private void execute(LdapProviderType ldapProviderType, String domain) {
    Hashtable<String, String> env = new Hashtable<String, String>();
    LdapBrokerUtils.addLdapConfigValues(env);
    initContextVariables(env);
    Attributes results = null;
    DirContext ctx = null;
    try {
        ctx = createContext(env);
        LdapQueryData ldapQueryData = new LdapQueryDataImpl();
        ldapQueryData.setLdapQueryType(LdapQueryType.rootDSE);
        ldapQueryData.setDomain(domain);
        LdapQueryExecution queryExecution = LdapQueryExecutionBuilderImpl.getInstance().build(ldapProviderType, ldapQueryData);
        SearchControls searchControls = new SearchControls();
        searchControls.setReturningAttributes(queryExecution.getReturningAttributes());
        searchControls.setSearchScope(queryExecution.getSearchScope());
        // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
        searchControls.setReturningObjFlag(true);
        searchControls.setTimeLimit(Config.<Integer>GetValue(ConfigValues.LDAPOperationTimeout) * 1000);
        NamingEnumeration<SearchResult> search = ctx.search(queryExecution.getBaseDN(), queryExecution.getFilter(), searchControls);
        try {
            // build a map of attributes and their string values
            results = search.next().getAttributes();
        } finally {
            // make sure we close this search, otherwise the ldap connection will stick until GC kills it
            search.close();
        }
    } catch (NamingException e) {
        log.errorFormat("Failed to query rootDSE for LDAP server {0} due to {1}", ldapURI, e.getMessage());
    } finally {
        closeContext(ctx);
    }
    attributes = results;
}
#end_block

#method_before
protected boolean validateShareableDisk() {
    if (DiskStorageType.LUN == _oldDisk.getDiskStorageType()) {
        return true;
    }
    boolean isDiskUpdatedToShareable = getParameters().getDiskInfo().isShareable();
    boolean isDiskShareable = _oldDisk.isShareable();
    // Check if VM is not during snapshot.
    if (ImagesHandler.isVmInPreview(getVmId())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        return false;
    }
    // If user want to update the disk to be shareable then update the vm snapshot id to be null.
    if (!isDiskShareable && isDiskUpdatedToShareable) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(_oldDisk.getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) _oldDisk).getit_guid())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
            return false;
        }
        if (!isVersionSupportedForShareable(_oldDisk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
            return false;
        }
        ((DiskImage) _oldDisk).setvm_snapshot_id(null);
    } else if (isDiskShareable && !isDiskUpdatedToShareable) {
        if (getVmDAO().getVmsListForDisk(_oldDisk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
            return false;
        }
        // If disk is not floating, then update its vm snapshot id to the active VM snapshot.
        ((DiskImage) _oldDisk).setvm_snapshot_id(DbFacade.getInstance().getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE).getValue());
    }
    return true;
}
#method_after
protected boolean validateShareableDisk() {
    if (DiskStorageType.LUN == _oldDisk.getDiskStorageType()) {
        return true;
    }
    boolean isDiskUpdatedToShareable = getParameters().getDiskInfo().isShareable();
    boolean isDiskShareable = _oldDisk.isShareable();
    // Check if VM is not during snapshot.
    if (getSnapshotDao().exists(getVmId(), SnapshotStatus.IN_PREVIEW)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        return false;
    }
    // If user want to update the disk to be shareable then update the vm snapshot id to be null.
    if (!isDiskShareable && isDiskUpdatedToShareable) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(_oldDisk.getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) _oldDisk).getit_guid())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
            return false;
        }
        if (!isVersionSupportedForShareable(_oldDisk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
            return false;
        }
        DiskImage diskImage = (DiskImage) getParameters().getDiskInfo();
        if (!isVolumeFormatSupportedForShareable(diskImage.getvolume_format())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
            return false;
        }
        diskImage.setvm_snapshot_id(null);
    } else if (isDiskShareable && !isDiskUpdatedToShareable) {
        if (getVmDAO().getVmsListForDisk(_oldDisk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
            return false;
        }
        // If disk is not floating, then update its vm snapshot id to the active VM snapshot.
        ((DiskImage) _oldDisk).setvm_snapshot_id(DbFacade.getInstance().getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE).getValue());
    }
    return true;
}
#end_block

#method_before
@Override
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (getStoragePool() != null && getQuotaId() != null && !getStoragePool().getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED)) {
        quotaPermissionList.add(new PermissionSubject(getQuotaId(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
    }
}
#method_after
@Override
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (getStoragePool() != null && getQuotaId() != null && !getStoragePool().getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED)) {
        if (canPerformQuotaValidation()) {
            quotaPermissionList.add(new PermissionSubject(getQuotaId(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
        }
    }
}
#end_block

#method_before
private String getPrintableConnectionsList() {
    StringBuilder sb = new StringBuilder();
    for (storage_server_connections con : getConnectionList()) {
        sb.append("{ id: ");
        sb.append(con.getid());
        sb.append(", connection: ");
        sb.append(con.getconnection());
        sb.append(", iqn: ");
        sb.append(con.getiqn());
        sb.append(", vfsType: ");
        sb.append(con.getVfsType());
        sb.append(", mountOptions: ");
        sb.append(con.getMountOptions());
        sb.append(", nfsVersion: ");
        sb.append(con.getNfsVersion());
        sb.append(", nfsRetrans: ");
        sb.append(con.getNfsRetrans());
        sb.append(", nfsTimeo: ");
        sb.append(con.getNfsTimeo());
        sb.append(" };");
    }
    return sb.toString();
}
#method_after
private String getPrintableConnectionsList() {
    StringBuilder sb = new StringBuilder();
    for (storage_server_connections con : getConnectionList()) {
        sb.append(con);
    }
    return sb.toString();
}
#end_block

#method_before
private VolumeType getVolumeType() {
    return (getStoragePool().getstorage_pool_type() == StorageType.NFS || getStoragePool().getstorage_pool_type() == StorageType.LOCALFS) ? VolumeType.Sparse : VolumeType.Preallocated;
}
#method_after
private VolumeType getVolumeType() {
    return (getStoragePool().getstorage_pool_type().isFileDomain()) ? VolumeType.Sparse : VolumeType.Preallocated;
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, List<DiskImage> disks, List<VmNetworkInterface> ifaces) {
    Guid id;
    VM vm = DbFacade.getInstance().getVmDAO().get(dstId);
    VmBase vmBase = (vm != null) ? vm.getStaticData() : null;
    int diskCount = 0;
    int ifaceCount = 0;
    boolean isVm = (vmBase != null);
    if (!isVm) {
        vmBase = DbFacade.getInstance().getVmTemplateDAO().get(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    String isoPath = vmBase.getiso_path();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    for (VmDevice device : devices) {
        id = Guid.NewGuid();
        Map<String, Object> specParams = new HashMap<String, Object>();
        if (srcId.equals(Guid.Empty)) {
            // update number of monitors
            updateNumOfMonitorsInVmDevice(null, vmBase);
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.NewGuid(), dstId), VmDeviceType.DISK, VmDeviceType.CDROM, specParams, true, true);
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(null, vmBase, vm.isBalloonEnabled());
            // skip other Blank template devices
            break;
        }
        if (VmDeviceType.DISK.getName().equals(device.getType()) && VmDeviceType.DISK.getName().equals(device.getDevice())) {
            if (diskCount < disks.size()) {
                id = (disks.get(diskCount++)).getId();
            }
        } else if (VmDeviceType.INTERFACE.getName().equals(device.getType())) {
            if (ifaceCount < ifaces.size()) {
                id = ifaces.get(ifaceCount++).getId();
            }
        } else if (VmDeviceType.VIDEO.getName().equals(device.getType())) {
            specParams.putAll(getMemExpr(vmBase.getnum_of_monitors()));
        } else if (VmDeviceType.DISK.getName().equals(device.getType()) && VmDeviceType.CDROM.getName().equals(device.getDevice())) {
            // check here is source VM had CD (Vm from snapshot)
            String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
            shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
            if (!hasAlreadyCD && shouldHaveCD) {
                setCdPath(specParams, srcCdPath, isoPath);
            } else {
                // CD already exists
                continue;
            }
        } else if (VmDeviceType.BALLOON.getName().equals(device.getType())) {
            specParams.put(VdsProperties.Model, VdsProperties.Virtio);
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    // if destination is a VM , update devices boot order
    if (isVm) {
        updateBootOrderInVmDevice(vmBase);
        // create sound card for a desktop VM if not exists
        if (vmBase.getvm_type() == VmType.Desktop) {
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(vmBase.getId(), VmDeviceType.SOUND.getName());
            if (list.size() == 0) {
                String soundDevice = VmInfoBuilderBase.getSoundDevice(vm);
                addManagedDevice(new VmDeviceId(Guid.NewGuid(), vmBase.getId()), VmDeviceType.SOUND, VmDeviceType.getSoundDeviceType(soundDevice), new HashMap<String, Object>(), true, true);
            }
        }
    }
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, List<DiskImage> disks, List<VmNetworkInterface> ifaces) {
    Guid id;
    VM vm = DbFacade.getInstance().getVmDAO().get(dstId);
    VmBase vmBase = (vm != null) ? vm.getStaticData() : null;
    int diskCount = 0;
    int ifaceCount = 0;
    boolean isVm = (vmBase != null);
    if (!isVm) {
        vmBase = DbFacade.getInstance().getVmTemplateDAO().get(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    String isoPath = vmBase.getiso_path();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    for (VmDevice device : devices) {
        id = Guid.NewGuid();
        Map<String, Object> specParams = new HashMap<String, Object>();
        if (srcId.equals(Guid.Empty)) {
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.NewGuid(), dstId), VmDeviceType.DISK, VmDeviceType.CDROM, specParams, true, true);
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(null, vmBase, vm.isBalloonEnabled());
        }
        if (VmDeviceType.DISK.getName().equals(device.getType()) && VmDeviceType.DISK.getName().equals(device.getDevice())) {
            if (diskCount < disks.size()) {
                id = (disks.get(diskCount++)).getId();
            }
        } else if (VmDeviceType.INTERFACE.getName().equals(device.getType())) {
            if (ifaceCount < ifaces.size()) {
                id = ifaces.get(ifaceCount++).getId();
            }
        } else if (VmDeviceType.VIDEO.getName().equals(device.getType())) {
            if (isVm) {
                // to the new VMStatic params
                continue;
            } else {
                specParams.putAll(getMemExpr(vmBase.getnum_of_monitors()));
            }
        } else if (VmDeviceType.DISK.getName().equals(device.getType()) && VmDeviceType.CDROM.getName().equals(device.getDevice())) {
            // check here is source VM had CD (Vm from snapshot)
            String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
            shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
            if (!hasAlreadyCD && shouldHaveCD) {
                setCdPath(specParams, srcCdPath, isoPath);
            } else {
                // CD already exists
                continue;
            }
        } else if (VmDeviceType.BALLOON.getName().equals(device.getType())) {
            specParams.put(VdsProperties.Model, VdsProperties.Virtio);
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    if (isVm) {
        // update devices boot order
        updateBootOrderInVmDevice(vmBase);
        // create sound card for a desktop VM if not exists
        if (vmBase.getvm_type() == VmType.Desktop) {
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(vmBase.getId(), VmDeviceType.SOUND.getName());
            if (list.size() == 0) {
                String soundDevice = VmInfoBuilderBase.getSoundDevice(vm);
                addManagedDevice(new VmDeviceId(Guid.NewGuid(), vmBase.getId()), VmDeviceType.SOUND, VmDeviceType.getSoundDeviceType(soundDevice), new HashMap<String, Object>(), true, true);
            }
        }
        int numOfMonitors = (vm.getdisplay_type() == DisplayType.vnc) ? Math.max(1, vm.getnum_of_monitors()) : vm.getnum_of_monitors();
        // create Video device. Multiple if display type is spice
        for (int i = 0; i < numOfMonitors; i++) {
            addVideoDevice(vm);
        }
    }
}
#end_block

#method_before
private static void updateNumOfMonitorsInVmDevice(VmBase oldVmBase, VmBase newStatic) {
    int prevNumOfMonitors = 0;
    if (oldVmBase != null) {
        prevNumOfMonitors = oldVmBase.getnum_of_monitors();
    }
    if (newStatic.getnum_of_monitors() > prevNumOfMonitors) {
        // monitors were added
        for (int i = prevNumOfMonitors; i < newStatic.getnum_of_monitors(); i++) {
            Guid newId = Guid.NewGuid();
            VmDeviceUtils.addManagedDevice(new VmDeviceId(newId, newStatic.getId()), VmDeviceType.VIDEO, getDeviceDisplayType(newStatic.getdefault_display_type()), getMemExpr(newStatic.getnum_of_monitors()), true, false);
        }
    } else {
        // delete video cards
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newStatic.getId(), VmDeviceType.VIDEO.getName());
        removeNumberOfDevices(list, prevNumOfMonitors - newStatic.getnum_of_monitors());
    }
}
#method_after
private static void updateNumOfMonitorsInVmDevice(VmBase oldVmBase, VmBase newStatic) {
    int prevNumOfMonitors = 0;
    if (oldVmBase != null) {
        prevNumOfMonitors = oldVmBase.getnum_of_monitors();
    }
    if (newStatic.getnum_of_monitors() > prevNumOfMonitors) {
        // monitors were added
        for (int i = prevNumOfMonitors; i < newStatic.getnum_of_monitors(); i++) {
            Guid newId = Guid.NewGuid();
            VmDeviceUtils.addManagedDevice(new VmDeviceId(newId, newStatic.getId()), VmDeviceType.VIDEO, VmDeviceType.QXL, getMemExpr(newStatic.getnum_of_monitors()), true, false);
        }
    } else {
        // delete video cards
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newStatic.getId(), VmDeviceType.VIDEO.getName());
        removeNumberOfDevices(list, prevNumOfMonitors - newStatic.getnum_of_monitors());
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (disk == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk && ((DiskImage) disk).getimageStatus() == ImageStatus.ILLEGAL) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        return false;
    }
    retValue = retValue && acquireLockInternal() && isVmExist() && isVmUpOrDown() && isDiskCanBeAddedToVm(disk) && isDiskPassPCIAndIDELimit(disk);
    if (retValue && getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (retValue && disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (retValue && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHARABLE_DISK_ALREADY_ATTACHED);
    }
    if (retValue && isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getstorage_ids().get(0), getVm().getstorage_pool_id())) == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (retValue && isImageDisk) {
        retValue = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVm().getId()));
    }
    if (retValue && getParameters().isPlugUnPlug() && getVm().getstatus() != VMStatus.Down) {
        retValue = isOSSupportingHotPlug() && isHotPlugSupported() && isInterfaceSupportedForPlugUnPlug(disk);
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (disk == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk && ((DiskImage) disk).getimageStatus() == ImageStatus.ILLEGAL) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        return false;
    }
    retValue = retValue && acquireLockInternal() && isVmExist() && isVmUpOrDown() && isDiskCanBeAddedToVm(disk) && isDiskPassPCIAndIDELimit(disk);
    if (retValue && getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (retValue && disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (retValue && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (retValue && isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getstorage_ids().get(0), getVm().getstorage_pool_id())) == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (retValue && isImageDisk) {
        retValue = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVm().getId()));
    }
    if (retValue && getParameters().isPlugUnPlug() && getVm().getstatus() != VMStatus.Down) {
        retValue = isOSSupportingHotPlug() && isHotPlugSupported() && isInterfaceSupportedForPlugUnPlug(disk);
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    lockVmWithCompensationIfNeeded();
    if (!isInternalExecution()) {
        freeLock();
    }
    restoreSnapshotAndRemoveObsoleteSnapshots();
    VdcReturnValueBase returnValue = null;
    for (DiskImage image : getImagesList()) {
        if (image.getimageStatus() != ImageStatus.ILLEGAL) {
            ImagesContainterParametersBase params = new RestoreFromSnapshotParameters(image.getImageId(), getVmId(), targetSnapshot, removedSnapshotId);
            returnValue = runAsyncTask(VdcActionType.RestoreFromSnapshot, params);
        }
    }
    if (getImagesList().size() > 0) {
        // change its status from Image lock.
        if (getTaskIdList().size() == 0) {
            log.errorFormat("Can't restore snapshot for VM, since no destroyImage task could be established in the VDSM.");
            if (returnValue != null) {
                getReturnValue().setFault(returnValue.getFault());
                return;
            }
        } else {
            setSucceeded(true);
        }
        deleteOrphanedImages();
        removeSnapshotsFromDB();
    } else {
        removeSnapshotsFromDB();
        EndVmCommand();
        setSucceeded(true);
    }
}
#method_after
@Override
protected void ExecuteVmCommand() {
    if (!getImagesList().isEmpty()) {
        lockVmWithCompensationIfNeeded();
        if (!isInternalExecution()) {
            freeLock();
        }
    }
    restoreSnapshotAndRemoveObsoleteSnapshots();
    boolean succeeded = true;
    for (DiskImage image : getImagesList()) {
        if (image.getimageStatus() != ImageStatus.ILLEGAL) {
            ImagesContainterParametersBase params = new RestoreFromSnapshotParameters(image.getImageId(), getVmId(), targetSnapshot, removedSnapshotId);
            VdcReturnValueBase returnValue = runAsyncTask(VdcActionType.RestoreFromSnapshot, params);
            // Save the first fault
            if (succeeded && !returnValue.getSucceeded()) {
                succeeded = false;
                getReturnValue().setFault(returnValue.getFault());
            }
        }
    }
    removeSnapshotsFromDB();
    if (!getTaskIdList().isEmpty()) {
        deleteOrphanedImages();
    } else {
        endActionOnVmConfiguration();
    }
    setSucceeded(succeeded);
}
#end_block

#method_before
protected void deleteOrphanedImages() {
    VdcReturnValueBase returnValue;
    boolean noImagesRemovedYet = getTaskIdList().isEmpty();
    List<Guid> deletedDisksIds = new ArrayList<Guid>();
    for (DiskImage image : getDiskImageDAO().getImagesWithNoDisk(getVm().getId())) {
        if (!deletedDisksIds.contains(image.getimage_group_id())) {
            deletedDisksIds.add(image.getimage_group_id());
            returnValue = runAsyncTask(VdcActionType.RemoveImage, new RemoveImageParameters(image.getImageId()));
            if (!returnValue.getSucceeded() && noImagesRemovedYet) {
                setSucceeded(false);
                getReturnValue().setFault(returnValue.getFault());
                return;
            }
            noImagesRemovedYet = false;
        }
    }
}
#method_after
protected void deleteOrphanedImages() {
    VdcReturnValueBase returnValue;
    boolean noImagesRemovedYet = getTaskIdList().isEmpty();
    List<Guid> deletedDisksIds = new ArrayList<Guid>();
    for (DiskImage image : getDiskImageDAO().getImagesWithNoDisk(getVm().getId())) {
        if (!deletedDisksIds.contains(image.getId())) {
            deletedDisksIds.add(image.getId());
            returnValue = runAsyncTask(VdcActionType.RemoveImage, new RemoveImageParameters(image.getImageId()));
            if (!returnValue.getSucceeded() && noImagesRemovedYet) {
                setSucceeded(false);
                getReturnValue().setFault(returnValue.getFault());
                return;
            }
            noImagesRemovedYet = false;
        }
    }
}
#end_block

#method_before
protected void prepareToDeletePreviewBranch() {
    removedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.PREVIEW);
    Guid previewedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.REGULAR, SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(previewedSnapshotId, SnapshotStatus.OK);
    snapshotsToRemove.add(removedSnapshotId);
    List<DiskImage> images = getDiskImageDAO().getAllSnapshotsForVmSnapshot(removedSnapshotId);
    for (DiskImage image : images) {
        DiskImage parentImage = getDiskImageDAO().getSnapshotById(image.getParentId());
        NGuid snapshotToRemove = (parentImage == null) ? null : parentImage.getvm_snapshot_id();
        while (parentImage != null && snapshotToRemove != null && !snapshotToRemove.equals(previewedSnapshotId)) {
            if (snapshotToRemove != null && !snapshotsToRemove.contains(snapshotToRemove.getValue())) {
                snapshotsToRemove.add(snapshotToRemove.getValue());
            }
            parentImage = getDiskImageDAO().getSnapshotById(parentImage.getParentId());
            snapshotToRemove = (parentImage == null) ? null : parentImage.getvm_snapshot_id();
        }
    }
}
#method_after
protected void prepareToDeletePreviewBranch() {
    removedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.PREVIEW);
    Guid previewedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.REGULAR, SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(previewedSnapshotId, SnapshotStatus.OK);
    snapshotsToRemove.add(removedSnapshotId);
    List<DiskImage> images = getDiskImageDAO().getAllSnapshotsForVmSnapshot(removedSnapshotId);
    for (DiskImage image : images) {
        DiskImage parentImage = getDiskImageDAO().getSnapshotById(image.getParentId());
        NGuid snapshotToRemove = (parentImage == null) ? null : parentImage.getvm_snapshot_id();
        while (parentImage != null && snapshotToRemove != null && !snapshotToRemove.equals(previewedSnapshotId)) {
            if (!snapshotsToRemove.contains(snapshotToRemove.getValue())) {
                snapshotsToRemove.add(snapshotToRemove.getValue());
            }
            parentImage = getDiskImageDAO().getSnapshotById(parentImage.getParentId());
            snapshotToRemove = (parentImage == null) ? null : parentImage.getvm_snapshot_id();
        }
    }
}
#end_block

