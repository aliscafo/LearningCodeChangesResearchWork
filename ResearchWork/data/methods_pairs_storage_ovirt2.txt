894
#method_before
@Override
protected void executeVdsBrokerCommand() {
    log.info("-- executeIrsBrokerCommand: calling an image action command. parameters:");
    log.info("++ spId={}", getParameters().getStoragePoolId());
    log.info("++ sdId={}", getParameters().getStorageDomainId());
    log.info("++ image group Id={}", getParameters().getImageGroupId());
    log.info("++ image Id={}", getParameters().getImageId());
    status = executeImageActionVdsBrokerCommand(getParameters().getStoragePoolId().toString(), getParameters().getStorageDomainId().toString(), getParameters().getImageGroupId().toString(), getParameters().getImageId().toString());
    proceedProxyReturnValue();
    setReturnValue(status);
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    status = executeImageActionVdsBrokerCommand(getParameters().getStoragePoolId().toString(), getParameters().getStorageDomainId().toString(), getParameters().getImageGroupId().toString(), getParameters().getImageId().toString());
    proceedProxyReturnValue();
    setReturnValue(status);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.USER_ADD_PROFILE : AuditLogType.USER_ADD_PROFILE_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    UserProfile existingProfile = getUserProfile();
    if (existingProfile != null) {
        /* same as executeCommand below */
        return getSucceeded() ? AuditLogType.USER_UPDATE_PROFILE : AuditLogType.USER_UPDATE_PROFILE_FAILED;
    } else {
        return getSucceeded() ? AuditLogType.USER_ADD_PROFILE : AuditLogType.USER_ADD_PROFILE_FAILED;
    }
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__ADD);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__USER_PROFILE);
}
#method_after
@Override
protected void setActionMessageParameters() {
    UserProfile existingProfile = getUserProfile();
    if (existingProfile != null && isSSHPublicKeyUpdate(existingProfile)) {
        addValidationMessage(EngineMessage.VAR__ACTION__UPDATE);
    } else {
        addValidationMessage(EngineMessage.VAR__ACTION__ADD);
    }
    addValidationMessage(EngineMessage.VAR__TYPE__USER_PROFILE);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (needSSHPublicKeyUpdate) {
        executeCommandUpdate();
    } else {
        executeCommandAdd();
    }
}
#method_after
@Override
protected void executeCommand() {
    UserProfile existingProfile = getUserProfile();
    if (existingProfile != null) {
        /*
             * if validate() allowed us to get this far, then we must expect
             * isSSHPublicKeyUpdate(existingProfile) == true
             */
        executeCommandUpdateSSHPublicKey(existingProfile);
    } else {
        UserProfile profile = getParameters().getUserProfile();
        profile.setId(Guid.newGuid());
        profile.setUserId(getUserId());
        /* must be overridden */
        if (!StringUtils.isEmpty(profile.getSshPublicKey())) {
            profile.setSshPublicKeyId(Guid.newGuid());
        }
        userProfileDao.save(profile);
        setSucceeded(true);
    }
}
#end_block

#method_before
private boolean isSSHPublicKeyUpdate() {
    UserProfile existingProfile = getUserProfile();
    if (existingProfile != null) {
        /* fake Add on key which was blanked previously (rhbz#1283499) */
        if (StringUtils.isEmpty(existingProfile.getSshPublicKey()) && !StringUtils.isEmpty(getParameters().getUserProfile().getSshPublicKey())) {
            needSSHPublicKeyUpdate = true;
        }
    }
    return needSSHPublicKeyUpdate;
}
#method_after
private boolean isSSHPublicKeyUpdate(UserProfile existingProfile) {
    /* fake Add on key which was wiped previously (rhbz#1283499) */
    if (StringUtils.isEmpty(existingProfile.getSshPublicKey()) && !StringUtils.isEmpty(getParameters().getUserProfile().getSshPublicKey())) {
        return true;
    }
    return false;
}
#end_block

#method_before
private void collectVmPrestartFailureReasons(Map<String, Integer> failureReasons, List<String> messages) {
    if (log.isInfoEnabled()) {
        String reason = messages.stream().filter(msg -> ENGINE_MESSAGES.contains(msg)).collect(Collectors.joining(", "));
        Integer count = failureReasons.get(reason);
        failureReasons.put(reason, count == null ? 1 : count + 1);
    }
}
#method_after
private void collectVmPrestartFailureReasons(Map<String, Integer> failureReasons, List<String> messages) {
    if (log.isInfoEnabled()) {
        String reason = messages.stream().filter(EngineMessage::contains).collect(Collectors.joining(", "));
        Integer count = failureReasons.get(reason);
        failureReasons.put(reason, count == null ? 1 : count + 1);
    }
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    return getParameters().isUseCinderCommandCallback() ? new ConcurrentChildCommandsExecutionCallback() : null;
}
#method_after
@Override
public CommandCallback getCallback() {
    return (getParameters().isUseCinderCommandCallback() && getFlow().isStateless()) ? new ConcurrentChildCommandsExecutionCallback() : null;
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    return getParameters().isUseCinderCommandCallback() ? new ConcurrentChildCommandsExecutionCallback() : null;
}
#method_after
@Override
public CommandCallback getCallback() {
    return (getParameters().isUseCinderCommandCallback() && getFlow().isStateless()) ? new ConcurrentChildCommandsExecutionCallback() : null;
}
#end_block

#method_before
private CreateAllSnapshotsFromVmParameters buildCreateSnapshotParametersForEndAction() {
    CreateAllSnapshotsFromVmParameters parameters = buildCreateSnapshotParameters();
    parameters.setImagesParameters(getParameters().getImagesParameters());
    return parameters;
}
#method_after
private CreateAllSnapshotsFromVmParameters buildCreateSnapshotParametersForEndAction() {
    CreateAllSnapshotsFromVmParameters parameters = buildCreateSnapshotParameters();
    parameters.setImagesParameters(getParameters().getImagesParameters());
    if (getParameters().isUseCinderCommandCallback()) {
        parameters.setShouldBeEndedByParent(false);
        parameters.setCommandId(getParametersForChildCommand().get(0).getCommandId());
    }
    return parameters;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (isStatelessSnapshotExistsForVm()) {
        getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, getCreateAllSnapshotFromVmParameters(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), createContextForRunStatelessVm()).getSucceeded());
        if (!getSucceeded()) {
            getParameters().setShouldBeLogged(true);
            log.error("Could not run VM '{}' ({}) in stateless mode", getVm().getName(), getVm().getId());
            // could not run the vm don't try to run the end action again
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#method_after
@Override
protected void endSuccessfully() {
    if (isStatelessSnapshotExistsForVm()) {
        getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, buildCreateSnapshotParametersForEndAction(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), createContextForRunStatelessVm()).getSucceeded());
        if (!getSucceeded()) {
            getParameters().setShouldBeLogged(true);
            log.error("Could not run VM '{}' ({}) in stateless mode", getVm().getName(), getVm().getId());
            // could not run the vm don't try to run the end action again
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    if (isStatelessSnapshotExistsForVm()) {
        VdcReturnValueBase vdcReturnValue = getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, getCreateAllSnapshotFromVmParameters(), cloneContext().withoutExecutionContext().withoutLock());
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snapshot.
    } else {
        super.endWithFailure();
    }
}
#method_after
@Override
protected void endWithFailure() {
    if (isStatelessSnapshotExistsForVm()) {
        VdcReturnValueBase vdcReturnValue = getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, buildCreateSnapshotParametersForEndAction(), cloneContext().withoutExecutionContext().withoutLock());
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snapshot.
    } else {
        super.endWithFailure();
    }
}
#end_block

#method_before
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    Version vmCustomCompatibilityVersion = vm.getCustomCompatibilityVersion();
    List<VDS> hostsToRunOn = new ArrayList<>();
    /* get required compatibility version */
    if (vmCustomCompatibilityVersion == null) {
        // use cluster default - all hosts are valid
        return hosts;
    }
    /* find compatible hosts */
    for (VDS host : hosts) {
        if (host.getSupportedENGINESVersionsSet().contains(vmCustomCompatibilityVersion)) {
            hostsToRunOn.add(host);
            log.debug("Host {} wasn't filtered out as it supports the VM required compatibility version({})", host.getName(), vmCustomCompatibilityVersion);
        } else {
            log.debug("Host {} was filtered out as it doesn't support the VM required compatibility-version ({}). Host supported compatibility-versions are: {}.", host.getName(), vmCustomCompatibilityVersion, host.getSupportedEngines());
            messages.addMessage(host.getId(), String.format("$vmCompatibilityVersions %1$s", vmCustomCompatibilityVersion));
            messages.addMessage(host.getId(), String.format("$hostCompatibilityVersions %1$s", host.getSupportedEngines()));
            messages.addMessage(host.getId(), EngineMessage.VAR__DETAIL__UNSUPPORTED_COMPATIBILITY_VERSION.toString());
        }
    }
    return hostsToRunOn;
}
#method_after
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    // get required compatibility version
    Version vmCustomCompatibilityVersion = vm.getCustomCompatibilityVersion();
    if (vmCustomCompatibilityVersion == null) {
        // use cluster default - all hosts are valid
        return hosts;
    }
    // find compatible hosts
    List<VDS> hostsToRunOn = new ArrayList<>();
    for (VDS host : hosts) {
        if (host.getSupportedENGINESVersionsSet().contains(vmCustomCompatibilityVersion)) {
            hostsToRunOn.add(host);
            log.debug("Host {} wasn't filtered out as it supports the VM required compatibility version({})", host.getName(), vmCustomCompatibilityVersion);
        } else {
            log.debug("Host {} was filtered out as it doesn't support the VM required compatibility-version ({}). Host supported compatibility-versions are: {}.", host.getName(), vmCustomCompatibilityVersion, host.getSupportedEngines());
            messages.addMessage(host.getId(), String.format("$vmCompatibilityVersions %1$s", vmCustomCompatibilityVersion));
            messages.addMessage(host.getId(), String.format("$hostCompatibilityVersions %1$s", host.getSupportedEngines()));
            messages.addMessage(host.getId(), EngineMessage.VAR__DETAIL__UNSUPPORTED_COMPATIBILITY_VERSION.toString());
        }
    }
    return hostsToRunOn;
}
#end_block

#method_before
@Test
public void testFilterNicsWithUnmanagedNetworks() {
    List<VdsNetworkInterface> existingInterfaces = new ArrayList<VdsNetworkInterface>();
    for (int i = 0; i < 10; i++) {
        Nic nic = new Nic();
        nic.setName("eth" + i);
        // all even are unmanaged:
        NetworkImplementationDetails networkImplementationDetails = new NetworkImplementationDetails(true, i % 2 == 1);
        nic.setNetworkImplementationDetails(networkImplementationDetails);
        existingInterfaces.add(nic);
    }
    UnmanagedNetworkValidator validator = new UnmanagedNetworkValidator();
    List<VdsNetworkInterface> unmanagedNicsList = validator.filterNicsWithUnmanagedNetworks(existingInterfaces, new HashSet<String>());
    assertEquals(5, unmanagedNicsList.size());
    for (int i = 0; i < 5; i++) {
        assertEquals("eth" + (i * 2), unmanagedNicsList.get(i).getName());
    }
}
#method_after
@Test
public void testFilterNicsWithUnmanagedNetworks() {
    VdsNetworkInterface nicManaged = createNicWithNetworkImplementationDetails("eth0", true);
    VdsNetworkInterface nicUnmanaged = createNicWithNetworkImplementationDetails("eth1", false);
    List<VdsNetworkInterface> existingInterfaces = Arrays.asList(nicManaged, nicUnmanaged);
    Set<String> unmanagedNicsSet = validator.filterNicsWithUnmanagedNetworks(existingInterfaces, Collections.emptySet());
    assertEquals(1, unmanagedNicsSet.size());
    assertTrue(unmanagedNicsSet.contains("eth1"));
}
#end_block

#method_before
@Test
public void testFilterNicsWithUnmanagedNetworksNetworkImplementationDetailsIsNull() {
    List<VdsNetworkInterface> existingInterfaces = new ArrayList<VdsNetworkInterface>();
    for (int i = 0; i < 10; i++) {
        // networkImplementationDetails is null
        Nic nic = new Nic();
        nic.setName("eth" + i);
        existingInterfaces.add(nic);
    }
    UnmanagedNetworkValidator validator = new UnmanagedNetworkValidator();
    List<VdsNetworkInterface> unmanagedNicsList = validator.filterNicsWithUnmanagedNetworks(existingInterfaces, new HashSet<String>());
    assertTrue(unmanagedNicsList.isEmpty());
}
#method_after
@Test
public void testFilterNicsWithUnmanagedNetworksNetworkImplementationDetailsIsNull() {
    VdsNetworkInterface nicWithNetworkImplementationsDetailsNull = createNic("eth1");
    List<VdsNetworkInterface> existingInterfaces = Arrays.asList(nicWithNetworkImplementationsDetailsNull);
    Set<String> unmanagedNicsSet = validator.filterNicsWithUnmanagedNetworks(existingInterfaces, Collections.emptySet());
    assertTrue(unmanagedNicsSet.isEmpty());
}
#end_block

#method_before
public void testFilterNicsWithUnmanagedNetworksUmngmtNetRemoved() {
    List<VdsNetworkInterface> existingInterfaces = new ArrayList<VdsNetworkInterface>();
    for (int i = 0; i < 10; i++) {
        Nic nic = new Nic();
        nic.setName("eth" + i);
        // all even are unmanaged:
        NetworkImplementationDetails networkImplementationDetails = new NetworkImplementationDetails(true, i % 2 == 1);
        nic.setNetworkImplementationDetails(networkImplementationDetails);
        existingInterfaces.add(nic);
    }
    UnmanagedNetworkValidator validator = new UnmanagedNetworkValidator();
    Set<String> removedUnmanagedNetworks = new HashSet<String>();
    removedUnmanagedNetworks.add("eth4");
    removedUnmanagedNetworks.add("eth6");
    removedUnmanagedNetworks.add("eth8");
    List<VdsNetworkInterface> unmanagedNicsList = validator.filterNicsWithUnmanagedNetworks(existingInterfaces, removedUnmanagedNetworks);
    assertEquals(2, unmanagedNicsList.size());
    for (int i = 0; i < 2; i++) {
        assertEquals("eth" + (i * 2), unmanagedNicsList.get(i).getName());
    }
}
#method_after
public void testFilterNicsWithUnmanagedNetworksUmngmtNetRemoved() {
    VdsNetworkInterface nicWithUnmanagedToBeRemoved = createNicWithNetworkImplementationDetails("eth_unmanaged1_toBeRemoved", false);
    VdsNetworkInterface nicWithUnmanaged = createNicWithNetworkImplementationDetails("eth_unmanaged", false);
    VdsNetworkInterface nicWithManagedToBeRemoved = createNicWithNetworkImplementationDetails("eth_managed_toBeRemoved", true);
    VdsNetworkInterface nicWithManaged = createNicWithNetworkImplementationDetails("eth_managed", true);
    List<VdsNetworkInterface> existingInterfaces = Arrays.asList(nicWithUnmanagedToBeRemoved, nicWithUnmanaged, nicWithManagedToBeRemoved, nicWithManaged);
    Collection<String> removedUnmanagedNetworks = Arrays.asList("eth_unmanaged1_toBeRemoved", "eth_managed_toBeRemoved");
    Set<String> unmanagedNicsSet = validator.filterNicsWithUnmanagedNetworks(existingInterfaces, removedUnmanagedNetworks);
    assertEquals(1, unmanagedNicsSet.size());
    assertTrue(unmanagedNicsSet.contains("eth_unmanaged"));
}
#end_block

#method_before
@Test
public void testValidateLabels() {
    Nic nic = new Nic();
    nic.setName("eth7");
    Set<NicLabel> labels = new HashSet<NicLabel>();
    for (int i = 0; i < 10; i++) {
        NicLabel label = new NicLabel(null, "eth" + i, "label" + i);
        labels.add(label);
    }
    UnmanagedNetworkValidator validator = new UnmanagedNetworkValidator();
    ValidationResult result = validator.validateLabels(nic, labels);
    assertEquals(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_LABEL_ON_UNMANAGED_NETWORK, result.getMessage());
    assertEquals("$" + LABEL + " label7", result.getVariableReplacements().get(0));
    assertEquals("$" + NIC + " eth7", result.getVariableReplacements().get(1));
    labels = new HashSet<NicLabel>();
    for (int i = 0; i < 10; i++) {
        NicLabel label = new NicLabel(null, "other" + i, "label" + i);
    }
    result = validator.validateLabels(nic, labels);
    assertEquals(ValidationResult.VALID, result);
}
#method_after
@Test
public void testValidateLabels() {
    String nicWithUnmanagedNetwork = "eth_unmanaged";
    NicLabel label = new NicLabel(null, "eth1", "label1");
    NicLabel labelWithUnmanagedNetwork = new NicLabel(null, nicWithUnmanagedNetwork, "labelOnUnmanaged");
    Collection<NicLabel> labels = Arrays.asList(label, labelWithUnmanagedNetwork);
    ValidationResult result = validator.validateLabels(nicWithUnmanagedNetwork, labels);
    assertThat(result, failsWith(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_LABEL_ON_UNMANAGED_NETWORK, ReplacementUtils.createSetVariableString(LABEL, "labelOnUnmanaged"), ReplacementUtils.createSetVariableString(NIC, "eth_unmanaged")));
    NicLabel labelWithoutUnmanaged = new NicLabel(null, "eth_other", "label1");
    Collection<NicLabel> labelsNotOnUnmanagedNetwork = Arrays.asList(labelWithoutUnmanaged);
    result = validator.validateLabels(nicWithUnmanagedNetwork, labelsNotOnUnmanagedNetwork);
    assertTrue(result.isValid());
}
#end_block

#method_before
@Test
public void testValidateAttachements() {
    List<NetworkAttachment> attachementList = new ArrayList<NetworkAttachment>();
    NetworkAttachment attachement = new NetworkAttachment();
    attachement.setNetworkName("network1");
    attachement.setNicName("eth0");
    attachementList.add(attachement);
    attachement = new NetworkAttachment();
    attachement.setNetworkName("any2");
    attachement.setNicName("eth1");
    attachementList.add(attachement);
    Nic unmgmtNic = new Nic();
    unmgmtNic.setName("eth0");
    UnmanagedNetworkValidator validator = new UnmanagedNetworkValidator();
    ValidationResult result = validator.validateAttachements(unmgmtNic, attachementList);
    assertEquals(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_ATTACHEMENT_ON_UNMANAGED_NETWORK, result.getMessage());
    assertEquals("$" + NETWORK + " network1", result.getVariableReplacements().get(0));
    assertEquals("$" + NIC + " eth0", result.getVariableReplacements().get(1));
    unmgmtNic.setName("eth7");
    result = validator.validateAttachements(unmgmtNic, attachementList);
    assertEquals(ValidationResult.VALID, result);
}
#method_after
@Test
public void testValidateAttachements() {
    String unmanagedNicName = "eth0";
    NetworkAttachment attachement1 = new NetworkAttachment();
    attachement1.setNetworkName("network1");
    attachement1.setNicName(unmanagedNicName);
    NetworkAttachment attachement2 = new NetworkAttachment();
    attachement2.setNetworkName("any2");
    attachement2.setNicName("eth1");
    List<NetworkAttachment> attachementList = Arrays.asList(attachement1, attachement2);
    Nic unmgmtNic = createNicWithNetworkImplementationDetails(unmanagedNicName, false);
    List<VdsNetworkInterface> existingInterfaces = Arrays.asList(unmgmtNic);
    Set<String> nicsWithUnmanagedNetworks = validator.filterNicsWithUnmanagedNetworks(existingInterfaces, Collections.emptySet());
    assertEquals(1, nicsWithUnmanagedNetworks.size());
    String filteredNicName = nicsWithUnmanagedNetworks.iterator().next();
    assertEquals(filteredNicName, unmanagedNicName);
    ValidationResult result = validator.validateAttachements(filteredNicName, attachementList);
    assertThat(result, failsWith(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_ATTACHEMENT_ON_UNMANAGED_NETWORK, ReplacementUtils.createSetVariableString(NETWORK, "network1"), ReplacementUtils.createSetVariableString(NIC, "eth0")));
    result = validator.validateAttachements("eth7", attachementList);
    assertTrue(result.isValid());
}
#end_block

#method_before
public ValidationResult validate(HostSetupNetworksParameters params, List<VdsNetworkInterface> existingInterfaces, BusinessEntityMap<VdsNetworkInterface> existingInterfacesMap, BusinessEntityMap<Network> networkBusinessEntityMap) {
    List<VdsNetworkInterface> nicWithUnmanagedNetworks = filterNicsWithUnmanagedNetworks(existingInterfaces, params.getRemovedUnmanagedNetworks());
    ValidationResult vr = ValidationResult.VALID;
    for (VdsNetworkInterface unmgmtNic : nicWithUnmanagedNetworks) {
        vr = validateAttachements(unmgmtNic, params.getNetworkAttachments());
        vr = skipValidation(vr) ? vr : validateLabels(unmgmtNic, params.getLabels());
        vr = skipValidation(vr) ? vr : validateBonds(unmgmtNic, params.getBonds(), existingInterfacesMap);
        vr = skipValidation(vr) ? vr : validateRemovedLabels(unmgmtNic, params.getRemovedLabels());
        if (skipValidation(vr))
            break;
    }
    return vr;
}
#method_after
public ValidationResult validate(HostSetupNetworksParameters params, List<VdsNetworkInterface> existingInterfaces, BusinessEntityMap<Network> networkBusinessEntityMap) {
    ValidationResult result = validateRemovedUnmanagedNetworks(params.getRemovedUnmanagedNetworks(), existingInterfaces, networkBusinessEntityMap);
    if (!result.isValid()) {
        return result;
    }
    Set<String> nicsWithUnmanagedNetworks = filterNicsWithUnmanagedNetworks(existingInterfaces, params.getRemovedUnmanagedNetworks());
    for (String nicWithUnmanagedNetwork : nicsWithUnmanagedNetworks) {
        result = validateLabels(nicWithUnmanagedNetwork, params.getLabels());
        if (!result.isValid()) {
            return result;
        }
        result = validateAttachements(nicWithUnmanagedNetwork, params.getNetworkAttachments());
        if (!result.isValid()) {
            return result;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult validateLabels(VdsNetworkInterface unmgmtNic, Set<NicLabel> labels) {
    for (NicLabel label : labels) {
        if (unmgmtNic.getName().equals(label.getNicName()))
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_LABEL_ON_UNMANAGED_NETWORK, ReplacementUtils.createSetVariableString(LABEL, label.getName()), ReplacementUtils.createSetVariableString(NIC, label.getNicName()));
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validateLabels(String nicWithUnmanagedNetwork, Collection<NicLabel> labels) {
    for (NicLabel label : labels) {
        if (label.getNicName().equals(nicWithUnmanagedNetwork)) {
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_LABEL_ON_UNMANAGED_NETWORK, ReplacementUtils.createSetVariableString(LABEL, label.getName()), ReplacementUtils.createSetVariableString(NIC, label.getNicName()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult validateAttachements(VdsNetworkInterface unmgmtNic, List<NetworkAttachment> networkAttachments) {
    for (NetworkAttachment attachement : networkAttachments) {
        if (unmgmtNic.getName().equals(attachement.getNicName()))
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_ATTACHEMENT_ON_UNMANAGED_NETWORK, ReplacementUtils.createSetVariableString(NETWORK, attachement.getNetworkName()), ReplacementUtils.createSetVariableString(NIC, attachement.getNicName()));
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validateAttachements(String nicWithUnmanagedNetwork, List<NetworkAttachment> networkAttachments) {
    for (NetworkAttachment attachement : networkAttachments) {
        if (attachement.getNicName().equals(nicWithUnmanagedNetwork)) {
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_ATTACHEMENT_ON_UNMANAGED_NETWORK, ReplacementUtils.createSetVariableString(NETWORK, attachement.getNetworkName()), ReplacementUtils.createSetVariableString(NIC, attachement.getNicName()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
List<VdsNetworkInterface> filterNicsWithUnmanagedNetworks(List<VdsNetworkInterface> existingInterfaces, Set<String> removedUnmanagedNetworks) {
    List<VdsNetworkInterface> nicsWithUnmanagedNetworks = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface nic : existingInterfaces) {
        if (nic.getNetworkImplementationDetails() != null && !nic.getNetworkImplementationDetails().isManaged())
            if (!removedUnmanagedNetworks.contains(nic.getNetworkName()))
                nicsWithUnmanagedNetworks.add(nic);
    }
    return nicsWithUnmanagedNetworks;
}
#method_after
Set<String> filterNicsWithUnmanagedNetworks(List<VdsNetworkInterface> existingInterfaces, Collection<String> removedUnmanagedNetworks) {
    Set<String> nicsWithUnmanagedNetworks = new HashSet<>();
    for (VdsNetworkInterface nic : existingInterfaces) {
        if (nic.getNetworkImplementationDetails() != null && !nic.getNetworkImplementationDetails().isManaged()) {
            if (!removedUnmanagedNetworks.contains(nic.getNetworkName())) {
                nicsWithUnmanagedNetworks.add(NetworkUtils.stripVlan(nic));
            }
        }
    }
    return nicsWithUnmanagedNetworks;
}
#end_block

#method_before
private void setSupportedFeatures() {
    Version clusterCompatibilityVersion = host.getVdsGroupCompatibilityVersion();
    networkCustomPropertiesSupported = FeatureSupported.networkCustomProperties(clusterCompatibilityVersion);
    hostNetworkQosSupported = FeatureSupported.hostNetworkQos(clusterCompatibilityVersion);
}
#method_after
private void setSupportedFeatures() {
    Version clusterCompatibilityVersion = host.getClusterCompatibilityVersion();
    networkCustomPropertiesSupported = FeatureSupported.networkCustomProperties(clusterCompatibilityVersion);
    hostNetworkQosSupported = FeatureSupported.hostNetworkQos(clusterCompatibilityVersion);
}
#end_block

#method_before
List<String> translateErrorMessages(List<String> messages) {
    return Backend.getInstance().getErrorsTranslator().TranslateErrorText(messages);
}
#method_after
List<String> translateErrorMessages(List<String> messages) {
    return Backend.getInstance().getErrorsTranslator().translateErrorText(messages);
}
#end_block

#method_before
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : new NicLabelValidator(params, existingInterfacesMap, bondsMap, hostSetupNetworksValidatorHelper).validate();
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    vr = skipValidation(vr) ? vr : validateQos(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : createUnmanagedNetworkValidator().validate(params, existingInterfaces, existingInterfacesMap, networkBusinessEntityMap);
    return vr;
}
#method_after
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : new NicLabelValidator(params, existingInterfacesMap, bondsMap, hostSetupNetworksValidatorHelper).validate();
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    vr = skipValidation(vr) ? vr : validateQos(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateBondModeVsNetworksAttachedToIt(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : unmanagedNetworkValidator.validate(params, existingInterfaces, networkBusinessEntityMap);
    return vr;
}
#end_block

#method_before
ValidationResult validateQosOverriddenInterfaces() {
    for (NetworkAttachment networkAttachment : params.getNetworkAttachments()) {
        if (networkAttachment.isQosOverridden()) {
            Network network = getNetworkRelatedToAttachment(networkAttachment);
            String networkName = network.getName();
            if (!hostNetworkQosSupported) {
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, ReplacementUtils.createSetVariableString(ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED_LIST, networkName));
            }
            HostNetworkQos hostNetworkQos = networkAttachment.getHostNetworkQos();
            HostNetworkQosValidator qosValidator = createHostNetworkQosValidator(hostNetworkQos);
            ValidationResult requiredValuesPresent = qosValidator.requiredQosValuesPresentForOverriding(networkName);
            if (!requiredValuesPresent.isValid()) {
                return requiredValuesPresent;
            }
            ValidationResult valuesConsistent = qosValidator.valuesConsistent(networkName);
            if (!valuesConsistent.isValid()) {
                return valuesConsistent;
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validateQosOverriddenInterfaces() {
    for (NetworkAttachment networkAttachment : params.getNetworkAttachments()) {
        if (networkAttachment.isQosOverridden()) {
            Network network = getNetworkRelatedToAttachment(networkAttachment);
            String networkName = network.getName();
            if (!hostNetworkQosSupported) {
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, networkName));
            }
            HostNetworkQos hostNetworkQos = networkAttachment.getHostNetworkQos();
            HostNetworkQosValidator qosValidator = createHostNetworkQosValidator(hostNetworkQos);
            ValidationResult requiredValuesPresent = qosValidator.requiredQosValuesPresentForOverriding(networkName);
            if (!requiredValuesPresent.isValid()) {
                return requiredValuesPresent;
            }
            ValidationResult valuesConsistent = qosValidator.valuesConsistent(networkName);
            if (!valuesConsistent.isValid()) {
                return valuesConsistent;
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult networksUniquelyConfiguredOnHost(Collection<NetworkAttachment> attachmentsToConfigure) {
    Set<Guid> usedNetworkIds = new HashSet<>(attachmentsToConfigure.size());
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        boolean alreadyUsedNetworkId = usedNetworkIds.contains(attachment.getNetworkId());
        if (alreadyUsedNetworkId) {
            Network network = existingNetworkRelatedToAttachment(attachment);
            return new ValidationResult(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, ReplacementUtils.createSetVariableString(VAR_NETWORKS_ALREADY_ATTACHED_TO_IFACES_LIST, network.getName()));
        } else {
            usedNetworkIds.add(attachment.getNetworkId());
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult networksUniquelyConfiguredOnHost(Collection<NetworkAttachment> attachmentsToConfigure) {
    Set<Guid> usedNetworkIds = new HashSet<>(attachmentsToConfigure.size());
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        boolean alreadyUsedNetworkId = usedNetworkIds.contains(attachment.getNetworkId());
        if (alreadyUsedNetworkId) {
            Network network = existingNetworkRelatedToAttachment(attachment);
            EngineMessage engineMessage = EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES;
            return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, network.getName()));
        } else {
            usedNetworkIds.add(attachment.getNetworkId());
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
        removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
    }
    final List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    if (vmNames.isEmpty()) {
        return ValidationResult.VALID;
    } else {
        final List<String> sortedRemovedNetsworks = new ArrayList<>(removedNetworks);
        Collections.sort(sortedRemovedNetsworks);
        return new ValidationResult(EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, LinqUtils.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAMES, sortedRemovedNetsworks), ReplacementUtils.replaceWith(VAR_NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS_LIST, vmNames)));
    }
}
#method_after
@SuppressWarnings("unchecked")
ValidationResult validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
        removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
    }
    final List<String> vmsNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    final List<String> removedNetworksList = new ArrayList<>(removedNetworks);
    DetachNetworkUsedByVmValidator detachNetworkUsedByVmValidator = new DetachNetworkUsedByVmValidator(vmsNames, removedNetworksList);
    return detachNetworkUsedByVmValidator.validate();
}
#end_block

#method_before
ValidationResult validRemovedBonds(Collection<NetworkAttachment> attachmentsToConfigure) {
    List<Guid> invalidBondIds = Entities.idsNotReferencingExistingRecords(params.getRemovedBonds(), existingInterfacesMap.unmodifiableEntitiesByIdMap());
    if (!invalidBondIds.isEmpty()) {
        return new ValidationResult(EngineMessage.NETWORK_BOND_RECORD_DOES_NOT_EXISTS, ReplacementUtils.replaceWith(VAR_NETWORK_BOND_RECORD_DOES_NOT_EXISTS_LIST, invalidBondIds));
    }
    Map<String, List<Guid>> nicNameToAttachedNetworkAttachmentIds = getIdsOfNetworkAttachmentsRelatedToInterfaceNames(attachmentsToConfigure);
    for (VdsNetworkInterface removedBond : removedBondVdsNetworkInterface) {
        String bondName = removedBond.getName();
        VdsNetworkInterface existingBond = existingInterfacesMap.get(bondName);
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingBond).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        boolean cantRemoveRequiredInterface = nicNameToAttachedNetworkAttachmentIds.containsKey(bondName);
        if (cantRemoveRequiredInterface) {
            List<Guid> networkAttachmentsForNic = nicNameToAttachedNetworkAttachmentIds.get(bondName);
            List<String> replacements = new ArrayList<>();
            replacements.add(ReplacementUtils.createSetVariableString(VAR_BOND_NAME, bondName));
            replacements.addAll(ReplacementUtils.replaceWith(VAR_ATTACHMENT_IDS, networkAttachmentsForNic));
            return new ValidationResult(EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS, replacements);
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validRemovedBonds(Collection<NetworkAttachment> attachmentsToConfigure) {
    List<Guid> invalidBondIds = Entities.idsNotReferencingExistingRecords(params.getRemovedBonds(), existingInterfacesMap.unmodifiableEntitiesByIdMap());
    if (!invalidBondIds.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.NETWORK_BOND_RECORDS_DOES_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, invalidBondIds));
    }
    Map<String, List<Guid>> nicNameToAttachedNetworkAttachmentIds = getIdsOfNetworkAttachmentsRelatedToInterfaceNames(attachmentsToConfigure);
    for (VdsNetworkInterface removedBond : removedBondVdsNetworkInterface) {
        String bondName = removedBond.getName();
        VdsNetworkInterface existingBond = existingInterfacesMap.get(bondName);
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingBond).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        boolean cantRemoveRequiredInterface = nicNameToAttachedNetworkAttachmentIds.containsKey(bondName);
        if (cantRemoveRequiredInterface) {
            List<Guid> networkAttachmentsForNic = nicNameToAttachedNetworkAttachmentIds.get(bondName);
            EngineMessage engineMessage = EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS;
            List<String> replacements = new ArrayList<>();
            replacements.add(ReplacementUtils.getVariableAssignmentString(engineMessage, bondName));
            replacements.addAll(ReplacementUtils.replaceWith(VAR_ATTACHMENT_IDS, networkAttachmentsForNic));
            return new ValidationResult(engineMessage, replacements);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private Map<String, List<Guid>> getIdsOfNetworkAttachmentsRelatedToInterfaceNames(Collection<NetworkAttachment> networkAttachments) {
    Map<String, List<Guid>> map = new HashMap<>();
    for (NetworkAttachment attachment : networkAttachments) {
        MultiValueMapUtils.addToMap(attachment.getNicName(), attachment.getId(), map, new ListCreator<Guid>());
    }
    return map;
}
#method_after
private Map<String, List<Guid>> getIdsOfNetworkAttachmentsRelatedToInterfaceNames(Collection<NetworkAttachment> networkAttachments) {
    Map<String, List<Guid>> map = new HashMap<>();
    for (NetworkAttachment attachment : networkAttachments) {
        MultiValueMapUtils.addToMap(attachment.getNicName(), attachment.getId(), map, new ListCreator<>());
    }
    return map;
}
#end_block

#method_before
ValidationResult validNewOrModifiedBonds() {
    for (Bond modifiedOrNewBond : params.getBonds()) {
        String bondName = modifiedOrNewBond.getName();
        ValidationResult validateCoherentNicIdentification = validateCoherentNicIdentification(modifiedOrNewBond);
        if (!validateCoherentNicIdentification.isValid()) {
            return validateCoherentNicIdentification;
        }
        // does not test, whether interface exists, but only if the instance is non-null and its name is set.
        ValidationResult interfaceByNameExists = createHostInterfaceValidator(modifiedOrNewBond).interfaceByNameExists();
        if (!interfaceByNameExists.isValid()) {
            return interfaceByNameExists;
        }
        boolean validBondName = bondName != null && bondName.matches(BusinessEntitiesDefinitions.BOND_NAME_PATTERN);
        if (!validBondName) {
            return new ValidationResult(EngineMessage.NETWORK_BOND_NAME_BAD_FORMAT, ReplacementUtils.createSetVariableString(VAR_NETWORK_BOND_NAME_BAD_FORMAT_ENTITY, bondName));
        }
        // either it's newly create bond, thus non existing, or given name must reference existing bond.
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingInterfacesMap.get(bondName)).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        // count of bond slaves must be at least two.
        if (modifiedOrNewBond.getSlaves().size() < 2) {
            return new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.createSetVariableString(VAR_NETWORK_BONDS_INVALID_SLAVE_COUNT_LIST, bondName));
        }
        ValidationResult validateModifiedBondSlaves = validateModifiedBondSlaves(modifiedOrNewBond);
        if (!validateModifiedBondSlaves.isValid()) {
            return validateModifiedBondSlaves;
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validNewOrModifiedBonds() {
    for (Bond modifiedOrNewBond : params.getBonds()) {
        String bondName = modifiedOrNewBond.getName();
        Guid bondId = modifiedOrNewBond.getId();
        /*
             * bondId is provided, but bondName not. This means that user attempted update, but bond of such ID does not
             * exit, thus completors did not complete name.
             */
        if (bondId != null && bondName == null) {
            return new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_HAVING_ID_DOES_NOT_EXIST, ReplacementUtils.createSetVariableString(VAR_NIC_ID, bondId));
        }
        /*
             * user did not provide neither bondId nor bondName. That means he probably attempted new bond creation
             * but forgot to provide bondName.
             */
        if (bondId == null && bondName == null) {
            return new ValidationResult(EngineMessage.BOND_DOES_NOT_HAVE_NEITHER_ID_NOR_NAME_SPECIFIED);
        }
        /*
             * if (bondId == null && bondName != null) …
             * User provided only bondName, and completors failed to find existing bonds id for that name.
             * We cannot tell, what user wanted to do(create/update). We have to assume, it's new record creation, which
             * is valid scenario.
             */
        ValidationResult validateCoherentNicIdentification = validateCoherentNicIdentification(modifiedOrNewBond);
        if (!validateCoherentNicIdentification.isValid()) {
            return validateCoherentNicIdentification;
        }
        boolean validBondName = bondName.matches(BusinessEntitiesDefinitions.BOND_NAME_PATTERN);
        if (!validBondName) {
            EngineMessage engineMessage = EngineMessage.NETWORK_BOND_NAME_BAD_FORMAT;
            return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, bondName));
        }
        // either it's newly create bond, thus non existing, or given name must reference existing bond.
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingInterfacesMap.get(bondName)).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        // count of bond slaves must be at least two.
        if (modifiedOrNewBond.getSlaves().size() < 2) {
            return new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bondName));
        }
        ValidationResult validateModifiedBondSlaves = validateModifiedBondSlaves(modifiedOrNewBond);
        if (!validateModifiedBondSlaves.isValid()) {
            return validateModifiedBondSlaves;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult validateModifiedBondSlaves(Bond modifiedOrNewBond) {
    for (String slaveName : modifiedOrNewBond.getSlaves()) {
        VdsNetworkInterface potentialSlave = existingInterfacesMap.get(slaveName);
        HostInterfaceValidator slaveHostInterfaceValidator = createHostInterfaceValidator(potentialSlave);
        ValidationResult interfaceExists = slaveHostInterfaceValidator.interfaceExists();
        if (!interfaceExists.isValid()) {
            return interfaceExists;
        }
        ValidationResult interfaceIsValidSlave = slaveHostInterfaceValidator.interfaceIsValidSlave();
        if (!interfaceIsValidSlave.isValid()) {
            return interfaceIsValidSlave;
        }
        /* definition of currently processed bond references this slave, but this slave already 'slaves' for
                another bond. This is ok only when this bond will be removed as a part of this request
                or the slave will be removed from its former bond, as a part of this request. */
        String currentSlavesBondName = potentialSlave.getBondName();
        if (potentialSlave.isPartOfBond() && /* we're creating new bond, and it's definition contains reference to slave already assigned
                        to a different bond. */
        (!potentialSlave.isPartOfBond(modifiedOrNewBond.getName()) && // …but this bond is also removed in this request, so it's ok.
        !isBondRemoved(currentSlavesBondName) && // … or slave was removed from its former bond
        !bondIsUpdatedAndDoesNotContainCertainSlave(slaveName, currentSlavesBondName))) {
            return new ValidationResult(EngineMessage.NETWORK_INTERFACE_ALREADY_IN_BOND, ReplacementUtils.createSetVariableString(VAR_NETWORK_INTERFACE_ALREADY_IN_BOND_ENTITY, slaveName));
        }
        ValidationResult slaveHasAttachedNetworksValidationResult = validateSlaveHasNoNetworks(potentialSlave.getName());
        if (!slaveHasAttachedNetworksValidationResult.isValid()) {
            return slaveHasAttachedNetworksValidationResult;
        }
        if (slaveUsedMultipleTimesInDifferentBonds(slaveName)) {
            return new ValidationResult(EngineMessage.NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES, ReplacementUtils.createSetVariableString("NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES_ENTITY", slaveName));
        }
        ValidationResult slaveHasNoLabelsValidationResult = validateSlaveHasNoLabels(slaveName);
        if (!slaveHasNoLabelsValidationResult.isValid()) {
            return slaveHasNoLabelsValidationResult;
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validateModifiedBondSlaves(Bond modifiedOrNewBond) {
    for (String slaveName : modifiedOrNewBond.getSlaves()) {
        VdsNetworkInterface potentialSlave = existingInterfacesMap.get(slaveName);
        HostInterfaceValidator slaveHostInterfaceValidator = createHostInterfaceValidator(potentialSlave);
        ValidationResult interfaceExists = slaveHostInterfaceValidator.interfaceExists(slaveName);
        if (!interfaceExists.isValid()) {
            return interfaceExists;
        }
        ValidationResult interfaceIsValidSlave = slaveHostInterfaceValidator.interfaceIsValidSlave();
        if (!interfaceIsValidSlave.isValid()) {
            return interfaceIsValidSlave;
        }
        /*
             * definition of currently processed bond references this slave, but this slave already 'slaves' for
             * another bond. This is ok only when this bond will be removed as a part of this request
             * or the slave will be removed from its former bond, as a part of this request.
             */
        String currentSlavesBondName = potentialSlave.getBondName();
        if (potentialSlave.isPartOfBond() && /*
                         * we're creating new bond, and it's definition contains reference to slave already assigned
                         * to a different bond.
                         */
        (!potentialSlave.isPartOfBond(modifiedOrNewBond.getName()) && // … but this bond is also removed in this request, so it's ok.
        !isBondRemoved(currentSlavesBondName) && // … or slave was removed from its former bond
        !bondIsUpdatedAndDoesNotContainCertainSlave(slaveName, currentSlavesBondName))) {
            EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ALREADY_IN_BOND;
            return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName));
        }
        ValidationResult slaveHasAttachedNetworksValidationResult = validateSlaveHasNoNetworks(potentialSlave.getName());
        if (!slaveHasAttachedNetworksValidationResult.isValid()) {
            return slaveHasAttachedNetworksValidationResult;
        }
        if (slaveUsedMultipleTimesInDifferentBonds(slaveName)) {
            return new ValidationResult(EngineMessage.NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES, ReplacementUtils.createSetVariableString("NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES_ENTITY", slaveName));
        }
        ValidationResult slaveHasNoLabelsValidationResult = validateSlaveHasNoLabels(slaveName);
        if (!slaveHasNoLabelsValidationResult.isValid()) {
            return slaveHasNoLabelsValidationResult;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult validateSlaveHasNoNetworks(String slaveName) {
    for (NetworkAttachment attachment : getAttachmentsToConfigure()) {
        if (Objects.equals(attachment.getNicName(), slaveName)) {
            if (attachment.getId() == null) {
                return new ValidationResult(EngineMessage.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME, ReplacementUtils.createSetVariableString(NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME_ENTITY, slaveName), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, attachment.getNetworkName()));
            } else {
                return new ValidationResult(EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE, ReplacementUtils.createSetVariableString(NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE_ENTITY, slaveName), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, attachment.getNetworkName()));
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult validateSlaveHasNoNetworks(String slaveName) {
    for (NetworkAttachment attachment : getAttachmentsToConfigure()) {
        if (Objects.equals(attachment.getNicName(), slaveName)) {
            if (attachment.getId() == null) {
                EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, attachment.getNetworkName()));
            } else {
                EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, attachment.getNetworkName()));
            }
        }
    }
    for (VdsNetworkInterface iface : existingInterfaces) {
        if (slaveName.equals(NetworkUtils.stripVlan(iface))) {
            if (iface.getNetworkImplementationDetails() != null && !iface.getNetworkImplementationDetails().isManaged()) {
                return new ValidationResult(EngineMessage.NETWORK_INTERFACE_WITH_UNMANAGED_NETWORK_CANNOT_BE_SLAVE, ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, iface.getNetworkName()), ReplacementUtils.createSetVariableString(VAR_NIC_NAME, slaveName));
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : referencedNetworkAttachmentActuallyExists(attachment.getId());
        // TODO MM: complain about unset network id.
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : validateCoherentNetworkIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : modifiedAttachmentNotRemoved(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentNotReferenceVlanDevice(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentAndNicReferenceSameLabelNotConflict(attachment);
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.ipConfiguredForStaticBootProtocol();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForDisplayNetwork();
        // this is not nic exist, but only nic is set.
        vr = skipValidation(vr) ? vr : validator.nicExists();
        vr = skipValidation(vr) ? vr : nicActuallyExistsOrReferencesNewBond(attachment);
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfacesMap);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(attachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : validator.validateGateway();
        boolean attachmentUpdated = !isNewAttachment(attachment.getId());
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : validator.networkNotUsedByVms();
            vr = skipValidation(vr) ? vr : notMovingLabeledNetworkToDifferentNic(attachment);
        }
    }
    return vr;
}
#method_after
ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : referencedNetworkAttachmentActuallyExists(attachment.getId());
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : validateCoherentNetworkIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : modifiedAttachmentNotRemoved(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentNotReferenceVlanDevice(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentAndNicReferenceSameLabelNotConflict(attachment);
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForRoleNetwork();
        vr = skipValidation(vr) ? vr : validator.nicNameIsSet();
        vr = skipValidation(vr) ? vr : nicActuallyExistsOrReferencesNewBond(attachment);
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfacesMap);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(attachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : validator.validateGateway();
        vr = skipValidation(vr) ? vr : networkAttachmentIpConfigurationValidator.validateNetworkAttachmentIpConfiguration(params.getNetworkAttachments());
        boolean attachmentUpdated = !isNewAttachment(attachment.getId());
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : validator.networkNotUsedByVms();
            vr = skipValidation(vr) ? vr : notMovingLabeledNetworkToDifferentNic(attachment);
        }
    }
    return vr;
}
#end_block

#method_before
private ValidationResult referencedNetworkAttachmentActuallyExists(Guid networkAttachmentId) {
    boolean doesNotReferenceExistingNetworkAttachment = networkAttachmentId == null;
    if (doesNotReferenceExistingNetworkAttachment) {
        return ValidationResult.VALID;
    }
    for (NetworkAttachment existingAttachment : existingAttachments) {
        if (existingAttachment.getId().equals(networkAttachmentId)) {
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS);
}
#method_after
private ValidationResult referencedNetworkAttachmentActuallyExists(Guid networkAttachmentId) {
    boolean doesNotReferenceExistingNetworkAttachment = networkAttachmentId == null;
    if (doesNotReferenceExistingNetworkAttachment) {
        return ValidationResult.VALID;
    }
    for (NetworkAttachment existingAttachment : existingAttachments) {
        if (existingAttachment.getId().equals(networkAttachmentId)) {
            return ValidationResult.VALID;
        }
    }
    EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS;
    String id = networkAttachmentId.toString();
    String replacement = ReplacementUtils.getVariableAssignmentString(engineMessage, id);
    return new ValidationResult(engineMessage, replacement);
}
#end_block

#method_before
private ValidationResult validateCoherentNicIdentification(Bond bond) {
    Guid nicId = bond.getId();
    String nicName = bond.getName();
    EngineMessage message = EngineMessage.BOND_REFERENCES_NICS_INCOHERENTLY;
    return hostSetupNetworksValidatorHelper.validateCoherentIdentification(bond.getName(), nicId, nicName, message, existingInterfacesMap);
}
#method_after
private ValidationResult validateCoherentNicIdentification(Bond bond) {
    Guid nicId = bond.getId();
    String nicName = bond.getName();
    EngineMessage message = EngineMessage.BOND_REFERENCES_NICS_INCOHERENTLY;
    return hostSetupNetworksValidatorHelper.validateCoherentIdentification(nicName, nicId, nicName, message, existingInterfacesMap);
}
#end_block

#method_before
private ValidationResult modifiedAttachmentExists(Guid networkAttachmentId) {
    if (isNewAttachment(networkAttachmentId)) {
        return ValidationResult.VALID;
    }
    for (NetworkAttachment existingAttachment : existingAttachments) {
        if (existingAttachment.getId().equals(networkAttachmentId)) {
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS, ReplacementUtils.createSetVariableString(VAR_NETWORK_ATTACHMENT_NOT_EXISTS_ENTITY, networkAttachmentId.toString()));
}
#method_after
private ValidationResult modifiedAttachmentExists(Guid networkAttachmentId) {
    if (isNewAttachment(networkAttachmentId)) {
        return ValidationResult.VALID;
    }
    for (NetworkAttachment existingAttachment : existingAttachments) {
        if (existingAttachment.getId().equals(networkAttachmentId)) {
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS, networkAttachmentId.toString()));
}
#end_block

#method_before
ValidationResult modifiedAttachmentNotRemoved(NetworkAttachment networkAttachment) {
    Guid networkAttachmentId = networkAttachment.getId();
    if (isNewAttachment(networkAttachmentId)) {
        return ValidationResult.VALID;
    }
    boolean attachmentInRemoveList = params.getRemovedNetworkAttachments().contains(networkAttachmentId);
    return ValidationResult.failWith(EngineMessage.NETWORK_ATTACHMENT_IN_BOTH_LISTS, ReplacementUtils.createSetVariableString("NETWORK_ATTACHMENT_IN_BOTH_LISTS_ENTITY", networkAttachmentId.toString())).when(attachmentInRemoveList);
}
#method_after
ValidationResult modifiedAttachmentNotRemoved(NetworkAttachment networkAttachment) {
    Guid networkAttachmentId = networkAttachment.getId();
    if (isNewAttachment(networkAttachmentId)) {
        return ValidationResult.VALID;
    }
    boolean attachmentInRemoveList = params.getRemovedNetworkAttachments().contains(networkAttachmentId);
    EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENT_IN_BOTH_LISTS;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, networkAttachmentId.toString())).when(attachmentInRemoveList);
}
#end_block

#method_before
private ValidationResult nicActuallyExistsOrReferencesNewBond(NetworkAttachment attachment) {
    boolean nicActuallyExistsOrReferencesNewBond = isNicActuallyExistsOrReferencesNewBond(attachment.getNicName(), attachment.getNicId());
    if (nicActuallyExistsOrReferencesNewBond) {
        return ValidationResult.VALID;
    }
    // Duplicate message / fix other code as well?
    return new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST);
}
#method_after
private ValidationResult nicActuallyExistsOrReferencesNewBond(NetworkAttachment attachment) {
    String nicName = attachment.getNicName();
    Guid nicId = attachment.getNicId();
    boolean nicActuallyExistsOrReferencesNewBond = isNicActuallyExistsOrReferencesNewBond(nicName, nicId);
    return ValidationResult.failWith(EngineMessage.HOST_NETWORK_INTERFACE_HAVING_ID_OR_NAME_DOES_NOT_EXIST, ReplacementUtils.createSetVariableString(VAR_NIC_ID, nicId), ReplacementUtils.createSetVariableString(VAR_NIC_NAME, nicName)).when(!nicActuallyExistsOrReferencesNewBond);
}
#end_block

#method_before
private ValidationResult validRemovedNetworkAttachments() {
    List<Guid> invalidIds = Entities.idsNotReferencingExistingRecords(params.getRemovedNetworkAttachments(), existingAttachments);
    if (!invalidIds.isEmpty()) {
        return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS, ReplacementUtils.replaceWith(VAR_NETWORK_ATTACHMENTS_NOT_EXISTS_LIST, invalidIds));
    }
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = removedNetworkAttachments.iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachmentToValidate);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.notRemovingManagementNetwork();
        vr = skipValidation(vr) ? vr : notRemovingLabeledNetworks(attachment);
        vr = skipValidation(vr) ? vr : validateNotRemovingUsedNetworkByVms();
    }
    return vr;
}
#method_after
private ValidationResult validRemovedNetworkAttachments() {
    List<Guid> invalidIds = Entities.idsNotReferencingExistingRecords(params.getRemovedNetworkAttachments(), existingAttachments);
    if (!invalidIds.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENTS_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, invalidIds));
    }
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = removedNetworkAttachments.iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachmentToValidate);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.notRemovingManagementNetwork();
        vr = skipValidation(vr) ? vr : notRemovingLabeledNetworks(attachment);
        vr = skipValidation(vr) ? vr : validateNotRemovingUsedNetworkByVms();
    }
    return vr;
}
#end_block

#method_before
ValidationResult notRemovingLabeledNetworks(NetworkAttachment attachment) {
    Network removedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return ValidationResult.VALID;
    }
    boolean networkAttachedToNicByAnotherAttachment = networkAttachmentsByNetworkId.get(removedNetwork.getId()) != null;
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, ReplacementUtils.createSetVariableString(VAR_ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC_LIST, removedNetwork.getName())).when(!networkAttachedToNicByAnotherAttachment && isNicToConfigureContainTheLabel(attachment.getNicName(), removedNetwork.getLabel()));
}
#method_after
ValidationResult notRemovingLabeledNetworks(NetworkAttachment attachment) {
    Network removedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return ValidationResult.VALID;
    }
    boolean networkAttachedToNicByAnotherAttachment = networkAttachmentsByNetworkId.get(removedNetwork.getId()) != null;
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, removedNetwork.getName())).when(!networkAttachedToNicByAnotherAttachment && isNicToConfigureContainTheLabel(attachment.getNicName(), removedNetwork.getLabel()));
}
#end_block

#method_before
ValidationResult notMovingLabeledNetworkToDifferentNic(NetworkAttachment attachment) {
    Network movedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(movedNetwork)) {
        return ValidationResult.VALID;
    }
    NetworkAttachment existingAttachment = attachmentsById.get(attachment.getId());
    boolean movedToDifferentNic = !existingAttachment.getNicId().equals(attachment.getNicId());
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC, ReplacementUtils.createSetVariableString("networkName", movedNetwork.getName()), ReplacementUtils.createSetVariableString(ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC_ENTITY, movedNetwork.getLabel())).when(movedToDifferentNic && isNicToConfigureContainTheLabel(existingAttachment.getNicName(), movedNetwork.getLabel()));
}
#method_after
ValidationResult notMovingLabeledNetworkToDifferentNic(NetworkAttachment attachment) {
    Network movedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(movedNetwork)) {
        return ValidationResult.VALID;
    }
    NetworkAttachment existingAttachment = attachmentsById.get(attachment.getId());
    boolean movedToDifferentNic = !existingAttachment.getNicId().equals(attachment.getNicId());
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, movedNetwork.getName()), ReplacementUtils.getVariableAssignmentString(engineMessage, movedNetwork.getLabel())).when(movedToDifferentNic && isNicToConfigureContainTheLabel(existingAttachment.getNicName(), movedNetwork.getLabel()));
}
#end_block

#method_before
ValidationResult validateAttachmentAndNicReferenceSameLabelNotConflict(NetworkAttachment attachment) {
    Network network = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(network)) {
        return ValidationResult.VALID;
    }
    String label = network.getLabel();
    String nicThatShouldHaveTheLabel = nicLabelByLabel.containsKey(label) ? nicLabelByLabel.get(label).getNicName() : null;
    return ValidationResult.failWith(EngineMessage.NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC, ReplacementUtils.createSetVariableString("NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC_ENTITY", network.getName()), ReplacementUtils.createSetVariableString("interfaceName", attachment.getNicName()), ReplacementUtils.createSetVariableString("labeledInterfaceName", nicThatShouldHaveTheLabel)).unless(nicThatShouldHaveTheLabel == null || nicThatShouldHaveTheLabel.equals(attachment.getNicName()));
}
#method_after
ValidationResult validateAttachmentAndNicReferenceSameLabelNotConflict(NetworkAttachment attachment) {
    Network network = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(network)) {
        return ValidationResult.VALID;
    }
    String label = network.getLabel();
    String nicThatShouldHaveTheLabel = nicLabelByLabel.containsKey(label) ? nicLabelByLabel.get(label).getNicName() : null;
    EngineMessage engineMessage = EngineMessage.NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, network.getName()), ReplacementUtils.createSetVariableString(VAR_NIC_NAME, attachment.getNicName()), ReplacementUtils.createSetVariableString(VAR_LABELED_NIC_NAME, nicThatShouldHaveTheLabel)).unless(nicThatShouldHaveTheLabel == null || nicThatShouldHaveTheLabel.equals(attachment.getNicName()));
}
#end_block

#method_before
private ValidationResult validateCustomProperties() {
    String version = host.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validPropertiesForVmNetwork = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validPropertiesForVmNetwork.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesForNonVm = new HashMap<>(validPropertiesForVmNetwork);
    validPropertiesForNonVm.remove("bridge_opts");
    return validateCustomProperties(util, validPropertiesForVmNetwork, validPropertiesForNonVm);
}
#method_after
private ValidationResult validateCustomProperties() {
    String version = host.getClusterCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validPropertiesForVmNetwork = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validPropertiesForVmNetwork.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesForNonVm = new HashMap<>(validPropertiesForVmNetwork);
    validPropertiesForNonVm.remove("bridge_opts");
    return validateCustomProperties(util, validPropertiesForVmNetwork, validPropertiesForNonVm);
}
#end_block

#method_before
ValidationResult validateCustomProperties(SimpleCustomPropertiesUtil util, Map<String, String> validPropertiesForVm, Map<String, String> validPropertiesForNonVm) {
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        Network network = existingNetworkRelatedToAttachment(attachment);
        if (attachment.hasProperties()) {
            if (!networkCustomPropertiesSupported) {
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, ReplacementUtils.createSetVariableString(VAR_ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED_LIST, network.getName()));
            }
            List<ValidationError> errors = util.validateProperties(network.isVmNetwork() ? validPropertiesForVm : validPropertiesForNonVm, attachment.getProperties());
            if (!errors.isEmpty()) {
                handleCustomPropertiesError(util, errors);
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, ReplacementUtils.createSetVariableString(VAR_ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT_LIST, network.getName()));
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validateCustomProperties(SimpleCustomPropertiesUtil util, Map<String, String> validPropertiesForVm, Map<String, String> validPropertiesForNonVm) {
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        Network network = existingNetworkRelatedToAttachment(attachment);
        if (attachment.hasProperties()) {
            if (!networkCustomPropertiesSupported) {
                EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, network.getName()));
            }
            List<ValidationError> errors = util.validateProperties(network.isVmNetwork() ? validPropertiesForVm : validPropertiesForNonVm, attachment.getProperties());
            if (!errors.isEmpty()) {
                handleCustomPropertiesError(util, errors);
                EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, network.getName()));
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult validateAttachmentNotReferenceVlanDevice(NetworkAttachment attachment) {
    VdsNetworkInterface nic = existingInterfacesMap.get(attachment.getNicName());
    return ValidationResult.failWith(EngineMessage.ATTACHMENT_REFERENCE_VLAN_DEVICE, ReplacementUtils.createSetVariableString("ATTACHMENT_REFERENCE_VLAN_DEVICE_ENTITY", attachment.getNetworkName()), ReplacementUtils.createSetVariableString("nicName", attachment.getNicName())).when(nic != null && NetworkUtils.isVlan(nic));
}
#method_after
private ValidationResult validateAttachmentNotReferenceVlanDevice(NetworkAttachment attachment) {
    VdsNetworkInterface nic = existingInterfacesMap.get(attachment.getNicName());
    EngineMessage engineMessage = EngineMessage.ATTACHMENT_REFERENCE_VLAN_DEVICE;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, attachment.getNetworkName()), ReplacementUtils.createSetVariableString(VAR_NIC_NAME, attachment.getNicName())).when(nic != null && NetworkUtils.isVlan(nic));
}
#end_block

#method_before
@BeforeClass
public static void setUp() throws Exception {
    numaTuneMode = NumaTuneMode.INTERLEAVE;
    vdsNumaNodes = createTestVdsNumaNodes();
    vmNumaNodes = createTestVmNumaNodes();
}
#method_after
@Before
public void setUp() throws Exception {
    numaTuneMode = NumaTuneMode.INTERLEAVE;
    vdsNumaNodes = createTestVdsNumaNodes();
    vmNumaNodes = createTestVmNumaNodes();
}
#end_block

#method_before
@Override
protected void executeIrsBrokerCommand() {
    log.info("-- executeIrsBrokerCommand: calling 'SPMGetVolumeInfo', parameters:");
    log.info("++ spUUID={}", getParameters().getStoragePoolId());
    log.info("++ sdUUID={}", getParameters().getStorageDomainId());
    log.info("++ imageGroupGUID={}", getParameters().getImageGroupId());
    log.info("++ volUUID={}", getParameters().getImageId());
    GetVolumeInfoVDSCommandParameters params = new GetVolumeInfoVDSCommandParameters(getCurrentIrsProxyData().getCurrentVdsId(), getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getParameters().getImageGroupId(), getParameters().getImageId());
    setVDSReturnValue(resourceManager.runVdsCommand(VDSCommandType.GetVolumeInfo, params));
}
#method_after
@Override
protected void executeIrsBrokerCommand() {
    log.info("Executing GetVolumeInfo using the current SPM");
    GetVolumeInfoVDSCommandParameters params = new GetVolumeInfoVDSCommandParameters(getCurrentIrsProxyData().getCurrentVdsId(), getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getParameters().getImageGroupId(), getParameters().getImageId());
    setVDSReturnValue(resourceManager.runVdsCommand(VDSCommandType.GetVolumeInfo, params));
}
#end_block

#method_before
@Override
protected ToStringBuilder appendAttributes(ToStringBuilder tsb) {
    return super.appendAttributes(tsb).append("storagePoolId", getStoragePoolId()).append("storageDomainId", getStorageDomainId()).append("imageGroupId", getImageGroupId()).append("imageId", getImageId());
}
#method_after
@Override
protected ToStringBuilder appendAttributes(ToStringBuilder tsb) {
    return super.appendAttributes(tsb).append("imageId", getImageId());
}
#end_block

#method_before
protected static int getNumOfPrestartedVmsInPool(Guid poolId, ArrayList<String> messages) {
    List<VM> vmsInPool = DbFacade.getInstance().getVmDao().getAllForVmPool(poolId);
    int numOfPrestartedVmsInPool = 0;
    if (vmsInPool != null) {
        for (VM vm : vmsInPool) {
            if (vm.isStartingOrUp() && canAttachPrestartedVmToUser(vm.getId(), messages))
                ++numOfPrestartedVmsInPool;
        }
    }
    return numOfPrestartedVmsInPool;
}
#method_after
protected static int getNumOfPrestartedVmsInPool(Guid poolId, ArrayList<String> messages) {
    List<VM> vmsInPool = DbFacade.getInstance().getVmDao().getAllForVmPool(poolId);
    int numOfPrestartedVmsInPool = 0;
    if (vmsInPool != null) {
        for (VM vm : vmsInPool) {
            if (vm.isStartingOrUp() && canAttachPrestartedVmToUser(vm.getId(), messages)) {
                ++numOfPrestartedVmsInPool;
            }
        }
    }
    return numOfPrestartedVmsInPool;
}
#end_block

#method_before
protected static boolean canRunPoolVm(Guid vmId, List<String> messages) {
    VM vm = DbFacade.getInstance().getVmDao().get(vmId);
    if (vm == null) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND.name());
        return false;
    }
    // TODO: This is done to keep consistency with VmDao.getById.
    // It can probably be removed, but that requires some more research
    VmHandler.updateNetworkInterfacesFromDb(vm);
    RunVmParams runVmParams = new RunVmParams(vmId);
    return new RunVmValidator(vm, runVmParams, false, findActiveISODomain(vm.getStoragePoolId())).canRunVm(messages, fetchStoragePool(vm.getStoragePoolId()), Collections.<Guid>emptyList(), null, null, DbFacade.getInstance().getVdsGroupDao().get(vm.getVdsGroupId()));
}
#method_after
protected static boolean canRunPoolVm(Guid vmId, List<String> messages) {
    VM vm = DbFacade.getInstance().getVmDao().get(vmId);
    if (vm == null) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND.name());
        return false;
    }
    // TODO: This is done to keep consistency with VmDao.getById.
    // It can probably be removed, but that requires some more research
    VmHandler.updateNetworkInterfacesFromDb(vm);
    RunVmParams runVmParams = new RunVmParams(vmId);
    return new RunVmValidator(vm, runVmParams, false, findActiveISODomain(vm.getStoragePoolId())).canRunVm(messages, fetchStoragePool(vm.getStoragePoolId()), Collections.<Guid>emptyList(), null, null, DbFacade.getInstance().getClusterDao().get(vm.getClusterId()));
}
#end_block

#method_before
private void managePrestartedVmsInPool(VmPool vmPool) {
    Guid vmPoolId = vmPool.getVmPoolId();
    int prestartedVms = VmPoolCommandBase.getNumOfPrestartedVmsInPool(vmPoolId, new ArrayList<>());
    int missingPrestartedVms = vmPool.getPrestartedVms() - prestartedVms;
    if (missingPrestartedVms > 0) {
        // We do not want to start too many vms at once
        int numOfVmsToPrestart = Math.min(missingPrestartedVms, Config.<Integer>getValue(ConfigValues.VmPoolMonitorBatchSize));
        log.info("VmPool '{}' is missing {} prestarted Vms, attempting to prestart {} Vms", vmPoolId, missingPrestartedVms, numOfVmsToPrestart);
        prestartVms(vmPoolId, numOfVmsToPrestart);
    }
}
#method_after
private void managePrestartedVmsInPool(VmPool vmPool) {
    Guid vmPoolId = vmPool.getVmPoolId();
    int prestartedVms = VmPoolCommandBase.getNumOfPrestartedVmsInPool(vmPoolId, new ArrayList<>());
    int missingPrestartedVms = vmPool.getPrestartedVms() - prestartedVms;
    if (missingPrestartedVms > 0) {
        // We do not want to start too many vms at once
        int numOfVmsToPrestart = Math.min(missingPrestartedVms, Config.<Integer>getValue(ConfigValues.VmPoolMonitorBatchSize));
        log.info("VmPool '{}' is missing {} prestarted VMs, attempting to prestart {} VMs", vmPoolId, missingPrestartedVms, numOfVmsToPrestart);
        prestartVms(vmPoolId, numOfVmsToPrestart);
    }
}
#end_block

#method_before
private void prestartVms(Guid vmPoolId, int numOfVmsToPrestart) {
    // Fetch all vms that are in status down
    List<VmPoolMap> vmPoolMaps = DbFacade.getInstance().getVmPoolDao().getVmMapsInVmPoolByVmPoolIdAndStatus(vmPoolId, VMStatus.Down);
    int failedAttempts = 0;
    int prestartedVmsCounter = 0;
    final int maxFailedAttempts = Config.<Integer>getValue(ConfigValues.VmPoolMonitorMaxAttempts);
    Map<String, Integer> failureReasons = new HashMap<>();
    if (vmPoolMaps != null && vmPoolMaps.size() > 0) {
        for (VmPoolMap map : vmPoolMaps) {
            if (failedAttempts < maxFailedAttempts && prestartedVmsCounter < numOfVmsToPrestart) {
                ArrayList<String> messages = new ArrayList<>();
                if (prestartVm(map.getVmId(), messages)) {
                    prestartedVmsCounter++;
                    failedAttempts = 0;
                } else {
                    failedAttempts++;
                    collectVmPrestartFailureReasons(failureReasons, messages);
                }
            } else {
                // If we reached the required amount or we exceeded the number of allowed failures, stop
                logResultOfPrestartVms(prestartedVmsCounter, numOfVmsToPrestart, vmPoolId, failureReasons);
                break;
            }
        }
    } else {
        log.info("No Vms available for prestarting");
    }
}
#method_after
private void prestartVms(Guid vmPoolId, int numOfVmsToPrestart) {
    // Fetch all vms that are in status down
    List<VmPoolMap> vmPoolMaps = DbFacade.getInstance().getVmPoolDao().getVmMapsInVmPoolByVmPoolIdAndStatus(vmPoolId, VMStatus.Down);
    int failedAttempts = 0;
    int prestartedVmsCounter = 0;
    final int maxFailedAttempts = Config.<Integer>getValue(ConfigValues.VmPoolMonitorMaxAttempts);
    Map<String, Integer> failureReasons = new HashMap<>();
    if (vmPoolMaps != null && vmPoolMaps.size() > 0) {
        for (VmPoolMap map : vmPoolMaps) {
            if (failedAttempts < maxFailedAttempts && prestartedVmsCounter < numOfVmsToPrestart) {
                List<String> messages = new ArrayList<>();
                if (prestartVm(map.getVmId(), messages)) {
                    prestartedVmsCounter++;
                    failedAttempts = 0;
                } else {
                    failedAttempts++;
                    collectVmPrestartFailureReasons(failureReasons, messages);
                }
            } else {
                // If we reached the required amount or we exceeded the number of allowed failures, stop
                logResultOfPrestartVms(prestartedVmsCounter, numOfVmsToPrestart, vmPoolId, failureReasons);
                break;
            }
        }
    } else {
        log.info("No VMs available for prestarting");
    }
}
#end_block

#method_before
private void collectVmPrestartFailureReasons(Map<String, Integer> failureReasons, List<String> messages) {
    String reason = String.join(", ", messages);
    Integer count = failureReasons.get(reason);
    failureReasons.put(reason, count == null ? 1 : count + 1);
}
#method_after
private void collectVmPrestartFailureReasons(Map<String, Integer> failureReasons, List<String> messages) {
    if (log.isInfoEnabled()) {
        String reason = messages.stream().filter(ErrorMessageUtils::isMessage).collect(Collectors.joining(", "));
        Integer count = failureReasons.get(reason);
        failureReasons.put(reason, count == null ? 1 : count + 1);
    }
}
#end_block

#method_before
private void logResultOfPrestartVms(int prestartedVmsCounter, int numOfVmsToPrestart, Guid vmPoolId, Map<String, Integer> failureReasons) {
    if (prestartedVmsCounter > 0) {
        log.info("Prestarted {} Vms out of the {} required, in VmPool '{}'", prestartedVmsCounter, numOfVmsToPrestart, vmPoolId);
    } else {
        log.info("Failed to prestart any Vms for VmPool '{}'", vmPoolId);
    }
    if (prestartedVmsCounter < numOfVmsToPrestart) {
        for (Map.Entry<String, Integer> entry : failureReasons.entrySet()) {
            log.info("Failed to prestart {} Vms with reason {}", entry.getValue(), entry.getKey());
        }
    }
}
#method_after
private void logResultOfPrestartVms(int prestartedVmsCounter, int numOfVmsToPrestart, Guid vmPoolId, Map<String, Integer> failureReasons) {
    if (prestartedVmsCounter > 0) {
        log.info("Prestarted {} VMs out of the {} required, in VmPool '{}'", prestartedVmsCounter, numOfVmsToPrestart, vmPoolId);
    } else {
        log.info("Failed to prestart any VMs for VmPool '{}'", vmPoolId);
    }
    if (prestartedVmsCounter < numOfVmsToPrestart) {
        for (Map.Entry<String, Integer> entry : failureReasons.entrySet()) {
            log.info("Failed to prestart {} VMs with reason {}", entry.getValue(), entry.getKey());
        }
    }
}
#end_block

#method_before
private boolean runVmAsStateless(VM vmToRunAsStateless) {
    log.info("Running Vm '{}' as stateless", vmToRunAsStateless);
    RunVmParams runVmParams = new RunVmParams(vmToRunAsStateless.getId());
    runVmParams.setEntityInfo(new EntityInfo(VdcObjectType.VM, vmToRunAsStateless.getId()));
    runVmParams.setRunAsStateless(true);
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, runVmParams, ExecutionHandler.createInternalJobContext());
    boolean prestartingVmSucceeded = vdcReturnValue.getSucceeded();
    if (!prestartingVmSucceeded) {
        AuditLogableBase log = new AuditLogableBase();
        log.addCustomValue("VmPoolName", vmToRunAsStateless.getVmPoolName());
        new AuditLogDirector().log(log, AuditLogType.VM_FAILED_TO_PRESTART_IN_POOL);
    }
    log.info("Running Vm '{}' as stateless {}", vmToRunAsStateless, prestartingVmSucceeded ? "succeeded" : "failed");
    return prestartingVmSucceeded;
}
#method_after
private boolean runVmAsStateless(VM vmToRunAsStateless) {
    log.info("Running VM '{}' as stateless", vmToRunAsStateless);
    RunVmParams runVmParams = new RunVmParams(vmToRunAsStateless.getId());
    runVmParams.setEntityInfo(new EntityInfo(VdcObjectType.VM, vmToRunAsStateless.getId()));
    runVmParams.setRunAsStateless(true);
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, runVmParams, ExecutionHandler.createInternalJobContext());
    boolean prestartingVmSucceeded = vdcReturnValue.getSucceeded();
    if (!prestartingVmSucceeded) {
        AuditLogableBase log = new AuditLogableBase();
        log.addCustomValue("VmPoolName", vmToRunAsStateless.getVmPoolName());
        new AuditLogDirector().log(log, AuditLogType.VM_FAILED_TO_PRESTART_IN_POOL);
    }
    log.info("Running VM '{}' as stateless {}", vmToRunAsStateless, prestartingVmSucceeded ? "succeeded" : "failed");
    return prestartingVmSucceeded;
}
#end_block

#method_before
protected Array createArrayOf(String typeName, Object[] array) {
    Connection connection = null;
    try {
        connection = getJdbcTemplate().getDataSource().getConnection();
        return connection.createArrayOf(typeName, array);
    } catch (SQLException e) {
        throw new RuntimeException(e);
    } finally {
        if (connection != null) {
            try {
                connection.close();
            } catch (SQLException e) {
            }
        }
    }
}
#method_after
protected Array createArrayOf(String typeName, Object[] array) {
    try (Connection connection = getJdbcTemplate().getDataSource().getConnection()) {
        return connection.createArrayOf(typeName, array);
    } catch (SQLException ex) {
        throw new RuntimeException(ex);
    }
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__REMOVE);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__LABEL);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__REMOVE);
    addValidationMessage(EngineMessage.VAR__TYPE__LABEL);
}
#end_block

#method_before
@Test
public void testInterfaceExistsWhenInterfaceIsNull() throws Exception {
    String failingSlaveName = "slaveName";
    assertThat(new HostInterfaceValidator(null).interfaceExists(failingSlaveName), failsWith(EngineMessage.HOST_NETWORK_INTERFACE_HAVING_NAME_DOES_NOT_EXIST, ReplacementUtils.createSetVariableString(HostInterfaceValidator.VAR_NIC_NAME, failingSlaveName)));
}
#method_after
@Test
public void testInterfaceExistsWhenInterfaceIsNull() throws Exception {
    String failingSlaveName = "slaveName";
    EngineMessage engineMessage = EngineMessage.HOST_NETWORK_INTERFACE_HAVING_NAME_DOES_NOT_EXIST;
    String nicNameReplacement = ReplacementUtils.getVariableAssignmentString(engineMessage, failingSlaveName);
    assertThat(new HostInterfaceValidator(null).interfaceExists(failingSlaveName), failsWith(engineMessage, nicNameReplacement));
}
#end_block

#method_before
@Test
public void testInterfaceAlreadyLabeledWithWhenInterfaceIsNotLabeled() throws Exception {
    VdsNetworkInterface vdsNetworkInterface = createVdsNetworkInterfaceWithName();
    vdsNetworkInterface.setLabels(new HashSet<String>());
    assertThat(new HostInterfaceValidator(vdsNetworkInterface).interfaceAlreadyLabeledWith("labelA"), isValid());
}
#method_after
@Test
public void testInterfaceAlreadyLabeledWithWhenInterfaceIsNotLabeled() throws Exception {
    VdsNetworkInterface vdsNetworkInterface = createVdsNetworkInterfaceWithName();
    vdsNetworkInterface.setLabels(new HashSet<>());
    assertThat(new HostInterfaceValidator(vdsNetworkInterface).interfaceAlreadyLabeledWith("labelA"), isValid());
}
#end_block

#method_before
// TODO MM: note for CR: this cannot happen and testing for it also does not make sense, since produced message would be inaccurate.
// TODO MM: remove, also with nullity check in validator.
// @Test
// public void testInterfaceByNameExistsWhenInterfaceIsNull() throws Exception {
// assertThat(new HostInterfaceValidator(null).interfaceHasNameSet(),
// failsWith(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST));
// 
// }
@Test
public void testInterfaceByNameExistsWhenInterfacesNameIsNull() throws Exception {
    assertThat(new HostInterfaceValidator(createVdsNetworkInterfaceWithName(null)).interfaceHasNameSet(), failsWith(EngineMessage.HOST_NETWORK_INTERFACE_DOES_NOT_HAVE_NAME_SET));
}
#method_after
@Test
public void testInterfaceByNameExistsWhenInterfacesNameIsNull() throws Exception {
    assertThat(new HostInterfaceValidator(createVdsNetworkInterfaceWithName(null)).interfaceHasNameSet(), failsWith(EngineMessage.HOST_NETWORK_INTERFACE_DOES_NOT_HAVE_NAME_SET));
}
#end_block

#method_before
protected Collection<String> getEntitiesNames(List<? extends Nameable> entities) {
    List<String> result = new ArrayList<>(entities.size());
    for (Nameable itemName : entities) {
        result.add(itemName.getName());
    }
    return result;
}
#method_after
private Collection<String> getEntitiesNames(List<? extends Nameable> entities) {
    List<String> result = new ArrayList<>(entities.size());
    for (Nameable itemName : entities) {
        result.add(itemName.getName());
    }
    return result;
}
#end_block

#method_before
public ValidationResult networkNotUsedByVms() {
    List<VM> vms = getVms();
    return networkNotUsedByVms(getEntitiesNames(vms));
}
#method_after
public ValidationResult networkNotUsedByVms() {
    return networkNotUsed(getVms(), EngineMessage.VAR__ENTITIES__VMS, EngineMessage.VAR__ENTITIES__VM);
}
#end_block

#method_before
public ValidationResult networkNotUsedByHosts() {
    List<VDS> allForNetwork = getDbFacade().getVdsDao().getAllForNetwork(network.getId());
    return new PluralMessages(EngineMessage.VAR__ENTITIES__HOST, EngineMessage.VAR__ENTITIES__HOSTS).getNetworkInUse(getEntitiesNames(allForNetwork));
}
#method_after
public ValidationResult networkNotUsedByHosts() {
    return networkNotUsed(getDbFacade().getVdsDao().getAllForNetwork(network.getId()), EngineMessage.VAR__ENTITIES__HOSTS, EngineMessage.VAR__ENTITIES__HOST);
}
#end_block

#method_before
public ValidationResult networkNotUsedByTemplates() {
    return new PluralMessages(EngineMessage.VAR__ENTITIES__VM_TEMPLATE, EngineMessage.VAR__ENTITIES__VM_TEMPLATES).getNetworkInUse(getEntitiesNames(getTemplates()));
}
#method_after
public ValidationResult networkNotUsedByTemplates() {
    return networkNotUsed(getTemplates(), EngineMessage.VAR__ENTITIES__VM_TEMPLATES, EngineMessage.VAR__ENTITIES__VM_TEMPLATE);
}
#end_block

#method_before
public ValidationResult networkAttachmentIsSet() {
    // TODO MM: what to do with this? this actually does not mean, that the attachment does not exist,
    // we just did not get one, and we don't even know how one searched for it, so we also don't know what to complain about.
    EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, null)).when(attachment == null);
}
#method_after
public ValidationResult networkAttachmentIsSet() {
    EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, null)).when(attachment == null);
}
#end_block

#method_before
public ValidationResult networkExists() {
    return getNetworkValidator().networkIsSet(attachment.getNetworkId());
}
#method_after
public ValidationResult networkExists() {
    Guid networkId = attachment.getNetworkId();
    String networkName = attachment.getNetworkName();
    // User did not specify neither id nor name.
    if (networkId == null && networkName == null) {
        return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_NETWORK_ID_OR_NAME_IS_NOT_SET);
    }
    // User specified id, for which completors did not find Network record.
    if (networkId != null && networkName == null) {
        EngineMessage engineMessage = EngineMessage.NETWORK_HAVING_ID_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, networkId.toString()));
    }
    // User specified name, for which completors did not find Network record.
    if (networkId == null && networkName != null) {
        EngineMessage engineMessage = EngineMessage.NETWORK_HAVING_NAME_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, networkName));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult networkNotUsedByVms() {
    if (FeatureSupported.changeNetworkUsedByVmSupported(host.getVdsGroupCompatibilityVersion())) {
        return ValidationResult.VALID;
    }
    Network network = getNetwork();
    List<String> vmNames = vmInterfaceManager.findActiveVmsUsingNetworks(host.getId(), Collections.singleton(network.getName()));
    return new NetworkValidator(this.vmDao, network).networkNotUsedByVms(vmNames);
}
#method_after
public ValidationResult networkNotUsedByVms() {
    return networkNotUsedByVms(getNetwork().getName());
}
#end_block

#method_before
public ValidationResult networkNotUsedByVms() {
    if (FeatureSupported.changeNetworkUsedByVmSupported(host.getVdsGroupCompatibilityVersion())) {
        return ValidationResult.VALID;
    }
    Network network = getNetwork();
    List<String> vmNames = vmInterfaceManager.findActiveVmsUsingNetworks(host.getId(), Collections.singleton(network.getName()));
    return new NetworkValidator(this.vmDao, network).networkNotUsedByVms(vmNames);
}
#method_after
private ValidationResult networkNotUsedByVms(String networkName) {
    if (FeatureSupported.changeNetworkUsedByVmSupported(host.getClusterCompatibilityVersion())) {
        return ValidationResult.VALID;
    }
    List<String> vmNames = vmInterfaceManager.findActiveVmsUsingNetworks(host.getId(), Collections.singleton(networkName));
    return new PluralMessages().getNetworkInUse(vmNames, EngineMessage.VAR__ENTITIES__VM, EngineMessage.VAR__ENTITIES__VMS);
}
#end_block

#method_before
/*
     * Flow to this method is tricky.
     * <br/>
     * <code>attachment.getNicName()</code> returns name of nic.
     * <br/>
     * This name is either calculated from nicId, and if it's null then it means:
     * a) nic of such ID does not exist thus name cannot be calculated. getNicName is null and nic does not exist.
     * b) user did not not provide neither nicId nor nicName and thus nic is not identified. getNicName is also null.
     * <br/>
     * and then there's bonus flow: user specified some nicName, which does not exist in system. This validation succeeds
     * while nic does not exist in system.
     * */
public ValidationResult nicNameIsSet() {
    return ValidationResult.failWith(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST).when(attachment.getNicName() == null);
}
#method_after
public ValidationResult nicNameIsSet() {
    return ValidationResult.failWith(EngineMessage.HOST_NETWORK_INTERFACE_DOES_NOT_HAVE_NAME_SET).when(attachment.getNicName() == null && attachment.getNicId() == null);
}
#end_block

#method_before
public ValidationResult validateGateway() {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    boolean invalidGateway = ipConfiguration != null && ipConfiguration.hasPrimaryAddressSet() && StringUtils.isNotEmpty(ipConfiguration.getPrimaryAddress().getGateway()) && !managementNetworkUtil.isManagementNetwork(getNetwork().getId()) && !FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion());
    EngineMessage engineMessage = EngineMessage.NETWORK_ATTACH_HAVING_NAME_ILLEGAL_GATEWAY;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, attachment.getNetworkName())).when(invalidGateway);
}
#method_after
public ValidationResult validateGateway() {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    boolean invalidGateway = ipConfiguration != null && ipConfiguration.hasPrimaryAddressSet() && StringUtils.isNotEmpty(ipConfiguration.getPrimaryAddress().getGateway()) && !managementNetworkUtil.isManagementNetwork(getNetwork().getId(), host.getClusterId()) && !FeatureSupported.multipleGatewaysSupported(host.getClusterCompatibilityVersion());
    EngineMessage engineMessage = EngineMessage.NETWORK_ATTACH_HAVING_NAME_ILLEGAL_GATEWAY;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, attachment.getNetworkName())).when(invalidGateway);
}
#end_block

#method_before
private NetworkCluster getNetworkCluster() {
    if (networkCluster == null) {
        NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
        networkCluster = networkClusterDao.get(networkClusterId);
    }
    return networkCluster;
}
#method_after
private NetworkCluster getNetworkCluster() {
    if (networkCluster == null) {
        NetworkClusterId networkClusterId = new NetworkClusterId(host.getClusterId(), attachment.getNetworkId());
        networkCluster = networkClusterDao.get(networkClusterId);
    }
    return networkCluster;
}
#end_block

#method_before
private VnicProfile getVnicProfileForNetwork(Network network, String vnicProfileName) {
    if (vnicProfileName == null) {
        return null;
    }
    for (VnicProfileView vnicProfile : getVnicProfilesInDc()) {
        if (ObjectUtils.equals(vnicProfile.getNetworkId(), network.getId()) && vnicProfileName.equals(vnicProfile.getName())) {
            return vnicProfile;
        }
    }
    return null;
}
#method_after
private VnicProfile getVnicProfileForNetwork(Network network, String vnicProfileName) {
    if (vnicProfileName == null) {
        return null;
    }
    for (VnicProfileView vnicProfile : getVnicProfilesInDc()) {
        if (Objects.equals(vnicProfile.getNetworkId(), network.getId()) && vnicProfileName.equals(vnicProfile.getName())) {
            return vnicProfile;
        }
    }
    return null;
}
#end_block

#method_before
public static ValidationResult updateNicForBackwardCompatibility(VmNic nic, VmNic oldNic, String networkName, boolean portMirroring, VmBase vm, DbUser user) {
    // if network wasn't provided, no need for backward compatibility logic
    if (networkName == null) {
        return ValidationResult.VALID;
    }
    // if the network was provided but unchanged, use the provided vnic profile id
    if (oldNic != null && oldNic.getVnicProfileId() != null) {
        VnicProfile oldProfile = getVnicProfileDao().get(oldNic.getVnicProfileId());
        Network oldNetwork = getNetworkDao().get(oldProfile.getNetworkId());
        if (StringUtils.equals(networkName, oldNetwork.getName())) {
            return ValidationResult.VALID;
        }
    }
    // empty network name is considered as an empty (unlinked) network
    if ("".equals(networkName)) {
        if (portMirroring) {
            return new ValidationResult(EngineMessage.PORT_MIRRORING_REQUIRES_NETWORK);
        } else {
            nic.setVnicProfileId(null);
            return ValidationResult.VALID;
        }
    }
    if (vm.getVdsGroupId() == null) {
        return networkOfGivenNameNotExistsInCluster(networkName);
    }
    // if the network was provided with changed name, resolve a suitable profile for it
    Network network = getNetworkDao().getByNameAndCluster(networkName, vm.getVdsGroupId());
    if (network == null) {
        return networkOfGivenNameNotExistsInCluster(networkName);
    }
    List<VnicProfile> vnicProfiles = getVnicProfileDao().getAllForNetwork(network.getId());
    for (VnicProfile profile : vnicProfiles) {
        if (isVnicProfilePermitted(user, profile, portMirroring)) {
            nic.setVnicProfileId(profile.getId());
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_CANNOT_FIND_VNIC_PROFILE_FOR_NETWORK);
}
#method_after
public static ValidationResult updateNicForBackwardCompatibility(VmNic nic, VmNic oldNic, String networkName, boolean portMirroring, VmBase vm, DbUser user) {
    // if network wasn't provided, no need for backward compatibility logic
    if (networkName == null) {
        return ValidationResult.VALID;
    }
    // if the network was provided but unchanged, use the provided vnic profile id
    if (oldNic != null && oldNic.getVnicProfileId() != null) {
        VnicProfile oldProfile = getVnicProfileDao().get(oldNic.getVnicProfileId());
        Network oldNetwork = getNetworkDao().get(oldProfile.getNetworkId());
        if (StringUtils.equals(networkName, oldNetwork.getName())) {
            return ValidationResult.VALID;
        }
    }
    // empty network name is considered as an empty (unlinked) network
    if ("".equals(networkName)) {
        if (portMirroring) {
            return new ValidationResult(EngineMessage.PORT_MIRRORING_REQUIRES_NETWORK);
        } else {
            nic.setVnicProfileId(null);
            return ValidationResult.VALID;
        }
    }
    if (vm.getClusterId() == null) {
        return networkOfGivenNameNotExistsInCluster(networkName);
    }
    // if the network was provided with changed name, resolve a suitable profile for it
    Network network = getNetworkDao().getByNameAndCluster(networkName, vm.getClusterId());
    if (network == null) {
        return networkOfGivenNameNotExistsInCluster(networkName);
    }
    List<VnicProfile> vnicProfiles = getVnicProfileDao().getAllForNetwork(network.getId());
    for (VnicProfile profile : vnicProfiles) {
        if (isVnicProfilePermitted(user, profile, portMirroring)) {
            nic.setVnicProfileId(profile.getId());
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_CANNOT_FIND_VNIC_PROFILE_FOR_NETWORK);
}
#end_block

#method_before
@Test
public void testNetworkAttachmentIsSetWhenAttachmentIsNull() throws Exception {
    EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS;
    assertThat(createNetworkAttachmentValidator(null).networkAttachmentIsSet(), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, "null")));
}
#method_after
@Test
public void testNetworkAttachmentIsSetWhenAttachmentIsNull() {
    EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS;
    assertThat(createNetworkAttachmentValidator(null).networkAttachmentIsSet(), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, "null")));
}
#end_block

#method_before
@Test
public void testNetworkAttachmentIsSetWhenAttachmentIsNotNull() throws Exception {
    assertThat(createNetworkAttachmentValidator(new NetworkAttachment()).networkAttachmentIsSet(), isValid());
}
#method_after
@Test
public void testNetworkAttachmentIsSetWhenAttachmentIsNotNull() {
    assertThat(createNetworkAttachmentValidator(new NetworkAttachment()).networkAttachmentIsSet(), isValid());
}
#end_block

#method_before
@Test
public void testNotExternalNetworkWhenExternalNetworkIsProvided() throws Exception {
    Network externalNetwork = new Network();
    externalNetwork.setId(Guid.newGuid());
    externalNetwork.setProvidedBy(new ProviderNetwork(Guid.newGuid(), ""));
    when(networkDaoMock.get(eq(externalNetwork.getId()))).thenReturn(externalNetwork);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(externalNetwork.getId());
    assertThat(createNetworkAttachmentValidator(attachment).notExternalNetwork(), failsWith(EngineMessage.EXTERNAL_NETWORK_HAVING_NAME_CANNOT_BE_PROVISIONED));
}
#method_after
@Test
public void testNotExternalNetworkWhenExternalNetworkIsProvided() {
    Network externalNetwork = new Network();
    externalNetwork.setId(Guid.newGuid());
    externalNetwork.setProvidedBy(new ProviderNetwork(Guid.newGuid(), ""));
    when(networkDaoMock.get(eq(externalNetwork.getId()))).thenReturn(externalNetwork);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(externalNetwork.getId());
    assertThat(createNetworkAttachmentValidator(attachment).notExternalNetwork(), failsWith(EngineMessage.EXTERNAL_NETWORK_HAVING_NAME_CANNOT_BE_PROVISIONED));
}
#end_block

#method_before
@Test
public void testNotExternalNetwork() throws Exception {
    Network notExternalNetwork = new Network();
    notExternalNetwork.setId(Guid.newGuid());
    notExternalNetwork.setProvidedBy(null);
    when(networkDaoMock.get(eq(notExternalNetwork.getId()))).thenReturn(notExternalNetwork);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(notExternalNetwork.getId());
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
    assertThat(validator.notExternalNetwork(), isValid());
}
#method_after
@Test
public void testNotExternalNetwork() {
    Network notExternalNetwork = new Network();
    notExternalNetwork.setId(Guid.newGuid());
    notExternalNetwork.setProvidedBy(null);
    when(networkDaoMock.get(eq(notExternalNetwork.getId()))).thenReturn(notExternalNetwork);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(notExternalNetwork.getId());
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
    assertThat(validator.notExternalNetwork(), isValid());
}
#end_block

#method_before
@Test
public void testNotRemovingManagementNetwork() throws Exception {
    NetworkAttachmentValidator networkAttachmentValidatorSpy = Mockito.spy(createNetworkAttachmentValidator(new NetworkAttachment()));
    doReturn(networkValidatorMock).when(networkAttachmentValidatorSpy).getNetworkValidator();
    ValidationResult propagatedResult = new ValidationResult(EngineMessage.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a");
    when(networkValidatorMock.notRemovingManagementNetwork()).thenReturn(propagatedResult);
    assertThat("ValidationResult is not correctly propagated", networkAttachmentValidatorSpy.notRemovingManagementNetwork(), failsWith(EngineMessage.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a"));
}
#method_after
@Test
public void testNotRemovingManagementNetwork() {
    NetworkAttachmentValidator networkAttachmentValidatorSpy = Mockito.spy(createNetworkAttachmentValidator(new NetworkAttachment()));
    doReturn(networkValidatorMock).when(networkAttachmentValidatorSpy).getNetworkValidator();
    ValidationResult propagatedResult = new ValidationResult(EngineMessage.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a");
    when(networkValidatorMock.notRemovingManagementNetwork()).thenReturn(propagatedResult);
    assertThat("ValidationResult is not correctly propagated", networkAttachmentValidatorSpy.notRemovingManagementNetwork(), failsWith(EngineMessage.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a"));
}
#end_block

#method_before
@Test
public void testNetworkAttachedToClusterWhenAttached() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(new NetworkCluster());
    when(networkDaoMock.get(eq(network.getId()))).thenReturn(network);
    assertThat(createNetworkAttachmentValidator(attachment).networkAttachedToCluster(), isValid());
}
#method_after
@Test
public void testNetworkAttachedToClusterWhenAttached() {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getClusterId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(new NetworkCluster());
    when(networkDaoMock.get(eq(network.getId()))).thenReturn(network);
    assertThat(createNetworkAttachmentValidator(attachment).networkAttachedToCluster(), isValid());
}
#end_block

#method_before
@Test
public void testNetworkAttachedToClusterWhenNotAttached() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    network.setName("networkName");
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    attachment.setNetworkName(network.getName());
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), network.getId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(null);
    when(networkDaoMock.get(eq(network.getId()))).thenReturn(network);
    EngineMessage engineMessage = EngineMessage.NETWORK_OF_GIVEN_NAME_NOT_EXISTS_IN_CLUSTER;
    assertThat(createNetworkAttachmentValidator(attachment).networkAttachedToCluster(), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, network.getName())));
}
#method_after
@Test
public void testNetworkAttachedToClusterWhenNotAttached() {
    Network network = new Network();
    network.setId(Guid.newGuid());
    network.setName("networkName");
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    attachment.setNetworkName(network.getName());
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getClusterId(), network.getId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(null);
    when(networkDaoMock.get(eq(network.getId()))).thenReturn(network);
    EngineMessage engineMessage = EngineMessage.NETWORK_OF_GIVEN_NAME_NOT_EXISTS_IN_CLUSTER;
    assertThat(createNetworkAttachmentValidator(attachment).networkAttachedToCluster(), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, network.getName())));
}
#end_block

#method_before
@Test
public void testNicExistsWhenNicNameIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicName(null);
    assertThat(createNetworkAttachmentValidator(attachment).nicNameIsSet(), failsWith(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#method_after
@Test
public void testNicExistsWhenNicNameIsNull() {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicName(null);
    assertThat(createNetworkAttachmentValidator(attachment).nicNameIsSet(), failsWith(EngineMessage.HOST_NETWORK_INTERFACE_DOES_NOT_HAVE_NAME_SET));
}
#end_block

#method_before
@Test
public void testNicExistsWhenNicNameIsNotNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicId(null);
    attachment.setNicName("whatever");
    assertThat(createNetworkAttachmentValidator(attachment).nicNameIsSet(), isValid());
}
#method_after
@Test
public void testNicExistsWhenNicNameIsNotNull() {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicId(null);
    attachment.setNicName("whatever");
    assertThat(createNetworkAttachmentValidator(attachment).nicNameIsSet(), isValid());
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    assertThat(createNetworkAttachmentValidator(attachment).networkIpAddressWasSameAsHostnameAndChanged(null), isValid());
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsNull() {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    assertThat(createNetworkAttachmentValidator(attachment).networkIpAddressWasSameAsHostnameAndChanged(null), isValid());
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsDhcp() throws Exception {
    doTestNetworkIpAddressWasSameAsHostnameAndChangedForBootProtocol(NetworkBootProtocol.DHCP);
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsDhcp() {
    doTestNetworkIpAddressWasSameAsHostnameAndChangedForBootProtocol(NetworkBootProtocol.DHCP);
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsNone() throws Exception {
    doTestNetworkIpAddressWasSameAsHostnameAndChangedForBootProtocol(NetworkBootProtocol.NONE);
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsNone() {
    doTestNetworkIpAddressWasSameAsHostnameAndChangedForBootProtocol(NetworkBootProtocol.NONE);
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIfaceDoesNotExist() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, null);
    attachment.setNicName("nicName");
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
    BusinessEntityMap<VdsNetworkInterface> nics = new BusinessEntityMap<>(Collections.<VdsNetworkInterface>emptyList());
    assertThat(validator.networkIpAddressWasSameAsHostnameAndChanged(nics), isValid());
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIfaceDoesNotExist() {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, null);
    attachment.setNicName("nicName");
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
    BusinessEntityMap<VdsNetworkInterface> nics = new BusinessEntityMap<>(Collections.<VdsNetworkInterface>emptyList());
    assertThat(validator.networkIpAddressWasSameAsHostnameAndChanged(nics), isValid());
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChanged() throws Exception {
    Network network = new Network();
    network.setName("networkName");
    network.setId(Guid.newGuid());
    VdsNetworkInterface existingInterface = new VdsNetworkInterface();
    existingInterface.setName("nicName");
    existingInterface.setAddress("anyAddress");
    existingInterface.setNetworkName(network.getName());
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, null);
    attachment.setNicName(existingInterface.getName());
    attachment.setNetworkId(network.getId());
    host.setHostName(existingInterface.getAddress());
    when(networkDaoMock.get(attachment.getNetworkId())).thenReturn(network);
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
    BusinessEntityMap<VdsNetworkInterface> nics = new BusinessEntityMap<>(Collections.singletonList(existingInterface));
    assertThat(validator.networkIpAddressWasSameAsHostnameAndChanged(nics), failsWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED, ReplacementUtils.createSetVariableString(NetworkAttachmentValidator.VAR_ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED_LIST, existingInterface.getNetworkName())));
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChanged() {
    Network network = new Network();
    network.setName("networkName");
    network.setId(Guid.newGuid());
    VdsNetworkInterface existingInterface = new VdsNetworkInterface();
    existingInterface.setName("nicName");
    existingInterface.setAddress("anyAddress");
    existingInterface.setNetworkName(network.getName());
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, null);
    attachment.setNicName(existingInterface.getName());
    attachment.setNetworkId(network.getId());
    host.setHostName(existingInterface.getAddress());
    when(networkDaoMock.get(attachment.getNetworkId())).thenReturn(network);
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
    BusinessEntityMap<VdsNetworkInterface> nics = new BusinessEntityMap<>(Collections.singletonList(existingInterface));
    assertThat(validator.networkIpAddressWasSameAsHostnameAndChanged(nics), failsWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED, ReplacementUtils.createSetVariableString(NetworkAttachmentValidator.VAR_ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED_LIST, existingInterface.getNetworkName())));
}
#end_block

#method_before
@Test
public void testNetworkNotChangedWhenOldAttachmentIsNull() throws Exception {
    assertThat(createNetworkAttachmentValidator(null).networkNotChanged(null), isValid());
}
#method_after
@Test
public void testNetworkNotChangedWhenOldAttachmentIsNull() {
    assertThat(createNetworkAttachmentValidator(null).networkNotChanged(null), isValid());
}
#end_block

#method_before
@Test
public void testNetworkNotChangedWhenDifferentNetworkIds() throws Exception {
    NetworkAttachment oldAttachment = new NetworkAttachment();
    oldAttachment.setId(Guid.newGuid());
    oldAttachment.setNetworkId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(Guid.newGuid());
    assertThat(createNetworkAttachmentValidator(attachment).networkNotChanged(oldAttachment), failsWith(EngineMessage.CANNOT_CHANGE_ATTACHED_NETWORK, ReplacementUtils.createSetVariableString(NetworkAttachmentValidator.VAR_NETWORK_ATTACHMENT_ID, oldAttachment.getId())));
}
#method_after
@Test
public void testNetworkNotChangedWhenDifferentNetworkIds() {
    NetworkAttachment oldAttachment = new NetworkAttachment();
    oldAttachment.setId(Guid.newGuid());
    oldAttachment.setNetworkId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(Guid.newGuid());
    assertThat(createNetworkAttachmentValidator(attachment).networkNotChanged(oldAttachment), failsWith(EngineMessage.CANNOT_CHANGE_ATTACHED_NETWORK, ReplacementUtils.createSetVariableString(NetworkAttachmentValidator.VAR_NETWORK_ATTACHMENT_ID, oldAttachment.getId())));
}
#end_block

#method_before
@Test
public void testNetworkNotChanged() throws Exception {
    Guid networkId = Guid.newGuid();
    NetworkAttachment oldAttachment = new NetworkAttachment();
    oldAttachment.setNetworkId(networkId);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(networkId);
    assertThat(createNetworkAttachmentValidator(attachment).networkNotChanged(oldAttachment), isValid());
}
#method_after
@Test
public void testNetworkNotChanged() {
    Guid networkId = Guid.newGuid();
    NetworkAttachment oldAttachment = new NetworkAttachment();
    oldAttachment.setNetworkId(networkId);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(networkId);
    assertThat(createNetworkAttachmentValidator(attachment).networkNotChanged(oldAttachment), isValid());
}
#end_block

#method_before
@Test
public void testValidateGatewayWhenIpConfigurationIsNotSet() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    assertThat(createNetworkAttachmentValidator(attachment).validateGateway(), isValid());
}
#method_after
@Test
public void testValidateGatewayWhenIpConfigurationIsNotSet() {
    NetworkAttachment attachment = new NetworkAttachment();
    assertThat(createNetworkAttachmentValidator(attachment).validateGateway(), isValid());
}
#end_block

#method_before
@Test
public void testValidateGatewayWhenGatewayIsNull() throws Exception {
    doTestValidateGateway(null, false, isValid());
}
#method_after
@Test
public void testValidateGatewayWhenGatewayIsNull() {
    doTestValidateGateway(null, false, true, isValid());
}
#end_block

#method_before
@Test
public void testValidateGatewayWhenGatewayIsNotSpecified() throws Exception {
    doTestValidateGateway("", false, isValid());
}
#method_after
@Test
public void testValidateGatewayWhenGatewayIsNotSpecified() {
    doTestValidateGateway("", false, true, isValid());
}
#end_block

#method_before
private void doTestValidateGateway(String gatewayValue, boolean managementNetwork, Matcher<ValidationResult> resultMatcher) {
    Network network = createNetwork();
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null);
    attachment.setNetworkId(network.getId());
    attachment.getIpConfiguration().getPrimaryAddress().setGateway(gatewayValue);
    when(networkDaoMock.get(eq(network.getId()))).thenReturn(network);
    when(managementNetworkUtilMock.isManagementNetwork(network.getId())).thenReturn(managementNetwork);
    assertThat(createNetworkAttachmentValidator(attachment).validateGateway(), resultMatcher);
}
#method_after
private void doTestValidateGateway(String gatewayValue, boolean managementNetwork, boolean multipleGatewaysSupported, Matcher<ValidationResult> resultMatcher) {
    host.setClusterCompatibilityVersion(multipleGatewaysSupported ? Version.v3_6 : Version.v3_5);
    Network network = createNetwork();
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null);
    attachment.setNetworkId(network.getId());
    attachment.getIpConfiguration().getPrimaryAddress().setGateway(gatewayValue);
    when(networkDaoMock.get(eq(network.getId()))).thenReturn(network);
    when(managementNetworkUtilMock.isManagementNetwork(network.getId(), CLUSTER_ID)).thenReturn(managementNetwork);
    assertThat(createNetworkAttachmentValidator(attachment).validateGateway(), resultMatcher);
}
#end_block

#method_before
@Test
public void testNetworkNotAttachedToHost() throws Exception {
    Network network = createNetwork();
    when(networkDaoMock.get(network.getId())).thenReturn(network);
    // no vds for network id.
    when(vdsDaoMock.getAllForNetwork(eq(network.getId()))).thenReturn(Collections.<VDS>emptyList());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    assertThat(createNetworkAttachmentValidator(attachment).networkNotAttachedToHost(), isValid());
}
#method_after
@Test
public void testNetworkNotAttachedToHost() {
    Network network = createNetwork();
    when(networkDaoMock.get(network.getId())).thenReturn(network);
    // no vds for network id.
    when(vdsDaoMock.getAllForNetwork(eq(network.getId()))).thenReturn(Collections.<VDS>emptyList());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    assertThat(createNetworkAttachmentValidator(attachment).networkNotAttachedToHost(), isValid());
}
#end_block

#method_before
@Test
public void testNetworkNotAttachedToHostWhenAttached() throws Exception {
    Network network = createNetwork();
    when(networkDaoMock.get(network.getId())).thenReturn(network);
    when(vdsDaoMock.getAllForNetwork(eq(network.getId()))).thenReturn(Collections.singletonList(host));
    String networkName = "networkName";
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    attachment.setNetworkName(networkName);
    assertThat(createNetworkAttachmentValidator(attachment).networkNotAttachedToHost(), failsWith(EngineMessage.NETWORK_ALREADY_ATTACHED_TO_HOST, ReplacementUtils.createSetVariableString("networkName", networkName), ReplacementUtils.createSetVariableString("hostName", host.getName())));
}
#method_after
@Test
public void testNetworkNotAttachedToHostWhenAttached() {
    Network network = createNetwork();
    when(networkDaoMock.get(network.getId())).thenReturn(network);
    when(vdsDaoMock.getAllForNetwork(eq(network.getId()))).thenReturn(Collections.singletonList(host));
    String networkName = "networkName";
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    attachment.setNetworkName(networkName);
    assertThat(createNetworkAttachmentValidator(attachment).networkNotAttachedToHost(), failsWith(EngineMessage.NETWORK_ALREADY_ATTACHED_TO_HOST, ReplacementUtils.createSetVariableString("networkName", networkName), ReplacementUtils.createSetVariableString("hostName", host.getName())));
}
#end_block

#method_before
@Test
public void testNetworkNotUsedByVmsWhenNotUsed() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    network.setName("name");
    host.setVdsGroupCompatibilityVersion(Version.v3_5);
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setNetworkId(network.getId());
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(networkAttachment);
    when(vmInterfaceManager.findActiveVmsUsingNetworks(eq(host.getId()), collectionContainingOneGivenNetworkName(network.getName()))).thenReturn(Collections.<String>emptyList());
    when(networkDaoMock.get(eq(network.getId()))).thenReturn(network);
    assertThat(validator.networkNotUsedByVms(), isValid());
}
#method_after
@Test
public void testNetworkNotUsedByVmsWhenNotUsed() {
    Network network = new Network();
    network.setId(Guid.newGuid());
    network.setName("name");
    host.setClusterCompatibilityVersion(Version.v3_5);
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setNetworkId(network.getId());
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(networkAttachment);
    when(vmInterfaceManager.findActiveVmsUsingNetworks(eq(host.getId()), collectionContainingOneGivenNetworkName(network.getName()))).thenReturn(Collections.<String>emptyList());
    when(networkDaoMock.get(eq(network.getId()))).thenReturn(network);
    assertThat(validator.networkNotUsedByVms(), isValid());
}
#end_block

#method_before
@Test
public void testNetworkNotUsedByVmsWhenUsedChangeNotSupported() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    network.setName("name");
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setNetworkId(network.getId());
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(networkAttachment);
    when(vmInterfaceManager.findActiveVmsUsingNetworks(eq(host.getId()), collectionContainingOneGivenNetworkName(network.getName()))).thenReturn(Collections.singletonList("networkName"));
    when(networkDaoMock.get(eq(network.getId()))).thenReturn(network);
    host.setVdsGroupCompatibilityVersion(Version.v3_5);
    assertThat(validator.networkNotUsedByVms(), failsWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_IN_ONE_USE));
}
#method_after
@Test
public void testNetworkNotUsedByVmsWhenUsedChangeNotSupported() {
    Network network = new Network();
    network.setId(Guid.newGuid());
    network.setName("name");
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setNetworkId(network.getId());
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(networkAttachment);
    when(vmInterfaceManager.findActiveVmsUsingNetworks(eq(host.getId()), collectionContainingOneGivenNetworkName(network.getName()))).thenReturn(Collections.singletonList("networkName"));
    when(networkDaoMock.get(eq(network.getId()))).thenReturn(network);
    host.setClusterCompatibilityVersion(Version.v3_5);
    assertThat(validator.networkNotUsedByVms(), failsWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_IN_ONE_USE));
}
#end_block

#method_before
@Test
public void testNetworkNotUsedByVmsWhenUsedChangeSupported() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    network.setName("name");
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setNetworkId(network.getId());
    when(networkDaoMock.get(eq(network.getId()))).thenReturn(network);
    host.setVdsGroupCompatibilityVersion(Version.v3_6);
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(networkAttachment);
    assertThat(validator.networkNotUsedByVms(), isValid());
}
#method_after
@Test
public void testNetworkNotUsedByVmsWhenUsedChangeSupported() {
    Network network = new Network();
    network.setId(Guid.newGuid());
    network.setName("name");
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setNetworkId(network.getId());
    when(networkDaoMock.get(eq(network.getId()))).thenReturn(network);
    host.setClusterCompatibilityVersion(Version.v3_6);
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(networkAttachment);
    assertThat(validator.networkNotUsedByVms(), isValid());
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__ADD);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__LABEL);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__ADD);
    addValidationMessage(EngineMessage.VAR__TYPE__LABEL);
}
#end_block

#method_before
// public ValidationResult __interfaceExists() {
// this is crap
// return ValidationResult.failWith(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST).when(iface == null);
// }
public ValidationResult interfaceExists(String nicId) {
    return ValidationResult.failWith(EngineMessage.HOST_NETWORK_INTERFACE_HAVING_NAME_DOES_NOT_EXIST, ReplacementUtils.createSetVariableString(VAR_NIC_NAME, nicId)).when(iface == null);
}
#method_after
public ValidationResult interfaceExists(String nicName) {
    EngineMessage engineMessage = EngineMessage.HOST_NETWORK_INTERFACE_HAVING_NAME_DOES_NOT_EXIST;
    String nicNameReplacement = ReplacementUtils.getVariableAssignmentString(engineMessage, nicName);
    return ValidationResult.failWith(engineMessage, nicNameReplacement).when(iface == null);
}
#end_block

#method_before
public ValidationResult interfaceHasNameSet() {
    // TODO MM: iface here is new or modified bond. Namely if it's new device, it does not have id set, so I don't know how to make message more specific.
    return ValidationResult.failWith(EngineMessage.HOST_NETWORK_INTERFACE_DOES_NOT_HAVE_NAME_SET).when(/*iface == null || */
    iface.getName() == null);
}
#method_after
public ValidationResult interfaceHasNameSet() {
    return ValidationResult.failWith(EngineMessage.HOST_NETWORK_INTERFACE_DOES_NOT_HAVE_NAME_SET).when(iface.getName() == null);
}
#end_block

#method_before
private List<String> validateNetworksNotAssignedToIncorrectNics(List<VdsNetworkInterface> hostInterfaces, List<Network> networks) {
    Map<String, VdsNetworkInterface> networkNameToNicMap = Entities.hostInterfacesByNetworkName(hostInterfaces);
    List<String> badlyAssignedNetworks = new ArrayList<>();
    for (Network network : networks) {
        boolean networkIsAssignedToHostInterface = networkNameToNicMap.containsKey(network.getName());
        if (networkIsAssignedToHostInterface) {
            VdsNetworkInterface assignedHostInterface = networkNameToNicMap.get(network.getName());
            if (!StringUtils.equals(iface.getName(), NetworkUtils.stripVlan(assignedHostInterface))) {
                badlyAssignedNetworks.add(network.getName());
            }
        }
    }
    return badlyAssignedNetworks;
}
#method_after
private List<String> validateNetworksNotAssignedToIncorrectNics(List<VdsNetworkInterface> hostInterfaces, List<Network> networks) {
    Map<String, VdsNetworkInterface> networkNameToNicMap = NetworkUtils.hostInterfacesByNetworkName(hostInterfaces);
    List<String> badlyAssignedNetworks = new ArrayList<>();
    for (Network network : networks) {
        boolean networkIsAssignedToHostInterface = networkNameToNicMap.containsKey(network.getName());
        if (networkIsAssignedToHostInterface) {
            VdsNetworkInterface assignedHostInterface = networkNameToNicMap.get(network.getName());
            if (!StringUtils.equals(iface.getName(), NetworkUtils.stripVlan(assignedHostInterface))) {
                badlyAssignedNetworks.add(network.getName());
            }
        }
    }
    return badlyAssignedNetworks;
}
#end_block

#method_before
private void setSupportedFeatures() {
    Version clusterCompatibilityVersion = host.getVdsGroupCompatibilityVersion();
    networkCustomPropertiesSupported = FeatureSupported.networkCustomProperties(clusterCompatibilityVersion);
    hostNetworkQosSupported = FeatureSupported.hostNetworkQos(clusterCompatibilityVersion);
}
#method_after
private void setSupportedFeatures() {
    Version clusterCompatibilityVersion = host.getClusterCompatibilityVersion();
    networkCustomPropertiesSupported = FeatureSupported.networkCustomProperties(clusterCompatibilityVersion);
    hostNetworkQosSupported = FeatureSupported.hostNetworkQos(clusterCompatibilityVersion);
}
#end_block

#method_before
List<String> translateErrorMessages(List<String> messages) {
    return Backend.getInstance().getErrorsTranslator().TranslateErrorText(messages);
}
#method_after
List<String> translateErrorMessages(List<String> messages) {
    return Backend.getInstance().getErrorsTranslator().translateErrorText(messages);
}
#end_block

#method_before
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : new NicLabelValidator(params, existingInterfacesMap, bondsMap, hostSetupNetworksValidatorHelper).validate();
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    vr = skipValidation(vr) ? vr : validateQos(attachmentsToConfigure);
    return vr;
}
#method_after
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : new NicLabelValidator(params, existingInterfacesMap, bondsMap, hostSetupNetworksValidatorHelper).validate();
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    vr = skipValidation(vr) ? vr : validateQos(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateBondModeVsNetworksAttachedToIt(attachmentsToConfigure);
    return vr;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
ValidationResult validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
        removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
    }
    final List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    if (vmNames.isEmpty()) {
        return ValidationResult.VALID;
    } else {
        final List<String> sortedRemovedNetsworks = new ArrayList<>(removedNetworks);
        Collections.sort(sortedRemovedNetsworks);
        EngineMessage engineMessage = EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS;
        return new ValidationResult(engineMessage, LinqUtils.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAMES, sortedRemovedNetsworks), ReplacementUtils.getListVariableAssignmentString(engineMessage, vmNames)));
    }
}
#method_after
@SuppressWarnings("unchecked")
ValidationResult validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
        removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
    }
    final List<String> vmsNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    final List<String> removedNetworksList = new ArrayList<>(removedNetworks);
    DetachNetworkUsedByVmValidator detachNetworkUsedByVmValidator = new DetachNetworkUsedByVmValidator(vmsNames, removedNetworksList);
    return detachNetworkUsedByVmValidator.validate();
}
#end_block

#method_before
ValidationResult validRemovedBonds(Collection<NetworkAttachment> attachmentsToConfigure) {
    List<Guid> invalidBondIds = Entities.idsNotReferencingExistingRecords(params.getRemovedBonds(), existingInterfacesMap.unmodifiableEntitiesByIdMap());
    if (!invalidBondIds.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.NETWORK_BOND_RECORDS_DOES_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, invalidBondIds));
    }
    Map<String, List<Guid>> nicNameToAttachedNetworkAttachmentIds = getIdsOfNetworkAttachmentsRelatedToInterfaceNames(attachmentsToConfigure);
    for (VdsNetworkInterface removedBond : removedBondVdsNetworkInterface) {
        String bondName = removedBond.getName();
        VdsNetworkInterface existingBond = existingInterfacesMap.get(bondName);
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingBond).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        boolean cantRemoveRequiredInterface = nicNameToAttachedNetworkAttachmentIds.containsKey(bondName);
        if (cantRemoveRequiredInterface) {
            List<Guid> networkAttachmentsForNic = nicNameToAttachedNetworkAttachmentIds.get(bondName);
            // TODO MM: simplify.
            EngineMessage engineMessage = EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS;
            List<String> replacements = new ArrayList<>();
            replacements.add(ReplacementUtils.getVariableAssignmentString(engineMessage, bondName));
            replacements.addAll(ReplacementUtils.replaceWith(VAR_ATTACHMENT_IDS, networkAttachmentsForNic));
            return new ValidationResult(engineMessage, replacements);
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validRemovedBonds(Collection<NetworkAttachment> attachmentsToConfigure) {
    List<Guid> invalidBondIds = Entities.idsNotReferencingExistingRecords(params.getRemovedBonds(), existingInterfacesMap.unmodifiableEntitiesByIdMap());
    if (!invalidBondIds.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.NETWORK_BOND_RECORDS_DOES_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, invalidBondIds));
    }
    Map<String, List<Guid>> nicNameToAttachedNetworkAttachmentIds = getIdsOfNetworkAttachmentsRelatedToInterfaceNames(attachmentsToConfigure);
    for (VdsNetworkInterface removedBond : removedBondVdsNetworkInterface) {
        String bondName = removedBond.getName();
        VdsNetworkInterface existingBond = existingInterfacesMap.get(bondName);
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingBond).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        boolean cantRemoveRequiredInterface = nicNameToAttachedNetworkAttachmentIds.containsKey(bondName);
        if (cantRemoveRequiredInterface) {
            List<Guid> networkAttachmentsForNic = nicNameToAttachedNetworkAttachmentIds.get(bondName);
            EngineMessage engineMessage = EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS;
            List<String> replacements = new ArrayList<>();
            replacements.add(ReplacementUtils.getVariableAssignmentString(engineMessage, bondName));
            replacements.addAll(ReplacementUtils.replaceWith(VAR_ATTACHMENT_IDS, networkAttachmentsForNic));
            return new ValidationResult(engineMessage, replacements);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private Map<String, List<Guid>> getIdsOfNetworkAttachmentsRelatedToInterfaceNames(Collection<NetworkAttachment> networkAttachments) {
    Map<String, List<Guid>> map = new HashMap<>();
    for (NetworkAttachment attachment : networkAttachments) {
        MultiValueMapUtils.addToMap(attachment.getNicName(), attachment.getId(), map, new ListCreator<Guid>());
    }
    return map;
}
#method_after
private Map<String, List<Guid>> getIdsOfNetworkAttachmentsRelatedToInterfaceNames(Collection<NetworkAttachment> networkAttachments) {
    Map<String, List<Guid>> map = new HashMap<>();
    for (NetworkAttachment attachment : networkAttachments) {
        MultiValueMapUtils.addToMap(attachment.getNicName(), attachment.getId(), map, new ListCreator<>());
    }
    return map;
}
#end_block

#method_before
ValidationResult validNewOrModifiedBonds() {
    for (Bond modifiedOrNewBond : params.getBonds()) {
        String bondName = modifiedOrNewBond.getName();
        ValidationResult validateCoherentNicIdentification = validateCoherentNicIdentification(modifiedOrNewBond);
        if (!validateCoherentNicIdentification.isValid()) {
            return validateCoherentNicIdentification;
        }
        // does not test, whether interface exists, but only if the instance is non-null and its name is set.
        HostInterfaceValidator nameIsSetValidator = createHostInterfaceValidator(modifiedOrNewBond);
        ValidationResult interfaceDoesNotHaveNameSet = nameIsSetValidator.interfaceHasNameSet();
        if (!interfaceDoesNotHaveNameSet.isValid()) {
            return interfaceDoesNotHaveNameSet;
        }
        boolean validBondName = bondName != null && bondName.matches(BusinessEntitiesDefinitions.BOND_NAME_PATTERN);
        if (!validBondName) {
            EngineMessage engineMessage = EngineMessage.NETWORK_BOND_NAME_BAD_FORMAT;
            return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, bondName));
        }
        // either it's newly create bond, thus non existing, or given name must reference existing bond.
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingInterfacesMap.get(bondName)).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        // count of bond slaves must be at least two.
        if (modifiedOrNewBond.getSlaves().size() < 2) {
            return new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bondName));
        }
        ValidationResult validateModifiedBondSlaves = validateModifiedBondSlaves(modifiedOrNewBond);
        if (!validateModifiedBondSlaves.isValid()) {
            return validateModifiedBondSlaves;
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validNewOrModifiedBonds() {
    for (Bond modifiedOrNewBond : params.getBonds()) {
        String bondName = modifiedOrNewBond.getName();
        Guid bondId = modifiedOrNewBond.getId();
        /*
             * bondId is provided, but bondName not. This means that user attempted update, but bond of such ID does not
             * exit, thus completors did not complete name.
             */
        if (bondId != null && bondName == null) {
            return new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_HAVING_ID_DOES_NOT_EXIST, ReplacementUtils.createSetVariableString(VAR_NIC_ID, bondId));
        }
        /*
             * user did not provide neither bondId nor bondName. That means he probably attempted new bond creation
             * but forgot to provide bondName.
             */
        if (bondId == null && bondName == null) {
            return new ValidationResult(EngineMessage.BOND_DOES_NOT_HAVE_NEITHER_ID_NOR_NAME_SPECIFIED);
        }
        /*
             * if (bondId == null && bondName != null) …
             * User provided only bondName, and completors failed to find existing bonds id for that name.
             * We cannot tell, what user wanted to do(create/update). We have to assume, it's new record creation, which
             * is valid scenario.
             */
        ValidationResult validateCoherentNicIdentification = validateCoherentNicIdentification(modifiedOrNewBond);
        if (!validateCoherentNicIdentification.isValid()) {
            return validateCoherentNicIdentification;
        }
        boolean validBondName = bondName.matches(BusinessEntitiesDefinitions.BOND_NAME_PATTERN);
        if (!validBondName) {
            EngineMessage engineMessage = EngineMessage.NETWORK_BOND_NAME_BAD_FORMAT;
            return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, bondName));
        }
        // either it's newly create bond, thus non existing, or given name must reference existing bond.
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingInterfacesMap.get(bondName)).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        // count of bond slaves must be at least two.
        if (modifiedOrNewBond.getSlaves().size() < 2) {
            return new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bondName));
        }
        ValidationResult validateModifiedBondSlaves = validateModifiedBondSlaves(modifiedOrNewBond);
        if (!validateModifiedBondSlaves.isValid()) {
            return validateModifiedBondSlaves;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult validateModifiedBondSlaves(Bond modifiedOrNewBond) {
    for (String slaveName : modifiedOrNewBond.getSlaves()) {
        VdsNetworkInterface potentialSlave = existingInterfacesMap.get(slaveName);
        HostInterfaceValidator slaveHostInterfaceValidator = createHostInterfaceValidator(potentialSlave);
        ValidationResult interfaceExists = slaveHostInterfaceValidator.interfaceExists(slaveName);
        if (!interfaceExists.isValid()) {
            return interfaceExists;
        }
        ValidationResult interfaceIsValidSlave = slaveHostInterfaceValidator.interfaceIsValidSlave();
        if (!interfaceIsValidSlave.isValid()) {
            return interfaceIsValidSlave;
        }
        /* definition of currently processed bond references this slave, but this slave already 'slaves' for
                another bond. This is ok only when this bond will be removed as a part of this request
                or the slave will be removed from its former bond, as a part of this request. */
        String currentSlavesBondName = potentialSlave.getBondName();
        if (potentialSlave.isPartOfBond() && /* we're creating new bond, and it's definition contains reference to slave already assigned
                        to a different bond. */
        (!potentialSlave.isPartOfBond(modifiedOrNewBond.getName()) && // …but this bond is also removed in this request, so it's ok.
        !isBondRemoved(currentSlavesBondName) && // … or slave was removed from its former bond
        !bondIsUpdatedAndDoesNotContainCertainSlave(slaveName, currentSlavesBondName))) {
            EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ALREADY_IN_BOND;
            return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName));
        }
        ValidationResult slaveHasAttachedNetworksValidationResult = validateSlaveHasNoNetworks(potentialSlave.getName());
        if (!slaveHasAttachedNetworksValidationResult.isValid()) {
            return slaveHasAttachedNetworksValidationResult;
        }
        if (slaveUsedMultipleTimesInDifferentBonds(slaveName)) {
            return new ValidationResult(EngineMessage.NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES, ReplacementUtils.createSetVariableString("NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES_ENTITY", slaveName));
        }
        ValidationResult slaveHasNoLabelsValidationResult = validateSlaveHasNoLabels(slaveName);
        if (!slaveHasNoLabelsValidationResult.isValid()) {
            return slaveHasNoLabelsValidationResult;
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validateModifiedBondSlaves(Bond modifiedOrNewBond) {
    for (String slaveName : modifiedOrNewBond.getSlaves()) {
        VdsNetworkInterface potentialSlave = existingInterfacesMap.get(slaveName);
        HostInterfaceValidator slaveHostInterfaceValidator = createHostInterfaceValidator(potentialSlave);
        ValidationResult interfaceExists = slaveHostInterfaceValidator.interfaceExists(slaveName);
        if (!interfaceExists.isValid()) {
            return interfaceExists;
        }
        ValidationResult interfaceIsValidSlave = slaveHostInterfaceValidator.interfaceIsValidSlave();
        if (!interfaceIsValidSlave.isValid()) {
            return interfaceIsValidSlave;
        }
        /*
             * definition of currently processed bond references this slave, but this slave already 'slaves' for
             * another bond. This is ok only when this bond will be removed as a part of this request
             * or the slave will be removed from its former bond, as a part of this request.
             */
        String currentSlavesBondName = potentialSlave.getBondName();
        if (potentialSlave.isPartOfBond() && /*
                         * we're creating new bond, and it's definition contains reference to slave already assigned
                         * to a different bond.
                         */
        (!potentialSlave.isPartOfBond(modifiedOrNewBond.getName()) && // … but this bond is also removed in this request, so it's ok.
        !isBondRemoved(currentSlavesBondName) && // … or slave was removed from its former bond
        !bondIsUpdatedAndDoesNotContainCertainSlave(slaveName, currentSlavesBondName))) {
            EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ALREADY_IN_BOND;
            return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName));
        }
        ValidationResult slaveHasAttachedNetworksValidationResult = validateSlaveHasNoNetworks(potentialSlave.getName());
        if (!slaveHasAttachedNetworksValidationResult.isValid()) {
            return slaveHasAttachedNetworksValidationResult;
        }
        if (slaveUsedMultipleTimesInDifferentBonds(slaveName)) {
            return new ValidationResult(EngineMessage.NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES, ReplacementUtils.createSetVariableString("NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES_ENTITY", slaveName));
        }
        ValidationResult slaveHasNoLabelsValidationResult = validateSlaveHasNoLabels(slaveName);
        if (!slaveHasNoLabelsValidationResult.isValid()) {
            return slaveHasNoLabelsValidationResult;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : referencedNetworkAttachmentActuallyExists(attachment.getId());
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : validateCoherentNetworkIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : modifiedAttachmentNotRemoved(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentNotReferenceVlanDevice(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentAndNicReferenceSameLabelNotConflict(attachment);
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.ipConfiguredForStaticBootProtocol();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForDisplayNetwork();
        vr = skipValidation(vr) ? vr : validator.nicNameIsSet();
        vr = skipValidation(vr) ? vr : nicActuallyExistsOrReferencesNewBond(attachment);
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfacesMap);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(attachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : validator.validateGateway();
        boolean attachmentUpdated = !isNewAttachment(attachment.getId());
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : validator.networkNotUsedByVms();
            vr = skipValidation(vr) ? vr : notMovingLabeledNetworkToDifferentNic(attachment);
        }
    }
    return vr;
}
#method_after
ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : referencedNetworkAttachmentActuallyExists(attachment.getId());
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : validateCoherentNetworkIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : modifiedAttachmentNotRemoved(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentNotReferenceVlanDevice(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentAndNicReferenceSameLabelNotConflict(attachment);
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForRoleNetwork();
        vr = skipValidation(vr) ? vr : validator.nicNameIsSet();
        vr = skipValidation(vr) ? vr : nicActuallyExistsOrReferencesNewBond(attachment);
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfacesMap);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(attachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : validator.validateGateway();
        vr = skipValidation(vr) ? vr : networkAttachmentIpConfigurationValidator.validateNetworkAttachmentIpConfiguration(params.getNetworkAttachments());
        boolean attachmentUpdated = !isNewAttachment(attachment.getId());
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : validator.networkNotUsedByVms();
            vr = skipValidation(vr) ? vr : notMovingLabeledNetworkToDifferentNic(attachment);
        }
    }
    return vr;
}
#end_block

#method_before
private ValidationResult referencedNetworkAttachmentActuallyExists(Guid networkAttachmentId) {
    boolean doesNotReferenceExistingNetworkAttachment = networkAttachmentId == null;
    if (doesNotReferenceExistingNetworkAttachment) {
        return ValidationResult.VALID;
    }
    for (NetworkAttachment existingAttachment : existingAttachments) {
        if (existingAttachment.getId().equals(networkAttachmentId)) {
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS);
}
#method_after
private ValidationResult referencedNetworkAttachmentActuallyExists(Guid networkAttachmentId) {
    boolean doesNotReferenceExistingNetworkAttachment = networkAttachmentId == null;
    if (doesNotReferenceExistingNetworkAttachment) {
        return ValidationResult.VALID;
    }
    for (NetworkAttachment existingAttachment : existingAttachments) {
        if (existingAttachment.getId().equals(networkAttachmentId)) {
            return ValidationResult.VALID;
        }
    }
    EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS;
    String id = networkAttachmentId.toString();
    String replacement = ReplacementUtils.getVariableAssignmentString(engineMessage, id);
    return new ValidationResult(engineMessage, replacement);
}
#end_block

#method_before
private ValidationResult nicActuallyExistsOrReferencesNewBond(NetworkAttachment attachment) {
    String nicName = attachment.getNicName();
    Guid nicId = attachment.getNicId();
    boolean nicActuallyExistsOrReferencesNewBond = isNicActuallyExistsOrReferencesNewBond(nicName, nicId);
    return ValidationResult.failWith(EngineMessage.HOST_NETWORK_INTERFACE_HAVING_ID_AND_NAME_DOES_NOT_EXIST, ReplacementUtils.createSetVariableString(VAR_NIC_ID, nicId), ReplacementUtils.createSetVariableString(VAR_NIC_NAME, nicName)).when(!nicActuallyExistsOrReferencesNewBond);
}
#method_after
private ValidationResult nicActuallyExistsOrReferencesNewBond(NetworkAttachment attachment) {
    String nicName = attachment.getNicName();
    Guid nicId = attachment.getNicId();
    boolean nicActuallyExistsOrReferencesNewBond = isNicActuallyExistsOrReferencesNewBond(nicName, nicId);
    return ValidationResult.failWith(EngineMessage.HOST_NETWORK_INTERFACE_HAVING_ID_OR_NAME_DOES_NOT_EXIST, ReplacementUtils.createSetVariableString(VAR_NIC_ID, nicId), ReplacementUtils.createSetVariableString(VAR_NIC_NAME, nicName)).when(!nicActuallyExistsOrReferencesNewBond);
}
#end_block

#method_before
private ValidationResult validRemovedNetworkAttachments() {
    List<Guid> invalidIds = Entities.idsNotReferencingExistingRecords(params.getRemovedNetworkAttachments(), existingAttachments);
    if (!invalidIds.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENTS_NOT_EXISTS;
        return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS, ReplacementUtils.getListVariableAssignmentString(engineMessage, invalidIds));
    }
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = removedNetworkAttachments.iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachmentToValidate);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.notRemovingManagementNetwork();
        vr = skipValidation(vr) ? vr : notRemovingLabeledNetworks(attachment);
        vr = skipValidation(vr) ? vr : validateNotRemovingUsedNetworkByVms();
    }
    return vr;
}
#method_after
private ValidationResult validRemovedNetworkAttachments() {
    List<Guid> invalidIds = Entities.idsNotReferencingExistingRecords(params.getRemovedNetworkAttachments(), existingAttachments);
    if (!invalidIds.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENTS_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, invalidIds));
    }
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = removedNetworkAttachments.iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachmentToValidate);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.notRemovingManagementNetwork();
        vr = skipValidation(vr) ? vr : notRemovingLabeledNetworks(attachment);
        vr = skipValidation(vr) ? vr : validateNotRemovingUsedNetworkByVms();
    }
    return vr;
}
#end_block

#method_before
private ValidationResult validateCustomProperties() {
    String version = host.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validPropertiesForVmNetwork = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validPropertiesForVmNetwork.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesForNonVm = new HashMap<>(validPropertiesForVmNetwork);
    validPropertiesForNonVm.remove("bridge_opts");
    return validateCustomProperties(util, validPropertiesForVmNetwork, validPropertiesForNonVm);
}
#method_after
private ValidationResult validateCustomProperties() {
    String version = host.getClusterCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validPropertiesForVmNetwork = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validPropertiesForVmNetwork.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesForNonVm = new HashMap<>(validPropertiesForVmNetwork);
    validPropertiesForNonVm.remove("bridge_opts");
    return validateCustomProperties(util, validPropertiesForVmNetwork, validPropertiesForNonVm);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getNetworkDao().update(getNetwork());
            for (NetworkCluster clusterAttachment : getNetworkClusterDao().getAllForNetwork(getNetwork().getId())) {
                NetworkClusterHelper.setStatus(clusterAttachment.getClusterId(), getNetwork());
            }
            if (networkChangedToNonVmNetwork()) {
                removeVnicProfiles();
            }
            return null;
        }
    });
    if (!getNetwork().isExternal()) {
        if (NetworkHelper.setupNetworkSupported(getStoragePool().getCompatibilityVersion())) {
            applyNetworkChangesToHosts();
        } else if (!onlyPermittedFieldsChanged() || !allowedNetworkLabelManipulation()) {
            List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getVdsInterfacesByNetworkId(getNetwork().getId());
            if (!nics.isEmpty()) {
                auditLogDirector.log(this, AuditLogType.MULTI_UPDATE_NETWORK_NOT_POSSIBLE);
            }
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(() -> {
        getNetworkDao().update(getNetwork());
        for (NetworkCluster clusterAttachment : getNetworkClusterDao().getAllForNetwork(getNetwork().getId())) {
            NetworkClusterHelper.setStatus(clusterAttachment.getClusterId(), getNetwork());
        }
        if (networkChangedToNonVmNetwork()) {
            removeVnicProfiles();
        }
        return null;
    });
    if (!getNetwork().isExternal()) {
        if (NetworkHelper.setupNetworkSupported(getStoragePool().getCompatibilityVersion())) {
            applyNetworkChangesToHosts();
        } else if (!onlyPermittedFieldsChanged() || !allowedNetworkLabelManipulation()) {
            List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getVdsInterfacesByNetworkId(getNetwork().getId());
            if (!nics.isEmpty()) {
                auditLogDirector.log(this, AuditLogType.MULTI_UPDATE_NETWORK_NOT_POSSIBLE);
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
private void applyNetworkChangesToHosts() {
    SyncNetworkParametersBuilder builder = new SyncNetworkParametersBuilder(getContext());
    ArrayList<VdcActionParametersBase> parameters = builder.buildParameters(getNetwork(), getOldNetwork());
    if (!parameters.isEmpty()) {
        NetworkParametersBuilder.updateParametersSequencing(parameters);
        runInternalMultipleActions(VdcActionType.PersistentSetupNetworks, parameters);
    }
}
#method_after
private void applyNetworkChangesToHosts() {
    ArrayList<VdcActionParametersBase> parameters = syncNetworkParametersBuilder.buildParameters(getNetwork(), getOldNetwork());
    if (!parameters.isEmpty()) {
        HostSetupNetworksParametersBuilder.updateParametersSequencing(parameters);
        runInternalMultipleActions(VdcActionType.PersistentHostSetupNetworks, parameters);
    }
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    super.setActionMessageParameters();
    addCanDoActionMessage(EngineMessage.VAR__ACTION__UPDATE);
}
#method_after
@Override
protected void setActionMessageParameters() {
    super.setActionMessageParameters();
    addValidationMessage(EngineMessage.VAR__ACTION__UPDATE);
}
#end_block

#method_before
private boolean allowedNetworkLabelManipulation() {
    boolean labelNotChanged = !labelChanged();
    return !getNetwork().isExternal() && (labelNotChanged || labelAdded());
}
#method_after
private boolean allowedNetworkLabelManipulation() {
    boolean labelNotChanged = !labelChanged(getNetwork(), getOldNetwork());
    return !getNetwork().isExternal() && (labelNotChanged || labelAdded(getNetwork(), getOldNetwork()));
}
#end_block

#method_before
public ValidationResult networkNotUsedByRunningVms() {
    List<VM> runningVms = new ArrayList<>();
    List<VmNetworkInterface> vnics = vmNetworkInterfaceDao.getAllForNetwork(network.getId());
    Map<Guid, List<VmNetworkInterface>> vnicsByVmId = Entities.vmInterfacesByVmId(vnics);
    for (VM vm : getVms()) {
        if (vm.isRunningOrPaused()) {
            for (VmNetworkInterface nic : vnicsByVmId.get(vm.getId())) {
                if (VmNetworkCanBeUpdatedPredicate.getInstance().eval(nic)) {
                    runningVms.add(vm);
                    break;
                }
            }
        }
    }
    final List<VM> runningVmNotSupportNetworkChange = LinqUtils.filter(runningVms, new Predicate<VM>() {

        final Map<Guid, Version> clusterVersions = new HashMap<>();

        @Override
        public boolean eval(VM vm) {
            final Guid clusterId = vm.getVdsGroupId();
            Version clusterVersion = clusterVersions.get(clusterId);
            if (clusterVersion == null) {
                final VDSGroup cluster = vdsGroupDao.get(clusterId);
                clusterVersion = cluster.getCompatibilityVersion();
                clusterVersions.put(clusterId, clusterVersion);
            }
            return !FeatureSupported.changeNetworkUsedByVmSupported(clusterVersion);
        }
    });
    return new PluralMessages(EngineMessage.VAR__ENTITIES__VM, EngineMessage.VAR__ENTITIES__VMS).getNetworkInUse(getEntitiesNames(runningVmNotSupportNetworkChange));
}
#method_after
public ValidationResult networkNotUsedByRunningVms() {
    List<VM> runningVms = new ArrayList<>();
    List<VmNetworkInterface> vnics = vmNetworkInterfaceDao.getAllForNetwork(network.getId());
    Map<Guid, List<VmNetworkInterface>> vnicsByVmId = NetworkUtils.vmInterfacesByVmId(vnics);
    for (VM vm : getVms()) {
        if (vm.isRunningOrPaused()) {
            for (VmNetworkInterface nic : vnicsByVmId.get(vm.getId())) {
                if (VmNetworkCanBeUpdatedPredicate.getInstance().test(nic)) {
                    runningVms.add(vm);
                    break;
                }
            }
        }
    }
    final List<VM> runningVmNotSupportNetworkChange = runningVms.stream().filter(new Predicate<VM>() {

        final Map<Guid, Version> clusterVersions = new HashMap<>();

        @Override
        public boolean test(VM vm) {
            final Guid clusterId = vm.getClusterId();
            Version clusterVersion = clusterVersions.get(clusterId);
            if (clusterVersion == null) {
                final Cluster cluster = clusterDao.get(clusterId);
                clusterVersion = cluster.getCompatibilityVersion();
                clusterVersions.put(clusterId, clusterVersion);
            }
            return !FeatureSupported.changeNetworkUsedByVmSupported(clusterVersion);
        }
    }).collect(Collectors.toList());
    return networkNotUsed(runningVmNotSupportNetworkChange, EngineMessage.VAR__ENTITIES__VMS, EngineMessage.VAR__ENTITIES__VM);
}
#end_block

#method_before
public ValidationResult externalNetworkDetailsUnchanged(Network newNetwork) {
    return ObjectUtils.equals(network.getVlanId(), newNetwork.getVlanId()) && network.getMtu() == newNetwork.getMtu() && network.getStp() == newNetwork.getStp() && network.isVmNetwork() == newNetwork.isVmNetwork() && ObjectUtils.equals(network.getProvidedBy(), newNetwork.getProvidedBy()) ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_EXTERNAL_NETWORK_DETAILS_CANNOT_BE_EDITED);
}
#method_after
public ValidationResult externalNetworkDetailsUnchanged(Network newNetwork) {
    return Objects.equals(network.getVlanId(), newNetwork.getVlanId()) && network.getMtu() == newNetwork.getMtu() && network.getStp() == newNetwork.getStp() && network.isVmNetwork() == newNetwork.isVmNetwork() && Objects.equals(network.getProvidedBy(), newNetwork.getProvidedBy()) ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_EXTERNAL_NETWORK_DETAILS_CANNOT_BE_EDITED);
}
#end_block

#method_before
private ArrayList<VdcActionParametersBase> buildParameters(Network network, Network oldNetwork) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getVdsInterfacesByNetworkId(network.getId());
    // sync network on nics if the label wasn't changed
    if (!labelChanged()) {
        createSyncNetworkParameters(parameters, nics);
        return parameters;
    }
    // add network to labeled interfaces and sync network on the rest
    if (labelAdded() || labelRenamed()) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(network);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForAdd = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to add network
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // add network to labeled nic if network not configured on host
            if (nic == null) {
                nicsForAdd.add(labeledNic);
            } else {
                // sync the network
                nicsForSync.add(nic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createAddNetworkParameters(nicsForAdd));
        createSyncNetworkParameters(parameters, nicsForSync);
        return parameters;
    }
    // remove network from labeled interfaces
    if (labelRemoved()) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(oldNetwork);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForRemove = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to remove the network from
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // remove the network from labeled nic
            if (nic != null) {
                nicsForRemove.add(labeledNic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createRemoveNetworkParameters(nicsForRemove));
        createSyncNetworkParameters(parameters, nicsForSync);
        return parameters;
    }
    return parameters;
}
#method_after
private ArrayList<VdcActionParametersBase> buildParameters(Network network, Network oldNetwork) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    List<VdsNetworkInterface> nics = interfaceDao.getVdsInterfacesByNetworkId(network.getId());
    // sync network on nics if the label wasn't changed
    if (!labelChanged(network, oldNetwork)) {
        createSyncNetworkParameters(network, parameters, nics);
        return parameters;
    }
    // add network to labeled interfaces and sync network on the rest
    if (labelAdded(network, oldNetwork) || labelRenamed(network, oldNetwork)) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(network);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForAdd = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to add network
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // add network to labeled nic if network not configured on host
            if (nic == null) {
                nicsForAdd.add(labeledNic);
            } else {
                // sync the network
                nicsForSync.add(nic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createAddNetworkParameters(network, nicsForAdd));
        createSyncNetworkParameters(network, parameters, nicsForSync);
        return parameters;
    }
    // remove network from labeled interfaces
    if (labelRemoved(network, oldNetwork)) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(oldNetwork);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForRemove = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to remove the network from
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // remove the network from labeled nic
            if (nic != null) {
                nicsForRemove.add(labeledNic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createRemoveNetworkParameters(network, nicsForRemove));
        createSyncNetworkParameters(network, parameters, nicsForSync);
        return parameters;
    }
    return parameters;
}
#end_block

#method_before
private ArrayList<VdcActionParametersBase> createAddNetworkParameters(List<VdsNetworkInterface> nicsForAdd) {
    AddNetworkParametersBuilder builder = new AddNetworkParametersBuilder(getNetwork(), getContext());
    return builder.buildParameters(nicsForAdd);
}
#method_after
private ArrayList<VdcActionParametersBase> createAddNetworkParameters(Network network, List<VdsNetworkInterface> nicsForAdd) {
    return addNetworkParametersBuilder.buildParameters(network, nicsForAdd);
}
#end_block

#method_before
private ArrayList<VdcActionParametersBase> createRemoveNetworkParameters(List<VdsNetworkInterface> nicsForRemove) {
    RemoveNetworkParametersBuilder builder = new RemoveNetworkParametersBuilder(getOldNetwork(), getContext(), managementNetworkUtil);
    return builder.buildParameters(nicsForRemove);
}
#method_after
private ArrayList<VdcActionParametersBase> createRemoveNetworkParameters(Network oldNetwork, List<VdsNetworkInterface> nicsForRemove) {
    return removeNetworkParametersBuilder.buildParameters(oldNetwork, nicsForRemove);
}
#end_block

#method_before
private List<VdsNetworkInterface> getLabeledNics(Network network) {
    List<NetworkCluster> clusters = getNetworkClusterDao().getAllForNetwork(network.getId());
    List<VdsNetworkInterface> labeledNics = new ArrayList<>();
    for (NetworkCluster networkCluster : clusters) {
        labeledNics.addAll(getDbFacade().getInterfaceDao().getAllInterfacesByLabelForCluster(networkCluster.getClusterId(), network.getLabel()));
    }
    return labeledNics;
}
#method_after
private List<VdsNetworkInterface> getLabeledNics(Network network) {
    List<NetworkCluster> clusters = networkClusterDao.getAllForNetwork(network.getId());
    List<VdsNetworkInterface> labeledNics = new ArrayList<>();
    for (NetworkCluster networkCluster : clusters) {
        labeledNics.addAll(interfaceDao.getAllInterfacesByLabelForCluster(networkCluster.getClusterId(), network.getLabel()));
    }
    return labeledNics;
}
#end_block

#method_before
private void createSyncNetworkParameters(ArrayList<VdcActionParametersBase> parameters, Collection<VdsNetworkInterface> nics) {
    Set<Guid> hostIdsToSync = new HashSet<>();
    for (VdsNetworkInterface nic : nics) {
        NetworkImplementationDetails networkImplementationDetails = networkImplementationDetailsUtils.calculateNetworkImplementationDetails(nic, getNetwork());
        boolean networkShouldBeSynced = networkImplementationDetails != null && !networkImplementationDetails.isInSync();
        if (networkShouldBeSynced) {
            hostIdsToSync.add(nic.getVdsId());
        }
    }
    for (Guid hostId : hostIdsToSync) {
        PersistentSetupNetworksParameters setupNetworkParams = createSetupNetworksParameters(hostId);
        setupNetworkParams.setNetworkNames(getNetworkName());
        setupNetworkParams.setNetworksToSync(Collections.singletonList(getNetworkName()));
        parameters.add(setupNetworkParams);
    }
}
#method_after
private void createSyncNetworkParameters(Network network, ArrayList<VdcActionParametersBase> parameters, Collection<VdsNetworkInterface> nics) {
    Set<Guid> hostIdsToSync = new HashSet<>();
    for (VdsNetworkInterface nic : nics) {
        NetworkImplementationDetails networkImplementationDetails = networkImplementationDetailsUtils.calculateNetworkImplementationDetails(nic, network);
        boolean networkShouldBeSynced = networkImplementationDetails != null && !networkImplementationDetails.isInSync();
        if (networkShouldBeSynced) {
            hostIdsToSync.add(nic.getVdsId());
        }
    }
    for (Guid hostId : hostIdsToSync) {
        PersistentHostSetupNetworksParameters setupNetworkParams = createHostSetupNetworksParameters(hostId);
        setupNetworkParams.setNetworkNames(network.getName());
        NetworkAttachment attachment = getNetworkIdToAttachmentMap(hostId).get(network.getId());
        attachment.setOverrideConfiguration(true);
        setupNetworkParams.getNetworkAttachments().add(attachment);
        parameters.add(setupNetworkParams);
    }
}
#end_block

#method_before
private boolean labelChanged() {
    return !Objects.equals(getNetwork().getLabel(), getOldNetwork().getLabel());
}
#method_after
private static boolean labelChanged(Network network, Network oldNetwork) {
    return !Objects.equals(network.getLabel(), oldNetwork.getLabel());
}
#end_block

#method_before
private boolean labelAdded() {
    return !NetworkUtils.isLabeled(getOldNetwork()) && NetworkUtils.isLabeled(getNetwork());
}
#method_after
private static boolean labelAdded(Network network, Network oldNetwork) {
    return !NetworkUtils.isLabeled(oldNetwork) && NetworkUtils.isLabeled(network);
}
#end_block

#method_before
private boolean labelRemoved() {
    return NetworkUtils.isLabeled(getOldNetwork()) && !NetworkUtils.isLabeled(getNetwork());
}
#method_after
private static boolean labelRemoved(Network network, Network oldNetwork) {
    return NetworkUtils.isLabeled(oldNetwork) && !NetworkUtils.isLabeled(network);
}
#end_block

#method_before
private boolean labelRenamed() {
    return NetworkUtils.isLabeled(getOldNetwork()) && NetworkUtils.isLabeled(getNetwork()) && labelChanged();
}
#method_after
private static boolean labelRenamed(Network network, Network oldNetwork) {
    return NetworkUtils.isLabeled(oldNetwork) && NetworkUtils.isLabeled(network) && labelChanged(network, oldNetwork);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setStoragePoolId(getNetwork().getDataCenterId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            removeVnicProfiles();
            removeFromClusters();
            getCompensationContext().snapshotEntity(getNetwork());
            getNetworkDao().remove(getNetwork().getId());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getNetwork().isExternal()) {
        if (getParameters().isRemoveFromNetworkProvider()) {
            removeExternalNetwork();
        }
    }
    if (NetworkHelper.shouldRemoveNetworkFromHostUponNetworkRemoval(getNetwork(), getStoragePool().getCompatibilityVersion())) {
        removeNetworkFromHosts();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    setStoragePoolId(getNetwork().getDataCenterId());
    TransactionSupport.executeInNewTransaction(() -> {
        removeVnicProfiles();
        removeFromClusters();
        getCompensationContext().snapshotEntity(getNetwork());
        getNetworkDao().remove(getNetwork().getId());
        getCompensationContext().stateChanged();
        return null;
    });
    if (getNetwork().isExternal()) {
        if (getParameters().isRemoveFromNetworkProvider()) {
            removeExternalNetwork();
        }
    }
    if (NetworkHelper.shouldRemoveNetworkFromHostUponNetworkRemoval(getNetwork(), getStoragePool().getCompatibilityVersion())) {
        removeNetworkFromHosts();
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    super.setActionMessageParameters();
    addCanDoActionMessage(EngineMessage.VAR__ACTION__REMOVE);
}
#method_after
@Override
protected void setActionMessageParameters() {
    super.setActionMessageParameters();
    addValidationMessage(EngineMessage.VAR__ACTION__REMOVE);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    host = new VDS();
    host.setId(Guid.newGuid());
    host.setVdsGroupCompatibilityVersion(Version.v3_5);
    final VdsDynamic vdsDynamic = new VdsDynamic();
    vdsDynamic.setSupportedClusterLevels(TEST_VERSION);
    host.setDynamicData(vdsDynamic);
    bond = new Bond();
    bond.setId(Guid.newGuid());
    when(mockNetworkExclusivenessValidatorResolver.resolveNetworkExclusivenessValidator(TEST_SUPPORTED_VERSIONS)).thenReturn(mockNetworkExclusivenessValidator);
}
#method_after
@Before
public void setUp() throws Exception {
    host = new VDS();
    host.setId(Guid.newGuid());
    host.setClusterCompatibilityVersion(Version.v3_5);
    final VdsDynamic vdsDynamic = new VdsDynamic();
    vdsDynamic.setSupportedClusterLevels(TEST_VERSION);
    host.setDynamicData(vdsDynamic);
    bond = new Bond();
    bond.setId(Guid.newGuid());
    when(mockNetworkExclusivenessValidatorResolver.resolveNetworkExclusivenessValidator(TEST_SUPPORTED_VERSIONS)).thenReturn(mockNetworkExclusivenessValidator);
    when(mockNetworkAttachmentIpConfigurationValidator.validateNetworkAttachmentIpConfiguration(any())).thenReturn(ValidationResult.VALID);
}
#end_block

#method_before
private NetworkAttachment createNetworkAttachment(Network network, Guid id) {
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setId(id);
    networkAttachment.setNetworkId(network.getId());
    networkAttachment.setNetworkName(network.getName());
    return networkAttachment;
}
#method_after
private NetworkAttachment createNetworkAttachment(Network networkA, VdsNetworkInterface nic, Guid guid) {
    NetworkAttachment attachment = createNetworkAttachment(networkA, guid);
    if (nic != null) {
        attachment.setNicId(nic.getId());
        attachment.setNicName(nic.getName());
    }
    return attachment;
}
#end_block

#method_before
private NetworkAttachment createNetworkAttachment(Network networkA, VdsNetworkInterface nic) {
    NetworkAttachment attachment = createNetworkAttachment(networkA, Guid.newGuid());
    attachment.setNicId(nic.getId());
    attachment.setNicName(nic.getName());
    return attachment;
}
#method_after
private NetworkAttachment createNetworkAttachment(Network networkA, VdsNetworkInterface nic) {
    return createNetworkAttachment(networkA, nic, Guid.newGuid());
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    Bond bond = createBond();
    final EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_IS_NOT_BOND;
    ValidationResult notABondValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, bond.getName()));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, notABondValidationResult, notABondValidationResult, ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    Bond bond = createBond();
    final EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_IS_NOT_BOND;
    ValidationResult notABondValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, bond.getName()));
    doTestValidModifiedBonds(bond, notABondValidationResult, notABondValidationResult, ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bond.getName())), ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bond.getName())), ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
    ValidationResult slavesValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, "slaveA"), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, "networkName"));
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, /*this mocks validateModifiedBondSlaves to just verify, that caller method will behave ok, when
            validateModifiedBondSlaves return invalid result*/
    slavesValidationResult, slavesValidationResult);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
    ValidationResult slavesValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, "slaveA"), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, "networkName"));
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, /*this mocks validateModifiedBondSlaves to just verify, that caller method will behave ok, when
            validateModifiedBondSlaves return invalid result*/
    slavesValidationResult, slavesValidationResult);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsWhenAllOk() throws Exception {
    Bond bond = new Bond("bond1");
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsWhenAllOk() throws Exception {
    Bond bond = new Bond("bond1");
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#end_block

#method_before
private void doTestValidModifiedBonds(Bond bond, ValidationResult interfaceByNameExistValidationResult, ValidationResult interfaceIsBondValidationResult, ValidationResult expectedValidationResult, ValidationResult slavesValidationValidationResult) {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(bond)).addExistingInterfaces((List<VdsNetworkInterface>) null).addExistingAttachments((List<NetworkAttachment>) null).addNetworks((Collection<Network>) null).build());
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceHasNameSet()).thenReturn(interfaceByNameExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationValidationResult).when(validator).validateModifiedBondSlaves(any(Bond.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessage(), expectedValidationResult.getVariableReplacements()));
    }
    verify(hostInterfaceValidatorMock).interfaceHasNameSet();
    // assert only if previous call was successful, otherwise this method was not called.
    if (interfaceByNameExistValidationResult.isValid()) {
        verify(hostInterfaceValidatorMock).interfaceIsBondOrNull();
    }
}
#method_after
private void doTestValidModifiedBonds(Bond bond, ValidationResult interfaceIsBondValidationResult, ValidationResult expectedValidationResult, ValidationResult slavesValidationValidationResult) {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(bond)).addExistingInterfaces((List<VdsNetworkInterface>) null).addExistingAttachments((List<NetworkAttachment>) null).addNetworks((Collection<Network>) null).build());
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationValidationResult).when(validator).validateModifiedBondSlaves(any(Bond.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessage(), expectedValidationResult.getVariableReplacements()));
    }
}
#end_block

#method_before
@Test
public void testValidateCustomPropertiesWhenAttachmentDoesNotHaveCustomProperties() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setProperties(null);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setProperties(new HashMap<String, String>());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addNetworkAttachments(networkAttachmentA, networkAttachmentB)).addNetworks(Arrays.asList(networkA, networkB)).build();
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), isValid());
}
#method_after
@Test
public void testValidateCustomPropertiesWhenAttachmentDoesNotHaveCustomProperties() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setProperties(null);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setProperties(new HashMap<>());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addNetworkAttachments(networkAttachmentA, networkAttachmentB)).addNetworks(Arrays.asList(networkA, networkB)).build();
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), isValid());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertiesFeatureIsNotSupported() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    host.setVdsGroupCompatibilityVersion(Version.v3_4);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(params).addNetworks(networkA).build());
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED;
    assertThat(validator.validateCustomProperties(null, Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, networkA.getName())));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertiesFeatureIsNotSupported() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    host.setClusterCompatibilityVersion(Version.v3_4);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(params).addNetworks(networkA).build());
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED;
    assertThat(validator.validateCustomProperties(null, Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, networkA.getName())));
}
#end_block

#method_before
@Test
public void testAddNetworkToNicAlongWithAddingItIntoBond() {
    Network networkA = createNetworkWithName("networkA");
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA, (Guid) null);
    networkAttachment.setNicId(nicA.getId());
    networkAttachment.setNicName(nicA.getName());
    networkAttachment.setNetworkId(networkA.getId());
    networkAttachment.setNetworkName(networkA.getName());
    Bond bond = new Bond();
    bond.setName("bond1");
    setBondSlaves(bond, nicA, nicB);
    when(networkDaoMock.get(eq(networkA.getId()))).thenReturn(networkA);
    when(networkClusterDaoMock.get(new NetworkClusterId(host.getVdsGroupId(), networkA.getId()))).thenReturn(mock(NetworkCluster.class));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addNetworkAttachments(networkAttachment).addBonds(bond).build()).addExistingInterfaces(nicA, nicB).addNetworks(networkA).build();
    ValidationResult validate = validator.validate();
    assertThat(validate, not(isValid()));
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME;
    assertThat(validate, failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, nicA.getName()), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, networkA.getName())));
}
#method_after
@Test
public void testAddNetworkToNicAlongWithAddingItIntoBond() {
    Network networkA = createNetworkWithName("networkA");
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA, (Guid) null);
    networkAttachment.setNicId(nicA.getId());
    networkAttachment.setNicName(nicA.getName());
    networkAttachment.setNetworkId(networkA.getId());
    networkAttachment.setNetworkName(networkA.getName());
    Bond bond = new Bond();
    bond.setName("bond1");
    setBondSlaves(bond, nicA, nicB);
    addNetworkIdToNetworkDaoMock(networkA);
    addNetworkToClusterDaoMock(networkA.getId());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addNetworkAttachments(networkAttachment).addBonds(bond).build()).addExistingInterfaces(nicA, nicB).addNetworks(networkA).build();
    ValidationResult validate = validator.validate();
    assertThat(validate, not(isValid()));
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME;
    assertThat(validate, failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, nicA.getName()), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, networkA.getName())));
}
#end_block

#method_before
@Test
public void testValidateQosOverriddenInterfacesWhenAttachmentHasQosOverriddenAndRequiredValuesNotPresent() {
    EngineMessage hostNetworkQosValidatorFailure = EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_MISSING_VALUES;
    host.setVdsGroupCompatibilityVersion(Version.v3_6);
    Network network = createNetworkWithName("network");
    HostSetupNetworksValidator validator = createValidatorForTestingValidateQosOverridden(network);
    HostSetupNetworksValidator validatorSpy = spy(validator);
    HostNetworkQosValidator hostNetworkQosValidatorMock = mock(HostNetworkQosValidator.class);
    when(hostNetworkQosValidatorMock.requiredQosValuesPresentForOverriding(eq(network.getName()))).thenReturn(new ValidationResult(hostNetworkQosValidatorFailure));
    doReturn(hostNetworkQosValidatorMock).when(validatorSpy).createHostNetworkQosValidator(any(HostNetworkQos.class));
    assertThat(validatorSpy.validateQosOverriddenInterfaces(), ValidationResultMatchers.failsWith(hostNetworkQosValidatorFailure));
    verify(hostNetworkQosValidatorMock).requiredQosValuesPresentForOverriding(eq(network.getName()));
    verifyNoMoreInteractions(hostNetworkQosValidatorMock);
}
#method_after
@Test
public void testValidateQosOverriddenInterfacesWhenAttachmentHasQosOverriddenAndRequiredValuesNotPresent() {
    EngineMessage hostNetworkQosValidatorFailure = EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_MISSING_VALUES;
    host.setClusterCompatibilityVersion(Version.v3_6);
    Network network = createNetworkWithName("network");
    HostSetupNetworksValidator validator = createValidatorForTestingValidateQosOverridden(network);
    HostSetupNetworksValidator validatorSpy = spy(validator);
    HostNetworkQosValidator hostNetworkQosValidatorMock = mock(HostNetworkQosValidator.class);
    when(hostNetworkQosValidatorMock.requiredQosValuesPresentForOverriding(eq(network.getName()))).thenReturn(new ValidationResult(hostNetworkQosValidatorFailure));
    doReturn(hostNetworkQosValidatorMock).when(validatorSpy).createHostNetworkQosValidator(any(HostNetworkQos.class));
    assertThat(validatorSpy.validateQosOverriddenInterfaces(), ValidationResultMatchers.failsWith(hostNetworkQosValidatorFailure));
    verify(hostNetworkQosValidatorMock).requiredQosValuesPresentForOverriding(eq(network.getName()));
    verifyNoMoreInteractions(hostNetworkQosValidatorMock);
}
#end_block

#method_before
@Test
public void testValidateQosOverriddenInterfacesWhenAttachmentHasQosOverriddenAndRequiredValuesPresentButInconsistent() {
    EngineMessage hostNetworkQosValidatorFailure = EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_INCONSISTENT_VALUES;
    host.setVdsGroupCompatibilityVersion(Version.v3_6);
    Network network = createNetworkWithName("network");
    HostSetupNetworksValidator validator = createValidatorForTestingValidateQosOverridden(network);
    HostSetupNetworksValidator validatorSpy = spy(validator);
    HostNetworkQosValidator hostNetworkQosValidatorMock = mock(HostNetworkQosValidator.class);
    when(hostNetworkQosValidatorMock.requiredQosValuesPresentForOverriding(eq(network.getName()))).thenReturn(ValidationResult.VALID);
    when(hostNetworkQosValidatorMock.valuesConsistent(eq(network.getName()))).thenReturn(new ValidationResult(hostNetworkQosValidatorFailure));
    doReturn(hostNetworkQosValidatorMock).when(validatorSpy).createHostNetworkQosValidator(any(HostNetworkQos.class));
    assertThat(validatorSpy.validateQosOverriddenInterfaces(), ValidationResultMatchers.failsWith(hostNetworkQosValidatorFailure));
    verify(hostNetworkQosValidatorMock).requiredQosValuesPresentForOverriding(eq(network.getName()));
    verify(hostNetworkQosValidatorMock).valuesConsistent(eq(network.getName()));
    verifyNoMoreInteractions(hostNetworkQosValidatorMock);
}
#method_after
@Test
public void testValidateQosOverriddenInterfacesWhenAttachmentHasQosOverriddenAndRequiredValuesPresentButInconsistent() {
    EngineMessage hostNetworkQosValidatorFailure = EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_INCONSISTENT_VALUES;
    host.setClusterCompatibilityVersion(Version.v3_6);
    Network network = createNetworkWithName("network");
    HostSetupNetworksValidator validator = createValidatorForTestingValidateQosOverridden(network);
    HostSetupNetworksValidator validatorSpy = spy(validator);
    HostNetworkQosValidator hostNetworkQosValidatorMock = mock(HostNetworkQosValidator.class);
    when(hostNetworkQosValidatorMock.requiredQosValuesPresentForOverriding(eq(network.getName()))).thenReturn(ValidationResult.VALID);
    when(hostNetworkQosValidatorMock.valuesConsistent(eq(network.getName()))).thenReturn(new ValidationResult(hostNetworkQosValidatorFailure));
    doReturn(hostNetworkQosValidatorMock).when(validatorSpy).createHostNetworkQosValidator(any(HostNetworkQos.class));
    assertThat(validatorSpy.validateQosOverriddenInterfaces(), ValidationResultMatchers.failsWith(hostNetworkQosValidatorFailure));
    verify(hostNetworkQosValidatorMock).requiredQosValuesPresentForOverriding(eq(network.getName()));
    verify(hostNetworkQosValidatorMock).valuesConsistent(eq(network.getName()));
    verifyNoMoreInteractions(hostNetworkQosValidatorMock);
}
#end_block

#method_before
public ParametersBuilder addNetworkAttachments(NetworkAttachment... networkAttachments) {
    if (emptyParameters(networkAttachments)) {
        return this;
    }
    if (parameters.getNetworkAttachments() == null) {
        parameters.setNetworkAttachments(new ArrayList<NetworkAttachment>());
    }
    parameters.getNetworkAttachments().addAll(Arrays.asList(networkAttachments));
    return this;
}
#method_after
public ParametersBuilder addNetworkAttachments(NetworkAttachment... networkAttachments) {
    if (nullParameters(networkAttachments)) {
        return this;
    }
    if (parameters.getNetworkAttachments() == null) {
        parameters.setNetworkAttachments(new ArrayList<>());
    }
    parameters.getNetworkAttachments().addAll(Arrays.asList(networkAttachments));
    return this;
}
#end_block

#method_before
public ParametersBuilder addRemovedBonds(Guid... ids) {
    if (emptyParameters(ids)) {
        return this;
    }
    if (parameters.getRemovedBonds() == null) {
        parameters.setRemovedBonds(new HashSet<Guid>());
    }
    parameters.getRemovedBonds().addAll(Arrays.asList(ids));
    return this;
}
#method_after
public ParametersBuilder addRemovedBonds(Guid... ids) {
    if (nullParameters(ids)) {
        return this;
    }
    if (parameters.getRemovedBonds() == null) {
        parameters.setRemovedBonds(new HashSet<>());
    }
    parameters.getRemovedBonds().addAll(Arrays.asList(ids));
    return this;
}
#end_block

#method_before
public ParametersBuilder addRemovedNetworkAttachments(NetworkAttachment... networkAttachments) {
    if (emptyParameters(networkAttachments)) {
        return this;
    }
    if (parameters.getRemovedNetworkAttachments() == null) {
        parameters.setRemovedNetworkAttachments(new HashSet<Guid>());
    }
    for (NetworkAttachment networkAttachment : networkAttachments) {
        parameters.getRemovedNetworkAttachments().add(networkAttachment.getId());
    }
    return this;
}
#method_after
public ParametersBuilder addRemovedNetworkAttachments(NetworkAttachment... networkAttachments) {
    if (nullParameters(networkAttachments)) {
        return this;
    }
    if (parameters.getRemovedNetworkAttachments() == null) {
        parameters.setRemovedNetworkAttachments(new HashSet<>());
    }
    for (NetworkAttachment networkAttachment : networkAttachments) {
        parameters.getRemovedNetworkAttachments().add(networkAttachment.getId());
    }
    return this;
}
#end_block

#method_before
public ParametersBuilder addBonds(Bond... bonds) {
    if (emptyParameters(bonds)) {
        return this;
    }
    if (parameters.getBonds() == null) {
        parameters.setBonds(new ArrayList<Bond>());
    }
    parameters.getBonds().addAll(Arrays.asList(bonds));
    return this;
}
#method_after
public ParametersBuilder addBonds(Bond... bonds) {
    if (nullParameters(bonds)) {
        return this;
    }
    if (parameters.getBonds() == null) {
        parameters.setBonds(new ArrayList<>());
    }
    parameters.getBonds().addAll(Arrays.asList(bonds));
    return this;
}
#end_block

#method_before
public ParametersBuilder addRemovedLabels(String... removedLabels) {
    if (emptyParameters(removedLabels)) {
        return this;
    }
    if (parameters.getRemovedLabels() == null) {
        parameters.setRemovedLabels(new HashSet<String>());
    }
    parameters.getRemovedLabels().addAll(Arrays.asList(removedLabels));
    return this;
}
#method_after
public ParametersBuilder addRemovedLabels(String... removedLabels) {
    if (nullParameters(removedLabels)) {
        return this;
    }
    if (parameters.getRemovedLabels() == null) {
        parameters.setRemovedLabels(new HashSet<>());
    }
    parameters.getRemovedLabels().addAll(Arrays.asList(removedLabels));
    return this;
}
#end_block

#method_before
public ParametersBuilder addLabels(NicLabel... nicLabels) {
    if (emptyParameters(nicLabels)) {
        return this;
    }
    if (parameters.getLabels() == null) {
        parameters.setLabels(new HashSet<NicLabel>());
    }
    parameters.getLabels().addAll(Arrays.asList(nicLabels));
    return this;
}
#method_after
public ParametersBuilder addLabels(NicLabel... nicLabels) {
    if (nullParameters(nicLabels)) {
        return this;
    }
    if (parameters.getLabels() == null) {
        parameters.setLabels(new HashSet<>());
    }
    parameters.getLabels().addAll(Arrays.asList(nicLabels));
    return this;
}
#end_block

#method_before
public HostSetupNetworksValidator build() {
    return new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, new BusinessEntityMap<>(networks), managementNetworkUtil, networkClusterDaoMock, networkDaoMock, vdsDaoMock, new HostSetupNetworksValidatorHelper(), vmDao, mockNetworkExclusivenessValidatorResolver);
}
#method_after
public HostSetupNetworksValidator build() {
    return new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, new BusinessEntityMap<>(networks), managementNetworkUtil, networkClusterDaoMock, networkDaoMock, vdsDaoMock, new HostSetupNetworksValidatorHelper(), vmDao, mockNetworkExclusivenessValidatorResolver, mockNetworkAttachmentIpConfigurationValidator);
}
#end_block

#method_before
public ValidationResult networkNotChanged() {
    if (ObjectUtils.equals(vnicProfile.getNetworkId(), getOldVnicProfile().getNetworkId())) {
        return ValidationResult.VALID;
    }
    return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_CANNOT_CHANGE_VNIC_PROFILE_NETWORK);
}
#method_after
public ValidationResult networkNotChanged() {
    if (Objects.equals(vnicProfile.getNetworkId(), getOldVnicProfile().getNetworkId())) {
        return ValidationResult.VALID;
    }
    return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_CANNOT_CHANGE_VNIC_PROFILE_NETWORK);
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__TYPE__LABEL);
    addCanDoActionMessage(EngineMessage.VAR__ACTION__ADD);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__TYPE__LABEL);
    addValidationMessage(EngineMessage.VAR__ACTION__ADD);
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__TYPE__LABEL);
    addCanDoActionMessage(EngineMessage.VAR__ACTION__REMOVE);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__TYPE__LABEL);
    addValidationMessage(EngineMessage.VAR__ACTION__REMOVE);
}
#end_block

#method_before
protected List<String> listFiles() {
    GetImagesListParameters queryParams = new GetImagesListParameters(asGuid(storageDomainId), ImageFileType.All);
    queryParams.setForceRefresh(true);
    List<RepoImage> files = getBackendCollection(RepoImage.class, VdcQueryType.GetImagesList, queryParams);
    return files.stream().map(RepoImage::getRepoImageId).collect(Collectors.toCollection(LinkedList::new));
}
#method_after
protected List<String> listFiles() {
    GetImagesListParameters queryParams = new GetImagesListParameters(asGuid(storageDomainId), ImageFileType.All);
    queryParams.setForceRefresh(true);
    List<RepoImage> files = getBackendCollection(RepoImage.class, VdcQueryType.GetImagesList, queryParams);
    return files.stream().map(RepoImage::getRepoImageId).collect(toList());
}
#end_block

#method_before
private ExtendSANStorageDomainParameters createParameters(Guid storageDomainId, List<LogicalUnit> newLuns, boolean force) {
    ExtendSANStorageDomainParameters params = new ExtendSANStorageDomainParameters();
    params.setStorageDomainId(storageDomainId);
    ArrayList<String> lunIds = newLuns.stream().map(LogicalUnit::getId).collect(Collectors.toCollection(ArrayList::new));
    params.setLunIds(lunIds);
    params.setForce(force);
    return params;
}
#method_after
private ExtendSANStorageDomainParameters createParameters(Guid storageDomainId, List<LogicalUnit> newLuns, boolean force) {
    ExtendSANStorageDomainParameters params = new ExtendSANStorageDomainParameters();
    params.setStorageDomainId(storageDomainId);
    ArrayList<String> lunIds = newLuns.stream().map(LogicalUnit::getId).collect(toCollection(ArrayList::new));
    params.setLunIds(lunIds);
    params.setForce(force);
    return params;
}
#end_block

#method_before
@Override
protected boolean validate() {
    VDS host = getVds();
    completeMissingDataInParameters();
    boolean requestValid = validateEntitiesFromRequest(getParameters().getNetworkAttachments()) && validateEntitiesFromRequest(getParameters().getBonds());
    if (!requestValid) {
        return requestValid;
    }
    fillInUnsetBondingOptions();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    IdQueryParameters idParameters = new IdQueryParameters(getVdsId());
    VdcQueryReturnValue existingBondsResponse = runInternalQuery(VdcQueryType.GetHostBondsByHostId, idParameters);
    if (!existingBondsResponse.getSucceeded()) {
        return false;
    }
    List<VdsNetworkInterface> existingBonds = existingBondsResponse.getReturnValue();
    removeUnchangedAttachments(networkAttachmentDao.getAllForHost(getVdsId()));
    removeUnchangedBonds(existingBonds);
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#method_after
@Override
protected boolean validate() {
    VDS host = getVds();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    completeMissingDataInParameters();
    boolean requestValid = validateEntitiesFromRequest(getParameters().getNetworkAttachments()) && validateEntitiesFromRequest(getParameters().getBonds());
    if (!requestValid) {
        return requestValid;
    }
    fillInUnsetBondingOptions();
    IdQueryParameters idParameters = new IdQueryParameters(getVdsId());
    VdcQueryReturnValue existingBondsResponse = runInternalQuery(VdcQueryType.GetHostBondsByHostId, idParameters);
    if (!existingBondsResponse.getSucceeded()) {
        return false;
    }
    List<VdsNetworkInterface> existingBonds = existingBondsResponse.getReturnValue();
    removeUnchangedAttachments(networkAttachmentDao.getAllForHost(getVdsId()));
    removeUnchangedBonds(existingBonds);
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#end_block

#method_before
private void completeMissingDataInParameters() {
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    nicNameNicIdCompleter.completeLabels(getParameters().getLabels());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getExistingAttachments(), getNetworkBusinessEntityMap());
    NicLabelsCompleter labelsCompleter = new NicLabelsCompleter(getParameters(), getExistingAttachments(), getClusterNetworks(), getExistingNicsBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments();
}
#method_after
private void completeMissingDataInParameters() {
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    nicNameNicIdCompleter.completeLabels(getParameters().getLabels());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getExistingAttachments(), getNetworkBusinessEntityMap());
    NicLabelsCompleter labelsCompleter = new NicLabelsCompleter(getParameters(), getExistingAttachments(), getClusterNetworks(), getExistingNicsBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments();
    fillInUnsetIpConfigs();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        log.info("No changes were detected in setup networks for host '{}' (ID: '{}')", getVdsName(), getVdsId());
        setSucceeded(true);
        return;
    }
    int timeout = getSetupNetworksTimeout();
    FutureVDSCall<VDSReturnValue> setupNetworksTask = invokeSetupNetworksCommand(timeout);
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().rollbackOnFailure()) {
                throw new EngineException(EngineError.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock()) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                logMonitorLockReleased("Host setup networks");
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Host Setup networks command timed out for {} seconds", timeout);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        log.info("No changes were detected in setup networks for host '{}' (ID: '{}')", getVdsName(), getVdsId());
        setSucceeded(true);
        return;
    }
    int timeout = getSetupNetworksTimeout();
    FutureVDSCall<VDSReturnValue> setupNetworksTask = invokeSetupNetworksCommand(timeout);
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().rollbackOnFailure()) {
                throw new EngineException(EngineError.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock("Host setup networks")) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Host Setup networks command timed out for {} seconds", timeout);
    }
}
#end_block

#method_before
private HostSetupNetworksVdsCommandParameters createSetupNetworksParameters(int timeout) {
    final HostSetupNetworksVdsCommandParameters hostCmdParams = new HostSetupNetworksVdsCommandParameters(getVds(), getNetworksToConfigure(), getAllNetworksToRemove(), getParameters().getBonds(), getRemovedBondNames());
    hostCmdParams.setRollbackOnFailure(getParameters().rollbackOnFailure());
    hostCmdParams.setConectivityTimeout(timeout);
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(getVds().getClusterCompatibilityVersion());
    hostCmdParams.setHostNetworkQosSupported(hostNetworkQosSupported);
    hostCmdParams.setManagementNetworkChanged(isManagementNetworkChanged());
    return hostCmdParams;
}
#method_after
private HostSetupNetworksVdsCommandParameters createSetupNetworksParameters(int timeout) {
    final HostSetupNetworksVdsCommandParameters hostCmdParams = new HostSetupNetworksVdsCommandParameters(getVds(), getNetworksToConfigure(), getAllNetworksToRemove(), getParameters().getBonds(), getRemovedBondNames());
    hostCmdParams.setRollbackOnFailure(getParameters().rollbackOnFailure());
    hostCmdParams.setConnectivityTimeout(timeout);
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(getVds().getClusterCompatibilityVersion());
    hostCmdParams.setHostNetworkQosSupported(hostNetworkQosSupported);
    hostCmdParams.setManagementNetworkChanged(isManagementNetworkChanged());
    return hostCmdParams;
}
#end_block

#method_before
public void perform(List<Pair<VM, VmInternalData>> monitoredVms, long fetchTime, VdsManager vdsManager, boolean updateStatistics) {
    if (monitoredVms.isEmpty()) {
        return;
    }
    List<VmAnalyzer> vmAnalyzers = Collections.emptyList();
    try {
        vmAnalyzers = refreshVmStats(monitoredVms, fetchTime, vdsManager, updateStatistics);
        afterVMsRefreshTreatment(vmAnalyzers, vdsManager);
        vdsManager.vmsMonitoringInitFinished();
    } catch (RuntimeException ex) {
        log.error("Failed during vms monitoring on host {} error is: {}", vdsManager.getVdsName(), ex);
        log.error("Exception:", ex);
    } finally {
        unlockVms(vmAnalyzers);
    }
}
#method_after
public void perform() {
    try {
        refreshExistingVmJobList();
        refreshVmStats();
        afterVMsRefreshTreatment();
        vdsManager.vmsMonitoringInitFinished();
    } catch (RuntimeException ex) {
        log.error("Failed during vms monitoring on host {} error is: {}", vdsManager.getVdsName(), ex);
        log.error("Exception:", ex);
    } finally {
        unlockVmsManager();
    }
}
#end_block

#method_before
private boolean tryLockVmForUpdate(Pair<VM, VmInternalData> pair, long fetchTime, Guid vdsId) {
    Guid vmId = getVmId(pair.getFirst(), pair.getSecond());
    VmManager vmManager = resourceManager.getVmManager(vmId);
    if (!vmManager.trylock()) {
        log.debug("skipping VM '{}' from this monitoring cycle" + " - the VM is locked by its VmManager ", vmId);
        return false;
    }
    if (!vmManager.isLatestData(pair.getSecond(), vdsId)) {
        log.warn("skipping VM '{}' from this monitoring cycle" + " - newer VM data was already processed", vmId);
        vmManager.unlock();
        return false;
    }
    if (vmManager.getVmDataChangedTime() != null && fetchTime - vmManager.getVmDataChangedTime() <= 0) {
        log.warn("skipping VM '{}' from this monitoring cycle" + " - the VM data has changed since fetching the data", vmId);
        vmManager.unlock();
        return false;
    }
    return true;
}
#method_after
private boolean tryLockVmForUpdate(Pair<VM, VmInternalData> pair) {
    Guid vmId = getVmId(pair);
    if (vmId != null) {
        VmManager vmManager = getResourceManager().getVmManager(vmId);
        if (vmManager.trylock()) {
            if (!vmManager.isLatestData(pair.getSecond(), vdsManager.getVdsId())) {
                log.warn("skipping VM '{}' from this monitoring cycle" + " - newer VM data was already processed", vmId);
                vmManager.unlock();
            } else if (vmManager.getVmDataChangedTime() != null && fetchTime - vmManager.getVmDataChangedTime() <= 0) {
                log.warn("skipping VM '{}' from this monitoring cycle" + " - the VM data has changed since fetching the data", vmId);
                vmManager.unlock();
            } else {
                // store the locked managers to finally release them at the end of the cycle
                vmManagers.put(vmId, vmManager);
                return true;
            }
        } else {
            log.debug("skipping VM '{}' from this monitoring cycle" + " - the VM is locked by its VmManager ", getVmId(pair));
        }
    }
    return false;
}
#end_block

#method_before
private List<VmAnalyzer> refreshVmStats(List<Pair<VM, VmInternalData>> monitoredVms, long fetchTime, VdsManager vdsManager, boolean updateStatistics) {
    List<VmAnalyzer> vmAnalyzers = new ArrayList<>(monitoredVms.size());
    monitoredVms.forEach(vm -> {
        // TODO filter out migratingTo VMs if no action is taken on them
        if (tryLockVmForUpdate(vm, fetchTime, vdsManager.getVdsId())) {
            VmAnalyzer vmAnalyzer = getVmAnalyzer(vm, vdsManager, updateStatistics);
            vmAnalyzers.add(vmAnalyzer);
            vmAnalyzer.analyze();
        }
    });
    addUnmanagedVms(vmAnalyzers, vdsManager.getVdsId());
    flush(vmAnalyzers);
    return vmAnalyzers;
}
#method_after
private void refreshVmStats() {
    for (Pair<VM, VmInternalData> monitoredVm : monitoredVms) {
        // TODO filter out migratingTo VMs if no action is taken on them
        if (tryLockVmForUpdate(monitoredVm)) {
            VmAnalyzer vmAnalyzer = getVmAnalyzer(monitoredVm);
            vmAnalyzers.add(vmAnalyzer);
            vmAnalyzer.analyze();
        }
    }
    processVmsWithDevicesChange();
    saveVmsToDb();
}
#end_block

#method_before
protected VmAnalyzer getVmAnalyzer(Pair<VM, VmInternalData> pair, VdsManager vdsManager, boolean updateStatistics) {
    VmAnalyzer vmAnalyzer = new VmAnalyzer(pair.getFirst(), pair.getSecond(), updateStatistics);
    vmAnalyzer.setDbFacade(dbFacade);
    vmAnalyzer.setResourceManager(resourceManager);
    vmAnalyzer.setAuditLogDirector(auditLogDirector);
    vmAnalyzer.setVdsManager(vdsManager);
    return vmAnalyzer;
}
#method_after
protected VmAnalyzer getVmAnalyzer(Pair<VM, VmInternalData> pair) {
    return new VmAnalyzer(pair.getFirst(), pair.getSecond(), this, auditLogDirector);
}
#end_block

#method_before
private void afterVMsRefreshTreatment(List<VmAnalyzer> vmAnalyzers, VdsManager vdsManager) {
    Collection<Guid> movedToDownVms = new ArrayList<>();
    List<Guid> succeededToRunVms = new ArrayList<>();
    List<Guid> autoVmsToRun = new ArrayList<>();
    List<Guid> coldRebootVmsToRun = new ArrayList<>();
    // now loop over the result and act
    for (VmAnalyzer vmAnalyzer : vmAnalyzers) {
        // rerun all vms from rerun list
        if (vmAnalyzer.isRerun()) {
            log.error("Rerun VM '{}'. Called from VDS '{}'", vmAnalyzer.getDbVm().getId(), vdsManager.getVdsName());
            resourceManager.rerunFailedCommand(vmAnalyzer.getDbVm().getId(), vdsManager.getVdsId());
        }
        if (vmAnalyzer.isSuccededToRun()) {
            vdsManager.succeededToRunVm(vmAnalyzer.getDbVm().getId());
            succeededToRunVms.add(vmAnalyzer.getDbVm().getId());
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        if (vmAnalyzer.isAutoVmToRun() && !vmAnalyzer.isRerun()) {
            autoVmsToRun.add(vmAnalyzer.getDbVm().getId());
        }
        if (vmAnalyzer.isColdRebootVmToRun()) {
            coldRebootVmsToRun.add(vmAnalyzer.getDbVm().getId());
        }
        // process all vms that their ip changed.
        if (vmAnalyzer.isClientIpChanged()) {
            final VmDynamic vmDynamic = vmAnalyzer.getVdsmVm().getVmDynamic();
            getVdsEventListener().processOnClientIpChange(vmDynamic.getId(), vmDynamic.getClientIp());
        }
        // process all vms that powering up.
        if (vmAnalyzer.isPoweringUp()) {
            getVdsEventListener().processOnVmPoweringUp(vmAnalyzer.getVdsmVm().getVmDynamic().getId());
        }
        if (vmAnalyzer.isMovedToDown()) {
            movedToDownVms.add(vmAnalyzer.getDbVm().getId());
        }
        if (vmAnalyzer.isRemoveFromAsync()) {
            resourceManager.removeAsyncRunningVm(vmAnalyzer.getDbVm().getId());
        }
    }
    getVdsEventListener().updateSlaPolicies(succeededToRunVms, vdsManager.getVdsId());
    // run all vms that crashed that marked with auto startup
    getVdsEventListener().runFailedAutoStartVMs(autoVmsToRun);
    // run all vms that went down as a part of cold reboot process
    getVdsEventListener().runColdRebootVms(coldRebootVmsToRun);
    // process all vms that went down
    getVdsEventListener().processOnVmStop(movedToDownVms, vdsManager.getVdsId());
    getVdsEventListener().refreshHostIfAnyVmHasHostDevices(succeededToRunVms, vdsManager.getVdsId());
}
#method_after
private void afterVMsRefreshTreatment() {
    Collection<Guid> movedToDownVms = new ArrayList<>();
    List<Guid> succeededToRunVms = new ArrayList<>();
    List<Guid> externalVms = new ArrayList<>();
    // now loop over the result and act
    for (VmAnalyzer vmAnalyzer : vmAnalyzers) {
        // rerun all vms from rerun list
        if (vmAnalyzer.isRerun()) {
            log.error("Rerun VM '{}'. Called from VDS '{}'", vmAnalyzer.getDbVm().getId(), vdsManager.getVdsName());
            getResourceManager().rerunFailedCommand(vmAnalyzer.getDbVm().getId(), vdsManager.getVdsId());
        }
        if (vmAnalyzer.isSuccededToRun()) {
            vdsManager.succeededToRunVm(vmAnalyzer.getDbVm().getId());
            succeededToRunVms.add(vmAnalyzer.getDbVm().getId());
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        if (vmAnalyzer.isAutoVmToRun() && !vmAnalyzer.isRerun()) {
            autoVmsToRun.add(vmAnalyzer.getDbVm().getId());
        }
        if (vmAnalyzer.isColdRebootVmToRun()) {
            coldRebootVmsToRun.add(vmAnalyzer.getDbVm().getId());
        }
        // process all vms that their ip changed.
        if (vmAnalyzer.isClientIpChanged()) {
            final VmDynamic vmDynamic = vmAnalyzer.getVdsmVm().getVmDynamic();
            getVdsEventListener().processOnClientIpChange(vmDynamic.getId(), vmDynamic.getClientIp());
        }
        // process all vms that powering up.
        if (vmAnalyzer.isPoweringUp()) {
            getVdsEventListener().processOnVmPoweringUp(vmAnalyzer.getVdsmVm().getVmDynamic().getId());
        }
        if (vmAnalyzer.isMovedToDown()) {
            movedToDownVms.add(vmAnalyzer.getDbVm().getId());
        }
        if (vmAnalyzer.isRemoveFromAsync()) {
            getResourceManager().removeAsyncRunningVm(vmAnalyzer.getDbVm().getId());
        }
        if (vmAnalyzer.isHostedEngineUnmanaged()) {
            // @since 3.6 - we take existing HE VM and reimport it
            externalVms.add(vmAnalyzer.getVdsmVm().getVmDynamic().getId());
        }
        if (vmAnalyzer.isExternalVm()) {
            externalVms.add(vmAnalyzer.getVdsmVm().getVmDynamic().getId());
        }
    }
    getVdsEventListener().updateSlaPolicies(succeededToRunVms, vdsManager.getVdsId());
    // run all vms that crashed that marked with auto startup
    getVdsEventListener().runFailedAutoStartVMs(autoVmsToRun);
    // run all vms that went down as a part of cold reboot process
    getVdsEventListener().runColdRebootVms(coldRebootVmsToRun);
    // process all vms that went down
    getVdsEventListener().processOnVmStop(movedToDownVms, vdsManager.getVdsId());
    getVdsEventListener().refreshHostIfAnyVmHasHostDevices(succeededToRunVms, vdsManager.getVdsId());
    getVdsEventListener().addUnmanagedVms(externalVms);
}
#end_block

#method_before
// ***** DB interaction *****
private void saveVmGuestAgentNetworkDevices(List<VmAnalyzer> vmAnalyzers) {
    Map<Guid, List<VmGuestAgentInterface>> vmGuestAgentNics = vmAnalyzers.stream().filter(analyzer -> !analyzer.getVmGuestAgentNics().isEmpty()).map(analyzer -> new Pair<>(analyzer.getDbVm().getId(), analyzer.getVmGuestAgentNics())).collect(Collectors.toMap(Pair::getFirst, Pair::getSecond));
    if (!vmGuestAgentNics.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            for (Guid vmId : vmGuestAgentNics.keySet()) {
                dbFacade.getVmGuestAgentInterfaceDao().removeAllForVm(vmId);
            }
            for (List<VmGuestAgentInterface> nics : vmGuestAgentNics.values()) {
                if (nics != null) {
                    for (VmGuestAgentInterface nic : nics) {
                        dbFacade.getVmGuestAgentInterfaceDao().save(nic);
                    }
                }
            }
            return null;
        });
    }
}
#method_after
// ***** DB interaction *****
private void saveVmGuestAgentNetworkDevices() {
    if (!vmGuestAgentNics.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (Guid vmId : vmGuestAgentNics.keySet()) {
                    getDbFacade().getVmGuestAgentInterfaceDao().removeAllForVm(vmId);
                }
                for (List<VmGuestAgentInterface> nics : vmGuestAgentNics.values()) {
                    if (nics != null) {
                        for (VmGuestAgentInterface nic : nics) {
                            getDbFacade().getVmGuestAgentInterfaceDao().save(nic);
                        }
                    }
                }
                return null;
            }
        });
    }
}
#end_block

#method_before
private void saveVmJobsToDb(List<VmAnalyzer> vmAnalyzers) {
    dbFacade.getVmJobDao().updateAllInBatch(vmAnalyzers.stream().map(VmAnalyzer::getVmJobsToUpdate).flatMap(Collection::stream).collect(Collectors.toList()));
    List<Guid> vmJobIdsToRemove = vmAnalyzers.stream().map(VmAnalyzer::getVmJobIdsToRemove).flatMap(List::stream).collect(Collectors.toList());
    if (!vmJobIdsToRemove.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            dbFacade.getVmJobDao().removeAll(vmJobIdsToRemove);
            return null;
        });
    }
}
#method_after
private void saveVmJobsToDb() {
    getDbFacade().getVmJobDao().updateAllInBatch(vmJobsToUpdate.values());
    if (!vmJobIdsToRemove.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getDbFacade().getVmJobDao().removeAll(vmJobIdsToRemove);
                return null;
            }
        });
    }
}
#end_block

#method_before
private static Guid getVmId(VM dbVm, VmInternalData vdsmVm) {
    return dbVm != null ? dbVm.getId() : vdsmVm.getVmDynamic().getId();
}
#method_after
private Guid getVmId(Pair<VM, VmInternalData> pair) {
    return (pair.getFirst() != null) ? pair.getFirst().getId() : ((pair.getSecond() != null) ? pair.getSecond().getVmDynamic().getId() : null);
}
#end_block

#method_before
protected IVdsEventListener getVdsEventListener() {
    return resourceManager.getEventListener();
}
#method_after
protected IVdsEventListener getVdsEventListener() {
    return ResourceManager.getInstance().getEventListener();
}
#end_block

#method_before
public int getNumOfCpus() {
    return this.getCpuPerSocket() * this.getNumOfSockets();
}
#method_after
public int getNumOfCpus() {
    return this.getCpuPerSocket() * this.getNumOfSockets() * this.getThreadsPerCpu();
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + cpuPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + osId;
    result = prime * result + memSizeMb;
    result = prime * result + niceLevel;
    result = prime * result + cpuShares;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((dedicatedVmForVdsList == null) ? 0 : dedicatedVmForVdsList.hashCode());
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((tunnelMigration == null) ? 0 : tunnelMigration.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((createdByUserId == null) ? 0 : createdByUserId.hashCode());
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + ((migrationDowntime == null) ? 0 : migrationDowntime.hashCode());
    result = prime * result + ((serialNumberPolicy == null) ? 0 : serialNumberPolicy.hashCode());
    result = prime * result + ((customSerialNumber == null) ? 0 : customSerialNumber.hashCode());
    result = prime * result + (bootMenuEnabled ? 1231 : 1237);
    result = prime * result + (spiceFileTransferEnabled ? 1231 : 1237);
    result = prime * result + (spiceCopyPasteEnabled ? 1231 : 1237);
    result = prime * result + ((cpuProfileId == null) ? 0 : cpuProfileId.hashCode());
    result = prime * result + ((numaTuneMode == null) ? 0 : numaTuneMode.getValue().hashCode());
    result = prime * result + ((vNumaNodeList == null) ? 0 : vNumaNodeList.hashCode());
    result = prime * result + (autoConverge == null ? 0 : autoConverge.hashCode());
    result = prime * result + (migrateCompressed == null ? 0 : migrateCompressed.hashCode());
    result = prime * result + ((predefinedProperties == null) ? 0 : predefinedProperties.hashCode());
    result = prime * result + ((userDefinedProperties == null) ? 0 : userDefinedProperties.hashCode());
    result = prime * result + ((customEmulatedMachine == null) ? 0 : customEmulatedMachine.hashCode());
    result = prime * result + ((customCpuName == null) ? 0 : customCpuName.hashCode());
    result = prime * result + ((smallIconId == null) ? 0 : smallIconId.hashCode());
    result = prime * result + ((largeIconId == null) ? 0 : largeIconId.hashCode());
    result = prime * result + ((consoleDisconnectAction == null) ? 0 : consoleDisconnectAction.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + cpuPerSocket;
    result = prime * result + threadsPerCpu;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + osId;
    result = prime * result + memSizeMb;
    result = prime * result + niceLevel;
    result = prime * result + cpuShares;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((dedicatedVmForVdsList == null) ? 0 : dedicatedVmForVdsList.hashCode());
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((tunnelMigration == null) ? 0 : tunnelMigration.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((createdByUserId == null) ? 0 : createdByUserId.hashCode());
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + ((migrationDowntime == null) ? 0 : migrationDowntime.hashCode());
    result = prime * result + ((serialNumberPolicy == null) ? 0 : serialNumberPolicy.hashCode());
    result = prime * result + ((customSerialNumber == null) ? 0 : customSerialNumber.hashCode());
    result = prime * result + (bootMenuEnabled ? 1231 : 1237);
    result = prime * result + (spiceFileTransferEnabled ? 1231 : 1237);
    result = prime * result + (spiceCopyPasteEnabled ? 1231 : 1237);
    result = prime * result + ((cpuProfileId == null) ? 0 : cpuProfileId.hashCode());
    result = prime * result + ((numaTuneMode == null) ? 0 : numaTuneMode.getValue().hashCode());
    result = prime * result + ((vNumaNodeList == null) ? 0 : vNumaNodeList.hashCode());
    result = prime * result + (autoConverge == null ? 0 : autoConverge.hashCode());
    result = prime * result + (migrateCompressed == null ? 0 : migrateCompressed.hashCode());
    result = prime * result + ((predefinedProperties == null) ? 0 : predefinedProperties.hashCode());
    result = prime * result + ((userDefinedProperties == null) ? 0 : userDefinedProperties.hashCode());
    result = prime * result + ((customEmulatedMachine == null) ? 0 : customEmulatedMachine.hashCode());
    result = prime * result + ((customCpuName == null) ? 0 : customCpuName.hashCode());
    result = prime * result + ((smallIconId == null) ? 0 : smallIconId.hashCode());
    result = prime * result + ((largeIconId == null) ? 0 : largeIconId.hashCode());
    result = prime * result + ((consoleDisconnectAction == null) ? 0 : consoleDisconnectAction.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && ObjectUtils.objectsEqual(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && ObjectUtils.objectsEqual(description, other.description) && failBack == other.failBack && ObjectUtils.objectsEqual(initrdUrl, other.initrdUrl) && ObjectUtils.objectsEqual(isoPath, other.isoPath) && ObjectUtils.objectsEqual(kernelParams, other.kernelParams) && ObjectUtils.objectsEqual(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && ObjectUtils.objectsEqual(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && ObjectUtils.objectsEqual(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && ObjectUtils.objectsEqual(dedicatedVmForVdsList, other.dedicatedVmForVdsList) && migrationSupport == other.migrationSupport && ObjectUtils.objectsEqual(tunnelMigration, other.tunnelMigration) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && ObjectUtils.objectsEqual(migrationDowntime, other.migrationDowntime) && serialNumberPolicy == other.serialNumberPolicy && ObjectUtils.objectsEqual(customSerialNumber, other.customSerialNumber) && bootMenuEnabled == other.bootMenuEnabled && spiceFileTransferEnabled == other.spiceFileTransferEnabled && spiceCopyPasteEnabled == other.spiceCopyPasteEnabled && ObjectUtils.objectsEqual(cpuProfileId, other.cpuProfileId) && ObjectUtils.objectsEqual(numaTuneMode.getValue(), other.numaTuneMode.getValue()) && ObjectUtils.objectsEqual(vNumaNodeList, other.vNumaNodeList)) && ObjectUtils.objectsEqual(autoConverge, other.autoConverge) && ObjectUtils.objectsEqual(migrateCompressed, other.migrateCompressed) && ObjectUtils.objectsEqual(predefinedProperties, other.predefinedProperties) && ObjectUtils.objectsEqual(userDefinedProperties, other.userDefinedProperties) && ObjectUtils.objectsEqual(customEmulatedMachine, other.customEmulatedMachine) && ObjectUtils.objectsEqual(customCpuName, other.customCpuName) && Objects.equals(smallIconId, other.smallIconId) && Objects.equals(largeIconId, other.largeIconId) && ObjectUtils.objectsEqual(consoleDisconnectAction, other.consoleDisconnectAction);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && ObjectUtils.objectsEqual(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && ObjectUtils.objectsEqual(description, other.description) && failBack == other.failBack && ObjectUtils.objectsEqual(initrdUrl, other.initrdUrl) && ObjectUtils.objectsEqual(isoPath, other.isoPath) && ObjectUtils.objectsEqual(kernelParams, other.kernelParams) && ObjectUtils.objectsEqual(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && threadsPerCpu == other.threadsPerCpu && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && ObjectUtils.objectsEqual(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && ObjectUtils.objectsEqual(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && ObjectUtils.objectsEqual(dedicatedVmForVdsList, other.dedicatedVmForVdsList) && migrationSupport == other.migrationSupport && ObjectUtils.objectsEqual(tunnelMigration, other.tunnelMigration) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && ObjectUtils.objectsEqual(migrationDowntime, other.migrationDowntime) && serialNumberPolicy == other.serialNumberPolicy && ObjectUtils.objectsEqual(customSerialNumber, other.customSerialNumber) && bootMenuEnabled == other.bootMenuEnabled && spiceFileTransferEnabled == other.spiceFileTransferEnabled && spiceCopyPasteEnabled == other.spiceCopyPasteEnabled && ObjectUtils.objectsEqual(cpuProfileId, other.cpuProfileId) && ObjectUtils.objectsEqual(numaTuneMode.getValue(), other.numaTuneMode.getValue()) && ObjectUtils.objectsEqual(vNumaNodeList, other.vNumaNodeList)) && ObjectUtils.objectsEqual(autoConverge, other.autoConverge) && ObjectUtils.objectsEqual(migrateCompressed, other.migrateCompressed) && ObjectUtils.objectsEqual(predefinedProperties, other.predefinedProperties) && ObjectUtils.objectsEqual(userDefinedProperties, other.userDefinedProperties) && ObjectUtils.objectsEqual(customEmulatedMachine, other.customEmulatedMachine) && ObjectUtils.objectsEqual(customCpuName, other.customCpuName) && Objects.equals(smallIconId, other.smallIconId) && Objects.equals(largeIconId, other.largeIconId) && ObjectUtils.objectsEqual(consoleDisconnectAction, other.consoleDisconnectAction);
}
#end_block

#method_before
protected boolean validateInputs() {
    return super.validateInputs();
}
#method_after
@Override
protected boolean validateInputs() {
    return super.validateInputs();
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!isVmExist()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Arrays.asList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!isVmExist()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Collections.singletonList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#end_block

#method_before
protected boolean checkIfLunDiskCanBeAdded(DiskValidator diskValidator) {
    LunDisk lunDisk = ((LunDisk) getParameters().getDiskInfo());
    LUNs lun = lunDisk.getLun();
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (StorageServerConnections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getIqn()) || StringUtils.isEmpty(conn.getConnection()) || StringUtils.isEmpty(conn.getPort())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
        default:
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUNId()) != null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    if (getVm() != null && !(isVmNotLocked() && isVmNotInPreviewSnapshot())) {
        return false;
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    if (getVds() != null) {
        lunFromStorage = getLunDisk(lun, getVds());
        if (lunFromStorage == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_INVALID);
        }
    }
    if (!validate(diskValidator.isUsingScsiReservationValid(getVm(), lunDisk))) {
        return false;
    }
    return true;
}
#method_after
protected boolean checkIfLunDiskCanBeAdded(DiskValidator diskValidator) {
    LunDisk lunDisk = (LunDisk) getParameters().getDiskInfo();
    LUNs lun = lunDisk.getLun();
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (StorageServerConnections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getIqn()) || StringUtils.isEmpty(conn.getConnection()) || StringUtils.isEmpty(conn.getPort())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
        default:
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUNId()) != null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    if (getVm() != null && !(isVmNotLocked() && isVmNotInPreviewSnapshot())) {
        return false;
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    if (getVds() != null) {
        lunFromStorage = getLunDisk(lun, getVds());
        if (lunFromStorage == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_INVALID);
        }
    }
    if (!validate(diskValidator.isUsingScsiReservationValid(getVm(), lunDisk))) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (useCallback()) {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    } else {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        getCompensationContext().snapshotNewEntity(addManagedDeviceForDisk(getParameters().getDiskInfo().getId()));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (useCallback()) {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    } else {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        getCompensationContext().snapshotNewEntity(addManagedDeviceForDisk(getParameters().getDiskInfo().getId()));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
private void createDiskBasedOnCinder() {
    // ToDo: upon using CoCo infra in this commnad, move this logic.
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.AddCinderDisk, buildAddCinderDiskParameters(), cloneContextAndDetachFromParent(), new SubjectEntity(VdcObjectType.Storage, getParameters().getStorageDomainId()));
    try {
        setReturnValue(future.get());
        setSucceeded(getReturnValue().getSucceeded());
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error creating Cinder disk '{}': {}", getParameters().getDiskInfo().getDiskAlias(), e.getMessage());
        log.debug("Exception", e);
    }
}
#method_after
private void createDiskBasedOnCinder() {
    // ToDo: upon using CoCo infra in this commnad, move this logic.
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.AddCinderDisk, buildAddCinderDiskParameters(), cloneContextAndDetachFromParent());
    try {
        setReturnValue(future.get());
        setSucceeded(getReturnValue().getSucceeded());
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error creating Cinder disk '{}': {}", getParameters().getDiskInfo().getDiskAlias(), e.getMessage());
        log.debug("Exception", e);
    }
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(() -> {
        Deserializer deserializer = SerializationFactory.getDeserializer();
        List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDao().getAllForCommandId(commandId);
        log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
        for (BusinessEntitySnapshot snapshot : entitySnapshots) {
            Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
            Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
            log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
            Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
            GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
            switch(snapshot.getSnapshotType()) {
                case CHANGED_STATUS_ONLY:
                    EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                    ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                    break;
                case DELETED_OR_UPDATED_ENTITY:
                    BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                    if (daoForEntity.get(entitySnapshot.getId()) == null) {
                        daoForEntity.save(entitySnapshot);
                    } else {
                        daoForEntity.update(entitySnapshot);
                    }
                    break;
                case UPDATED_ONLY_ENTITY:
                    daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                    break;
                case NEW_ENTITY_ID:
                    daoForEntity.remove(snapshotData);
                    break;
            }
        }
        cleanUpCompensationData();
        return null;
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(() -> {
        Deserializer deserializer = SerializationFactory.getDeserializer();
        List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDao().getAllForCommandId(commandId);
        log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
        for (BusinessEntitySnapshot snapshot : entitySnapshots) {
            Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
            Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
            log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString());
            Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
            GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
            switch(snapshot.getSnapshotType()) {
                case CHANGED_STATUS_ONLY:
                    EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                    ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                    break;
                case DELETED_OR_UPDATED_ENTITY:
                    BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                    if (daoForEntity.get(entitySnapshot.getId()) == null) {
                        daoForEntity.save(entitySnapshot);
                    } else {
                        daoForEntity.update(entitySnapshot);
                    }
                    break;
                case UPDATED_ONLY_ENTITY:
                    daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                    break;
                case NEW_ENTITY_ID:
                    daoForEntity.remove(snapshotData);
                    break;
            }
        }
        cleanUpCompensationData();
        return null;
    });
}
#end_block

#method_before
private void cleanUpCompensationData() {
    if (!(getCompensationContext() instanceof NoOpCompensationContext)) {
        getBusinessEntitySnapshotDao().removeAllForCommandId(commandId);
    }
}
#method_after
private void cleanUpCompensationData() {
    getCompensationContext().resetCompensation();
}
#end_block

#method_before
protected void auditLog(AuditLogableBase logable, AuditLogType logType) {
    auditLogDirector.log(logable, logType);
}
#method_after
void auditLog(AuditLogableBase logable, AuditLogType logType) {
    auditLogDirector.log(logable, logType);
}
#end_block

#method_before
protected void logRollbackedTask() {
    String type = (getCurrentTaskHandler().getRevertTaskType() != null ? getCurrentTaskHandler().getRevertTaskType().name() : AsyncTaskType.unknown.name());
    log.error("Reverting task '{}', handler '{}'", type, getCurrentTaskHandler().getClass().getName());
}
#method_after
protected void logRollbackedTask() {
    String type = getCurrentTaskHandler().getRevertTaskType() != null ? getCurrentTaskHandler().getRevertTaskType().name() : AsyncTaskType.unknown.name();
    log.error("Reverting task '{}', handler '{}'", type, getCurrentTaskHandler().getClass().getName());
}
#end_block

#method_before
final public boolean checkSinglePermission(PermissionSubject permSubject, Collection<String> messages) {
    final Guid objectId = permSubject.getObjectId();
    final VdcObjectType objectType = permSubject.getObjectType();
    final ActionGroup objectActionGroup = permSubject.getActionGroup();
    // if objectId is null we can't check permission
    if (objectId == null) {
        if (log.isDebugEnabled()) {
            log.debug("The object to check is null for action '{}'.", getActionType());
        }
        messages.add(EngineMessage.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.name());
        return false;
    }
    // Check that an action group is defined for this action;
    if (objectActionGroup == null) {
        if (log.isDebugEnabled()) {
            log.debug("No action group is defined for action '{}'.", getActionType());
        }
        return false;
    }
    // Check the authorization:
    if (!checkUserAuthorization(getCurrentUser().getId(), objectActionGroup, objectId, objectType)) {
        messages.add(permSubject.getMessage().name());
        return false;
    }
    return true;
}
#method_after
public final boolean checkSinglePermission(PermissionSubject permSubject, Collection<String> messages) {
    final Guid objectId = permSubject.getObjectId();
    final VdcObjectType objectType = permSubject.getObjectType();
    final ActionGroup objectActionGroup = permSubject.getActionGroup();
    // if objectId is null we can't check permission
    if (objectId == null) {
        if (log.isDebugEnabled()) {
            log.debug("The object to check is null for action '{}'.", getActionType());
        }
        messages.add(EngineMessage.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.name());
        return false;
    }
    // Check that an action group is defined for this action;
    if (objectActionGroup == null) {
        if (log.isDebugEnabled()) {
            log.debug("No action group is defined for action '{}'.", getActionType());
        }
        return false;
    }
    // Check the authorization:
    if (!checkUserAuthorization(getCurrentUser().getId(), objectActionGroup, objectId, objectType)) {
        messages.add(permSubject.getMessage().name());
        return false;
    }
    return true;
}
#end_block

#method_before
private CommandEntity buildCommandEntity(Guid rootCommandId, boolean enableCallback) {
    return CommandEntity.buildCommandEntity(getUserId(), getCommandId(), getParameters().getParentParameters() == null ? Guid.Empty : getParameters().getParentParameters().getCommandId(), rootCommandId, getExecutionContext() == null || getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext() == null || getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallback, getReturnValue());
}
#method_after
private CommandEntity buildCommandEntity(Guid rootCommandId, boolean enableCallback) {
    return CommandEntity.buildCommandEntity(getUserId(), getCommandId(), getParameters().getParentParameters() == null ? Guid.Empty : getParameters().getParentParameters().getCommandId(), rootCommandId, getExecutionContext() == null || getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext() == null || getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallback, getReturnValue(), getCommandData());
}
#end_block

#method_before
private void restoreConfiguration(Snapshot targetSnapshot) {
    SnapshotsManager snapshotsManager = new SnapshotsManager();
    removedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    snapshotsToRemove.add(removedSnapshotId);
    snapshotsManager.removeAllIllegalDisks(removedSnapshotId, getVmId());
    snapshotsManager.attempToRestoreVmConfigurationFromSnapshot(getVm(), targetSnapshot, targetSnapshot.getId(), null, getCompensationContext(), getVm().getClusterCompatibilityVersion(), getCurrentUser());
    getSnapshotDao().remove(targetSnapshot.getId());
    // add active snapshot with status locked, so that other commands that depend on the VM's snapshots won't run in parallel
    snapshotsManager.addActiveSnapshot(targetSnapshot.getId(), getVm(), SnapshotStatus.LOCKED, targetSnapshot.getMemoryVolume(), getCompensationContext());
}
#method_after
private void restoreConfiguration(Snapshot targetSnapshot) {
    SnapshotsManager snapshotsManager = new SnapshotsManager();
    removedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    snapshotsToRemove.add(removedSnapshotId);
    snapshotsManager.removeAllIllegalDisks(removedSnapshotId, getVmId());
    snapshotsManager.attempToRestoreVmConfigurationFromSnapshot(getVm(), targetSnapshot, targetSnapshot.getId(), null, getCompensationContext(), getVm().getCompatibilityVersion(), getCurrentUser());
    getSnapshotDao().remove(targetSnapshot.getId());
    // add active snapshot with status locked, so that other commands that depend on the VM's snapshots won't run in parallel
    snapshotsManager.addActiveSnapshot(targetSnapshot.getId(), getVm(), SnapshotStatus.LOCKED, targetSnapshot.getMemoryVolume(), getCompensationContext());
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    if (!validate(snapshotValidator.snapshotExists(getSnapshot())) || !validate(snapshotValidator.snapshotExists(getVmId(), getSnapshot().getId())) || !validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    if (Guid.Empty.equals(getSnapshot().getId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    VmValidator vmValidator = createVmValidator(getVm());
    MultipleStorageDomainsValidator storageValidator = createStorageDomainValidator();
    if (!validate(storageValidator.allDomainsExistAndActive()) || !validate(storageValidator.allDomainsWithinThresholds()) || !performImagesChecks() || !validate(vmValidator.vmDown()) || // if the user choose to commit a snapshot the vm can't have disk snapshots attached to other vms.
    (getSnapshot()).getType() == SnapshotType.REGULAR && !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    if (getSnapshot().getType() == SnapshotType.REGULAR && getSnapshot().getStatus() != SnapshotStatus.IN_PREVIEW) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_SNAPSHOT_NOT_IN_PREVIEW);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    if (!validate(snapshotValidator.snapshotExists(getSnapshot())) || !validate(snapshotValidator.snapshotExists(getVmId(), getSnapshot().getId())) || !validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    if (Guid.Empty.equals(getSnapshot().getId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    VmValidator vmValidator = createVmValidator(getVm());
    MultipleStorageDomainsValidator storageValidator = createStorageDomainValidator();
    if (!validate(storageValidator.allDomainsExistAndActive()) || !validate(storageValidator.allDomainsWithinThresholds()) || !performImagesChecks() || !validate(vmValidator.vmDown()) || // if the user choose to commit a snapshot the vm can't have disk snapshots attached to other vms.
    getSnapshot().getType() == SnapshotType.REGULAR && !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    if (getSnapshot().getType() == SnapshotType.REGULAR && getSnapshot().getStatus() != SnapshotStatus.IN_PREVIEW) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_SNAPSHOT_NOT_IN_PREVIEW);
    }
    return true;
}
#end_block

#method_before
public CinderBroker getCinderBroker() {
    if (cinderBroker == null) {
        cinderBroker = new CinderBroker(getStorageDomainId(), getReturnValue().getExecuteFailedMessages());
    }
    return cinderBroker;
}
#method_after
@Override
public CinderBroker getCinderBroker() {
    if (cinderBroker == null) {
        cinderBroker = new CinderBroker(getStorageDomainId(), getReturnValue().getExecuteFailedMessages());
    }
    return cinderBroker;
}
#end_block

#method_before
protected boolean validatePciAndIdeLimit(List<VM> vmsDiskPluggedTo) {
    for (VM vm : vmsDiskPluggedTo) {
        List<VmNic> allVmInterfaces = getVmNicDao().getAllForVm(vm.getId());
        List<Disk> allVmDisks = new LinkedList<>(getOtherVmDisks(vm.getId()));
        allVmDisks.add(getNewDisk());
        if (!checkPciAndIdeLimit(vm.getOs(), vm.getClusterCompatibilityVersion(), vm.getNumOfMonitors(), allVmInterfaces, allVmDisks, VmDeviceUtils.hasVirtioScsiController(vm.getId()), VmDeviceUtils.hasWatchdog(vm.getId()), VmDeviceUtils.hasMemoryBalloon(vm.getId()), VmDeviceUtils.hasSoundDevice(vm.getId()), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean validatePciAndIdeLimit(List<VM> vmsDiskPluggedTo) {
    for (VM vm : vmsDiskPluggedTo) {
        List<VmNic> allVmInterfaces = getVmNicDao().getAllForVm(vm.getId());
        List<Disk> allVmDisks = new LinkedList<>(getOtherVmDisks(vm.getId()));
        allVmDisks.add(getNewDisk());
        if (!checkPciAndIdeLimit(vm.getOs(), vm.getCompatibilityVersion(), vm.getNumOfMonitors(), allVmInterfaces, allVmDisks, VmDeviceUtils.hasVirtioScsiController(vm.getId()), VmDeviceUtils.hasWatchdog(vm.getId()), VmDeviceUtils.hasMemoryBalloon(vm.getId()), VmDeviceUtils.hasSoundDevice(vm.getId()), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean validateVmPoolProperties() {
    if ((updateReadOnlyRequested() || updateWipeAfterDeleteRequested()) && getVm().getVmPoolId() != null)
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    return true;
}
#method_after
protected boolean validateVmPoolProperties() {
    if ((updateReadOnlyRequested() || updateWipeAfterDeleteRequested()) && getVm().getVmPoolId() != null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    }
    return true;
}
#end_block

#method_before
private boolean shouldPerformMetadataUpdate() {
    return ((getNewDisk().getDiskStorageType() == DiskStorageType.IMAGE) && (!Objects.equals(getOldDisk().getDiskAlias(), getNewDisk().getDiskAlias()) || !Objects.equals(getOldDisk().getDiskDescription(), getNewDisk().getDiskDescription())));
}
#method_after
private boolean shouldPerformMetadataUpdate() {
    return (getNewDisk().getDiskStorageType() == DiskStorageType.IMAGE) && (!Objects.equals(getOldDisk().getDiskAlias(), getNewDisk().getDiskAlias()) || !Objects.equals(getOldDisk().getDiskDescription(), getNewDisk().getDiskDescription()));
}
#end_block

#method_before
protected boolean validateAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getValidationMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getValidationMessages()) && canAddVm(getReturnValue().getValidationMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean validateAddVmCommand() {
    return areParametersLegal(getReturnValue().getValidationMessages()) && checkNumberOfMonitors() && checkSingleQxlDisplay() && checkPciAndIdeLimit(getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getValidationMessages()) && canAddVm(getReturnValue().getValidationMessages(), destStorages.values()) && hostToRunExist();
}
#end_block

#method_before
protected boolean checkSingleQxlDisplay() {
    if (!getParameters().getVmStaticData().getSingleQxlPci()) {
        return true;
    }
    return (VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion()));
}
#method_after
protected boolean checkSingleQxlDisplay() {
    if (!getParameters().getVmStaticData().getSingleQxlPci()) {
        return true;
    }
    return VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion());
}
#end_block

#method_before
public static boolean checkCpuSockets(int num_of_sockets, int cpu_per_socket, int threadsPerCpu, String compatibility_version, List<String> validationMessages) {
    boolean retValue = true;
    if (retValue && (num_of_sockets * cpu_per_socket * threadsPerCpu) > Config.<Integer>getValue(ConfigValues.MaxNumOfVmCpus, compatibility_version)) {
        validationMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_NUM_CPU.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets > Config.<Integer>getValue(ConfigValues.MaxNumOfVmSockets, compatibility_version)) {
        validationMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_NUM_SOCKETS.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket > Config.<Integer>getValue(ConfigValues.MaxNumOfCpuPerSocket, compatibility_version)) {
        validationMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && threadsPerCpu > Config.<Integer>getValue(ConfigValues.MaxNumOfThreadsPerCpu, compatibility_version)) {
        validationMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_THREADS_PER_CPU.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket < 1) {
        validationMessages.add(EngineMessage.ACTION_TYPE_FAILED_MIN_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets < 1) {
        validationMessages.add(EngineMessage.ACTION_TYPE_FAILED_MIN_NUM_SOCKETS.toString());
        retValue = false;
    }
    if (retValue && threadsPerCpu < 1) {
        validationMessages.add(EngineMessage.ACTION_TYPE_FAILED_MIN_THREADS_PER_CPU.toString());
        retValue = false;
    }
    return retValue;
}
#method_after
public static boolean checkCpuSockets(int num_of_sockets, int cpu_per_socket, int threadsPerCpu, String compatibility_version, List<String> validationMessages) {
    if ((num_of_sockets * cpu_per_socket * threadsPerCpu) > Config.<Integer>getValue(ConfigValues.MaxNumOfVmCpus, compatibility_version)) {
        validationMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_NUM_CPU.toString());
        return false;
    }
    if (num_of_sockets > Config.<Integer>getValue(ConfigValues.MaxNumOfVmSockets, compatibility_version)) {
        validationMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_NUM_SOCKETS.toString());
        return false;
    }
    if (cpu_per_socket > Config.<Integer>getValue(ConfigValues.MaxNumOfCpuPerSocket, compatibility_version)) {
        validationMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_CPU_PER_SOCKET.toString());
        return false;
    }
    if (threadsPerCpu > Config.<Integer>getValue(ConfigValues.MaxNumOfThreadsPerCpu, compatibility_version)) {
        validationMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_THREADS_PER_CPU.toString());
        return false;
    }
    if (cpu_per_socket < 1) {
        validationMessages.add(EngineMessage.ACTION_TYPE_FAILED_MIN_CPU_PER_SOCKET.toString());
        return false;
    }
    if (num_of_sockets < 1) {
        validationMessages.add(EngineMessage.ACTION_TYPE_FAILED_MIN_NUM_SOCKETS.toString());
        return false;
    }
    if (threadsPerCpu < 1) {
        validationMessages.add(EngineMessage.ACTION_TYPE_FAILED_MIN_THREADS_PER_CPU.toString());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion())).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean buildAndCheckDestStorageDomains() {
    boolean retValue = true;
    if (diskInfoDestinationMap.isEmpty()) {
        retValue = fillDestMap();
    } else {
        retValue = validateProvidedDestinations();
    }
    if (retValue && getImagesToCheckDestinationStorageDomains().size() != diskInfoDestinationMap.size()) {
        log.error("Can not find any default active domain for one of the disks of template with id '{}'", vmDisksSource.getId());
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        retValue = false;
    }
    return retValue && validateIsImagesOnDomains();
}
#method_after
protected boolean buildAndCheckDestStorageDomains() {
    boolean retValue;
    if (diskInfoDestinationMap.isEmpty()) {
        retValue = fillDestMap();
    } else {
        retValue = validateProvidedDestinations();
    }
    if (retValue && getImagesToCheckDestinationStorageDomains().size() != diskInfoDestinationMap.size()) {
        log.error("Can not find any default active domain for one of the disks of template with id '{}'", vmDisksSource.getId());
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        retValue = false;
    }
    return retValue && validateIsImagesOnDomains();
}
#end_block

#method_before
protected static boolean isLegalClusterId(Guid clusterId, List<String> reasons) {
    // check given cluster id
    Cluster cluster = DbFacade.getInstance().getClusterDao().get(clusterId);
    boolean legalClusterId = (cluster != null);
    if (!legalClusterId) {
        reasons.add(EngineError.VM_INVALID_SERVER_CLUSTER_ID.toString());
    }
    return legalClusterId;
}
#method_after
protected static boolean isLegalClusterId(Guid clusterId, List<String> reasons) {
    // check given cluster id
    Cluster cluster = DbFacade.getInstance().getClusterDao().get(clusterId);
    boolean legalClusterId = cluster != null;
    if (!legalClusterId) {
        reasons.add(EngineError.VM_INVALID_SERVER_CLUSTER_ID.toString());
    }
    return legalClusterId;
}
#end_block

#method_before
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        Collection<DiskImage> templateDisks = getImagesToCheckDestinationStorageDomains();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(templateDisks, true, false, true);
        for (DiskImage image : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, buildCreateSnapshotFromTemplateParameters(image));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new EngineException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(templateDisks);
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        Collection<DiskImage> templateDisks = getImagesToCheckDestinationStorageDomains();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(templateDisks, true, false, true);
        for (DiskImage image : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, buildCreateSnapshotFromTemplateParameters(image));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new EngineException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(templateDisks);
    }
    return true;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return getSucceeded() ? (!getReturnValue().getVdsmTaskIdList().isEmpty() ? AuditLogType.USER_ADD_VM_STARTED : AuditLogType.USER_ADD_VM) : AuditLogType.USER_FAILED_ADD_VM;
        case END_SUCCESS:
            return getSucceeded() ? AuditLogType.USER_ADD_VM_FINISHED_SUCCESS : AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
        default:
            return AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return getSucceeded() ? !getReturnValue().getVdsmTaskIdList().isEmpty() ? AuditLogType.USER_ADD_VM_STARTED : AuditLogType.USER_ADD_VM : AuditLogType.USER_FAILED_ADD_VM;
        case END_SUCCESS:
            return getSucceeded() ? AuditLogType.USER_ADD_VM_FINISHED_SUCCESS : AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
        default:
            return AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<>();
    permissionList.add(new PermissionSubject(getClusterId(), VdcObjectType.Cluster, getActionType().getActionGroup()));
    permissionList.add(new PermissionSubject(getVmTemplateId(), VdcObjectType.VmTemplate, getActionType().getActionGroup()));
    if (getVmTemplate() != null && !getVmTemplate().getDiskList().isEmpty()) {
        for (DiskImage disk : getParameters().getDiskInfoDestinationMap().values()) {
            if (disk.getStorageIds() != null && !disk.getStorageIds().isEmpty()) {
                permissionList.add(new PermissionSubject(disk.getStorageIds().get(0), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
            }
        }
    }
    addPermissionSubjectForAdminLevelProperties(permissionList);
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<>();
    permissionList.add(new PermissionSubject(getClusterId(), VdcObjectType.Cluster, getActionType().getActionGroup()));
    permissionList.add(new PermissionSubject(getVmTemplateId(), VdcObjectType.VmTemplate, getActionType().getActionGroup()));
    if (getVmTemplate() != null && !getVmTemplate().getDiskList().isEmpty()) {
        permissionList.addAll(getParameters().getDiskInfoDestinationMap().values().stream().filter(disk -> disk.getStorageIds() != null && !disk.getStorageIds().isEmpty()).map(disk -> new PermissionSubject(disk.getStorageIds().get(0), VdcObjectType.Storage, ActionGroup.CREATE_DISK)).collect(Collectors.toList()));
    }
    addPermissionSubjectForAdminLevelProperties(permissionList);
    return permissionList;
}
#end_block

#method_before
private boolean isMakeCreatorExplicitOwner() {
    return getParameters().isMakeCreatorExplicitOwner() || (getCurrentUser() != null && !checkUserAuthorization(getCurrentUser().getId(), ActionGroup.MANIPULATE_PERMISSIONS, getVmId(), VdcObjectType.VM));
}
#method_after
private boolean isMakeCreatorExplicitOwner() {
    return getParameters().isMakeCreatorExplicitOwner() || (getCurrentUser() != null && getParameters().getPoolId() == null && !checkUserAuthorization(getCurrentUser().getId(), ActionGroup.MANIPULATE_PERMISSIONS, getVmId(), VdcObjectType.VM));
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    for (DiskImage disk : diskInfoDestinationMap.values()) {
        list.add(new QuotaStorageConsumptionParameter(disk.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, disk.getStorageIds().get(0), (double) disk.getSizeInGigabytes()));
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    return diskInfoDestinationMap.values().stream().map(disk -> new QuotaStorageConsumptionParameter(disk.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, disk.getStorageIds().get(0), (double) disk.getSizeInGigabytes())).collect(Collectors.toList());
}
#end_block

#method_before
public void setIconIds(VmStatic vmStatic) {
    if (getParameters().getVmLargeIcon() != null) {
        final VmIconIdSizePair iconIds = IconUtils.ensureIconPairInDatabase(getParameters().getVmLargeIcon());
        vmStatic.setLargeIconId(iconIds.getLarge());
        vmStatic.setSmallIconId(iconIds.getSmall());
        return;
    } else {
        if (vmStatic.getLargeIconId() == null || vmStatic.getSmallIconId() == null) {
            vmStatic.setSmallIconId(getVmTemplate().getSmallIconId());
            vmStatic.setLargeIconId(getVmTemplate().getLargeIconId());
        }
    }
}
#method_after
public void setIconIds(VmStatic vmStatic) {
    if (getParameters().getVmLargeIcon() != null) {
        final VmIconIdSizePair iconIds = IconUtils.ensureIconPairInDatabase(getParameters().getVmLargeIcon());
        vmStatic.setLargeIconId(iconIds.getLarge());
        vmStatic.setSmallIconId(iconIds.getSmall());
    } else {
        if (vmStatic.getLargeIconId() == null || vmStatic.getSmallIconId() == null) {
            vmStatic.setSmallIconId(getVmTemplate().getSmallIconId());
            vmStatic.setLargeIconId(getVmTemplate().getLargeIconId());
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getDisk() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    return (validateHostedEngineDisks() && validateAllVmsForDiskAreDown()) && canRemoveDiskBasedOnStorageTypeCheck();
}
#method_after
@Override
protected boolean validate() {
    if (getDisk() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    return validateHostedEngineDisks() && validateAllVmsForDiskAreDown() && canRemoveDiskBasedOnStorageTypeCheck();
}
#end_block

#method_before
private List<VM> getVmsForDiskId() {
    if (listVms == null) {
        listVms = getVmDao().getVmsListForDisk((Guid) getParameters().getDiskId(), true);
    }
    return listVms;
}
#method_after
private List<VM> getVmsForDiskId() {
    if (listVms == null) {
        listVms = getVmDao().getVmsListForDisk(getParameters().getDiskId(), true);
    }
    return listVms;
}
#end_block

#method_before
private DiskImagesValidator createDiskImagesValidator(DiskImage disk) {
    return new DiskImagesValidator(Arrays.asList(disk));
}
#method_after
private DiskImagesValidator createDiskImagesValidator(DiskImage disk) {
    return new DiskImagesValidator(Collections.singletonList(disk));
}
#end_block

#method_before
private boolean canRemoveVmImageDisk() {
    if (!listVms.isEmpty()) {
        Guid storagePoolId = listVms.get(0).getStoragePoolId();
        StoragePool sp = getStoragePoolDao().get(storagePoolId);
        if (!validate(new StoragePoolValidator(sp).isUp())) {
            return false;
        }
        List<DiskImage> diskList = ImagesHandler.filterImageDisks(Arrays.asList(getDisk()), true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskList);
        if (!validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    for (VM vm : listVms) {
        if (!validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId())) || !validate(snapshotsValidator.vmNotInPreview(vm.getId()))) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean canRemoveVmImageDisk() {
    if (!listVms.isEmpty()) {
        Guid storagePoolId = listVms.get(0).getStoragePoolId();
        StoragePool sp = getStoragePoolDao().get(storagePoolId);
        if (!validate(new StoragePoolValidator(sp).isUp())) {
            return false;
        }
        List<DiskImage> diskList = ImagesHandler.filterImageDisks(Collections.singletonList(getDisk()), true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskList);
        if (!validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    for (VM vm : listVms) {
        if (!validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId())) || !validate(snapshotsValidator.vmNotInPreview(vm.getId()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean removeVm() {
    final List<DiskImage> diskImages = ImagesHandler.filterImageDisks(getVm().getDiskList(), true, false, true);
    final List<LunDisk> lunDisks = ImagesHandler.filterDiskBasedOnLuns(getVm().getDiskMap().values(), false);
    for (VmNic nic : getInterfaces()) {
        new ExternalNetworkManager(nic).deallocateIfExternal();
    }
    removeMemoryVolumes();
    TransactionSupport.executeInNewTransaction(() -> {
        removeVmFromDb();
        if (getParameters().isRemoveDisks()) {
            for (DiskImage image : diskImages) {
                getCompensationContext().snapshotEntityStatus(image.getImage(), ImageStatus.ILLEGAL);
                ImagesHandler.updateImageStatus(image.getImage().getId(), ImageStatus.LOCKED);
            }
            for (LunDisk lunDisk : lunDisks) {
                ImagesHandler.removeLunDisk(lunDisk);
            }
            getCompensationContext().stateChanged();
        } else {
            for (DiskImage image : diskImages) {
                getImageDao().updateImageVmSnapshotId(image.getImageId(), null);
            }
        }
        return null;
    });
    Collection<DiskImage> unremovedDisks = Collections.emptyList();
    if (getParameters().isRemoveDisks()) {
        if (!diskImages.isEmpty()) {
            unremovedDisks = (Collection<DiskImage>) removeVmImages(diskImages).getActionReturnValue();
        }
        unremovedDisks.addAll(removeCinderDisks());
        if (!unremovedDisks.isEmpty()) {
            processUnremovedDisks(unremovedDisks);
            return false;
        }
    }
    vmDeleted.fire(getVmId());
    return true;
}
#method_after
private boolean removeVm() {
    final List<DiskImage> diskImages = ImagesHandler.filterImageDisks(getVm().getDiskList(), true, false, true);
    final List<LunDisk> lunDisks = ImagesHandler.filterDiskBasedOnLuns(getVm().getDiskMap().values(), false);
    for (VmNic nic : getInterfaces()) {
        new ExternalNetworkManager(nic).deallocateIfExternal();
    }
    removeMemoryVolumes();
    TransactionSupport.executeInNewTransaction(() -> {
        removeVmFromDb();
        if (getParameters().isRemoveDisks()) {
            for (DiskImage image : diskImages) {
                getCompensationContext().snapshotEntityStatus(image.getImage(), ImageStatus.ILLEGAL);
                ImagesHandler.updateImageStatus(image.getImage().getId(), ImageStatus.LOCKED);
            }
            for (LunDisk lunDisk : lunDisks) {
                ImagesHandler.removeLunDisk(lunDisk);
            }
            getCompensationContext().stateChanged();
        } else {
            for (DiskImage image : diskImages) {
                getImageDao().updateImageVmSnapshotId(image.getImageId(), null);
            }
        }
        return null;
    });
    Collection<DiskImage> unremovedDisks = Collections.emptyList();
    if (getParameters().isRemoveDisks()) {
        if (!diskImages.isEmpty()) {
            unremovedDisks = removeVmImages(diskImages).getActionReturnValue();
        }
        unremovedDisks.addAll(removeCinderDisks());
        if (!unremovedDisks.isEmpty()) {
            processUnremovedDisks(unremovedDisks);
            return false;
        }
    }
    vmDeleted.fire(getVmId());
    return true;
}
#end_block

#method_before
private void processUnremovedDisks(Collection<? extends DiskImage> diskImages) {
    List<String> disksLeftInVm = new ArrayList<>();
    for (DiskImage diskImage : diskImages) {
        disksLeftInVm.add(diskImage.getDiskAlias());
    }
    addCustomValue("DisksNames", StringUtils.join(disksLeftInVm, ","));
}
#method_after
private void processUnremovedDisks(Collection<? extends DiskImage> diskImages) {
    addCustomValue("DisksNames", diskImages.stream().map(DiskImage::getDiskAlias).collect(Collectors.joining(",")));
}
#end_block

#method_before
private void restoreVmConfigFromSnapshot() {
    getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(getSnapshotDao().getId(getVm().getId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED), SnapshotStatus.OK);
    snapshotsManager.attempToRestoreVmConfigurationFromSnapshot(getVm(), getDstSnapshot(), getSnapshotDao().getId(getVm().getId(), SnapshotType.ACTIVE), getImagesToPreview(), getCompensationContext(), getVm().getClusterCompatibilityVersion(), getCurrentUser());
}
#method_after
private void restoreVmConfigFromSnapshot() {
    getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(getSnapshotDao().getId(getVm().getId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED), SnapshotStatus.OK);
    snapshotsManager.attempToRestoreVmConfigurationFromSnapshot(getVm(), getDstSnapshot(), getSnapshotDao().getId(getVm().getId(), SnapshotType.ACTIVE), getImagesToPreview(), getCompensationContext(), getVm().getCompatibilityVersion(), getCurrentUser());
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = getParameters().isRestoreMemory() && FeatureSupported.memorySnapshot(getVm().getClusterCompatibilityVersion()) && FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getClusterCompatibilityVersion());
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(previousActiveSnapshot);
        getSnapshotDao().remove(previousActiveSnapshotId);
        snapshotsManager.addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), previousActiveSnapshot.getMemoryVolume(), getCompensationContext());
        snapshotsManager.addActiveSnapshot(newActiveSnapshotId, getVm(), restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, images, getCompensationContext());
        // being executed in the same transaction so we can restore the vm config and end the command.
        if (!filteredImages.isEmpty()) {
            getCompensationContext().stateChanged();
        } else {
            getVmStaticDao().incrementDbGeneration(getVm().getId());
            restoreVmConfigFromSnapshot();
        }
        return null;
    });
    if (!filteredImages.isEmpty()) {
        VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = getParameters().isRestoreMemory() && FeatureSupported.memorySnapshot(getVm().getCompatibilityVersion()) && FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getCompatibilityVersion());
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(previousActiveSnapshot);
        getSnapshotDao().remove(previousActiveSnapshotId);
        snapshotsManager.addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), previousActiveSnapshot.getMemoryVolume(), getCompensationContext());
        snapshotsManager.addActiveSnapshot(newActiveSnapshotId, getVm(), restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, images, getCompensationContext());
        // being executed in the same transaction so we can restore the vm config and end the command.
        if (!filteredImages.isEmpty()) {
            getCompensationContext().stateChanged();
        } else {
            getVmStaticDao().incrementDbGeneration(getVm().getId());
            restoreVmConfigFromSnapshot();
        }
        return null;
    });
    if (!filteredImages.isEmpty()) {
        VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    }
    setSucceeded(true);
}
#end_block

#method_before
private void markExpiredCommandAsFailure(Guid cmdId) {
    CommandEntity cmdEntity = coco.getCommandEntity(cmdId);
    if (cmdEntity != null && cmdEntity.getCommandStatus() == CommandStatus.ACTIVE) {
        Calendar cal = Calendar.getInstance();
        Integer cmdLifeTimeInMin = cmdEntity.getCommandParameters().getLifeInMinutes();
        cal.add(Calendar.MINUTE, (-1) * (cmdLifeTimeInMin == null ? Config.<Integer>getValue(ConfigValues.CoCoLifeInMinutes) : cmdLifeTimeInMin));
        if (cmdEntity.getCreatedAt().getTime() < cal.getTime().getTime()) {
            log.warn("Marking expired command as Failed: command '{} ({})' that started at '{}' has been marked as Failed.", cmdEntity.getCommandType(), cmdEntity.getId(), cmdEntity.getCreatedAt());
            coco.updateCommandStatus(cmdId, CommandStatus.FAILED);
        }
    }
}
#method_after
private void markExpiredCommandAsFailure(Guid cmdId) {
    CommandEntity cmdEntity = coco.getCommandEntity(cmdId);
    if (cmdEntity != null && cmdEntity.getCommandStatus() == CommandStatus.ACTIVE) {
        Calendar cal = Calendar.getInstance();
        Integer cmdLifeTimeInMin = cmdEntity.getCommandParameters().getLifeInMinutes();
        cal.add(Calendar.MINUTE, -1 * (cmdLifeTimeInMin == null ? Config.<Integer>getValue(ConfigValues.CoCoLifeInMinutes) : cmdLifeTimeInMin));
        if (cmdEntity.getCreatedAt().getTime() < cal.getTime().getTime()) {
            log.warn("Marking expired command as Failed: command '{} ({})' that started at '{}' has been marked as Failed.", cmdEntity.getCommandType(), cmdEntity.getId(), cmdEntity.getCreatedAt());
            coco.updateCommandStatus(cmdId, CommandStatus.FAILED);
        }
    }
}
#end_block

#method_before
private VdcReturnValueBase executeCommand(final CommandBase<?> command, final CommandContext cmdContext) {
    CommandCallback callback = command.getCallback();
    VdcReturnValueBase result = BackendUtils.getBackendCommandObjectsHandler(log).runAction(command, cmdContext != null ? cmdContext.getExecutionContext() : null);
    updateCommand(command, result);
    if (callback != null) {
        callback.executed(result);
    }
    return result;
}
#method_after
private VdcReturnValueBase executeCommand(final CommandBase<?> command, final CommandContext cmdContext) {
    VdcReturnValueBase result = BackendUtils.getBackendCommandObjectsHandler(log).runAction(command, cmdContext != null ? cmdContext.getExecutionContext() : null);
    updateCommand(command, result);
    return result;
}
#end_block

#method_before
@Override
protected void init(T parameters) {
    super.init(parameters);
    // Images must be specified in parameters and belong to a single Disk;
    // Otherwise, we'll fail on validate.
    DiskImage representativeImage = getRepresentativeImage();
    if (representativeImage == null) {
        return;
    }
    setImage(representativeImage);
    setStorageDomainId(representativeImage.getStorageIds().get(0));
    getParameters().setUseCinderCommandCallback(!ImagesHandler.filterDisksBasedOnCinder(getImages()).isEmpty());
    if (!Guid.isNullOrEmpty(getParameters().getContainerId())) {
        setVmId(getParameters().getContainerId());
    } else {
        List<VM> listVms = getVmDao().getVmsListForDisk(representativeImage.getId(), false);
        if (!listVms.isEmpty()) {
            VM vm = listVms.get(0);
            setVm(vm);
        }
    }
    // thus initTaskHandlers() can't yet tell if this is a live or cold merge.
    if (isLiveMerge()) {
        clearTaskHandlers();
    }
}
#method_after
@Override
protected void init(T parameters) {
    super.init(parameters);
    // Images must be specified in parameters and belong to a single Disk;
    // Otherwise, we'll fail on validate.
    DiskImage representativeImage = getRepresentativeImage();
    if (representativeImage != null) {
        setImage(representativeImage);
        getParameters().setStorageDomainId(representativeImage.getStorageIds().get(0));
        getParameters().setDiskAlias(representativeImage.getDiskAlias());
        getParameters().setUseCinderCommandCallback(!ImagesHandler.filterDisksBasedOnCinder(getImages()).isEmpty());
        if (Guid.isNullOrEmpty(getParameters().getContainerId())) {
            List<VM> listVms = getVmDao().getVmsListForDisk(representativeImage.getId(), false);
            if (!listVms.isEmpty()) {
                VM vm = listVms.get(0);
                setVm(vm);
                getParameters().setContainerId(vm.getId());
            }
        }
    }
    setVmId(getParameters().getContainerId());
    setStorageDomainId(getParameters().getStorageDomainId());
    // thus initTaskHandlers() can't yet tell if this is a live or cold merge.
    if (isLiveMerge()) {
        clearTaskHandlers();
    }
}
#end_block

#method_before
protected boolean isLiveMergeSupported() {
    return FeatureSupported.liveMerge(getVm().getClusterCompatibilityVersion());
}
#method_after
protected boolean isLiveMergeSupported() {
    return FeatureSupported.liveMerge(getVm().getCompatibilityVersion());
}
#end_block

#method_before
private void addAuditLogCustomValues() {
    this.addCustomValue("DiskAlias", getDiskImage().getDiskAlias());
    this.addCustomValue("Snapshots", StringUtils.join(getSnapshotsNames(), ", "));
}
#method_after
private void addAuditLogCustomValues() {
    this.addCustomValue("DiskAlias", getParameters().getDiskAlias());
    this.addCustomValue("Snapshots", StringUtils.join(getSnapshotsNames(), ", "));
}
#end_block

#method_before
protected DiskImage getRepresentativeImage() {
    return getImages().get(0);
}
#method_after
protected DiskImage getRepresentativeImage() {
    if (!getImages().isEmpty()) {
        return getImages().get(0);
    }
    return null;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    addAuditLogCustomValues();
    switch(getActionState()) {
        case EXECUTE:
            if (!hasTaskHandlers()) {
                return getParameters().getTaskGroupSuccess() ? AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_SUCCESS : AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_FAILURE;
            }
            if (isFirstTaskHandler() && getSucceeded()) {
                return AuditLogType.USER_REMOVE_DISK_SNAPSHOT;
            }
            if (!getParameters().getTaskGroupSuccess()) {
                return AuditLogType.USER_FAILED_REMOVE_DISK_SNAPSHOT;
            }
            break;
        case END_SUCCESS:
            return AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_SUCCESS;
        case END_FAILURE:
            return AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_FAILURE;
    }
    return AuditLogType.UNASSIGNED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    addAuditLogCustomValues();
    switch(getActionState()) {
        case EXECUTE:
            if (!hasTaskHandlers() && !getParameters().isUseCinderCommandCallback()) {
                return getParameters().getTaskGroupSuccess() ? AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_SUCCESS : AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_FAILURE;
            }
            if (isFirstTaskHandler() && getSucceeded()) {
                return AuditLogType.USER_REMOVE_DISK_SNAPSHOT;
            }
            if (!getParameters().getTaskGroupSuccess()) {
                return AuditLogType.USER_FAILED_REMOVE_DISK_SNAPSHOT;
            }
            break;
        case END_SUCCESS:
            return AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_SUCCESS;
        case END_FAILURE:
            return AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_FAILURE;
    }
    return AuditLogType.UNASSIGNED;
}
#end_block

#method_before
protected boolean validateInputs() {
    return super.validateInputs();
}
#method_after
@Override
protected boolean validateInputs() {
    return super.validateInputs();
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!isVmExist()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Arrays.asList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!isVmExist()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Collections.singletonList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#end_block

#method_before
protected boolean checkIfLunDiskCanBeAdded(DiskValidator diskValidator) {
    LunDisk lunDisk = ((LunDisk) getParameters().getDiskInfo());
    LUNs lun = lunDisk.getLun();
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (StorageServerConnections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getIqn()) || StringUtils.isEmpty(conn.getConnection()) || StringUtils.isEmpty(conn.getPort())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
        default:
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUNId()) != null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    if (getVm() != null && !(isVmNotLocked() && isVmNotInPreviewSnapshot())) {
        return false;
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    if (getVds() != null) {
        lunFromStorage = getLunDisk(lun, getVds());
        if (lunFromStorage == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_INVALID);
        }
    }
    if (!validate(diskValidator.isUsingScsiReservationValid(getVm(), lunDisk))) {
        return false;
    }
    return true;
}
#method_after
protected boolean checkIfLunDiskCanBeAdded(DiskValidator diskValidator) {
    LunDisk lunDisk = (LunDisk) getParameters().getDiskInfo();
    LUNs lun = lunDisk.getLun();
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (StorageServerConnections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getIqn()) || StringUtils.isEmpty(conn.getConnection()) || StringUtils.isEmpty(conn.getPort())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
        default:
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUNId()) != null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    if (getVm() != null && !(isVmNotLocked() && isVmNotInPreviewSnapshot())) {
        return false;
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    if (getVds() != null) {
        lunFromStorage = getLunDisk(lun, getVds());
        if (lunFromStorage == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_INVALID);
        }
    }
    if (!validate(diskValidator.isUsingScsiReservationValid(getVm(), lunDisk))) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (useCallback()) {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    } else {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        getCompensationContext().snapshotNewEntity(addManagedDeviceForDisk(getParameters().getDiskInfo().getId()));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (isExecutedAsChildCommand()) {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    } else {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    ArrayList<Guid> taskList = isExecutedAsChildCommand() ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
    taskList.addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        getCompensationContext().snapshotNewEntity(addManagedDeviceForDisk(getParameters().getDiskInfo().getId()));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
public void executeCommand() {
    CinderDisk disk = getDisk();
    lockDisk();
    VM vm = getVmForNonShareableDiskImage(disk);
    // so no lock is required.
    if (getParameters().isLockVM() && vm != null) {
        getParameters().setVmId(vm.getId());
        lockVmSnapshotsWithWait(vm);
    }
    getParameters().setRemovedVolume(getDisk());
    getParameters().setStorageDomainId(getDisk().getStorageIds().get(0));
    getParameters().setUpdateSnapshot(true);
    if (getDisk().getImageStatus() == ImageStatus.ILLEGAL) {
        handleRemoveCinderVolumesForIllegal();
        setCommandStatus(CommandStatus.SUCCEEDED);
        setSucceeded(true);
        return;
    }
    // Get the first volume to delete from.
    CinderDisk parentVolume = (CinderDisk) getDiskImageDao().getSnapshotById(disk.getId());
    initCinderDiskVolumesParametersList(parentVolume);
    if (!removeCinderVolume(0, getDisk().getStorageIds().get(0))) {
        getImageDao().updateStatusOfImagesByImageGroupId(getDisk().getId(), ImageStatus.ILLEGAL);
        setSucceeded(false);
        return;
    }
    persistCommand(getParameters().getParentCommand(), true);
    getReturnValue().setActionReturnValue(disk.getId());
    setSucceeded(true);
}
#method_after
@Override
public void executeCommand() {
    CinderDisk disk = getDisk();
    lockDisk();
    VM vm = getVmForNonShareableDiskImage(disk);
    // so no lock is required.
    if (getParameters().isLockVM() && vm != null) {
        getParameters().setVmId(vm.getId());
        lockVmSnapshotsWithWait(vm);
    }
    getParameters().setRemovedVolume(getDisk());
    getParameters().setStorageDomainId(getDisk().getStorageIds().get(0));
    getParameters().setUpdateSnapshot(true);
    if (getDisk().getImageStatus() == ImageStatus.ILLEGAL) {
        handleRemoveCinderVolumesForIllegal();
        setCommandStatus(CommandStatus.SUCCEEDED);
        setSucceeded(true);
        return;
    }
    // Get the first volume to delete from.
    CinderDisk parentVolume = (CinderDisk) getDiskImageDao().getSnapshotById(disk.getId());
    initCinderDiskVolumesParametersList(parentVolume);
    if (!removeCinderVolume(0, getDisk().getStorageIds().get(0))) {
        getImageDao().updateStatusOfImagesByImageGroupId(getDisk().getId(), ImageStatus.ILLEGAL);
        setSucceeded(false);
        return;
    }
    persistCommand(getParameters().getParentCommand(), true);
    getReturnValue().setActionReturnValue(disk.getId());
    setSucceeded(true);
}
#end_block

#method_before
private void freeVmSnapshotsWithWait() {
    if (getParameters().getVmId() != null) {
        EngineLock snapshotsEngineLock = new EngineLock();
        Map<String, Pair<String, String>> snapshotsExlusiveLockMap = Collections.singletonMap(getParameters().getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_SNAPSHOTS, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
        snapshotsEngineLock.setExclusiveLocks(snapshotsExlusiveLockMap);
        getLockManager().releaseLock(snapshotsEngineLock);
    }
}
#method_after
private void freeVmSnapshotsWithWait() {
    if (getParameters().getVmId() != null) {
        EngineLock snapshotsEngineLock = new EngineLock();
        Map<String, Pair<String, String>> snapshotsExclusiveLockMap = Collections.singletonMap(getParameters().getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_SNAPSHOTS, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
        snapshotsEngineLock.setExclusiveLocks(snapshotsExclusiveLockMap);
        getLockManager().releaseLock(snapshotsEngineLock);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (!getVm().isDown()) {
        if (FeatureSupported.liveMerge(getVm().getClusterCompatibilityVersion())) {
            if (!getVm().isQualifiedForSnapshotMerge()) {
                log.error("Cannot remove VM snapshot. Vm is not Down, Up or Paused");
                throw new EngineException(EngineError.VM_NOT_QUALIFIED_FOR_SNAPSHOT_MERGE);
            } else if (getVm().getRunOnVds() == null || !getVdsDao().get(getVm().getRunOnVds()).getLiveMergeSupport()) {
                log.error("Cannot remove VM snapshot. The host on which VM is running does not support Live Merge");
                throw new EngineException(EngineError.VM_HOST_CANNOT_LIVE_MERGE);
            }
        } else {
            log.error("Cannot remove VM snapshot. Vm is not Down and cluster version does not support Live Merge");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
    }
    final Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
    boolean snapshotHasImages = hasImages();
    boolean removeSnapshotMemory = isMemoryVolumeRemoveable(snapshot.getMemoryVolume());
    // No need for locking, VDSM tasks, and all that jazz.
    if (!snapshotHasImages && !removeSnapshotMemory) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
        setSucceeded(true);
        return;
    }
    lockSnapshot(snapshot);
    freeLock();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    boolean useTaskManagerToRemoveMemory = false;
    if (snapshotHasImages) {
        removeImages();
        if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDiskLive) {
            persistCommand(getParameters().getParentCommand(), true);
            useTaskManagerToRemoveMemory = true;
        }
    }
    if (removeSnapshotMemory) {
        removeMemory(snapshot, useTaskManagerToRemoveMemory);
        if (!snapshotHasImages) {
            // no async tasks - ending command manually
            endVmCommand();
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (!getVm().isDown()) {
        if (FeatureSupported.liveMerge(getVm().getCompatibilityVersion())) {
            if (!getVm().isQualifiedForSnapshotMerge()) {
                log.error("Cannot remove VM snapshot. Vm is not Down, Up or Paused");
                throw new EngineException(EngineError.VM_NOT_QUALIFIED_FOR_SNAPSHOT_MERGE);
            } else if (getVm().getRunOnVds() == null || !getVdsDao().get(getVm().getRunOnVds()).getLiveMergeSupport()) {
                log.error("Cannot remove VM snapshot. The host on which VM is running does not support Live Merge");
                throw new EngineException(EngineError.VM_HOST_CANNOT_LIVE_MERGE);
            }
        } else {
            log.error("Cannot remove VM snapshot. Vm is not Down and cluster version does not support Live Merge");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
    }
    final Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
    boolean snapshotHasImages = hasImages();
    boolean removeSnapshotMemory = isMemoryVolumeRemoveable(snapshot.getMemoryVolume());
    // No need for locking, VDSM tasks, and all that jazz.
    if (!snapshotHasImages && !removeSnapshotMemory) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
        setSucceeded(true);
        return;
    }
    lockSnapshot(snapshot);
    freeLock();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    boolean useTaskManagerToRemoveMemory = false;
    if (snapshotHasImages) {
        removeImages();
        if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDiskLive) {
            persistCommand(getParameters().getParentCommand(), true);
            useTaskManagerToRemoveMemory = true;
        }
    }
    if (removeSnapshotMemory) {
        removeMemory(snapshot, useTaskManagerToRemoveMemory);
        if (!snapshotHasImages) {
            // no async tasks - ending command manually
            endVmCommand();
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    initializeObjectState();
    if (getParameters().getTaskGroupSuccess()) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
    } else {
        List<String> failedToRemoveDisks = new ArrayList<>();
        Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
        for (VdcActionParametersBase parameters : getParameters().getImagesParameters()) {
            ImagesContainterParametersBase imagesParams = (parameters instanceof ImagesContainterParametersBase ? (ImagesContainterParametersBase) parameters : null);
            if (imagesParams == null) {
                // instances of ImagesContainterParametersBase objects.
                continue;
            }
            if (imagesParams.getTaskGroupSuccess()) {
                snapshot = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snapshot, imagesParams.getImageId());
            } else {
                log.error("Could not delete image '{}' from snapshot '{}'", imagesParams.getImageId(), getParameters().getSnapshotId());
                DiskImage diskImage = getDiskImageDao().getSnapshotById(imagesParams.getImageId());
                failedToRemoveDisks.add(diskImage.getDiskAlias());
            }
        }
        // Remove memory volume and update the dao.
        // Note: on failure, we can treat memory volume deletion as deleting an image
        // and remove it from the snapshot entity (rollback isn't applicable).
        snapshot.setMemoryVolume("");
        getSnapshotDao().update(snapshot);
        if (!failedToRemoveDisks.isEmpty()) {
            addCustomValue("DiskAliases", StringUtils.join(failedToRemoveDisks, ", "));
            auditLogDirector.log(this, AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE_PARTIAL_SNAPSHOT);
        }
        getSnapshotDao().updateStatus(getParameters().getSnapshotId(), SnapshotStatus.OK);
    }
    super.endVmCommand();
}
#method_after
@Override
protected void endVmCommand() {
    initializeObjectState();
    if (getParameters().getTaskGroupSuccess()) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
    } else {
        List<String> failedToRemoveDisks = new ArrayList<>();
        Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
        for (VdcActionParametersBase parameters : getParameters().getImagesParameters()) {
            ImagesContainterParametersBase imagesParams = parameters instanceof ImagesContainterParametersBase ? (ImagesContainterParametersBase) parameters : null;
            if (imagesParams == null) {
                // instances of ImagesContainterParametersBase objects.
                continue;
            }
            if (imagesParams.getTaskGroupSuccess()) {
                snapshot = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snapshot, imagesParams.getImageId());
            } else {
                log.error("Could not delete image '{}' from snapshot '{}'", imagesParams.getImageId(), getParameters().getSnapshotId());
                DiskImage diskImage = getDiskImageDao().getSnapshotById(imagesParams.getImageId());
                failedToRemoveDisks.add(diskImage.getDiskAlias());
            }
        }
        // Remove memory volume and update the dao.
        // Note: on failure, we can treat memory volume deletion as deleting an image
        // and remove it from the snapshot entity (rollback isn't applicable).
        snapshot.setMemoryVolume("");
        getSnapshotDao().update(snapshot);
        if (!failedToRemoveDisks.isEmpty()) {
            addCustomValue("DiskAliases", StringUtils.join(failedToRemoveDisks, ", "));
            auditLogDirector.log(this, AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE_PARTIAL_SNAPSHOT);
        }
        getSnapshotDao().updateStatus(getParameters().getSnapshotId(), SnapshotStatus.OK);
    }
    super.endVmCommand();
}
#end_block

#method_before
@Override
protected boolean validate() {
    initializeObjectState();
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = createVmValidator(getVm());
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validateVmNotDuringSnapshot() || !validateVmNotInPreview() || !validateSnapshotExists() || !validateSnapshotType() || (FeatureSupported.liveMerge(getVm().getClusterCompatibilityVersion()) ? (!validate(vmValidator.vmQualifiedForSnapshotMerge()) || !validate(vmValidator.vmHostCanLiveMerge())) : !validate(vmValidator.vmDown())) || !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    if (hasImages()) {
        // Check the VM's images
        if (!validateImages()) {
            return false;
        }
        // check that we are not deleting the template
        if (!validateImageNotInTemplate()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_IMAGE_TEMPLATE);
        }
        if (!validateStorageDomains()) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    initializeObjectState();
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = createVmValidator(getVm());
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validateVmNotDuringSnapshot() || !validateVmNotInPreview() || !validateSnapshotExists() || !validateSnapshotType() || (FeatureSupported.liveMerge(getVm().getCompatibilityVersion()) ? (!validate(vmValidator.vmQualifiedForSnapshotMerge()) || !validate(vmValidator.vmHostCanLiveMerge())) : !validate(vmValidator.vmDown())) || !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    if (hasImages()) {
        // Check the VM's images
        if (!validateImages()) {
            return false;
        }
        // check that we are not deleting the template
        if (!validateImageNotInTemplate()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_IMAGE_TEMPLATE);
        }
        if (!validateStorageDomains()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean validateSnapshotType() {
    Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
    return validate(createSnapshotValidator().snapshotTypeSupported(snapshot, Collections.singletonList(Snapshot.SnapshotType.REGULAR)));
}
#method_after
protected boolean validateSnapshotType() {
    Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
    return validate(createSnapshotValidator().isRegularSnapshot(snapshot));
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    revertCinderVolume((CinderDisk) getDestinationDiskImage());
    if (isDestinationImageExists(getDestinationDiskImage().getId()) && (isImageSnapshot(getDestinationDiskImage()))) {
        updateLastModifiedInParent(getDestinationDiskImage().getParentId());
    }
    super.endWithFailure();
    if (getParameters().getSnapshotType().equals(Snapshot.SnapshotType.STATELESS)) {
        updateOldImageAsActive(Snapshot.SnapshotType.ACTIVE, true);
    }
}
#method_after
@Override
protected void endWithFailure() {
    revertCinderVolume((CinderDisk) getDestinationDiskImage());
    if (isDestinationImageExists(getDestinationDiskImage().getId()) && isImageSnapshot(getDestinationDiskImage())) {
        updateLastModifiedInParent(getDestinationDiskImage().getParentId());
    }
    super.endWithFailure();
    if (getParameters().getSnapshotType().equals(Snapshot.SnapshotType.STATELESS)) {
        updateOldImageAsActive(Snapshot.SnapshotType.ACTIVE, true);
    }
}
#end_block

#method_before
@Override
protected void init() {
    T parameters = getParameters();
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (VmDeviceUtils.shouldOverrideSoundDevice(getParameters().getMasterVm(), getVm().getCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        VmHandler.updateDefaultTimeZone(parameterMasterVm);
        VmHandler.autoSelectUsbPolicy(getParameters().getMasterVm(), getCluster());
        VmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#method_after
@Override
protected void init() {
    T parameters = getParameters();
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (VmDeviceUtils.shouldOverrideSoundDevice(getParameters().getMasterVm(), getVm() == null ? CompatibilityVersionUtils.getEffective(parameterMasterVm, getCluster()) : getVm().getCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        VmHandler.updateDefaultTimeZone(parameterMasterVm);
        VmHandler.autoSelectUsbPolicy(getParameters().getMasterVm(), getCluster());
        VmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#end_block

#method_before
protected void separateCustomProperties(VmStatic parameterMasterVm) {
    if (getCluster() != null) {
        // Parses the custom properties field that was filled by frontend to
        // predefined and user defined fields
        VmPropertiesUtils.getInstance().separateCustomPropertiesToUserAndPredefined(getVm().getCompatibilityVersion(), parameterMasterVm);
    }
}
#method_after
protected void separateCustomProperties(VmStatic parameterMasterVm) {
    if (getCluster() != null) {
        // Parses the custom properties field that was filled by frontend to
        // predefined and user defined fields
        VmPropertiesUtils.getInstance().separateCustomPropertiesToUserAndPredefined(getVm() == null ? CompatibilityVersionUtils.getEffective(parameterMasterVm, getCluster()) : getVm().getCompatibilityVersion(), parameterMasterVm);
    }
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVm().getCompatibilityVersion(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the display type is supported
    Guid srcId = isVmInDb ? getVmId() : VmTemplateHandler.BLANK_VM_TEMPLATE_ID;
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getMasterVm().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(srcId), getParameters().getGraphicsDevices()), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getValidationMessages(), getVm().getCompatibilityVersion())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getValidationMessages(), getVm().getCompatibilityVersion())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVm().getCompatibilityVersion())) {
        return failValidation(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVm().getCompatibilityVersion())).isValid())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    if (!VmPropertiesUtils.getInstance().validateVmProperties(getVm().getCompatibilityVersion(), getParameters().getMasterVm().getCustomProperties(), getReturnValue().getValidationMessages())) {
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getThreadsPerCpu(), getVm().getCompatibilityVersion().toString(), getReturnValue().getValidationMessages());
}
#method_after
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVm().getCompatibilityVersion(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the display type is supported
    Guid srcId = isVmInDb ? getVmId() : VmTemplateHandler.BLANK_VM_TEMPLATE_ID;
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getMasterVm().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(srcId), getParameters().getGraphicsDevices()), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getValidationMessages(), getVm().getCompatibilityVersion())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getValidationMessages(), getVm().getCompatibilityVersion())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVm().getCompatibilityVersion())) {
        return failValidation(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVm().getCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    if (!VmPropertiesUtils.getInstance().validateVmProperties(getVm().getCompatibilityVersion(), getParameters().getMasterVm().getCustomProperties(), getReturnValue().getValidationMessages())) {
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getThreadsPerCpu(), getVm().getCompatibilityVersion().toString(), getReturnValue().getValidationMessages());
}
#end_block

#method_before
protected boolean validateSpaceRequirements() {
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    List<DiskImage> disksList = ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false, true);
    List<DiskImage> disksListForStorageChecks = createDiskDummiesForSpaceValidations(disksList);
    MultipleStorageDomainsValidator multipleSdValidator = getStorageDomainsValidator(getVm().getStoragePoolId(), getStorageGuidSet());
    return (validate(multipleSdValidator.allDomainsWithinThresholds()) && validate(multipleSdValidator.allDomainsHaveSpaceForClonedDisks(disksListForStorageChecks)));
}
#method_after
protected boolean validateSpaceRequirements() {
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    List<DiskImage> disksList = ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false, true);
    List<DiskImage> disksListForStorageChecks = createDiskDummiesForSpaceValidations(disksList);
    MultipleStorageDomainsValidator multipleSdValidator = getStorageDomainsValidator(getVm().getStoragePoolId(), getStorageGuidSet());
    return validate(multipleSdValidator.allDomainsWithinThresholds()) && validate(multipleSdValidator.allDomainsHaveSpaceForClonedDisks(disksListForStorageChecks));
}
#end_block

#method_before
private Set<Guid> getStorageGuidSet() {
    Set<Guid> destImageDomains = new HashSet<>();
    for (DiskImage diskImage : diskInfoDestinationMap.values()) {
        destImageDomains.add(diskImage.getStorageIds().get(0));
    }
    return destImageDomains;
}
#method_after
private Set<Guid> getStorageGuidSet() {
    return diskInfoDestinationMap.values().stream().map(d -> d.getStorageIds().get(0)).collect(Collectors.toSet());
}
#end_block

#method_before
protected void addVmTemplateImage(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, DiskImage diskImage) {
    // The return value of this action is the 'copyImage' task GUID:
    VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, buildChildCommandParameters(diskImage, Guid.newGuid()), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!retValue.getSucceeded()) {
        throw new EngineException(retValue.getFault().getError(), retValue.getFault().getMessage());
    }
    getReturnValue().getVdsmTaskIdList().addAll(retValue.getInternalVdsmTaskIdList());
    DiskImage newImage = (DiskImage) retValue.getActionReturnValue();
    srcDeviceIdToTargetDeviceIdMapping.put(diskImage.getId(), newImage.getId());
}
#method_after
protected void addVmTemplateImage(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, DiskImage diskImage) {
    // The return value of this action is the 'copyImage' task GUID:
    VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, buildChildCommandParameters(diskImage, Guid.newGuid()), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!retValue.getSucceeded()) {
        throw new EngineException(retValue.getFault().getError(), retValue.getFault().getMessage());
    }
    getReturnValue().getVdsmTaskIdList().addAll(retValue.getInternalVdsmTaskIdList());
    DiskImage newImage = retValue.getActionReturnValue();
    srcDeviceIdToTargetDeviceIdMapping.put(diskImage.getId(), newImage.getId());
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    for (DiskImage disk : getVm().getDiskList()) {
        list.add(new QuotaStorageConsumptionParameter(getQuotaIdForDisk(disk), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, disk.getStorageIds().get(0), (double) disk.getSizeInGigabytes()));
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    return getVm().getDiskList().stream().map(disk -> new QuotaStorageConsumptionParameter(getQuotaIdForDisk(disk), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, disk.getStorageIds().get(0), (double) disk.getSizeInGigabytes())).collect(Collectors.toList());
}
#end_block

#method_before
public Set<Guid> keySet() {
    initializeCache();
    return commandMap.keySet();
}
#method_after
@Override
public Set<Guid> keySet() {
    initializeCache();
    return commandMap.keySet();
}
#end_block

#method_before
public void removeAllCommandsBeforeDate(DateTime cutoff) {
    DbFacade.getInstance().getCommandEntityDao().removeAllBeforeDate(cutoff);
    cacheInitialized = false;
    initializeCache();
}
#method_after
@Override
public void removeAllCommandsBeforeDate(DateTime cutoff) {
    DbFacade.getInstance().getCommandEntityDao().removeAllBeforeDate(cutoff);
    cacheInitialized = false;
    initializeCache();
}
#end_block

#method_before
public void updateCommandStatus(Guid commandId, CommandStatus status) {
    final CommandEntity cmdEntity = get(commandId);
    if (cmdEntity != null) {
        cmdEntity.setCommandStatus(status);
        saveOrUpdateWithoutTransaction(cmdEntity);
    }
}
#method_after
@Override
public void updateCommandStatus(Guid commandId, CommandStatus status) {
    final CommandEntity cmdEntity = get(commandId);
    if (cmdEntity != null) {
        cmdEntity.setCommandStatus(status);
        saveOrUpdateWithoutTransaction(cmdEntity);
    }
}
#end_block

#method_before
public void updateCommandExecuted(final Guid commandId) {
    CommandEntity cmdEntity = get(commandId);
    if (cmdEntity != null) {
        cmdEntity.setExecuted(true);
        DbFacade.getInstance().getCommandEntityDao().updateExecuted(commandId);
    }
}
#method_after
@Override
public void updateCommandExecuted(final Guid commandId) {
    CommandEntity cmdEntity = get(commandId);
    if (cmdEntity != null) {
        cmdEntity.setExecuted(true);
        DbFacade.getInstance().getCommandEntityDao().updateExecuted(commandId);
    }
}
#end_block

#method_before
public void updateCallbackNotified(final Guid commandId) {
    CommandEntity cmdEntity = get(commandId);
    if (cmdEntity != null) {
        cmdEntity.setCallbackNotified(true);
        DbFacade.getInstance().getCommandEntityDao().updateNotified(commandId);
    }
}
#method_after
@Override
public void updateCallbackNotified(final Guid commandId) {
    CommandEntity cmdEntity = get(commandId);
    if (cmdEntity != null) {
        cmdEntity.setCallbackNotified(true);
        DbFacade.getInstance().getCommandEntityDao().updateNotified(commandId);
    }
}
#end_block

#method_before
public void persistCommandAssociatedEntities(Collection<CommandAssociatedEntity> cmdAssociatedEntities) {
    if (cmdAssociatedEntities == null || cmdAssociatedEntities.isEmpty()) {
        return;
    }
    Transaction transaction = TransactionSupport.suspend();
    try {
        DbFacade.getInstance().getCommandEntityDao().insertCommandAssociatedEntities(cmdAssociatedEntities);
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#method_after
@Override
public void persistCommandAssociatedEntities(Collection<CommandAssociatedEntity> cmdAssociatedEntities) {
    if (CollectionUtils.isEmpty(cmdAssociatedEntities)) {
        return;
    }
    Transaction transaction = TransactionSupport.suspend();
    try {
        DbFacade.getInstance().getCommandEntityDao().insertCommandAssociatedEntities(cmdAssociatedEntities);
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#end_block

#method_before
public List<CommandAssociatedEntity> getCommandAssociatedEntities(Guid cmdId) {
    return DbFacade.getInstance().getCommandEntityDao().getAllCommandAssociatedEntities(cmdId);
}
#method_after
@Override
public List<CommandAssociatedEntity> getCommandAssociatedEntities(Guid cmdId) {
    return DbFacade.getInstance().getCommandEntityDao().getAllCommandAssociatedEntities(cmdId);
}
#end_block

#method_before
public List<Guid> getCommandIdsByEntityId(Guid entityId) {
    return DbFacade.getInstance().getCommandEntityDao().getCommandIdsByEntity(entityId);
}
#method_after
@Override
public List<Guid> getCommandIdsByEntityId(Guid entityId) {
    return DbFacade.getInstance().getCommandEntityDao().getCommandIdsByEntity(entityId);
}
#end_block

#method_before
public void persistCommandAssociatedEntities(Collection<CommandAssociatedEntity> cmdAssociatedEntities) {
    commandsCache.persistCommandAssociatedEntities(cmdAssociatedEntities);
}
#method_after
@Override
public void persistCommandAssociatedEntities(Collection<CommandAssociatedEntity> cmdAssociatedEntities) {
    commandsCache.persistCommandAssociatedEntities(cmdAssociatedEntities);
}
#end_block

#method_before
public List<Guid> getCommandIdsByEntityId(Guid entityId) {
    return commandsCache.getCommandIdsByEntityId(entityId);
}
#method_after
@Override
public List<Guid> getCommandIdsByEntityId(Guid entityId) {
    return commandsCache.getCommandIdsByEntityId(entityId);
}
#end_block

#method_before
public List<CommandAssociatedEntity> getCommandAssociatedEntities(Guid cmdId) {
    return commandsCache.getCommandAssociatedEntities(cmdId);
}
#method_after
@Override
public List<CommandAssociatedEntity> getCommandAssociatedEntities(Guid cmdId) {
    return commandsCache.getCommandAssociatedEntities(cmdId);
}
#end_block

#method_before
public List<CommandEntity> getCommandsWithCallbackEnabled() {
    return getCommands(true);
}
#method_after
@Override
public List<CommandEntity> getCommandsWithCallbackEnabled() {
    return getCommands(true);
}
#end_block

#method_before
private CommandBase<?> buildCommand(CommandEntity cmdEntity, CommandContext cmdContext) {
    CommandBase<?> command = null;
    if (cmdEntity != null) {
        if (cmdContext == null) {
            cmdContext = new CommandContext(new EngineContext()).withExecutionContext(new ExecutionContext());
        }
        command = CommandsFactory.createCommand(cmdEntity.getCommandType(), cmdEntity.getCommandParameters(), cmdContext);
        command.setCommandStatus(cmdEntity.getCommandStatus(), false);
        if (!Guid.isNullOrEmpty(cmdEntity.getParentCommandId()) && !cmdEntity.getParentCommandId().equals(cmdEntity.getId()) && command.getParameters().getParentParameters() == null) {
            CommandBase<?> parentCommand = retrieveCommand(cmdEntity.getParentCommandId());
            if (parentCommand != null) {
                command.getParameters().setParentParameters(parentCommand.getParameters());
            }
        }
    }
    return command;
}
#method_after
private CommandBase<?> buildCommand(CommandEntity cmdEntity, CommandContext cmdContext) {
    CommandBase<?> command = null;
    if (cmdEntity != null) {
        if (cmdContext == null) {
            cmdContext = new CommandContext(new EngineContext()).withExecutionContext(new ExecutionContext());
        }
        command = CommandsFactory.createCommand(cmdEntity.getCommandType(), cmdEntity.getCommandParameters(), cmdContext);
        command.setCommandStatus(cmdEntity.getCommandStatus(), false);
        command.setCommandData(cmdEntity.getData());
        if (!Guid.isNullOrEmpty(cmdEntity.getParentCommandId()) && !cmdEntity.getParentCommandId().equals(cmdEntity.getId()) && command.getParameters().getParentParameters() == null) {
            CommandBase<?> parentCommand = retrieveCommand(cmdEntity.getParentCommandId());
            if (parentCommand != null) {
                command.getParameters().setParentParameters(parentCommand.getParameters());
            }
        }
    }
    return command;
}
#end_block

#method_before
public CommandStatus getCommandStatus(final Guid commandId) {
    CommandEntity cmdEntity = commandsCache.get(commandId);
    if (cmdEntity != null) {
        return cmdEntity.getCommandStatus();
    }
    return CommandStatus.UNKNOWN;
}
#method_after
@Override
public CommandStatus getCommandStatus(final Guid commandId) {
    CommandEntity cmdEntity = commandsCache.get(commandId);
    if (cmdEntity != null) {
        return cmdEntity.getCommandStatus();
    }
    return CommandStatus.UNKNOWN;
}
#end_block

#method_before
public void removeAllCommandsInHierarchy(final Guid commandId) {
    for (Guid childCmdId : new ArrayList<>(getChildCommandIds(commandId))) {
        removeAllCommandsInHierarchy(childCmdId);
    }
    removeCommand(commandId);
}
#method_after
@Override
public void removeAllCommandsInHierarchy(final Guid commandId) {
    for (Guid childCmdId : new ArrayList<>(getChildCommandIds(commandId))) {
        removeAllCommandsInHierarchy(childCmdId);
    }
    removeCommand(commandId);
}
#end_block

#method_before
public void removeCommand(final Guid commandId) {
    commandsCache.remove(commandId);
    contextsCache.remove(commandId);
    updateCmdHierarchy(commandId);
}
#method_after
@Override
public void removeCommand(final Guid commandId) {
    commandsCache.remove(commandId);
    contextsCache.remove(commandId);
    updateCmdHierarchy(commandId);
}
#end_block

#method_before
public void removeAllCommandsBeforeDate(final DateTime cutoff) {
    commandsCache.removeAllCommandsBeforeDate(cutoff);
    synchronized (LOCK) {
        childHierarchyInitialized = false;
    }
}
#method_after
@Override
public void removeAllCommandsBeforeDate(final DateTime cutoff) {
    commandsCache.removeAllCommandsBeforeDate(cutoff);
    synchronized (LOCK) {
        childHierarchyInitialized = false;
    }
}
#end_block

#method_before
public void updateCommandStatus(final Guid commandId, final CommandStatus status) {
    commandsCache.updateCommandStatus(commandId, status);
}
#method_after
@Override
public void updateCommandStatus(final Guid commandId, final CommandStatus status) {
    commandsCache.updateCommandStatus(commandId, status);
}
#end_block

#method_before
public void updateCommandExecuted(Guid commandId) {
    commandsCache.updateCommandExecuted(commandId);
}
#method_after
@Override
public void updateCommandExecuted(Guid commandId) {
    commandsCache.updateCommandExecuted(commandId);
}
#end_block

#method_before
public void updateCallbackNotified(final Guid commandId) {
    commandsCache.updateCallbackNotified(commandId);
}
#method_after
@Override
public void updateCallbackNotified(final Guid commandId) {
    commandsCache.updateCallbackNotified(commandId);
}
#end_block

#method_before
public boolean hasCommandEntitiesWithRootCommandId(Guid rootCommandId) {
    CommandEntity cmdEntity;
    for (Guid cmdId : commandsCache.keySet()) {
        cmdEntity = commandsCache.get(cmdId);
        if (cmdEntity != null && !Guid.isNullOrEmpty(cmdEntity.getRootCommandId()) && !cmdEntity.getRootCommandId().equals(cmdId) && cmdEntity.getRootCommandId().equals(rootCommandId)) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean hasCommandEntitiesWithRootCommandId(Guid rootCommandId) {
    CommandEntity cmdEntity;
    for (Guid cmdId : commandsCache.keySet()) {
        cmdEntity = commandsCache.get(cmdId);
        if (cmdEntity != null && !Guid.isNullOrEmpty(cmdEntity.getRootCommandId()) && !cmdEntity.getRootCommandId().equals(cmdId) && cmdEntity.getRootCommandId().equals(rootCommandId)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public List<Guid> getChildCommandIds(Guid cmdId) {
    initChildHierarchy();
    if (childHierarchy.containsKey(cmdId)) {
        return childHierarchy.get(cmdId);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<Guid> getChildCommandIds(Guid cmdId) {
    initChildHierarchy();
    if (childHierarchy.containsKey(cmdId)) {
        return childHierarchy.get(cmdId);
    }
    return Collections.emptyList();
}
#end_block

#method_before
public List<Guid> getChildCommandIds(Guid cmdId, VdcActionType childActionType, CommandStatus status) {
    List<Guid> childCmdIds = new ArrayList<>();
    for (Guid childCmdId : getChildCommandIds(cmdId)) {
        CommandEntity childCmdEntity = getCommandEntity(childCmdId);
        if (childCmdEntity != null && childCmdEntity.getCommandType().equals(childActionType) && (status == null || status.equals(childCmdEntity.getCommandStatus()))) {
            childCmdIds.add(childCmdId);
        }
    }
    return childCmdIds;
}
#method_after
@Override
public List<Guid> getChildCommandIds(Guid cmdId, VdcActionType childActionType, CommandStatus status) {
    List<Guid> childCmdIds = new ArrayList<>();
    for (Guid childCmdId : getChildCommandIds(cmdId)) {
        CommandEntity childCmdEntity = getCommandEntity(childCmdId);
        if (childCmdEntity != null && childCmdEntity.getCommandType().equals(childActionType) && (status == null || status.equals(childCmdEntity.getCommandStatus()))) {
            childCmdIds.add(childCmdId);
        }
    }
    return childCmdIds;
}
#end_block

#method_before
public List<CommandEntity> getChildCmdsByRootCmdId(Guid cmdId) {
    return commandsCache.getChildCmdsByParentCmdId(cmdId);
}
#method_after
@Override
public List<CommandEntity> getChildCmdsByRootCmdId(Guid cmdId) {
    return commandsCache.getChildCmdsByParentCmdId(cmdId);
}
#end_block

#method_before
public List<AsyncTask> getAllAsyncTasksFromDb() {
    return coCoAsyncTaskHelper.getAllAsyncTasksFromDb(this);
}
#method_after
@Override
public List<AsyncTask> getAllAsyncTasksFromDb() {
    return coCoAsyncTaskHelper.getAllAsyncTasksFromDb(this);
}
#end_block

#method_before
public void saveAsyncTaskToDb(final AsyncTask asyncTask) {
    coCoAsyncTaskHelper.saveAsyncTaskToDb(asyncTask);
}
#method_after
@Override
public void saveAsyncTaskToDb(final AsyncTask asyncTask) {
    coCoAsyncTaskHelper.saveAsyncTaskToDb(asyncTask);
}
#end_block

#method_before
public AsyncTask getAsyncTaskFromDb(Guid asyncTaskId) {
    return coCoAsyncTaskHelper.getAsyncTaskFromDb(asyncTaskId);
}
#method_after
@Override
public AsyncTask getAsyncTaskFromDb(Guid asyncTaskId) {
    return coCoAsyncTaskHelper.getAsyncTaskFromDb(asyncTaskId);
}
#end_block

#method_before
public int removeTaskFromDbByTaskId(final Guid taskId) throws RuntimeException {
    return coCoAsyncTaskHelper.removeTaskFromDbByTaskId(taskId);
}
#method_after
@Override
public int removeTaskFromDbByTaskId(final Guid taskId) throws RuntimeException {
    return coCoAsyncTaskHelper.removeTaskFromDbByTaskId(taskId);
}
#end_block

#method_before
public AsyncTask getByVdsmTaskId(Guid vdsmTaskId) {
    return coCoAsyncTaskHelper.getByVdsmTaskId(vdsmTaskId);
}
#method_after
@Override
public AsyncTask getByVdsmTaskId(Guid vdsmTaskId) {
    return coCoAsyncTaskHelper.getByVdsmTaskId(vdsmTaskId);
}
#end_block

#method_before
public int removeByVdsmTaskId(final Guid vdsmTaskId) {
    return coCoAsyncTaskHelper.removeByVdsmTaskId(vdsmTaskId);
}
#method_after
@Override
public int removeByVdsmTaskId(final Guid vdsmTaskId) {
    return coCoAsyncTaskHelper.removeByVdsmTaskId(vdsmTaskId);
}
#end_block

#method_before
public void addOrUpdateTaskInDB(final AsyncTask asyncTask) {
    coCoAsyncTaskHelper.addOrUpdateTaskInDB(asyncTask);
}
#method_after
@Override
public void addOrUpdateTaskInDB(final AsyncTask asyncTask) {
    coCoAsyncTaskHelper.addOrUpdateTaskInDB(asyncTask);
}
#end_block

#method_before
public AsyncTask getAsyncTask(Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#method_after
@Override
public AsyncTask getAsyncTask(Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public AsyncTask createAsyncTask(CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
}
#method_after
@Override
public AsyncTask createAsyncTask(CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public Guid createTask(Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    return coCoAsyncTaskHelper.createTask(taskId, command, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
}
#method_after
@Override
public Guid createTask(Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    return coCoAsyncTaskHelper.createTask(taskId, command, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
}
#end_block

#method_before
public SPMAsyncTask concreteCreateTask(Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#method_after
@Override
public SPMAsyncTask concreteCreateTask(Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public void cancelTasks(final CommandBase<?> command) {
    coCoAsyncTaskHelper.cancelTasks(command, log);
}
#method_after
@Override
public void cancelTasks(final CommandBase<?> command) {
    coCoAsyncTaskHelper.cancelTasks(command, log);
}
#end_block

#method_before
public void revertTasks(CommandBase<?> command) {
    coCoAsyncTaskHelper.revertTasks(command);
}
#method_after
@Override
public void revertTasks(CommandBase<?> command) {
    coCoAsyncTaskHelper.revertTasks(command);
}
#end_block

#method_before
public VdcReturnValueBase endAction(SPMTask task, ExecutionContext context) {
    return coCoAsyncTaskHelper.endAction(task, context);
}
#method_after
@Override
public VdcReturnValueBase endAction(SPMTask task, ExecutionContext context) {
    return coCoAsyncTaskHelper.endAction(task, context);
}
#end_block

#method_before
public Guid getStorageDomainId() {
    return getDiskImage().getStorageIds().get(0);
}
#method_after
@Override
public Guid getStorageDomainId() {
    return getDiskImage().getStorageIds().get(0);
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(() -> {
        Deserializer deserializer = SerializationFactory.getDeserializer();
        List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDao().getAllForCommandId(commandId);
        log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
        for (BusinessEntitySnapshot snapshot : entitySnapshots) {
            Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
            Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
            log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
            Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
            GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
            switch(snapshot.getSnapshotType()) {
                case CHANGED_STATUS_ONLY:
                    EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                    ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                    break;
                case DELETED_OR_UPDATED_ENTITY:
                    BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                    if (daoForEntity.get(entitySnapshot.getId()) == null) {
                        daoForEntity.save(entitySnapshot);
                    } else {
                        daoForEntity.update(entitySnapshot);
                    }
                    break;
                case UPDATED_ONLY_ENTITY:
                    daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                    break;
                case NEW_ENTITY_ID:
                    daoForEntity.remove(snapshotData);
                    break;
            }
        }
        cleanUpCompensationData();
        return null;
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(() -> {
        Deserializer deserializer = SerializationFactory.getDeserializer();
        List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDao().getAllForCommandId(commandId);
        log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
        for (BusinessEntitySnapshot snapshot : entitySnapshots) {
            Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
            Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
            log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString());
            Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
            GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
            switch(snapshot.getSnapshotType()) {
                case CHANGED_STATUS_ONLY:
                    EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                    ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                    break;
                case DELETED_OR_UPDATED_ENTITY:
                    BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                    if (daoForEntity.get(entitySnapshot.getId()) == null) {
                        daoForEntity.save(entitySnapshot);
                    } else {
                        daoForEntity.update(entitySnapshot);
                    }
                    break;
                case UPDATED_ONLY_ENTITY:
                    daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                    break;
                case NEW_ENTITY_ID:
                    daoForEntity.remove(snapshotData);
                    break;
            }
        }
        cleanUpCompensationData();
        return null;
    });
}
#end_block

#method_before
private void cleanUpCompensationData() {
    if (!(getCompensationContext() instanceof NoOpCompensationContext)) {
        getBusinessEntitySnapshotDao().removeAllForCommandId(commandId);
    }
}
#method_after
private void cleanUpCompensationData() {
    getCompensationContext().resetCompensation();
}
#end_block

#method_before
protected void auditLog(AuditLogableBase logable, AuditLogType logType) {
    auditLogDirector.log(logable, logType);
}
#method_after
void auditLog(AuditLogableBase logable, AuditLogType logType) {
    auditLogDirector.log(logable, logType);
}
#end_block

#method_before
protected void logRollbackedTask() {
    String type = (getCurrentTaskHandler().getRevertTaskType() != null ? getCurrentTaskHandler().getRevertTaskType().name() : AsyncTaskType.unknown.name());
    log.error("Reverting task '{}', handler '{}'", type, getCurrentTaskHandler().getClass().getName());
}
#method_after
protected void logRollbackedTask() {
    String type = getCurrentTaskHandler().getRevertTaskType() != null ? getCurrentTaskHandler().getRevertTaskType().name() : AsyncTaskType.unknown.name();
    log.error("Reverting task '{}', handler '{}'", type, getCurrentTaskHandler().getClass().getName());
}
#end_block

#method_before
final public boolean checkSinglePermission(PermissionSubject permSubject, Collection<String> messages) {
    final Guid objectId = permSubject.getObjectId();
    final VdcObjectType objectType = permSubject.getObjectType();
    final ActionGroup objectActionGroup = permSubject.getActionGroup();
    // if objectId is null we can't check permission
    if (objectId == null) {
        if (log.isDebugEnabled()) {
            log.debug("The object to check is null for action '{}'.", getActionType());
        }
        messages.add(EngineMessage.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.name());
        return false;
    }
    // Check that an action group is defined for this action;
    if (objectActionGroup == null) {
        if (log.isDebugEnabled()) {
            log.debug("No action group is defined for action '{}'.", getActionType());
        }
        return false;
    }
    // Check the authorization:
    if (!checkUserAuthorization(getCurrentUser().getId(), objectActionGroup, objectId, objectType)) {
        messages.add(permSubject.getMessage().name());
        return false;
    }
    return true;
}
#method_after
public final boolean checkSinglePermission(PermissionSubject permSubject, Collection<String> messages) {
    final Guid objectId = permSubject.getObjectId();
    final VdcObjectType objectType = permSubject.getObjectType();
    final ActionGroup objectActionGroup = permSubject.getActionGroup();
    // if objectId is null we can't check permission
    if (objectId == null) {
        if (log.isDebugEnabled()) {
            log.debug("The object to check is null for action '{}'.", getActionType());
        }
        messages.add(EngineMessage.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.name());
        return false;
    }
    // Check that an action group is defined for this action;
    if (objectActionGroup == null) {
        if (log.isDebugEnabled()) {
            log.debug("No action group is defined for action '{}'.", getActionType());
        }
        return false;
    }
    // Check the authorization:
    if (!checkUserAuthorization(getCurrentUser().getId(), objectActionGroup, objectId, objectType)) {
        messages.add(permSubject.getMessage().name());
        return false;
    }
    return true;
}
#end_block

#method_before
private CommandEntity buildCommandEntity(Guid rootCommandId, boolean enableCallback) {
    return CommandEntity.buildCommandEntity(getUserId(), getCommandId(), getParameters().getParentParameters() == null ? Guid.Empty : getParameters().getParentParameters().getCommandId(), rootCommandId, getExecutionContext() == null || getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext() == null || getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallback, getReturnValue());
}
#method_after
private CommandEntity buildCommandEntity(Guid rootCommandId, boolean enableCallback) {
    return CommandEntity.buildCommandEntity(getUserId(), getCommandId(), getParameters().getParentParameters() == null ? Guid.Empty : getParameters().getParentParameters().getCommandId(), rootCommandId, getExecutionContext() == null || getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext() == null || getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallback, getReturnValue(), getCommandData());
}
#end_block

#method_before
private boolean isVMWithMemoryCompatible(VM vm) {
    // the cluster version where the preview is going to run
    Version recentClusterVersion = vm.getClusterCompatibilityVersion();
    // the vm.customCompatibilityVersion is set from OVF configuration
    return vm.getCustomCompatibilityVersion() != null && vm.getCustomCompatibilityVersion().getMajor() == recentClusterVersion.getMajor() && vm.getCustomCompatibilityVersion().getMinor() == recentClusterVersion.getMinor();
}
#method_after
private boolean isVMWithMemoryCompatible(VM vm) {
    Version recentClusterVersion = vm.getClusterCompatibilityVersion();
    // the cluster version in which the memory snapshot was taken
    Version originalClusterVersion = vm.getClusterCompatibilityVersionOrigin();
    if (vm.getCustomCompatibilityVersion() != null) {
        return true;
    }
    return originalClusterVersion != null && recentClusterVersion.getMajor() == originalClusterVersion.getMajor() && recentClusterVersion.getMinor() == originalClusterVersion.getMinor();
}
#end_block

#method_before
protected void readGeneralData() {
    XmlNode content = selectSingleNode(_document, "//*/Content");
    XmlNode node;
    vmBase.setVmInit(new VmInit());
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    node = selectSingleNode(content, OvfProperties.DESCRIPTION);
    if (node != null) {
        vmBase.setDescription(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.COMMENT);
    if (node != null) {
        vmBase.setComment(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.DOMAIN);
    if (node != null) {
        vmBase.getVmInit().setDomain(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.CREATION_DATE);
    if (node != null) {
        Date creationDate = OvfParser.utcDateStringToLocaDate(node.innerText);
        if (creationDate != null) {
            vmBase.setCreationDate(creationDate);
        }
    }
    node = selectSingleNode(content, OvfProperties.EXPORT_DATE);
    if (node != null) {
        Date exportDate = OvfParser.utcDateStringToLocaDate(node.innerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = selectSingleNode(content, OvfProperties.DEFAULT_BOOT_SEQUENCE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.INITRD_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setInitrdUrl(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.KERNEL_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelUrl(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.KERNEL_PARAMS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelParams(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.GENERATION);
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.innerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_COMPATIBILITY_VERSION);
    if (node != null) {
        vmBase.setCustomCompatibilityVersion(new Version(node.innerText));
    }
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = selectSingleNode(content, getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            defaultDisplayType = DisplayType.forValue(Integer.parseInt(node.innerText));
            vmBase.setDefaultDisplayType(defaultDisplayType);
        }
    }
    XmlNodeList list = selectNodes(content, "Section");
    Version version = new Version(getVersion());
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || !FeatureSupported.singleQxlPci(version) || vmBase.getDefaultDisplayType() != DisplayType.qxl) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    // after reading the hardware section, if graphics device is still absent, add a default one
    addDefaultGraphicsDevice();
    // due to dependency on vmBase.getOsId() must be read AFTER readOsSection
    node = selectSingleNode(content, OvfProperties.TIMEZONE);
    if (node != null && StringUtils.isNotEmpty(node.innerText)) {
        vmBase.setTimeZone(node.innerText);
    } else {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    }
    node = selectSingleNode(content, OvfProperties.ORIGIN);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setOrigin(OriginType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.VM_TYPE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVmType(VmType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_SMARTCARD_ENABLED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.NUM_OF_IOTHREADS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText) && !FeatureSupported.isIoThreadsSupported(version)) {
            vmBase.setNumOfIoThreads(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.DELETE_PROTECTED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.SSO_METHOD);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSsoMethod(SsoMethod.fromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.TUNNEL_MIGRATION);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTunnelMigration(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.VNC_KEYBOARD_LAYOUT);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVncKeyboardLayout(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.MIN_ALLOCATED_MEMORY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMinAllocatedMem(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_STATELESS);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setStateless(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_RUN_AND_PAUSE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setRunAndPause(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.CREATED_BY_USER_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCreatedByUserId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_DOWNTIME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrationDowntime(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_SUPPORT);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            MigrationSupport migrationSupport = MigrationSupport.forValue(Integer.parseInt(node.innerText));
            vmBase.setMigrationSupport(migrationSupport);
        }
    }
    // TODO dedicated to multiple hosts
    readDedicatedHostsList();
    node = selectSingleNode(content, OvfProperties.SERIAL_NUMBER_POLICY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setSerialNumberPolicy(SerialNumberPolicy.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_SERIAL_NUMBER);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomSerialNumber(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.AUTO_STARTUP);
    if (node != null) {
        vmBase.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.PRIORITY);
    if (node != null) {
        vmBase.setPriority(Integer.parseInt(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_BOOT_MENU_ENABLED);
    if (node != null) {
        vmBase.setBootMenuEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED);
    if (node != null) {
        vmBase.setSpiceFileTransferEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_SPICE_COPY_PASTE_ENABLED);
    if (node != null) {
        vmBase.setSpiceCopyPasteEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_AUTO_CONVERGE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setAutoConverge(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_MIGRATE_COMPRESSED);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrateCompressed(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_EMULATED_MACHINE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomEmulatedMachine(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_CPU_NAME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomCpuName(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.PREDEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setPredefinedProperties(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.USER_DEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setUserDefinedProperties(node.innerText);
        }
    }
    vmBase.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(vmBase.getPredefinedProperties(), vmBase.getUserDefinedProperties()));
    readGeneralData(content);
    readVmInit(content);
}
#method_after
protected void readGeneralData() {
    XmlNode content = selectSingleNode(_document, "//*/Content");
    XmlNode node;
    vmBase.setVmInit(new VmInit());
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    node = selectSingleNode(content, OvfProperties.DESCRIPTION);
    if (node != null) {
        vmBase.setDescription(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.COMMENT);
    if (node != null) {
        vmBase.setComment(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.DOMAIN);
    if (node != null) {
        vmBase.getVmInit().setDomain(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.CREATION_DATE);
    if (node != null) {
        Date creationDate = OvfParser.utcDateStringToLocaDate(node.innerText);
        if (creationDate != null) {
            vmBase.setCreationDate(creationDate);
        }
    }
    node = selectSingleNode(content, OvfProperties.EXPORT_DATE);
    if (node != null) {
        Date exportDate = OvfParser.utcDateStringToLocaDate(node.innerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = selectSingleNode(content, OvfProperties.DEFAULT_BOOT_SEQUENCE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.INITRD_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setInitrdUrl(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.KERNEL_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelUrl(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.KERNEL_PARAMS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelParams(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.GENERATION);
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.innerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_COMPATIBILITY_VERSION);
    if (node != null) {
        vmBase.setCustomCompatibilityVersion(new Version(node.innerText));
    }
    // the originating ENGINE version
    Version originVersion = new Version(getVersion());
    node = selectSingleNode(content, OvfProperties.CLUSTER_COMPATIBILITY_VERSION);
    if (node != null) {
        originVersion = new Version(node.innerText);
    }
    vmBase.setClusterCompatibilityVersionOrigin(originVersion);
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = selectSingleNode(content, getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            defaultDisplayType = DisplayType.forValue(Integer.parseInt(node.innerText));
            vmBase.setDefaultDisplayType(defaultDisplayType);
        }
    }
    XmlNodeList list = selectNodes(content, "Section");
    Version version = new Version(getVersion());
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || !FeatureSupported.singleQxlPci(version) || vmBase.getDefaultDisplayType() != DisplayType.qxl) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    // after reading the hardware section, if graphics device is still absent, add a default one
    addDefaultGraphicsDevice();
    // if boot order is not set, figure out some default based on the set of bootable disks
    setDefaultBootDevice();
    // due to dependency on vmBase.getOsId() must be read AFTER readOsSection
    node = selectSingleNode(content, OvfProperties.TIMEZONE);
    if (node != null && StringUtils.isNotEmpty(node.innerText)) {
        vmBase.setTimeZone(node.innerText);
    } else {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    }
    node = selectSingleNode(content, OvfProperties.ORIGIN);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setOrigin(OriginType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.VM_TYPE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVmType(VmType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_SMARTCARD_ENABLED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.NUM_OF_IOTHREADS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText) && !FeatureSupported.isIoThreadsSupported(version)) {
            vmBase.setNumOfIoThreads(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.DELETE_PROTECTED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.SSO_METHOD);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSsoMethod(SsoMethod.fromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.TUNNEL_MIGRATION);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTunnelMigration(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.VNC_KEYBOARD_LAYOUT);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVncKeyboardLayout(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.MIN_ALLOCATED_MEMORY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMinAllocatedMem(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_STATELESS);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setStateless(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_RUN_AND_PAUSE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setRunAndPause(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.CREATED_BY_USER_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCreatedByUserId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_DOWNTIME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrationDowntime(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_SUPPORT);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            MigrationSupport migrationSupport = MigrationSupport.forValue(Integer.parseInt(node.innerText));
            vmBase.setMigrationSupport(migrationSupport);
        }
    }
    // TODO dedicated to multiple hosts
    readDedicatedHostsList();
    node = selectSingleNode(content, OvfProperties.SERIAL_NUMBER_POLICY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setSerialNumberPolicy(SerialNumberPolicy.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_SERIAL_NUMBER);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomSerialNumber(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.AUTO_STARTUP);
    if (node != null) {
        vmBase.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.PRIORITY);
    if (node != null) {
        vmBase.setPriority(Integer.parseInt(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_BOOT_MENU_ENABLED);
    if (node != null) {
        vmBase.setBootMenuEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED);
    if (node != null) {
        vmBase.setSpiceFileTransferEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_SPICE_COPY_PASTE_ENABLED);
    if (node != null) {
        vmBase.setSpiceCopyPasteEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_AUTO_CONVERGE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setAutoConverge(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_MIGRATE_COMPRESSED);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrateCompressed(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_EMULATED_MACHINE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomEmulatedMachine(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_CPU_NAME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomCpuName(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.PREDEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setPredefinedProperties(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.USER_DEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setUserDefinedProperties(node.innerText);
        }
    }
    vmBase.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(vmBase.getPredefinedProperties(), vmBase.getUserDefinedProperties()));
    readGeneralData(content);
    readVmInit(content);
}
#end_block

#method_before
protected void writeGeneralData() {
    if (vmBase.getDescription() != null) {
        _writer.writeStartElement(OvfProperties.DESCRIPTION);
        _writer.writeRaw(vmBase.getDescription());
        _writer.writeEndElement();
    }
    if (vmBase.getComment() != null) {
        _writer.writeStartElement(OvfProperties.COMMENT);
        _writer.writeRaw(vmBase.getComment());
        _writer.writeEndElement();
    }
    if (!vmInitEnabled() && vmBase.getVmInit() != null && vmBase.getVmInit().getDomain() != null) {
        _writer.writeStartElement(OvfProperties.DOMAIN);
        _writer.writeRaw(vmBase.getVmInit().getDomain());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.CREATION_DATE);
    _writer.writeRaw(OvfParser.localDateToUtcDateString(vmBase.getCreationDate()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.EXPORT_DATE);
    _writer.writeRaw(OvfParser.localDateToUtcDateString(new Date()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.DELETE_PROTECTED);
    _writer.writeRaw(String.valueOf(vmBase.isDeleteProtected()));
    _writer.writeEndElement();
    if (vmBase.getSsoMethod() != null) {
        _writer.writeStartElement(OvfProperties.SSO_METHOD);
        _writer.writeRaw(vmBase.getSsoMethod().toString());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.IS_SMARTCARD_ENABLED);
    _writer.writeRaw(String.valueOf(vmBase.isSmartcardEnabled()));
    _writer.writeEndElement();
    if (vmBase.getNumOfIoThreads() != 0) {
        _writer.writeStartElement(OvfProperties.NUM_OF_IOTHREADS);
        _writer.writeRaw(String.valueOf(vmBase.getNumOfIoThreads()));
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.TIMEZONE);
    _writer.writeRaw(vmBase.getTimeZone());
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.DEFAULT_BOOT_SEQUENCE);
    _writer.writeRaw(String.valueOf(vmBase.getDefaultBootSequence().getValue()));
    _writer.writeEndElement();
    if (!StringUtils.isBlank(vmBase.getInitrdUrl())) {
        _writer.writeStartElement(OvfProperties.INITRD_URL);
        _writer.writeRaw(vmBase.getInitrdUrl());
        _writer.writeEndElement();
    }
    if (!StringUtils.isBlank(vmBase.getKernelUrl())) {
        _writer.writeStartElement(OvfProperties.KERNEL_URL);
        _writer.writeRaw(vmBase.getKernelUrl());
        _writer.writeEndElement();
    }
    if (!StringUtils.isBlank(vmBase.getKernelParams())) {
        _writer.writeStartElement(OvfProperties.KERNEL_PARAMS);
        _writer.writeRaw(vmBase.getKernelParams());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.GENERATION);
    _writer.writeRaw(String.valueOf(vmBase.getDbGeneration()));
    _writer.writeEndElement();
    if (vmBase.getCustomCompatibilityVersion() != null) {
        _writer.writeStartElement(OvfProperties.CUSTOM_COMPATIBILITY_VERSION);
        _writer.writeRaw(String.valueOf(vmBase.getCustomCompatibilityVersion()));
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.VM_TYPE);
    _writer.writeRaw(String.valueOf(vmBase.getVmType().getValue()));
    _writer.writeEndElement();
    if (vmBase.getTunnelMigration() != null) {
        _writer.writeStartElement(OvfProperties.TUNNEL_MIGRATION);
        _writer.writeRaw(String.valueOf(vmBase.getTunnelMigration()));
        _writer.writeEndElement();
    }
    if (vmBase.getVncKeyboardLayout() != null) {
        _writer.writeStartElement(OvfProperties.VNC_KEYBOARD_LAYOUT);
        _writer.writeRaw(vmBase.getVncKeyboardLayout());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.MIN_ALLOCATED_MEMORY);
    _writer.writeRaw(String.valueOf(vmBase.getMinAllocatedMem()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.IS_STATELESS);
    _writer.writeRaw(String.valueOf(vmBase.isStateless()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.IS_RUN_AND_PAUSE);
    _writer.writeRaw(String.valueOf(vmBase.isRunAndPause()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.AUTO_STARTUP);
    _writer.writeRaw(String.valueOf(vmBase.isAutoStartup()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.PRIORITY);
    _writer.writeRaw(String.valueOf(vmBase.getPriority()));
    _writer.writeEndElement();
    if (vmBase.getCreatedByUserId() != null) {
        _writer.writeStartElement(OvfProperties.CREATED_BY_USER_ID);
        _writer.writeRaw(String.valueOf(vmBase.getCreatedByUserId()));
        _writer.writeEndElement();
    }
    if (vmBase.getMigrationDowntime() != null) {
        _writer.writeStartElement(OvfProperties.MIGRATION_DOWNTIME);
        _writer.writeRaw(String.valueOf(vmBase.getMigrationDowntime()));
        _writer.writeEndElement();
    }
    writeVmInit();
    if (vmBase.getMigrationSupport() != null) {
        _writer.writeStartElement(OvfProperties.MIGRATION_SUPPORT);
        _writer.writeRaw(String.valueOf(vmBase.getMigrationSupport().getValue()));
        _writer.writeEndElement();
    }
    // TODO dedicated to multiple hosts - are we breaking any standard here?
    if (vmBase.getDedicatedVmForVdsList().size() > 0) {
        for (Guid hostId : vmBase.getDedicatedVmForVdsList()) {
            _writer.writeStartElement(OvfProperties.DEDICATED_VM_FOR_VDS);
            _writer.writeRaw(String.valueOf(hostId));
            _writer.writeEndElement();
        }
    }
    if (vmBase.getSerialNumberPolicy() != null) {
        _writer.writeStartElement(OvfProperties.SERIAL_NUMBER_POLICY);
        _writer.writeRaw(String.valueOf(vmBase.getSerialNumberPolicy().getValue()));
        _writer.writeEndElement();
    }
    if (vmBase.getCustomSerialNumber() != null) {
        _writer.writeStartElement(OvfProperties.CUSTOM_SERIAL_NUMBER);
        _writer.writeRaw(vmBase.getCustomSerialNumber());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.IS_BOOT_MENU_ENABLED);
    _writer.writeRaw(String.valueOf(vmBase.isBootMenuEnabled()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED);
    _writer.writeRaw(String.valueOf(vmBase.isSpiceFileTransferEnabled()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.IS_SPICE_COPY_PASTE_ENABLED);
    _writer.writeRaw(String.valueOf(vmBase.isSpiceCopyPasteEnabled()));
    _writer.writeEndElement();
    if (vmBase.getAutoConverge() != null) {
        _writer.writeStartElement(OvfProperties.IS_AUTO_CONVERGE);
        _writer.writeRaw(String.valueOf(vmBase.getAutoConverge()));
        _writer.writeEndElement();
    }
    if (vmBase.getMigrateCompressed() != null) {
        _writer.writeStartElement(OvfProperties.IS_MIGRATE_COMPRESSED);
        _writer.writeRaw(String.valueOf(vmBase.getMigrateCompressed()));
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.CUSTOM_EMULATED_MACHINE);
    _writer.writeRaw(vmBase.getCustomEmulatedMachine());
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.CUSTOM_CPU_NAME);
    _writer.writeRaw(vmBase.getCustomCpuName());
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.PREDEFINED_PROPERTIES);
    _writer.writeRaw(vmBase.getPredefinedProperties());
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.USER_DEFINED_PROPERTIES);
    _writer.writeRaw(vmBase.getUserDefinedProperties());
    _writer.writeEndElement();
}
#method_after
protected void writeGeneralData() {
    if (vmBase.getDescription() != null) {
        _writer.writeStartElement(OvfProperties.DESCRIPTION);
        _writer.writeRaw(vmBase.getDescription());
        _writer.writeEndElement();
    }
    if (vmBase.getComment() != null) {
        _writer.writeStartElement(OvfProperties.COMMENT);
        _writer.writeRaw(vmBase.getComment());
        _writer.writeEndElement();
    }
    if (!vmInitEnabled() && vmBase.getVmInit() != null && vmBase.getVmInit().getDomain() != null) {
        _writer.writeStartElement(OvfProperties.DOMAIN);
        _writer.writeRaw(vmBase.getVmInit().getDomain());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.CREATION_DATE);
    _writer.writeRaw(OvfParser.localDateToUtcDateString(vmBase.getCreationDate()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.EXPORT_DATE);
    _writer.writeRaw(OvfParser.localDateToUtcDateString(new Date()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.DELETE_PROTECTED);
    _writer.writeRaw(String.valueOf(vmBase.isDeleteProtected()));
    _writer.writeEndElement();
    if (vmBase.getSsoMethod() != null) {
        _writer.writeStartElement(OvfProperties.SSO_METHOD);
        _writer.writeRaw(vmBase.getSsoMethod().toString());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.IS_SMARTCARD_ENABLED);
    _writer.writeRaw(String.valueOf(vmBase.isSmartcardEnabled()));
    _writer.writeEndElement();
    if (vmBase.getNumOfIoThreads() != 0) {
        _writer.writeStartElement(OvfProperties.NUM_OF_IOTHREADS);
        _writer.writeRaw(String.valueOf(vmBase.getNumOfIoThreads()));
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.TIMEZONE);
    _writer.writeRaw(vmBase.getTimeZone());
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.DEFAULT_BOOT_SEQUENCE);
    _writer.writeRaw(String.valueOf(vmBase.getDefaultBootSequence().getValue()));
    _writer.writeEndElement();
    if (!StringUtils.isBlank(vmBase.getInitrdUrl())) {
        _writer.writeStartElement(OvfProperties.INITRD_URL);
        _writer.writeRaw(vmBase.getInitrdUrl());
        _writer.writeEndElement();
    }
    if (!StringUtils.isBlank(vmBase.getKernelUrl())) {
        _writer.writeStartElement(OvfProperties.KERNEL_URL);
        _writer.writeRaw(vmBase.getKernelUrl());
        _writer.writeEndElement();
    }
    if (!StringUtils.isBlank(vmBase.getKernelParams())) {
        _writer.writeStartElement(OvfProperties.KERNEL_PARAMS);
        _writer.writeRaw(vmBase.getKernelParams());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.GENERATION);
    _writer.writeRaw(String.valueOf(vmBase.getDbGeneration()));
    _writer.writeEndElement();
    if (vmBase.getCustomCompatibilityVersion() != null) {
        _writer.writeStartElement(OvfProperties.CUSTOM_COMPATIBILITY_VERSION);
        _writer.writeRaw(String.valueOf(vmBase.getCustomCompatibilityVersion()));
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.CLUSTER_COMPATIBILITY_VERSION);
    // cluster version the VM/Snapshot originates from
    _writer.writeRaw(String.valueOf(version));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.VM_TYPE);
    _writer.writeRaw(String.valueOf(vmBase.getVmType().getValue()));
    _writer.writeEndElement();
    if (vmBase.getTunnelMigration() != null) {
        _writer.writeStartElement(OvfProperties.TUNNEL_MIGRATION);
        _writer.writeRaw(String.valueOf(vmBase.getTunnelMigration()));
        _writer.writeEndElement();
    }
    if (vmBase.getVncKeyboardLayout() != null) {
        _writer.writeStartElement(OvfProperties.VNC_KEYBOARD_LAYOUT);
        _writer.writeRaw(vmBase.getVncKeyboardLayout());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.MIN_ALLOCATED_MEMORY);
    _writer.writeRaw(String.valueOf(vmBase.getMinAllocatedMem()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.IS_STATELESS);
    _writer.writeRaw(String.valueOf(vmBase.isStateless()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.IS_RUN_AND_PAUSE);
    _writer.writeRaw(String.valueOf(vmBase.isRunAndPause()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.AUTO_STARTUP);
    _writer.writeRaw(String.valueOf(vmBase.isAutoStartup()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.PRIORITY);
    _writer.writeRaw(String.valueOf(vmBase.getPriority()));
    _writer.writeEndElement();
    if (vmBase.getCreatedByUserId() != null) {
        _writer.writeStartElement(OvfProperties.CREATED_BY_USER_ID);
        _writer.writeRaw(String.valueOf(vmBase.getCreatedByUserId()));
        _writer.writeEndElement();
    }
    if (vmBase.getMigrationDowntime() != null) {
        _writer.writeStartElement(OvfProperties.MIGRATION_DOWNTIME);
        _writer.writeRaw(String.valueOf(vmBase.getMigrationDowntime()));
        _writer.writeEndElement();
    }
    writeVmInit();
    if (vmBase.getMigrationSupport() != null) {
        _writer.writeStartElement(OvfProperties.MIGRATION_SUPPORT);
        _writer.writeRaw(String.valueOf(vmBase.getMigrationSupport().getValue()));
        _writer.writeEndElement();
    }
    // TODO dedicated to multiple hosts - are we breaking any standard here?
    if (vmBase.getDedicatedVmForVdsList().size() > 0) {
        for (Guid hostId : vmBase.getDedicatedVmForVdsList()) {
            _writer.writeStartElement(OvfProperties.DEDICATED_VM_FOR_VDS);
            _writer.writeRaw(String.valueOf(hostId));
            _writer.writeEndElement();
        }
    }
    if (vmBase.getSerialNumberPolicy() != null) {
        _writer.writeStartElement(OvfProperties.SERIAL_NUMBER_POLICY);
        _writer.writeRaw(String.valueOf(vmBase.getSerialNumberPolicy().getValue()));
        _writer.writeEndElement();
    }
    if (vmBase.getCustomSerialNumber() != null) {
        _writer.writeStartElement(OvfProperties.CUSTOM_SERIAL_NUMBER);
        _writer.writeRaw(vmBase.getCustomSerialNumber());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.IS_BOOT_MENU_ENABLED);
    _writer.writeRaw(String.valueOf(vmBase.isBootMenuEnabled()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED);
    _writer.writeRaw(String.valueOf(vmBase.isSpiceFileTransferEnabled()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.IS_SPICE_COPY_PASTE_ENABLED);
    _writer.writeRaw(String.valueOf(vmBase.isSpiceCopyPasteEnabled()));
    _writer.writeEndElement();
    if (vmBase.getAutoConverge() != null) {
        _writer.writeStartElement(OvfProperties.IS_AUTO_CONVERGE);
        _writer.writeRaw(String.valueOf(vmBase.getAutoConverge()));
        _writer.writeEndElement();
    }
    if (vmBase.getMigrateCompressed() != null) {
        _writer.writeStartElement(OvfProperties.IS_MIGRATE_COMPRESSED);
        _writer.writeRaw(String.valueOf(vmBase.getMigrateCompressed()));
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.CUSTOM_EMULATED_MACHINE);
    _writer.writeRaw(vmBase.getCustomEmulatedMachine());
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.CUSTOM_CPU_NAME);
    _writer.writeRaw(vmBase.getCustomCpuName());
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.PREDEFINED_PROPERTIES);
    _writer.writeRaw(vmBase.getPredefinedProperties());
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.USER_DEFINED_PROPERTIES);
    _writer.writeRaw(vmBase.getUserDefinedProperties());
    _writer.writeEndElement();
}
#end_block

#method_before
public ImportVmModel getSpecificImportModel() {
    selectedImportVmModel = null;
    switch(importSources.getSelectedItem()) {
        case EXPORT_DOMAIN:
            importFromExportDomainModel.setEntity(null);
            importFromExportDomainModel.init(getVmsToImport(), exportDomain.getId());
            importFromExportDomainModel.setEntity(exportDomain.getId());
            selectedImportVmModel = importFromExportDomainModel;
            break;
        case VMWARE:
            importFromExternalSourceModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            importFromExternalSourceModel.setUrl(getUrl());
            importFromExternalSourceModel.setUsername(getUsername().getEntity());
            importFromExternalSourceModel.setPassword(getPassword().getEntity());
            importFromExternalSourceModel.setProxyHostId(getProxyHosts().getSelectedItem() != null ? getProxyHosts().getSelectedItem().getId() : null);
            selectedImportVmModel = importFromExternalSourceModel;
            break;
        case OVA:
            importFromOvaModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            importFromOvaModel.setIsoName(getOvaPath().getEntity());
            importFromOvaModel.setHostId(getHosts().getSelectedItem().getId());
            selectedImportVmModel = importFromOvaModel;
            break;
        case XEN:
            importFromExternalSourceModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            importFromExternalSourceModel.setUrl(getXenUri().getEntity());
            // $NON-NLS-1$
            importFromExternalSourceModel.setUsername("");
            // $NON-NLS-1$
            importFromExternalSourceModel.setPassword("");
            importFromExternalSourceModel.setProxyHostId(getProxyHosts().getSelectedItem() != null ? getProxyHosts().getSelectedItem().getId() : null);
            selectedImportVmModel = importFromExternalSourceModel;
            break;
        default:
    }
    return selectedImportVmModel;
}
#method_after
public ImportVmModel getSpecificImportModel() {
    selectedImportVmModel = null;
    switch(importSources.getSelectedItem()) {
        case EXPORT_DOMAIN:
            importFromExportDomainModel.setEntity(null);
            importFromExportDomainModel.init(getVmsToImport(), exportDomain.getId());
            importFromExportDomainModel.setEntity(exportDomain.getId());
            selectedImportVmModel = importFromExportDomainModel;
            break;
        case VMWARE:
            importFromExternalSourceModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            importFromExternalSourceModel.setUrl(getUrl());
            importFromExternalSourceModel.setUsername(getUsername().getEntity());
            importFromExternalSourceModel.setPassword(getPassword().getEntity());
            importFromExternalSourceModel.setProxyHostId(getProxyHosts().getSelectedItem() != null ? getProxyHosts().getSelectedItem().getId() : null);
            selectedImportVmModel = importFromExternalSourceModel;
            break;
        case OVA:
            importFromOvaModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            importFromOvaModel.setIsoName(getOvaPath().getEntity());
            importFromOvaModel.setHostId(getHosts().getSelectedItem().getId());
            selectedImportVmModel = importFromOvaModel;
            break;
        case XEN:
            importFromExternalSourceModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            importFromExternalSourceModel.setUrl(getXenUri().getEntity());
            // $NON-NLS-1$
            importFromExternalSourceModel.setUsername("");
            // $NON-NLS-1$
            importFromExternalSourceModel.setPassword("");
            importFromExternalSourceModel.setProxyHostId(getXenProxyHosts().getSelectedItem() != null ? getXenProxyHosts().getSelectedItem().getId() : null);
            selectedImportVmModel = importFromExternalSourceModel;
            break;
        default:
    }
    return selectedImportVmModel;
}
#end_block

#method_before
private void vmwareProviderChanged() {
    Provider<VmwareVmProviderProperties> provider = getVmwareProviders().getSelectedItem();
    if (provider == null) {
        provider = new Provider<>();
        provider.setAdditionalProperties(new VmwareVmProviderProperties());
    }
    getUsername().setEntity(provider.getUsername());
    getPassword().setEntity(provider.getPassword());
    VmwareVmProviderProperties properties = (VmwareVmProviderProperties) provider.getAdditionalProperties();
    getvCenter().setEntity(properties.getvCenter());
    getEsx().setEntity(properties.getEsx());
    Pair<String, String> dcAndCluster = splitToDcAndCluster(properties.getDataCenter());
    getVmwareDatacenter().setEntity(dcAndCluster.getFirst());
    getVmwareCluster().setEntity(dcAndCluster.getSecond());
    getVerify().setEntity(properties.isVerifySSL());
    if (properties.getProxyHostId() == null) {
        getProxyHosts().setSelectedItem(null);
    } else {
        for (VDS host : getProxyHosts().getItems()) {
            if (host != null && host.getId().equals(properties.getProxyHostId())) {
                getProxyHosts().setSelectedItem(host);
                break;
            }
        }
    }
}
#method_after
private void vmwareProviderChanged() {
    Provider<VmwareVmProviderProperties> provider = getVmwareProviders().getSelectedItem();
    if (provider == null) {
        provider = new Provider<>();
        provider.setAdditionalProperties(new VmwareVmProviderProperties());
    }
    getUsername().setEntity(provider.getUsername());
    getPassword().setEntity(provider.getPassword());
    VmwareVmProviderProperties properties = provider.getAdditionalProperties();
    getvCenter().setEntity(properties.getvCenter());
    getEsx().setEntity(properties.getEsx());
    Pair<String, String> dcAndCluster = splitToDcAndCluster(properties.getDataCenter());
    getVmwareDatacenter().setEntity(dcAndCluster.getFirst());
    getVmwareCluster().setEntity(dcAndCluster.getSecond());
    getVerify().setEntity(properties.isVerifySSL());
    if (properties.getProxyHostId() == null) {
        getProxyHosts().setSelectedItem(null);
    } else {
        for (VDS host : getProxyHosts().getItems()) {
            if (host != null && host.getId().equals(properties.getProxyHostId())) {
                getProxyHosts().setSelectedItem(host);
                break;
            }
        }
    }
}
#end_block

#method_before
private void initDataCenters() {
    getDataCenters().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            StoragePool dataCenter = dataCenters.getSelectedItem();
            Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, new IdQueryParameters(dataCenter.getId()), new AsyncQuery(this, createGetStorageDomainsByStoragePoolIdCallback(dataCenter)));
        }
    });
    dataCenters.getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            AsyncQuery hostsQuery = new AsyncQuery();
            hostsQuery.setModel(ImportVmsModel.this);
            hostsQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    List<VDS> hosts = (List<VDS>) returnValue;
                    List<VDS> upHosts = filterUpHosts(hosts);
                    proxyHosts.setItems(addAnyHostInCluster(upHosts));
                    ImportVmsModel.this.hosts.setItems(upHosts);
                    stopProgress();
                }
            };
            AsyncDataProvider.getInstance().getHostListByDataCenter(hostsQuery, dataCenters.getSelectedItem().getId());
        }

        private List<VDS> filterUpHosts(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>();
            for (VDS host : hosts) {
                if (host.getStatus() == VDSStatus.Up) {
                    result.add(host);
                }
            }
            return result;
        }

        private List<VDS> addAnyHostInCluster(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>(hosts);
            // Any host in the cluster
            result.add(0, null);
            return result;
        }
    });
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final List<StoragePool> dataCenters = new ArrayList<>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (dataCenters == null || dataCenters.isEmpty()) {
                getDataCenters().setIsChangeable(false);
                getImportSources().setIsChangeable(false);
                setError(constants.notAvailableWithNoUpDC());
                stopProgress();
                return;
            }
            Collections.sort(dataCenters, new NameableComparator());
            ImportVmsModel.this.dataCenters.setItems(dataCenters);
        }
    }));
}
#method_after
private void initDataCenters() {
    getDataCenters().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            StoragePool dataCenter = dataCenters.getSelectedItem();
            Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, new IdQueryParameters(dataCenter.getId()), new AsyncQuery(this, createGetStorageDomainsByStoragePoolIdCallback(dataCenter)));
        }
    });
    dataCenters.getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            AsyncQuery hostsQuery = new AsyncQuery();
            hostsQuery.setModel(ImportVmsModel.this);
            hostsQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    List<VDS> hosts = (List<VDS>) returnValue;
                    List<VDS> upHosts = filterUpHosts(hosts);
                    proxyHosts.setItems(addAnyHostInCluster(upHosts));
                    xenProxyHosts.setItems(addAnyHostInCluster(upHosts));
                    ImportVmsModel.this.hosts.setItems(upHosts);
                    stopProgress();
                }
            };
            AsyncDataProvider.getInstance().getHostListByDataCenter(hostsQuery, dataCenters.getSelectedItem().getId());
        }

        private List<VDS> filterUpHosts(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>();
            for (VDS host : hosts) {
                if (host.getStatus() == VDSStatus.Up) {
                    result.add(host);
                }
            }
            return result;
        }

        private List<VDS> addAnyHostInCluster(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>(hosts);
            // Any host in the cluster
            result.add(0, null);
            return result;
        }
    });
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final List<StoragePool> dataCenters = new ArrayList<>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (dataCenters.isEmpty()) {
                getDataCenters().setIsChangeable(false);
                getImportSources().setIsChangeable(false);
                setError(constants.notAvailableWithNoUpDC());
                stopProgress();
                return;
            }
            Collections.sort(dataCenters, new NameableComparator());
            ImportVmsModel.this.dataCenters.setItems(dataCenters);
        }
    }));
}
#end_block

#method_before
public void loadVmsFromVmware() {
    clearProblem();
    if (!validateVmwareConfiguration()) {
        return;
    }
    loadVMsFromExternalProvider(OriginType.VMWARE, getUrl(), getUsername().getEntity(), getPassword().getEntity());
}
#method_after
public void loadVmsFromVmware() {
    clearProblem();
    if (!validateVmwareConfiguration()) {
        return;
    }
    Guid proxyId = getProxyHosts().getSelectedItem() != null ? getProxyHosts().getSelectedItem().getId() : null;
    loadVMsFromExternalProvider(OriginType.VMWARE, getUrl(), getUsername().getEntity(), getPassword().getEntity(), proxyId);
}
#end_block

#method_before
public void loadVmsFromXen() {
    clearProblem();
    if (!validateXenConfiguration()) {
        return;
    }
    // $NON-NLS-1$ //$NON-NLS-2$
    loadVMsFromExternalProvider(OriginType.XEN, getXenUri().getEntity(), "", "");
}
#method_after
public void loadVmsFromXen() {
    clearProblem();
    if (!validateXenConfiguration()) {
        return;
    }
    Guid proxyId = getXenProxyHosts().getSelectedItem() != null ? getXenProxyHosts().getSelectedItem().getId() : null;
    // $NON-NLS-1$ //$NON-NLS-2$
    loadVMsFromExternalProvider(OriginType.XEN, getXenUri().getEntity(), "", "", proxyId);
}
#end_block

#method_before
private void loadVMsFromExternalProvider(final OriginType type, String uri, String username, String password) {
    startProgress();
    AsyncQuery query = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            if (returnValue instanceof VdcQueryReturnValue) {
                setError(messages.providerFailure());
                stopProgress();
            } else {
                List<VM> remoteVms = (List<VM>) returnValue;
                List<VM> remoteDownVms = new ArrayList<>();
                for (VM vm : remoteVms) {
                    if (vm.isDown()) {
                        vm.setOrigin(type);
                        remoteDownVms.add(vm);
                    }
                }
                if (remoteVms.size() != remoteDownVms.size()) {
                    setWarning(constants.runningVmsWereFilteredOnImportVm());
                }
                updateVms(remoteDownVms);
            }
        }
    });
    query.setHandleFailure(true);
    AsyncDataProvider.getInstance().getVmsFromExternalServer(query, getDataCenters().getSelectedItem().getId(), getProxyHosts().getSelectedItem() != null ? getProxyHosts().getSelectedItem().getId() : null, uri, username, password);
}
#method_after
private void loadVMsFromExternalProvider(final OriginType type, String uri, String username, String password, Guid proxyId) {
    startProgress();
    AsyncQuery query = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            if (returnValue instanceof VdcQueryReturnValue) {
                setError(messages.providerFailure());
                stopProgress();
            } else {
                List<VM> remoteVms = (List<VM>) returnValue;
                List<VM> remoteDownVms = new ArrayList<>();
                for (VM vm : remoteVms) {
                    if (vm.isDown()) {
                        remoteDownVms.add(vm);
                    }
                }
                if (remoteVms.size() != remoteDownVms.size()) {
                    setWarning(constants.runningVmsWereFilteredOnImportVm());
                }
                updateVms(remoteDownVms);
            }
        }
    });
    query.setHandleFailure(true);
    AsyncDataProvider.getInstance().getVmsFromExternalServer(query, getDataCenters().getSelectedItem().getId(), proxyId, uri, username, password, type);
}
#end_block

#method_before
public ValidationResult canDisableVirtioScsi(Collection<? extends Disk> vmDisks) {
    if (vmDisks == null) {
        vmDisks = getDiskDao().getAllForVm(vms.iterator().next().getId(), true);
    }
    return vmDisks.stream().filter(d -> d.getDiskInterface() == DiskInterface.VirtIO_SCSI).findFirst().map(x -> new ValidationResult(EngineMessage.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS)).orElse(ValidationResult.VALID);
}
#method_after
public ValidationResult canDisableVirtioScsi(Collection<? extends Disk> vmDisks) {
    if (vmDisks == null) {
        vmDisks = getDiskDao().getAllForVm(vms.iterator().next().getId(), true);
    }
    boolean isVirtioScsiDiskExist = vmDisks.stream().anyMatch(d -> d.getDiskInterface() == DiskInterface.VirtIO_SCSI);
    if (isVirtioScsiDiskExist) {
        return new ValidationResult(EngineMessage.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private Guid getStorageDomainId(Guid poolId, StorageDomainType type, StorageDomainStatus status) {
    return getStorageDomains(poolId, type, status).stream().map(StorageDomain::getId).findFirst().orElse(Guid.Empty);
}
#method_after
private Guid getStorageDomainId(Guid poolId, StorageDomainType type, StorageDomainStatus status) {
    return getStorageDomains(poolId, type, status).stream().findFirst().map(StorageDomain::getId).orElse(Guid.Empty);
}
#end_block

#method_before
@Override
public void dataCenterWithClusterSelectedItemChanged() {
    super.dataCenterWithClusterSelectedItemChanged();
    if (getModel().getSelectedCluster() != null) {
        updateCpuProfile(getModel().getSelectedCluster().getId(), getCompatibilityVersion(), vm.getCpuProfileId());
    }
    if (getVm().getStatus().isSuspended() && !getModel().getSelectedCluster().getCompatibilityVersion().equals(getVm().getCompatibilityVersion())) {
        getModel().getEditingEnabled().setMessage(getModel().constants.suspendedVMsWhenClusterChange());
    }
}
#method_after
@Override
public void dataCenterWithClusterSelectedItemChanged() {
    super.dataCenterWithClusterSelectedItemChanged();
    if (getModel().getSelectedCluster() != null) {
        updateCpuProfile(getModel().getSelectedCluster().getId(), getCompatibilityVersion(), vm.getCpuProfileId());
        if (isInStateWithMemoryVolume(getVm()) && !isRestoreMemoryVolumeSupported()) {
            getModel().getEditingEnabled().setMessage(getModel().constants.suspendedVMsWhenClusterChange());
        }
    }
}
#end_block

#method_before
@Override
public void updateMinAllocatedMemory() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    Cluster cluster = dataCenterWithCluster.getCluster();
    if (cluster == null) {
        return;
    }
    if (getModel().getMemSize().getEntity() < vm.getVmMemSizeMb()) {
        double overCommitFactor = 100.0 / cluster.getMaxVdsMemoryOverCommit();
        getModel().getMinAllocatedMemory().setEntity((int) (getModel().getMemSize().getEntity() * overCommitFactor));
    } else {
        getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    }
}
#method_after
@Override
public void updateMinAllocatedMemory() {
    if (getModel().getMemSize().getEntity() == null) {
        return;
    }
    Cluster cluster = getModel().getSelectedCluster();
    if (cluster == null) {
        return;
    }
    double overCommitFactor = 100.0 / cluster.getMaxVdsMemoryOverCommit();
    getModel().getMinAllocatedMemory().setEntity((int) (getModel().getMemSize().getEntity() * overCommitFactor));
}
#end_block

#method_before
@Override
public boolean isApplicable(Cluster oldCluster, Cluster newCluster) {
    return !oldCluster.getCompatibilityVersion().equals(newCluster.getCompatibilityVersion());
}
#method_after
@Override
public boolean isApplicable(Cluster oldCluster, Cluster newCluster) {
    Version newClusterVersion = newCluster.getCompatibilityVersion();
    Version oldClusterVersion = oldCluster.getCompatibilityVersion();
    return !oldClusterVersion.equals(newClusterVersion);
}
#end_block

#method_before
@Override
public boolean check(VM vm) {
    return vm.getStatus().isSuspended();
}
#method_after
@Override
public boolean check(VM vm) {
    if (EnumSet.of(VMStatus.Suspended, VMStatus.SavingState, VMStatus.RestoringState).contains(vm.getStatus())) {
        return vm.getCustomCompatibilityVersion() != null;
    }
    return true;
}
#end_block

#method_before
@Override
public String getMainMessage() {
    return EngineMessage.CLUSTER_WARN_VM_DUE_TO_UNSUPPORTED_RESUME.name();
}
#method_after
@Override
public String getMainMessage() {
    return EngineMessage.CLUSTER_WARN_VM_DUE_TO_UNSUPPORTED_MEMORY_RESTORE.name();
}
#end_block

#method_before
private void assertReturnedRange(List<Range> ranges, MacsStorage macsStorage, List<Integer> expectedRangeIndices) {
    for (int expectedRangeIndex : expectedRangeIndices) {
        Range actualRange = macsStorage.getRangeWithAvailableMac();
        Range expectedRange = ranges.get(expectedRangeIndex);
        logger.info("expecting range {}, got {}", expectedRangeIndex, ranges.stream().map(Object::hashCode).collect(Collectors.toList()).indexOf(actualRange.hashCode()));
        assertThat(actualRange, new IsSame<>(expectedRange));
    }
}
#method_after
private void assertReturnedRange(List<Range> ranges, MacsStorage macsStorage, List<Integer> expectedRangeIndices) {
    for (int expectedRangeIndex : expectedRangeIndices) {
        Range actualRange = macsStorage.getRangeWithAvailableMac();
        Range expectedRange = ranges.get(expectedRangeIndex);
        assertThat(actualRange, new IsSame<>(expectedRange));
    }
}
#end_block

#method_before
private long findUnusedMac() {
    int index = usedMacs.nextClearBit(startingLocationWhenSearchingForUnusedMac);
    boolean notFound = index == numberOfMacsInRange;
    if (notFound) {
        index = usedMacs.nextClearBit(0);
    }
    startingLocationWhenSearchingForUnusedMac = index + 1;
    return rangeStart + index;
}
#method_after
private long findUnusedMac() {
    int index = usedMacs.nextClearBit(startingLocationWhenSearchingForUnusedMac);
    boolean notFound = index == numberOfMacsInRange;
    if (notFound) {
        index = usedMacs.nextClearBit(0);
    }
    startingLocationWhenSearchingForUnusedMac = (index + 1) % numberOfMacsInRange;
    return rangeStart + index;
}
#end_block

#method_before
Range getRangeWithAvailableMac() {
    int numberOfRanges = ranges.size();
    Range range = findRangeWithAvailableMac(startIndexForEmptyRangeSearch, numberOfRanges, numberOfRanges);
    if (range != null)
        return range;
    return findRangeWithAvailableMac(0, startIndexForEmptyRangeSearch, numberOfRanges);
// Integer firstRangeWithAvailableMacs = null;
// 
// for(int i = 0; i < ranges.size(); i++) {
// Range range = ranges.get(i);
// boolean hasAvailableMacs = range.getAvailableCount() > 0;
// if (!hasAvailableMacs) {
// continue;
// }
// 
// if (i> previouslyUsedRange) {
// previouslyUsedRange = i;
// return range;
// }
// 
// if (firstRangeWithAvailableMacs == null) {
// firstRangeWithAvailableMacs = i;
// }
// }
// 
// previouslyUsedRange = firstRangeWithAvailableMacs;
// return ranges.get(firstRangeWithAvailableMacs);
}
#method_after
Range getRangeWithAvailableMac() {
    int numberOfRanges = ranges.size();
    Range range = findRangeWithAvailableMac(startIndexForEmptyRangeSearch, numberOfRanges, numberOfRanges);
    if (range != null) {
        return range;
    }
    return findRangeWithAvailableMac(0, startIndexForEmptyRangeSearch, numberOfRanges);
}
#end_block

#method_before
private void allocateAndFreeMacAndExpectGivenMac(Range range, long expectedMac) {
    Long mac = range.allocateMacs(1).get(0);
    logger.info("expecting that MAC {} should be obtained, got {}", expectedMac, mac);
    assertThat(mac, is(expectedMac));
    range.freeMac(mac);
}
#method_after
private void allocateAndFreeMacAndExpectGivenMac(Range range, long expectedMac) {
    Long mac = range.allocateMacs(1).get(0);
    assertThat(mac, is(expectedMac));
    range.freeMac(mac);
}
#end_block

#method_before
private void setDefaultBootDevice() {
    boolean hasBootDevice = vmBase.getManagedDeviceMap().values().stream().anyMatch(device -> device.getBootOrder() > 0);
    if (hasBootDevice) {
        return;
    }
    final int[] order = new int[] { 1 };
    _images.stream().filter(DiskImage::isBoot).map(image -> vmBase.getManagedDeviceMap().get(image.getId())).filter(Objects::nonNull).forEachOrdered(device -> device.setBootOrder(order[0]++));
}
#method_after
private void setDefaultBootDevice() {
    boolean hasBootDevice = vmBase.getManagedDeviceMap().values().stream().anyMatch(device -> device.getBootOrder() > 0);
    if (hasBootDevice) {
        return;
    }
    // regular non-final variable cannot be used in lambda expression
    AtomicInteger order = new AtomicInteger(1);
    _images.stream().filter(DiskImage::isBoot).map(image -> vmBase.getManagedDeviceMap().get(image.getId())).filter(Objects::nonNull).forEachOrdered(device -> device.setBootOrder(order.getAndIncrement()));
}
#end_block

#method_before
boolean validate() {
    getTemplateName().validateEntity(new IValidation[] { new LengthValidation(BusinessEntitiesDefinitions.VM_TEMPLATE_NAME_SIZE), new I18NNameValidation() {

        @Override
        protected String end() {
            // $NON-NLS-1$
            return "]*$";
        }
    } });
    return getTemplateName().getIsValid();
}
#method_after
public boolean validate() {
    getTemplateName().validateEntity(new IValidation[] { new LengthValidation(BusinessEntitiesDefinitions.VM_TEMPLATE_NAME_SIZE), new I18NExtraNameOrNoneValidation() });
    return getTemplateName().getIsValid();
}
#end_block

#method_before
@Override
public void edit(final ImportExportRepoImageBaseModel model) {
    driver.edit(model);
    importAsTemplateEditor.setVisible(model.isImportModel());
    clusterEditor.setVisible(model.isImportModel());
    templateNameEditor.setVisible(model.isImportModel());
    model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (// $NON-NLS-1$
            "ImportExportEntities".equals(args.propertyName) && model.getEntities() != null) {
                imageList.setRowData(model.getEntities());
            }
        }
    });
    initTable(model);
}
#method_after
@Override
public void edit(final ImportExportRepoImageBaseModel model) {
    driver.edit(model);
    importAsTemplateEditor.setVisible(model.isImportModel());
    clusterEditor.setVisible(model.isImportModel());
    model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (// $NON-NLS-1$
            "ImportExportEntities".equals(args.propertyName) && model.getEntities() != null) {
                imageList.setRowData(model.getEntities());
            }
        }
    });
    initTable(model);
}
#end_block

#method_before
private void initTable(ImportExportRepoImageBaseModel model) {
    imageList = new EntityModelCellTable<>(SelectionMode.NONE, true);
    imageList.enableColumnResizing();
    imageList.addColumn(new AbstractEntityModelTextColumn<Object>() {

        @Override
        public String getText(Object image) {
            if (image instanceof RepoImage) {
                return ((RepoImage) image).getRepoImageTitle();
            } else if (image instanceof DiskImage) {
                return ((DiskImage) image).getDiskAlias();
            }
            return constants.unknown();
        }
    }, constants.fileNameIso(), // $NON-NLS-1$
    "150px");
    if (model.isImportModel()) {
        imageList.addColumn(new DiskAliasTextColumn(new DiskAliasFieldUpdater()), templates.sub(constants.diskSnapshotAlias(), constants.clickToEdit()), // $NON-NLS-1$
        "150px");
    }
    imageList.addColumn(new AbstractEntityModelTextColumn<Object>() {

        @Override
        public String getText(Object image) {
            if (image instanceof RepoImage) {
                return ((RepoImage) image).getFileType().toString();
            } else if (image instanceof DiskImage) {
                return ImageFileType.Disk.toString();
            }
            return constants.unknown();
        }
    }, constants.typeIso(), // $NON-NLS-1$
    "100px");
    imageList.addColumn(new AbstractDiskSizeColumn<EntityModel>(SizeConverter.SizeUnit.BYTES) {

        @Override
        protected Long getRawValue(EntityModel object) {
            if (object.getEntity() instanceof RepoImage) {
                return ((RepoImage) object.getEntity()).getSize();
            } else if (object.getEntity() instanceof DiskImage) {
                return ((DiskImage) (object.getEntity())).getSize();
            }
            return null;
        }
    }, constants.actualSizeTemplate(), // $NON-NLS-1$
    "100px");
    // $NON-NLS-1$
    imageList.setWidth("100%", true);
    imageListPanel.setWidget(imageList);
}
#method_after
private void initTable(ImportExportRepoImageBaseModel model) {
    imageList = new EntityModelCellTable<>(SelectionMode.NONE, true);
    imageList.enableColumnResizing();
    imageList.addColumn(new AbstractEntityModelTextColumn<Object>() {

        @Override
        public String getText(Object image) {
            if (image instanceof RepoImage) {
                return ((RepoImage) image).getRepoImageTitle();
            } else if (image instanceof DiskImage) {
                return ((DiskImage) image).getDiskAlias();
            }
            return constants.unknown();
        }
    }, constants.fileNameIso(), // $NON-NLS-1$
    "150px");
    if (model.isImportModel()) {
        imageList.addColumn(new DiskAliasTextColumn(new DiskAliasFieldUpdater()), templates.sub(constants.diskSnapshotAlias(), constants.clickToEdit()), // $NON-NLS-1$
        "150px");
    }
    imageList.addColumn(new AbstractEntityModelTextColumn<Object>() {

        @Override
        public String getText(Object image) {
            if (image instanceof RepoImage) {
                return ((RepoImage) image).getFileType().toString();
            } else if (image instanceof DiskImage) {
                return ImageFileType.Disk.toString();
            }
            return constants.unknown();
        }
    }, constants.typeIso(), // $NON-NLS-1$
    "100px");
    imageList.addColumn(new AbstractDiskSizeColumn<EntityModel>(SizeConverter.SizeUnit.BYTES) {

        @Override
        protected Long getRawValue(EntityModel object) {
            if (object.getEntity() instanceof RepoImage) {
                return ((RepoImage) object.getEntity()).getSize();
            } else if (object.getEntity() instanceof DiskImage) {
                return ((DiskImage) object.getEntity()).getSize();
            }
            return null;
        }
    }, constants.actualSizeTemplate(), // $NON-NLS-1$
    "100px");
    // $NON-NLS-1$
    imageList.setWidth("100%", true);
    imageListPanel.setWidget(imageList);
}
#end_block

#method_before
private static NetworkOperation binaryOperationWithNetworkInterfaceModelAsSecondOperand(NetworkItemModel<?> op1, NetworkInterfaceModel dst) {
    // first collect the networks into one set
    Set<LogicalNetworkModel> networks = new HashSet<>();
    networks.addAll(dst.getItems());
    // op1 is a NIC, verify that it isn't already part of a bond or dragged unto itself
    if (op1 instanceof NetworkInterfaceModel) {
        NetworkInterfaceModel src = (NetworkInterfaceModel) op1;
        if (src.isBonded() || src.equals(dst)) {
            return NetworkOperation.NULL_OPERATION;
        }
        networks.addAll(src.getItems());
    } else if (op1 instanceof LogicalNetworkModel) {
        // op1 is a network, verify that it isn't dragged unto the NIC already containing it
        if (!networks.add((LogicalNetworkModel) op1)) {
            return NetworkOperation.NULL_OPERATION;
        }
    } else if (op1 instanceof NetworkLabelModel) {
        // op1 is a label, verify that it's not applied to the interface already labelled by it
        NetworkLabelModel src = (NetworkLabelModel) op1;
        if (dst.equals(src.getInterface())) {
            return NetworkOperation.NULL_OPERATION;
        }
        networks.addAll(src.getNetworks());
    }
    final String hostMaxSupportedClusterVersion = getClusterCompatibilityVersion(op1);
    final boolean permissiveValidation = AsyncDataProvider.getInstance().isNetworkExclusivenessPermissiveValidation(hostMaxSupportedClusterVersion);
    // go over the networks and check whether they comply, if not - the reason is important
    boolean vlanFound = false;
    String nonVlanVmNetwork = null;
    int nonVlanCounter = 0;
    for (LogicalNetworkModel network : networks) {
        if (!network.isManaged()) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_UNMANAGED;
            }
            if (op1.aggregatesNetworks()) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BATCH_UNMANAGED;
            }
        } else {
            if (!network.isInSync()) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_OUT_OF_SYNC;
                }
                if (op1.aggregatesNetworks()) {
                    dst.setCulpritNetwork(network.getName());
                    return NetworkOperation.NULL_OPERATION_BATCH_OUT_OF_SYNC;
                }
            }
        }
        if (network.hasVlan()) {
            vlanFound = true;
        } else {
            ++nonVlanCounter;
            if (network.getNetwork().isVmNetwork()) {
                nonVlanVmNetwork = network.getName();
            }
        }
        if (nonVlanCounter > 1) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_TOO_MANY_NON_VLANS;
            }
            if (op1.aggregatesNetworks()) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BATCH_TOO_MANY_NON_VLANS;
            }
        } else {
            if (!permissiveValidation && nonVlanVmNetwork != null && vlanFound) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_VM_WITH_VLANS;
                }
                if (op1.aggregatesNetworks()) {
                    dst.setCulpritNetwork(nonVlanVmNetwork);
                    return NetworkOperation.NULL_OPERATION_BATCH_VM_WITH_VLANS;
                }
            }
        }
        if (network.getNetwork().isVmNetwork()) {
            if (dst instanceof BondNetworkInterfaceModel) {
                if (!BondMode.isBondModeValidForVmNetwork(dst.getIface().getBondOptions())) {
                    return NetworkOperation.NULL_OPERATION_INVALID_BOND_MODE;
                }
            }
        }
    }
    // networks comply, all that's left is to return the correct operation
    if (op1 instanceof LogicalNetworkModel) {
        return NetworkOperation.ATTACH_NETWORK;
    }
    if (op1 instanceof BondNetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.JOIN_BONDS;
        } else {
            return NetworkOperation.EXTEND_BOND_WITH;
        }
    }
    if (op1 instanceof NetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.ADD_TO_BOND;
        } else {
            return NetworkOperation.BOND_WITH;
        }
    }
    if (op1 instanceof NetworkLabelModel) {
        return NetworkOperation.LABEL;
    }
    return NetworkOperation.NULL_OPERATION;
}
#method_after
private static NetworkOperation binaryOperationWithNetworkInterfaceModelAsSecondOperand(NetworkItemModel<?> op1, NetworkInterfaceModel dst) {
    // first collect the networks into one set
    Set<LogicalNetworkModel> networks = new HashSet<>();
    networks.addAll(dst.getItems());
    // op1 is a NIC, verify that it isn't already part of a bond or dragged unto itself
    if (op1 instanceof NetworkInterfaceModel) {
        NetworkInterfaceModel src = (NetworkInterfaceModel) op1;
        if (src.isBonded() || src.equals(dst)) {
            return NetworkOperation.NULL_OPERATION;
        }
        networks.addAll(src.getItems());
    } else if (op1 instanceof LogicalNetworkModel) {
        // op1 is a network, verify that it isn't dragged unto the NIC already containing it
        if (!networks.add((LogicalNetworkModel) op1)) {
            return NetworkOperation.NULL_OPERATION;
        }
    } else if (op1 instanceof NetworkLabelModel) {
        // op1 is a label, verify that it's not applied to the interface already labelled by it
        NetworkLabelModel src = (NetworkLabelModel) op1;
        if (dst.equals(src.getInterface())) {
            return NetworkOperation.NULL_OPERATION;
        }
        networks.addAll(src.getNetworks());
    }
    final String clusterCompatibilityVersion = getClusterCompatibilityVersion(op1);
    final boolean permissiveValidation = AsyncDataProvider.getInstance().isNetworkExclusivenessPermissiveValidation(clusterCompatibilityVersion);
    // go over the networks and check whether they comply, if not - the reason is important
    boolean vlanFound = false;
    String nonVlanVmNetwork = null;
    int nonVlanCounter = 0;
    for (LogicalNetworkModel network : networks) {
        if (!network.isManaged()) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_UNMANAGED;
            }
            if (op1.aggregatesNetworks()) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BATCH_UNMANAGED;
            }
        } else {
            if (!network.isInSync()) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_OUT_OF_SYNC;
                }
                if (op1.aggregatesNetworks()) {
                    dst.setCulpritNetwork(network.getName());
                    return NetworkOperation.NULL_OPERATION_BATCH_OUT_OF_SYNC;
                }
            }
        }
        if (network.hasVlan()) {
            vlanFound = true;
        } else {
            ++nonVlanCounter;
            if (network.getNetwork().isVmNetwork()) {
                nonVlanVmNetwork = network.getName();
            }
        }
        if (nonVlanCounter > 1) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_TOO_MANY_NON_VLANS;
            }
            if (op1.aggregatesNetworks()) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BATCH_TOO_MANY_NON_VLANS;
            }
        } else {
            if (!permissiveValidation && nonVlanVmNetwork != null && vlanFound) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_VM_WITH_VLANS;
                }
                if (op1.aggregatesNetworks()) {
                    dst.setCulpritNetwork(nonVlanVmNetwork);
                    return NetworkOperation.NULL_OPERATION_BATCH_VM_WITH_VLANS;
                }
            }
        }
        if (network.getNetwork().isVmNetwork()) {
            if (dst instanceof BondNetworkInterfaceModel) {
                if (!BondMode.isBondModeValidForVmNetwork(dst.getIface().getBondOptions())) {
                    return NetworkOperation.NULL_OPERATION_INVALID_BOND_MODE;
                }
            }
        }
    }
    // networks comply, all that's left is to return the correct operation
    if (op1 instanceof LogicalNetworkModel) {
        return NetworkOperation.ATTACH_NETWORK;
    }
    if (op1 instanceof BondNetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.JOIN_BONDS;
        } else {
            return NetworkOperation.EXTEND_BOND_WITH;
        }
    }
    if (op1 instanceof NetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.ADD_TO_BOND;
        } else {
            return NetworkOperation.BOND_WITH;
        }
    }
    if (op1 instanceof NetworkLabelModel) {
        return NetworkOperation.LABEL;
    }
    return NetworkOperation.NULL_OPERATION;
}
#end_block

#method_before
public boolean canRunVm(List<String> messages, StoragePool storagePool, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, List<Guid> destVdsList, VDSGroup vdsGroup) {
    if (vm.getStatus() == VMStatus.Paused) {
        // as the rest of the checks were already checked before
        return validate(validateVdsStatus(vm), messages);
    } else if (vm.getStatus() == VMStatus.Suspended) {
        return validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStorageDomains(vm, isInternalExecution, filterReadOnlyAndPreallocatedDisks(getVmImageDisks())), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && getSchedulingManager().canSchedule(vdsGroup, vm, vdsBlackList, vdsWhiteList, destVdsList, messages);
    }
    return validateVmProperties(vm, runVmParam.getCustomProperties(), messages) && validate(validateBootSequence(vm, runVmParam.getBootSequence(), getVmDisks(), activeIsoDomainId), messages) && validate(validateDisplayType(), messages) && validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(validateIsoPath(vm, runVmParam.getDiskPath(), runVmParam.getFloppyPath(), activeIsoDomainId), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStatelessVm(vm, runVmParam.getRunAsStateless()), messages) && validate(validateFloppy(), messages) && validate(validateStorageDomains(vm, isInternalExecution, filterReadOnlyAndPreallocatedDisks(getVmImageDisks())), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && validate(validateMemorySize(vm), messages) && getSchedulingManager().canSchedule(vdsGroup, vm, vdsBlackList, vdsWhiteList, destVdsList, messages);
}
#method_after
public boolean canRunVm(List<String> messages, StoragePool storagePool, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, List<Guid> destVdsList, Cluster cluster) {
    if (vm.getStatus() == VMStatus.Paused) {
        // as the rest of the checks were already checked before
        return validate(validateVdsStatus(vm), messages);
    } else if (vm.getStatus() == VMStatus.Suspended) {
        return validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStorageDomains(vm, isInternalExecution, filterReadOnlyAndPreallocatedDisks(getVmImageDisks())), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && getSchedulingManager().canSchedule(cluster, vm, vdsBlackList, vdsWhiteList, destVdsList, messages);
    }
    return validateVmProperties(vm, runVmParam.getCustomProperties(), messages) && validate(validateBootSequence(vm, runVmParam.getBootSequence(), getVmDisks(), activeIsoDomainId), messages) && validate(validateDisplayType(), messages) && validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(validateIsoPath(vm, runVmParam.getDiskPath(), runVmParam.getFloppyPath(), activeIsoDomainId), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStatelessVm(vm, runVmParam.getRunAsStateless()), messages) && validate(validateFloppy(), messages) && validate(validateStorageDomains(vm, isInternalExecution, filterReadOnlyAndPreallocatedDisks(getVmImageDisks())), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && validate(validateMemorySize(vm), messages) && getSchedulingManager().canSchedule(cluster, vm, vdsBlackList, vdsWhiteList, destVdsList, messages);
}
#end_block

#method_before
protected ValidationResult validateMemorySize(VM vm) {
    int maxSize;
    if (getOsRepository().get64bitOss().contains(vm.getOs())) {
        ConfigValues config = vm.getClusterArch() == ArchitectureType.ppc64 ? ConfigValues.VMPpc64BitMaxMemorySizeInMB : ConfigValues.VM64BitMaxMemorySizeInMB;
        maxSize = Config.getValue(config, vm.getVdsGroupCompatibilityVersion().getValue());
    } else {
        maxSize = Config.getValue(ConfigValues.VM32BitMaxMemorySizeInMB);
    }
    if (vm.getMemSizeMb() > maxSize) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_MEMORY_EXCEEDS_SUPPORTED_LIMIT);
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult validateMemorySize(VM vm) {
    int maxSize;
    if (getOsRepository().get64bitOss().contains(vm.getOs())) {
        ConfigValues config = vm.getClusterArch() == ArchitectureType.ppc64 ? ConfigValues.VMPpc64BitMaxMemorySizeInMB : ConfigValues.VM64BitMaxMemorySizeInMB;
        maxSize = Config.getValue(config, vm.getCompatibilityVersion().getValue());
    } else {
        maxSize = Config.getValue(ConfigValues.VM32BitMaxMemorySizeInMB);
    }
    if (vm.getMemSizeMb() > maxSize) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_MEMORY_EXCEEDS_SUPPORTED_LIMIT);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult validateFloppy() {
    if (StringUtils.isNotEmpty(runVmParam.getFloppyPath()) && !VmValidationUtils.isFloppySupported(vm.getOs(), vm.getVdsGroupCompatibilityVersion())) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_FLOPPY_IS_NOT_SUPPORTED_BY_OS);
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult validateFloppy() {
    if (StringUtils.isNotEmpty(runVmParam.getFloppyPath()) && !VmValidationUtils.isFloppySupported(vm.getOs(), vm.getCompatibilityVersion())) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_FLOPPY_IS_NOT_SUPPORTED_BY_OS);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
protected ValidationResult validateDisplayType() {
    if (!VmValidationUtils.isGraphicsAndDisplaySupported(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), getVmActiveGraphics(), vm.getDefaultDisplayType())) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_VM_DISPLAY_TYPE_IS_NOT_SUPPORTED_BY_OS);
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult validateDisplayType() {
    if (!VmValidationUtils.isGraphicsAndDisplaySupported(vm.getOs(), vm.getCompatibilityVersion(), getVmActiveGraphics(), vm.getDefaultDisplayType())) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_VM_DISPLAY_TYPE_IS_NOT_SUPPORTED_BY_OS);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
protected boolean validateVmProperties(VM vm, String runOnceCustomProperties, List<String> messages) {
    String customProperties = runOnceCustomProperties != null ? runOnceCustomProperties : vm.getCustomProperties();
    return getVmPropertiesUtils().validateVmProperties(vm.getVdsGroupCompatibilityVersion(), customProperties, messages);
}
#method_after
protected boolean validateVmProperties(VM vm, String runOnceCustomProperties, List<String> messages) {
    String customProperties = runOnceCustomProperties != null ? runOnceCustomProperties : vm.getCustomProperties();
    return getVmPropertiesUtils().validateVmProperties(vm.getCompatibilityVersion(), customProperties, messages);
}
#end_block

#method_before
protected ValidationResult validateInterfacesConfigured(VM vm) {
    for (VmNetworkInterface nic : vm.getInterfaces()) {
        if (nic.getVnicProfileId() == null) {
            return FeatureSupported.networkLinking(vm.getVdsGroupCompatibilityVersion()) ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_INTERFACE_NETWORK_NOT_CONFIGURED);
        }
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult validateInterfacesConfigured(VM vm) {
    for (VmNetworkInterface nic : vm.getInterfaces()) {
        if (nic.getVnicProfileId() == null) {
            return FeatureSupported.networkLinking(vm.getClusterCompatibilityVersion()) ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_INTERFACE_NETWORK_NOT_CONFIGURED);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
protected ValidationResult validateInterfacesAttachedToClusterNetworks(VM vm, final Set<String> clusterNetworkNames, final Set<String> interfaceNetworkNames) {
    Set<String> result = new HashSet<>(interfaceNetworkNames);
    result.removeAll(clusterNetworkNames);
    if (FeatureSupported.networkLinking(vm.getVdsGroupCompatibilityVersion())) {
        result.remove(null);
    }
    // aren't attached to the cluster
    return result.isEmpty() ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_NOT_IN_CLUSTER, String.format("$networks %1$s", StringUtils.join(result, ",")));
}
#method_after
protected ValidationResult validateInterfacesAttachedToClusterNetworks(VM vm, final Set<String> clusterNetworkNames, final Set<String> interfaceNetworkNames) {
    Set<String> result = new HashSet<>(interfaceNetworkNames);
    result.removeAll(clusterNetworkNames);
    if (FeatureSupported.networkLinking(vm.getClusterCompatibilityVersion())) {
        result.remove(null);
    }
    // aren't attached to the cluster
    return result.isEmpty() ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_NOT_IN_CLUSTER, String.format("$networks %1$s", StringUtils.join(result, ",")));
}
#end_block

#method_before
private List<Network> getClusterNetworks() {
    if (cachedClusterNetworks == null) {
        cachedClusterNetworks = getNetworkDao().getAllForCluster(vm.getVdsGroupId());
    }
    return cachedClusterNetworks;
}
#method_after
private List<Network> getClusterNetworks() {
    if (cachedClusterNetworks == null) {
        cachedClusterNetworks = getNetworkDao().getAllForCluster(vm.getClusterId());
    }
    return cachedClusterNetworks;
}
#end_block

#method_before
@Override
protected void commonInitialize() {
    super.commonInitialize();
    getModel().getIsStateless().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getModel().getTemplateWithVersion() == null || getModel().getTemplateWithVersion().getItems() == null || getModel().getTemplateWithVersion().getSelectedItem() == null) {
                return;
            }
            List<VmTemplate> baseTemplates = new ArrayList<>();
            for (TemplateWithVersion templateWithVersion : getModel().getTemplateWithVersion().getItems()) {
                if (templateWithVersion.isLatest()) {
                    continue;
                }
                baseTemplates.add(templateWithVersion.getBaseTemplate());
            }
            TemplateWithVersion selectedItemTemplateWithVersion = getModel().getTemplateWithVersion().getSelectedItem();
            VmTemplate selectedTemplateWithVersion = selectedItemTemplateWithVersion.getTemplateVersion();
            if (selectedTemplateWithVersion == null) {
                return;
            }
            Guid selectedId = selectedTemplateWithVersion.getId();
            // will be moved back in the callback which can be async
            updateStatelessFlag = false;
            initTemplateWithVersion(baseTemplates, selectedId, selectedItemTemplateWithVersion.isLatest(), getModel().getIsStateless().getEntity());
        }
    });
}
#method_after
@Override
protected void commonInitialize() {
    super.commonInitialize();
    getModel().getIsStateless().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getModel().getTemplateWithVersion() == null || getModel().getTemplateWithVersion().getItems() == null || getModel().getTemplateWithVersion().getSelectedItem() == null) {
                return;
            }
            List<VmTemplate> baseTemplates = new ArrayList<>();
            for (TemplateWithVersion templateWithVersion : getModel().getTemplateWithVersion().getItems()) {
                if (templateWithVersion.isLatest() || templateWithVersion.getTemplateVersion() == null) {
                    continue;
                }
                baseTemplates.add(templateWithVersion.getTemplateVersion());
            }
            TemplateWithVersion selectedItemTemplateWithVersion = getModel().getTemplateWithVersion().getSelectedItem();
            VmTemplate selectedTemplateWithVersion = selectedItemTemplateWithVersion.getTemplateVersion();
            if (selectedTemplateWithVersion == null) {
                return;
            }
            Guid selectedId = selectedTemplateWithVersion.getId();
            // will be moved back in the callback which can be async
            updateStatelessFlag = false;
            initTemplateWithVersion(baseTemplates, selectedId, selectedItemTemplateWithVersion.isLatest(), getModel().getIsStateless().getEntity());
        }
    });
}
#end_block

#method_before
@Override
public void updateMinAllocatedMemory() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    Cluster cluster = dataCenterWithCluster == null ? null : dataCenterWithCluster.getCluster();
    if (cluster == null) {
        return;
    }
    double overCommitFactor = 100.0 / cluster.getMaxVdsMemoryOverCommit();
    getModel().getMinAllocatedMemory().setEntity((int) (getModel().getMemSize().getEntity() * overCommitFactor));
}
#method_after
@Override
public void updateMinAllocatedMemory() {
    if (getModel().getMemSize().getEntity() == null) {
        return;
    }
    final Cluster cluster = getModel().getSelectedCluster();
    if (cluster == null) {
        return;
    }
    double overCommitFactor = 100.0 / cluster.getMaxVdsMemoryOverCommit();
    getModel().getMinAllocatedMemory().setEntity((int) (getModel().getMemSize().getEntity() * overCommitFactor));
}
#end_block

#method_before
@Theory
public void testGetFailedVolumeIds(List<Guid> failedVolumes) {
    DestroyImageParameters params = new DestroyImageParameters(Guid.newGuid(), Guid.newGuid(), Guid.newGuid(), Guid.newGuid(), Guid.newGuid(), ALL_VOLUMES, false, false);
    DestroyImageCheckCommand cmd = spy(new DestroyImageCheckCommand<>(params));
    for (Guid volumeId : ALL_VOLUMES) {
        GetVolumeInfoVDSCommandParameters vdsParams = new GetVolumeInfoVDSCommandParameters(params.getVdsId(), params.getStoragePoolId(), params.getStorageDomainId(), params.getImageGroupId(), volumeId);
        if (failedVolumes.contains(volumeId)) {
            doReturn(null).when(cmd).runVdsCommand(VDSCommandType.GetVolumeInfo, vdsParams);
        } else {
            doThrow(new EngineException(EngineError.VolumeDoesNotExist)).when(cmd).runVdsCommand(VDSCommandType.GetVolumeInfo, vdsParams);
        }
    }
    assertEquals(cmd.getFailedVolumeIds(), failedVolumes);
}
#method_after
@Theory
public void testGetFailedVolumeIds(List<Guid> failedVolumes) {
    DestroyImageParameters params = new DestroyImageParameters(Guid.newGuid(), Guid.newGuid(), Guid.newGuid(), Guid.newGuid(), Guid.newGuid(), ALL_VOLUMES, false, false);
    DestroyImageCheckCommand<DestroyImageParameters> cmd = spy(new DestroyImageCheckCommand<>(params, null));
    for (Guid volumeId : ALL_VOLUMES) {
        GetVolumeInfoVDSCommandParameters vdsParams = new GetVolumeInfoVDSCommandParameters(params.getVdsId(), params.getStoragePoolId(), params.getStorageDomainId(), params.getImageGroupId(), volumeId);
        if (failedVolumes.contains(volumeId)) {
            doReturn(null).when(cmd).runVdsCommand(eq(VDSCommandType.GetVolumeInfo), refEq(vdsParams));
        } else {
            doThrow(new EngineException(EngineError.VolumeDoesNotExist)).when(cmd).runVdsCommand(eq(VDSCommandType.GetVolumeInfo), refEq(vdsParams));
        }
    }
    assertEquals(cmd.getFailedVolumeIds(), failedVolumes);
}
#end_block

#method_before
@Override
protected boolean validate() {
    GlusterVolumeEntity volume = getGlusterVolume();
    if (!super.validate()) {
        return false;
    }
    if (!validate(getBrickValidator().canStopOrCommitRemoveBrick(volume, getParameters().getBricks()))) {
        return false;
    }
    if (!(getGlusterTaskUtils().isTaskOfType(volume, GlusterTaskType.REMOVE_BRICK)) || !(getGlusterTaskUtils().isTaskStatus(volume, JobExecutionStatus.STARTED) || getGlusterTaskUtils().isTaskStatus(volume, JobExecutionStatus.FINISHED))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REMOVE_BRICKS_NOT_STARTED);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    GlusterVolumeEntity volume = getGlusterVolume();
    if (!super.validate()) {
        return false;
    }
    if (!validate(getBrickValidator().canStopOrCommitRemoveBrick(volume, getParameters().getBricks()))) {
        return false;
    }
    if (!getGlusterTaskUtils().isTaskOfType(volume, GlusterTaskType.REMOVE_BRICK) || !(getGlusterTaskUtils().isTaskStatus(volume, JobExecutionStatus.STARTED) || getGlusterTaskUtils().isTaskStatus(volume, JobExecutionStatus.FINISHED))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REMOVE_BRICKS_NOT_STARTED);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    GlusterVolumeEntity glusterVolume = getGlusterVolume();
    if (!super.validate()) {
        return false;
    }
    if (!(getGlusterTaskUtils().isTaskOfType(glusterVolume, GlusterTaskType.REBALANCE)) || !(getGlusterTaskUtils().isTaskStatus(glusterVolume, JobExecutionStatus.STARTED))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REBALANCE_NOT_STARTED);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    GlusterVolumeEntity glusterVolume = getGlusterVolume();
    if (!super.validate()) {
        return false;
    }
    if (!getGlusterTaskUtils().isTaskOfType(glusterVolume, GlusterTaskType.REBALANCE) || !getGlusterTaskUtils().isTaskStatus(glusterVolume, JobExecutionStatus.STARTED)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REBALANCE_NOT_STARTED);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.ResetGlusterVolumeOptions, new ResetGlusterVolumeOptionsVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().getVolumeOption(), getParameters().isForceAction()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        if (getParameters().getVolumeOption() != null && !(getParameters().getVolumeOption().getKey().isEmpty())) {
            GlusterVolumeOptionEntity entity = getGlusterVolume().getOption(getParameters().getVolumeOption().getKey());
            isResetAllOptions = false;
            if (entity != null) {
                removeOptionInDb(entity);
                String optionValue = entity.getValue();
                getParameters().getVolumeOption().setValue(optionValue != null ? optionValue : "");
                addCustomValue(GlusterConstants.OPTION_KEY, getParameters().getVolumeOption().getKey());
                addCustomValue(GlusterConstants.OPTION_VALUE, getParameters().getVolumeOption().getValue());
            }
        } else {
            for (GlusterVolumeOptionEntity option : getGlusterVolume().getOptions()) {
                removeOptionInDb(option);
            }
            isResetAllOptions = true;
        }
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.ResetGlusterVolumeOptions, new ResetGlusterVolumeOptionsVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().getVolumeOption(), getParameters().isForceAction()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        if (getParameters().getVolumeOption() != null && !getParameters().getVolumeOption().getKey().isEmpty()) {
            GlusterVolumeOptionEntity entity = getGlusterVolume().getOption(getParameters().getVolumeOption().getKey());
            isResetAllOptions = false;
            if (entity != null) {
                removeOptionInDb(entity);
                String optionValue = entity.getValue();
                getParameters().getVolumeOption().setValue(optionValue != null ? optionValue : "");
                addCustomValue(GlusterConstants.OPTION_KEY, getParameters().getVolumeOption().getKey());
                addCustomValue(GlusterConstants.OPTION_VALUE, getParameters().getVolumeOption().getValue());
            }
        } else {
            for (GlusterVolumeOptionEntity option : getGlusterVolume().getOptions()) {
                removeOptionInDb(option);
            }
            isResetAllOptions = true;
        }
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        return (isResetAllOptions) ? AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_ALL : AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET;
    } else {
        return errorType == null ? AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED : errorType;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        return isResetAllOptions ? AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_ALL : AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET;
    } else {
        return errorType == null ? AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED : errorType;
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new EngineException(EngineError.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVdsStaticToDb();
        addVdsDynamicToDb();
        addVdsStatisticsToDb();
        getCompensationContext().stateChanged();
        return null;
    });
    if (getParameters().isProvisioned()) {
        HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(getHostProvider()));
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword(), getParameters().getDiscoverIp());
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVds(getParameters().getvds());
        logable.addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        auditLogDirector.log(logable, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getCluster().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        initializeVds(true);
        alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
        testVdsPowerManagementStatus(getParameters().getVdsStaticData());
        setSucceeded(true);
        setActionReturnValue(getVdsIdRef());
        // If the installation failed, we don't want to compensate for the failure since it will remove the
        // host, but instead the host should be left in an "install failed" status.
        getCompensationContext().resetCompensation();
        return null;
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().isPending() && !getParameters().isProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setNetworkProviderId(getParameters().getNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        installVdsParameters.setEnableSerialConsole(getParameters().getEnableSerialConsole());
        Map<String, String> values = new HashMap<>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(() -> runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx)));
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new EngineException(EngineError.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVdsStaticToDb();
        addVdsDynamicToDb();
        addVdsStatisticsToDb();
        getCompensationContext().stateChanged();
        return null;
    });
    if (getParameters().isProvisioned()) {
        HostProviderProxy proxy = ProviderProxyFactory.getInstance().create(getHostProvider());
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword(), getParameters().getDiscoverIp());
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVds(getParameters().getvds());
        logable.addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        auditLogDirector.log(logable, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getCluster().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        initializeVds(true);
        alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
        testVdsPowerManagementStatus(getParameters().getVdsStaticData());
        setSucceeded(true);
        setActionReturnValue(getVdsIdRef());
        // If the installation failed, we don't want to compensate for the failure since it will remove the
        // host, but instead the host should be left in an "install failed" status.
        getCompensationContext().resetCompensation();
        return null;
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().isPending() && !getParameters().isProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setNetworkProviderId(getParameters().getNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        installVdsParameters.setEnableSerialConsole(getParameters().getEnableSerialConsole());
        Map<String, String> values = new HashMap<>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(() -> runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx)));
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
protected VdcReturnValueBase createReturnValue() {
    return super.createReturnValue();
}
#method_after
@Override
protected VdcReturnValueBase createReturnValue() {
    return super.createReturnValue();
}
#end_block

#method_before
protected boolean isPowerManagementLegal(boolean pmEnabled, List<FenceAgent> fenceAgents, String clusterCompatibilityVersion) {
    return super.isPowerManagementLegal(pmEnabled, fenceAgents, clusterCompatibilityVersion);
}
#method_after
@Override
protected boolean isPowerManagementLegal(boolean pmEnabled, List<FenceAgent> fenceAgents, String clusterCompatibilityVersion) {
    return super.isPowerManagementLegal(pmEnabled, fenceAgents, clusterCompatibilityVersion);
}
#end_block

#method_before
protected void addValidationMessage(EngineMessage message) {
    super.addValidationMessage(message);
}
#method_after
@Override
protected void addValidationMessage(EngineMessage message) {
    super.addValidationMessage(message);
}
#end_block

#method_before
protected boolean validate(ValidationResult validationResult) {
    return super.validate(validationResult);
}
#method_after
@Override
protected boolean validate(ValidationResult validationResult) {
    return super.validate(validationResult);
}
#end_block

#method_before
protected void endMoveVmCommand() {
    boolean vmExists = (getVm() != null);
    if (vmExists) {
        incrementDbGeneration();
    }
    endActionOnAllImageGroups();
    if (vmExists) {
        VmHandler.unLockVm(getVm());
        VmHandler.updateDisksFromDb(getVm());
    } else {
        setCommandShouldBeLogged(false);
        log.warn("MoveVmCommand::EndMoveVmCommand: Vm is null - not performing full endAction");
    }
    setSucceeded(true);
}
#method_after
protected void endMoveVmCommand() {
    boolean vmExists = getVm() != null;
    if (vmExists) {
        incrementDbGeneration();
    }
    endActionOnAllImageGroups();
    if (vmExists) {
        VmHandler.unLockVm(getVm());
        VmHandler.updateDisksFromDb(getVm());
    } else {
        setCommandShouldBeLogged(false);
        log.warn("MoveVmCommand::EndMoveVmCommand: Vm is null - not performing full endAction");
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // check source to copy hook from - if engine copy or server copy
    final boolean copyfromEngine = (getParameters().getSourceServerId() == null);
    entity = getGlusterHook();
    addCustomValue(GlusterConstants.HOOK_NAME, entity.getName());
    final String hookContent;
    final String hookChecksum;
    final GlusterHookContentType hookContentType;
    if (copyfromEngine) {
        hookContent = entity.getContent();
        hookChecksum = entity.getChecksum();
        hookContentType = entity.getContentType();
    } else {
        // use a server's copy
        GlusterServerHook sourceServerHook = getGlusterHooksDao().getGlusterServerHook(entity.getId(), getParameters().getSourceServerId());
        VDSReturnValue retValue = runVdsCommand(VDSCommandType.GetGlusterHookContent, new GlusterHookVDSParameters(getParameters().getSourceServerId(), entity.getGlusterCommand(), entity.getStage(), entity.getName()));
        if (!retValue.getSucceeded()) {
            // throw exception as we cannot continue without content
            log.error("Failed to get content from server with id '{}': {}", getParameters().getSourceServerId(), retValue.getExceptionString());
            throw new EngineException(retValue.getVdsError().getCode(), retValue.getVdsError().getMessage());
        }
        hookContent = (String) retValue.getReturnValue();
        hookChecksum = sourceServerHook.getChecksum();
        hookContentType = sourceServerHook.getContentType();
    }
    List<Callable<Pair<Guid, VDSReturnValue>>> taskList = new ArrayList<>();
    List<Guid> serverIdsToUpdate = new ArrayList<>();
    if (copyfromEngine) {
        for (final GlusterServerHook serverHook : getContentConflictServerHooks()) {
            serverIdsToUpdate.add(serverHook.getServerId());
        }
    } else {
        // need to be updated with hook content
        for (final VDS server : getClusterUtils().getAllUpServers(entity.getClusterId())) {
            if (!server.getId().equals(getParameters().getSourceServerId())) {
                serverIdsToUpdate.add(server.getId());
            }
        }
    }
    for (final Guid serverId : serverIdsToUpdate) {
        taskList.add(() -> {
            VDSReturnValue returnValue;
            returnValue = runVdsCommand(VDSCommandType.UpdateGlusterHook, new GlusterHookVDSParameters(serverId, entity.getGlusterCommand(), entity.getStage(), entity.getName(), hookContent, hookChecksum));
            return new Pair<>(serverId, returnValue);
        });
    }
    setSucceeded(true);
    if (!taskList.isEmpty()) {
        List<Pair<Guid, VDSReturnValue>> pairResults = ThreadPoolUtil.invokeAll(taskList);
        for (Pair<Guid, VDSReturnValue> pairResult : pairResults) {
            VDSReturnValue retValue = pairResult.getSecond();
            if (!retValue.getSucceeded()) {
                errors.add(retValue.getVdsError().getMessage());
            }
        }
    } else {
        setSucceeded(false);
    }
    if (errors.size() > 0) {
        setSucceeded(false);
        errorType = AuditLogType.GLUSTER_HOOK_UPDATE_FAILED;
        handleVdsErrors(getAuditLogTypeValue(), errors);
        addCustomValue(GlusterConstants.FAILURE_MESSAGE, StringUtils.join(errors, SystemUtils.LINE_SEPARATOR));
    }
    if (getSucceeded() && !copyfromEngine) {
        // update server's content copy
        entity.setChecksum(hookChecksum);
        entity.setContent(hookContent);
        entity.setContentType(hookContentType);
    }
    if (getSucceeded()) {
        entity.removeContentConflict();
        updateGlusterHook(entity);
    }
}
#method_after
@Override
protected void executeCommand() {
    // check source to copy hook from - if engine copy or server copy
    final boolean copyfromEngine = getParameters().getSourceServerId() == null;
    entity = getGlusterHook();
    addCustomValue(GlusterConstants.HOOK_NAME, entity.getName());
    final String hookContent;
    final String hookChecksum;
    final GlusterHookContentType hookContentType;
    if (copyfromEngine) {
        hookContent = entity.getContent();
        hookChecksum = entity.getChecksum();
        hookContentType = entity.getContentType();
    } else {
        // use a server's copy
        GlusterServerHook sourceServerHook = getGlusterHooksDao().getGlusterServerHook(entity.getId(), getParameters().getSourceServerId());
        VDSReturnValue retValue = runVdsCommand(VDSCommandType.GetGlusterHookContent, new GlusterHookVDSParameters(getParameters().getSourceServerId(), entity.getGlusterCommand(), entity.getStage(), entity.getName()));
        if (!retValue.getSucceeded()) {
            // throw exception as we cannot continue without content
            log.error("Failed to get content from server with id '{}': {}", getParameters().getSourceServerId(), retValue.getExceptionString());
            throw new EngineException(retValue.getVdsError().getCode(), retValue.getVdsError().getMessage());
        }
        hookContent = (String) retValue.getReturnValue();
        hookChecksum = sourceServerHook.getChecksum();
        hookContentType = sourceServerHook.getContentType();
    }
    List<Callable<Pair<Guid, VDSReturnValue>>> taskList = new ArrayList<>();
    List<Guid> serverIdsToUpdate = new ArrayList<>();
    if (copyfromEngine) {
        for (final GlusterServerHook serverHook : getContentConflictServerHooks()) {
            serverIdsToUpdate.add(serverHook.getServerId());
        }
    } else {
        // need to be updated with hook content
        for (final VDS server : getClusterUtils().getAllUpServers(entity.getClusterId())) {
            if (!server.getId().equals(getParameters().getSourceServerId())) {
                serverIdsToUpdate.add(server.getId());
            }
        }
    }
    for (final Guid serverId : serverIdsToUpdate) {
        taskList.add(() -> {
            VDSReturnValue returnValue;
            returnValue = runVdsCommand(VDSCommandType.UpdateGlusterHook, new GlusterHookVDSParameters(serverId, entity.getGlusterCommand(), entity.getStage(), entity.getName(), hookContent, hookChecksum));
            return new Pair<>(serverId, returnValue);
        });
    }
    setSucceeded(true);
    if (!taskList.isEmpty()) {
        List<Pair<Guid, VDSReturnValue>> pairResults = ThreadPoolUtil.invokeAll(taskList);
        for (Pair<Guid, VDSReturnValue> pairResult : pairResults) {
            VDSReturnValue retValue = pairResult.getSecond();
            if (!retValue.getSucceeded()) {
                errors.add(retValue.getVdsError().getMessage());
            }
        }
    } else {
        setSucceeded(false);
    }
    if (errors.size() > 0) {
        setSucceeded(false);
        errorType = AuditLogType.GLUSTER_HOOK_UPDATE_FAILED;
        handleVdsErrors(getAuditLogTypeValue(), errors);
        addCustomValue(GlusterConstants.FAILURE_MESSAGE, StringUtils.join(errors, SystemUtils.LINE_SEPARATOR));
    }
    if (getSucceeded() && !copyfromEngine) {
        // update server's content copy
        entity.setChecksum(hookChecksum);
        entity.setContent(hookContent);
        entity.setContentType(hookContentType);
    }
    if (getSucceeded()) {
        entity.removeContentConflict();
        updateGlusterHook(entity);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    initializeStorageDomain();
    // save storage if got from parameters in order to save first empty
    // storage in db and use it later
    String storage = ((getStorageDomain().getStorage()) != null) ? getStorageDomain().getStorage() : "";
    // set domain storage to empty because not nullable in db and for shared
    // status to be locked
    getStorageDomain().setStorage("");
    addStorageDomainInDb();
    if (StringUtils.isEmpty(storage)) {
        storage = createVG();
    }
    getStorageDomain().setStorage(storage);
    if (StringUtils.isNotEmpty(getStorageDomain().getStorage()) && (addStorageDomainInIrs())) {
        DbFacade.getInstance().getStorageDomainStaticDao().update(getStorageDomain().getStorageStaticData());
        updateStorageDomainDynamicFromIrs();
        proceedVGLunsInDb();
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    initializeStorageDomain();
    // save storage if got from parameters in order to save first empty
    // storage in db and use it later
    String storage = (getStorageDomain().getStorage() != null) ? getStorageDomain().getStorage() : "";
    // set domain storage to empty because not nullable in db and for shared
    // status to be locked
    getStorageDomain().setStorage("");
    addStorageDomainInDb();
    if (StringUtils.isEmpty(storage)) {
        storage = createVG();
    }
    getStorageDomain().setStorage(storage);
    if (StringUtils.isNotEmpty(getStorageDomain().getStorage()) && addStorageDomainInIrs()) {
        DbFacade.getInstance().getStorageDomainStaticDao().update(getStorageDomain().getStorageStaticData());
        updateStorageDomainDynamicFromIrs();
        proceedVGLunsInDb();
        setSucceeded(true);
    }
}
#end_block

#method_before
@Override
protected boolean canAddDomain() {
    if (((getParameters().getLunIds() == null || getParameters().getLunIds().isEmpty()) && StringUtils.isEmpty(getStorageDomain().getStorage()))) {
        return failValidation(EngineMessage.ERROR_CANNOT_CREATE_STORAGE_DOMAIN_WITHOUT_VG_LV);
    }
    if (isLunsAlreadyInUse(getParameters().getLunIds())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canAddDomain() {
    if ((getParameters().getLunIds() == null || getParameters().getLunIds().isEmpty()) && StringUtils.isEmpty(getStorageDomain().getStorage())) {
        return failValidation(EngineMessage.ERROR_CANNOT_CREATE_STORAGE_DOMAIN_WITHOUT_VG_LV);
    }
    if (isLunsAlreadyInUse(getParameters().getLunIds())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    // set version to latest supported version if not given
    if (getStoragePool().getCompatibilityVersion().isNotValid()) {
        getStoragePool().setCompatibilityVersion(Version.getLast());
    }
    if (result && !(isStoragePoolUnique(getStoragePool().getName()))) {
        result = false;
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
    } else if (!checkStoragePoolNameLengthValid()) {
        result = false;
    } else if (!VersionSupport.checkVersionSupported(getStoragePool().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    return result;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    // set version to latest supported version if not given
    if (getStoragePool().getCompatibilityVersion().isNotValid()) {
        getStoragePool().setCompatibilityVersion(Version.getLast());
    }
    if (result && !isStoragePoolUnique(getStoragePool().getName())) {
        result = false;
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
    } else if (!checkStoragePoolNameLengthValid()) {
        result = false;
    } else if (!VersionSupport.checkVersionSupported(getStoragePool().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    return result;
}
#end_block

#method_before
@Override
protected boolean validate() {
    GlusterVolumeEntity volume = getGlusterVolume();
    if (!super.validate()) {
        return false;
    }
    if (!validate(getBrickValidator().canStopOrCommitRemoveBrick(volume, getParameters().getBricks()))) {
        return false;
    }
    if (!(getGlusterTaskUtils().isTaskOfType(volume, GlusterTaskType.REMOVE_BRICK)) || !(getGlusterTaskUtils().isTaskStatus(volume, JobExecutionStatus.FINISHED))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REMOVE_BRICKS_NOT_FINISHED);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    GlusterVolumeEntity volume = getGlusterVolume();
    if (!super.validate()) {
        return false;
    }
    if (!validate(getBrickValidator().canStopOrCommitRemoveBrick(volume, getParameters().getBricks()))) {
        return false;
    }
    if (!getGlusterTaskUtils().isTaskOfType(volume, GlusterTaskType.REMOVE_BRICK) || !getGlusterTaskUtils().isTaskStatus(volume, JobExecutionStatus.FINISHED)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REMOVE_BRICKS_NOT_FINISHED);
    }
    return true;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return noActionDone ? AuditLogType.UNASSIGNED : (getSucceeded() ? AuditLogType.USER_DETACH_USER_GROUP_FROM_TAG : AuditLogType.USER_DETACH_USER_GROUP_FROM_TAG_FAILED);
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return noActionDone ? AuditLogType.UNASSIGNED : getSucceeded() ? AuditLogType.USER_DETACH_USER_GROUP_FROM_TAG : AuditLogType.USER_DETACH_USER_GROUP_FROM_TAG_FAILED;
}
#end_block

#method_before
protected IscsiBond getIscsiBond() {
    return getParameters().getIscsiBond();
}
#method_after
@Override
protected IscsiBond getIscsiBond() {
    return getParameters().getIscsiBond();
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return noActionDone ? AuditLogType.UNASSIGNED : (getSucceeded() ? AuditLogType.USER_DETACH_USER_FROM_TAG : AuditLogType.USER_DETACH_USER_FROM_TAG_FAILED);
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return noActionDone ? AuditLogType.UNASSIGNED : getSucceeded() ? AuditLogType.USER_DETACH_USER_FROM_TAG : AuditLogType.USER_DETACH_USER_FROM_TAG_FAILED;
}
#end_block

#method_before
public CommandCallback getCallback() {
    return new HostUpgradeCallback();
}
#method_after
@Override
public CommandCallback getCallback() {
    return new HostUpgradeCallback();
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean retVal = validate(templateExists());
    if (retVal) {
        List<DiskImage> images = templatesFromExport.get(templatesFromExport.keySet().stream().filter(t -> t.getId().equals(getParameters().getVmTemplateId())).findFirst().orElse(null));
        if (images != null) {
            getParameters().setImages(images);
        } else {
            retVal = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        }
    }
    if (retVal) {
        StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
        retVal = validate(validator.isDomainExistAndActive());
    }
    if (retVal && getStorageDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        retVal = false;
    }
    if (retVal) {
        // we fectch from db and not using VmTmplate property becase
        // VmTemplate is the one from export domain and not from database
        VmTemplate tmpl = DbFacade.getInstance().getVmTemplateDao().get(getVmTemplateId());
        if (tmpl != null) {
            retVal = (tmpl.getStatus() != VmTemplateStatus.Locked);
            if (!retVal) {
                getReturnValue().getValidationMessages().add(EngineMessage.VM_TEMPLATE_IMAGE_IS_LOCKED.toString());
            }
        }
    }
    return retVal;
}
#method_after
@Override
protected boolean validate() {
    boolean retVal = validate(templateExists());
    if (retVal) {
        List<DiskImage> images = templatesFromExport.get(templatesFromExport.keySet().stream().filter(t -> t.getId().equals(getParameters().getVmTemplateId())).findFirst().orElse(null));
        if (images != null) {
            getParameters().setImages(images);
        } else {
            retVal = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        }
    }
    if (retVal) {
        StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
        retVal = validate(validator.isDomainExistAndActive());
    }
    if (retVal && getStorageDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        retVal = false;
    }
    if (retVal) {
        // we fectch from db and not using VmTmplate property becase
        // VmTemplate is the one from export domain and not from database
        VmTemplate tmpl = DbFacade.getInstance().getVmTemplateDao().get(getVmTemplateId());
        if (tmpl != null) {
            retVal = tmpl.getStatus() != VmTemplateStatus.Locked;
            if (!retVal) {
                getReturnValue().getValidationMessages().add(EngineMessage.VM_TEMPLATE_IMAGE_IS_LOCKED.toString());
            }
        }
    }
    return retVal;
}
#end_block

#method_before
@Override
protected boolean validate() {
    Cluster cluster = getCluster();
    if (!cluster.supportsGlusterService() || (!getGlusterUtil().isGlusterBrickProvisioningSupported(cluster.getCompatibilityVersion(), getCluster().getId()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_PROVISIONING_NOT_SUPPORTED_BY_CLUSTER);
    }
    HostValidator validator = new HostValidator(getVds());
    if (!validate(validator.isUp())) {
        return false;
    }
    String deviceType;
    if (getParameters().getDisks() == null || getParameters().getDisks().isEmpty()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DEVICE_REQUIRED);
        return false;
    } else {
        deviceType = getParameters().getDisks().get(0).getDevType();
    }
    for (StorageDevice device : getParameters().getDisks()) {
        // for performance reasons.
        if (!Objects.equals(deviceType, device.getDevType())) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_DIFFERENT_STORAGE_DEVICE_TYPES_SELECTED);
            return false;
        }
        // Ensure that device is not already used by some other brick or LVM.
        if (!device.getCanCreateBrick()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_DEVICE_IS_ALREADY_IN_USE);
            addValidationMessageVariable("storageDevice", device.getName());
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    Cluster cluster = getCluster();
    if (!cluster.supportsGlusterService() || !getGlusterUtil().isGlusterBrickProvisioningSupported(cluster.getCompatibilityVersion(), getCluster().getId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_PROVISIONING_NOT_SUPPORTED_BY_CLUSTER);
    }
    HostValidator validator = new HostValidator(getVds());
    if (!validate(validator.isUp())) {
        return false;
    }
    String deviceType;
    if (getParameters().getDisks() == null || getParameters().getDisks().isEmpty()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DEVICE_REQUIRED);
        return false;
    } else {
        deviceType = getParameters().getDisks().get(0).getDevType();
    }
    for (StorageDevice device : getParameters().getDisks()) {
        // for performance reasons.
        if (!Objects.equals(deviceType, device.getDevType())) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_DIFFERENT_STORAGE_DEVICE_TYPES_SELECTED);
            return false;
        }
        // Ensure that device is not already used by some other brick or LVM.
        if (!device.getCanCreateBrick()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_DEVICE_IS_ALREADY_IN_USE);
            addValidationMessageVariable("storageDevice", device.getName());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean retValue = true;
    if (getParameters().getJobId() != null) {
        job = getJobDao().get((Guid) getParameters().getJobId());
        if (job == null) {
            retValue = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_NO_JOB);
        } else if (!job.isExternal()) {
            retValue = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_NOT_EXTERNAL);
        }
    } else {
        retValue = false;
        addValidationMessage(EngineMessage.ACTION_TYPE_NO_JOB);
    }
    if (!retValue) {
        addValidationMessage(EngineMessage.VAR__ACTION__CLEAR);
        addValidationMessage(EngineMessage.VAR__TYPE__EXTERNAL_JOB);
    }
    return retValue;
}
#method_after
@Override
protected boolean validate() {
    boolean retValue = true;
    if (getParameters().getJobId() != null) {
        job = getJobDao().get(getParameters().getJobId());
        if (job == null) {
            retValue = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_NO_JOB);
        } else if (!job.isExternal()) {
            retValue = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_NOT_EXTERNAL);
        }
    } else {
        retValue = false;
        addValidationMessage(EngineMessage.ACTION_TYPE_NO_JOB);
    }
    if (!retValue) {
        addValidationMessage(EngineMessage.VAR__ACTION__CLEAR);
        addValidationMessage(EngineMessage.VAR__TYPE__EXTERNAL_JOB);
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    job = getJobDao().get((Guid) getParameters().getJobId());
    job.setAutoCleared(true);
    getJobDao().update(job);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    job = getJobDao().get(getParameters().getJobId());
    job.setAutoCleared(true);
    getJobDao().update(job);
    setSucceeded(true);
}
#end_block

#method_before
public boolean checkQuotaNameExisting(Quota quota, List<String> messages) {
    Quota quotaByName = getQuotaDao().getQuotaByQuotaName(quota.getQuotaName());
    // Check if there is no quota with the same name that already exists.
    if ((quotaByName != null) && (!quotaByName.getId().equals(quota.getId()))) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED.toString());
        return false;
    }
    return true;
}
#method_after
public boolean checkQuotaNameExisting(Quota quota, List<String> messages) {
    Quota quotaByName = getQuotaDao().getQuotaByQuotaName(quota.getQuotaName());
    // Check if there is no quota with the same name that already exists.
    if ((quotaByName != null) && !quotaByName.getId().equals(quota.getId())) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED.toString());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getDisk() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    if (getVm() == null) {
        addValidationMessageVariable("diskAliases", getDiskAlias());
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_IS_NOT_VM_DISK);
    }
    if (getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Arrays.asList((DiskImage) getDisk()));
        if (!validate(diskImagesValidator.diskImagesNotLocked()) || !validate(diskImagesValidator.diskImagesNotIllegal())) {
            return false;
        }
        StorageDomainStatic sds = getStorageDomainStaticDao().get(((DiskImage) getDisk()).getStorageIds().get(0));
        if (!sds.getStorageType().isBlockDomain()) {
            addValidationMessageVariable("diskAlias", getDiskAlias());
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_ALIGNMENT_SCAN_STORAGE_TYPE);
        }
    }
    if (getVm().isRunningOrPaused()) {
        return failValidation(EngineMessage.ERROR_CANNOT_RUN_ALIGNMENT_SCAN_VM_IS_RUNNING);
    }
    if (getVdsIdInGroup() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    }
    StoragePool sp = getStoragePoolDao().get(getStoragePoolId());
    if (!validate(new StoragePoolValidator(sp).isUp())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getDisk() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    if (getVm() == null) {
        addValidationMessageVariable("diskAliases", getDiskAlias());
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_IS_NOT_VM_DISK);
    }
    if (getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Collections.singletonList((DiskImage) getDisk()));
        if (!validate(diskImagesValidator.diskImagesNotLocked()) || !validate(diskImagesValidator.diskImagesNotIllegal())) {
            return false;
        }
        StorageDomainStatic sds = getStorageDomainStaticDao().get(((DiskImage) getDisk()).getStorageIds().get(0));
        if (!sds.getStorageType().isBlockDomain()) {
            addValidationMessageVariable("diskAlias", getDiskAlias());
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_ALIGNMENT_SCAN_STORAGE_TYPE);
        }
    }
    if (getVm().isRunningOrPaused()) {
        return failValidation(EngineMessage.ERROR_CANNOT_RUN_ALIGNMENT_SCAN_VM_IS_RUNNING);
    }
    if (getVdsIdInGroup() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    }
    StoragePool sp = getStoragePoolDao().get(getStoragePoolId());
    if (!validate(new StoragePoolValidator(sp).isUp())) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean isImageExclusiveLockNeeded() {
    /* In case the volume format is RAW (same as a direct LUN) the exclusive image
         * lock is not needed since the alignment scan can run without any interference
         * by a concurrent running VM.
         */
    return (getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) getDisk()).getVolumeFormat() != VolumeFormat.RAW);
}
#method_after
protected boolean isImageExclusiveLockNeeded() {
    /* In case the volume format is RAW (same as a direct LUN) the exclusive image
         * lock is not needed since the alignment scan can run without any interference
         * by a concurrent running VM.
         */
    return getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) getDisk()).getVolumeFormat() != VolumeFormat.RAW;
}
#end_block

#method_before
@Override
public VM getVm() {
    if (diskVm == null && getDisk() != null) {
        for (VM vm : getVmDao().getVmsListForDisk(getDisk().getId(), false)) {
            diskVm = vm;
            break;
        }
    }
    return diskVm;
}
#method_after
@Override
public VM getVm() {
    if (diskVm == null && getDisk() != null) {
        diskVm = getVmDao().getVmsListForDisk(getDisk().getId(), false).stream().findFirst().orElse(null);
    }
    return diskVm;
}
#end_block

#method_before
protected Disk getDisk() {
    if (diskToScan == null) {
        diskToScan = getDiskDao().get((Guid) getParameters().getDiskId());
    }
    return diskToScan;
}
#method_after
protected Disk getDisk() {
    if (diskToScan == null) {
        diskToScan = getDiskDao().get(getParameters().getDiskId());
    }
    return diskToScan;
}
#end_block

#method_before
protected boolean pciAndIdeWithinLimit(VM vm, List<VmNic> allInterfaces) {
    List<Disk> allDisks = getDiskDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vm.getOs(), vm.getClusterCompatibilityVersion(), vm.getNumOfMonitors(), allInterfaces, allDisks, VmDeviceUtils.hasVirtioScsiController(getVmId()), VmDeviceUtils.hasWatchdog(getVmId()), VmDeviceUtils.hasMemoryBalloon(getVmId()), VmDeviceUtils.hasSoundDevice(getVmId()), getReturnValue().getValidationMessages());
}
#method_after
protected boolean pciAndIdeWithinLimit(VM vm, List<VmNic> allInterfaces) {
    List<Disk> allDisks = getDiskDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vm.getOs(), vm.getCompatibilityVersion(), vm.getNumOfMonitors(), allInterfaces, allDisks, VmDeviceUtils.hasVirtioScsiController(getVmId()), VmDeviceUtils.hasWatchdog(getVmId()), VmDeviceUtils.hasMemoryBalloon(getVmId()), VmDeviceUtils.hasSoundDevice(getVmId()), getReturnValue().getValidationMessages());
}
#end_block

#method_before
private boolean isFileDomainInEditState(StorageDomain storageDomain) {
    return (storageDomain.getStatus() == StorageDomainStatus.Maintenance || storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached);
}
#method_after
private boolean isFileDomainInEditState(StorageDomain storageDomain) {
    return storageDomain.getStatus() == StorageDomainStatus.Maintenance || storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached;
}
#end_block

#method_before
protected boolean validateNotificationMethod(EventNotificationMethod eventNotificationMethod, EventSubscriber eventSubscriber, DbUser user) {
    boolean retValue = true;
    EventNotificationMethod notificationMethod = eventNotificationMethod;
    switch(notificationMethod) {
        case SMTP:
            String mailAddress = (StringUtils.isEmpty(eventSubscriber.getMethodAddress())) ? user.getEmail() : eventSubscriber.getMethodAddress();
            if (!isEmailValid(mailAddress)) {
                addValidationMessage(EngineMessage.USER_DOES_NOT_HAVE_A_VALID_EMAIL);
                retValue = false;
            }
            break;
        default:
            addValidationMessage(EngineMessage.EN_UNKNOWN_NOTIFICATION_METHOD);
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
protected boolean validateNotificationMethod(EventNotificationMethod eventNotificationMethod, EventSubscriber eventSubscriber, DbUser user) {
    boolean retValue = true;
    EventNotificationMethod notificationMethod = eventNotificationMethod;
    switch(notificationMethod) {
        case SMTP:
            String mailAddress = StringUtils.isEmpty(eventSubscriber.getMethodAddress()) ? user.getEmail() : eventSubscriber.getMethodAddress();
            if (!isEmailValid(mailAddress)) {
                addValidationMessage(EngineMessage.USER_DOES_NOT_HAVE_A_VALID_EMAIL);
                retValue = false;
            }
            break;
        default:
            addValidationMessage(EngineMessage.EN_UNKNOWN_NOTIFICATION_METHOD);
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
protected boolean isUserAuthorizedToRunAction() {
    return true;
}
#method_after
@Override
protected boolean isUserAuthorizedToRunAction() {
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    return validate(NumaValidator.checkVmNumaNodesIntegrity(getVm(), getVmNumaNodesForValidation()));
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validate(NumaValidator.checkVmNumaIndexDuplicates(getParameters().getVmNumaNodeList()))) {
        return false;
    }
    return validate(NumaValidator.checkVmNumaNodesIntegrity(getVm(), getVmNumaNodesForValidation()));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected boolean validate() {
    super.validate();
    if (isLunsAlreadyInUse(getParameters().getLunIds())) {
        return false;
    }
    if (!(checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getStorageDomain().getStorageType().isBlockDomain()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        return false;
    }
    final ConnectAllHostsToLunCommandReturnValue connectResult = (ConnectAllHostsToLunCommandReturnValue) runInternalAction(VdcActionType.ConnectAllHostsToLun, new ExtendSANStorageDomainParameters(getParameters().getStorageDomainId(), getParameters().getLunIds()));
    if (!connectResult.getSucceeded()) {
        addValidationMessage(EngineMessage.ERROR_CANNOT_EXTEND_CONNECTION_FAILED);
        if (connectResult.getFailedVds() != null) {
            getReturnValue().getValidationMessages().add(String.format("$hostName %1s", connectResult.getFailedVds().getName()));
        }
        String lunId = connectResult.getFailedLun() != null ? connectResult.getFailedLun().getLUNId() : "";
        getReturnValue().getValidationMessages().add(String.format("$lun %1s", lunId));
        return false;
    } else {
        // use luns list from connect command
        getParameters().setLunsList((ArrayList<LUNs>) connectResult.getActionReturnValue());
    }
    return true;
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected boolean validate() {
    super.validate();
    if (isLunsAlreadyInUse(getParameters().getLunIds())) {
        return false;
    }
    if (!(checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getStorageDomain().getStorageType().isBlockDomain()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        return false;
    }
    final ConnectAllHostsToLunCommandReturnValue connectResult = (ConnectAllHostsToLunCommandReturnValue) runInternalAction(VdcActionType.ConnectAllHostsToLun, new ExtendSANStorageDomainParameters(getParameters().getStorageDomainId(), getParameters().getLunIds()));
    if (!connectResult.getSucceeded()) {
        addValidationMessage(EngineMessage.ERROR_CANNOT_EXTEND_CONNECTION_FAILED);
        if (connectResult.getFailedVds() != null) {
            getReturnValue().getValidationMessages().add(String.format("$hostName %1s", connectResult.getFailedVds().getName()));
        }
        String lunId = connectResult.getFailedLun() != null ? connectResult.getFailedLun().getLUNId() : "";
        getReturnValue().getValidationMessages().add(String.format("$lun %1s", lunId));
        return false;
    } else {
        // use luns list from connect command
        getParameters().setLunsList(connectResult.getActionReturnValue());
    }
    return true;
}
#end_block

#method_before
private boolean networkConfigurationSupported(VdsNetworkInterface iface, Map<String, Network> networksByName) {
    if (StringUtils.isEmpty(iface.getNetworkName())) {
        return true;
    }
    Network attachedNetwork = networksByName.get(iface.getNetworkName());
    // Prevent attaching a network if unmanaged network is already attached to the nic
    if (attachedNetwork == null) {
        return false;
    }
    // Prevent attaching a VM network when a VM network is already attached
    if (vmNetworkNonVlan(attachedNetwork) || vmNetworkNonVlan(logicalNetwork)) {
        return false;
    }
    // Verify that only VM networks exists on the nic if the non-Vm network feature isn't supported by the cluster
    if (!FeatureSupported.nonVmNetwork(getVds().getClusterCompatibilityVersion()) && (!iface.isBridged())) {
        return false;
    }
    // Prevent attaching non-VM network to a nic which already has an attached non-VM network
    if (NetworkUtils.isNonVmNonVlanNetwork(attachedNetwork) && NetworkUtils.isNonVmNonVlanNetwork(logicalNetwork)) {
        return false;
    }
    return true;
}
#method_after
private boolean networkConfigurationSupported(VdsNetworkInterface iface, Map<String, Network> networksByName) {
    if (StringUtils.isEmpty(iface.getNetworkName())) {
        return true;
    }
    Network attachedNetwork = networksByName.get(iface.getNetworkName());
    // Prevent attaching a network if unmanaged network is already attached to the nic
    if (attachedNetwork == null) {
        return false;
    }
    // Prevent attaching a VM network when a VM network is already attached
    if (vmNetworkNonVlan(attachedNetwork) || vmNetworkNonVlan(logicalNetwork)) {
        return false;
    }
    // Verify that only VM networks exists on the nic if the non-Vm network feature isn't supported by the cluster
    if (!FeatureSupported.nonVmNetwork(getVds().getClusterCompatibilityVersion()) && !iface.isBridged()) {
        return false;
    }
    // Prevent attaching non-VM network to a nic which already has an attached non-VM network
    if (NetworkUtils.isNonVmNonVlanNetwork(attachedNetwork) && NetworkUtils.isNonVmNonVlanNetwork(logicalNetwork)) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean isPowerManagementLegal(boolean pmEnabled, List<FenceAgent> fenceAgents, String clusterCompatibilityVersion) {
    return super.isPowerManagementLegal(pmEnabled, fenceAgents, clusterCompatibilityVersion);
}
#method_after
@Override
protected boolean isPowerManagementLegal(boolean pmEnabled, List<FenceAgent> fenceAgents, String clusterCompatibilityVersion) {
    return super.isPowerManagementLegal(pmEnabled, fenceAgents, clusterCompatibilityVersion);
}
#end_block

#method_before
@Override
protected boolean validate() {
    clusterId = getParameters().getClusterId();
    serverId = getParameters().getServerId();
    serviceType = getParameters().getServiceType();
    actionType = getParameters().getActionType();
    if (!manageActionDetailsMap.keySet().contains(actionType)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_ACTION_TYPE);
    }
    if (Guid.isNullOrEmpty(clusterId) && Guid.isNullOrEmpty(serverId)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTERID_AND_SERVERID_BOTH_NULL);
    }
    if (!(Guid.isNullOrEmpty(clusterId)) && getClusterUtils().getAllUpServers(clusterId).size() == 0) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_SERVERS_FOR_CLUSTER);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    clusterId = getParameters().getClusterId();
    serverId = getParameters().getServerId();
    serviceType = getParameters().getServiceType();
    actionType = getParameters().getActionType();
    if (!manageActionDetailsMap.keySet().contains(actionType)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_ACTION_TYPE);
    }
    if (Guid.isNullOrEmpty(clusterId) && Guid.isNullOrEmpty(serverId)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTERID_AND_SERVERID_BOTH_NULL);
    }
    if (!Guid.isNullOrEmpty(clusterId) && getClusterUtils().getAllUpServers(clusterId).size() == 0) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_SERVERS_FOR_CLUSTER);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (!(Guid.isNullOrEmpty(serverId))) {
        performActionForServicesOfServer();
    } else if (!(Guid.isNullOrEmpty(clusterId))) {
        performActionForServicesOfCluster();
    }
    addCustomValue(GlusterConstants.SERVICE_TYPE, getParameters().getServiceType().name());
}
#method_after
@Override
protected void executeCommand() {
    if (!Guid.isNullOrEmpty(serverId)) {
        performActionForServicesOfServer();
    } else if (!Guid.isNullOrEmpty(clusterId)) {
        performActionForServicesOfCluster();
    }
    addCustomValue(GlusterConstants.SERVICE_TYPE, getParameters().getServiceType().name());
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (!(Guid.isNullOrEmpty(getParameters().getServerId()))) {
        return Collections.singletonMap(getParameters().getServerId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.GLUSTER, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    } else if (!(Guid.isNullOrEmpty(getParameters().getClusterId()))) {
        return Collections.singletonMap(getParameters().getClusterId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.GLUSTER, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return null;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (!Guid.isNullOrEmpty(getParameters().getServerId())) {
        return Collections.singletonMap(getParameters().getServerId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.GLUSTER, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    } else if (!Guid.isNullOrEmpty(getParameters().getClusterId())) {
        return Collections.singletonMap(getParameters().getClusterId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.GLUSTER, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return null;
}
#end_block

#method_before
@Override
protected boolean validate() {
    M validator = getQosValidator(getQos());
    return (validateParameters() && validate(validator.requiredValuesPresent()));
}
#method_after
@Override
protected boolean validate() {
    M validator = getQosValidator(getQos());
    return validateParameters() && validate(validator.requiredValuesPresent());
}
#end_block

#method_before
protected IscsiBond getIscsiBond() {
    if (iscsiBond == null) {
        iscsiBond = getDbFacade().getIscsiBondDao().get(getParameters().getIscsiBondId());
    }
    return iscsiBond;
}
#method_after
@Override
protected IscsiBond getIscsiBond() {
    if (iscsiBond == null) {
        iscsiBond = getDbFacade().getIscsiBondDao().get(getParameters().getIscsiBondId());
    }
    return iscsiBond;
}
#end_block

#method_before
public static <P extends VdcActionParametersBase> CommandBase<P> createCommand(VdcActionType action, P parameters, CommandContext commandContext) {
    try {
        return Injector.injectMembers(instantiateCommand(action, parameters, commandContext));
    } catch (InvocationTargetException ex) {
        log.error("Error in invocating CTOR of command '{}': {}", action.name(), ex.getMessage());
        log.debug("Exception", ex);
        return null;
    } catch (Exception ex) {
        log.error("An exception has occured while trying to create a command object for command '{}': {}", action.name(), ex.getMessage());
        log.debug("Exception", ex);
        return null;
    }
}
#method_after
public static <P extends VdcActionParametersBase> CommandBase<P> createCommand(VdcActionType action, P parameters, CommandContext commandContext) {
    try {
        Constructor<CommandBase<? extends VdcActionParametersBase>> commandConstructor = findCommandConstructor(getCommandClass(action.name()), parameters.getClass(), CommandContext.class);
        if (commandContext == null) {
            commandContext = CommandContext.createContext(parameters.getSessionId());
        } else if (commandContext.getEngineContext().getSessionId() == null) {
            // Needed for SEAT mechanism - session ID is available only on parameters
            // upon command re-instantiation (when moving between task handlers).
            commandContext.getEngineContext().withSessionId(parameters.getSessionId());
        }
        @SuppressWarnings("unchecked")
        CommandBase<P> command = (CommandBase<P>) commandConstructor.newInstance(parameters, commandContext);
        return Injector.injectMembers(command);
    } catch (InvocationTargetException ex) {
        log.error("Error in invocating CTOR of command '{}': {}", action.name(), ex.getMessage());
        log.debug("Exception", ex);
        return null;
    } catch (Exception ex) {
        log.error("An exception has occured while trying to create a command object for command '{}': {}", action.name(), ex.getMessage());
        log.debug("Exception", ex);
        return null;
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isInternalExecution() && !ObjectIdentityChecker.canUpdateField(getVm(), "clusterId", getVm().getStatus())) {
        addValidationMessage(EngineMessage.VM_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    ChangeVmClusterValidator validator = new ChangeVmClusterValidator(this, getParameters().getClusterId());
    return validator.validate();
}
#method_after
@Override
protected boolean validate() {
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isInternalExecution() && !ObjectIdentityChecker.canUpdateField(getVm(), "clusterId", getVm().getStatus())) {
        addValidationMessage(EngineMessage.VM_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    ChangeVmClusterValidator validator = new ChangeVmClusterValidator(this, getParameters().getClusterId(), getParameters().getVmCustomCompatibilityVersion());
    return validator.validate();
}
#end_block

#method_before
protected GlusterUtil getGlusterUtil() {
    return GlusterUtil.getInstance();
}
#method_after
@Override
protected GlusterUtil getGlusterUtil() {
    return GlusterUtil.getInstance();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid clusterId = getParameters().getClusterId();
    Guid volumeId = getParameters().getVolumeId();
    List<GlusterVolumeSnapshotConfig> fetchedConfigParams = getGlusterVolumeSnapshotConfigDao().getConfigByClusterId(clusterId);
    // segregate the fetched cluster and volume specific config params
    Map<String, GlusterVolumeSnapshotConfig> fetchedClusterConfigParams = new HashMap<>();
    Map<String, GlusterVolumeSnapshotConfig> fetchedVolumeConfigParams = new HashMap<>();
    for (GlusterVolumeSnapshotConfig param : fetchedConfigParams) {
        if (Guid.isNullOrEmpty(param.getVolumeId())) {
            fetchedClusterConfigParams.put(param.getParamName(), param);
        } else if (volumeId != null && param.getVolumeId().equals(volumeId)) {
            fetchedVolumeConfigParams.put(param.getParamName(), param);
        }
    }
    List<GlusterVolumeSnapshotConfig> configParams = getParameters().getConfigParams();
    // segregate the cluster and volume specific config params
    Map<String, GlusterVolumeSnapshotConfig> clusterConfigParams = new HashMap<>();
    Map<String, GlusterVolumeSnapshotConfig> volumeConfigParams = new HashMap<>();
    for (GlusterVolumeSnapshotConfig param : configParams) {
        if (Guid.isNullOrEmpty(param.getVolumeId())) {
            clusterConfigParams.put(param.getParamName(), param);
        } else {
            volumeConfigParams.put(param.getParamName(), param);
        }
    }
    // form the final list of updated config params
    List<GlusterVolumeSnapshotConfig> updatedClusterConfigParams = new ArrayList<>();
    for (GlusterVolumeSnapshotConfig cfgParam : clusterConfigParams.values()) {
        GlusterVolumeSnapshotConfig fetchedCfgParam = fetchedClusterConfigParams.get(cfgParam.getParamName());
        if (fetchedCfgParam != null && !(fetchedCfgParam.getParamValue().equals(cfgParam.getParamValue()))) {
            updatedClusterConfigParams.add(cfgParam);
        }
    }
    List<GlusterVolumeSnapshotConfig> updatedVolumeConfigParams = new ArrayList<>();
    for (GlusterVolumeSnapshotConfig cfgParam : volumeConfigParams.values()) {
        GlusterVolumeSnapshotConfig fetchedCfgParam = fetchedVolumeConfigParams.get(cfgParam.getParamName());
        if (fetchedCfgParam != null && !(fetchedCfgParam.getParamValue().equals(cfgParam.getParamValue()))) {
            updatedVolumeConfigParams.add(cfgParam);
        }
    }
    List<GlusterVolumeSnapshotConfig> updatedConfigs = new ArrayList<>();
    for (GlusterVolumeSnapshotConfig param : updatedClusterConfigParams) {
        updatedConfigs.add(param);
    }
    for (GlusterVolumeSnapshotConfig param : updatedVolumeConfigParams) {
        updatedConfigs.add(param);
    }
    for (GlusterVolumeSnapshotConfig config : updatedConfigs) {
        VDSReturnValue retVal = runVdsCommand(VDSCommandType.SetGlusterVolumeSnapshotConfig, new GlusterVolumeSnapshotSetConfigVDSParameters(upServer.getId(), config));
        if (!retVal.getSucceeded()) {
            failedCfgs.add(config.getParamName());
            updatesSuccessful = false;
        } else {
            if (config.getVolumeId() != null) {
                getGlusterVolumeSnapshotConfigDao().updateConfigByVolumeIdAndName(config.getClusterId(), config.getVolumeId(), config.getParamName(), config.getParamValue());
            } else {
                getGlusterVolumeSnapshotConfigDao().updateConfigByClusterIdAndName(config.getClusterId(), config.getParamName(), config.getParamValue());
            }
            updatesSuccessful = true;
        }
    }
    if (!updatesSuccessful) {
        addCustomValue("failedSnapshotConfigs", failedCfgs.toString());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid clusterId = getParameters().getClusterId();
    Guid volumeId = getParameters().getVolumeId();
    List<GlusterVolumeSnapshotConfig> fetchedConfigParams = getGlusterVolumeSnapshotConfigDao().getConfigByClusterId(clusterId);
    // segregate the fetched cluster and volume specific config params
    Map<String, GlusterVolumeSnapshotConfig> fetchedClusterConfigParams = new HashMap<>();
    Map<String, GlusterVolumeSnapshotConfig> fetchedVolumeConfigParams = new HashMap<>();
    for (GlusterVolumeSnapshotConfig param : fetchedConfigParams) {
        if (Guid.isNullOrEmpty(param.getVolumeId())) {
            fetchedClusterConfigParams.put(param.getParamName(), param);
        } else if (volumeId != null && param.getVolumeId().equals(volumeId)) {
            fetchedVolumeConfigParams.put(param.getParamName(), param);
        }
    }
    List<GlusterVolumeSnapshotConfig> configParams = getParameters().getConfigParams();
    // segregate the cluster and volume specific config params
    Map<String, GlusterVolumeSnapshotConfig> clusterConfigParams = new HashMap<>();
    Map<String, GlusterVolumeSnapshotConfig> volumeConfigParams = new HashMap<>();
    for (GlusterVolumeSnapshotConfig param : configParams) {
        if (Guid.isNullOrEmpty(param.getVolumeId())) {
            clusterConfigParams.put(param.getParamName(), param);
        } else {
            volumeConfigParams.put(param.getParamName(), param);
        }
    }
    // form the final list of updated config params
    List<GlusterVolumeSnapshotConfig> updatedClusterConfigParams = new ArrayList<>();
    for (GlusterVolumeSnapshotConfig cfgParam : clusterConfigParams.values()) {
        GlusterVolumeSnapshotConfig fetchedCfgParam = fetchedClusterConfigParams.get(cfgParam.getParamName());
        if (fetchedCfgParam != null && !fetchedCfgParam.getParamValue().equals(cfgParam.getParamValue())) {
            updatedClusterConfigParams.add(cfgParam);
        }
    }
    List<GlusterVolumeSnapshotConfig> updatedVolumeConfigParams = new ArrayList<>();
    for (GlusterVolumeSnapshotConfig cfgParam : volumeConfigParams.values()) {
        GlusterVolumeSnapshotConfig fetchedCfgParam = fetchedVolumeConfigParams.get(cfgParam.getParamName());
        if (fetchedCfgParam != null && !fetchedCfgParam.getParamValue().equals(cfgParam.getParamValue())) {
            updatedVolumeConfigParams.add(cfgParam);
        }
    }
    List<GlusterVolumeSnapshotConfig> updatedConfigs = new ArrayList<>();
    for (GlusterVolumeSnapshotConfig param : updatedClusterConfigParams) {
        updatedConfigs.add(param);
    }
    for (GlusterVolumeSnapshotConfig param : updatedVolumeConfigParams) {
        updatedConfigs.add(param);
    }
    for (GlusterVolumeSnapshotConfig config : updatedConfigs) {
        VDSReturnValue retVal = runVdsCommand(VDSCommandType.SetGlusterVolumeSnapshotConfig, new GlusterVolumeSnapshotSetConfigVDSParameters(upServer.getId(), config));
        if (!retVal.getSucceeded()) {
            failedCfgs.add(config.getParamName());
            updatesSuccessful = false;
        } else {
            if (config.getVolumeId() != null) {
                getGlusterVolumeSnapshotConfigDao().updateConfigByVolumeIdAndName(config.getClusterId(), config.getVolumeId(), config.getParamName(), config.getParamValue());
            } else {
                getGlusterVolumeSnapshotConfigDao().updateConfigByClusterIdAndName(config.getClusterId(), config.getParamName(), config.getParamValue());
            }
            updatesSuccessful = true;
        }
    }
    if (!updatesSuccessful) {
        addCustomValue("failedSnapshotConfigs", failedCfgs.toString());
    }
    setSucceeded(true);
}
#end_block

#method_before
private void addGlusterVolumeBricksInDb(List<GlusterBrickEntity> newBricks, int replicaCount, int stripeCount) {
    // Reorder the volume bricks
    GlusterVolumeEntity volume = getGlusterVolume();
    List<GlusterBrickEntity> volumeBricks = volume.getBricks();
    if (isReplicaCountIncreased(replicaCount) || isStripeCountIncreased(stripeCount)) {
        GlusterBrickEntity brick;
        int brick_num = 0;
        int count = (isReplicaCountIncreased(replicaCount)) ? replicaCount : stripeCount;
        // Updating existing brick order
        for (int i = 0; i < volumeBricks.size(); i++) {
            if (((i + 1) % count) == 0) {
                brick_num++;
            }
            brick = volumeBricks.get(i);
            brick.setBrickOrder(brick_num);
            brick_num++;
            getGlusterBrickDao().updateBrickOrder(brick.getId(), brick.getBrickOrder());
        }
        // Adding new bricks
        for (int i = 0; i < newBricks.size(); i++) {
            brick = newBricks.get(i);
            brick.setBrickOrder((i + 1) * count - 1);
            brick.setStatus(getBrickStatus());
            getGlusterBrickDao().save(brick);
        }
    } else {
        // No change in the replica/stripe count
        int brickCount = volumeBricks.get(volumeBricks.size() - 1).getBrickOrder();
        for (GlusterBrickEntity brick : newBricks) {
            brick.setBrickOrder(++brickCount);
            brick.setStatus(getBrickStatus());
            getGlusterBrickDao().save(brick);
        }
    }
    // Update the volume replica/stripe count
    if (isReplicaCountIncreased(replicaCount)) {
        volume.setReplicaCount(replicaCount);
    }
    if (volume.getVolumeType() == GlusterVolumeType.REPLICATE && replicaCount < (volume.getBricks().size() + newBricks.size())) {
        volume.setVolumeType(GlusterVolumeType.DISTRIBUTED_REPLICATE);
    }
    if (isStripeCountIncreased(stripeCount)) {
        volume.setStripeCount(stripeCount);
    }
    if (volume.getVolumeType() == GlusterVolumeType.STRIPE && stripeCount < (volume.getBricks().size() + newBricks.size())) {
        volume.setVolumeType(GlusterVolumeType.DISTRIBUTED_STRIPE);
    }
    // TODO: check for DISTRIBUTED_STRIPED_REPLICATE and STRIPED_REPLICATE
    getGlusterVolumeDao().updateGlusterVolume(volume);
}
#method_after
private void addGlusterVolumeBricksInDb(List<GlusterBrickEntity> newBricks, int replicaCount, int stripeCount) {
    // Reorder the volume bricks
    GlusterVolumeEntity volume = getGlusterVolume();
    List<GlusterBrickEntity> volumeBricks = volume.getBricks();
    if (isReplicaCountIncreased(replicaCount) || isStripeCountIncreased(stripeCount)) {
        GlusterBrickEntity brick;
        int brick_num = 0;
        int count = isReplicaCountIncreased(replicaCount) ? replicaCount : stripeCount;
        // Updating existing brick order
        for (int i = 0; i < volumeBricks.size(); i++) {
            if (((i + 1) % count) == 0) {
                brick_num++;
            }
            brick = volumeBricks.get(i);
            brick.setBrickOrder(brick_num);
            brick_num++;
            getGlusterBrickDao().updateBrickOrder(brick.getId(), brick.getBrickOrder());
        }
        // Adding new bricks
        for (int i = 0; i < newBricks.size(); i++) {
            brick = newBricks.get(i);
            brick.setBrickOrder((i + 1) * count - 1);
            brick.setStatus(getBrickStatus());
            getGlusterBrickDao().save(brick);
        }
    } else {
        // No change in the replica/stripe count
        int brickCount = volumeBricks.get(volumeBricks.size() - 1).getBrickOrder();
        for (GlusterBrickEntity brick : newBricks) {
            brick.setBrickOrder(++brickCount);
            brick.setStatus(getBrickStatus());
            getGlusterBrickDao().save(brick);
        }
    }
    // Update the volume replica/stripe count
    if (isReplicaCountIncreased(replicaCount)) {
        volume.setReplicaCount(replicaCount);
    }
    if (volume.getVolumeType() == GlusterVolumeType.REPLICATE && replicaCount < (volume.getBricks().size() + newBricks.size())) {
        volume.setVolumeType(GlusterVolumeType.DISTRIBUTED_REPLICATE);
    }
    if (isStripeCountIncreased(stripeCount)) {
        volume.setStripeCount(stripeCount);
    }
    if (volume.getVolumeType() == GlusterVolumeType.STRIPE && stripeCount < (volume.getBricks().size() + newBricks.size())) {
        volume.setVolumeType(GlusterVolumeType.DISTRIBUTED_STRIPE);
    }
    // TODO: check for DISTRIBUTED_STRIPED_REPLICATE and STRIPED_REPLICATE
    getGlusterVolumeDao().updateGlusterVolume(volume);
}
#end_block

#method_before
private boolean isReplicaCountIncreased(int replicaCount) {
    return ((getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) && replicaCount > getGlusterVolume().getReplicaCount());
}
#method_after
private boolean isReplicaCountIncreased(int replicaCount) {
    return (getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) && replicaCount > getGlusterVolume().getReplicaCount();
}
#end_block

#method_before
private boolean isStripeCountIncreased(int stripeCount) {
    return ((getGlusterVolume().getVolumeType() == GlusterVolumeType.STRIPE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_STRIPE) && stripeCount > getGlusterVolume().getStripeCount());
}
#method_after
private boolean isStripeCountIncreased(int stripeCount) {
    return (getGlusterVolume().getVolumeType() == GlusterVolumeType.STRIPE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_STRIPE) && stripeCount > getGlusterVolume().getStripeCount();
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!FeatureSupported.isSuspendSupportedByArchitecture(getVm().getClusterArch(), getVm().getClusterCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_SUSPEND_NOT_SUPPORTED);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VMStatus vmStatus = getVm().getStatus();
    if (vmStatus == VMStatus.WaitForLaunch || vmStatus == VMStatus.NotResponding) {
        return failVmStatusIllegal();
    }
    if (vmStatus != VMStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_UP);
    }
    if (CommandCoordinatorUtil.entityHasTasks(getVmId())) {
        return failValidation(EngineMessage.VM_CANNOT_SUSPENDE_HAS_RUNNING_TASKS);
    }
    if (getVm().getVmPoolId() != null) {
        return failValidation(EngineMessage.VM_CANNOT_SUSPEND_VM_FROM_POOL);
    }
    // (then isStateless is false)
    if (getVm().isStateless() || DbFacade.getInstance().getSnapshotDao().exists(getVmId(), SnapshotType.STATELESS)) {
        return failValidation(EngineMessage.VM_CANNOT_SUSPEND_STATELESS_VM);
    }
    if (getStorageDomainId() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!FeatureSupported.isSuspendSupportedByArchitecture(getVm().getClusterArch(), getVm().getCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_SUSPEND_NOT_SUPPORTED);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VMStatus vmStatus = getVm().getStatus();
    if (vmStatus == VMStatus.WaitForLaunch || vmStatus == VMStatus.NotResponding) {
        return failVmStatusIllegal();
    }
    if (vmStatus != VMStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_UP);
    }
    if (CommandCoordinatorUtil.entityHasTasks(getVmId())) {
        return failValidation(EngineMessage.VM_CANNOT_SUSPENDE_HAS_RUNNING_TASKS);
    }
    if (getVm().getVmPoolId() != null) {
        return failValidation(EngineMessage.VM_CANNOT_SUSPEND_VM_FROM_POOL);
    }
    // (then isStateless is false)
    if (getVm().isStateless() || DbFacade.getInstance().getSnapshotDao().exists(getVmId(), SnapshotType.STATELESS)) {
        return failValidation(EngineMessage.VM_CANNOT_SUSPEND_STATELESS_VM);
    }
    if (getStorageDomainId() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    return (checkQuotaValidationForAdd(getParameters().getQuota(), getReturnValue().getValidationMessages()));
}
#method_after
@Override
protected boolean validate() {
    return checkQuotaValidationForAdd(getParameters().getQuota(), getReturnValue().getValidationMessages());
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    addCustomValue("InterfaceType", (VmInterfaceType.forValue(getInterface().getType()).getDescription()).toString());
    this.setVmName(getVmStaticDao().get(getParameters().getVmId()).getName());
    boolean succeeded = false;
    boolean macAddedToPool = false;
    try {
        if (StringUtils.isEmpty(getMacAddress())) {
            getInterface().setMacAddress(macPool.allocateNewMac());
            macAddedToPool = true;
        } else {
            macAddedToPool = addMacToPool(getMacAddress());
        }
        getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
        getInterface().setId(Guid.newGuid());
        getInterface().setVmId(getParameters().getVmId());
        TransactionSupport.executeInNewTransaction(() -> {
            addInterfaceToDb(getInterface());
            addInterfaceDeviceToDb();
            getCompensationContext().stateChanged();
            return null;
        });
        if (getInterface().isPlugged()) {
            succeeded = activateOrDeactivateNewNic(getInterface(), PlugAction.PLUG);
        } else {
            succeeded = true;
        }
    } finally {
        setSucceeded(succeeded);
        if (macAddedToPool && !succeeded) {
            macPool.freeMac(getMacAddress());
        }
    }
}
#method_after
@Override
protected void executeVmCommand() {
    addCustomValue("InterfaceType", VmInterfaceType.forValue(getInterface().getType()).getDescription().toString());
    this.setVmName(getVmStaticDao().get(getParameters().getVmId()).getName());
    boolean succeeded = false;
    boolean macAddedToPool = false;
    try {
        if (StringUtils.isEmpty(getMacAddress())) {
            getInterface().setMacAddress(macPool.allocateNewMac());
            macAddedToPool = true;
        } else {
            macAddedToPool = addMacToPool(getMacAddress());
        }
        getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
        getInterface().setId(Guid.newGuid());
        getInterface().setVmId(getParameters().getVmId());
        TransactionSupport.executeInNewTransaction(() -> {
            addInterfaceToDb(getInterface());
            addInterfaceDeviceToDb();
            getCompensationContext().stateChanged();
            return null;
        });
        if (getInterface().isPlugged()) {
            succeeded = activateOrDeactivateNewNic(getInterface(), PlugAction.PLUG);
        } else {
            succeeded = true;
        }
    } finally {
        setSucceeded(succeeded);
        if (macAddedToPool && !succeeded) {
            macPool.freeMac(getMacAddress());
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (getVm().getStatus() != VMStatus.Up) {
        return failVmStatusIllegal();
    }
    if (!FeatureSupported.vmSlaPolicy(getVm().getClusterCompatibilityVersion())) {
        return failValidation(EngineMessage.VM_SLA_POLICY_NOT_SUPPORTED);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (getVm().getStatus() != VMStatus.Up) {
        return failVmStatusIllegal();
    }
    if (!FeatureSupported.vmSlaPolicy(getVm().getCompatibilityVersion())) {
        return failValidation(EngineMessage.VM_SLA_POLICY_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
@Before
public void initCommandsCollection() {
    // Create a stream of all VdcActionType objects.
    commandClasses = Arrays.stream(VdcActionType.values()).filter(vdcActionType -> vdcActionType != VdcActionType.Unknown).map(vdcActionType -> CommandsFactory.getCommandClass(vdcActionType.toString())).collect(Collectors.toList());
}
#method_after
@BeforeClass
public static void initCommandsCollection() {
    // Create a stream of all VdcActionType objects.
    commandClasses = Arrays.stream(VdcActionType.values()).filter(vdcActionType -> vdcActionType != VdcActionType.Unknown).map(vdcActionType -> CommandsFactory.getCommandClass(vdcActionType.toString())).collect(Collectors.toList());
}
#end_block

#method_before
@Before
public void createMandatoryConstructorSignaturePredicate() {
    // Signature for a constructor that gets parameters and context objects.
    mandatoryConstructorSignature = createConstructorSignaturePredicate(VdcActionParametersBase.class, CommandContext.class);
}
#method_after
@BeforeClass
public static void createMandatoryConstructorSignaturePredicate() {
    // Signature for a constructor that receives parameters and context objects.
    mandatoryConstructorSignature = createConstructorSignaturePredicate(VdcActionParametersBase.class, CommandContext.class);
}
#end_block

#method_before
private Predicate<Constructor<?>> createConstructorSignaturePredicate(Class<?>... constructorParametersTypes) {
    return constructor -> ReflectionUtils.isCompatible(constructor.getParameterTypes(), constructorParametersTypes);
}
#method_after
private static Predicate<Constructor<?>> createConstructorSignaturePredicate(Class<?>... constructorParametersTypes) {
    return constructor -> ReflectionUtils.isCompatible(constructor.getParameterTypes(), constructorParametersTypes);
}
#end_block

#method_before
@Test
public void testCommandMandatoryConstructorsExistence() {
    List<String> commandsWithoutMandatoryConstructor = commandClasses.stream().filter(commandClass -> Arrays.stream(commandClass.getDeclaredConstructors()).noneMatch(mandatoryConstructorSignature)).map(commandClass -> commandClass.getSimpleName()).sorted().collect(Collectors.toList());
    assertThat("There are commands that don't contain the mandatory constructor (constructor that gets " + "parameters and context objects):", commandsWithoutMandatoryConstructor, empty());
}
#method_after
@Test
public void testCommandMandatoryConstructorsExistence() {
    List<String> commandsWithoutMandatoryConstructor = commandClasses.stream().filter(commandClass -> Arrays.stream(commandClass.getDeclaredConstructors()).noneMatch(mandatoryConstructorSignature)).map(Class::getSimpleName).sorted().collect(Collectors.toList());
    assertThat("There are commands that don't contain the mandatory constructor (constructor that receives " + "parameters and context objects):", commandsWithoutMandatoryConstructor, empty());
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    addCustomValue("InterfaceType", (VmInterfaceType.forValue(getInterface().getType()).getDescription()).toString());
    boolean succeeded = false;
    boolean macAddedToPool = false;
    try {
        if (isVnicProfileChanged(oldIface, getInterface())) {
            Network newNetwork = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
            Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
            if (!Objects.equals(oldNetwork, newNetwork)) {
                new ExternalNetworkManager(oldIface).deallocateIfExternal();
            }
        }
        if (macShouldBeChanged) {
            macAddedToPool = addMacToPool(getMacAddress());
        }
        if (mustChangeAddress(oldIface.getType(), getInterface().getType())) {
            getVmDeviceDao().clearDeviceAddress(getInterface().getId());
        }
        getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
        TransactionSupport.executeInNewTransaction(() -> {
            updatePassthoughDeviceIfNeeded();
            getCompensationContext().snapshotEntity(oldIface);
            getVmNicDao().update(getInterface());
            getCompensationContext().stateChanged();
            return null;
        });
        succeeded = updateHost();
    } finally {
        setSucceeded(succeeded);
        MacPoolManagerStrategy macPool = getMacPool();
        if (macAddedToPool) {
            if (succeeded) {
                macPool.freeMac(oldIface.getMacAddress());
            } else {
                macPool.freeMac(getMacAddress());
            }
        }
    }
}
#method_after
@Override
protected void executeVmCommand() {
    addCustomValue("InterfaceType", VmInterfaceType.forValue(getInterface().getType()).getDescription().toString());
    boolean succeeded = false;
    boolean macAddedToPool = false;
    try {
        if (isVnicProfileChanged(oldIface, getInterface())) {
            Network newNetwork = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
            Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
            if (!Objects.equals(oldNetwork, newNetwork)) {
                new ExternalNetworkManager(oldIface).deallocateIfExternal();
            }
        }
        if (macShouldBeChanged) {
            macAddedToPool = addMacToPool(getMacAddress());
        }
        if (mustChangeAddress(oldIface.getType(), getInterface().getType())) {
            getVmDeviceDao().clearDeviceAddress(getInterface().getId());
        }
        getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
        TransactionSupport.executeInNewTransaction(() -> {
            updatePassthoughDeviceIfNeeded();
            getCompensationContext().snapshotEntity(oldIface);
            getVmNicDao().update(getInterface());
            getCompensationContext().stateChanged();
            return null;
        });
        succeeded = updateHost();
    } finally {
        setSucceeded(succeeded);
        MacPoolManagerStrategy macPool = getMacPool();
        if (macAddedToPool) {
            if (succeeded) {
                macPool.freeMac(oldIface.getMacAddress());
            } else {
                macPool.freeMac(getMacAddress());
            }
        }
    }
}
#end_block

#method_before
private boolean propertiesRequiringUnplugPlugWereUpdated() {
    return (!oldIface.getType().equals(getInterface().getType())) || (!oldIface.getMacAddress().equals(getMacAddress()));
}
#method_after
private boolean propertiesRequiringUnplugPlugWereUpdated() {
    return !oldIface.getType().equals(getInterface().getType()) || !oldIface.getMacAddress().equals(getMacAddress());
}
#end_block

#method_before
private boolean isVnicAttachedToExternalNetwork() {
    final Network network = getNetwork();
    return (network != null && network.isExternal());
}
#method_after
private boolean isVnicAttachedToExternalNetwork() {
    final Network network = getNetwork();
    return network != null && network.isExternal();
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    if (oldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failValidation(EngineMessage.VM_TEMPLATE_IS_LOCKED);
    }
    // Check that the USB policy is legal
    boolean returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion(), getReturnValue().getValidationMessages());
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getCluster().getArchitecture(), getReturnValue().getValidationMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate((new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVmTemplate().getCompatibilityVersion())).isValid());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmTemplateData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getValidationMessages(), getVmTemplate().getCompatibilityVersion());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getParameters().getVmTemplateData().getThreadsPerCpu(), getVmTemplate().getCompatibilityVersion().toString(), getReturnValue().getValidationMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getValidationMessages(), getVmTemplate().getCompatibilityVersion())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateData().getId());
        if (!VmCommand.checkPciAndIdeLimit(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion(), getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, new ArrayList<DiskImageBase>(getParameters().getVmTemplateData().getDiskList()), VmDeviceUtils.hasVirtioScsiController(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), VmDeviceUtils.hasMemoryBalloon(getParameters().getVmTemplateData().getId()), isSoundDeviceEnabled(), getReturnValue().getValidationMessages())) {
            returnValue = false;
        }
    }
    if (getParameters().getVmTemplateData().getMinAllocatedMem() > getParameters().getVmTemplateData().getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!getVmPropertiesUtils().validateVmProperties(getVmTemplate().getCompatibilityVersion(), getParameters().getVmTemplateData().getCustomProperties(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (returnValue) {
        boolean balloonEnabled = Boolean.TRUE.equals(getParameters().isBalloonEnabled());
        if (balloonEnabled && !osRepository.isBalloonEnabled(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion())) {
            addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
            return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
        }
    }
    boolean soundDeviceEnabled = Boolean.TRUE.equals(getParameters().isSoundDeviceEnabled());
    if (soundDeviceEnabled && !osRepository.isSoundDeviceEnabled(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return returnValue;
}
#method_after
private boolean doClusterRelatedChecks() {
    if (oldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failValidation(EngineMessage.VM_TEMPLATE_IS_LOCKED);
    }
    // Check that the USB policy is legal
    boolean returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion(), getReturnValue().getValidationMessages());
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getCluster().getArchitecture(), getReturnValue().getValidationMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate(new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVmTemplate().getCompatibilityVersion()).isValid());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmTemplateData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getValidationMessages(), getVmTemplate().getCompatibilityVersion());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getParameters().getVmTemplateData().getThreadsPerCpu(), getVmTemplate().getCompatibilityVersion().toString(), getReturnValue().getValidationMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getValidationMessages(), getVmTemplate().getCompatibilityVersion())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateData().getId());
        if (!VmCommand.checkPciAndIdeLimit(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion(), getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, new ArrayList<>(getParameters().getVmTemplateData().getDiskList()), VmDeviceUtils.hasVirtioScsiController(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), VmDeviceUtils.hasMemoryBalloon(getParameters().getVmTemplateData().getId()), isSoundDeviceEnabled(), getReturnValue().getValidationMessages())) {
            returnValue = false;
        }
    }
    if (getParameters().getVmTemplateData().getMinAllocatedMem() > getParameters().getVmTemplateData().getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!getVmPropertiesUtils().validateVmProperties(getVmTemplate().getCompatibilityVersion(), getParameters().getVmTemplateData().getCustomProperties(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (returnValue) {
        boolean balloonEnabled = Boolean.TRUE.equals(getParameters().isBalloonEnabled());
        if (balloonEnabled && !osRepository.isBalloonEnabled(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion())) {
            addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
            return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
        }
    }
    boolean soundDeviceEnabled = Boolean.TRUE.equals(getParameters().isSoundDeviceEnabled());
    if (soundDeviceEnabled && !osRepository.isSoundDeviceEnabled(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean retValue = true;
    if (getParameters().getJobId() != null) {
        job = getJobDao().get((Guid) getParameters().getJobId());
        if (job == null) {
            retValue = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_NO_JOB);
        } else if (!job.isExternal()) {
            retValue = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_NOT_EXTERNAL);
        }
    } else {
        retValue = false;
        addValidationMessage(EngineMessage.ACTION_TYPE_NO_JOB);
    }
    if (!retValue) {
        addValidationMessage(EngineMessage.VAR__ACTION__CLEAR);
        addValidationMessage(EngineMessage.VAR__TYPE__EXTERNAL_JOB);
    }
    return retValue;
}
#method_after
@Override
protected boolean validate() {
    boolean retValue = true;
    if (getParameters().getJobId() != null) {
        job = getJobDao().get(getParameters().getJobId());
        if (job == null) {
            retValue = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_NO_JOB);
        } else if (!job.isExternal()) {
            retValue = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_NOT_EXTERNAL);
        }
    } else {
        retValue = false;
        addValidationMessage(EngineMessage.ACTION_TYPE_NO_JOB);
    }
    if (!retValue) {
        addValidationMessage(EngineMessage.VAR__ACTION__CLEAR);
        addValidationMessage(EngineMessage.VAR__TYPE__EXTERNAL_JOB);
    }
    return retValue;
}
#end_block

#method_before
private boolean isUpdateVmRequired(VM poolVm) {
    // old template version (based on current vm data)
    Guid currentTempVersion = null;
    // old latest status
    boolean isCurrentLatest = false;
    if (poolVm.isNextRunConfigurationExists()) {
        VdcQueryReturnValue qRetNextRun = getBackend().runInternalQuery(VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(poolVm.getId()));
        if (qRetNextRun.getSucceeded()) {
            final VM nextRunVm = qRetNextRun.getReturnValue();
            if (nextRunVm != null) {
                // template version was changed, the cause still needs to be checked
                currentTempVersion = nextRunVm.getVmtGuid();
                isCurrentLatest = nextRunVm.isUseLatestVersion();
            }
        }
    } else {
        currentTempVersion = poolVm.getVmtGuid();
        isCurrentLatest = poolVm.isUseLatestVersion();
    }
    boolean isLatestPropertyChanged = (isCurrentLatest != getParameters().getVmStaticData().isUseLatestVersion());
    // template ID changed but latest is not set, as it would cause false-positives
    boolean isTemplateIdChanged = false;
    Guid newPoolTemplateVersion = getParameters().getVmStaticData().getVmtGuid();
    if (newPoolTemplateVersion != null) {
        isTemplateIdChanged = !newPoolTemplateVersion.equals(currentTempVersion) && !isCurrentLatest;
    }
    return isLatestPropertyChanged || isTemplateIdChanged;
}
#method_after
private boolean isUpdateVmRequired(VM poolVm) {
    // old template version (based on current vm data)
    Guid currentTempVersion = null;
    // old latest status
    boolean isCurrentLatest = false;
    if (poolVm.isNextRunConfigurationExists()) {
        VdcQueryReturnValue qRetNextRun = getBackend().runInternalQuery(VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(poolVm.getId()));
        if (qRetNextRun.getSucceeded()) {
            final VM nextRunVm = qRetNextRun.getReturnValue();
            if (nextRunVm != null) {
                // template version was changed, the cause still needs to be checked
                currentTempVersion = nextRunVm.getVmtGuid();
                isCurrentLatest = nextRunVm.isUseLatestVersion();
            }
        }
    } else {
        currentTempVersion = poolVm.getVmtGuid();
        isCurrentLatest = poolVm.isUseLatestVersion();
    }
    boolean isLatestPropertyChanged = isCurrentLatest != getParameters().getVmStaticData().isUseLatestVersion();
    // template ID changed but latest is not set, as it would cause false-positives
    boolean isTemplateIdChanged = false;
    Guid newPoolTemplateVersion = getParameters().getVmStaticData().getVmtGuid();
    if (newPoolTemplateVersion != null) {
        isTemplateIdChanged = !newPoolTemplateVersion.equals(currentTempVersion) && !isCurrentLatest;
    }
    return isLatestPropertyChanged || isTemplateIdChanged;
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(() -> {
        for (DiskImage disk : disks) {
            Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
            Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
            MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
            tempVar.setParentCommand(getActionType());
            tempVar.setUseCopyCollapse(true);
            tempVar.setVolumeType(disk.getVolumeType());
            tempVar.setVolumeFormat(disk.getVolumeFormat());
            tempVar.setCopyVolumeType(CopyVolumeType.SharedVol);
            tempVar.setSourceDomainId(getParameters().getSourceDomainId());
            tempVar.setForceOverride(getParameters().getForceOverride());
            tempVar.setImportEntity(true);
            tempVar.setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, containerID));
            tempVar.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
            for (DiskImage diskImage : getParameters().getVmTemplate().getDiskList()) {
                if (originalDiskId.equals(diskImage.getId())) {
                    tempVar.setQuotaId(diskImage.getQuotaId());
                    tempVar.setDiskProfileId(diskImage.getDiskProfileId());
                    break;
                }
            }
            MoveOrCopyImageGroupParameters p = tempVar;
            p.setParentParameters(getParameters());
            VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, p);
            if (!vdcRetValue.getSucceeded()) {
                throw ((vdcRetValue.getFault() != null) ? new EngineException(vdcRetValue.getFault().getError()) : new EngineException(EngineError.ENGINE));
            }
            getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        }
        return null;
    });
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(() -> {
        for (DiskImage disk : disks) {
            Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
            Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
            MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
            tempVar.setParentCommand(getActionType());
            tempVar.setUseCopyCollapse(true);
            tempVar.setVolumeType(disk.getVolumeType());
            tempVar.setVolumeFormat(disk.getVolumeFormat());
            tempVar.setCopyVolumeType(CopyVolumeType.SharedVol);
            tempVar.setSourceDomainId(getParameters().getSourceDomainId());
            tempVar.setForceOverride(getParameters().getForceOverride());
            tempVar.setImportEntity(true);
            tempVar.setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, containerID));
            tempVar.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
            for (DiskImage diskImage : getParameters().getVmTemplate().getDiskList()) {
                if (originalDiskId.equals(diskImage.getId())) {
                    tempVar.setQuotaId(diskImage.getQuotaId());
                    tempVar.setDiskProfileId(diskImage.getDiskProfileId());
                    break;
                }
            }
            MoveOrCopyImageGroupParameters p = tempVar;
            p.setParentParameters(getParameters());
            VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, p);
            if (!vdcRetValue.getSucceeded()) {
                throw vdcRetValue.getFault() != null ? new EngineException(vdcRetValue.getFault().getError()) : new EngineException(EngineError.ENGINE);
            }
            getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        }
        return null;
    });
}
#end_block

#method_before
protected boolean setAndValidateCpuProfile() {
    getVmTemplate().setClusterId(getClusterId());
    getVmTemplate().setCpuProfileId(getParameters().getCpuProfileId());
    return validate(CpuProfileHelper.setAndValidateCpuProfile(getVmTemplate(), getCluster().getCompatibilityVersion()));
}
#method_after
protected boolean setAndValidateCpuProfile() {
    getVmTemplate().setClusterId(getClusterId());
    getVmTemplate().setCpuProfileId(getParameters().getCpuProfileId());
    return validate(CpuProfileHelper.setAndValidateCpuProfile(getVmTemplate(), getEffectiveCompatibilityVersion()));
}
#end_block

#method_before
private void updateWindowsWarningMessage() {
    // $NON-NLS-1$
    setMessage("");
    Integer selectedOS = vmImportGeneralModel.getOperatingSystems().getSelectedItem();
    if (selectedOS == null) {
        return;
    }
    boolean attachDrivers = getAttachDrivers().getEntity();
    boolean someDriverSelected = !StringUtils.isEmpty(getIso().getSelectedItem());
    boolean isWindows = AsyncDataProvider.getInstance().isWindowsOsType(selectedOS);
    if (isWindows && (!attachDrivers || !someDriverSelected)) {
        setMessage(ConstantsManager.getInstance().getConstants().missingVirtioDriversForWindows());
    }
}
#method_after
private void updateWindowsWarningMessage() {
    // $NON-NLS-1$
    setWinWithoutVirtioMessage("");
    Integer selectedOS = vmImportGeneralModel.getOperatingSystems().getSelectedItem();
    if (selectedOS == null) {
        return;
    }
    boolean attachDrivers = getAttachDrivers().getEntity();
    boolean someDriverSelected = !StringUtils.isEmpty(getIso().getSelectedItem());
    boolean isWindows = AsyncDataProvider.getInstance().isWindowsOsType(selectedOS);
    if (isWindows && (!attachDrivers || !someDriverSelected)) {
        setWinWithoutVirtioMessage(ConstantsManager.getInstance().getConstants().missingVirtioDriversForWindows());
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = getParameters().isRestoreMemory() && FeatureSupported.memorySnapshot(getVm().getCompatibilityVersion()) && FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getCompatibilityVersion());
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(previousActiveSnapshot);
            getSnapshotDao().remove(previousActiveSnapshotId);
            snapshotsManager.addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), previousActiveSnapshot.getMemoryVolume(), getCompensationContext());
            snapshotsManager.addActiveSnapshot(newActiveSnapshotId, getVm(), restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, images, getCompensationContext());
            // being executed in the same transaction so we can restore the vm config and end the command.
            if (!filteredImages.isEmpty()) {
                getCompensationContext().stateChanged();
            } else {
                getVmStaticDao().incrementDbGeneration(getVm().getId());
                restoreVmConfigFromSnapshot();
            }
            return null;
        }
    });
    if (!filteredImages.isEmpty()) {
        VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = getParameters().isRestoreMemory() && FeatureSupported.memorySnapshot(getVm().getCompatibilityVersion()) && FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getCompatibilityVersion());
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(previousActiveSnapshot);
        getSnapshotDao().remove(previousActiveSnapshotId);
        snapshotsManager.addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), previousActiveSnapshot.getMemoryVolume(), getCompensationContext());
        snapshotsManager.addActiveSnapshot(newActiveSnapshotId, getVm(), restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, images, getCompensationContext());
        // being executed in the same transaction so we can restore the vm config and end the command.
        if (!filteredImages.isEmpty()) {
            getCompensationContext().stateChanged();
        } else {
            getVmStaticDao().incrementDbGeneration(getVm().getId());
            restoreVmConfigFromSnapshot();
        }
        return null;
    });
    if (!filteredImages.isEmpty()) {
        VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__PREVIEW);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__SNAPSHOT);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__PREVIEW);
    addValidationMessage(EngineMessage.VAR__TYPE__SNAPSHOT);
}
#end_block

#method_before
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
        if (osRepository.get64bitOss().contains(vm.getOs())) {
            ConfigValues config = vm.getClusterArch() == ArchitectureType.ppc64 ? ConfigValues.VMPpc64BitMaxMemorySizeInMB : ConfigValues.VM64BitMaxMemorySizeInMB;
            createInfo.put(VdsProperties.maxMemSize, Config.getValue(config, vm.getCompatibilityVersion().getValue()));
        } else {
            createInfo.put(VdsProperties.maxMemSize, Config.getValue(ConfigValues.VM32BitMaxMemorySizeInMB));
        }
        createInfo.put(VdsProperties.maxMemSlots, Config.getValue(ConfigValues.MaxMemorySlots));
    }
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (vm.getNumOfIoThreads() != 0) {
        createInfo.put(VdsProperties.numOfIoThreads, vm.getNumOfIoThreads());
    }
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
        createInfo.put(VdsProperties.threads_per_core, (Integer.toString(vm.getThreadsPerCpu())));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, calcMaxVCpu().toString());
        }
    }
    final String compatibilityVersion = vm.getCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    if (vm.getEmulatedMachine() != null) {
        createInfo.put(VdsProperties.emulatedMachine, vm.getEmulatedMachine());
    }
    // enabled.
    if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
        createInfo.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
        createInfo.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getCpuName() != null) {
        // uses dynamic vm data which was already updated by runVmCommand
        createInfo.put(VdsProperties.cpuType, vm.getCpuName());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
    if (keyboardLayout == null) {
        keyboardLayout = vm.getDefaultVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
        }
    }
    createInfo.put(VdsProperties.KeyboardLayout, keyboardLayout);
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC)) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    // ensure compatibility with VDSM <= 4.16
    addVmSpiceOptions(vm.getGraphicsInfos(), createInfo);
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
}
#method_after
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
        if (osRepository.get64bitOss().contains(vm.getOs())) {
            ConfigValues config = vm.getClusterArch() == ArchitectureType.ppc64 ? ConfigValues.VMPpc64BitMaxMemorySizeInMB : ConfigValues.VM64BitMaxMemorySizeInMB;
            createInfo.put(VdsProperties.maxMemSize, Config.getValue(config, vm.getCompatibilityVersion().getValue()));
        } else {
            createInfo.put(VdsProperties.maxMemSize, Config.getValue(ConfigValues.VM32BitMaxMemorySizeInMB));
        }
        createInfo.put(VdsProperties.maxMemSlots, Config.getValue(ConfigValues.MaxMemorySlots));
    }
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (vm.getNumOfIoThreads() != 0) {
        createInfo.put(VdsProperties.numOfIoThreads, vm.getNumOfIoThreads());
    }
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, Integer.toString(vm.getCpuPerSocket()));
        createInfo.put(VdsProperties.threads_per_core, Integer.toString(vm.getThreadsPerCpu()));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, calcMaxVCpu().toString());
        }
    }
    final String compatibilityVersion = vm.getCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    if (vm.getEmulatedMachine() != null) {
        createInfo.put(VdsProperties.emulatedMachine, vm.getEmulatedMachine());
    }
    // enabled.
    if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
        createInfo.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
        createInfo.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getCpuName() != null) {
        // uses dynamic vm data which was already updated by runVmCommand
        createInfo.put(VdsProperties.cpuType, vm.getCpuName());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
    if (keyboardLayout == null) {
        keyboardLayout = vm.getDefaultVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
        }
    }
    createInfo.put(VdsProperties.KeyboardLayout, keyboardLayout);
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC)) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    // ensure compatibility with VDSM <= 4.16
    addVmSpiceOptions(vm.getGraphicsInfos(), createInfo);
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
}
#end_block

#method_before
private Integer calcMaxVCpu() {
    Integer maxSockets = Config.<Integer>getValue(ConfigValues.MaxNumOfVmSockets, vm.getCompatibilityVersion().getValue());
    Integer maxVCpus = Config.<Integer>getValue(ConfigValues.MaxNumOfVmCpus, vm.getCompatibilityVersion().getValue());
    int threadsPerCore = vm.getThreadsPerCpu();
    int cpuPerSocket = vm.getCpuPerSocket();
    maxVCpus = cpuPerSocket * threadsPerCore * (Math.min(maxSockets, maxVCpus / (cpuPerSocket * threadsPerCore)));
    return maxVCpus;
}
#method_after
private Integer calcMaxVCpu() {
    Integer maxSockets = Config.<Integer>getValue(ConfigValues.MaxNumOfVmSockets, vm.getCompatibilityVersion().getValue());
    Integer maxVCpus = Config.<Integer>getValue(ConfigValues.MaxNumOfVmCpus, vm.getCompatibilityVersion().getValue());
    int threadsPerCore = vm.getThreadsPerCpu();
    int cpuPerSocket = vm.getCpuPerSocket();
    maxVCpus = cpuPerSocket * threadsPerCore * Math.min(maxSockets, maxVCpus / (cpuPerSocket * threadsPerCore));
    return maxVCpus;
}
#end_block

#method_before
protected void buildVmNetworkCluster() {
    // set Display network
    List<NetworkCluster> all = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(vm.getVdsGroupId());
    NetworkCluster networkCluster = null;
    for (NetworkCluster tempNetworkCluster : all) {
        if (tempNetworkCluster.isDisplay()) {
            networkCluster = tempNetworkCluster;
            break;
        }
    }
    if (networkCluster != null) {
        Network net = null;
        List<Network> allNetworks = DbFacade.getInstance().getNetworkDao().getAll();
        for (Network tempNetwork : allNetworks) {
            if (tempNetwork.getId().equals(networkCluster.getNetworkId())) {
                net = tempNetwork;
                break;
            }
        }
        if (net != null) {
            createInfo.put(VdsProperties.DISPLAY_NETWORK, net.getName());
        }
    }
}
#method_after
protected void buildVmNetworkCluster() {
    // set Display network
    List<NetworkCluster> all = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(vm.getClusterId());
    NetworkCluster networkCluster = null;
    for (NetworkCluster tempNetworkCluster : all) {
        if (tempNetworkCluster.isDisplay()) {
            networkCluster = tempNetworkCluster;
            break;
        }
    }
    if (networkCluster != null) {
        Network net = null;
        List<Network> allNetworks = DbFacade.getInstance().getNetworkDao().getAll();
        for (Network tempNetwork : allNetworks) {
            if (tempNetwork.getId().equals(networkCluster.getNetworkId())) {
                net = tempNetwork;
                break;
            }
        }
        if (net != null) {
            createInfo.put(VdsProperties.DISPLAY_NETWORK, net.getName());
        }
    }
}
#end_block

#method_before
protected void buildVmTimeZone() {
    // get vm timezone
    String timeZone = getTimeZoneForVm(vm);
    String javaZoneId = null;
    if (osRepository.isWindows(vm.getOs())) {
        // convert to java & calculate offset
        javaZoneId = WindowsJavaTimezoneMapping.get(timeZone);
    } else {
        javaZoneId = timeZone;
    }
    int offset = 0;
    if (javaZoneId != null) {
        offset = (TimeZone.getTimeZone(javaZoneId).getOffset(new Date().getTime()) / 1000);
    }
    createInfo.put(VdsProperties.utc_diff, "" + offset);
}
#method_after
protected void buildVmTimeZone() {
    // get vm timezone
    String timeZone = getTimeZoneForVm(vm);
    String javaZoneId = null;
    if (osRepository.isWindows(vm.getOs())) {
        // convert to java & calculate offset
        javaZoneId = WindowsJavaTimezoneMapping.get(timeZone);
    } else {
        javaZoneId = timeZone;
    }
    int offset = 0;
    if (javaZoneId != null) {
        offset = TimeZone.getTimeZone(javaZoneId).getOffset(new Date().getTime()) / 1000;
    }
    createInfo.put(VdsProperties.utc_diff, "" + offset);
}
#end_block

#method_before
protected static void reportUnsupportedVnicProfileFeatures(VM vm, VmNic nic, VnicProfile vnicProfile, List<VnicProfileProperties> unsupportedFeatures) {
    if (unsupportedFeatures.isEmpty()) {
        return;
    }
    AuditLogableBase event = new AuditLogableBase();
    event.setVmId(vm.getId());
    event.setVdsGroupId(vm.getVdsGroupId());
    event.setCustomId(nic.getId().toString());
    event.setCompatibilityVersion(vm.getCompatibilityVersion().toString());
    event.addCustomValue("NicName", nic.getName());
    event.addCustomValue("VnicProfile", vnicProfile == null ? null : vnicProfile.getName());
    String[] unsupportedFeatureNames = new String[unsupportedFeatures.size()];
    for (int i = 0; i < unsupportedFeatures.size(); i++) {
        unsupportedFeatureNames[i] = unsupportedFeatures.get(i).getFeatureName();
    }
    event.addCustomValue("UnsupportedFeatures", StringUtils.join(unsupportedFeatureNames, ", "));
    new AuditLogDirector().log(event, AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES);
}
#method_after
protected static void reportUnsupportedVnicProfileFeatures(VM vm, VmNic nic, VnicProfile vnicProfile, List<VnicProfileProperties> unsupportedFeatures) {
    if (unsupportedFeatures.isEmpty()) {
        return;
    }
    AuditLogableBase event = new AuditLogableBase();
    event.setVmId(vm.getId());
    event.setClusterId(vm.getClusterId());
    event.setCustomId(nic.getId().toString());
    event.setCompatibilityVersion(vm.getCompatibilityVersion().toString());
    event.addCustomValue("NicName", nic.getName());
    event.addCustomValue("VnicProfile", vnicProfile == null ? null : vnicProfile.getName());
    String[] unsupportedFeatureNames = new String[unsupportedFeatures.size()];
    for (int i = 0; i < unsupportedFeatures.size(); i++) {
        unsupportedFeatureNames[i] = unsupportedFeatures.get(i).getFeatureName();
    }
    event.addCustomValue("UnsupportedFeatures", StringUtils.join(unsupportedFeatureNames, ", "));
    new AuditLogDirector().log(event, AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES);
}
#end_block

#method_before
public void buildVmSerialNumber() {
    new VmSerialNumberBuilder(vm, getVdsGroup(), createInfo).buildVmSerialNumber();
}
#method_after
public void buildVmSerialNumber() {
    new VmSerialNumberBuilder(vm, getCluster(), createInfo).buildVmSerialNumber();
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__UPDATE_SLA_POLICY);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__VM);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__UPDATE_SLA_POLICY);
    addValidationMessage(EngineMessage.VAR__TYPE__VM);
}
#end_block

#method_before
public boolean isMemorySnapshotSupported(VM vm) {
    if (vm == null) {
        return false;
    }
    boolean archMemorySnapshotSupported = isMemorySnapshotSupportedByArchitecture(vm.getClusterArch(), vm.getCompatibilityVersion());
    return ((Boolean) getConfigValuePreConverted(ConfigurationValues.MemorySnapshotSupported, vm.getCompatibilityVersion().toString())) && archMemorySnapshotSupported;
}
#method_after
public boolean isMemorySnapshotSupported(VM vm) {
    if (vm == null) {
        return false;
    }
    boolean archMemorySnapshotSupported = isMemorySnapshotSupportedByArchitecture(vm.getClusterArch(), vm.getCompatibilityVersion());
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.MemorySnapshotSupported, vm.getCompatibilityVersion().toString()) && archMemorySnapshotSupported;
}
#end_block

#method_before
public boolean isLiveMergeSupported(VM vm) {
    return (vm != null && (Boolean) getConfigValuePreConverted(ConfigurationValues.LiveMergeSupported, vm.getCompatibilityVersion().toString()));
}
#method_after
public boolean isLiveMergeSupported(VM vm) {
    return vm != null && (Boolean) getConfigValuePreConverted(ConfigurationValues.LiveMergeSupported, vm.getCompatibilityVersion().toString());
}
#end_block

#method_before
public void initBalloonSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            balloonSupportMap = (Map<Integer, Map<Version, Boolean>>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetBalloonSupportMap), callback);
}
#method_after
public void initBalloonSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            balloonSupportMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetBalloonSupportMap), callback);
}
#end_block

#method_before
public void getClusterById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupById, new IdQueryParameters(id), aQuery);
}
#method_after
public void getClusterById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterById, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public void getClusterListByName(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDSGroup>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Cluster: name=" + name + " sortby name", SearchType.Cluster), aQuery);
}
#method_after
public void getClusterListByName(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Cluster>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Cluster: name=" + name + " sortby name", SearchType.Cluster), aQuery);
}
#end_block

#method_before
public void getClusterList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getClusterList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Cluster> list = (ArrayList<Cluster>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<Cluster>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetClustersByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public List<VDSGroup> filterByArchitecture(List<VDSGroup> clusters, ArchitectureType targetArchitecture) {
    List<VDSGroup> filteredClusters = new ArrayList<>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getArchitecture().equals(targetArchitecture)) {
            filteredClusters.add(cluster);
        }
    }
    return filteredClusters;
}
#method_after
public List<Cluster> filterByArchitecture(List<Cluster> clusters, ArchitectureType targetArchitecture) {
    List<Cluster> filteredClusters = new ArrayList<>();
    for (Cluster cluster : clusters) {
        if (cluster.getArchitecture().equals(targetArchitecture)) {
            filteredClusters.add(cluster);
        }
    }
    return filteredClusters;
}
#end_block

#method_before
public List<VDSGroup> filterClustersWithoutArchitecture(List<VDSGroup> clusters) {
    List<VDSGroup> filteredClusters = new ArrayList<>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getArchitecture() != ArchitectureType.undefined) {
            filteredClusters.add(cluster);
        }
    }
    return filteredClusters;
}
#method_after
public List<Cluster> filterClustersWithoutArchitecture(List<Cluster> clusters) {
    List<Cluster> filteredClusters = new ArrayList<>();
    for (Cluster cluster : clusters) {
        if (cluster.getArchitecture() != ArchitectureType.undefined) {
            filteredClusters.add(cluster);
        }
    }
    return filteredClusters;
}
#end_block

#method_before
public void getClusterByServiceList(AsyncQuery aQuery, Guid dataCenterId, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDSGroup>();
            }
            final ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
            return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getClusterByServiceList(AsyncQuery aQuery, Guid dataCenterId, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Cluster>();
            }
            final ArrayList<Cluster> list = (ArrayList<Cluster>) source;
            return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetClustersByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public void getClusterListByService(AsyncQuery aQuery, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = getClusterByServiceList((ArrayList<VDSGroup>) source, supportsVirtService, supportsGlusterService);
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsGroups, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getClusterListByService(AsyncQuery aQuery, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Cluster> list = getClusterByServiceList((ArrayList<Cluster>) source, supportsVirtService, supportsGlusterService);
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<Cluster>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClusters, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getClusterList(AsyncQuery aQuery, boolean doRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsGroups, doRefresh ? new VdcQueryParametersBase() : new VdcQueryParametersBase().withoutRefresh(), aQuery);
}
#method_after
public void getClusterList(AsyncQuery aQuery, boolean doRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Cluster> list = (ArrayList<Cluster>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<Cluster>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClusters, doRefresh ? new VdcQueryParametersBase() : new VdcQueryParametersBase().withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getClustersWithPermittedAction(AsyncQuery aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
            }
            return new ArrayList<VDSGroup>();
        }
    };
    GetEntitiesWithPermittedActionParameters getEntitiesWithPermittedActionParameters = new GetEntitiesWithPermittedActionParameters();
    getEntitiesWithPermittedActionParameters.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetClustersWithPermittedAction, getEntitiesWithPermittedActionParameters, aQuery);
}
#method_after
public void getClustersWithPermittedAction(AsyncQuery aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Cluster> list = (ArrayList<Cluster>) source;
                return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
            }
            return new ArrayList<Cluster>();
        }
    };
    GetEntitiesWithPermittedActionParameters getEntitiesWithPermittedActionParameters = new GetEntitiesWithPermittedActionParameters();
    getEntitiesWithPermittedActionParameters.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetClustersWithPermittedAction, getEntitiesWithPermittedActionParameters, aQuery);
}
#end_block

#method_before
public void getClustersHavingHosts(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClustersHavingHosts, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getClustersHavingHosts(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Cluster> list = (ArrayList<Cluster>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<Cluster>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClustersHavingHosts, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getFilteredAttachableDisks(AsyncQuery aQuery, Guid storagePoolId, Guid vmId, int os, Version compatibilityVersion) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Disk>) source : new ArrayList<Disk>();
        }
    };
    GetFilteredAttachableDisksParameters params = new GetFilteredAttachableDisksParameters(storagePoolId);
    params.setVmId(vmId);
    params.setOs(os);
    params.setVdsGroupCompatibilityVersion(compatibilityVersion);
    Frontend.getInstance().runQuery(VdcQueryType.GetFilteredAttachableDisks, params, aQuery);
}
#method_after
public void getFilteredAttachableDisks(AsyncQuery aQuery, Guid storagePoolId, Guid vmId, int os, Version compatibilityVersion) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Disk>) source : new ArrayList<Disk>();
        }
    };
    GetFilteredAttachableDisksParameters params = new GetFilteredAttachableDisksParameters(storagePoolId);
    params.setVmId(vmId);
    params.setOs(os);
    params.setClusterCompatibilityVersion(compatibilityVersion);
    Frontend.getInstance().runQuery(VdcQueryType.GetFilteredAttachableDisks, params, aQuery);
}
#end_block

#method_before
public void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (originalInterface.getVlanId() == null) {
        // no vlan:
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = returnValue.getReturnValue();
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (Objects.equals(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else {
        // vlan:
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (Objects.equals(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#method_after
public void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (originalInterface.getVlanId() == null) {
        // no vlan:
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = returnValue.getReturnValue();
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (Objects.equals(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else {
        // vlan:
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (Objects.equals(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null) {
                        defaultInterfaceName.append(vlanParent.getName());
                    }
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#end_block

#method_before
public void getAllErrata(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Erratum>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetErrataForSystem, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getAllErrata(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Erratum>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetErrataForEngine, new GetErrataCountsParameters(), aQuery);
}
#end_block

#method_before
public boolean isCustomIconId(Guid iconId) {
    return (!largeToSmallOsDefaultIconIdMap.containsKey(iconId)) && (!largeToSmallOsDefaultIconIdMap.containsValue(iconId));
}
#method_after
public boolean isCustomIconId(Guid iconId) {
    return !largeToSmallOsDefaultIconIdMap.containsKey(iconId) && !largeToSmallOsDefaultIconIdMap.containsValue(iconId);
}
#end_block

#method_before
public void getNumberOfActiveVmsInCluster(AsyncQuery aQuery, Guid clusterId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return Integer.valueOf(0);
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetNumberOfActiveVmsInVdsGroupByVdsGroupId, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getNumberOfActiveVmsInCluster(AsyncQuery aQuery, Guid clusterId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return Integer.valueOf(0);
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetNumberOfActiveVmsInClusterByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
public void getNumberOfVmsInCluster(AsyncQuery aQuery, Guid clusterId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetNumberOfVmsInVdsGroupByVdsGroupId, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getNumberOfVmsInCluster(AsyncQuery aQuery, Guid clusterId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetNumberOfVmsInClusterByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
public ArrayList<VDSGroup> getClusterByServiceList(List<VDSGroup> list, boolean supportsVirtService, boolean supportsGlusterService) {
    final ArrayList<VDSGroup> filteredList = new ArrayList<>();
    for (VDSGroup cluster : list) {
        if ((supportsVirtService && cluster.supportsVirtService()) || (supportsGlusterService && cluster.supportsGlusterService())) {
            filteredList.add(cluster);
        }
    }
    // sort by cluster name
    Collections.sort(filteredList, new NameableComparator());
    return filteredList;
}
#method_after
public ArrayList<Cluster> getClusterByServiceList(List<Cluster> list, boolean supportsVirtService, boolean supportsGlusterService) {
    final ArrayList<Cluster> filteredList = new ArrayList<>();
    for (Cluster cluster : list) {
        if ((supportsVirtService && cluster.supportsVirtService()) || (supportsGlusterService && cluster.supportsGlusterService())) {
            filteredList.add(cluster);
        }
    }
    // sort by cluster name
    Collections.sort(filteredList, new NameableComparator());
    return filteredList;
}
#end_block

#method_before
public void getVMsWithVNumaNodesByClusterId(AsyncQuery asyncQuery, Guid clusterId) {
    asyncQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery asyncQuery) {
            if (source == null) {
                return new ArrayList<VM>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmsWithNumaByVdsGroupId, new IdQueryParameters(clusterId), asyncQuery);
}
#method_after
public void getVMsWithVNumaNodesByClusterId(AsyncQuery asyncQuery, Guid clusterId) {
    asyncQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery asyncQuery) {
            if (source == null) {
                return new ArrayList<VM>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmsWithNumaByClusterId, new IdQueryParameters(clusterId), asyncQuery);
}
#end_block

#method_before
public void getClusterEditWarnings(AsyncQuery aQuery, Guid clusterId, VDSGroup cluster) {
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterEditWarnings, new ClusterEditParameters(cluster), aQuery);
}
#method_after
public void getClusterEditWarnings(AsyncQuery aQuery, Guid clusterId, Cluster cluster) {
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterEditWarnings, new ClusterEditParameters(cluster), aQuery);
}
#end_block

#method_before
public void postOnNew(List<VdcReturnValueBase> returnValues) {
    SnapshotModel model = (SnapshotModel) getWindow();
    model.stopProgress();
    if (returnValues != null && Linq.all(returnValues, new Linq.CanDoActionSucceedPredicate())) {
        cancel();
    }
}
#method_after
public void postOnNew(List<VdcReturnValueBase> returnValues) {
    SnapshotModel model = (SnapshotModel) getWindow();
    model.stopProgress();
    if (returnValues != null && Linq.all(returnValues, new Linq.ValidateSucceedPredicate())) {
        cancel();
    }
}
#end_block

#method_before
protected void updateIsCloneVmSupported() {
    if (getEntity() == null) {
        return;
    }
    final VM vm = getEntity();
    AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmSnapshotListModel model = (VmSnapshotListModel) target;
            StoragePool dataCenter = (StoragePool) returnValue;
            Version minVmVersion = vm.getCompatibilityVersion();
            Version minDcVersion = dataCenter.getCompatibilityVersion();
            AsyncDataProvider.getInstance().isCommandCompatible(new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    VmSnapshotListModel model = (VmSnapshotListModel) target;
                    model.setIsCloneVmSupported((Boolean) returnValue);
                }
            }), VdcActionType.AddVmFromSnapshot, minVmVersion, minDcVersion);
        }
    }), vm.getStoragePoolId());
}
#method_after
protected void updateIsCloneVmSupported() {
    if (getEntity() == null) {
        return;
    }
    final VM vm = getEntity();
    AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmSnapshotListModel model = (VmSnapshotListModel) target;
            StoragePool dataCenter = (StoragePool) returnValue;
            if (dataCenter == null) {
                return;
            }
            Version minVmVersion = vm.getCompatibilityVersion();
            Version minDcVersion = dataCenter.getCompatibilityVersion();
            AsyncDataProvider.getInstance().isCommandCompatible(new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    VmSnapshotListModel model = (VmSnapshotListModel) target;
                    model.setIsCloneVmSupported((Boolean) returnValue);
                }
            }), VdcActionType.AddVmFromSnapshot, minVmVersion, minDcVersion);
        }
    }), vm.getStoragePoolId());
}
#end_block

#method_before
public boolean canRunVm(List<String> messages, StoragePool storagePool, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, List<Guid> destVdsList, VDSGroup vdsGroup) {
    if (vm.getStatus() == VMStatus.Paused) {
        // as the rest of the checks were already checked before
        return validate(validateVdsStatus(vm), messages);
    } else if (vm.getStatus() == VMStatus.Suspended) {
        return validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStorageDomains(vm, isInternalExecution, filterReadOnlyAndPreallocatedDisks(getVmImageDisks())), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && getSchedulingManager().canSchedule(vdsGroup, vm, vdsBlackList, vdsWhiteList, destVdsList, messages);
    }
    return validateVmProperties(vm, runVmParam.getCustomProperties(), messages) && validate(validateBootSequence(vm, runVmParam.getBootSequence(), getVmDisks(), activeIsoDomainId), messages) && validate(validateDisplayType(), messages) && validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(validateIsoPath(vm, runVmParam.getDiskPath(), runVmParam.getFloppyPath(), activeIsoDomainId), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStatelessVm(vm, runVmParam.getRunAsStateless()), messages) && validate(validateFloppy(), messages) && validate(validateStorageDomains(vm, isInternalExecution, filterReadOnlyAndPreallocatedDisks(getVmImageDisks())), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && validate(validateMemorySize(vm), messages) && getSchedulingManager().canSchedule(vdsGroup, vm, vdsBlackList, vdsWhiteList, destVdsList, messages);
}
#method_after
public boolean canRunVm(List<String> messages, StoragePool storagePool, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, List<Guid> destVdsList, Cluster cluster) {
    if (vm.getStatus() == VMStatus.Paused) {
        // as the rest of the checks were already checked before
        return validate(validateVdsStatus(vm), messages);
    } else if (vm.getStatus() == VMStatus.Suspended) {
        return validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStorageDomains(vm, isInternalExecution, filterReadOnlyAndPreallocatedDisks(getVmImageDisks())), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && getSchedulingManager().canSchedule(cluster, vm, vdsBlackList, vdsWhiteList, destVdsList, messages);
    }
    return validateVmProperties(vm, runVmParam.getCustomProperties(), messages) && validate(validateBootSequence(vm, runVmParam.getBootSequence(), getVmDisks(), activeIsoDomainId), messages) && validate(validateDisplayType(), messages) && validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(validateIsoPath(vm, runVmParam.getDiskPath(), runVmParam.getFloppyPath(), activeIsoDomainId), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStatelessVm(vm, runVmParam.getRunAsStateless()), messages) && validate(validateFloppy(), messages) && validate(validateStorageDomains(vm, isInternalExecution, filterReadOnlyAndPreallocatedDisks(getVmImageDisks())), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && validate(validateMemorySize(vm), messages) && getSchedulingManager().canSchedule(cluster, vm, vdsBlackList, vdsWhiteList, destVdsList, messages);
}
#end_block

#method_before
protected ValidationResult validateInterfacesConfigured(VM vm) {
    for (VmNetworkInterface nic : vm.getInterfaces()) {
        if (nic.getVnicProfileId() == null) {
            return FeatureSupported.networkLinking(vm.getVdsGroupCompatibilityVersion()) ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_INTERFACE_NETWORK_NOT_CONFIGURED);
        }
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult validateInterfacesConfigured(VM vm) {
    for (VmNetworkInterface nic : vm.getInterfaces()) {
        if (nic.getVnicProfileId() == null) {
            return FeatureSupported.networkLinking(vm.getClusterCompatibilityVersion()) ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_INTERFACE_NETWORK_NOT_CONFIGURED);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
protected ValidationResult validateInterfacesAttachedToClusterNetworks(VM vm, final Set<String> clusterNetworkNames, final Set<String> interfaceNetworkNames) {
    Set<String> result = new HashSet<>(interfaceNetworkNames);
    result.removeAll(clusterNetworkNames);
    if (FeatureSupported.networkLinking(vm.getVdsGroupCompatibilityVersion())) {
        result.remove(null);
    }
    // aren't attached to the cluster
    return result.isEmpty() ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_NOT_IN_CLUSTER, String.format("$networks %1$s", StringUtils.join(result, ",")));
}
#method_after
protected ValidationResult validateInterfacesAttachedToClusterNetworks(VM vm, final Set<String> clusterNetworkNames, final Set<String> interfaceNetworkNames) {
    Set<String> result = new HashSet<>(interfaceNetworkNames);
    result.removeAll(clusterNetworkNames);
    if (FeatureSupported.networkLinking(vm.getClusterCompatibilityVersion())) {
        result.remove(null);
    }
    // aren't attached to the cluster
    return result.isEmpty() ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_NOT_IN_CLUSTER, String.format("$networks %1$s", StringUtils.join(result, ",")));
}
#end_block

#method_before
private List<Network> getClusterNetworks() {
    if (cachedClusterNetworks == null) {
        cachedClusterNetworks = getNetworkDao().getAllForCluster(vm.getVdsGroupId());
    }
    return cachedClusterNetworks;
}
#method_after
private List<Network> getClusterNetworks() {
    if (cachedClusterNetworks == null) {
        cachedClusterNetworks = getNetworkDao().getAllForCluster(vm.getClusterId());
    }
    return cachedClusterNetworks;
}
#end_block

#method_before
private void updateScanAlignmentCommandAvailability() {
    boolean isExecutionAllowed = true;
    if (getSelectedItems() != null && getEntity() != null) {
        ArrayList<Disk> disks = Linq.<Disk>cast(getSelectedItems());
        for (Disk disk : disks) {
            if (!(disk instanceof LunDisk) && !isDiskOnBlockDevice(disk)) {
                isExecutionAllowed = false;
                break;
            }
        }
    } else {
        isExecutionAllowed = false;
    }
    getScanAlignmentCommand().setIsExecutionAllowed(isExecutionAllowed);
// onPropertyChanged(new PropertyChangedEventArgs("IsScanAlignmentEnabled")); //$NON-NLS-1$
}
#method_after
private void updateScanAlignmentCommandAvailability() {
    boolean isExecutionAllowed = true;
    if (isVmDown() && getSelectedItems() != null && getEntity() != null) {
        ArrayList<Disk> disks = Linq.<Disk>cast(getSelectedItems());
        for (Disk disk : disks) {
            if (!(disk instanceof LunDisk) && !isDiskOnBlockDevice(disk)) {
                isExecutionAllowed = false;
                break;
            }
        }
    } else {
        isExecutionAllowed = false;
    }
    getScanAlignmentCommand().setIsExecutionAllowed(isExecutionAllowed);
// onPropertyChanged(new PropertyChangedEventArgs("IsScanAlignmentEnabled")); //$NON-NLS-1$
}
#end_block

#method_before
protected boolean isDiskPassPciAndIdeLimit(Disk diskInfo) {
    List<VmNic> vmInterfaces = getVmNicDao().getAllForVm(getVmId());
    List<Disk> allVmDisks = new ArrayList<>(getVm().getDiskMap().values());
    allVmDisks.add(diskInfo);
    return checkPciAndIdeLimit(getVm().getOs(), getVm().getCompatibilityVersion(), getVm().getNumOfMonitors(), vmInterfaces, allVmDisks, isVirtioScsiControllerAttached(getVmId()), hasWatchdog(getVmId()), isBalloonEnabled(getVmId()), isSoundDeviceEnabled(getVmId()), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean isDiskPassPciAndIdeLimit(Disk diskInfo) {
    List<VmNic> vmInterfaces = getVmNicDao().getAllForVm(getVmId());
    List<Disk> allVmDisks = new ArrayList<>(getVm().getDiskMap().values());
    allVmDisks.add(diskInfo);
    return checkPciAndIdeLimit(getVm().getOs(), getVm().getCompatibilityVersion(), getVm().getNumOfMonitors(), vmInterfaces, allVmDisks, isVirtioScsiControllerAttached(getVmId()), hasWatchdog(getVmId()), isBalloonEnabled(getVmId()), isSoundDeviceEnabled(getVmId()), getReturnValue().getValidationMessages());
}
#end_block

#method_before
protected boolean isDiskCanBeAddedToVm(Disk diskInfo, VM vm) {
    if (!diskInfo.isDiskSnapshot() && diskInfo.isBoot()) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.isBoot() && !disk.isDiskSnapshot()) {
                addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_DISK_BOOT_IN_USE);
                getReturnValue().getCanDoActionMessages().add(String.format("$DiskName %1$s", disk.getDiskAlias()));
                getReturnValue().getCanDoActionMessages().add(String.format("$VmName %1$s", vm.getName()));
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean isDiskCanBeAddedToVm(Disk diskInfo, VM vm) {
    if (!diskInfo.isDiskSnapshot() && diskInfo.isBoot()) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.isBoot() && !disk.isDiskSnapshot()) {
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_DISK_BOOT_IN_USE);
                getReturnValue().getValidationMessages().add(String.format("$DiskName %1$s", disk.getDiskAlias()));
                getReturnValue().getValidationMessages().add(String.format("$VmName %1$s", vm.getName()));
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
protected boolean isVmExist() {
    if (getVm() == null) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    return true;
}
#method_after
protected boolean isVmExist() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean isDiskExist(Disk disk) {
    if (disk == null || !isDiskExistInVm(disk)) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
        return false;
    }
    return true;
}
#method_after
protected boolean isDiskExist(Disk disk) {
    if (disk == null || !isDiskExistInVm(disk)) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean isHotPlugDiskSnapshotSupported() {
    if (!FeatureSupported.hotPlugDiskSnapshot(getVds().getVdsGroupCompatibilityVersion())) {
        return failCanDoAction(EngineMessage.HOT_PLUG_DISK_SNAPSHOT_IS_NOT_SUPPORTED);
    }
    return true;
}
#method_after
protected boolean isHotPlugDiskSnapshotSupported() {
    if (!FeatureSupported.hotPlugDiskSnapshot(getVds().getClusterCompatibilityVersion())) {
        return failValidation(EngineMessage.HOT_PLUG_DISK_SNAPSHOT_IS_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__HOT_SET_CPUS);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__VM);
    addCanDoActionMessageVariable("clusterVersion", getVm().getCompatibilityVersion());
    addCanDoActionMessageVariable("architecture", getVm().getClusterArch());
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__HOT_SET_CPUS);
    addValidationMessage(EngineMessage.VAR__TYPE__VM);
    addValidationMessageVariable("clusterVersion", getVm().getCompatibilityVersion());
    addValidationMessageVariable("architecture", getVm().getClusterArch());
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    // Calculate the change in CPU consumption, result above Zero means we add CPUs to
    // the VM
    // result bellow Zero means we subtracted CPUs from the VM
    int cpuToConsume = getParameters().getVm().getNumOfCpus() - getVm().getNumOfCpus();
    if (cpuToConsume > 0) {
        // Consume CPU quota
        list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getVm().getVdsGroupId(), getVm().getCpuPerSocket() * getVm().getThreadsPerCpu() * cpuToConsume, 0));
    } else if (cpuToConsume < 0) {
        // Release CPU quota
        list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getVm().getVdsGroupId(), getVm().getCpuPerSocket() * getVm().getThreadsPerCpu() * Math.abs(cpuToConsume), 0));
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    // Calculate the change in CPU consumption, result above Zero means we add CPUs to
    // the VM
    // result bellow Zero means we subtracted CPUs from the VM
    int cpuToConsume = getParameters().getVm().getNumOfCpus() - getVm().getNumOfCpus();
    if (cpuToConsume > 0) {
        // Consume CPU quota
        list.add(new QuotaClusterConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getVm().getClusterId(), getVm().getCpuPerSocket() * getVm().getThreadsPerCpu() * cpuToConsume, 0));
    } else if (cpuToConsume < 0) {
        // Release CPU quota
        list.add(new QuotaClusterConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getVm().getClusterId(), getVm().getCpuPerSocket() * getVm().getThreadsPerCpu() * Math.abs(cpuToConsume), 0));
    }
    return list;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__TYPE__VM);
    addCanDoActionMessage(EngineMessage.VAR__ACTION__HIBERNATE);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__TYPE__VM);
    addValidationMessage(EngineMessage.VAR__ACTION__HIBERNATE);
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    List<Map<String, String>> drives = new ArrayList<>(vm.getDiskMap().size());
    int ideCount = 0, pciCount = 0;
    List<Disk> disks = getSortedDisks();
    List<VmDevice> vmDiskDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName());
    for (Disk temp : disks) {
        DiskImage disk = (DiskImage) temp;
        // Get the VM device for this disk
        VmDevice vmDevice = findVmDeviceForDisk(disk.getId(), vmDiskDevices);
        if (vmDevice == null || vmDevice.getIsPlugged()) {
            Map<String, String> drive = new HashMap<>();
            drive.put("domainID", disk.getStorageIds().get(0).toString());
            drive.put("poolID", disk.getStoragePoolId().toString());
            drive.put("volumeID", disk.getImageId().toString());
            drive.put("imageID", disk.getId().toString());
            drive.put("format", disk.getVolumeFormat().toString().toLowerCase());
            drive.put("propagateErrors", disk.getPropagateErrors().toString().toLowerCase());
            switch(disk.getDiskInterface()) {
                case IDE:
                    try {
                        drive.put("if", "ide");
                        drive.put("index", String.valueOf(ideIndexSlots[ideCount]));
                        ideCount++;
                    } catch (IndexOutOfBoundsException e) {
                        log.error("buildVmDrives throws IndexOutOfBoundsException for index {}, IDE slots are limited to 4.", ideCount);
                        throw e;
                    }
                    break;
                case VirtIO:
                    drive.put("if", "virtio");
                    drive.put("index", String.valueOf(pciCount));
                    drive.put("boot", String.valueOf(disk.isBoot()).toLowerCase());
                    pciCount++;
                    break;
                default:
                    // ISCI not supported
                    logUnsupportedInterfaceType();
                    break;
            }
            drives.add(drive);
        }
    }
    Map<String, String>[] drivesArray = new Map[drives.size()];
    createInfo.put("drives", drives.toArray(drivesArray));
}
#method_after
@Override
protected void buildVmDrives() {
    List<Map<String, String>> drives = new ArrayList<>(vm.getDiskMap().size());
    int ideCount = 0;
    int pciCount = 0;
    List<Disk> disks = getSortedDisks();
    List<VmDevice> vmDiskDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName());
    for (Disk temp : disks) {
        DiskImage disk = (DiskImage) temp;
        // Get the VM device for this disk
        VmDevice vmDevice = findVmDeviceForDisk(disk.getId(), vmDiskDevices);
        if (vmDevice == null || vmDevice.getIsPlugged()) {
            Map<String, String> drive = new HashMap<>();
            drive.put("domainID", disk.getStorageIds().get(0).toString());
            drive.put("poolID", disk.getStoragePoolId().toString());
            drive.put("volumeID", disk.getImageId().toString());
            drive.put("imageID", disk.getId().toString());
            drive.put("format", disk.getVolumeFormat().toString().toLowerCase());
            drive.put("propagateErrors", disk.getPropagateErrors().toString().toLowerCase());
            switch(disk.getDiskInterface()) {
                case IDE:
                    try {
                        drive.put("if", "ide");
                        drive.put("index", String.valueOf(ideIndexSlots[ideCount]));
                        ideCount++;
                    } catch (IndexOutOfBoundsException e) {
                        log.error("buildVmDrives throws IndexOutOfBoundsException for index {}, IDE slots are limited to 4.", ideCount);
                        throw e;
                    }
                    break;
                case VirtIO:
                    drive.put("if", "virtio");
                    drive.put("index", String.valueOf(pciCount));
                    drive.put("boot", String.valueOf(disk.isBoot()).toLowerCase());
                    pciCount++;
                    break;
                default:
                    // ISCI not supported
                    logUnsupportedInterfaceType();
                    break;
            }
            drives.add(drive);
        }
    }
    Map<String, String>[] drivesArray = new Map[drives.size()];
    createInfo.put("drives", drives.toArray(drivesArray));
}
#end_block

#method_before
@Override
protected void buildVmBootSequence() {
    // get device list for the VM
    List<VmDevice> devices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmId(vm.getId());
    String bootSeqInDB = VmDeviceCommonUtils.getBootSequence(devices).toString().toLowerCase();
    String bootSeqInBE = vm.getBootSequence().toString().toLowerCase();
    // TODO : find another way to distinguish run vs. run-once
    if (bootSeqInBE.equals(bootSeqInDB))
        createInfo.put(VdsProperties.Boot, bootSeqInDB);
    else
        // run once
        createInfo.put(VdsProperties.Boot, bootSeqInBE);
}
#method_after
@Override
protected void buildVmBootSequence() {
    // get device list for the VM
    List<VmDevice> devices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmId(vm.getId());
    String bootSeqInDB = VmDeviceCommonUtils.getBootSequence(devices).toString().toLowerCase();
    String bootSeqInBE = vm.getBootSequence().toString().toLowerCase();
    // TODO : find another way to distinguish run vs. run-once
    if (bootSeqInBE.equals(bootSeqInDB)) {
        createInfo.put(VdsProperties.Boot, bootSeqInDB);
    } else {
        // run once
        createInfo.put(VdsProperties.Boot, bootSeqInBE);
    }
}
#end_block

#method_before
private void updateSystemTabLists() {
    Guid clusterId = vm.getVdsGroupId();
    if (clusterId != null) {
        // update emulated machine list
        AsyncDataProvider.getInstance().getEmulatedMachinesByClusterID(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                if (returnValue != null) {
                    Set<String> emulatedSet = new TreeSet<>((HashSet<String>) returnValue);
                    String oldVal = getEmulatedMachine().getSelectedItem();
                    getEmulatedMachine().setItems(emulatedSet);
                    // even if converted - needed as fallback
                    getEmulatedMachine().setSelectedItem(oldVal);
                    convertEmulatedMachineField();
                }
            }
        }), clusterId);
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                if (returnValue != null) {
                    VDSGroup cluster = (VDSGroup) returnValue;
                    // update cpu names list
                    if (cluster.getCpuName() != null) {
                        AsyncDataProvider.getInstance().getSupportedCpuList(new AsyncQuery(this, new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                if (returnValue != null) {
                                    List<String> cpuList = new ArrayList<>();
                                    for (ServerCpu cpu : (List<ServerCpu>) returnValue) {
                                        cpuList.add(cpu.getVdsVerbData());
                                    }
                                    String oldVal = getCustomCpu().getSelectedItem();
                                    getCustomCpu().setItems(cpuList);
                                    // replace 'cluster cpu' with the explicit run-time value
                                    if (StringHelper.isNullOrEmpty(oldVal) && !cpuList.isEmpty()) {
                                        getCustomCpu().setSelectedItem(cpuList.get(cpuList.size() - 1));
                                    } else {
                                        getCustomCpu().setSelectedItem(oldVal);
                                    }
                                }
                            }
                        }), cluster.getCpuName());
                    }
                }
            }
        }), clusterId);
    }
}
#method_after
private void updateSystemTabLists() {
    Guid clusterId = vm.getClusterId();
    if (clusterId != null) {
        // update emulated machine list
        AsyncDataProvider.getInstance().getEmulatedMachinesByClusterID(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                if (returnValue != null) {
                    Set<String> emulatedSet = new TreeSet<>((HashSet<String>) returnValue);
                    String oldVal = getEmulatedMachine().getSelectedItem();
                    getEmulatedMachine().setItems(emulatedSet);
                    // even if converted - needed as fallback
                    getEmulatedMachine().setSelectedItem(oldVal);
                    convertEmulatedMachineField();
                }
            }
        }), clusterId);
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                if (returnValue != null) {
                    Cluster cluster = (Cluster) returnValue;
                    // update cpu names list
                    if (cluster.getCpuName() != null) {
                        AsyncDataProvider.getInstance().getSupportedCpuList(new AsyncQuery(this, new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                if (returnValue != null) {
                                    List<String> cpuList = new ArrayList<>();
                                    for (ServerCpu cpu : (List<ServerCpu>) returnValue) {
                                        cpuList.add(cpu.getVdsVerbData());
                                    }
                                    String oldVal = getCustomCpu().getSelectedItem();
                                    getCustomCpu().setItems(cpuList);
                                    // replace 'cluster cpu' with the explicit run-time value
                                    if (StringHelper.isNullOrEmpty(oldVal) && !cpuList.isEmpty()) {
                                        getCustomCpu().setSelectedItem(cpuList.get(cpuList.size() - 1));
                                    } else {
                                        getCustomCpu().setSelectedItem(oldVal);
                                    }
                                }
                            }
                        }), cluster.getCpuName());
                    }
                }
            }
        }), clusterId);
    }
}
#end_block

#method_before
private void convertEmulatedMachineField() {
    if (StringHelper.isNullOrEmpty(getEmulatedMachine().getSelectedItem())) {
        Guid clusterId = vm.getVdsGroupId();
        if (clusterId != null) {
            AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    if (returnValue != null) {
                        VDSGroup cluster = (VDSGroup) returnValue;
                        if (cluster.getEmulatedMachine() != null) {
                            getEmulatedMachine().setSelectedItem(cluster.getEmulatedMachine());
                        }
                    }
                }
            }), clusterId);
        }
    }
}
#method_after
private void convertEmulatedMachineField() {
    if (StringHelper.isNullOrEmpty(getEmulatedMachine().getSelectedItem())) {
        Guid clusterId = vm.getClusterId();
        if (clusterId != null) {
            AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    if (returnValue != null) {
                        Cluster cluster = (Cluster) returnValue;
                        if (cluster.getEmulatedMachine() != null) {
                            getEmulatedMachine().setSelectedItem(cluster.getEmulatedMachine());
                        }
                    }
                }
            }), clusterId);
        }
    }
}
#end_block

#method_before
private void updateDatacenters() {
    boolean isInVm = getVm() != null;
    getDataCenter().setIsAvailable(!isInVm);
    // $NON-NLS-1$
    setMessage("");
    if (isInVm) {
        AsyncDataProvider.getInstance().getDataCenterById((new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                AbstractDiskModel diskModel = (AbstractDiskModel) target;
                StoragePool dataCenter = (StoragePool) returnValue;
                ArrayList<StoragePool> dataCenters = new ArrayList<>();
                if (isDatacenterAvailable(dataCenter)) {
                    dataCenters.add(dataCenter);
                }
                diskModel.getDataCenter().setItems(dataCenters, Linq.firstOrNull(dataCenters));
                if (dataCenters.isEmpty()) {
                    diskModel.setMessage(constants.relevantDCnotActive());
                }
            }
        })), getVm().getStoragePoolId());
        updateBootableDiskAvailable();
    } else {
        AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                AbstractDiskModel diskModel = (AbstractDiskModel) target;
                ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                ArrayList<StoragePool> filteredDataCenters = new ArrayList<>();
                for (StoragePool dataCenter : dataCenters) {
                    if (isDatacenterAvailable(dataCenter)) {
                        filteredDataCenters.add(dataCenter);
                    }
                }
                diskModel.getDataCenter().setItems(filteredDataCenters);
                if (filteredDataCenters.isEmpty()) {
                    diskModel.setMessage(constants.noActiveDataCenters());
                }
            }
        }));
    }
}
#method_after
private void updateDatacenters() {
    boolean isInVm = getVm() != null;
    getDataCenter().setIsAvailable(!isInVm);
    // $NON-NLS-1$
    setMessage("");
    if (isInVm) {
        AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                AbstractDiskModel diskModel = (AbstractDiskModel) target;
                StoragePool dataCenter = (StoragePool) returnValue;
                ArrayList<StoragePool> dataCenters = new ArrayList<>();
                if (isDatacenterAvailable(dataCenter)) {
                    dataCenters.add(dataCenter);
                }
                diskModel.getDataCenter().setItems(dataCenters, Linq.firstOrNull(dataCenters));
                if (dataCenters.isEmpty()) {
                    diskModel.setMessage(constants.relevantDCnotActive());
                }
            }
        }), getVm().getStoragePoolId());
        updateBootableDiskAvailable();
    } else {
        AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                AbstractDiskModel diskModel = (AbstractDiskModel) target;
                ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                ArrayList<StoragePool> filteredDataCenters = new ArrayList<>();
                for (StoragePool dataCenter : dataCenters) {
                    if (isDatacenterAvailable(dataCenter)) {
                        filteredDataCenters.add(dataCenter);
                    }
                }
                diskModel.getDataCenter().setItems(filteredDataCenters);
                if (filteredDataCenters.isEmpty()) {
                    diskModel.setMessage(constants.noActiveDataCenters());
                }
            }
        }));
    }
}
#end_block

#method_before
public boolean validate() {
    getDescription().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    if (getVm() == null) {
        getAlias().validateEntity(new IValidation[] { new NotEmptyValidation(), new I18NNameValidation() });
    } else {
        getAlias().validateEntity(new IValidation[] { new I18NNameValidation() });
    }
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getCinderVolumeType().getIsAvailable()) {
        getCinderVolumeType().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    return getAlias().getIsValid() && getDescription().getIsValid() && getQuota().getIsValid() && getDiskInterface().getIsValid() && getCinderVolumeType().getIsValid();
}
#method_after
public boolean validate() {
    getDescription().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.DISK_DESCRIPTION_MAX_SIZE) });
    getAlias().validateEntity(getDiskAliasValidations());
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getCinderVolumeType().getIsAvailable()) {
        getCinderVolumeType().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    return getAlias().getIsValid() && getDescription().getIsValid() && getQuota().getIsValid() && getDiskInterface().getIsValid() && getCinderVolumeType().getIsValid();
}
#end_block

#method_before
/*
     * Video device
     */
private static void updateVideoDevices(VmBase oldVmBase, VmBase newVmBase) {
    boolean displayTypeChanged = oldVmBase.getDefaultDisplayType() != newVmBase.getDefaultDisplayType();
    boolean numOfMonitorsChanged = newVmBase.getDefaultDisplayType() == DisplayType.qxl && oldVmBase.getNumOfMonitors() != newVmBase.getNumOfMonitors();
    boolean singleQxlChanged = oldVmBase.getSingleQxlPci() != newVmBase.getSingleQxlPci();
    if (displayTypeChanged || numOfMonitorsChanged || singleQxlChanged) {
        removeVideoDevices(oldVmBase.getId());
        addVideoDevices(newVmBase, getNeededNumberOfVideoDevices(newVmBase));
    }
}
#method_after
/*
     * Video device
     */
private static void updateVideoDevices(VmBase oldVmBase, VmBase newVmBase) {
    boolean displayTypeChanged = oldVmBase.getDefaultDisplayType() != newVmBase.getDefaultDisplayType();
    boolean numOfMonitorsChanged = newVmBase.getDefaultDisplayType() == DisplayType.qxl && oldVmBase.getNumOfMonitors() != newVmBase.getNumOfMonitors();
    boolean singleQxlChanged = oldVmBase.getSingleQxlPci() != newVmBase.getSingleQxlPci();
    boolean guestOsChanged = oldVmBase.getOsId() != newVmBase.getOsId();
    if (displayTypeChanged || numOfMonitorsChanged || singleQxlChanged || guestOsChanged) {
        removeVideoDevices(oldVmBase.getId());
        addVideoDevices(newVmBase, getNeededNumberOfVideoDevices(newVmBase));
    }
}
#end_block

#method_before
private static Map<String, Object> getVideoDeviceSpecParams(VmBase vmBase) {
    return getVideoDeviceSpecParams(vmBase.getNumOfMonitors(), vmBase.getSingleQxlPci());
}
#method_after
private static Map<String, Object> getVideoDeviceSpecParams(VmBase vmBase) {
    return VideoDeviceSettings.getVideoDeviceSpecParams(vmBase);
}
#end_block

#method_before
/*
     * Generic device methods
     */
public static String getVmDeviceAddress(VmBase vmBase, final Guid deviceId) {
    VmDevice device = vmBase.getManagedDeviceMap().get(deviceId);
    if (device != null)
        return device.getAddress();
    else
        return StringUtils.EMPTY;
}
#method_after
/*
     * Generic device methods
     */
public static String getVmDeviceAddress(VmBase vmBase, final Guid deviceId) {
    VmDevice device = vmBase.getManagedDeviceMap().get(deviceId);
    if (device != null) {
        return device.getAddress();
    } else {
        return StringUtils.EMPTY;
    }
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    VM dstVm = dbFacade.getVmDao().get(dstId);
    VmBase dstVmBase = (dstVm != null) ? dstVm.getStaticData() : null;
    boolean dstIsVm = (dstVmBase != null);
    if (!dstIsVm) {
        dstVmBase = dbFacade.getVmTemplateDao().get(dstId);
    }
    List<VmDevice> srcDevices = dao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, dstVm, dstVmBase, dstIsVm, srcDevices, srcDeviceIdToDstDeviceIdMapping, isSoundEnabled, isConsoleEnabled, isVirtioScsiEnabled, isBalloonEnabled, graphicsToSkip, copySnapshotDevices);
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, VmBase dstVmBase, List<VmDevice> srcDevices, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices, boolean copyHostDevices) {
    if (graphicsToSkip == null) {
        graphicsToSkip = Collections.emptySet();
    }
    String dstCdPath = dstVmBase.getIsoPath();
    boolean dstIsVm = !(dstVmBase instanceof VmTemplate);
    boolean hasCd = hasCdDevice(dstVmBase.getId());
    boolean hasSound = false;
    boolean hasConsole = false;
    boolean hasVirtioScsi = false;
    boolean hasBalloon = false;
    boolean hasRng = hasRngDevice(dstId);
    Cluster cluster = null;
    if (dstVmBase.getClusterId() != null) {
        cluster = DbFacade.getInstance().getClusterDao().get(dstVmBase.getClusterId());
    }
    for (VmDevice device : srcDevices) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        Guid deviceId = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<>();
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                        deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    if (!hasCd) {
                        hasCd = true;
                        // check here is source VM had CD (VM from snapshot)
                        String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                        specParams.putAll(getCdDeviceSpecParams(srcCdPath, dstCdPath));
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                    deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsi = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (dstIsVm) {
                    // to the new VmStatic params.
                    continue;
                }
                specParams.putAll(getVideoDeviceSpecParams(dstVmBase));
                break;
            case BALLOON:
                if (!isBalloonEnabled) {
                    continue;
                }
                hasBalloon = true;
                specParams.putAll(getMemoryBalloonSpecParams());
                break;
            case SMARTCARD:
                specParams.putAll(getSmartcardDeviceSpecParams());
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasRng) {
                    continue;
                }
                if (!new VirtIoRngValidator().canAddRngDevice(cluster, new VmRngDevice(device)).isValid()) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                if (!isConsoleEnabled) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                hasConsole = true;
                break;
            case SOUND:
                if (!isSoundEnabled) {
                    continue;
                }
                hasSound = true;
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasGraphicsDevice(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            case HOSTDEV:
                if (!copyHostDevices) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(deviceId, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    if (!hasCd) {
        addCdDevice(dstId, dstCdPath);
    }
    // according to the destination USB policy
    if (srcId.equals(Guid.Empty)) {
        updateUsbSlots(null, dstVmBase);
    }
    if (isSoundEnabled && !hasSound) {
        if (dstIsVm) {
            addSoundDevice(dstVmBase);
        } else {
            addSoundDevice(dstVmBase.getId(), dstVmBase.getOsId(), cluster != null ? cluster.getCompatibilityVersion() : null);
        }
    }
    if (isConsoleEnabled && !hasConsole) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsi) {
        addVirtioScsiController(dstId);
    }
    if (isBalloonEnabled && !hasBalloon) {
        addMemoryBalloon(dstId);
    }
    if (dstIsVm) {
        updateBootOrder(dstVmBase.getId());
        addVideoDevices(dstVmBase, getNeededNumberOfVideoDevices(dstVmBase));
    }
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    VM dstVm = dbFacade.getVmDao().get(dstId);
    VmBase dstVmBase = (dstVm != null) ? dstVm.getStaticData() : null;
    boolean dstIsVm = (dstVmBase != null);
    if (!dstIsVm) {
        dstVmBase = dbFacade.getVmTemplateDao().get(dstId);
    }
    List<VmDevice> srcDevices = dao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, dstVm, dstVmBase, dstIsVm, srcDevices, srcDeviceIdToDstDeviceIdMapping, isSoundEnabled, isConsoleEnabled, isVirtioScsiEnabled, isBalloonEnabled, graphicsToSkip, copySnapshotDevices);
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    VmBase srcVmBase = getVmBase(srcId);
    VmBase dstVmBase = getVmBase(dstId);
    List<VmDevice> srcDevices = dao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, dstVmBase, srcDevices, srcDeviceIdToDstDeviceIdMapping, isSoundEnabled, isConsoleEnabled, isVirtioScsiEnabled, isBalloonEnabled, graphicsToSkip, copySnapshotDevices, canCopyHostDevices(srcVmBase, dstVmBase));
}
#end_block

#method_before
private static void addImportedOtherDevices(VmBase vmBase, List<VmDevice> vmDeviceToAdd) {
    boolean hasCd = false;
    boolean hasSound = false;
    for (VmDevice vmDevice : vmBase.getManagedDeviceMap().values()) {
        switch(vmDevice.getType()) {
            case DISK:
                if (VmDeviceType.CDROM.getName().equals(vmDevice.getDevice())) {
                    hasCd = true;
                } else {
                    // disks are added separately
                    continue;
                }
                break;
            case INTERFACE:
                // network interfaces are added separately
                continue;
            case VIDEO:
                vmDevice.setSpecParams(getVideoDeviceSpecParams(vmBase));
                break;
            case SOUND:
                hasSound = true;
                break;
        }
        vmDevice.setIsManaged(true);
        vmDeviceToAdd.add(vmDevice);
    }
    if (!hasCd) {
        // add an empty CD
        addCdDevice(vmBase.getId());
    }
    // add sound card for desktops imported from old versions only, since devices didn't exist
    Version ovfVer = new Version(vmBase.getOvfVersion());
    if (!hasSound && VmDeviceCommonUtils.isOldClusterVersion(ovfVer) && vmBase.getVmType() == VmType.Desktop) {
        addSoundDevice(vmBase);
    }
    // add unmanaged devices
    for (VmDevice vmDevice : vmBase.getUnmanagedDeviceList()) {
        vmDeviceToAdd.add(vmDevice);
    }
}
#method_after
private static void addImportedOtherDevices(VmBase vmBase, List<VmDevice> vmDeviceToAdd) {
    boolean hasCd = false;
    boolean hasSound = false;
    for (VmDevice vmDevice : vmBase.getManagedDeviceMap().values()) {
        switch(vmDevice.getType()) {
            case DISK:
                if (VmDeviceType.CDROM.getName().equals(vmDevice.getDevice())) {
                    hasCd = true;
                } else {
                    // disks are added separately
                    continue;
                }
                break;
            case INTERFACE:
                // network interfaces are added separately
                continue;
            case VIDEO:
                vmDevice.setSpecParams(getVideoDeviceSpecParams(vmBase));
                break;
            case SOUND:
                hasSound = true;
                break;
            case HOSTDEV:
                // it is currently unsafe to import host devices, due to possibility of invalid dedicatedVmForVds
                continue;
        }
        vmDevice.setIsManaged(true);
        vmDeviceToAdd.add(vmDevice);
    }
    if (!hasCd) {
        // add an empty CD
        addCdDevice(vmBase.getId());
    }
    // add sound card for desktops imported from old versions only, since devices didn't exist
    Version ovfVer = new Version(vmBase.getOvfVersion());
    if (!hasSound && VmDeviceCommonUtils.isOldClusterVersion(ovfVer) && vmBase.getVmType() == VmType.Desktop) {
        addSoundDevice(vmBase);
    }
    // add unmanaged devices
    for (VmDevice vmDevice : vmBase.getUnmanagedDeviceList()) {
        vmDeviceToAdd.add(vmDevice);
    }
}
#end_block

#method_before
protected void updateStoragePoolMasterDomainVersionInDiffTransaction() {
    executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            int master_domain_version = getStoragePoolDao().increaseStoragePoolMasterVersion(getStoragePool().getId());
            getStoragePool().setMasterDomainVersion(master_domain_version);
            return null;
        }
    });
}
#method_after
protected void updateStoragePoolMasterDomainVersionInDiffTransaction() {
    executeInScope(TransactionScopeOption.Suppress, () -> {
        int master_domain_version = getStoragePoolDao().increaseStoragePoolMasterVersion(getStoragePool().getId());
        getStoragePool().setMasterDomainVersion(master_domain_version);
        return null;
    });
}
#end_block

#method_before
protected VDS checkForActiveVds() {
    List<VDS> hosts = getVdsDao().getAllForStoragePoolAndStatus(getStoragePool().getId(), VDSStatus.Up);
    if (!hosts.isEmpty()) {
        return hosts.get(new Random().nextInt(hosts.size()));
    }
    addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    return null;
}
#method_after
protected VDS checkForActiveVds() {
    List<VDS> hosts = getVdsDao().getAllForStoragePoolAndStatus(getStoragePool().getId(), VDSStatus.Up);
    if (!hosts.isEmpty()) {
        return hosts.get(new Random().nextInt(hosts.size()));
    }
    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    return null;
}
#end_block

#method_before
protected boolean checkStoragePool() {
    if (getStoragePool() == null) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
        return false;
    }
    return true;
}
#method_after
protected boolean checkStoragePool() {
    if (getStoragePool() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean canDetachStorageDomainWithVmsAndDisks(StorageDomain storageDomain) {
    if (!storageDomain.getStorageDomainType().isDataDomain()) {
        return true;
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    List<VM> vmRelatedToDomain = getVmDao().getAllForStorageDomain(storageDomain.getId());
    List<String> vmsInPreview = vmRelatedToDomain.stream().filter(vm -> !snapshotsValidator.vmNotInPreview(vm.getId()).isValid()).map(VM::getName).collect(Collectors.toList());
    List<VM> vmsWithDisksOnMultipleStorageDomain = getVmDao().getAllVMsWithDisksOnOtherStorageDomain(storageDomain.getId());
    vmRelatedToDomain.removeAll(vmsWithDisksOnMultipleStorageDomain);
    List<String> entitiesDeleteProtected = new ArrayList<>();
    List<String> vmsInPool = new ArrayList<>();
    for (VM vm : vmRelatedToDomain) {
        if (vm.isDeleteProtected()) {
            entitiesDeleteProtected.add(vm.getName());
        }
        if (vm.getVmPoolId() != null) {
            vmsInPool.add(vm.getName());
        }
    }
    List<VmTemplate> templatesRelatedToDomain = getVmTemplateDao().getAllForStorageDomain(storageDomain.getId());
    List<VmTemplate> vmTemplatesWithDisksOnMultipleStorageDomain = getVmTemplateDao().getAllTemplatesWithDisksOnOtherStorageDomain(storageDomain.getId());
    templatesRelatedToDomain.removeAll(vmTemplatesWithDisksOnMultipleStorageDomain);
    entitiesDeleteProtected.addAll(templatesRelatedToDomain.stream().filter(VmBase::isDeleteProtected).map(VmTemplate::getName).collect(Collectors.toList()));
    boolean succeeded = true;
    if (!entitiesDeleteProtected.isEmpty()) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DELETE_PROTECTED);
        addCanDoActionMessageVariable("vms", StringUtils.join(entitiesDeleteProtected, ","));
        succeeded = false;
    }
    if (!vmsInPool.isEmpty()) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_VMS_IN_POOL);
        addCanDoActionMessageVariable("vms", StringUtils.join(vmsInPool, ","));
        succeeded = false;
    }
    if (!vmsInPreview.isEmpty()) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DELETE_VMS_IN_PREVIEW);
        addCanDoActionMessageVariable("vms", StringUtils.join(vmsInPreview, ","));
        succeeded = false;
    }
    return succeeded;
}
#method_after
protected boolean canDetachStorageDomainWithVmsAndDisks(StorageDomain storageDomain) {
    if (!storageDomain.getStorageDomainType().isDataDomain()) {
        return true;
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    List<VM> vmRelatedToDomain = getVmDao().getAllForStorageDomain(storageDomain.getId());
    List<String> vmsInPreview = vmRelatedToDomain.stream().filter(vm -> !snapshotsValidator.vmNotInPreview(vm.getId()).isValid()).map(VM::getName).collect(Collectors.toList());
    List<VM> vmsWithDisksOnMultipleStorageDomain = getVmDao().getAllVMsWithDisksOnOtherStorageDomain(storageDomain.getId());
    vmRelatedToDomain.removeAll(vmsWithDisksOnMultipleStorageDomain);
    List<String> entitiesDeleteProtected = new ArrayList<>();
    List<String> vmsInPool = new ArrayList<>();
    for (VM vm : vmRelatedToDomain) {
        if (vm.isDeleteProtected()) {
            entitiesDeleteProtected.add(vm.getName());
        }
        if (vm.getVmPoolId() != null) {
            vmsInPool.add(vm.getName());
        }
    }
    List<VmTemplate> templatesRelatedToDomain = getVmTemplateDao().getAllForStorageDomain(storageDomain.getId());
    List<VmTemplate> vmTemplatesWithDisksOnMultipleStorageDomain = getVmTemplateDao().getAllTemplatesWithDisksOnOtherStorageDomain(storageDomain.getId());
    templatesRelatedToDomain.removeAll(vmTemplatesWithDisksOnMultipleStorageDomain);
    entitiesDeleteProtected.addAll(templatesRelatedToDomain.stream().filter(VmBase::isDeleteProtected).map(VmTemplate::getName).collect(Collectors.toList()));
    boolean succeeded = true;
    if (!entitiesDeleteProtected.isEmpty()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DELETE_PROTECTED);
        addValidationMessageVariable("vms", StringUtils.join(entitiesDeleteProtected, ","));
        succeeded = false;
    }
    if (!vmsInPool.isEmpty()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_VMS_IN_POOL);
        addValidationMessageVariable("vms", StringUtils.join(vmsInPool, ","));
        succeeded = false;
    }
    if (!vmsInPreview.isEmpty()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DELETE_VMS_IN_PREVIEW);
        addValidationMessageVariable("vms", StringUtils.join(vmsInPreview, ","));
        succeeded = false;
    }
    return succeeded;
}
#end_block

#method_before
private void removeEntitiesFromStorageDomain(final List<VM> vmsForStorageDomain, final List<VmTemplate> vmTemplatesForStorageDomain, final List<DiskImage> disksForStorageDomain, final Guid storageDomainId) {
    if (!vmsForStorageDomain.isEmpty() || !vmTemplatesForStorageDomain.isEmpty() || !disksForStorageDomain.isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                for (VM vm : vmsForStorageDomain) {
                    removeEntityLeftOver(vm.getId(), vm.getName(), storageDomainId);
                    getUnregisteredOVFDataDao().saveOVFData(new OvfEntityData(vm.getId(), vm.getName(), VmEntityType.VM, vm.getClusterArch(), vm.getCompatibilityVersion(), storageDomainId, null, null));
                }
                for (VmTemplate vmTemplate : vmTemplatesForStorageDomain) {
                    removeEntityLeftOver(vmTemplate.getId(), vmTemplate.getName(), storageDomainId);
                    getUnregisteredOVFDataDao().saveOVFData(new OvfEntityData(vmTemplate.getId(), vmTemplate.getName(), VmEntityType.TEMPLATE, vmTemplate.getClusterArch(), getVdsGroupDao().get(vmTemplate.getVdsGroupId()).getCompatibilityVersion(), storageDomainId, null, null));
                }
                getStorageDomainDao().removeEntitesFromStorageDomain(storageDomainId);
                return null;
            }
        });
    }
}
#method_after
private void removeEntitiesFromStorageDomain(final List<VM> vmsForStorageDomain, final List<VmTemplate> vmTemplatesForStorageDomain, final List<DiskImage> disksForStorageDomain, final Guid storageDomainId) {
    if (!vmsForStorageDomain.isEmpty() || !vmTemplatesForStorageDomain.isEmpty() || !disksForStorageDomain.isEmpty()) {
        TransactionSupport.executeInNewTransaction(() -> {
            for (VM vm : vmsForStorageDomain) {
                removeEntityLeftOver(vm.getId(), vm.getName(), storageDomainId);
                getUnregisteredOVFDataDao().saveOVFData(new OvfEntityData(vm.getId(), vm.getName(), VmEntityType.VM, vm.getClusterArch(), vm.getCompatibilityVersion(), storageDomainId, null, null));
            }
            for (VmTemplate vmTemplate : vmTemplatesForStorageDomain) {
                removeEntityLeftOver(vmTemplate.getId(), vmTemplate.getName(), storageDomainId);
                getUnregisteredOVFDataDao().saveOVFData(new OvfEntityData(vmTemplate.getId(), vmTemplate.getName(), VmEntityType.TEMPLATE, vmTemplate.getClusterArch(), getClusterDao().get(vmTemplate.getClusterId()).getCompatibilityVersion(), storageDomainId, null, null));
            }
            getStorageDomainDao().removeEntitesFromStorageDomain(storageDomainId);
            return null;
        });
    }
}
#end_block

#method_before
protected boolean checkStoragePoolStatus(StoragePoolStatus status) {
    boolean returnValue = false;
    StoragePool storagePool = getStoragePool();
    if (storagePool != null) {
        returnValue = (storagePool.getStatus() == status);
        if (!returnValue && !getReturnValue().getCanDoActionMessages().contains(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_STATUS_ILLEGAL.toString())) {
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_STATUS_ILLEGAL);
        }
    }
    return returnValue;
}
#method_after
protected boolean checkStoragePoolStatus(StoragePoolStatus status) {
    boolean returnValue = false;
    StoragePool storagePool = getStoragePool();
    if (storagePool != null) {
        returnValue = storagePool.getStatus() == status;
        if (!returnValue && !getReturnValue().getValidationMessages().contains(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_STATUS_ILLEGAL.toString())) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_STATUS_ILLEGAL);
        }
    }
    return returnValue;
}
#end_block

#method_before
protected boolean checkStoragePoolStatusNotEqual(StoragePoolStatus status, EngineMessage onFailMessage) {
    boolean returnValue = false;
    StoragePool storagePool = getStoragePool();
    if (storagePool != null) {
        returnValue = (storagePool.getStatus() != status);
        if (!returnValue && !getReturnValue().getCanDoActionMessages().contains(onFailMessage.name())) {
            addCanDoActionMessage(onFailMessage);
        }
    }
    return returnValue;
}
#method_after
protected boolean checkStoragePoolStatusNotEqual(StoragePoolStatus status, EngineMessage onFailMessage) {
    boolean returnValue = false;
    StoragePool storagePool = getStoragePool();
    if (storagePool != null) {
        returnValue = storagePool.getStatus() != status;
        if (!returnValue && !getReturnValue().getValidationMessages().contains(onFailMessage.name())) {
            addValidationMessage(onFailMessage);
        }
    }
    return returnValue;
}
#end_block

#method_before
protected boolean isStorageDomainNotNull(StorageDomain domain) {
    if (domain == null) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
        return false;
    }
    return true;
}
#method_after
protected boolean isStorageDomainNotNull(StorageDomain domain) {
    if (domain == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
        return false;
    }
    return true;
}
#end_block

#method_before
protected void calcStoragePoolStatusByDomainsStatus() {
    StorageDomain masterDomain = getStorageDomainDao().getStorageDomains(getStoragePool().getId(), StorageDomainType.Master).stream().findFirst().orElse(null);
    // if no master then Uninitialized
    // if master not active maintenance
    StoragePoolStatus newStatus = (masterDomain == null) ? StoragePoolStatus.Uninitialized : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Maintenance) ? StoragePoolStatus.Maintenance : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Active) ? StoragePoolStatus.Up : StoragePoolStatus.NonResponsive;
    if (newStatus != getStoragePool().getStatus()) {
        getCompensationContext().snapshotEntity(getStoragePool());
        getStoragePool().setStatus(newStatus);
        StoragePool poolFromDb = getStoragePoolDao().get(getStoragePool().getId());
        if ((getStoragePool().getSpmVdsId() == null && poolFromDb.getSpmVdsId() != null) || (getStoragePool().getSpmVdsId() != null && !getStoragePool().getSpmVdsId().equals(poolFromDb.getSpmVdsId()))) {
            getStoragePool().setSpmVdsId(poolFromDb.getSpmVdsId());
        }
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            getStoragePool().setSpmVdsId(null);
        }
        executeInScope(TransactionScopeOption.Required, new TransactionMethod<StoragePool>() {

            @Override
            public StoragePool runInTransaction() {
                getStoragePoolDao().update(getStoragePool());
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
    }
}
#method_after
protected void calcStoragePoolStatusByDomainsStatus() {
    StorageDomain masterDomain = getStorageDomainDao().getStorageDomains(getStoragePool().getId(), StorageDomainType.Master).stream().findFirst().orElse(null);
    // if no master then Uninitialized
    // if master not active maintenance
    StoragePoolStatus newStatus = (masterDomain == null) ? StoragePoolStatus.Uninitialized : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Maintenance) ? StoragePoolStatus.Maintenance : (masterDomain.getStatus() != null && masterDomain.getStatus() == StorageDomainStatus.Active) ? StoragePoolStatus.Up : StoragePoolStatus.NonResponsive;
    if (newStatus != getStoragePool().getStatus()) {
        getCompensationContext().snapshotEntity(getStoragePool());
        getStoragePool().setStatus(newStatus);
        StoragePool poolFromDb = getStoragePoolDao().get(getStoragePool().getId());
        if ((getStoragePool().getSpmVdsId() == null && poolFromDb.getSpmVdsId() != null) || (getStoragePool().getSpmVdsId() != null && !getStoragePool().getSpmVdsId().equals(poolFromDb.getSpmVdsId()))) {
            getStoragePool().setSpmVdsId(poolFromDb.getSpmVdsId());
        }
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            getStoragePool().setSpmVdsId(null);
        }
        executeInScope(TransactionScopeOption.Required, () -> {
            getStoragePoolDao().update(getStoragePool());
            return null;
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
    }
}
#end_block

#method_before
protected boolean checkStoragePoolNameLengthValid() {
    boolean result = true;
    if (getStoragePool().getName().length() > Config.<Integer>getValue(ConfigValues.StoragePoolNameSizeLimit)) {
        result = false;
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    return result;
}
#method_after
protected boolean checkStoragePoolNameLengthValid() {
    boolean result = true;
    if (getStoragePool().getName().length() > Config.<Integer>getValue(ConfigValues.StoragePoolNameSizeLimit)) {
        result = false;
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    return result;
}
#end_block

#method_before
private RestoreAllCinderSnapshotsParameters buildCinderChildCommandParameters(List<CinderDisk> cinderDisksToRestore, List<CinderDisk> cinderDisksToRemove, List<CinderDisk> cinderVolumesToRemove, Guid removedSnapshotId) {
    RestoreAllCinderSnapshotsParameters restoreParams = new RestoreAllCinderSnapshotsParameters(getVmId(), cinderDisksToRestore, cinderDisksToRemove, cinderVolumesToRemove);
    restoreParams.setRemovedSnapshotId(removedSnapshotId);
    restoreParams.setSnapshot(getSnapshot());
    restoreParams.setParentHasTasks(!getReturnValue().getVdsmTaskIdList().isEmpty());
    restoreParams.setParentCommand(getActionType());
    restoreParams.setParentParameters(getParameters());
    return withRootCommandInfo(restoreParams);
}
#method_after
private RestoreAllCinderSnapshotsParameters buildCinderChildCommandParameters(List<CinderDisk> cinderDisksToRestore, List<CinderDisk> cinderDisksToRemove, List<CinderDisk> cinderVolumesToRemove, Guid removedSnapshotId) {
    RestoreAllCinderSnapshotsParameters restoreParams = new RestoreAllCinderSnapshotsParameters(getVmId(), cinderDisksToRestore, cinderDisksToRemove, cinderVolumesToRemove);
    restoreParams.setRemovedSnapshotId(removedSnapshotId);
    restoreParams.setSnapshot(getSnapshot());
    restoreParams.setParentHasTasks(!getReturnValue().getVdsmTaskIdList().isEmpty());
    restoreParams.setParentCommand(getActionType());
    restoreParams.setParentParameters(getParameters());
    restoreParams.setShouldBeEndedByParent(false);
    return withRootCommandInfo(restoreParams);
}
#end_block

#method_before
protected void removeSnapshotsFromDB() {
    for (Guid snapshotId : snapshotsToRemove) {
        Snapshot snap = getSnapshotDao().get(snapshotId);
        // Cinder volumes might not have correlated snapshot.
        if (snap != null) {
            String memoryVolume = getSnapshotDao().get(snapshotId).getMemoryVolume();
            if (!memoryVolume.isEmpty() && getSnapshotDao().getNumOfSnapshotsByMemory(memoryVolume) == 1) {
                boolean succeed = removeMemoryVolumes(memoryVolume, getActionType(), false);
                if (!succeed) {
                    log.error("Failed to remove memory '{}' of snapshot '{}'", memoryVolume, snapshotId);
                }
            }
            getSnapshotDao().remove(snapshotId);
        }
    }
}
#method_after
protected void removeSnapshotsFromDB() {
    for (Guid snapshotId : snapshotsToRemove) {
        Snapshot snap = getSnapshotDao().get(snapshotId);
        // Cinder volumes might not have correlated snapshot.
        if (snap != null) {
            String memoryVolume = getSnapshotDao().get(snapshotId).getMemoryVolume();
            if (!memoryVolume.isEmpty() && getSnapshotDao().getNumOfSnapshotsByMemory(memoryVolume) == 1) {
                boolean succeed = removeMemoryDisks(memoryVolume);
                if (!succeed) {
                    log.error("Failed to remove memory '{}' of snapshot '{}'", memoryVolume, snapshotId);
                }
            }
            getSnapshotDao().remove(snapshotId);
        }
    }
}
#end_block

#method_before
protected void restoreSnapshotAndRemoveObsoleteSnapshots(Snapshot targetSnapshot) {
    Guid activeSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    List<DiskImage> imagesFromActiveSnapshot = getDiskImageDao().getAllSnapshotsForVmSnapshot(activeSnapshotId);
    Snapshot previewedSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.PREVIEW);
    if (previewedSnapshot != null) {
        SnapshotVmConfigurationHelper snapshotVmConfigurationHelper = new SnapshotVmConfigurationHelper();
        VM vmFromConf = snapshotVmConfigurationHelper.getVmFromConfiguration(previewedSnapshot.getVmConfiguration(), previewedSnapshot.getVmId(), previewedSnapshot.getId());
        imagesFromPreviewSnapshot.addAll(vmFromConf.getImages());
    }
    List<DiskImage> intersection = ImagesHandler.imagesIntersection(imagesFromActiveSnapshot, imagesFromPreviewSnapshot);
    switch(targetSnapshot.getType()) {
        case PREVIEW:
            getSnapshotDao().updateStatus(getSnapshotDao().getId(getVmId(), SnapshotType.REGULAR, SnapshotStatus.IN_PREVIEW), SnapshotStatus.OK);
            getParameters().setImages((List<DiskImage>) CollectionUtils.union(imagesFromPreviewSnapshot, intersection));
            imagesFromPreviewSnapshot.forEach(image -> {
                if (image.getDiskStorageType() != DiskStorageType.CINDER) {
                    imagesToRestore.add(image);
                } else {
                    List<DiskImage> cinderDiskFromPreviewSnapshot = intersection.stream().filter(diskImage -> diskImage.getId().equals(image.getId())).collect(Collectors.toList());
                    if (!cinderDiskFromPreviewSnapshot.isEmpty()) {
                        imagesToRestore.add(cinderDiskFromPreviewSnapshot.get(0));
                    }
                }
            });
            updateSnapshotIdForSkipRestoreImages(ImagesHandler.imagesSubtract(imagesFromActiveSnapshot, imagesToRestore), targetSnapshot.getId());
            restoreConfiguration(targetSnapshot);
            break;
        case STATELESS:
            imagesToRestore = getParameters().getImages();
            restoreConfiguration(targetSnapshot);
            break;
        case REGULAR:
            prepareToDeletePreviewBranch(imagesFromActiveSnapshot);
            // Set the active snapshot's images as target images for restore, because they are what we keep.
            getParameters().setImages(imagesFromActiveSnapshot);
            imagesFromActiveSnapshot.forEach(image -> {
                List<DiskImage> cinderDiskFromPreviewSnapshot = imagesFromPreviewSnapshot.stream().filter(diskImage -> diskImage.getId().equals(image.getId())).collect(Collectors.toList());
                if (!cinderDiskFromPreviewSnapshot.isEmpty()) {
                    if (image.getDiskStorageType() == DiskStorageType.IMAGE) {
                        imagesToRestore.add(image);
                    } else if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        CinderDisk cinderVolume = getInitialCinderVolumeToDelete(image);
                        if (cinderVolume != null) {
                            imagesToRestore.add(cinderVolume);
                        }
                    }
                }
            });
            updateSnapshotIdForSkipRestoreImages(ImagesHandler.imagesSubtract(imagesFromActiveSnapshot, imagesToRestore), activeSnapshotId);
            break;
        default:
            throw new EngineException(EngineError.ENGINE, "No support for restoring to snapshot type: " + targetSnapshot.getType());
    }
}
#method_after
protected void restoreSnapshotAndRemoveObsoleteSnapshots(Snapshot targetSnapshot) {
    Guid activeSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    List<DiskImage> imagesFromActiveSnapshot = getDiskImageDao().getAllSnapshotsForVmSnapshot(activeSnapshotId);
    Snapshot previewedSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.PREVIEW);
    if (previewedSnapshot != null) {
        SnapshotVmConfigurationHelper snapshotVmConfigurationHelper = new SnapshotVmConfigurationHelper();
        VM vmFromConf = snapshotVmConfigurationHelper.getVmFromConfiguration(previewedSnapshot.getVmConfiguration(), previewedSnapshot.getVmId(), previewedSnapshot.getId());
        List<DiskImage> previewedImagesFromDB = getDiskImageDao().getAllSnapshotsForVmSnapshot(previewedSnapshot.getId());
        imagesFromPreviewSnapshot.addAll(ImagesHandler.imagesIntersection(vmFromConf.getImages(), previewedImagesFromDB));
    }
    List<DiskImage> intersection = ImagesHandler.imagesIntersection(imagesFromActiveSnapshot, imagesFromPreviewSnapshot);
    switch(targetSnapshot.getType()) {
        case PREVIEW:
            getSnapshotDao().updateStatus(getSnapshotDao().getId(getVmId(), SnapshotType.REGULAR, SnapshotStatus.IN_PREVIEW), SnapshotStatus.OK);
            getParameters().setImages((List<DiskImage>) CollectionUtils.union(imagesFromPreviewSnapshot, intersection));
            imagesFromPreviewSnapshot.forEach(image -> {
                if (image.getDiskStorageType() != DiskStorageType.CINDER) {
                    imagesToRestore.add(image);
                } else {
                    List<DiskImage> cinderDiskFromPreviewSnapshot = intersection.stream().filter(diskImage -> diskImage.getId().equals(image.getId())).collect(Collectors.toList());
                    if (!cinderDiskFromPreviewSnapshot.isEmpty()) {
                        imagesToRestore.add(cinderDiskFromPreviewSnapshot.get(0));
                    }
                }
            });
            updateSnapshotIdForSkipRestoreImages(ImagesHandler.imagesSubtract(imagesFromActiveSnapshot, imagesToRestore), targetSnapshot.getId());
            restoreConfiguration(targetSnapshot);
            break;
        case STATELESS:
            imagesToRestore = getParameters().getImages();
            restoreConfiguration(targetSnapshot);
            break;
        case REGULAR:
            prepareToDeletePreviewBranch(imagesFromActiveSnapshot);
            // Set the active snapshot's images as target images for restore, because they are what we keep.
            getParameters().setImages(imagesFromActiveSnapshot);
            imagesFromActiveSnapshot.forEach(image -> {
                List<DiskImage> cinderDiskFromPreviewSnapshot = imagesFromPreviewSnapshot.stream().filter(diskImage -> diskImage.getId().equals(image.getId())).collect(Collectors.toList());
                if (!cinderDiskFromPreviewSnapshot.isEmpty()) {
                    if (image.getDiskStorageType() == DiskStorageType.IMAGE) {
                        imagesToRestore.add(image);
                    } else if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        CinderDisk cinderVolume = getInitialCinderVolumeToDelete(image);
                        if (cinderVolume != null) {
                            imagesToRestore.add(cinderVolume);
                        }
                    }
                }
            });
            updateSnapshotIdForSkipRestoreImages(ImagesHandler.imagesSubtract(imagesFromActiveSnapshot, imagesToRestore), activeSnapshotId);
            break;
        default:
            throw new EngineException(EngineError.ENGINE, "No support for restoring to snapshot type: " + targetSnapshot.getType());
    }
}
#end_block

#method_before
private void addRedundantCinderSnapshots(Guid previewedSnapshotId, List<DiskImage> imagesFromActiveSnapshot) {
    List<CinderDisk> cinderImagesForPreviewedSnapshot = ImagesHandler.filterDisksBasedOnCinder(getDiskImageDao().getAllSnapshotsForVmSnapshot(previewedSnapshotId));
    for (DiskImage image : cinderImagesForPreviewedSnapshot) {
        List<DiskImage> cinderDiskFromSnapshot = imagesFromActiveSnapshot.stream().filter(diskImage -> diskImage.getId().equals(image.getId())).collect(Collectors.toList());
        List<Guid> redundantSnapshotIdsToDelete = CINDERStorageHelper.getRedundantVolumesToDeleteAfterCommitSnapshot(image.getId(), cinderDiskFromSnapshot.get(0).getImageId());
        snapshotsToRemove.addAll(redundantSnapshotIdsToDelete);
    }
}
#method_after
private void addRedundantCinderSnapshots(Guid previewedSnapshotId, List<DiskImage> imagesFromActiveSnapshot) {
    List<CinderDisk> cinderImagesForPreviewedSnapshot = ImagesHandler.filterDisksBasedOnCinder(getDiskImageDao().getAllSnapshotsForVmSnapshot(previewedSnapshotId));
    Set<Guid> criticalSnapshotsChain = getCriticalSnapshotsChain(imagesFromActiveSnapshot, cinderImagesForPreviewedSnapshot);
    for (DiskImage image : cinderImagesForPreviewedSnapshot) {
        List<Guid> redundantSnapshotIdsToDelete = CINDERStorageHelper.getRedundantVolumesToDeleteAfterCommitSnapshot(image.getId(), criticalSnapshotsChain);
        snapshotsToRemove.addAll(redundantSnapshotIdsToDelete);
    }
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__REVERT_TO);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__SNAPSHOT);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__REVERT_TO);
    addValidationMessage(EngineMessage.VAR__TYPE__SNAPSHOT);
}
#end_block

#method_before
@Override
protected void init(T parameters) {
    super.init(parameters);
    // Images must be specified in parameters and belong to a single Disk;
    // Otherwise, we'll fail on canDoAction.
    DiskImage representativeImage = getRepresentativeImage();
    if (representativeImage == null) {
        return;
    }
    setImage(representativeImage);
    setStorageDomainId(representativeImage.getStorageIds().get(0));
    getParameters().setUseCinderCommandCallback(!ImagesHandler.filterDisksBasedOnCinder(getImages()).isEmpty());
    if (!Guid.isNullOrEmpty(getParameters().getContainerId())) {
        setVmId(getParameters().getContainerId());
    } else {
        List<VM> listVms = getVmDao().getVmsListForDisk(representativeImage.getId(), false);
        if (!listVms.isEmpty()) {
            VM vm = listVms.get(0);
            setVm(vm);
        }
    }
    // thus initTaskHandlers() can't yet tell if this is a live or cold merge.
    if (isLiveMerge()) {
        clearTaskHandlers();
    }
}
#method_after
@Override
protected void init(T parameters) {
    super.init(parameters);
    // Images must be specified in parameters and belong to a single Disk;
    // Otherwise, we'll fail on validate.
    DiskImage representativeImage = getRepresentativeImage();
    if (representativeImage != null) {
        setImage(representativeImage);
        getParameters().setStorageDomainId(representativeImage.getStorageIds().get(0));
        getParameters().setDiskAlias(representativeImage.getDiskAlias());
        getParameters().setUseCinderCommandCallback(!ImagesHandler.filterDisksBasedOnCinder(getImages()).isEmpty());
        if (Guid.isNullOrEmpty(getParameters().getContainerId())) {
            List<VM> listVms = getVmDao().getVmsListForDisk(representativeImage.getId(), false);
            if (!listVms.isEmpty()) {
                VM vm = listVms.get(0);
                setVm(vm);
                getParameters().setContainerId(vm.getId());
            }
        }
    }
    setVmId(getParameters().getContainerId());
    setStorageDomainId(getParameters().getStorageDomainId());
    // thus initTaskHandlers() can't yet tell if this is a live or cold merge.
    if (isLiveMerge()) {
        clearTaskHandlers();
    }
}
#end_block

#method_before
protected List<DiskImage> getImages() {
    if (images == null) {
        images = new ArrayList<>();
        for (Guid imageId : getParameters().getImageIds()) {
            if (imageId == null) {
                // Disks existence is validated in canDoAction
                continue;
            }
            DiskImage image = getDiskImageDao().getSnapshotById(imageId);
            if (image != null) {
                images.add(image);
            }
        }
    }
    return images;
}
#method_after
protected List<DiskImage> getImages() {
    if (images == null) {
        images = new ArrayList<>();
        for (Guid imageId : getParameters().getImageIds()) {
            if (imageId == null) {
                // Disks existence is validated in validate
                continue;
            }
            DiskImage image = getDiskImageDao().getSnapshotById(imageId);
            if (image != null) {
                images.add(image);
            }
        }
    }
    return images;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__REMOVE);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__DISK__SNAPSHOT);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__REMOVE);
    addValidationMessage(EngineMessage.VAR__TYPE__DISK__SNAPSHOT);
}
#end_block

#method_before
public void startNextLiveMerge(int completedChildren) {
    if (completedChildren == 0) {
        // Lock all disk images in advance
        ImagesHandler.updateAllDiskImageSnapshotsStatus(getImageGroupId(), ImageStatus.LOCKED);
    } else {
        checkImageIdConsistency(completedChildren - 1);
    }
    Guid imageId = getParameters().getImageIds().get(completedChildren);
    log.info("Starting child command {} of {}, image '{}'", completedChildren + 1, getParameters().getImageIds().size(), imageId);
    RemoveSnapshotSingleDiskParameters parameters = buildRemoveSnapshotSingleDiskLiveParameters(imageId);
    if (getParameters().getChildImageIds() == null) {
        getParameters().setChildImageIds(Arrays.asList(new Guid[getParameters().getImageIds().size()]));
    }
    getParameters().getChildImageIds().set(completedChildren, parameters.getDestinationImageId());
    persistCommand(getParameters().getParentCommand(), true);
    CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveSnapshotSingleDiskLive, parameters, cloneContextAndDetachFromParent());
}
#method_after
public void startNextLiveMerge(int completedChildren) {
    if (completedChildren == 0) {
        // Lock all disk images in advance
        ImagesHandler.updateAllDiskImageSnapshotsStatus(getImageGroupId(), ImageStatus.LOCKED);
    } else {
        checkImageIdConsistency(completedChildren - 1);
    }
    Guid imageId = getParameters().getImageIds().get(completedChildren);
    log.info("Starting child command {} of {}, image '{}'", completedChildren + 1, getParameters().getImageIds().size(), imageId);
    RemoveSnapshotSingleDiskParameters parameters = buildRemoveSnapshotSingleDiskLiveParameters(imageId);
    parameters.setShouldBeEndedByParent(false);
    if (getParameters().getChildImageIds() == null) {
        getParameters().setChildImageIds(Arrays.asList(new Guid[getParameters().getImageIds().size()]));
    }
    getParameters().getChildImageIds().set(completedChildren, parameters.getDestinationImageId());
    persistCommand(getParameters().getParentCommand(), true);
    CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveSnapshotSingleDiskLive, parameters, cloneContextAndDetachFromParent());
}
#end_block

#method_before
private RemoveAllVmCinderDisksParameters buildRemoveCinderSnapshotDiskParameters(List<CinderDisk> cinderDisks) {
    RemoveAllVmCinderDisksParameters params = new RemoveAllVmCinderDisksParameters();
    params.setCinderDisks(cinderDisks);
    params.setParentCommand(getActionType());
    params.setParentParameters(getParameters());
    params.setSessionId(getParameters().getSessionId());
    params.setInvokeEndActionOnParent(false);
    return params;
}
#method_after
private RemoveAllVmCinderDisksParameters buildRemoveCinderSnapshotDiskParameters(List<CinderDisk> cinderDisks) {
    RemoveAllVmCinderDisksParameters params = new RemoveAllVmCinderDisksParameters();
    params.setCinderDisks(cinderDisks);
    params.setParentCommand(getActionType());
    params.setParentParameters(getParameters());
    params.setSessionId(getParameters().getSessionId());
    params.setInvokeEndActionOnParent(false);
    params.setShouldBeEndedByParent(false);
    return params;
}
#end_block

#method_before
private void addAuditLogCustomValues() {
    this.addCustomValue("DiskAlias", getDiskImage().getDiskAlias());
    this.addCustomValue("Snapshots", StringUtils.join(getSnapshotsNames(), ", "));
}
#method_after
private void addAuditLogCustomValues() {
    this.addCustomValue("DiskAlias", getParameters().getDiskAlias());
    this.addCustomValue("Snapshots", StringUtils.join(getSnapshotsNames(), ", "));
}
#end_block

#method_before
private List<String> getSnapshotsNames() {
    List<String> snapshotsNames = new LinkedList<>();
    for (DiskImage image : getImages()) {
        Snapshot snapshot = getSnapshotDao().get(image.getSnapshotId());
        if (snapshot != null) {
            snapshotsNames.add(snapshot.getDescription());
        }
    }
    return snapshotsNames;
}
#method_after
private List<String> getSnapshotsNames() {
    // which will prevent audit logging of '<UNKNOWN>' when the command completes.
    if (getParameters().getSnapshotNames() == null) {
        getParameters().setSnapshotNames(new LinkedList<>());
        for (DiskImage image : getImages()) {
            Snapshot snapshot = getSnapshotDao().get(image.getSnapshotId());
            if (snapshot != null) {
                getParameters().getSnapshotNames().add(snapshot.getDescription());
            }
        }
    }
    return getParameters().getSnapshotNames();
}
#end_block

#method_before
protected boolean canRunActionOnNonManagedVm() {
    ValidationResult nonManagedVmValidationResult = VmHandler.canRunActionOnNonManagedVm(getVm(), this.getActionType());
    if (!nonManagedVmValidationResult.isValid()) {
        return failCanDoAction(nonManagedVmValidationResult.getMessage());
    }
    return true;
}
#method_after
protected boolean canRunActionOnNonManagedVm() {
    ValidationResult nonManagedVmValidationResult = VmHandler.canRunActionOnNonManagedVm(getVm(), this.getActionType());
    if (!nonManagedVmValidationResult.isValid()) {
        return failValidation(nonManagedVmValidationResult.getMessage());
    }
    return true;
}
#end_block

#method_before
protected DiskImage getRepresentativeImage() {
    return getImages().get(0);
}
#method_after
protected DiskImage getRepresentativeImage() {
    if (!getImages().isEmpty()) {
        return getImages().get(0);
    }
    return null;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    addAuditLogCustomValues();
    switch(getActionState()) {
        case EXECUTE:
            if (!hasTaskHandlers()) {
                return getParameters().getTaskGroupSuccess() ? AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_SUCCESS : AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_FAILURE;
            }
            if (isFirstTaskHandler() && getSucceeded()) {
                return AuditLogType.USER_REMOVE_DISK_SNAPSHOT;
            }
            if (!getParameters().getTaskGroupSuccess()) {
                return AuditLogType.USER_FAILED_REMOVE_DISK_SNAPSHOT;
            }
            break;
        case END_SUCCESS:
            return AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_SUCCESS;
        case END_FAILURE:
            return AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_FAILURE;
    }
    return AuditLogType.UNASSIGNED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    addAuditLogCustomValues();
    switch(getActionState()) {
        case EXECUTE:
            if (!hasTaskHandlers() && !getParameters().isUseCinderCommandCallback()) {
                return getParameters().getTaskGroupSuccess() ? AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_SUCCESS : AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_FAILURE;
            }
            if (isFirstTaskHandler() && getSucceeded()) {
                return AuditLogType.USER_REMOVE_DISK_SNAPSHOT;
            }
            if (!getParameters().getTaskGroupSuccess()) {
                return AuditLogType.USER_FAILED_REMOVE_DISK_SNAPSHOT;
            }
            break;
        case END_SUCCESS:
            return AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_SUCCESS;
        case END_FAILURE:
            return AuditLogType.USER_REMOVE_DISK_SNAPSHOT_FINISHED_FAILURE;
    }
    return AuditLogType.UNASSIGNED;
}
#end_block

#method_before
protected boolean validateTemplateArchitecture() {
    if (getVmTemplate().getClusterArch() == ArchitectureType.undefined) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_IMPORT_TEMPLATE_WITH_NOT_SUPPORTED_ARCHITECTURE);
        return false;
    }
    return true;
}
#method_after
protected boolean validateTemplateArchitecture() {
    if (getVmTemplate().getClusterArch() == ArchitectureType.undefined) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_IMPORT_TEMPLATE_WITH_NOT_SUPPORTED_ARCHITECTURE);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean success = true;
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initImportClonedTemplateDisks();
            addVmTemplateToDb();
            updateOriginalTemplateNameOnDerivedVms();
            addVmInterfaces();
            getCompensationContext().stateChanged();
            VmHandler.addVmInitToDB(getVmTemplate());
            return null;
        }
    });
    boolean doesVmTemplateContainImages = !getImages().isEmpty();
    if (doesVmTemplateContainImages && !isImagesAlreadyOnTarget()) {
        moveOrCopyAllImageGroups(getVmTemplateId(), getImages());
    }
    VmDeviceUtils.addImportedDevices(getVmTemplate(), getParameters().isImportAsNewEntity());
    if (!doesVmTemplateContainImages || isImagesAlreadyOnTarget()) {
        endMoveOrCopyCommand();
    }
    checkTrustedService();
    setSucceeded(success);
}
#method_after
@Override
protected void executeCommand() {
    boolean success = true;
    TransactionSupport.executeInNewTransaction(() -> {
        initImportClonedTemplateDisks();
        addVmTemplateToDb();
        updateOriginalTemplateNameOnDerivedVms();
        addVmInterfaces();
        getCompensationContext().stateChanged();
        VmHandler.addVmInitToDB(getVmTemplate());
        return null;
    });
    boolean doesVmTemplateContainImages = !getImages().isEmpty();
    if (doesVmTemplateContainImages && !isImagesAlreadyOnTarget()) {
        moveOrCopyAllImageGroups(getVmTemplateId(), getImages());
    }
    VmDeviceUtils.addImportedDevices(getVmTemplate(), getParameters().isImportAsNewEntity());
    if (!doesVmTemplateContainImages || isImagesAlreadyOnTarget()) {
        endMoveOrCopyCommand();
    }
    checkTrustedService();
    setSucceeded(success);
}
#end_block

#method_before
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmTemplateName", getVmTemplateName());
    if (getVmTemplate().isTrustedService() && !getVdsGroup().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVmTemplate().isTrustedService() && getVdsGroup().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#method_after
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmTemplateName", getVmTemplateName());
    if (getVmTemplate().isTrustedService() && !getCluster().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVmTemplate().isTrustedService() && getCluster().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (DiskImage disk : disks) {
                Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
                Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
                MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
                tempVar.setParentCommand(getActionType());
                tempVar.setUseCopyCollapse(true);
                tempVar.setVolumeType(disk.getVolumeType());
                tempVar.setVolumeFormat(disk.getVolumeFormat());
                tempVar.setCopyVolumeType(CopyVolumeType.SharedVol);
                tempVar.setSourceDomainId(getParameters().getSourceDomainId());
                tempVar.setForceOverride(getParameters().getForceOverride());
                tempVar.setImportEntity(true);
                tempVar.setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, containerID));
                tempVar.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
                for (DiskImage diskImage : getParameters().getVmTemplate().getDiskList()) {
                    if (originalDiskId.equals(diskImage.getId())) {
                        tempVar.setQuotaId(diskImage.getQuotaId());
                        tempVar.setDiskProfileId(diskImage.getDiskProfileId());
                        break;
                    }
                }
                MoveOrCopyImageGroupParameters p = tempVar;
                p.setParentParameters(getParameters());
                VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, p);
                if (!vdcRetValue.getSucceeded()) {
                    throw ((vdcRetValue.getFault() != null) ? new EngineException(vdcRetValue.getFault().getError()) : new EngineException(EngineError.ENGINE));
                }
                getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
            }
            return null;
        }
    });
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(() -> {
        for (DiskImage disk : disks) {
            Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
            Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
            MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
            tempVar.setParentCommand(getActionType());
            tempVar.setUseCopyCollapse(true);
            tempVar.setVolumeType(disk.getVolumeType());
            tempVar.setVolumeFormat(disk.getVolumeFormat());
            tempVar.setCopyVolumeType(CopyVolumeType.SharedVol);
            tempVar.setSourceDomainId(getParameters().getSourceDomainId());
            tempVar.setForceOverride(getParameters().getForceOverride());
            tempVar.setImportEntity(true);
            tempVar.setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, containerID));
            tempVar.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
            for (DiskImage diskImage : getParameters().getVmTemplate().getDiskList()) {
                if (originalDiskId.equals(diskImage.getId())) {
                    tempVar.setQuotaId(diskImage.getQuotaId());
                    tempVar.setDiskProfileId(diskImage.getDiskProfileId());
                    break;
                }
            }
            MoveOrCopyImageGroupParameters p = tempVar;
            p.setParentParameters(getParameters());
            VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, p);
            if (!vdcRetValue.getSucceeded()) {
                throw vdcRetValue.getFault() != null ? new EngineException(vdcRetValue.getFault().getError()) : new EngineException(EngineError.ENGINE);
            }
            getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        }
        return null;
    });
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    getVmTemplate().setVdsGroupId(getParameters().getVdsGroupId());
    // if "run on host" field points to a non existent vds (in the current cluster) -> remove field and continue
    if (!VmHandler.validateDedicatedVdsExistOnSameCluster(getVmTemplate(), null)) {
        getVmTemplate().setDedicatedVmForVdsList(Collections.<Guid>emptyList());
    }
    getVmTemplate().setStatus(VmTemplateStatus.Locked);
    getVmTemplate().setQuotaId(getParameters().getQuotaId());
    VmHandler.updateImportedVmUsbPolicy(getVmTemplate());
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    int count = 1;
    for (DiskImage image : getImages()) {
        image.setActive(true);
        ImageStorageDomainMap map = BaseImagesCommand.saveImage(image);
        getCompensationContext().snapshotNewEntity(image.getImage());
        getCompensationContext().snapshotNewEntity(map);
        if (!DbFacade.getInstance().getBaseDiskDao().exists(image.getId())) {
            image.setDiskAlias(ImagesHandler.getSuggestedDiskAlias(image, getVmTemplateName(), count));
            count++;
            DbFacade.getInstance().getBaseDiskDao().save(image);
            getCompensationContext().snapshotNewEntity(image);
        }
        DiskImageDynamic diskDynamic = new DiskImageDynamic();
        diskDynamic.setId(image.getImageId());
        diskDynamic.setActualSize(image.getActualSizeInBytes());
        DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
        getCompensationContext().snapshotNewEntity(diskDynamic);
    }
}
#method_after
protected void addVmTemplateToDb() {
    getVmTemplate().setClusterId(getParameters().getClusterId());
    // if "run on host" field points to a non existent vds (in the current cluster) -> remove field and continue
    if (!VmHandler.validateDedicatedVdsExistOnSameCluster(getVmTemplate(), null)) {
        getVmTemplate().setDedicatedVmForVdsList(Collections.<Guid>emptyList());
    }
    getVmTemplate().setStatus(VmTemplateStatus.Locked);
    getVmTemplate().setQuotaId(getParameters().getQuotaId());
    VmHandler.updateImportedVmUsbPolicy(getVmTemplate());
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    int count = 1;
    for (DiskImage image : getImages()) {
        image.setActive(true);
        ImageStorageDomainMap map = BaseImagesCommand.saveImage(image);
        getCompensationContext().snapshotNewEntity(image.getImage());
        getCompensationContext().snapshotNewEntity(map);
        if (!DbFacade.getInstance().getBaseDiskDao().exists(image.getId())) {
            image.setDiskAlias(ImagesHandler.getSuggestedDiskAlias(image, getVmTemplateName(), count));
            count++;
            DbFacade.getInstance().getBaseDiskDao().save(image);
            getCompensationContext().snapshotNewEntity(image);
        }
        DiskImageDynamic diskDynamic = new DiskImageDynamic();
        diskDynamic.setId(image.getImageId());
        diskDynamic.setActualSize(image.getActualSizeInBytes());
        DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
        getCompensationContext().snapshotNewEntity(diskDynamic);
    }
}
#end_block

#method_before
protected void addVmInterfaces() {
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVmTemplate().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getCompatibilityVersion(), AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_INVALID_INTERFACES);
    for (VmNetworkInterface iface : getVmTemplate().getInterfaces()) {
        if (iface.getId() == null) {
            iface.setId(Guid.newGuid());
        }
        iface.setVmId(getVmTemplateId());
        VmNic nic = new VmNic();
        nic.setId(iface.getId());
        nic.setVmTemplateId(getVmTemplateId());
        nic.setName(iface.getName());
        nic.setLinked(iface.isLinked());
        nic.setSpeed(iface.getSpeed());
        nic.setType(iface.getType());
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        nic.setVnicProfileId(iface.getVnicProfileId());
        getVmNicDao().save(nic);
        getCompensationContext().snapshotNewEntity(nic);
        VmNetworkStatistics iStat = new VmNetworkStatistics();
        nic.setStatistics(iStat);
        iStat.setId(iface.getId());
        iStat.setVmId(getVmTemplateId());
        getDbFacade().getVmNetworkStatisticsDao().save(iStat);
        getCompensationContext().snapshotNewEntity(iStat);
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmTemplateName());
}
#method_after
protected void addVmInterfaces() {
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVmTemplate().getClusterId(), getStoragePoolId(), getCluster().getCompatibilityVersion(), AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_INVALID_INTERFACES);
    for (VmNetworkInterface iface : getVmTemplate().getInterfaces()) {
        if (iface.getId() == null) {
            iface.setId(Guid.newGuid());
        }
        iface.setVmId(getVmTemplateId());
        VmNic nic = new VmNic();
        nic.setId(iface.getId());
        nic.setVmTemplateId(getVmTemplateId());
        nic.setName(iface.getName());
        nic.setLinked(iface.isLinked());
        nic.setSpeed(iface.getSpeed());
        nic.setType(iface.getType());
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        nic.setVnicProfileId(iface.getVnicProfileId());
        getVmNicDao().save(nic);
        getCompensationContext().snapshotNewEntity(nic);
        VmNetworkStatistics iStat = new VmNetworkStatistics();
        nic.setStatistics(iStat);
        iStat.setId(iface.getId());
        iStat.setVmId(getVmTemplateId());
        getDbFacade().getVmNetworkStatisticsDao().save(iStat);
        getCompensationContext().snapshotNewEntity(iStat);
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmTemplateName());
}
#end_block

#method_before
protected boolean setAndValidateCpuProfile() {
    getVmTemplate().setVdsGroupId(getVdsGroupId());
    getVmTemplate().setCpuProfileId(getParameters().getCpuProfileId());
    return validate(CpuProfileHelper.setAndValidateCpuProfile(getVmTemplate(), getVmTemplate().getCompatibilityVersion()));
}
#method_after
protected boolean setAndValidateCpuProfile() {
    getVmTemplate().setClusterId(getClusterId());
    getVmTemplate().setCpuProfileId(getParameters().getCpuProfileId());
    return validate(CpuProfileHelper.setAndValidateCpuProfile(getVmTemplate(), getEffectiveCompatibilityVersion()));
}
#end_block

#method_before
@Override
protected void init() {
    if (getVm() != null) {
        needsHostDevices = hostDeviceManager.checkVmNeedsDirectPassthrough(getVm());
    }
    loadVmInit();
}
#method_after
@Override
protected void init() {
    super.init();
    if (getVm() != null) {
        needsHostDevices = hostDeviceManager.checkVmNeedsDirectPassthrough(getVm());
    }
    loadVmInit();
}
#end_block

#method_before
protected String getIsoPrefixFilePath(String url) {
    // The initial Url.
    String fullPathFileName = url;
    // If file name got prefix of iso:// then set the path to the Iso domain.
    int prefixLength = ISO_PREFIX.length();
    if (url.length() >= prefixLength && (url.substring(0, prefixLength)).equalsIgnoreCase(ISO_PREFIX)) {
        fullPathFileName = cdPathWindowsToLinux(url.substring(prefixLength));
    }
    return fullPathFileName;
}
#method_after
protected String getIsoPrefixFilePath(String url) {
    // The initial Url.
    String fullPathFileName = url;
    // If file name got prefix of iso:// then set the path to the Iso domain.
    int prefixLength = ISO_PREFIX.length();
    if (url.length() >= prefixLength && url.substring(0, prefixLength).equalsIgnoreCase(ISO_PREFIX)) {
        fullPathFileName = cdPathWindowsToLinux(url.substring(prefixLength));
    }
    return fullPathFileName;
}
#end_block

#method_before
private boolean checkRequiredHostDevicesAvailability() {
    if (!needsHostDevices) {
        return true;
    }
    // Only single dedicated host allowed for host devices, verified on canDoActions
    return hostDeviceManager.checkVmHostDeviceAvailability(getVm(), getVm().getDedicatedVmForVdsList().get(0));
}
#method_after
private boolean checkRequiredHostDevicesAvailability() {
    if (!needsHostDevices) {
        return true;
    }
    // Only single dedicated host allowed for host devices, verified on validates
    return hostDeviceManager.checkVmHostDeviceAvailability(getVm(), getVm().getDedicatedVmForVdsList().get(0));
}
#end_block

#method_before
private void acquireHostDevicesLock() {
    if (needsHostDevices) {
        // Only single dedicated host allowed for host devices, verified on canDoActions
        hostDeviceManager.acquireHostDevicesLock(getVm().getDedicatedVmForVdsList().get(0));
    }
}
#method_after
private void acquireHostDevicesLock() {
    if (needsHostDevices) {
        // Only single dedicated host allowed for host devices, verified on validates
        hostDeviceManager.acquireHostDevicesLock(getVm().getDedicatedVmForVdsList().get(0));
    }
}
#end_block

#method_before
private void releaseHostDevicesLock() {
    if (needsHostDevices) {
        // Only single dedicated host allowed for host devices, verified on canDoActions
        hostDeviceManager.releaseHostDevicesLock(getVm().getDedicatedVmForVdsList().get(0));
    }
}
#method_after
private void releaseHostDevicesLock() {
    if (needsHostDevices) {
        // Only single dedicated host allowed for host devices, verified on validates
        hostDeviceManager.releaseHostDevicesLock(getVm().getDedicatedVmForVdsList().get(0));
    }
}
#end_block

#method_before
private boolean areDisksLocked(VdcReturnValueBase vdcReturnValue) {
    return vdcReturnValue.getCanDoActionMessages().contains(EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED.name());
}
#method_after
private boolean areDisksLocked(VdcReturnValueBase vdcReturnValue) {
    return vdcReturnValue.getValidationMessages().contains(EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED.name());
}
#end_block

#method_before
protected CreateVmVDSCommandParameters buildCreateVmParameters() {
    CreateVmVDSCommandParameters parameters = new CreateVmVDSCommandParameters(getVdsId(), getVm());
    return parameters;
}
#method_after
protected CreateVmVDSCommandParameters buildCreateVmParameters() {
    return new CreateVmVDSCommandParameters(getVdsId(), getVm());
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getFlow() == RunVmFlow.REMOVE_STATELESS_IMAGES) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (getFlow() == RunVmFlow.RESUME_PAUSE) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (isInternalExecution()) {
                if (getSucceeded()) {
                    boolean isStateless = isStatelessSnapshotExistsForVm();
                    if (isStateless) {
                        return AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS;
                    } else if (getFlow() == RunVmFlow.CREATE_STATELESS_IMAGES) {
                        return AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING;
                    } else {
                        return AuditLogType.VDS_INITIATED_RUN_VM;
                    }
                }
                return AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? isVmRunningOnNonDefaultVds() ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : (isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM) : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getVm().isRunAndPause() ? AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE : getTaskIdList().isEmpty() ? AuditLogType.USER_STARTED_VM : AuditLogType.USER_INITIATED_RUN_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getFlow() == RunVmFlow.REMOVE_STATELESS_IMAGES) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (getFlow() == RunVmFlow.RESUME_PAUSE) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (isInternalExecution()) {
                if (getSucceeded()) {
                    boolean isStateless = isStatelessSnapshotExistsForVm();
                    if (isStateless) {
                        return AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS;
                    } else if (getFlow() == RunVmFlow.CREATE_STATELESS_IMAGES) {
                        return AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING;
                    } else {
                        return AuditLogType.VDS_INITIATED_RUN_VM;
                    }
                }
                return AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? getActionReturnValue() == VMStatus.Up ? isVmRunningOnNonDefaultVds() ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getVm().isRunAndPause() ? AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE : getTaskIdList().isEmpty() ? AuditLogType.USER_STARTED_VM : AuditLogType.USER_INITIATED_RUN_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
protected boolean isVmRunningOnNonDefaultVds() {
    return getVm().getDedicatedVmForVdsList().isEmpty() == false && getVm().getDedicatedVmForVdsList().contains(getVm().getRunOnVds()) == false;
}
#method_after
protected boolean isVmRunningOnNonDefaultVds() {
    return !getVm().getDedicatedVmForVdsList().isEmpty() && !getVm().getDedicatedVmForVdsList().contains(getVm().getRunOnVds());
}
#end_block

#method_before
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    VmDeviceUtils.updateVmDevicesOnRun(getVm().getStaticData());
    updateGraphicsInfos();
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    if (getParameters().getInitializationType() == null) {
        VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
        if (!getVm().isInitialized() && getVm().getVmInit() != null) {
            getVm().setInitializationType(InitializationType.None);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                if (!isPayloadExists(VmDeviceType.FLOPPY)) {
                    getVm().setInitializationType(InitializationType.Sysprep);
                }
            } else if (getVm().getVmInit() != null) {
                if (!isPayloadExists(VmDeviceType.CDROM)) {
                    getVm().setInitializationType(InitializationType.CloudInit);
                }
            }
        }
    } else if (getParameters().getInitializationType() != InitializationType.None) {
        getVm().setInitializationType(getParameters().getInitializationType());
        // the payload since we can only have one media (Floppy/CDROM) per payload.
        if (getParameters().getInitializationType() == InitializationType.Sysprep && isPayloadExists(VmDeviceType.FLOPPY)) {
            getVm().setVmPayload(null);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && isPayloadExists(VmDeviceType.CDROM)) {
            getVm().setVmPayload(null);
        }
    }
    // have floppy payload since we are limited to only one floppy device
    if (!StringUtils.isEmpty(getParameters().getFloppyPath()) && isPayloadExists(VmDeviceType.FLOPPY)) {
        getVm().setVmPayload(null);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    // update dynamic cluster-parameters
    if (getVm().getCpuName() == null) {
        // no run-once data -> use static field or inherit from cluster
        if (getVm().getCustomCpuName() != null) {
            getVm().setCpuName(getVm().getCustomCpuName());
        } else {
            // get what cpu flags should be passed to vdsm according to the cluster
            getVm().setCpuName(getCpuFlagsManagerHandler().getCpuId(getVm().getVdsGroupCpuName(), getVm().getCompatibilityVersion()));
        }
    }
    if (getVm().getEmulatedMachine() == null) {
        getVm().setEmulatedMachine((getVm().getCustomEmulatedMachine() != null ? getVm().getCustomEmulatedMachine() : getVdsGroup().getEmulatedMachine()));
    }
    getVm().setHibernationVolHandle(getMemoryFromActiveSnapshot());
}
#method_after
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    VmDeviceUtils.updateVmDevicesOnRun(getVm().getStaticData());
    updateGraphicsInfos();
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    if (getParameters().getInitializationType() == null) {
        VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
        if (!getVm().isInitialized() && getVm().getVmInit() != null) {
            getVm().setInitializationType(InitializationType.None);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                if (!isPayloadExists(VmDeviceType.FLOPPY)) {
                    getVm().setInitializationType(InitializationType.Sysprep);
                }
            } else if (getVm().getVmInit() != null) {
                if (!isPayloadExists(VmDeviceType.CDROM)) {
                    getVm().setInitializationType(InitializationType.CloudInit);
                }
            }
        }
    } else if (getParameters().getInitializationType() != InitializationType.None) {
        getVm().setInitializationType(getParameters().getInitializationType());
        // the payload since we can only have one media (Floppy/CDROM) per payload.
        if (getParameters().getInitializationType() == InitializationType.Sysprep && isPayloadExists(VmDeviceType.FLOPPY)) {
            getVm().setVmPayload(null);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && isPayloadExists(VmDeviceType.CDROM)) {
            getVm().setVmPayload(null);
        }
    }
    // have floppy payload since we are limited to only one floppy device
    if (!StringUtils.isEmpty(getParameters().getFloppyPath()) && isPayloadExists(VmDeviceType.FLOPPY)) {
        getVm().setVmPayload(null);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    // update dynamic cluster-parameters
    if (getVm().getCpuName() == null) {
        // no run-once data -> use static field or inherit from cluster
        if (getVm().getCustomCpuName() != null) {
            getVm().setCpuName(getVm().getCustomCpuName());
        } else {
            // get what cpu flags should be passed to vdsm according to the cluster
            getVm().setCpuName(getCpuFlagsManagerHandler().getCpuId(getVm().getClusterCpuName(), getVm().getCompatibilityVersion()));
        }
    }
    if (getVm().getEmulatedMachine() == null) {
        getVm().setEmulatedMachine(getVm().getCustomEmulatedMachine() != null ? getVm().getCustomEmulatedMachine() : getCluster().getEmulatedMachine());
    }
    getVm().setHibernationVolHandle(getMemoryFromActiveSnapshot());
}
#end_block

#method_before
protected boolean isPayloadExists(VmDeviceType deviceType) {
    if (getVm().getVmPayload() != null && getVm().getVmPayload().getDeviceType().equals(deviceType)) {
        return true;
    }
    return false;
}
#method_after
protected boolean isPayloadExists(VmDeviceType deviceType) {
    return getVm().getVmPayload() != null && getVm().getVmPayload().getDeviceType().equals(deviceType);
}
#end_block

#method_before
protected boolean getVdsToRunOn() {
    Guid vdsToRunOn = schedulingManager.schedule(getVdsGroup(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdListToRunOn(), new ArrayList<>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.error("Can't find VDS to run the VM '{}' on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        EngineException outEx = new EngineException(EngineError.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error("VmHandler::{}: {}", getClass().getName(), outEx.getMessage());
        return false;
    }
    return true;
}
#method_after
protected boolean getVdsToRunOn() {
    Guid vdsToRunOn = schedulingManager.schedule(getCluster(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdListToRunOn(), new ArrayList<>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.error("Can't find VDS to run the VM '{}' on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        EngineException outEx = new EngineException(EngineError.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error("VmHandler::{}: {}", getClass().getName(), outEx.getMessage());
        return false;
    }
    return true;
}
#end_block

#method_before
private String guestToolsVersionTreatment() {
    boolean attachCd = false;
    String selectedToolsVersion = "";
    String selectedToolsClusterVersion = "";
    Guid isoDomainId = getActiveIsoDomainId();
    if (osRepository.isWindows(getVm().getVmOsId()) && null != isoDomainId) {
        // get cluster version of the vm tools
        Version vmToolsClusterVersion = null;
        if (getVm().getHasAgent()) {
            Version clusterVer = getVm().getPartialVersion();
            if (new Version("4.4").equals(clusterVer)) {
                vmToolsClusterVersion = new Version("2.1");
            } else {
                vmToolsClusterVersion = clusterVer;
            }
        }
        // Fetch cached Iso files from active Iso domain.
        List<RepoImage> repoFilesMap = getIsoDomainListSyncronizer().getCachedIsoListByDomainId(isoDomainId, ImageFileType.ISO);
        Version bestClusterVer = null;
        int bestToolVer = 0;
        for (RepoImage map : repoFilesMap) {
            String fileName = StringUtils.defaultString(map.getRepoImageId(), "");
            Matcher matchToolPattern = Pattern.compile(IsoDomainListSyncronizer.REGEX_TOOL_PATTERN).matcher(fileName);
            if (matchToolPattern.find()) {
                // Get cluster version and tool version of Iso tool.
                Version clusterVer = new Version(matchToolPattern.group(IsoDomainListSyncronizer.TOOL_CLUSTER_LEVEL));
                int toolVersion = Integer.parseInt(matchToolPattern.group(IsoDomainListSyncronizer.TOOL_VERSION));
                if (clusterVer.compareTo(getVm().getCompatibilityVersion()) <= 0) {
                    if ((bestClusterVer == null) || (clusterVer.compareTo(bestClusterVer) > 0)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    } else if (clusterVer.equals(bestClusterVer) && toolVersion > bestToolVer) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    }
                }
            }
        }
        if (bestClusterVer != null && (vmToolsClusterVersion == null || vmToolsClusterVersion.compareTo(bestClusterVer) < 0 || (vmToolsClusterVersion.equals(bestClusterVer) && getVm().getHasAgent() && getVm().getGuestAgentVersion().getBuild() < bestToolVer))) {
            // Vm has no tools or there are new tools
            selectedToolsVersion = (Integer.toString(bestToolVer));
            selectedToolsClusterVersion = bestClusterVer.toString();
            attachCd = true;
        }
    }
    if (attachCd) {
        String rhevToolsPath = String.format("%1$s%2$s_%3$s.iso", IsoDomainListSyncronizer.getGuestToolsSetupIsoPrefix(), selectedToolsClusterVersion, selectedToolsVersion);
        String isoDir = (String) runVdsCommand(VDSCommandType.IsoDirectory, new IrsBaseVDSCommandParameters(getVm().getStoragePoolId())).getReturnValue();
        rhevToolsPath = isoDir + File.separator + rhevToolsPath;
        return rhevToolsPath;
    }
    return null;
}
#method_after
private String guestToolsVersionTreatment() {
    boolean attachCd = false;
    String selectedToolsVersion = "";
    String selectedToolsClusterVersion = "";
    Guid isoDomainId = getActiveIsoDomainId();
    if (osRepository.isWindows(getVm().getVmOsId()) && null != isoDomainId) {
        // get cluster version of the vm tools
        Version vmToolsClusterVersion = null;
        if (getVm().getHasAgent()) {
            Version clusterVer = getVm().getPartialVersion();
            if (new Version("4.4").equals(clusterVer)) {
                vmToolsClusterVersion = new Version("2.1");
            } else {
                vmToolsClusterVersion = clusterVer;
            }
        }
        // Fetch cached Iso files from active Iso domain.
        List<RepoImage> repoFilesMap = getIsoDomainListSyncronizer().getCachedIsoListByDomainId(isoDomainId, ImageFileType.ISO);
        Version bestClusterVer = null;
        int bestToolVer = 0;
        for (RepoImage map : repoFilesMap) {
            String fileName = StringUtils.defaultString(map.getRepoImageId(), "");
            Matcher matchToolPattern = Pattern.compile(IsoDomainListSyncronizer.REGEX_TOOL_PATTERN).matcher(fileName);
            if (matchToolPattern.find()) {
                // Get cluster version and tool version of Iso tool.
                Version clusterVer = new Version(matchToolPattern.group(IsoDomainListSyncronizer.TOOL_CLUSTER_LEVEL));
                int toolVersion = Integer.parseInt(matchToolPattern.group(IsoDomainListSyncronizer.TOOL_VERSION));
                if (clusterVer.compareTo(getVm().getCompatibilityVersion()) <= 0) {
                    if ((bestClusterVer == null) || (clusterVer.compareTo(bestClusterVer) > 0)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    } else if (clusterVer.equals(bestClusterVer) && toolVersion > bestToolVer) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    }
                }
            }
        }
        if (bestClusterVer != null && (vmToolsClusterVersion == null || vmToolsClusterVersion.compareTo(bestClusterVer) < 0 || (vmToolsClusterVersion.equals(bestClusterVer) && getVm().getHasAgent() && getVm().getGuestAgentVersion().getBuild() < bestToolVer))) {
            // Vm has no tools or there are new tools
            selectedToolsVersion = Integer.toString(bestToolVer);
            selectedToolsClusterVersion = bestClusterVer.toString();
            attachCd = true;
        }
    }
    if (attachCd) {
        String rhevToolsPath = String.format("%1$s%2$s_%3$s.iso", IsoDomainListSyncronizer.getGuestToolsSetupIsoPrefix(), selectedToolsClusterVersion, selectedToolsVersion);
        String isoDir = (String) runVdsCommand(VDSCommandType.IsoDirectory, new IrsBaseVDSCommandParameters(getVm().getStoragePoolId())).getReturnValue();
        rhevToolsPath = isoDir + File.separator + rhevToolsPath;
        return rhevToolsPath;
    }
    return null;
}
#end_block

#method_before
boolean checkRngDeviceClusterCompatibility() {
    List<VmDevice> rngDevs = getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(getVmId(), VmDeviceGeneralType.RNG, VmDeviceType.VIRTIO.getName());
    if (!rngDevs.isEmpty()) {
        VmRngDevice rngDev = new VmRngDevice(rngDevs.get(0));
        if (!getVdsGroup().getRequiredRngSources().contains(rngDev.getSource())) {
            return false;
        }
    }
    return true;
}
#method_after
boolean checkRngDeviceClusterCompatibility() {
    List<VmDevice> rngDevs = getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(getVmId(), VmDeviceGeneralType.RNG, VmDeviceType.VIRTIO.getName());
    if (!rngDevs.isEmpty()) {
        VmRngDevice rngDev = new VmRngDevice(rngDevs.get(0));
        if (!getCluster().getRequiredRngSources().contains(rngDev.getSource())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__RUN);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__VM);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__RUN);
    addValidationMessage(EngineMessage.VAR__TYPE__VM);
}
#end_block

#method_before
private void removeMemoryFromActiveSnapshot() {
    String memory = getActiveSnapshot().getMemoryVolume();
    if (StringUtils.isEmpty(memory)) {
        return;
    }
    getSnapshotDao().removeMemoryFromActiveSnapshot(getVmId());
    if (getFlow() == RunVmFlow.RESUME_HIBERNATE) {
        removeHibernationDisks(memory);
    } else // If the memory volumes are not used by any other snapshot, we can remove them
    if (getSnapshotDao().getNumOfSnapshotsByMemory(memory) == 0) {
        removeMemoryVolumes(memory, getActionType(), true);
    }
}
#method_after
private void removeMemoryFromActiveSnapshot() {
    String memory = getActiveSnapshot().getMemoryVolume();
    if (StringUtils.isEmpty(memory)) {
        return;
    }
    getSnapshotDao().removeMemoryFromActiveSnapshot(getVmId());
    // If the memory volumes are not used by any other snapshot, we can remove them
    if (getSnapshotDao().getNumOfSnapshotsByMemory(memory) == 0) {
        removeMemoryDisks(memory);
    }
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getVm().getVdsGroupId(), getVm().getCpuPerSocket() * getVm().getNumOfSockets(), getVm().getMemSizeMb()));
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    list.add(new QuotaClusterConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getVm().getClusterId(), getVm().getCpuPerSocket() * getVm().getNumOfSockets(), getVm().getMemSizeMb()));
    return list;
}
#end_block

#method_before
protected boolean initVdss() {
    setVdsIdRef(getVm().getRunOnVds());
    Guid vdsToRunOn = schedulingManager.schedule(getVdsGroup(), getVm(), getVdsBlackList(), getVdsWhiteList(), getDestinationHostList(), new ArrayList<>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setDestinationVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    if (vdsToRunOn != null && vdsToRunOn.equals(Guid.Empty)) {
        return false;
    }
    if (getDestinationVds() == null || getVds() == null) {
        return false;
    }
    return true;
}
#method_after
protected boolean initVdss() {
    setVdsIdRef(getVm().getRunOnVds());
    Guid vdsToRunOn = schedulingManager.schedule(getCluster(), getVm(), getVdsBlackList(), getVdsWhiteList(), getDestinationHostList(), new ArrayList<>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setDestinationVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    if (vdsToRunOn != null && vdsToRunOn.equals(Guid.Empty)) {
        return false;
    }
    if (getDestinationVds() == null || getVds() == null) {
        return false;
    }
    return true;
}
#end_block

#method_before
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, getDestinationVdsId(), dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getMigrationNetworkIp(), getVds().getVdsGroupCompatibilityVersion(), getMaximumMigrationDowntime(), getAutoConverge(), getMigrateCompressed(), getDestinationVds().getConsoleAddress());
}
#method_after
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, getDestinationVdsId(), dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getMigrationNetworkIp(), getVds().getClusterCompatibilityVersion(), getMaximumMigrationDowntime(), getAutoConverge(), getMigrateCompressed(), getDestinationVds().getConsoleAddress());
}
#end_block

#method_before
private void updateVmAfterMigrationToDifferentCluster() {
    if (getVm().getVdsGroupId().equals(getParameters().getTargetVdsGroupId())) {
        return;
    }
    ChangeVMClusterParameters params = new ChangeVMClusterParameters(getParameters().getTargetVdsGroupId(), getVmId());
    setSucceeded(getBackend().runInternalAction(VdcActionType.ChangeVMCluster, params).getSucceeded());
}
#method_after
private void updateVmAfterMigrationToDifferentCluster() {
    if (getVm().getClusterId().equals(getParameters().getTargetClusterId())) {
        return;
    }
    ChangeVMClusterParameters params = new ChangeVMClusterParameters(getParameters().getTargetClusterId(), getVmId(), getVm().getCustomCompatibilityVersion());
    setSucceeded(getBackend().runInternalAction(VdcActionType.ChangeVMCluster, params).getSucceeded());
}
#end_block

#method_before
private Boolean getAutoConverge() {
    if (FeatureSupported.autoConvergence(getVm().getCompatibilityVersion())) {
        if (getVm().getAutoConverge() != null) {
            return getVm().getAutoConverge();
        }
        if (getVdsGroup().getAutoConverge() != null) {
            return getVdsGroup().getAutoConverge();
        }
        return Config.getValue(ConfigValues.DefaultAutoConvergence);
    }
    return null;
}
#method_after
private Boolean getAutoConverge() {
    if (FeatureSupported.autoConvergence(getVm().getCompatibilityVersion())) {
        if (getVm().getAutoConverge() != null) {
            return getVm().getAutoConverge();
        }
        if (getCluster().getAutoConverge() != null) {
            return getCluster().getAutoConverge();
        }
        return Config.getValue(ConfigValues.DefaultAutoConvergence);
    }
    return null;
}
#end_block

#method_before
private Boolean getMigrateCompressed() {
    if (FeatureSupported.migrationCompression(getVm().getCompatibilityVersion())) {
        if (getVm().getMigrateCompressed() != null) {
            return getVm().getMigrateCompressed();
        }
        if (getVdsGroup().getMigrateCompressed() != null) {
            return getVdsGroup().getMigrateCompressed();
        }
        return Config.getValue(ConfigValues.DefaultMigrationCompression);
    }
    return null;
}
#method_after
private Boolean getMigrateCompressed() {
    if (FeatureSupported.migrationCompression(getVm().getCompatibilityVersion())) {
        if (getVm().getMigrateCompressed() != null) {
            return getVm().getMigrateCompressed();
        }
        if (getCluster().getMigrateCompressed() != null) {
            return getCluster().getMigrateCompressed();
        }
        return Config.getValue(ConfigValues.DefaultMigrationCompression);
    }
    return null;
}
#end_block

#method_before
private boolean isTunnelMigrationUsed() {
    if (!FeatureSupported.tunnelMigration(getVm().getCompatibilityVersion())) {
        return false;
    }
    // use cluster's setting
    return getVm().getTunnelMigration() != null ? getVm().getTunnelMigration() : getVdsGroup().isTunnelMigration();
}
#method_after
private boolean isTunnelMigrationUsed() {
    if (!FeatureSupported.tunnelMigration(getVm().getCompatibilityVersion())) {
        return false;
    }
    // use cluster's setting
    return getVm().getTunnelMigration() != null ? getVm().getTunnelMigration() : getCluster().isTunnelMigration();
}
#end_block

#method_before
private String getMigrationNetworkIp() {
    if (!FeatureSupported.migrationNetwork(getVm().getCompatibilityVersion())) {
        return null;
    }
    Network migrationNetwork = null;
    // Find migrationNetworkCluster
    List<Network> allNetworksInCluster = getNetworkDao().getAllForCluster(getVm().getVdsGroupId());
    for (Network tempNetwork : allNetworksInCluster) {
        if (tempNetwork.getCluster().isMigration()) {
            migrationNetwork = tempNetwork;
            break;
        }
    }
    if (migrationNetwork != null) {
        // assure migration network is active on source host
        if (getMigrationNetworkAddress(getVds().getId(), migrationNetwork.getName()) == null) {
            return null;
        }
        // find migration IP address on destination host
        return getMigrationNetworkAddress(getDestinationVds().getId(), migrationNetwork.getName());
    }
    return null;
}
#method_after
private String getMigrationNetworkIp() {
    if (!FeatureSupported.migrationNetwork(getVm().getCompatibilityVersion())) {
        return null;
    }
    Network migrationNetwork = null;
    // Find migrationNetworkCluster
    List<Network> allNetworksInCluster = getNetworkDao().getAllForCluster(getVm().getClusterId());
    for (Network tempNetwork : allNetworksInCluster) {
        if (tempNetwork.getCluster().isMigration()) {
            migrationNetwork = tempNetwork;
            break;
        }
    }
    if (migrationNetwork != null) {
        // assure migration network is active on source host
        if (getMigrationNetworkAddress(getVds().getId(), migrationNetwork.getName()) == null) {
            return null;
        }
        // find migration IP address on destination host
        return getMigrationNetworkAddress(getDestinationVds().getId(), migrationNetwork.getName());
    }
    return null;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__MIGRATE);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__VM);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__MIGRATE);
    addValidationMessage(EngineMessage.VAR__TYPE__VM);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    // this runs before canDoAction so the getVm() can be null - instead of failing on NPE here we pass the parent permissions and let the canDoAction to return proper error
    if (getVm() == null) {
        return permissionList;
    }
    if (getParameters().getTargetVdsGroupId() != null && !getParameters().getTargetVdsGroupId().equals(getVm().getVdsGroupId())) {
        // additional permissions needed since changing the cluster
        permissionList.addAll(VmHandler.getPermissionsNeededToChangeCluster(getParameters().getVmId(), getParameters().getTargetVdsGroupId()));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    // this runs before validate so the getVm() can be null - instead of failing on NPE here we pass the parent permissions and let the validate to return proper error
    if (getVm() == null) {
        return permissionList;
    }
    if (getParameters().getTargetClusterId() != null && !getParameters().getTargetClusterId().equals(getVm().getClusterId())) {
        // additional permissions needed since changing the cluster
        permissionList.addAll(VmHandler.getPermissionsNeededToChangeCluster(getParameters().getVmId(), getParameters().getTargetClusterId()));
    }
    return permissionList;
}
#end_block

#method_before
protected void analyze() {
    proceedDownVms();
    proceedWatchdogEvents();
    proceedBalloonCheck();
    proceedGuaranteedMemoryCheck();
    updateRepository();
    prepareGuestAgentNetworkDevicesForUpdate();
    updateLunDisks();
    updateVmJobs();
    analyzeExternalVms();
    analyzeHostedEngineVm();
    if (vmDynamicToSave != null) {
        vmsMonitoring.addVmDynamicToList(vmDynamicToSave);
    }
    if (saveStatistics) {
        vmsMonitoring.addVmStatisticsToList(dbVm.getStatisticsData());
    }
    if (saveVmInterfaces) {
        vmsMonitoring.addVmInterfaceStatisticsToList(dbVm.getInterfaces());
    }
}
#method_after
protected void analyze() {
    if (vdsmVm == null) {
        removeVmFromCache();
        return;
    }
    if (isUnmanagedVm()) {
        saveDynamic(vdsmVm.getVmDynamic());
        return;
    }
    proceedDownVms();
    proceedWatchdogEvents();
    proceedBalloonCheck();
    proceedGuaranteedMemoryCheck();
    updateRepository();
    prepareGuestAgentNetworkDevicesForUpdate();
    updateLunDisks();
    updateVmJobs();
}
#end_block

#method_before
void proceedDownVms() {
    if (vdsmVm != null && vdsmVm.getVmDynamic().getStatus() == VMStatus.Down) {
        VMStatus prevStatus = VMStatus.Unassigned;
        if (dbVm != null) {
            prevStatus = dbVm.getStatus();
            proceedVmBeforeDeletion();
            // when going to suspend, delete vm from cache later
            if (prevStatus == VMStatus.SavingState) {
                vmsMonitoring.getResourceManager().internalSetVmStatus(dbVm, VMStatus.Suspended);
            }
            clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
        } else {
            VmDynamic dynamicFromDb = getDbFacade().getVmDynamicDao().get(vdsmVm.getVmDynamic().getId());
            if (dynamicFromDb != null) {
                prevStatus = dynamicFromDb.getStatus();
            }
        }
        if (prevStatus != VMStatus.Unassigned) {
            vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.Destroy, new DestroyVmVDSCommandParameters(getVdsManager().getVdsId(), vdsmVm.getVmDynamic().getId(), null, false, false, 0, true));
            if (dbVm != null && prevStatus == VMStatus.SavingState) {
                afterSuspendTreatment(vdsmVm.getVmDynamic());
            } else if (prevStatus != VMStatus.MigratingFrom) {
                handleVmOnDown(dbVm, vdsmVm.getVmDynamic());
            }
        }
    }
}
#method_after
void proceedDownVms() {
    if (vdsmVm.getVmDynamic().getStatus() == VMStatus.Down) {
        VMStatus prevStatus = VMStatus.Unassigned;
        if (dbVm != null) {
            prevStatus = dbVm.getStatus();
            proceedVmBeforeDeletion();
            // when going to suspend, delete vm from cache later
            if (prevStatus == VMStatus.SavingState) {
                vmsMonitoring.getResourceManager().internalSetVmStatus(dbVm, VMStatus.Suspended);
            }
            clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
        } else {
            VmDynamic dynamicFromDb = getDbFacade().getVmDynamicDao().get(vdsmVm.getVmDynamic().getId());
            if (dynamicFromDb != null) {
                prevStatus = dynamicFromDb.getStatus();
            }
        }
        if (prevStatus != VMStatus.Unassigned) {
            vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.Destroy, new DestroyVmVDSCommandParameters(getVdsManager().getVdsId(), vdsmVm.getVmDynamic().getId(), null, false, false, 0, true));
            if (dbVm != null && prevStatus == VMStatus.SavingState) {
                afterSuspendTreatment(vdsmVm.getVmDynamic());
            } else if (prevStatus != VMStatus.MigratingFrom) {
                handleVmOnDown(dbVm, vdsmVm.getVmDynamic());
            }
        }
    }
}
#end_block

#method_before
// TODO Method with Side-Effect - move to VmsMonitoring
private void proceedVmBeforeDeletion() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
    switch(dbVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vdsmVm.getVmDynamic() != null && vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal) {
                    if (dbVm.getMigratingToVds() != null) {
                        VDSReturnValue destoryReturnValue = vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(new Guid(dbVm.getMigratingToVds().toString()), dbVm.getId(), true, false, 0));
                        if (destoryReturnValue.getSucceeded()) {
                            log.info("Stopped migrating VM: '{}' on VDS: '{}'", dbVm.getName(), dbVm.getMigratingToVds());
                        } else {
                            log.info("Could not stop migrating VM: '{}' on VDS: '{}', Error: '{}'", dbVm.getName(), dbVm.getMigratingToVds(), destoryReturnValue.getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().internalSetVmStatus(dbVm, VMStatus.Down, vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
                    saveDynamic(dbVm.getDynamicData());
                    saveStatistics();
                    saveVmInterfaces();
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vdsmVm.getVmDynamic().getExitMessage());
                    vmsMonitoring.getResourceManager().removeAsyncRunningVm(vdsmVm.getVmDynamic().getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#method_after
// TODO Method with Side-Effect - move to VmsMonitoring
private void proceedVmBeforeDeletion() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
    if (dbVm.getStatus() == VMStatus.MigratingFrom) {
        // exit status that's OK, otherwise..
        if (vdsmVm != null && vdsmVm.getVmDynamic() != null && vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal) {
            if (dbVm.getMigratingToVds() != null) {
                VDSReturnValue destoryReturnValue = vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(new Guid(dbVm.getMigratingToVds().toString()), dbVm.getId(), true, false, 0));
                if (destoryReturnValue.getSucceeded()) {
                    log.info("Stopped migrating VM: '{}' on VDS: '{}'", dbVm.getName(), dbVm.getMigratingToVds());
                } else {
                    log.info("Could not stop migrating VM: '{}' on VDS: '{}', Error: '{}'", dbVm.getName(), dbVm.getMigratingToVds(), destoryReturnValue.getExceptionString());
                }
            }
            // set vm status to down if source vm crushed
            ResourceManager.getInstance().internalSetVmStatus(dbVm, VMStatus.Down, vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
            saveDynamic(dbVm.getDynamicData());
            saveStatistics();
            saveVmInterfaces();
            type = AuditLogType.VM_MIGRATION_ABORT;
            logable.addCustomValue("MigrationError", vdsmVm.getVmDynamic().getExitMessage());
            vmsMonitoring.getResourceManager().removeAsyncRunningVm(vdsmVm.getVmDynamic().getId());
        }
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#end_block

#method_before
private void proceedWatchdogEvents() {
    if (vdsmVm != null) {
        VmDynamic vmDynamic = vdsmVm.getVmDynamic();
        VM vmTo = dbVm;
        if (isNewWatchdogEvent(vmDynamic, vmTo)) {
            AuditLogableBase auditLogable = new AuditLogableBase();
            auditLogable.setVmId(vmDynamic.getId());
            auditLogable.addCustomValue("wdaction", vmDynamic.getLastWatchdogAction());
            // for the interpretation of vdsm's response see http://docs.python.org/2/library/time.html
            auditLogable.addCustomValue("wdevent", new Date(vmDynamic.getLastWatchdogEvent() * 1000).toString());
            auditLog(auditLogable, AuditLogType.WATCHDOG_EVENT);
        }
    }
}
#method_after
private void proceedWatchdogEvents() {
    VmDynamic vmDynamic = vdsmVm.getVmDynamic();
    VM vmTo = dbVm;
    if (isNewWatchdogEvent(vmDynamic, vmTo)) {
        AuditLogableBase auditLogable = new AuditLogableBase();
        auditLogable.setVmId(vmDynamic.getId());
        auditLogable.addCustomValue("wdaction", vmDynamic.getLastWatchdogAction());
        // for the interpretation of vdsm's response see http://docs.python.org/2/library/time.html
        auditLogable.addCustomValue("wdevent", new Date(vmDynamic.getLastWatchdogEvent() * 1000).toString());
        auditLog(auditLogable, AuditLogType.WATCHDOG_EVENT);
    }
}
#end_block

#method_before
private void proceedBalloonCheck() {
    if (getVdsManager().getCopyVds().isBalloonEnabled()) {
        if (dbVm == null || vdsmVm == null) {
            return;
        }
        VmBalloonInfo balloonInfo = vdsmVm.getVmStatistics().getVmBalloonInfo();
        if (balloonInfo == null) {
            return;
        }
        Guid vmId = vdsmVm.getVmDynamic().getId();
        /* last memory is null the first time we check it or when
               we're not getting the balloon info from vdsm
            */
        if (balloonInfo.getBalloonLastMemory() == null || balloonInfo.getBalloonLastMemory() == 0) {
            balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
            return;
        }
        if (isBalloonDeviceActiveOnVm(vdsmVm) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !isBalloonWorking(balloonInfo))) {
            vmBalloonDriverIsRequestedAndUnavailable(vmId);
        } else {
            vmBalloonDriverIsNotRequestedOrAvailable(vmId);
        }
        // save the current value for the next time we check it
        balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
        if (vdsmVm.getVmStatistics().getUsageMemPercent() != null && // guest agent is down
        vdsmVm.getVmStatistics().getUsageMemPercent() == 0 && // check if the device is present
        balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
            guestAgentIsDownAndBalloonInfalted(vmId);
        } else {
            guestAgentIsUpOrBalloonDeflated(vmId);
        }
    }
}
#method_after
private void proceedBalloonCheck() {
    if (getVdsManager().getCopyVds().isBalloonEnabled()) {
        if (dbVm == null) {
            return;
        }
        VmBalloonInfo balloonInfo = vdsmVm.getVmStatistics().getVmBalloonInfo();
        if (balloonInfo == null) {
            return;
        }
        Guid vmId = vdsmVm.getVmDynamic().getId();
        /* last memory is null the first time we check it or when
               we're not getting the balloon info from vdsm
            */
        if (balloonInfo.getBalloonLastMemory() == null || balloonInfo.getBalloonLastMemory() == 0) {
            balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
            return;
        }
        if (isBalloonDeviceActiveOnVm(vdsmVm) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !isBalloonWorking(balloonInfo))) {
            vmBalloonDriverIsRequestedAndUnavailable(vmId);
        } else {
            vmBalloonDriverIsNotRequestedOrAvailable(vmId);
        }
        // save the current value for the next time we check it
        balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
        if (vdsmVm.getVmStatistics().getUsageMemPercent() != null && // guest agent is down
        vdsmVm.getVmStatistics().getUsageMemPercent() == 0 && // check if the device is present
        balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
            guestAgentIsDownAndBalloonInfalted(vmId);
        } else {
            guestAgentIsUpOrBalloonDeflated(vmId);
        }
    }
}
#end_block

#method_before
// add the vm to the list of vms with uncontrolled inflated balloon or increment its counter
private void guestAgentIsDownAndBalloonInfalted(Guid vmId) {
    Integer currentVal = vmsWithUncontrolledBalloon.get(vmId);
    if (currentVal == null) {
        vmsWithUncontrolledBalloon.put(vmId, 1);
    } else {
        vmsWithUncontrolledBalloon.put(vmId, currentVal + 1);
        if (currentVal >= Config.<Integer>getValue(ConfigValues.IterationsWithBalloonProblem)) {
            AuditLogableBase auditLogable = new AuditLogableBase();
            auditLogable.setVmId(vmId);
            auditLogDirector.log(auditLogable, AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED);
            vmsWithUncontrolledBalloon.put(vmId, 0);
        }
    }
}
#method_after
// add the vm to the list of vms with uncontrolled inflated balloon or increment its counter
private void guestAgentIsDownAndBalloonInfalted(Guid vmId) {
    Integer currentVal = vmsWithUncontrolledBalloon.get(vmId);
    if (currentVal == null) {
        vmsWithUncontrolledBalloon.put(vmId, 1);
    } else {
        vmsWithUncontrolledBalloon.put(vmId, currentVal + 1);
        if (currentVal >= Config.<Integer>getValue(ConfigValues.IterationsWithBalloonProblem)) {
            AuditLogableBase auditLogable = new AuditLogableBase();
            auditLogable.setVmId(vmId);
            auditLog(auditLogable, AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED);
            vmsWithUncontrolledBalloon.put(vmId, 0);
        }
    }
}
#end_block

#method_before
// add the vm to the list of vms with balloon driver problem or increment its counter
private void vmBalloonDriverIsRequestedAndUnavailable(Guid vmId) {
    Integer currentVal = vmsWithBalloonDriverProblem.get(vmId);
    if (currentVal == null) {
        vmsWithBalloonDriverProblem.put(vmId, 1);
    } else {
        vmsWithBalloonDriverProblem.put(vmId, currentVal + 1);
        if (currentVal >= Config.<Integer>getValue(ConfigValues.IterationsWithBalloonProblem)) {
            AuditLogableBase auditLogable = new AuditLogableBase();
            auditLogable.setVmId(vmId);
            auditLogDirector.log(auditLogable, AuditLogType.VM_BALLOON_DRIVER_ERROR);
            vmsWithBalloonDriverProblem.put(vmId, 0);
        }
    }
}
#method_after
// add the vm to the list of vms with balloon driver problem or increment its counter
private void vmBalloonDriverIsRequestedAndUnavailable(Guid vmId) {
    Integer currentVal = vmsWithBalloonDriverProblem.get(vmId);
    if (currentVal == null) {
        vmsWithBalloonDriverProblem.put(vmId, 1);
    } else {
        vmsWithBalloonDriverProblem.put(vmId, currentVal + 1);
        if (currentVal >= Config.<Integer>getValue(ConfigValues.IterationsWithBalloonProblem)) {
            AuditLogableBase auditLogable = new AuditLogableBase();
            auditLogable.setVmId(vmId);
            auditLog(auditLogable, AuditLogType.VM_BALLOON_DRIVER_ERROR);
            vmsWithBalloonDriverProblem.put(vmId, 0);
        }
    }
}
#end_block

#method_before
private void proceedGuaranteedMemoryCheck() {
    if (dbVm != null && vdsmVm != null) {
        VmStatistics vmStatistics = vdsmVm.getVmStatistics();
        if (vmStatistics != null && vmStatistics.getVmBalloonInfo() != null && vmStatistics.getVmBalloonInfo().getCurrentMemory() != null && vmStatistics.getVmBalloonInfo().getCurrentMemory() > 0 && dbVm.getMinAllocatedMem() > vmStatistics.getVmBalloonInfo().getCurrentMemory() / TO_MEGA_BYTES) {
            AuditLogableBase auditLogable = new AuditLogableBase();
            auditLogable.addCustomValue("VmName", dbVm.getName());
            auditLogable.addCustomValue("VdsName", this.getVdsManager().getVdsName());
            auditLogable.addCustomValue("MemGuaranteed", String.valueOf(dbVm.getMinAllocatedMem()));
            auditLogable.addCustomValue("MemActual", Long.toString((vmStatistics.getVmBalloonInfo().getCurrentMemory() / TO_MEGA_BYTES)));
            auditLog(auditLogable, AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE);
        }
    }
}
#method_after
private void proceedGuaranteedMemoryCheck() {
    if (dbVm != null) {
        VmStatistics vmStatistics = vdsmVm.getVmStatistics();
        if (vmStatistics != null && vmStatistics.getVmBalloonInfo() != null && vmStatistics.getVmBalloonInfo().getCurrentMemory() != null && vmStatistics.getVmBalloonInfo().getCurrentMemory() > 0 && dbVm.getMinAllocatedMem() > vmStatistics.getVmBalloonInfo().getCurrentMemory() / TO_MEGA_BYTES) {
            AuditLogableBase auditLogable = new AuditLogableBase();
            auditLogable.addCustomValue("VmName", dbVm.getName());
            auditLogable.addCustomValue("VdsName", this.getVdsManager().getVdsName());
            auditLogable.addCustomValue("MemGuaranteed", String.valueOf(dbVm.getMinAllocatedMem()));
            auditLogable.addCustomValue("MemActual", Long.toString(vmStatistics.getVmBalloonInfo().getCurrentMemory() / TO_MEGA_BYTES));
            auditLog(auditLogable, AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE);
        }
    }
}
#end_block

#method_before
private void updateRepository() {
    if (vdsmVm != null) {
        VmDynamic vdsmVmDynamic = vdsmVm.getVmDynamic();
        // if not migrating here and not down
        if (!inMigrationTo(vdsmVmDynamic, dbVm) && vdsmVmDynamic.getStatus() != VMStatus.Down) {
            if (dbVm != null) {
                if (!StringUtils.equals(vdsmVmDynamic.getClientIp(), dbVm.getClientIp())) {
                    clientIpChanged = true;
                }
            }
            if (dbVm != null) {
                logVmStatusTransition();
                if (dbVm.getStatus() != VMStatus.Up && vdsmVmDynamic.getStatus() == VMStatus.Up || dbVm.getStatus() != VMStatus.PoweringUp && vdsmVmDynamic.getStatus() == VMStatus.PoweringUp) {
                    poweringUp = true;
                }
                // "Up" as this means that the power down operation failed:
                if (dbVm.getStatus() == VMStatus.PoweringDown && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                // log vm recovered from error
                if (dbVm.getStatus() == VMStatus.Paused && dbVm.getVmPauseStatus().isError() && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_RECOVERED_FROM_PAUSE_ERROR);
                }
                if (isRunSucceeded(vdsmVmDynamic) || isMigrationSucceeded(vdsmVmDynamic)) {
                    // Vm moved to Up status - remove its record from Async
                    // reportedAndUnchangedVms handling
                    log.debug("removing VM '{}' from successful run VMs list", dbVm.getId());
                    succeededToRun = true;
                }
                afterMigrationFrom(vdsmVmDynamic, dbVm);
                if (dbVm.getStatus() != VMStatus.NotResponding && vdsmVmDynamic.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (vdsmVmDynamic.getStatus() == VMStatus.Paused) {
                    removeFromAsync = true;
                    if (dbVm.getStatus() != VMStatus.Paused) {
                        AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                        auditLog(logable, AuditLogType.VM_PAUSED);
                        // check exit message to determine why the VM is paused
                        if (vdsmVmDynamic.getPauseStatus().isError()) {
                            AuditLogType logType = vmPauseStatusToAuditLogType(vdsmVmDynamic.getPauseStatus());
                            logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (dbVm != null || vdsmVmDynamic.getStatus() != VMStatus.MigratingFrom) {
                if (updateVmRunTimeInfo()) {
                    saveDynamic(dbVm.getDynamicData());
                }
            }
            if (dbVm != null) {
                updateVmStatistics();
                stable = true;
                if (!getVdsManager().isInitialized()) {
                    vmsMonitoring.getResourceManager().removeVmFromDownVms(getVdsManager().getVdsId(), vdsmVmDynamic.getId());
                }
            }
        } else {
            if (vdsmVmDynamic.getStatus() == VMStatus.MigratingTo) {
                stable = true;
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(vdsmVmDynamic.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                saveDynamic(null);
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache();
}
#method_after
private void updateRepository() {
    VmDynamic vdsmVmDynamic = vdsmVm.getVmDynamic();
    // if not migrating here and not down
    if (!inMigrationTo(vdsmVmDynamic, dbVm) && vdsmVmDynamic.getStatus() != VMStatus.Down) {
        if (dbVm != null) {
            if (!StringUtils.equals(vdsmVmDynamic.getClientIp(), dbVm.getClientIp())) {
                clientIpChanged = true;
            }
        }
        if (dbVm != null) {
            logVmStatusTransition();
            if (dbVm.getStatus() != VMStatus.Up && vdsmVmDynamic.getStatus() == VMStatus.Up || dbVm.getStatus() != VMStatus.PoweringUp && vdsmVmDynamic.getStatus() == VMStatus.PoweringUp) {
                poweringUp = true;
            }
            // "Up" as this means that the power down operation failed:
            if (dbVm.getStatus() == VMStatus.PoweringDown && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
            }
            // log vm recovered from error
            if (dbVm.getStatus() == VMStatus.Paused && dbVm.getVmPauseStatus().isError() && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                auditLog(logable, AuditLogType.VM_RECOVERED_FROM_PAUSE_ERROR);
            }
            if (isRunSucceeded(vdsmVmDynamic) || isMigrationSucceeded(vdsmVmDynamic)) {
                // Vm moved to Up status - remove its record from Async
                // reportedAndUnchangedVms handling
                log.debug("removing VM '{}' from successful run VMs list", dbVm.getId());
                succeededToRun = true;
            }
            afterMigrationFrom(vdsmVmDynamic, dbVm);
            if (dbVm.getStatus() != VMStatus.NotResponding && vdsmVmDynamic.getStatus() == VMStatus.NotResponding) {
                AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
            } else // check if vm is suspended and remove it from async list
            if (vdsmVmDynamic.getStatus() == VMStatus.Paused) {
                removeFromAsync = true;
                if (dbVm.getStatus() != VMStatus.Paused) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_PAUSED);
                    // check exit message to determine why the VM is paused
                    if (vdsmVmDynamic.getPauseStatus().isError()) {
                        AuditLogType logType = vmPauseStatusToAuditLogType(vdsmVmDynamic.getPauseStatus());
                        logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                        auditLog(logable, logType);
                    }
                }
            }
        }
        if (dbVm != null || vdsmVmDynamic.getStatus() != VMStatus.MigratingFrom) {
            if (updateVmRunTimeInfo()) {
                saveDynamic(dbVm.getDynamicData());
            }
        }
        if (dbVm != null) {
            updateVmStatistics();
            stable = true;
            if (!getVdsManager().isInitialized()) {
                vmsMonitoring.getResourceManager().removeVmFromDownVms(getVdsManager().getVdsId(), vdsmVmDynamic.getId());
            }
        }
    } else {
        if (vdsmVmDynamic.getStatus() == VMStatus.MigratingTo) {
            stable = true;
        }
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(vdsmVmDynamic.getId());
        if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
            saveDynamic(null);
        }
    }
    // compare between vm in cache and vm from vdsm
    if (dbVm != null && !stable) {
        removeVmFromCache();
    }
}
#end_block

#method_before
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.info("RefreshVmList VM id '{}' is migrating to VDS '{}' ignoring it in the refresh until migration is done", runningVm.getId(), getVdsManager().getVdsName());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(getVdsManager().getVdsId()) && runningVm.getStatus() != VMStatus.Up) {
            log.info("RefreshVmList VM id '{}' status = '{}' on VDS '{}' ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), getVdsManager().getVdsName());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    if (runningVm.getStatus() == VMStatus.MigratingTo) {
        // in migration
        log.info("RefreshVmList VM id '{}' is migrating to VDS '{}' ignoring it in the refresh until migration is done", runningVm.getId(), getVdsManager().getVdsName());
        return true;
    }
    if (vmToUpdate == null && runningVm.getStatus() != VMStatus.MigratingFrom) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getRunOnVds() != null && !vmDynamic.getRunOnVds().equals(getVdsManager().getVdsId()) && runningVm.getStatus() != VMStatus.Up) {
            log.info("RefreshVmList VM id '{}' status = '{}' on VDS '{}' ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getStatus(), getVdsManager().getVdsName());
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void logVmStatusTransionFromUnknown() {
    final AuditLogableBase auditLogable = new AuditLogableBase();
    auditLogable.setVmId(dbVm.getId());
    auditLogable.addCustomValue("VmStatus", vdsmVm.getVmDynamic().getStatus().toString());
    auditLogDirector.log(auditLogable, AuditLogType.VM_STATUS_RESTORED);
}
#method_after
private void logVmStatusTransionFromUnknown() {
    final AuditLogableBase auditLogable = new AuditLogableBase();
    auditLogable.setVmId(dbVm.getId());
    auditLogable.addCustomValue("VmStatus", vdsmVm.getVmDynamic().getStatus().toString());
    auditLog(auditLogable, AuditLogType.VM_STATUS_RESTORED);
}
#end_block

#method_before
private void updateVmStatistics() {
    // check if time for vm statistics refresh - update cache and DB
    if (vmsMonitoring.isTimeToUpdateVmStatistics()) {
        dbVm.updateRunTimeStatisticsData(vdsmVm.getVmStatistics(), dbVm);
        saveStatistics();
        saveVmInterfaces();
        updateInterfaceStatistics();
        updateVmNumaNodeRuntimeInfo();
        for (DiskImageDynamic diskImageDynamic : vdsmVm.getVmDynamic().getDisks()) {
            vmsMonitoring.addDiskImageDynamicToSave(new Pair<>(dbVm.getId(), diskImageDynamic));
        }
    }
}
#method_after
private void updateVmStatistics() {
    // check if time for vm statistics refresh - update cache and DB
    if (updateStatistics) {
        dbVm.updateRunTimeStatisticsData(vdsmVm.getVmStatistics(), dbVm);
        saveStatistics();
        saveVmInterfaces();
        updateInterfaceStatistics();
        updateVmNumaNodeRuntimeInfo();
        updateDiskImageDynamics();
    }
}
#end_block

#method_before
private void prepareGuestAgentNetworkDevicesForUpdate() {
    if (vdsmVm != null) {
        VmDynamic vdsmVmDynamic = vdsmVm.getVmDynamic();
        if (vdsmVmDynamic != null) {
            if (dbVm != null) {
                List<VmGuestAgentInterface> vmGuestAgentInterfaces = vdsmVm.getVmGuestAgentInterfaces();
                int guestAgentNicHash = vmGuestAgentInterfaces == null ? 0 : vmGuestAgentInterfaces.hashCode();
                if (guestAgentNicHash != vdsmVmDynamic.getGuestAgentNicsHash()) {
                    if (vmDynamicToSave == null) {
                        saveDynamic(dbVm.getDynamicData());
                    }
                    updateGuestAgentInterfacesChanges(vmDynamicToSave, vmGuestAgentInterfaces, guestAgentNicHash);
                }
            }
        }
    }
}
#method_after
private void prepareGuestAgentNetworkDevicesForUpdate() {
    VmDynamic vdsmVmDynamic = vdsmVm.getVmDynamic();
    if (vdsmVmDynamic != null) {
        if (dbVm != null) {
            List<VmGuestAgentInterface> vmGuestAgentInterfaces = vdsmVm.getVmGuestAgentInterfaces();
            int guestAgentNicHash = vmGuestAgentInterfaces == null ? 0 : vmGuestAgentInterfaces.hashCode();
            if (guestAgentNicHash != vdsmVmDynamic.getGuestAgentNicsHash()) {
                if (vmDynamicToSave == null) {
                    saveDynamic(dbVm.getDynamicData());
                }
                updateGuestAgentInterfacesChanges(vmDynamicToSave, vmGuestAgentInterfaces, guestAgentNicHash);
            }
        }
    }
}
#end_block

#method_before
protected void updateLunDisks() {
    // is updated by VDSM only once when running a VM.
    if (poweringUp && vdsmVm != null) {
        Map<String, LUNs> lunsMap = vdsmVm.getLunsMap();
        if (lunsMap.isEmpty()) {
            // LUNs list from getVmStats hasn't been updated yet or VDSM doesn't support LUNs list retrieval.
            return;
        }
        List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vdsmVm.getVmDynamic().getId(), true);
        for (Disk disk : vmDisks) {
            if (disk.getDiskStorageType() != DiskStorageType.LUN) {
                continue;
            }
            LUNs lunFromDB = ((LunDisk) disk).getLun();
            LUNs lunFromMap = lunsMap.get(lunFromDB.getId());
            // Hence, verify before updating.
            if (lunFromMap.getDeviceSize() != 0 && lunFromMap.getDeviceSize() != lunFromDB.getDeviceSize()) {
                // Found a mismatch - set LUN for update
                log.info("Updated LUN device size - ID: '{}', previous size: '{}', new size: '{}'.", lunFromDB.getLUNId(), lunFromDB.getDeviceSize(), lunFromMap.getDeviceSize());
                lunFromDB.setDeviceSize(lunFromMap.getDeviceSize());
                vmsMonitoring.getVmLunDisksToSave().add(lunFromDB);
            }
        }
    }
}
#method_after
protected void updateLunDisks() {
    // is updated by VDSM only once when running a VM.
    if (poweringUp) {
        Map<String, LUNs> lunsMap = vdsmVm.getLunsMap();
        if (lunsMap.isEmpty()) {
            // LUNs list from getVmStats hasn't been updated yet or VDSM doesn't support LUNs list retrieval.
            return;
        }
        vmLunDisksToSave = new ArrayList<>();
        List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vdsmVm.getVmDynamic().getId(), true);
        for (Disk disk : vmDisks) {
            if (disk.getDiskStorageType() != DiskStorageType.LUN) {
                continue;
            }
            LUNs lunFromDB = ((LunDisk) disk).getLun();
            LUNs lunFromMap = lunsMap.get(lunFromDB.getId());
            // Hence, verify before updating.
            if (lunFromMap.getDeviceSize() != 0 && lunFromMap.getDeviceSize() != lunFromDB.getDeviceSize()) {
                // Found a mismatch - set LUN for update
                log.info("Updated LUN device size - ID: '{}', previous size: '{}', new size: '{}'.", lunFromDB.getLUNId(), lunFromDB.getDeviceSize(), lunFromMap.getDeviceSize());
                lunFromDB.setDeviceSize(lunFromMap.getDeviceSize());
                vmLunDisksToSave.add(lunFromDB);
            }
        }
    }
}
#end_block

#method_before
protected void updateVmJobs() {
    if (vdsmVm != null) {
        Set<Guid> vmJobIdsToIgnore = new HashSet<>();
        Map<Guid, VmJob> jobsFromDb = new HashMap<>();
        for (VmJob job : getDbFacade().getVmJobDao().getAllForVm(vdsmVm.getVmDynamic().getId())) {
            // others are completely ignored for the time being
            if (vmsMonitoring.getExistingVmJobIds().contains(job.getId())) {
                jobsFromDb.put(job.getId(), job);
            }
        }
        if (vdsmVm.getVmStatistics().getVmJobs() == null) {
            // If no vmJobs key was returned, we can't presume anything about the jobs; save them all
            log.debug("No vmJob data returned from VDSM, preserving existing jobs");
            return;
        }
        for (VmJob jobFromVds : vdsmVm.getVmStatistics().getVmJobs()) {
            if (jobsFromDb.containsKey(jobFromVds.getId())) {
                if (jobsFromDb.get(jobFromVds.getId()).equals(jobFromVds)) {
                    // Same data, no update needed.  It would be nice if a caching
                    // layer would take care of this for us.
                    vmJobIdsToIgnore.add(jobFromVds.getId());
                    log.info("VM job '{}': In progress (no change)", jobFromVds.getId());
                } else {
                    vmsMonitoring.getVmJobsToUpdate().put(jobFromVds.getId(), jobFromVds);
                    log.info("VM job '{}': In progress, updating", jobFromVds.getId());
                }
            }
        }
        // Any existing jobs not saved need to be removed
        for (Guid id : jobsFromDb.keySet()) {
            if (!vmsMonitoring.getVmJobsToUpdate().containsKey(id) && !vmJobIdsToIgnore.contains(id)) {
                vmsMonitoring.getVmJobIdsToRemove().add(id);
                log.info("VM job '{}': Deleting", id);
            }
        }
    }
}
#method_after
protected void updateVmJobs() {
    if (vdsmVm.getVmStatistics().getVmJobs() == null) {
        // If no vmJobs key was returned, we can't presume anything about the jobs; save them all
        log.debug("No vmJob data returned from VDSM, preserving existing jobs");
        return;
    }
    vmJobsToUpdate = new HashMap<>();
    vmJobIdsToRemove = new ArrayList<>();
    List<Guid> existingVmJobIds = getDbFacade().getVmJobDao().getAllIds();
    // Only jobs that were in the DB before our update may be updated/removed;
    // others are completely ignored for the time being
    Map<Guid, VmJob> jobsFromDb = getDbFacade().getVmJobDao().getAllForVm(vdsmVm.getVmDynamic().getId()).stream().filter(job -> existingVmJobIds.contains(job.getId())).collect(Collectors.toMap(VmJob::getId, Function.identity()));
    Set<Guid> vmJobIdsToIgnore = new HashSet<>();
    vdsmVm.getVmStatistics().getVmJobs().stream().filter(job -> jobsFromDb.containsKey(job.getId())).forEach(job -> {
        if (jobsFromDb.get(job.getId()).equals(job)) {
            // Same data, no update needed.  It would be nice if a caching
            // layer would take care of this for us.
            vmJobIdsToIgnore.add(job.getId());
            log.info("VM job '{}': In progress (no change)", job.getId());
        } else {
            vmJobsToUpdate.put(job.getId(), job);
            log.info("VM job '{}': In progress, updating", job.getId());
        }
    });
    // Any existing jobs not saved need to be removed
    jobsFromDb.keySet().stream().filter(jobId -> !vmJobsToUpdate.containsKey(jobId) && !vmJobIdsToIgnore.contains(jobId)).forEach(jobId -> {
        vmJobIdsToRemove.add(jobId);
        log.info("VM job '{}': Deleting", jobId);
    });
}
#end_block

#method_before
private void updateVmNumaNodeRuntimeInfo() {
    VmStatistics statistics = vdsmVm.getVmStatistics();
    if (!dbVm.getStatus().isRunning()) {
        dbVm.getStatisticsData().getvNumaNodeStatisticsList().clear();
        return;
    }
    // Build numa nodes map of the host which the dbVm is running on with node index as the key
    Map<Integer, VdsNumaNode> runOnVdsAllNumaNodesMap = new HashMap<>();
    List<VdsNumaNode> runOnVdsAllNumaNodes = getDbFacade().getVdsNumaNodeDao().getAllVdsNumaNodeByVdsId(dbVm.getRunOnVds());
    for (VdsNumaNode vdsNumaNode : runOnVdsAllNumaNodes) {
        runOnVdsAllNumaNodesMap.put(vdsNumaNode.getIndex(), vdsNumaNode);
    }
    // Build numa nodes map of the dbVm with node index as the key
    Map<Integer, VmNumaNode> vmAllNumaNodesMap = new HashMap<>();
    List<VmNumaNode> vmAllNumaNodes = getDbFacade().getVmNumaNodeDao().getAllVmNumaNodeByVmId(dbVm.getId());
    for (VmNumaNode vmNumaNode : vmAllNumaNodes) {
        vmAllNumaNodesMap.put(vmNumaNode.getIndex(), vmNumaNode);
    }
    // Initialize the unpinned dbVm numa nodes list with the runtime pinning information
    List<VmNumaNode> vmNumaNodesNeedUpdate = new ArrayList<>();
    for (VmNumaNode vNode : statistics.getvNumaNodeStatisticsList()) {
        VmNumaNode dbVmNumaNode = vmAllNumaNodesMap.get(vNode.getIndex());
        if (dbVmNumaNode != null) {
            vNode.setId(dbVmNumaNode.getId());
            List<Integer> pinnedNodes = NumaUtils.getPinnedNodeIndexList(dbVmNumaNode.getVdsNumaNodeList());
            List<Pair<Guid, Pair<Boolean, Integer>>> runTimePinList = new ArrayList<>();
            for (Pair<Guid, Pair<Boolean, Integer>> pair : vNode.getVdsNumaNodeList()) {
                if ((!pinnedNodes.contains(pair.getSecond().getSecond())) && (runOnVdsAllNumaNodesMap.containsKey(pair.getSecond().getSecond()))) {
                    pair.setFirst(runOnVdsAllNumaNodesMap.get(pair.getSecond().getSecond()).getId());
                    pair.getSecond().setFirst(false);
                    runTimePinList.add(pair);
                }
            }
            if (!runTimePinList.isEmpty()) {
                vNode.setVdsNumaNodeList(runTimePinList);
                vmNumaNodesNeedUpdate.add(vNode);
            }
        }
    }
    dbVm.getStatisticsData().getvNumaNodeStatisticsList().addAll(vmNumaNodesNeedUpdate);
}
#method_after
private void updateVmNumaNodeRuntimeInfo() {
    VmStatistics statistics = vdsmVm.getVmStatistics();
    if (!dbVm.getStatus().isRunning()) {
        dbVm.getStatisticsData().getvNumaNodeStatisticsList().clear();
        return;
    }
    // Build numa nodes map of the host which the dbVm is running on with node index as the key
    Map<Integer, VdsNumaNode> runOnVdsAllNumaNodesMap = new HashMap<>();
    List<VdsNumaNode> runOnVdsAllNumaNodes = getDbFacade().getVdsNumaNodeDao().getAllVdsNumaNodeByVdsId(dbVm.getRunOnVds());
    for (VdsNumaNode vdsNumaNode : runOnVdsAllNumaNodes) {
        runOnVdsAllNumaNodesMap.put(vdsNumaNode.getIndex(), vdsNumaNode);
    }
    // Build numa nodes map of the dbVm with node index as the key
    Map<Integer, VmNumaNode> vmAllNumaNodesMap = new HashMap<>();
    List<VmNumaNode> vmAllNumaNodes = getDbFacade().getVmNumaNodeDao().getAllVmNumaNodeByVmId(dbVm.getId());
    for (VmNumaNode vmNumaNode : vmAllNumaNodes) {
        vmAllNumaNodesMap.put(vmNumaNode.getIndex(), vmNumaNode);
    }
    // Initialize the unpinned dbVm numa nodes list with the runtime pinning information
    List<VmNumaNode> vmNumaNodesNeedUpdate = new ArrayList<>();
    for (VmNumaNode vNode : statistics.getvNumaNodeStatisticsList()) {
        VmNumaNode dbVmNumaNode = vmAllNumaNodesMap.get(vNode.getIndex());
        if (dbVmNumaNode != null) {
            vNode.setId(dbVmNumaNode.getId());
            List<Integer> pinnedNodes = NumaUtils.getPinnedNodeIndexList(dbVmNumaNode.getVdsNumaNodeList());
            List<Pair<Guid, Pair<Boolean, Integer>>> runTimePinList = new ArrayList<>();
            for (Pair<Guid, Pair<Boolean, Integer>> pair : vNode.getVdsNumaNodeList()) {
                if (!pinnedNodes.contains(pair.getSecond().getSecond()) && runOnVdsAllNumaNodesMap.containsKey(pair.getSecond().getSecond())) {
                    pair.setFirst(runOnVdsAllNumaNodesMap.get(pair.getSecond().getSecond()).getId());
                    pair.getSecond().setFirst(false);
                    runTimePinList.add(pair);
                }
            }
            if (!runTimePinList.isEmpty()) {
                vNode.setVdsNumaNodeList(runTimePinList);
                vmNumaNodesNeedUpdate.add(vNode);
            }
        }
    }
    dbVm.getStatisticsData().getvNumaNodeStatisticsList().addAll(vmNumaNodesNeedUpdate);
}
#end_block

#method_before
/**
 * * Helpers and sub-methods ***
 */
private void updateGuestAgentInterfacesChanges(VmDynamic vmDynamic, List<VmGuestAgentInterface> vmGuestAgentInterfaces, int guestAgentNicHash) {
    vmDynamic.setGuestAgentNicsHash(guestAgentNicHash);
    vmDynamic.setVmIp(extractVmIpsFromGuestAgentInterfaces(vmGuestAgentInterfaces));
    vmsMonitoring.addVmGuestAgentNics(dbVm.getId(), vmGuestAgentInterfaces);
}
#method_after
/**
 * * Helpers and sub-methods ***
 */
private void updateGuestAgentInterfacesChanges(VmDynamic vmDynamic, List<VmGuestAgentInterface> vmGuestAgentInterfaces, int guestAgentNicHash) {
    vmDynamic.setGuestAgentNicsHash(guestAgentNicHash);
    vmDynamic.setVmIp(extractVmIpsFromGuestAgentInterfaces(vmGuestAgentInterfaces));
    vmGuestAgentNics = vmGuestAgentInterfaces;
}
#end_block

#method_before
protected boolean isBalloonWorking(VmBalloonInfo balloonInfo) {
    return (Math.abs(balloonInfo.getBalloonLastMemory() - balloonInfo.getBalloonTargetMemory()) > Math.abs(balloonInfo.getCurrentMemory() - balloonInfo.getBalloonTargetMemory()));
}
#method_after
protected boolean isBalloonWorking(VmBalloonInfo balloonInfo) {
    return Math.abs(balloonInfo.getBalloonLastMemory() - balloonInfo.getBalloonTargetMemory()) > Math.abs(balloonInfo.getCurrentMemory() - balloonInfo.getBalloonTargetMemory());
}
#end_block

#method_before
protected void auditLog(AuditLogableBase auditLogable, AuditLogType logType) {
    auditLogDirector.log(auditLogable, logType);
}
#method_after
protected void auditLog(AuditLogableBase auditLogable, AuditLogType logType) {
    getAuditLogDirector().log(auditLogable, logType);
}
#end_block

#method_before
public VdsManager getVdsManager() {
    return vmsMonitoring.getVdsManager();
}
#method_after
public VdsManager getVdsManager() {
    return vdsManager;
}
#end_block

#method_before
private void removeImages() {
    List<CinderDisk> cinderDisks = new ArrayList<>();
    for (final DiskImage source : getSourceImages()) {
        if (source.getDiskStorageType() == DiskStorageType.CINDER) {
            cinderDisks.add((CinderDisk) source);
            continue;
        }
        // The following is ok because we have tested in the candoaction that the vm
        // is not a template and the vm is not in preview mode and that
        // this is not the active snapshot.
        List<DiskImage> images = getDiskImageDao().getAllSnapshotsForParent(source.getImageId());
        DiskImage dest = null;
        if (!images.isEmpty()) {
            dest = images.get(0);
        }
        if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDisk) {
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest));
            if (vdcReturnValue != null && vdcReturnValue.getInternalVdsmTaskIdList() != null) {
                getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            }
        } else {
            CommandCoordinatorUtil.executeAsyncCommand(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest), cloneContextAndDetachFromParent());
        }
        List<Guid> quotasToRemoveFromCache = new ArrayList<>();
        quotasToRemoveFromCache.add(source.getQuotaId());
        if (dest != null) {
            quotasToRemoveFromCache.add(dest.getQuotaId());
        }
        getQuotaManager().removeQuotaFromCache(getStoragePoolId(), quotasToRemoveFromCache);
    }
    if (!cinderDisks.isEmpty()) {
        handleCinderSnapshotDisks(cinderDisks);
    }
}
#method_after
private void removeImages() {
    List<CinderDisk> cinderDisks = new ArrayList<>();
    for (final DiskImage source : getSourceImages()) {
        if (source.getDiskStorageType() == DiskStorageType.CINDER) {
            cinderDisks.add((CinderDisk) source);
            continue;
        }
        // The following is ok because we have tested in the validate that the vm
        // is not a template and the vm is not in preview mode and that
        // this is not the active snapshot.
        List<DiskImage> images = getDiskImageDao().getAllSnapshotsForParent(source.getImageId());
        DiskImage dest = null;
        if (!images.isEmpty()) {
            dest = images.get(0);
        }
        if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDisk) {
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest));
            if (vdcReturnValue != null && vdcReturnValue.getInternalVdsmTaskIdList() != null) {
                getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            }
        } else {
            CommandCoordinatorUtil.executeAsyncCommand(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest), cloneContextAndDetachFromParent());
        }
        List<Guid> quotasToRemoveFromCache = new ArrayList<>();
        quotasToRemoveFromCache.add(source.getQuotaId());
        if (dest != null) {
            quotasToRemoveFromCache.add(dest.getQuotaId());
        }
        getQuotaManager().removeQuotaFromCache(getStoragePoolId(), quotasToRemoveFromCache);
    }
    if (!cinderDisks.isEmpty()) {
        handleCinderSnapshotDisks(cinderDisks);
    }
}
#end_block

#method_before
private void handleCinderSnapshotDisks(List<CinderDisk> cinderDisks) {
    RemoveAllVmCinderDisksParameters params = buildCinderChildCommandParameters(cinderDisks);
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveAllCinderSnapshotDisks, params, cloneContextAndDetachFromParent(), CINDERStorageHelper.getStorageEntities(cinderDisks));
    try {
        VdcReturnValueBase vdcReturnValueBase = future.get();
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error removing snapshots for Cinder disks");
        }
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error removing snapshots for Cinder disks");
    }
}
#method_after
private void handleCinderSnapshotDisks(List<CinderDisk> cinderDisks) {
    for (CinderDisk cinderDisk : cinderDisks) {
        Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveCinderSnapshotDisk, buildRemoveCinderSnapshotDiskParameters(cinderDisk), cloneContextAndDetachFromParent(), new SubjectEntity(VdcObjectType.Storage, cinderDisk.getStorageIds().get(0)));
        try {
            VdcReturnValueBase vdcReturnValueBase = future.get();
            if (!vdcReturnValueBase.getSucceeded()) {
                log.error("Error removing snapshots for Cinder disk");
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error("Error removing snapshots for Cinder disk");
        }
    }
}
#end_block

#method_before
private void lockSnapshot(final Snapshot snapshot) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntityStatus(snapshot);
            getSnapshotDao().updateStatus(getParameters().getSnapshotId(), SnapshotStatus.LOCKED);
            getCompensationContext().stateChanged();
            return null;
        }
    });
}
#method_after
private void lockSnapshot(final Snapshot snapshot) {
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntityStatus(snapshot);
        getSnapshotDao().updateStatus(getParameters().getSnapshotId(), SnapshotStatus.LOCKED);
        getCompensationContext().stateChanged();
        return null;
    });
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    initializeObjectState();
    if (getParameters().getTaskGroupSuccess()) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
    } else {
        List<String> failedToRemoveDisks = new ArrayList<>();
        Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
        for (VdcActionParametersBase parameters : getParameters().getImagesParameters()) {
            ImagesContainterParametersBase imagesParams = (parameters instanceof ImagesContainterParametersBase ? (ImagesContainterParametersBase) parameters : null);
            if (imagesParams == null) {
                // instances of ImagesContainterParametersBase objects.
                continue;
            }
            if (imagesParams.getTaskGroupSuccess()) {
                snapshot = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snapshot, imagesParams.getImageId());
            } else {
                log.error("Could not delete image '{}' from snapshot '{}'", imagesParams.getImageId(), getParameters().getSnapshotId());
                DiskImage diskImage = getDiskImageDao().getSnapshotById(imagesParams.getImageId());
                failedToRemoveDisks.add(diskImage.getDiskAlias());
            }
        }
        // Remove memory volume and update the dao.
        // Note: on failure, we can treat memory volume deletion as deleting an image
        // and remove it from the snapshot entity (rollback isn't applicable).
        snapshot.setMemoryVolume("");
        getSnapshotDao().update(snapshot);
        if (!failedToRemoveDisks.isEmpty()) {
            addCustomValue("DiskAliases", StringUtils.join(failedToRemoveDisks, ", "));
            auditLogDirector.log(this, AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE_PARTIAL_SNAPSHOT);
        }
        getSnapshotDao().updateStatus(getParameters().getSnapshotId(), SnapshotStatus.OK);
    }
    super.endVmCommand();
}
#method_after
@Override
protected void endVmCommand() {
    initializeObjectState();
    if (getParameters().getTaskGroupSuccess()) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
    } else {
        List<String> failedToRemoveDisks = new ArrayList<>();
        Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
        for (VdcActionParametersBase parameters : getParameters().getImagesParameters()) {
            ImagesContainterParametersBase imagesParams = parameters instanceof ImagesContainterParametersBase ? (ImagesContainterParametersBase) parameters : null;
            if (imagesParams == null) {
                // instances of ImagesContainterParametersBase objects.
                continue;
            }
            if (imagesParams.getTaskGroupSuccess()) {
                snapshot = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snapshot, imagesParams.getImageId());
            } else {
                log.error("Could not delete image '{}' from snapshot '{}'", imagesParams.getImageId(), getParameters().getSnapshotId());
                DiskImage diskImage = getDiskImageDao().getSnapshotById(imagesParams.getImageId());
                failedToRemoveDisks.add(diskImage.getDiskAlias());
            }
        }
        // Remove memory volume and update the dao.
        // Note: on failure, we can treat memory volume deletion as deleting an image
        // and remove it from the snapshot entity (rollback isn't applicable).
        snapshot.setMemoryVolume("");
        getSnapshotDao().update(snapshot);
        if (!failedToRemoveDisks.isEmpty()) {
            addCustomValue("DiskAliases", StringUtils.join(failedToRemoveDisks, ", "));
            auditLogDirector.log(this, AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE_PARTIAL_SNAPSHOT);
        }
        getSnapshotDao().updateStatus(getParameters().getSnapshotId(), SnapshotStatus.OK);
    }
    super.endVmCommand();
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__TYPE__SNAPSHOT);
    addCanDoActionMessage(EngineMessage.VAR__ACTION__REMOVE);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__TYPE__SNAPSHOT);
    addValidationMessage(EngineMessage.VAR__ACTION__REMOVE);
}
#end_block

#method_before
protected List<Disk> filterDisks(List<Disk> diskList) {
    VM vm = DbFacade.getInstance().getVmDao().get(getParameters().getVmId(), getUserID(), getParameters().isFiltered());
    if (vm == null) {
        return new ArrayList<>();
    }
    return doFilter(diskList, vm.getOs(), vm.getCompatibilityVersion());
}
#method_after
@Override
protected List<Disk> filterDisks(List<Disk> diskList) {
    VM vm = DbFacade.getInstance().getVmDao().get(getParameters().getVmId(), getUserID(), getParameters().isFiltered());
    if (vm == null) {
        return new ArrayList<>();
    }
    return doFilter(diskList, vm.getOs(), vm.getCompatibilityVersion());
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmInitEnabled().setEntity(getVm().getVmInit() != null);
    getModel().getVmInitModel().init(getVm().getStaticData());
    getModel().getVmType().setIsChangeable(true);
    getModel().getIsSoundcardEnabled().setIsChangeable(true);
    getModel().getInstanceTypes().setIsChangeable(!vm.isRunning());
    getModel().getVmId().setIsAvailable(true);
    getModel().getVmId().setIsChangeable(false);
    loadDataCenter();
    instanceTypeManager = new ExistingVmInstanceTypeManager(getModel(), vm);
    if (vm.getVmPoolId() != null) {
        instanceTypeManager.setAlwaysEnabledFieldUpdate(true);
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVmNumaNodesByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VmNumaNode> nodes = (List<VmNumaNode>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            ExistingVmModelBehavior.this.getModel().setVmNumaNodes(nodes);
            ExistingVmModelBehavior.this.getModel().updateNodeCount(nodes.size());
        }
    }));
    // load dedicated host names into host names list
    if (getVm().getDedicatedVmForVdsList().size() > 0) {
        Frontend.getInstance().runQuery(VdcQueryType.GetAllHostNamesPinnedToVmById, new IdQueryParameters(vm.getId()), new AsyncQuery(new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                setDedicatedHostsNames((List<String>) ((VdcQueryReturnValue) returnValue).getReturnValue());
            }
        }));
    }
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmInitEnabled().setEntity(getVm().getVmInit() != null);
    getModel().getVmInitModel().init(getVm().getStaticData());
    getModel().getVmType().setIsChangeable(true);
    getModel().getIsSoundcardEnabled().setIsChangeable(true);
    getModel().getInstanceTypes().setIsChangeable(!vm.isRunning());
    getModel().getVmId().setIsAvailable(true);
    getModel().getVmId().setIsChangeable(false);
    loadDataCenter();
    instanceTypeManager = new ExistingVmInstanceTypeManager(getModel(), vm);
    if (vm.getVmPoolId() != null) {
        instanceTypeManager.setAlwaysEnabledFieldUpdate(true);
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVmNumaNodesByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VmNumaNode> nodes = ((VdcQueryReturnValue) returnValue).getReturnValue();
            ExistingVmModelBehavior.this.getModel().setVmNumaNodes(nodes);
            ExistingVmModelBehavior.this.getModel().updateNodeCount(nodes.size());
        }
    }));
    // load dedicated host names into host names list
    if (getVm().getDedicatedVmForVdsList().size() > 0) {
        Frontend.getInstance().runQuery(VdcQueryType.GetAllHostNamesPinnedToVmById, new IdQueryParameters(vm.getId()), new AsyncQuery(new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                setDedicatedHostsNames((List<String>) ((VdcQueryReturnValue) returnValue).getReturnValue());
            }
        }));
    }
}
#end_block

#method_before
private void loadDataCenter() {
    // Preinitialize the VM compatibility version because it's needed during init
    Version newCustomCompatibilityVersion = ((ExistingVmModelBehavior) getModel().getBehavior()).getVm().getStaticData().getCustomCompatibilityVersion();
    if (newCustomCompatibilityVersion != null) {
        getModel().getCustomCompatibilityVersion().setItems(Collections.singletonList(newCustomCompatibilityVersion), newCustomCompatibilityVersion);
    }
    AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            if (returnValue != null) {
                StoragePool dataCenter = (StoragePool) returnValue;
                final List<StoragePool> dataCenters = new ArrayList<>(Arrays.asList(new StoragePool[] { dataCenter }));
                initClusters(dataCenters);
            } else {
                ExistingVmModelBehavior behavior = (ExistingVmModelBehavior) model.getBehavior();
                VM currentVm = behavior.vm;
                VDSGroup tempVar = new VDSGroup();
                tempVar.setId(currentVm.getVdsGroupId());
                tempVar.setName(currentVm.getVdsGroupName());
                tempVar.setCompatibilityVersion(currentVm.getVdsGroupCompatibilityVersion());
                tempVar.setStoragePoolId(currentVm.getStoragePoolId());
                VDSGroup cluster = tempVar;
                DataCenterWithCluster dataCenterWithCluster = new DataCenterWithCluster(null, cluster);
                model.getDataCenterWithClustersList().setItems(Arrays.asList(dataCenterWithCluster));
                model.getDataCenterWithClustersList().setSelectedItem(dataCenterWithCluster);
                behavior.initTemplate();
                behavior.initCdImage();
            }
        }
    }), vm.getStoragePoolId());
}
#method_after
private void loadDataCenter() {
    // Preinitialize the VM compatibility version because it's needed during init
    Version newCustomCompatibilityVersion = ((ExistingVmModelBehavior) getModel().getBehavior()).getVm().getStaticData().getCustomCompatibilityVersion();
    if (newCustomCompatibilityVersion != null) {
        getModel().getCustomCompatibilityVersion().setItems(Collections.singletonList(newCustomCompatibilityVersion), newCustomCompatibilityVersion);
    }
    AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            if (returnValue != null) {
                StoragePool dataCenter = (StoragePool) returnValue;
                final List<StoragePool> dataCenters = new ArrayList<>(Arrays.asList(new StoragePool[] { dataCenter }));
                initClusters(dataCenters);
            } else {
                ExistingVmModelBehavior behavior = (ExistingVmModelBehavior) model.getBehavior();
                VM currentVm = behavior.vm;
                Cluster cluster = new Cluster();
                cluster.setId(currentVm.getClusterId());
                cluster.setName(currentVm.getClusterName());
                cluster.setCompatibilityVersion(currentVm.getClusterCompatibilityVersion());
                cluster.setStoragePoolId(currentVm.getStoragePoolId());
                DataCenterWithCluster dataCenterWithCluster = new DataCenterWithCluster(null, cluster);
                model.getDataCenterWithClustersList().setItems(Arrays.asList(dataCenterWithCluster));
                model.getDataCenterWithClustersList().setSelectedItem(dataCenterWithCluster);
                behavior.initTemplate();
                behavior.initCdImage();
            }
        }
    }), vm.getStoragePoolId());
}
#end_block

#method_before
protected void initClusters(final List<StoragePool> dataCenters) {
    AsyncDataProvider.getInstance().getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
            List<VDSGroup> filteredClusters = AsyncDataProvider.getInstance().filterByArchitecture(clusters, vm.getClusterArch());
            model.setDataCentersAndClusters(model, dataCenters, filteredClusters, vm.getVdsGroupId());
            updateCompatibilityVersion();
            initTemplate();
            initCdImage();
        }
    }), true, false);
}
#method_after
protected void initClusters(final List<StoragePool> dataCenters) {
    AsyncDataProvider.getInstance().getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            List<Cluster> clusters = (List<Cluster>) returnValue;
            List<Cluster> filteredClusters = AsyncDataProvider.getInstance().filterByArchitecture(clusters, vm.getClusterArch());
            model.setDataCentersAndClusters(model, dataCenters, filteredClusters, vm.getClusterId());
            updateCompatibilityVersion();
            initTemplate();
            initCdImage();
        }
    }), true, false);
}
#end_block

#method_before
@Override
public void templateWithVersion_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    buildModel(vm.getStaticData(), new BuilderExecutor.BuilderExecutionFinished<VmBase, UnitVmModel>() {

        @Override
        public void finished(VmBase source, UnitVmModel destination) {
            getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
            updateCpuSharesSelection();
            updateRngDevice(getVm().getId());
            updateTimeZone(vm.getTimeZone());
            updateGraphics();
            getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
            // Storage domain and provisioning are not available for an existing VM.
            getModel().getStorageDomain().setIsChangeable(false);
            getModel().getProvisioning().setIsAvailable(false);
            getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
            getModel().getCpuPinning().setEntity(vm.getCpuPinning());
            getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
            if (isHotSetCpuSupported()) {
                // cancel related events while fetching data
                getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
                getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
                getModel().getThreadsPerCore().getSelectedItemChangedEvent().removeListener(getModel());
                getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
                AsyncDataProvider.getInstance().getHostById(new AsyncQuery(new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        runningOnHost = (VDS) returnValue;
                        hostCpu = calculateHostCpus();
                        updateNumOfSockets();
                    }
                }), vm.getRunOnVds());
            }
            updateCpuProfile(vm.getVdsGroupId(), vm.getCompatibilityVersion(), vm.getCpuProfileId());
        }
    });
}
#method_after
@Override
public void templateWithVersion_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    buildModel(vm.getStaticData(), new BuilderExecutor.BuilderExecutionFinished<VmBase, UnitVmModel>() {

        @Override
        public void finished(VmBase source, UnitVmModel destination) {
            getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
            updateCpuSharesSelection();
            updateRngDevice(getVm().getId());
            updateTimeZone(vm.getTimeZone());
            updateGraphics();
            getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
            // Storage domain and provisioning are not available for an existing VM.
            getModel().getStorageDomain().setIsChangeable(false);
            getModel().getProvisioning().setIsAvailable(false);
            getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
            getModel().getCpuPinning().setEntity(vm.getCpuPinning());
            getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
            if (isHotSetCpuSupported()) {
                // cancel related events while fetching data
                getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
                getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
                getModel().getThreadsPerCore().getSelectedItemChangedEvent().removeListener(getModel());
                getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
                AsyncDataProvider.getInstance().getHostById(new AsyncQuery(new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        runningOnHost = (VDS) returnValue;
                        hostCpu = calculateHostCpus();
                        updateNumOfSockets();
                    }
                }), vm.getRunOnVds());
            }
            updateCpuProfile(vm.getClusterId(), vm.getCompatibilityVersion(), vm.getCpuProfileId());
        }
    });
}
#end_block

#method_before
private void updateInstanceImages() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<InstanceImageLineModel> imageLineModels = new ArrayList<>();
            for (Disk disk : ((ArrayList<Disk>) returnValue)) {
                InstanceImageLineModel lineModel = new InstanceImageLineModel(getModel().getInstanceImages());
                lineModel.initialize(disk, getVm());
                imageLineModels.add(lineModel);
            }
            getModel().getInstanceImages().setItems(imageLineModels);
            getModel().getInstanceImages().setVm(getVm());
        }
    }), getVm().getId());
}
#method_after
private void updateInstanceImages() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<InstanceImageLineModel> imageLineModels = new ArrayList<>();
            for (Disk disk : (ArrayList<Disk>) returnValue) {
                InstanceImageLineModel lineModel = new InstanceImageLineModel(getModel().getInstanceImages());
                lineModel.initialize(disk, getVm());
                imageLineModels.add(lineModel);
            }
            getModel().getInstanceImages().setItems(imageLineModels);
            getModel().getInstanceImages().setVm(getVm());
        }
    }), getVm().getId());
}
#end_block

#method_before
@Override
public void updateMinAllocatedMemory() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    VDSGroup cluster = dataCenterWithCluster.getCluster();
    if (cluster == null) {
        return;
    }
    if (getModel().getMemSize().getEntity() < vm.getVmMemSizeMb()) {
        double overCommitFactor = 100.0 / cluster.getMaxVdsMemoryOverCommit();
        getModel().getMinAllocatedMemory().setEntity((int) (getModel().getMemSize().getEntity() * overCommitFactor));
    } else {
        getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    }
}
#method_after
@Override
public void updateMinAllocatedMemory() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    Cluster cluster = dataCenterWithCluster.getCluster();
    if (cluster == null) {
        return;
    }
    if (getModel().getMemSize().getEntity() < vm.getVmMemSizeMb()) {
        double overCommitFactor = 100.0 / cluster.getMaxVdsMemoryOverCommit();
        getModel().getMinAllocatedMemory().setEntity((int) (getModel().getMemSize().getEntity() * overCommitFactor));
    } else {
        getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    }
}
#end_block

#method_before
public boolean isHotSetCpuSupported() {
    VDSGroup selectedCluster = getModel().getSelectedCluster();
    Version compatibilityVersion = getModel().getCompatibilityVersion();
    Boolean hotplugEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HotPlugEnabled, compatibilityVersion.getValue());
    boolean hotplugCpuSupported = Boolean.parseBoolean(((Map<String, String>) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HotPlugCpuSupported, compatibilityVersion.getValue())).get(selectedCluster.getArchitecture().name()));
    return getVm().getStatus() == VMStatus.Up && hotplugEnabled && hotplugCpuSupported;
}
#method_after
public boolean isHotSetCpuSupported() {
    Cluster selectedCluster = getModel().getSelectedCluster();
    Version compatibilityVersion = getModel().getCompatibilityVersion();
    Boolean hotplugEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HotPlugEnabled, compatibilityVersion.getValue());
    boolean hotplugCpuSupported = Boolean.parseBoolean(((Map<String, String>) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HotPlugCpuSupported, compatibilityVersion.getValue())).get(selectedCluster.getArchitecture().name()));
    return getVm().getStatus() == VMStatus.Up && hotplugEnabled && hotplugCpuSupported;
}
#end_block

#method_before
protected List<VdcReturnValueBase> endActionOnDisks() {
    if (getParameters().isUseCinderCommandCallback()) {
        // No need to explicitly invoke endAction as CoCo should handle it.
        return null;
    }
    List<VdcReturnValueBase> returnValues = new ArrayList<>();
    for (VdcActionParametersBase p : getParametersForChildCommand()) {
        if (overrideChildCommandSuccess()) {
            p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        }
        VdcReturnValueBase returnValue = getBackend().endAction(p.getCommandType() == VdcActionType.Unknown ? getChildActionType() : p.getCommandType(), p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        returnValues.add(returnValue);
    }
    return returnValues;
}
#method_after
protected List<VdcReturnValueBase> endActionOnDisks() {
    List<VdcReturnValueBase> returnValues = new ArrayList<>();
    for (VdcActionParametersBase p : getParametersForChildCommand()) {
        if (overrideChildCommandSuccess()) {
            p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        }
        VdcReturnValueBase returnValue = getBackend().endAction(p.getCommandType() == VdcActionType.Unknown ? getChildActionType() : p.getCommandType(), p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        returnValues.add(returnValue);
    }
    return returnValues;
}
#end_block

#method_before
protected boolean isVmNameValidLength(VM vm) {
    // get VM name
    String vmName = vm.getName();
    // get the max VM name (configuration parameter)
    int maxVmNameLengthWindows = Config.<Integer>getValue(ConfigValues.MaxVmNameLengthWindows);
    int maxVmNameLengthNonWindows = Config.<Integer>getValue(ConfigValues.MaxVmNameLengthNonWindows);
    // names are allowed different lengths in Windows and non-Windows OSs,
    // consider this when setting the max length.
    int maxLength = osRepository.isWindows(vm.getVmOsId()) ? maxVmNameLengthWindows : maxVmNameLengthNonWindows;
    // check if name is longer than allowed name
    boolean nameLengthValid = (vmName.length() <= maxLength);
    // return result
    return nameLengthValid;
}
#method_after
protected boolean isVmNameValidLength(VM vm) {
    // get VM name
    String vmName = vm.getName();
    // get the max VM name (configuration parameter)
    int maxVmNameLengthWindows = Config.<Integer>getValue(ConfigValues.MaxVmNameLengthWindows);
    int maxVmNameLengthNonWindows = Config.<Integer>getValue(ConfigValues.MaxVmNameLengthNonWindows);
    // names are allowed different lengths in Windows and non-Windows OSs,
    // consider this when setting the max length.
    int maxLength = osRepository.isWindows(vm.getVmOsId()) ? maxVmNameLengthWindows : maxVmNameLengthNonWindows;
    // check if name is longer than allowed name
    boolean nameLengthValid = vmName.length() <= maxLength;
    // return result
    return nameLengthValid;
}
#end_block

#method_before
protected boolean isHotPlugSupported() {
    if (FeatureSupported.hotPlug(getVm().getCompatibilityVersion())) {
        return true;
    }
    return failCanDoAction(EngineMessage.HOT_PLUG_IS_NOT_SUPPORTED);
}
#method_after
protected boolean isHotPlugSupported() {
    if (FeatureSupported.hotPlug(getVm().getCompatibilityVersion())) {
        return true;
    }
    return failValidation(EngineMessage.HOT_PLUG_IS_NOT_SUPPORTED);
}
#end_block

#method_before
protected boolean isNicSupportedForPlugUnPlug() {
    if (osRepository.hasNicHotplugSupport(getVm().getOs(), getVm().getCompatibilityVersion())) {
        return true;
    }
    return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
}
#method_after
protected boolean isNicSupportedForPlugUnPlug() {
    if (osRepository.hasNicHotplugSupport(getVm().getOs(), getVm().getCompatibilityVersion())) {
        return true;
    }
    return failValidation(EngineMessage.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
}
#end_block

#method_before
protected boolean isDiskSupportedForPlugUnPlug(Disk disk) {
    if (disk.getDiskInterface() == DiskInterface.IDE) {
        addCanDoActionMessageVariable("diskAlias", disk.getDiskAlias());
        addCanDoActionMessageVariable("vmName", getVm().getName());
        return failCanDoAction(EngineMessage.HOT_PLUG_IDE_DISK_IS_NOT_SUPPORTED);
    }
    Set<String> diskHotpluggableInterfaces = osRepository.getDiskHotpluggableInterfaces(getVm().getOs(), getVm().getCompatibilityVersion());
    if (CollectionUtils.isEmpty(diskHotpluggableInterfaces) || !diskHotpluggableInterfaces.contains(disk.getDiskInterface().name())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
    }
    return true;
}
#method_after
protected boolean isDiskSupportedForPlugUnPlug(Disk disk) {
    if (disk.getDiskInterface() == DiskInterface.IDE) {
        addValidationMessageVariable("diskAlias", disk.getDiskAlias());
        addValidationMessageVariable("vmName", getVm().getName());
        return failValidation(EngineMessage.HOT_PLUG_IDE_DISK_IS_NOT_SUPPORTED);
    }
    Set<String> diskHotpluggableInterfaces = osRepository.getDiskHotpluggableInterfaces(getVm().getOs(), getVm().getCompatibilityVersion());
    if (CollectionUtils.isEmpty(diskHotpluggableInterfaces) || !diskHotpluggableInterfaces.contains(disk.getDiskInterface().name())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
protected boolean checkPayload(VmPayload payload, String isoPath) {
    boolean returnValue = true;
    if (payload.getDeviceType() != VmDeviceType.CDROM && payload.getDeviceType() != VmDeviceType.FLOPPY) {
        addCanDoActionMessage(EngineMessage.VMPAYLOAD_INVALID_PAYLOAD_TYPE);
        returnValue = false;
    } else {
        for (String content : payload.getFiles().values()) {
            // Check each file individually, no constraint on total size
            if (!VmPayload.isPayloadSizeLegal(content)) {
                Integer lengthInKb = 2 * Config.<Integer>getValue(ConfigValues.PayloadSize) / Kb;
                addCanDoActionMessage(EngineMessage.VMPAYLOAD_SIZE_EXCEEDED);
                addCanDoActionMessageVariable("size", lengthInKb.toString());
                returnValue = false;
                break;
            }
        }
    }
    return returnValue;
}
#method_after
protected boolean checkPayload(VmPayload payload, String isoPath) {
    boolean returnValue = true;
    if (payload.getDeviceType() != VmDeviceType.CDROM && payload.getDeviceType() != VmDeviceType.FLOPPY) {
        addValidationMessage(EngineMessage.VMPAYLOAD_INVALID_PAYLOAD_TYPE);
        returnValue = false;
    } else {
        for (String content : payload.getFiles().values()) {
            // Check each file individually, no constraint on total size
            if (!VmPayload.isPayloadSizeLegal(content)) {
                Integer lengthInKb = 2 * Config.<Integer>getValue(ConfigValues.PayloadSize) / Kb;
                addValidationMessage(EngineMessage.VMPAYLOAD_SIZE_EXCEEDED);
                addValidationMessageVariable("size", lengthInKb.toString());
                returnValue = false;
                break;
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
protected boolean canRunActionOnNonManagedVm() {
    ValidationResult nonManagedVmValidationResult = VmHandler.canRunActionOnNonManagedVm(getVm(), this.getActionType());
    if (!nonManagedVmValidationResult.isValid()) {
        return failCanDoAction(nonManagedVmValidationResult.getMessage());
    }
    return true;
}
#method_after
protected boolean canRunActionOnNonManagedVm() {
    ValidationResult nonManagedVmValidationResult = VmHandler.canRunActionOnNonManagedVm(getVm(), this.getActionType());
    if (!nonManagedVmValidationResult.isValid()) {
        return failValidation(nonManagedVmValidationResult.getMessage());
    }
    return true;
}
#end_block

#method_before
protected boolean failVmStatusIllegal() {
    return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(getVm().getStatus()));
}
#method_after
protected boolean failVmStatusIllegal() {
    return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(getVm().getStatus()));
}
#end_block

#method_before
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotStatus snapshotStatus, SnapshotType snapshotType, VM vm, boolean saveVmConfiguration, String memoryVolume, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices, final CompensationContext compensationContext) {
    final Snapshot snapshot = new Snapshot(snapshotId, snapshotStatus, vm.getId(), saveVmConfiguration ? generateVmConfiguration(vm, disks, vmDevices) : null, snapshotType, description, new Date(), vm.getAppList(), memoryVolume);
    getSnapshotDao().save(snapshot);
    compensationContext.snapshotNewEntity(snapshot);
    return snapshot;
}
#method_after
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotStatus snapshotStatus, SnapshotType snapshotType, VM vm, boolean saveVmConfiguration, String memoryVolume, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices, final CompensationContext compensationContext) {
    final Snapshot snapshot = new Snapshot(snapshotId, snapshotStatus, vm.getId(), saveVmConfiguration ? generateVmConfiguration(vm, disks, vmDevices) : null, snapshotType, description, new Date(), vm.getAppList(), memoryVolume, MemoryUtils.getMemoryDiskId(memoryVolume), MemoryUtils.getMetadataDiskId(memoryVolume));
    getSnapshotDao().save(snapshot);
    compensationContext.snapshotNewEntity(snapshot);
    return snapshot;
}
#end_block

#method_before
public boolean updateVmFromConfiguration(VM vm, String configuration) {
    try {
        VmStatic oldVmStatic = vm.getStaticData();
        VM tempVM = new VM();
        ArrayList<DiskImage> images = new ArrayList<>();
        ArrayList<VmNetworkInterface> interfaces = new ArrayList<>();
        new OvfManager().importVm(configuration, tempVM, images, interfaces);
        for (DiskImage diskImage : images) {
            DiskImage dbImage = getDiskImageDao().getSnapshotById(diskImage.getImageId());
            if (dbImage != null) {
                diskImage.setStorageIds(dbImage.getStorageIds());
            }
        }
        new VMStaticOvfLogHandler(tempVM.getStaticData()).resetDefaults(oldVmStatic);
        vm.setStaticData(tempVM.getStaticData());
        IconUtils.preserveIcons(vm.getStaticData(), oldVmStatic);
        vm.setImages(images);
        vm.setInterfaces(interfaces);
        // These fields are not saved in the OVF, so get them from the current VM.
        vm.setIsoPath(oldVmStatic.getIsoPath());
        vm.setVdsGroupId(oldVmStatic.getVdsGroupId());
        // The VM configuration does not hold the vds group Id.
        // It is necessary to fetch the vm static from the Db, in order to get this information
        VmStatic vmStaticFromDb = getVmStaticDao().get(vm.getId());
        if (vmStaticFromDb != null) {
            VDSGroup vdsGroup = getVdsGroupDao().get(vmStaticFromDb.getVdsGroupId());
            if (vdsGroup != null) {
                vm.setStoragePoolId(vdsGroup.getStoragePoolId());
                vm.setVdsGroupCompatibilityVersion(vdsGroup.getCompatibilityVersion());
                vm.setVdsGroupName(vdsGroup.getName());
                vm.setVdsGroupCpuName(vdsGroup.getCpuName());
            }
        }
        // if the required dedicated host is invalid -> use current VM dedicated host
        if (!VmHandler.validateDedicatedVdsExistOnSameCluster(vm.getStaticData(), null)) {
            vm.setDedicatedVmForVdsList(oldVmStatic.getDedicatedVmForVdsList());
        }
        validateQuota(vm);
        return true;
    } catch (OvfReaderException e) {
        log.error("Failed to update VM from the configuration '{}': {}", configuration, e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#method_after
public boolean updateVmFromConfiguration(VM vm, String configuration) {
    try {
        VmStatic oldVmStatic = vm.getStaticData();
        VM tempVM = new VM();
        ArrayList<DiskImage> images = new ArrayList<>();
        ArrayList<VmNetworkInterface> interfaces = new ArrayList<>();
        new OvfManager().importVm(configuration, tempVM, images, interfaces);
        for (DiskImage diskImage : images) {
            DiskImage dbImage = getDiskImageDao().getSnapshotById(diskImage.getImageId());
            if (dbImage != null) {
                diskImage.setStorageIds(dbImage.getStorageIds());
            }
        }
        new VMStaticOvfLogHandler(tempVM.getStaticData()).resetDefaults(oldVmStatic);
        vm.setStaticData(tempVM.getStaticData());
        IconUtils.preserveIcons(vm.getStaticData(), oldVmStatic);
        vm.setImages(images);
        vm.setInterfaces(interfaces);
        // These fields are not saved in the OVF, so get them from the current VM.
        vm.setIsoPath(oldVmStatic.getIsoPath());
        vm.setClusterId(oldVmStatic.getClusterId());
        // The VM configuration does not hold the vds group Id.
        // It is necessary to fetch the vm static from the Db, in order to get this information
        VmStatic vmStaticFromDb = getVmStaticDao().get(vm.getId());
        if (vmStaticFromDb != null) {
            Cluster cluster = getClusterDao().get(vmStaticFromDb.getClusterId());
            if (cluster != null) {
                vm.setStoragePoolId(cluster.getStoragePoolId());
                vm.setClusterCompatibilityVersion(cluster.getCompatibilityVersion());
                vm.setClusterName(cluster.getName());
                vm.setClusterCpuName(cluster.getCpuName());
            }
        }
        // if the required dedicated host is invalid -> use current VM dedicated host
        if (!VmHandler.validateDedicatedVdsExistOnSameCluster(vm.getStaticData(), null)) {
            vm.setDedicatedVmForVdsList(oldVmStatic.getDedicatedVmForVdsList());
        }
        validateQuota(vm);
        return true;
    } catch (OvfReaderException e) {
        log.error("Failed to update VM from the configuration '{}': {}", configuration, e.getMessage());
        log.debug("Exception", e);
        return false;
    }
}
#end_block

#method_before
protected void synchronizeNics(VM vm, CompensationContext compensationContext, DbUser user) {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(getMacPool(vm.getStoragePoolId()));
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(vm.getVdsGroupId(), vm.getStoragePoolId(), vm.getCompatibilityVersion(), AuditLogType.IMPORTEXPORT_SNAPSHOT_VM_INVALID_INTERFACES);
    vmInterfaceManager.removeAll(vm.getId());
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        vmInterface.setVmId(vm.getId());
        // These fields might not be saved in the OVF, so fill them with reasonable values.
        if (vmInterface.getId() == null) {
            vmInterface.setId(Guid.newGuid());
        }
        vnicProfileHelper.updateNicWithVnicProfileForUser(vmInterface, user);
        vmInterfaceManager.add(vmInterface, compensationContext, true, vm.getOs(), vm.getCompatibilityVersion());
    }
    vnicProfileHelper.auditInvalidInterfaces(vm.getName());
}
#method_after
protected void synchronizeNics(VM vm, CompensationContext compensationContext, DbUser user) {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(getMacPool(vm.getStoragePoolId()));
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(vm.getClusterId(), vm.getStoragePoolId(), vm.getCompatibilityVersion(), AuditLogType.IMPORTEXPORT_SNAPSHOT_VM_INVALID_INTERFACES);
    vmInterfaceManager.removeAll(vm.getId());
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        vmInterface.setVmId(vm.getId());
        // These fields might not be saved in the OVF, so fill them with reasonable values.
        if (vmInterface.getId() == null) {
            vmInterface.setId(Guid.newGuid());
        }
        vnicProfileHelper.updateNicWithVnicProfileForUser(vmInterface, user);
        vmInterfaceManager.add(vmInterface, compensationContext, true, vm.getOs(), vm.getCompatibilityVersion());
    }
    vnicProfileHelper.auditInvalidInterfaces(vm.getName());
}
#end_block

#method_before
private void updateProperties() {
    VM vm = getEntity().getVm();
    super.updateProperties(vm.getId());
    getName().setEntity(vm.getName());
    getOperatingSystems().setItems(AsyncDataProvider.getInstance().getOsIds(vm.getClusterArch()));
    setDescription(vm.getVmDescription());
    // $NON-NLS-1$
    setQuotaName(vm.getQuotaName() != null ? vm.getQuotaName() : "");
    setQuotaAvailable(vm.getQuotaEnforcementType() != null && !vm.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    setTemplate(vmTemplateNameRenderer.render(vm));
    // $NON-NLS-1$
    setDefinedMemory(vm.getVmMemSizeMb() + " MB");
    // $NON-NLS-1$
    setMinAllocatedMemory(vm.getMinAllocatedMem() + " MB");
    if (vm.isRunningOrPaused() && vm.getGuestMemoryBuffered() != null && vm.getGuestMemoryCached() != null && vm.getGuestMemoryFree() != null) {
        setGuestFreeCachedBufferedMemInfo(// $NON-NLS-1$
        (vm.getGuestMemoryFree() / 1024L) + " / " + (vm.getGuestMemoryBuffered() / 1024L) + // $NON-NLS-1$
        " / " + (vm.getGuestMemoryCached() / 1024L) + // $NON-NLS-1$
        " MB");
    } else {
        // Handled in form
        setGuestFreeCachedBufferedMemInfo(null);
    }
    setOS(AsyncDataProvider.getInstance().getOsName(vm.getVmOsId()));
    setDefaultDisplayType(translator.translate(vm.getDefaultDisplayType()));
    setIsHighlyAvailable(vm.isAutoStartup());
    setPriority(AsyncDataProvider.getInstance().priorityToString(vm.getPriority()));
    setMonitorCount(vm.getNumOfMonitors());
    setUsbPolicy(translator.translate(vm.getUsbPolicy()));
    setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(vm.getNumOfCpus(), vm.getNumOfSockets(), vm.getCpuPerSocket(), vm.getThreadsPerCpu()));
    setGuestCpuCount(vm.getGuestCpuCount());
    setHasDomain(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    if (vm.getVmInit() != null) {
        setDomain(vm.getVmInit().getDomain());
    }
    setHasTimeZone(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    setTimeZone(vm.getTimeZone());
    setHasCustomProperties(!StringHelper.isNullOrEmpty(vm.getCustomProperties()));
    setCustomProperties(getHasCustomProperties() ? constants.configured() : constants.notConfigured());
    setCompatibilityVersion(vm.getCompatibilityVersion() != null ? vm.getCompatibilityVersion().toString() : // $NON-NLS-1$
    "");
    setVmId(vm.getId().toString());
    setFqdn(vm.getVmFQDN());
    setHasAlert(vm.getVmPauseStatus() != VmPauseStatus.NONE && vm.getVmPauseStatus() != VmPauseStatus.NOERR);
    if (getHasAlert()) {
        setAlert(translator.translate(vm.getVmPauseStatus()));
    } else {
        setAlert(null);
    }
    setHasDefaultHost(vm.getDedicatedVmForVdsList().isEmpty() == false);
    if (getHasDefaultHost()) {
        Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(// $NON-NLS-1$
        "Host: cluster = " + vm.getVdsGroupName() + " sortby name", SearchType.VDS), new // $NON-NLS-1$
        AsyncQuery(// $NON-NLS-1$
        this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmGeneralModel model = (VmGeneralModel) target;
                VM localVm = model.getEntity();
                if (localVm == null) {
                    return;
                }
                ArrayList<VDS> hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
                for (VDS host : hosts) {
                    if (localVm.getDedicatedVmForVdsList().contains(host.getId())) {
                        model.setDefaultHost(host.getName());
                        break;
                    }
                }
            }
        }));
    } else {
        setDefaultHost(ConstantsManager.getInstance().getConstants().anyHostInCluster());
    }
}
#method_after
private void updateProperties() {
    VM vm = getEntity().getVm();
    super.updateProperties(vm.getId());
    getName().setEntity(vm.getName());
    getOperatingSystems().setItems(AsyncDataProvider.getInstance().getOsIds(vm.getClusterArch()));
    setDescription(vm.getVmDescription());
    // $NON-NLS-1$
    setQuotaName(vm.getQuotaName() != null ? vm.getQuotaName() : "");
    setQuotaAvailable(vm.getQuotaEnforcementType() != null && !vm.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    setTemplate(vmTemplateNameRenderer.render(vm));
    // $NON-NLS-1$
    setDefinedMemory(vm.getVmMemSizeMb() + " MB");
    // $NON-NLS-1$
    setMinAllocatedMemory(vm.getMinAllocatedMem() + " MB");
    if (vm.isRunningOrPaused() && vm.getGuestMemoryBuffered() != null && vm.getGuestMemoryCached() != null && vm.getGuestMemoryFree() != null) {
        setGuestFreeCachedBufferedMemInfo(// $NON-NLS-1$
        (vm.getGuestMemoryFree() / 1024L) + " / " + (vm.getGuestMemoryBuffered() / 1024L) + // $NON-NLS-1$
        " / " + (vm.getGuestMemoryCached() / 1024L) + // $NON-NLS-1$
        " MB");
    } else {
        // Handled in form
        setGuestFreeCachedBufferedMemInfo(null);
    }
    setOS(AsyncDataProvider.getInstance().getOsName(vm.getVmOsId()));
    setDefaultDisplayType(translator.translate(vm.getDefaultDisplayType()));
    setIsHighlyAvailable(vm.isAutoStartup());
    setPriority(AsyncDataProvider.getInstance().priorityToString(vm.getPriority()));
    setMonitorCount(vm.getNumOfMonitors());
    setUsbPolicy(translator.translate(vm.getUsbPolicy()));
    setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(vm.getNumOfCpus(), vm.getNumOfSockets(), vm.getCpuPerSocket(), vm.getThreadsPerCpu()));
    setGuestCpuCount(vm.getGuestCpuCount());
    setHasDomain(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    if (vm.getVmInit() != null) {
        setDomain(vm.getVmInit().getDomain());
    }
    setHasTimeZone(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    setTimeZone(vm.getTimeZone());
    setHasCustomProperties(!StringHelper.isNullOrEmpty(vm.getCustomProperties()));
    setCustomProperties(getHasCustomProperties() ? constants.configured() : constants.notConfigured());
    setCompatibilityVersion(vm.getCompatibilityVersion() != null ? vm.getCompatibilityVersion().toString() : // $NON-NLS-1$
    "");
    setVmId(vm.getId().toString());
    setFqdn(vm.getVmFQDN());
    setHasAlert(vm.getVmPauseStatus() != VmPauseStatus.NONE && vm.getVmPauseStatus() != VmPauseStatus.NOERR);
    if (getHasAlert()) {
        setAlert(translator.translate(vm.getVmPauseStatus()));
    } else {
        setAlert(null);
    }
    setHasDefaultHost(vm.getDedicatedVmForVdsList().isEmpty() == false);
    if (getHasDefaultHost()) {
        Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(// $NON-NLS-1$
        "Host: cluster = " + vm.getClusterName() + " sortby name", SearchType.VDS), new // $NON-NLS-1$
        AsyncQuery(// $NON-NLS-1$
        this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VM localVm = getEntity() != null ? getEntity().getVm() : null;
                if (localVm == null) {
                    return;
                }
                ArrayList<VDS> hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
                for (VDS host : hosts) {
                    if (localVm.getDedicatedVmForVdsList().contains(host.getId())) {
                        setDefaultHost(host.getName());
                        break;
                    }
                }
            }
        }));
    } else {
        setDefaultHost(ConstantsManager.getInstance().getConstants().anyHostInCluster());
    }
}
#end_block

#method_before
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    model.stopProgress();
    for (Object a : getSelectedItems()) {
        VM vm = (VM) a;
        MoveVmParameters parameter = new MoveVmParameters(vm.getId(), storageDomainId);
        parameter.setForceOverride(model.getForceOverride().getEntity());
        parameter.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameter.setTemplateMustExists(true);
        parameters.add(parameter);
    }
    if (!model.getCollapseSnapshots().getEntity()) {
        if ((missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0)) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().templatesNotFoundOnExportDomainTitle());
            confirmModel.setHelpTag(HelpTag.template_not_found_on_export_domain);
            // $NON-NLS-1$
            confirmModel.setHashName("template_not_found_on_export_domain");
            confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainMsg());
            confirmModel.setItems(missingTemplatesFromVms);
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnExportNoTemplates", this);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirmation", this);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress();
            Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    ExportVmModel localModel = (ExportVmModel) result.getState();
                    localModel.stopProgress();
                    cancel();
                }
            }, model);
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        for (VdcActionParametersBase item : parameters) {
            MoveVmParameters parameter = (MoveVmParameters) item;
            parameter.setTemplateMustExists(false);
        }
        model.startProgress();
        Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#method_after
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    model.stopProgress();
    for (Object a : getSelectedItems()) {
        VM vm = (VM) a;
        MoveVmParameters parameter = new MoveVmParameters(vm.getId(), storageDomainId);
        parameter.setForceOverride(model.getForceOverride().getEntity());
        parameter.setCopyCollapse(model.getCollapseSnapshots().getEntity());
        parameter.setTemplateMustExists(true);
        parameters.add(parameter);
    }
    if (!model.getCollapseSnapshots().getEntity()) {
        if (missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0) {
            ConfirmationModel confirmModel = new ConfirmationModel();
            setConfirmWindow(confirmModel);
            confirmModel.setTitle(ConstantsManager.getInstance().getConstants().templatesNotFoundOnExportDomainTitle());
            confirmModel.setHelpTag(HelpTag.template_not_found_on_export_domain);
            // $NON-NLS-1$
            confirmModel.setHashName("template_not_found_on_export_domain");
            confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainMsg());
            confirmModel.setItems(missingTemplatesFromVms);
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnExportNoTemplates", this);
            confirmModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirmation", this);
            confirmModel.getCommands().add(tempVar2);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress();
            Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    ExportVmModel localModel = (ExportVmModel) result.getState();
                    localModel.stopProgress();
                    cancel();
                }
            }, model);
        }
    } else {
        if (model.getProgress() != null) {
            return;
        }
        for (VdcActionParametersBase item : parameters) {
            MoveVmParameters parameter = (MoveVmParameters) item;
            parameter.setTemplateMustExists(false);
        }
        model.startProgress();
        Frontend.getInstance().runMultipleAction(VdcActionType.ExportVm, parameters, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#end_block

#method_before
private void powerAction(final String actionName, final String title, final String message) {
    Guid clusterId = getClusterIdOfSelectedVms();
    if (clusterId == null) {
        powerAction(actionName, title, message, false);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null) {
                    powerAction(actionName, title, message, cluster.isOptionalReasonRequired());
                }
            }
        }), clusterId);
    }
}
#method_after
private void powerAction(final String actionName, final String title, final String message) {
    Guid clusterId = getClusterIdOfSelectedVms();
    if (clusterId == null) {
        powerAction(actionName, title, message, false);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Cluster cluster = (Cluster) returnValue;
                if (cluster != null) {
                    powerAction(actionName, title, message, cluster.isOptionalReasonRequired());
                }
            }
        }), clusterId);
    }
}
#end_block

#method_before
private Guid getClusterIdOfSelectedVms() {
    Guid clusterId = null;
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        if (clusterId == null) {
            clusterId = a.getVdsGroupId();
        } else if (!clusterId.equals(a.getVdsGroupId())) {
            clusterId = null;
            break;
        }
    }
    return clusterId;
}
#method_after
private Guid getClusterIdOfSelectedVms() {
    Guid clusterId = null;
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        if (clusterId == null) {
            clusterId = a.getClusterId();
        } else if (!clusterId.equals(a.getClusterId())) {
            clusterId = null;
            break;
        }
    }
    return clusterId;
}
#end_block

#method_before
private void onChangeCD() {
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (Objects.equals(model.getIsoImage().getSelectedItem(), vm.getCurrentCd())) {
        cancel();
        return;
    }
    String isoName = // $NON-NLS-1$
    (Objects.equals(model.getIsoImage().getSelectedItem(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    model.startProgress();
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onChangeCD() {
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (Objects.equals(model.getIsoImage().getSelectedItem(), vm.getCurrentCd())) {
        cancel();
        return;
    }
    String isoName = // $NON-NLS-1$
    Objects.equals(model.getIsoImage().getSelectedItem(), ConsoleModel.getEjectLabel()) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    model.startProgress();
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void updateExistingVm(final boolean applyCpuChangesLater) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    // runEditVM: should be true if Cluster hasn't changed or if
    // Cluster has changed and Editing it in the Backend has succeeded:
    VM selectedItem = getSelectedItem();
    Guid oldClusterID = selectedItem.getVdsGroupId();
    Guid newClusterID = model.getSelectedCluster().getId();
    if (oldClusterID.equals(newClusterID) == false) {
        ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
        model.startProgress();
        Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                final VmListModel<Void> vmListModel = (VmListModel<Void>) result.getState();
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    VM vm = vmListModel.getcurrentVm();
                    VmManagementParametersBase updateVmParams = vmListModel.getUpdateVmParameters(applyCpuChangesLater);
                    Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vm.getId()), vmListModel);
                } else {
                    vmListModel.getWindow().stopProgress();
                }
            }
        }, this);
    } else {
        model.startProgress();
        VmManagementParametersBase updateVmParams = getUpdateVmParameters(applyCpuChangesLater);
        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
    }
}
#method_after
private void updateExistingVm(final boolean applyCpuChangesLater) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    // runEditVM: should be true if Cluster hasn't changed or if
    // Cluster has changed and Editing it in the Backend has succeeded:
    VM selectedItem = getSelectedItem();
    Guid oldClusterID = selectedItem.getClusterId();
    Guid newClusterID = model.getSelectedCluster().getId();
    if (oldClusterID.equals(newClusterID) == false) {
        ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId(), model.getCustomCompatibilityVersion().getSelectedItem());
        model.startProgress();
        Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                final VmListModel<Void> vmListModel = (VmListModel<Void>) result.getState();
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    VM vm = vmListModel.getcurrentVm();
                    VmManagementParametersBase updateVmParams = vmListModel.getUpdateVmParameters(applyCpuChangesLater);
                    Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vm.getId()), vmListModel);
                } else {
                    vmListModel.getWindow().stopProgress();
                }
            }
        }, this);
    } else {
        model.startProgress();
        VmManagementParametersBase updateVmParams = getUpdateVmParameters(applyCpuChangesLater);
        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
    }
}
#end_block

#method_before
private boolean validateStorage() {
    List<DiskImage> vmDisksList = getDisksListForChecks();
    vmDisksList = ImagesHandler.getDisksDummiesForStorageAllocations(vmDisksList);
    List<DiskImage> allDisks = new ArrayList<>(vmDisksList);
    List<DiskImage> memoryDisksList = null;
    if (getParameters().isSaveMemory()) {
        memoryDisksList = MemoryUtils.createDiskDummies(getVm().getTotalMemorySizeInBytes(), MemoryUtils.METADATA_SIZE_IN_BYTES);
        if (Guid.Empty.equals(getStorageDomainIdForVmMemory(memoryDisksList))) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        allDisks.addAll(memoryDisksList);
    }
    MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(allDisks);
    if (!validate(sdValidator.allDomainsExistAndActive()) || !validate(sdValidator.allDomainsWithinThresholds()) || !validateCinder()) {
        return false;
    }
    if (memoryDisksList == null) {
        // no memory volumes
        return validate(sdValidator.allDomainsHaveSpaceForNewDisks(vmDisksList));
    }
    return validate(sdValidator.allDomainsHaveSpaceForAllDisks(vmDisksList, memoryDisksList));
}
#method_after
private boolean validateStorage() {
    List<DiskImage> vmDisksList = getDisksListForChecks();
    vmDisksList = ImagesHandler.getDisksDummiesForStorageAllocations(vmDisksList);
    List<DiskImage> allDisks = new ArrayList<>(vmDisksList);
    List<DiskImage> memoryDisksList = null;
    if (getParameters().isSaveMemory()) {
        memoryDisksList = MemoryUtils.createDiskDummies(getVm().getTotalMemorySizeInBytes(), MemoryUtils.METADATA_SIZE_IN_BYTES);
        if (Guid.Empty.equals(getStorageDomainIdForVmMemory(memoryDisksList))) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        allDisks.addAll(memoryDisksList);
    }
    MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(allDisks);
    if (!validate(sdValidator.allDomainsExistAndActive()) || !validate(sdValidator.allDomainsWithinThresholds()) || !validateCinder()) {
        return false;
    }
    if (memoryDisksList == null) {
        // no memory volumes
        return validate(sdValidator.allDomainsHaveSpaceForNewDisks(vmDisksList));
    }
    return validate(sdValidator.allDomainsHaveSpaceForAllDisks(vmDisksList, memoryDisksList));
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    getParameters().setSnapshotType(determineSnapshotType());
    Guid createdSnapshotId = updateActiveSnapshotId();
    setActionReturnValue(createdSnapshotId);
    MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder();
    freezeVm();
    createSnapshotsForDisks();
    addSnapshotToDB(createdSnapshotId, memoryImageBuilder);
    fastForwardDisksToActiveSnapshot();
    memoryImageBuilder.build();
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        getParameters().setTaskGroupSuccess(true);
        incrementVmGeneration();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    getParameters().setSnapshotType(determineSnapshotType());
    Guid createdSnapshotId = updateActiveSnapshotId();
    setActionReturnValue(createdSnapshotId);
    MemoryImageBuilder memoryImageBuilder = getMemoryImageBuilder();
    freezeVm();
    createSnapshotsForDisks();
    memoryImageBuilder.build();
    addSnapshotToDB(createdSnapshotId, memoryImageBuilder);
    fastForwardDisksToActiveSnapshot();
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        getParameters().setTaskGroupSuccess(true);
        incrementVmGeneration();
    }
    setSucceeded(true);
}
#end_block

#method_before
private Guid updateActiveSnapshotId() {
    final Snapshot activeSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
    final Guid activeSnapshotId = activeSnapshot.getId();
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(activeSnapshot);
            getSnapshotDao().updateId(activeSnapshotId, newActiveSnapshotId);
            activeSnapshot.setId(newActiveSnapshotId);
            getCompensationContext().snapshotNewEntity(activeSnapshot);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    return activeSnapshotId;
}
#method_after
private Guid updateActiveSnapshotId() {
    final Snapshot activeSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
    final Guid activeSnapshotId = activeSnapshot.getId();
    TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
        getCompensationContext().snapshotEntity(activeSnapshot);
        getSnapshotDao().updateId(activeSnapshotId, newActiveSnapshotId);
        activeSnapshot.setId(newActiveSnapshotId);
        getCompensationContext().snapshotNewEntity(activeSnapshot);
        getCompensationContext().stateChanged();
        return null;
    });
    return activeSnapshotId;
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    if (CommandCoordinatorUtil.getChildCommandIds(getCommandId()).size() > 1) {
        log.info("There are still running CoCo tasks");
        return;
    }
    Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), determineSnapshotType(), SnapshotStatus.LOCKED);
    // if the snapshot was not created in the DB
    // the command should also be handled as a failure
    boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess();
    boolean liveSnapshotRequired = isLiveSnapshotApplicable();
    boolean liveSnapshotSucceeded = false;
    if (taskGroupSucceeded) {
        getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
        if (liveSnapshotRequired) {
            liveSnapshotSucceeded = performLiveSnapshot(createdSnapshot);
        } else {
            // they are not going to be in use since no live snapshot is created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                logMemorySavingFailed();
                getSnapshotDao().removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
    } else {
        if (createdSnapshot != null) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // Note that the memory volumes might not have been created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        } else {
            log.warn("No snapshot was created for VM '{}' which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    thawVm();
    endActionOnDisks();
    setSucceeded(taskGroupSucceeded && (!liveSnapshotRequired || liveSnapshotSucceeded));
    getReturnValue().setEndActionTryAgain(false);
}
#method_after
@Override
protected void endVmCommand() {
    Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    // if the snapshot was not created in the DB
    // the command should also be handled as a failure
    boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess();
    boolean liveSnapshotRequired = isLiveSnapshotApplicable();
    boolean liveSnapshotSucceeded = false;
    if (taskGroupSucceeded) {
        getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
        if (liveSnapshotRequired) {
            liveSnapshotSucceeded = performLiveSnapshot(createdSnapshot);
        } else {
            // they are not going to be in use since no live snapshot is created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                logMemorySavingFailed();
                getSnapshotDao().removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
    } else {
        if (createdSnapshot != null) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // Note that the memory volumes might not have been created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        } else {
            log.warn("No snapshot was created for VM '{}' which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    thawVm();
    endActionOnDisks();
    setSucceeded(taskGroupSucceeded && (!liveSnapshotRequired || liveSnapshotSucceeded));
    getReturnValue().setEndActionTryAgain(false);
}
#end_block

#method_before
protected boolean performLiveSnapshot(final Snapshot snapshot) {
    try {
        TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                runVdsCommand(VDSCommandType.Snapshot, buildLiveSnapshotParameters(snapshot));
                return null;
            }
        });
    } catch (EngineException e) {
        handleVdsLiveSnapshotFailure(e);
        return false;
    }
    return true;
}
#method_after
protected boolean performLiveSnapshot(final Snapshot snapshot) {
    try {
        TransactionSupport.executeInScope(TransactionScopeOption.Suppress, () -> {
            runVdsCommand(VDSCommandType.Snapshot, buildLiveSnapshotParameters(snapshot));
            return null;
        });
    } catch (EngineException e) {
        handleVdsLiveSnapshotFailure(e);
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean validateVM(VmValidator vmValidator) {
    LiveSnapshotValidator validator = new LiveSnapshotValidator(getStoragePool().getCompatibilityVersion(), getVds());
    return (getVm().isDown() || validate(validator.canDoSnapshot())) && validate(vmValidator.vmNotSavingRestoring()) && validate(vmValidator.validateVmStatusUsingMatrix(VdcActionType.CreateAllSnapshotsFromVm));
}
#method_after
protected boolean validateVM(VmValidator vmValidator) {
    LiveSnapshotValidator validator = new LiveSnapshotValidator(getStoragePool().getCompatibilityVersion(), getVds());
    return (getVm().isDown() || validate(validator.validateSnapshot())) && validate(vmValidator.vmNotSavingRestoring()) && validate(vmValidator.validateVmStatusUsingMatrix(VdcActionType.CreateAllSnapshotsFromVm));
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__CREATE);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__SNAPSHOT);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__CREATE);
    addValidationMessage(EngineMessage.VAR__TYPE__SNAPSHOT);
}
#end_block

#method_before
// ///////////////////////////////////////
// / TaskHandlerCommand implementation ///
// ///////////////////////////////////////
public void preventRollback() {
    throw new NotImplementedException();
}
#method_after
// ///////////////////////////////////////
// / TaskHandlerCommand implementation ///
// ///////////////////////////////////////
@Override
public void preventRollback() {
    throw new NotImplementedException();
}
#end_block

#method_before
public Guid createTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, VdcObjectType entityType, Guid... entityIds) {
    return super.createTask(taskId, asyncTaskCreationInfo, parentCommand, entityType, entityIds);
}
#method_after
@Override
public Guid createTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, VdcObjectType entityType, Guid... entityIds) {
    return super.createTask(taskId, asyncTaskCreationInfo, parentCommand, entityType, entityIds);
}
#end_block

#method_before
public Guid createTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return super.createTask(taskId, asyncTaskCreationInfo, parentCommand);
}
#method_after
@Override
public Guid createTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return super.createTask(taskId, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public ArrayList<Guid> getTaskIdList() {
    return super.getTaskIdList();
}
#method_after
@Override
public ArrayList<Guid> getTaskIdList() {
    return super.getTaskIdList();
}
#end_block

#method_before
public Guid persistAsyncTaskPlaceHolder() {
    return super.persistAsyncTaskPlaceHolder(getActionType());
}
#method_after
@Override
public Guid persistAsyncTaskPlaceHolder() {
    return super.persistAsyncTaskPlaceHolder(getActionType());
}
#end_block

#method_before
public Guid persistAsyncTaskPlaceHolder(String taskKey) {
    return super.persistAsyncTaskPlaceHolder(getActionType(), taskKey);
}
#method_after
@Override
public Guid persistAsyncTaskPlaceHolder(String taskKey) {
    return super.persistAsyncTaskPlaceHolder(getActionType(), taskKey);
}
#end_block

#method_before
private Map<String, Object> initNicStructure() {
    Map<String, Object> map = new HashMap<>();
    VmNic nic = getParameters().getNic();
    VmDevice vmDevice = getParameters().getVmDevice();
    Version clusterVersion = getParameters().getVm().getCompatibilityVersion();
    map.put(VdsProperties.Type, vmDevice.getType().getValue());
    map.put(VdsProperties.Device, VmDeviceType.BRIDGE.getName());
    map.put(VdsProperties.MAC_ADDR, nic.getMacAddress());
    if (FeatureSupported.networkLinking(clusterVersion)) {
        map.put(VdsProperties.LINK_ACTIVE, String.valueOf(nic.isLinked()));
    }
    addAddress(map, vmDevice.getAddress());
    map.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    map.put(VdsProperties.NIC_TYPE, VmInfoBuilder.evaluateInterfaceType(VmInterfaceType.forValue(nic.getType()), getParameters().getVm().getHasAgent()));
    map.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    VmInfoBuilder.addProfileDataToNic(map, getParameters().getVm(), vmDevice, nic);
    VmInfoBuilder.addNetworkFiltersToNic(map, clusterVersion);
    return map;
}
#method_after
private Map<String, Object> initNicStructure() {
    Map<String, Object> map = new HashMap<>();
    VmNic nic = getParameters().getNic();
    VmDevice vmDevice = getParameters().getVmDevice();
    VM vm = getParameters().getVm();
    if (!nic.isPassthrough()) {
        Version clusterVersion = getParameters().getVm().getCompatibilityVersion();
        map.put(VdsProperties.Type, vmDevice.getType().getValue());
        map.put(VdsProperties.Device, VmDeviceType.BRIDGE.getName());
        map.put(VdsProperties.MAC_ADDR, nic.getMacAddress());
        if (FeatureSupported.networkLinking(clusterVersion)) {
            map.put(VdsProperties.LINK_ACTIVE, String.valueOf(nic.isLinked()));
        }
        addAddress(map, vmDevice.getAddress());
        map.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
        map.put(VdsProperties.NIC_TYPE, VmInfoBuilder.evaluateInterfaceType(VmInterfaceType.forValue(nic.getType()), vm.getHasAgent()));
        map.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
        VmInfoBuilder.addProfileDataToNic(map, vm, vmDevice, nic);
        VmInfoBuilder.addNetworkFiltersToNic(map, clusterVersion);
    } else {
        VmInfoBuilder.addNetworkVirtualFunctionProperties(map, nic, vmDevice, vmDevice.getHostDevice(), vm);
    }
    return map;
}
#end_block

#method_before
private void loadHosts() {
    // append just active hosts
    AsyncDataProvider.getInstance().getHostListByCluster(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final List<VDS> hosts = (ArrayList<VDS>) returnValue;
            final List<VDS> activeHosts = new ArrayList<>();
            for (VDS host : hosts) {
                if (VDSStatus.Up.equals(host.getStatus())) {
                    activeHosts.add(host);
                }
            }
            getDefaultHost().setItems(activeHosts);
            // hide host tab when no active host is available
            if (activeHosts.isEmpty()) {
                setIsHostTabVisible(false);
            }
        }
    }), vm.getVdsGroupName());
}
#method_after
private void loadHosts() {
    // append just active hosts
    AsyncDataProvider.getInstance().getHostListByCluster(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final List<VDS> hosts = (ArrayList<VDS>) returnValue;
            final List<VDS> activeHosts = new ArrayList<>();
            for (VDS host : hosts) {
                if (VDSStatus.Up.equals(host.getStatus())) {
                    activeHosts.add(host);
                }
            }
            getDefaultHost().setItems(activeHosts);
            // hide host tab when no active host is available
            if (activeHosts.isEmpty()) {
                setIsHostTabVisible(false);
            }
        }
    }), vm.getClusterName());
}
#end_block

#method_before
public ValidationResult isDiskUsedAsOvfStore() {
    if (disk.isOvfStore()) {
        return new ValidationResult((EngineMessage.ACTION_TYPE_FAILED_OVF_DISK_NOT_SUPPORTED));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult isDiskUsedAsOvfStore() {
    if (disk.isOvfStore()) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_OVF_DISK_NOT_SUPPORTED);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
protected VmWatchdogValidator getVmWatchdogValidator() {
    VmWatchdogValidator vmWatchdogValidator = null;
    VmWatchdog watchdog = createWatchdogFromParams();
    if (getParameters().isVm()) {
        vmWatchdogValidator = new VmWatchdogValidator(getVm().getOs(), watchdog, getVm().getCompatibilityVersion());
    } else {
        if (getVmTemplate().getVdsGroupId() != null) {
            vmWatchdogValidator = new VmWatchdogValidator(getVmTemplate().getOsId(), watchdog, getVmTemplate().getCompatibilityVersion());
        }
    }
    return vmWatchdogValidator;
}
#method_after
protected VmWatchdogValidator getVmWatchdogValidator() {
    VmWatchdogValidator vmWatchdogValidator = null;
    VmWatchdog watchdog = createWatchdogFromParams();
    if (getParameters().isVm()) {
        vmWatchdogValidator = new VmWatchdogValidator(getVm().getOs(), watchdog, getVm().getCompatibilityVersion());
    } else {
        if (getVmTemplate().getClusterId() != null) {
            vmWatchdogValidator = new VmWatchdogValidator(getVmTemplate().getOsId(), watchdog, getVmTemplate().getCompatibilityVersion());
        }
    }
    return vmWatchdogValidator;
}
#end_block

#method_before
@Override
protected void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE.getName()));
    devicesByDeviceId.putAll(Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.HOST_DEVICE.getName())));
    for (VmNic vmInterface : vm.getInterfaces()) {
        // get vm device for this nic from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            Map struct = new HashMap();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (vmInterface.isPassthrough()) {
                String vfDeviceName = vm.getPassthroughVnicToVfMap().get(vmInterface.getId());
                addNetworkVirtualFunctionProperties(struct, vmInterface, vmDevice, vfDeviceName);
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInfoBuilder.evaluateInterfaceType(ifaceType, vm.getHasAgent()), vm.getCompatibilityVersion());
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#method_after
@Override
protected void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE.getName()));
    devicesByDeviceId.putAll(Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.HOST_DEVICE.getName())));
    for (VmNic vmInterface : vm.getInterfaces()) {
        // get vm device for this nic from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            Map struct = new HashMap();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (vmInterface.isPassthrough()) {
                String vfDeviceName = vm.getPassthroughVnicToVfMap().get(vmInterface.getId());
                addNetworkVirtualFunctionProperties(struct, vmInterface, vmDevice, vfDeviceName, vm);
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInfoBuilder.evaluateInterfaceType(ifaceType, vm.getHasAgent()), vm.getCompatibilityVersion());
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#end_block

#method_before
public static String evaluateInterfaceType(VmInterfaceType ifaceType, boolean vmHasAgent) {
    return ifaceType == VmInterfaceType.rtl8139_pv ? (vmHasAgent ? VmInterfaceType.pv.name() : VmInterfaceType.rtl8139.name()) : ifaceType.getInternalName();
}
#method_after
public static String evaluateInterfaceType(VmInterfaceType ifaceType, boolean vmHasAgent) {
    return ifaceType == VmInterfaceType.rtl8139_pv ? vmHasAgent ? VmInterfaceType.pv.name() : VmInterfaceType.rtl8139.name() : ifaceType.getInternalName();
}
#end_block

#method_before
@Override
protected void buildUnmanagedDevices() {
    Map<String, String> customMap = (createInfo.containsKey(VdsProperties.Custom)) ? (Map<String, String>) createInfo.get(VdsProperties.Custom) : new HashMap<>();
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getUnmanagedDevicesByVmId(vm.getId());
    if (!vmDevices.isEmpty()) {
        StringBuilder id = new StringBuilder();
        for (VmDevice vmDevice : vmDevices) {
            Map struct = new HashMap();
            id.append(VdsProperties.Device);
            id.append("_");
            id.append(vmDevice.getDeviceId());
            if (VmDeviceCommonUtils.isInWhiteList(vmDevice.getType(), vmDevice.getDevice())) {
                struct.put(VdsProperties.Type, vmDevice.getType().getValue());
                struct.put(VdsProperties.Device, vmDevice.getDevice());
                addAddress(vmDevice, struct);
                struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
                struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
                devices.add(struct);
            } else {
                customMap.put(id.toString(), vmDevice.toString());
            }
        }
    }
    createInfo.put(VdsProperties.Custom, customMap);
    createInfo.put(DEVICES, devices);
}
#method_after
@Override
protected void buildUnmanagedDevices() {
    Map<String, String> customMap = createInfo.containsKey(VdsProperties.Custom) ? (Map<String, String>) createInfo.get(VdsProperties.Custom) : new HashMap<>();
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getUnmanagedDevicesByVmId(vm.getId());
    if (!vmDevices.isEmpty()) {
        StringBuilder id = new StringBuilder();
        for (VmDevice vmDevice : vmDevices) {
            Map struct = new HashMap();
            id.append(VdsProperties.Device);
            id.append("_");
            id.append(vmDevice.getDeviceId());
            if (VmDeviceCommonUtils.isInWhiteList(vmDevice.getType(), vmDevice.getDevice())) {
                struct.put(VdsProperties.Type, vmDevice.getType().getValue());
                struct.put(VdsProperties.Device, vmDevice.getDevice());
                addAddress(vmDevice, struct);
                struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
                struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
                devices.add(struct);
            } else {
                customMap.put(id.toString(), vmDevice.toString());
            }
        }
    }
    createInfo.put(VdsProperties.Custom, customMap);
    createInfo.put(DEVICES, devices);
}
#end_block

#method_before
private void addNetworkVirtualFunctionProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String vfName) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.HostDev, vfName);
    addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    Map<String, Object> specParams = new HashMap<>();
    VnicProfile vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(vmInterface.getVnicProfileId());
    Network network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
    if (NetworkUtils.isVlan(network)) {
        specParams.put(VdsProperties.VLAN_ID, network.getVlanId());
    }
    struct.put(VdsProperties.SpecParams, specParams);
    addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getVdsGroupCompatibilityVersion(), getVnicCustomProperties(vnicProfile));
}
#method_after
static void addNetworkVirtualFunctionProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String vfName, VM vm) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.HostDev, vfName);
    addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    Map<String, Object> specParams = new HashMap<>();
    VnicProfile vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(vmInterface.getVnicProfileId());
    Network network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
    if (NetworkUtils.isVlan(network)) {
        specParams.put(VdsProperties.VLAN_ID, network.getVlanId());
    }
    struct.put(VdsProperties.SpecParams, specParams);
    addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getClusterCompatibilityVersion(), getVnicCustomProperties(vnicProfile));
}
#end_block

#method_before
public static void addProfileDataToNic(Map<String, Object> struct, VM vm, VmDevice vmDevice, VmNic nic) {
    VnicProfile vnicProfile = null;
    Network network = null;
    String networkName = "";
    List<VnicProfileProperties> unsupportedFeatures = new ArrayList<>();
    if (nic.getVnicProfileId() != null) {
        vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(nic.getVnicProfileId());
        if (vnicProfile != null) {
            network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
            networkName = network.getName();
            log.debug("VNIC '{}' is using profile '{}' on network '{}'", nic.getName(), vnicProfile, networkName);
            if (!addQosForDevice(struct, vnicProfile, vm.getCompatibilityVersion())) {
                unsupportedFeatures.add(VnicProfileProperties.NETWORK_QOS);
            }
        }
    }
    struct.put(VdsProperties.NETWORK, networkName);
    if (!addPortMirroringToVmInterface(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion(), network)) {
        unsupportedFeatures.add(VnicProfileProperties.PORT_MIRRORING);
    }
    if (!addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getCompatibilityVersion(), getVnicCustomProperties(vnicProfile))) {
        unsupportedFeatures.add(VnicProfileProperties.CUSTOM_PROPERTIES);
    }
    reportUnsupportedVnicProfileFeatures(vm, nic, vnicProfile, unsupportedFeatures);
}
#method_after
public static void addProfileDataToNic(Map<String, Object> struct, VM vm, VmDevice vmDevice, VmNic nic) {
    VnicProfile vnicProfile = null;
    Network network = null;
    String networkName = "";
    List<VnicProfileProperties> unsupportedFeatures = new ArrayList<>();
    if (nic.getVnicProfileId() != null) {
        vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(nic.getVnicProfileId());
        if (vnicProfile != null) {
            network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
            networkName = network.getName();
            log.debug("VNIC '{}' is using profile '{}' on network '{}'", nic.getName(), vnicProfile, networkName);
            if (!addQosForDevice(struct, vnicProfile, vm.getCompatibilityVersion())) {
                unsupportedFeatures.add(VnicProfileProperties.NETWORK_QOS);
            }
        }
    }
    struct.put(VdsProperties.NETWORK, networkName);
    if (!addPortMirroringToVmInterface(struct, vnicProfile, vm.getClusterCompatibilityVersion(), network)) {
        unsupportedFeatures.add(VnicProfileProperties.PORT_MIRRORING);
    }
    if (!addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getCompatibilityVersion(), getVnicCustomProperties(vnicProfile))) {
        unsupportedFeatures.add(VnicProfileProperties.CUSTOM_PROPERTIES);
    }
    reportUnsupportedVnicProfileFeatures(vm, nic, vnicProfile, unsupportedFeatures);
}
#end_block

#method_before
private static boolean addQosForDevice(Map<String, Object> struct, VnicProfile vnicProfile, Version vdsGroupCompatibilityVersion) {
    Guid qosId = vnicProfile.getNetworkQosId();
    if (!FeatureSupported.networkQoS(vdsGroupCompatibilityVersion)) {
        return qosId == null;
    }
    Map<String, Object> specParams = (Map<String, Object>) struct.get(VdsProperties.SpecParams);
    if (specParams == null) {
        specParams = new HashMap<>();
        struct.put(VdsProperties.SpecParams, specParams);
    }
    NetworkQoS networkQoS = (qosId == null) ? new NetworkQoS() : DbFacade.getInstance().getNetworkQosDao().get(qosId);
    NetworkQosMapper qosMapper = new NetworkQosMapper(specParams, VdsProperties.QOS_INBOUND, VdsProperties.QOS_OUTBOUND);
    qosMapper.serialize(networkQoS);
    return true;
}
#method_after
private static boolean addQosForDevice(Map<String, Object> struct, VnicProfile vnicProfile, Version clusterCompatibilityVersion) {
    Guid qosId = vnicProfile.getNetworkQosId();
    if (!FeatureSupported.networkQoS(clusterCompatibilityVersion)) {
        return qosId == null;
    }
    Map<String, Object> specParams = (Map<String, Object>) struct.get(VdsProperties.SpecParams);
    if (specParams == null) {
        specParams = new HashMap<>();
        struct.put(VdsProperties.SpecParams, specParams);
    }
    NetworkQoS networkQoS = (qosId == null) ? new NetworkQoS() : DbFacade.getInstance().getNetworkQosDao().get(qosId);
    NetworkQosMapper qosMapper = new NetworkQosMapper(specParams, VdsProperties.QOS_INBOUND, VdsProperties.QOS_OUTBOUND);
    qosMapper.serialize(networkQoS);
    return true;
}
#end_block

#method_before
private void addDevice(Map<String, Object> struct, VmDevice vmDevice, String path) {
    boolean isPayload = (VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevice.getDevice().equals(VmDeviceType.CDROM.getName()));
    Map<String, Object> specParams = (vmDevice.getSpecParams() == null) ? Collections.<String, Object>emptyMap() : vmDevice.getSpecParams();
    if (path != null) {
        struct.put(VdsProperties.Path, (isPayload) ? "" : path);
    }
    if (isPayload) {
        String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion());
        if ("scsi".equals(cdInterface)) {
            // SCSI unit 1 is reserved for payload
            struct.put(VdsProperties.Index, "1");
            struct.put(VdsProperties.Address, createAddressForScsiDisk(0, 1));
        } else if ("ide".equals(cdInterface)) {
            // 3 is magic number for payload - we are using it as hdd
            struct.put(VdsProperties.Index, "3");
        }
    }
    struct.put(VdsProperties.SpecParams, specParams);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    addBootOrder(vmDevice, struct);
    devices.add(struct);
    addToManagedDevices(vmDevice);
}
#method_after
private void addDevice(Map<String, Object> struct, VmDevice vmDevice, String path) {
    boolean isPayload = VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevice.getDevice().equals(VmDeviceType.CDROM.getName());
    Map<String, Object> specParams = (vmDevice.getSpecParams() == null) ? Collections.<String, Object>emptyMap() : vmDevice.getSpecParams();
    if (path != null) {
        struct.put(VdsProperties.Path, isPayload ? "" : path);
    }
    if (isPayload) {
        String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion());
        if ("scsi".equals(cdInterface)) {
            // SCSI unit 1 is reserved for payload
            struct.put(VdsProperties.Index, "1");
            struct.put(VdsProperties.Address, createAddressForScsiDisk(0, 1));
        } else if ("ide".equals(cdInterface)) {
            // 3 is magic number for payload - we are using it as hdd
            struct.put(VdsProperties.Index, "3");
        }
    }
    struct.put(VdsProperties.SpecParams, specParams);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    addBootOrder(vmDevice, struct);
    devices.add(struct);
    addToManagedDevices(vmDevice);
}
#end_block

#method_before
private void updateProperties() {
    VM vm = getEntity();
    super.updateProperties(vm.getId());
    setName(vm.getName());
    setDescription(vm.getVmDescription());
    // $NON-NLS-1$
    setQuotaName(vm.getQuotaName() != null ? vm.getQuotaName() : "");
    setQuotaAvailable(vm.getQuotaEnforcementType() != null && !vm.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    setTemplate(vmTemplateNameRenderer.render(vm));
    // $NON-NLS-1$
    setDefinedMemory(vm.getVmMemSizeMb() + " MB");
    // $NON-NLS-1$
    setMinAllocatedMemory(vm.getMinAllocatedMem() + " MB");
    if (vm.isRunningOrPaused() && vm.getGuestMemoryBuffered() != null && vm.getGuestMemoryCached() != null && vm.getGuestMemoryFree() != null) {
        setGuestFreeCachedBufferedMemInfo(// $NON-NLS-1$
        (vm.getGuestMemoryFree() / 1024L) + " / " + (vm.getGuestMemoryBuffered() / 1024L) + // $NON-NLS-1$
        " / " + (vm.getGuestMemoryCached() / 1024L) + // $NON-NLS-1$
        " MB");
    } else {
        // Handled in form
        setGuestFreeCachedBufferedMemInfo(null);
    }
    setOS(AsyncDataProvider.getInstance().getOsName(vm.getVmOsId()));
    EnumTranslator translator = EnumTranslator.getInstance();
    setDefaultDisplayType(translator.translate(vm.getDefaultDisplayType()));
    setOrigin(translator.translate(vm.getOrigin()));
    setIsHighlyAvailable(vm.isAutoStartup());
    setPriority(AsyncDataProvider.getInstance().priorityToString(vm.getPriority()));
    setMonitorCount(vm.getNumOfMonitors());
    setUsbPolicy(translator.translate(vm.getUsbPolicy()));
    setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(vm.getNumOfCpus(), vm.getNumOfSockets(), vm.getCpuPerSocket(), vm.getThreadsPerCpu()));
    setGuestCpuCount(vm.getGuestCpuCount());
    setHasDomain(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    if (vm.getVmInit() != null) {
        setDomain(vm.getVmInit().getDomain());
    }
    setHasTimeZone(!StringHelper.isNullOrEmpty(vm.getTimeZone()));
    setTimeZone(vm.getTimeZone());
    setHasCustomProperties(!StringHelper.isNullOrEmpty(vm.getCustomProperties()));
    setCustomProperties(getHasCustomProperties() ? constants.configured() : constants.notConfigured());
    setCompatibilityVersion(vm.getCompatibilityVersion() != null ? vm.getCompatibilityVersion().toString() : // $NON-NLS-1$
    "");
    setVmId(vm.getId().toString());
    setFqdn(vm.getVmFQDN());
    setHasAlert(vm.getVmPauseStatus() != VmPauseStatus.NONE && vm.getVmPauseStatus() != VmPauseStatus.NOERR);
    if (getHasAlert()) {
        setAlert(translator.translate(vm.getVmPauseStatus()));
    } else {
        setAlert(null);
    }
    setHasDefaultHost(vm.getDedicatedVmForVdsList().size() > 0);
    if (getHasDefaultHost()) {
        Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(// $NON-NLS-1$
        "Host: cluster = " + vm.getVdsGroupName() + " sortby name", SearchType.VDS).withoutRefresh(), new // $NON-NLS-1$
        AsyncQuery(// $NON-NLS-1$
        this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmGeneralModel model = (VmGeneralModel) target;
                VM localVm = model.getEntity();
                if (localVm == null) {
                    return;
                }
                ArrayList<VDS> hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
                if (localVm.getDedicatedVmForVdsList().size() > 0) {
                    String defaultHost = "";
                    for (VDS host : hosts) {
                        if (localVm.getDedicatedVmForVdsList().contains(host.getId())) {
                            if (defaultHost.isEmpty()) {
                                defaultHost = host.getName();
                            } else {
                                // $NON-NLS-1$
                                defaultHost += ", " + host.getName();
                            }
                        }
                    }
                    model.setDefaultHost(defaultHost);
                }
            }
        }));
    } else {
        setDefaultHost(ConstantsManager.getInstance().getConstants().anyHostInCluster());
    }
}
#method_after
private void updateProperties() {
    VM vm = getEntity();
    super.updateProperties(vm.getId());
    setName(vm.getName());
    setDescription(vm.getVmDescription());
    // $NON-NLS-1$
    setQuotaName(vm.getQuotaName() != null ? vm.getQuotaName() : "");
    setQuotaAvailable(vm.getQuotaEnforcementType() != null && !vm.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    setTemplate(vmTemplateNameRenderer.render(vm));
    // $NON-NLS-1$
    setDefinedMemory(vm.getVmMemSizeMb() + " MB");
    // $NON-NLS-1$
    setMinAllocatedMemory(vm.getMinAllocatedMem() + " MB");
    if (vm.isRunningOrPaused() && vm.getGuestMemoryBuffered() != null && vm.getGuestMemoryCached() != null && vm.getGuestMemoryFree() != null) {
        setGuestFreeCachedBufferedMemInfo(// $NON-NLS-1$
        (vm.getGuestMemoryFree() / 1024L) + " / " + (vm.getGuestMemoryBuffered() / 1024L) + // $NON-NLS-1$
        " / " + (vm.getGuestMemoryCached() / 1024L) + // $NON-NLS-1$
        " MB");
    } else {
        // Handled in form
        setGuestFreeCachedBufferedMemInfo(null);
    }
    setOS(AsyncDataProvider.getInstance().getOsName(vm.getVmOsId()));
    EnumTranslator translator = EnumTranslator.getInstance();
    setDefaultDisplayType(translator.translate(vm.getDefaultDisplayType()));
    setOrigin(translator.translate(vm.getOrigin()));
    setIsHighlyAvailable(vm.isAutoStartup());
    setPriority(AsyncDataProvider.getInstance().priorityToString(vm.getPriority()));
    setMonitorCount(vm.getNumOfMonitors());
    setUsbPolicy(translator.translate(vm.getUsbPolicy()));
    setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(vm.getNumOfCpus(), vm.getNumOfSockets(), vm.getCpuPerSocket(), vm.getThreadsPerCpu()));
    setGuestCpuCount(vm.getGuestCpuCount());
    setHasDomain(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    if (vm.getVmInit() != null) {
        setDomain(vm.getVmInit().getDomain());
    }
    setHasTimeZone(!StringHelper.isNullOrEmpty(vm.getTimeZone()));
    setTimeZone(vm.getTimeZone());
    setHasCustomProperties(!StringHelper.isNullOrEmpty(vm.getCustomProperties()));
    setCustomProperties(getHasCustomProperties() ? constants.configured() : constants.notConfigured());
    setCompatibilityVersion(vm.getCompatibilityVersion() != null ? vm.getCompatibilityVersion().toString() : // $NON-NLS-1$
    "");
    setVmId(vm.getId().toString());
    setFqdn(vm.getVmFQDN());
    setHasAlert(vm.getVmPauseStatus() != VmPauseStatus.NONE && vm.getVmPauseStatus() != VmPauseStatus.NOERR);
    if (getHasAlert()) {
        setAlert(translator.translate(vm.getVmPauseStatus()));
    } else {
        setAlert(null);
    }
    setHasDefaultHost(vm.getDedicatedVmForVdsList().size() > 0);
    if (getHasDefaultHost()) {
        Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(// $NON-NLS-1$
        "Host: cluster = " + vm.getClusterName() + " sortby name", SearchType.VDS).withoutRefresh(), new // $NON-NLS-1$
        AsyncQuery(// $NON-NLS-1$
        this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmGeneralModel model = (VmGeneralModel) target;
                VM localVm = model.getEntity();
                if (localVm == null) {
                    return;
                }
                ArrayList<VDS> hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
                if (localVm.getDedicatedVmForVdsList().size() > 0) {
                    String defaultHost = "";
                    for (VDS host : hosts) {
                        if (localVm.getDedicatedVmForVdsList().contains(host.getId())) {
                            if (defaultHost.isEmpty()) {
                                defaultHost = host.getName();
                            } else {
                                // $NON-NLS-1$
                                defaultHost += ", " + host.getName();
                            }
                        }
                    }
                    model.setDefaultHost(defaultHost);
                }
            }
        }));
    } else {
        setDefaultHost(ConstantsManager.getInstance().getConstants().anyHostInCluster());
    }
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__HOT_SET_MEMORY);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__VM);
    addCanDoActionMessageVariable("clusterVersion", getVm().getCompatibilityVersion());
    addCanDoActionMessageVariable("architecture", getVm().getClusterArch());
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__HOT_SET_MEMORY);
    addValidationMessage(EngineMessage.VAR__TYPE__VM);
    addValidationMessageVariable("clusterVersion", getVm().getCompatibilityVersion());
    addValidationMessageVariable("architecture", getVm().getClusterArch());
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    // Calculate the change in memory consumption,
    // result above Zero means we add memory to the VM (consume)
    // result bellow Zero means we subtracted memory from the VM (release)
    QuotaConsumptionParameter.QuotaAction quotaAction = (memoryToConsume > 0) ? QuotaConsumptionParameter.QuotaAction.CONSUME : QuotaConsumptionParameter.QuotaAction.RELEASE;
    list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, quotaAction, getVm().getVdsGroupId(), 0, Math.abs(memoryToConsume)));
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    // Calculate the change in memory consumption,
    // result above Zero means we add memory to the VM (consume)
    // result bellow Zero means we subtracted memory from the VM (release)
    QuotaConsumptionParameter.QuotaAction quotaAction = (memoryToConsume > 0) ? QuotaConsumptionParameter.QuotaAction.CONSUME : QuotaConsumptionParameter.QuotaAction.RELEASE;
    list.add(new QuotaClusterConsumptionParameter(getVm().getQuotaId(), null, quotaAction, getVm().getClusterId(), 0, Math.abs(memoryToConsume)));
    return list;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__TYPE__INTERFACE);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__TYPE__INTERFACE);
}
#end_block

#method_before
protected boolean uniqueInterfaceName(List<VmNic> interfaces) {
    return VmHandler.isNotDuplicateInterfaceName(interfaces, getInterfaceName(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean uniqueInterfaceName(List<VmNic> interfaces) {
    return VmHandler.isNotDuplicateInterfaceName(interfaces, getInterfaceName(), getReturnValue().getValidationMessages());
}
#end_block

#method_before
protected boolean pciAndIdeWithinLimit(VM vm, List<VmNic> allInterfaces) {
    List<Disk> allDisks = getDiskDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vm.getOs(), vm.getCompatibilityVersion(), vm.getNumOfMonitors(), allInterfaces, allDisks, VmDeviceUtils.hasVirtioScsiController(getVmId()), VmDeviceUtils.hasWatchdog(getVmId()), VmDeviceUtils.hasMemoryBalloon(getVmId()), VmDeviceUtils.hasSoundDevice(getVmId()), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean pciAndIdeWithinLimit(VM vm, List<VmNic> allInterfaces) {
    List<Disk> allDisks = getDiskDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vm.getOs(), vm.getCompatibilityVersion(), vm.getNumOfMonitors(), allInterfaces, allDisks, VmDeviceUtils.hasVirtioScsiController(getVmId()), VmDeviceUtils.hasWatchdog(getVmId()), VmDeviceUtils.hasMemoryBalloon(getVmId()), VmDeviceUtils.hasSoundDevice(getVmId()), getReturnValue().getValidationMessages());
}
#end_block

#method_before
private void earlyUpdateVmDynamicRunOnce() {
    if (getVm() != null) {
        // function is called before super.canDoAction(), vm object is not safe yet
        if (getParameters().getCustomCpuName() != null) {
            getVm().setCpuName(getParameters().getCustomCpuName());
        }
        if (getParameters().getCustomEmulatedMachine() != null) {
            getVm().setEmulatedMachine(getParameters().getCustomEmulatedMachine());
        }
    }
}
#method_after
private void earlyUpdateVmDynamicRunOnce() {
    if (getVm() != null) {
        // function is called before super.validate(), vm object is not safe yet
        if (getParameters().getCustomCpuName() != null) {
            getVm().setCpuName(getParameters().getCustomCpuName());
        }
        if (getParameters().getCustomEmulatedMachine() != null) {
            getVm().setEmulatedMachine(getParameters().getCustomEmulatedMachine());
        }
    }
}
#end_block

#method_before
protected void updateGraphicsInfos() {
    if (getParameters().getRunOnceGraphics().isEmpty()) {
        // configure from DB
        super.updateGraphicsInfos();
    } else {
        // configure from params
        for (GraphicsType graphicsType : getParameters().getRunOnceGraphics()) {
            getVm().getGraphicsInfos().put(graphicsType, new GraphicsInfo());
        }
    }
}
#method_after
@Override
protected void updateGraphicsInfos() {
    if (getParameters().getRunOnceGraphics().isEmpty()) {
        // configure from DB
        super.updateGraphicsInfos();
    } else {
        // configure from params
        for (GraphicsType graphicsType : getParameters().getRunOnceGraphics()) {
            getVm().getGraphicsInfos().put(graphicsType, new GraphicsInfo());
        }
    }
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__UPDATE);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__VM_DISK);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__UPDATE);
    addValidationMessage(EngineMessage.VAR__TYPE__VM_DISK);
}
#end_block

#method_before
protected boolean validatePciAndIdeLimit(List<VM> vmsDiskPluggedTo) {
    for (VM vm : vmsDiskPluggedTo) {
        List<VmNic> allVmInterfaces = getVmNicDao().getAllForVm(vm.getId());
        List<Disk> allVmDisks = new LinkedList<>(getOtherVmDisks(vm.getId()));
        allVmDisks.add(getNewDisk());
        if (!checkPciAndIdeLimit(vm.getOs(), vm.getCompatibilityVersion(), vm.getNumOfMonitors(), allVmInterfaces, allVmDisks, VmDeviceUtils.hasVirtioScsiController(vm.getId()), VmDeviceUtils.hasWatchdog(vm.getId()), VmDeviceUtils.hasMemoryBalloon(vm.getId()), VmDeviceUtils.hasSoundDevice(vm.getId()), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean validatePciAndIdeLimit(List<VM> vmsDiskPluggedTo) {
    for (VM vm : vmsDiskPluggedTo) {
        List<VmNic> allVmInterfaces = getVmNicDao().getAllForVm(vm.getId());
        List<Disk> allVmDisks = new LinkedList<>(getOtherVmDisks(vm.getId()));
        allVmDisks.add(getNewDisk());
        if (!checkPciAndIdeLimit(vm.getOs(), vm.getCompatibilityVersion(), vm.getNumOfMonitors(), allVmInterfaces, allVmDisks, VmDeviceUtils.hasVirtioScsiController(vm.getId()), VmDeviceUtils.hasWatchdog(vm.getId()), VmDeviceUtils.hasMemoryBalloon(vm.getId()), VmDeviceUtils.hasSoundDevice(vm.getId()), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean validateCanUpdateShareable() {
    if (DiskStorageType.LUN == getOldDisk().getDiskStorageType()) {
        return true;
    }
    // Check if VM is not during snapshot.
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (isUpdatedToShareable(getOldDisk(), getNewDisk())) {
        StorageDomainStatic sds = getStorageDomainStaticDao().get(((DiskImage) getNewDisk()).getStorageIds().get(0));
        if (sds.getStorageType() == StorageType.GLUSTERFS) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_SHAREABLE_DISKS_NOT_SUPPORTED_ON_GLUSTER_DOMAIN);
        }
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(getOldDisk().getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) getOldDisk()).getImageTemplateId())) {
            return failCanDoAction(EngineMessage.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
        }
        if (!isVersionSupportedForShareable(getOldDisk(), getStoragePoolDao().get(getVm().getStoragePoolId()).getCompatibilityVersion().getValue())) {
            return failCanDoAction(EngineMessage.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
        }
        if (!isVolumeFormatSupportedForShareable(((DiskImage) getNewDisk()).getVolumeFormat())) {
            return failCanDoAction(EngineMessage.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
        }
    } else if (isUpdatedToNonShareable(getOldDisk(), getNewDisk())) {
        if (vmsDiskOrSnapshotAttachedTo.size() > 1) {
            return failCanDoAction(EngineMessage.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
        }
    }
    return true;
}
#method_after
private boolean validateCanUpdateShareable() {
    if (DiskStorageType.LUN == getOldDisk().getDiskStorageType()) {
        return true;
    }
    // Check if VM is not during snapshot.
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (isUpdatedToShareable(getOldDisk(), getNewDisk())) {
        StorageDomainStatic sds = getStorageDomainStaticDao().get(((DiskImage) getNewDisk()).getStorageIds().get(0));
        if (sds.getStorageType() == StorageType.GLUSTERFS) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_SHAREABLE_DISKS_NOT_SUPPORTED_ON_GLUSTER_DOMAIN);
        }
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(getOldDisk().getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) getOldDisk()).getImageTemplateId())) {
            return failValidation(EngineMessage.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
        }
        if (!isVersionSupportedForShareable(getOldDisk(), getStoragePoolDao().get(getVm().getStoragePoolId()).getCompatibilityVersion().getValue())) {
            return failValidation(EngineMessage.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
        }
        if (!isVolumeFormatSupportedForShareable(((DiskImage) getNewDisk()).getVolumeFormat())) {
            return failValidation(EngineMessage.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
        }
    } else if (isUpdatedToNonShareable(getOldDisk(), getNewDisk())) {
        if (vmsDiskOrSnapshotAttachedTo.size() > 1) {
            return failValidation(EngineMessage.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
        }
    }
    return true;
}
#end_block

#method_before
protected boolean validateCanUpdateReadOnly(DiskValidator diskValidator) {
    if (updateReadOnlyRequested()) {
        if (getVm().getStatus() != VMStatus.Down && vmDeviceForVm.getIsPlugged()) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        return validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface());
    }
    return true;
}
#method_after
protected boolean validateCanUpdateReadOnly(DiskValidator diskValidator) {
    if (updateReadOnlyRequested()) {
        if (getVm().getStatus() != VMStatus.Down && vmDeviceForVm.getIsPlugged()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        return validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface());
    }
    return true;
}
#end_block

#method_before
protected boolean validateVmPoolProperties() {
    if ((updateReadOnlyRequested() || updateWipeAfterDeleteRequested()) && getVm().getVmPoolId() != null)
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    return true;
}
#method_after
protected boolean validateVmPoolProperties() {
    if ((updateReadOnlyRequested() || updateWipeAfterDeleteRequested()) && getVm().getVmPoolId() != null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    }
    return true;
}
#end_block

#method_before
protected boolean validateCanResizeDisk() {
    DiskImage newDiskImage = (DiskImage) getNewDisk();
    DiskImage oldDiskImage = (DiskImage) getOldDisk();
    if (newDiskImage.getSize() != oldDiskImage.getSize()) {
        if (Boolean.TRUE.equals(getVmDeviceForVm().getIsReadOnly())) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
        }
        if (vmDeviceForVm.getSnapshotId() != null) {
            DiskImage snapshotDisk = getDiskImageDao().getDiskSnapshotForVmSnapshot(getParameters().getDiskId(), vmDeviceForVm.getSnapshotId());
            if (snapshotDisk.getSize() != newDiskImage.getSize()) {
                return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_DISK_SNAPSHOT);
            }
        }
        if (oldDiskImage.getSize() > newDiskImage.getSize()) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_REQUESTED_DISK_SIZE_IS_TOO_SMALL);
        }
        for (VM vm : getVmsDiskPluggedTo()) {
            if (!VdcActionUtils.canExecute(Collections.singletonList(vm), VM.class, VdcActionType.ExtendImageSize)) {
                return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
            }
        }
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator((DiskImage) getNewDisk());
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
        // For size allocation validation, we'll create a dummy with the additional size required.
        // That way, the validator can hold all the logic about storage types.
        long additionalDiskSpaceInGB = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        DiskImage dummyForValidation = DiskImage.copyOf(newDiskImage);
        dummyForValidation.setSizeInGigabytes(additionalDiskSpaceInGB);
        return validate(storageDomainValidator.hasSpaceForNewDisk(dummyForValidation));
    }
    return true;
}
#method_after
protected boolean validateCanResizeDisk() {
    DiskImage newDiskImage = (DiskImage) getNewDisk();
    DiskImage oldDiskImage = (DiskImage) getOldDisk();
    if (newDiskImage.getSize() != oldDiskImage.getSize()) {
        if (Boolean.TRUE.equals(getVmDeviceForVm().getIsReadOnly())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
        }
        if (vmDeviceForVm.getSnapshotId() != null) {
            DiskImage snapshotDisk = getDiskImageDao().getDiskSnapshotForVmSnapshot(getParameters().getDiskId(), vmDeviceForVm.getSnapshotId());
            if (snapshotDisk.getSize() != newDiskImage.getSize()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_DISK_SNAPSHOT);
            }
        }
        if (oldDiskImage.getSize() > newDiskImage.getSize()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_REQUESTED_DISK_SIZE_IS_TOO_SMALL);
        }
        for (VM vm : getVmsDiskPluggedTo()) {
            if (!VdcActionUtils.canExecute(Collections.singletonList(vm), VM.class, VdcActionType.ExtendImageSize)) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
            }
        }
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator((DiskImage) getNewDisk());
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
        // For size allocation validation, we'll create a dummy with the additional size required.
        // That way, the validator can hold all the logic about storage types.
        long additionalDiskSpaceInGB = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        DiskImage dummyForValidation = DiskImage.copyOf(newDiskImage);
        dummyForValidation.setSizeInGigabytes(additionalDiskSpaceInGB);
        return validate(storageDomainValidator.hasSpaceForNewDisk(dummyForValidation));
    }
    return true;
}
#end_block

#method_before
private boolean shouldPerformMetadataUpdate() {
    return ((getNewDisk().getDiskStorageType() == DiskStorageType.IMAGE) && (!Objects.equals(getOldDisk().getDiskAlias(), getNewDisk().getDiskAlias()) || !Objects.equals(getOldDisk().getDiskDescription(), getNewDisk().getDiskDescription())));
}
#method_after
private boolean shouldPerformMetadataUpdate() {
    return (getNewDisk().getDiskStorageType() == DiskStorageType.IMAGE) && (!Objects.equals(getOldDisk().getDiskAlias(), getNewDisk().getDiskAlias()) || !Objects.equals(getOldDisk().getDiskDescription(), getNewDisk().getDiskDescription()));
}
#end_block

#method_before
private VdcActionParametersBase buildExtendCinderDiskParameters(CinderDisk newCinderDisk) {
    UpdateVmDiskParameters parameters = new UpdateVmDiskParameters(getVmId(), newCinderDisk.getId(), newCinderDisk);
    parameters.setParametersCurrentUser(getParameters().getParametersCurrentUser());
    return parameters;
}
#method_after
private VdcActionParametersBase buildExtendCinderDiskParameters(CinderDisk newCinderDisk) {
    UpdateVmDiskParameters parameters = new UpdateVmDiskParameters(getVmId(), newCinderDisk.getId(), newCinderDisk);
    parameters.setParametersCurrentUser(getParameters().getParametersCurrentUser());
    parameters.setShouldBeEndedByParent(false);
    return parameters;
}
#end_block

#method_before
private ValidationResult noVmsContainBootableDisks(List<VM> vms) {
    List<String> vmsWithBoot = new ArrayList<>(vms.size());
    for (VM vm : vms) {
        Disk bootDisk = getDiskDao().getVmBootActiveDisk(vm.getId());
        if (bootDisk != null) {
            vmsWithBoot.add(vm.getName());
        }
    }
    if (!vmsWithBoot.isEmpty()) {
        addCanDoActionMessageVariable("VmsName", StringUtils.join(vmsWithBoot.toArray(), ", "));
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VMS_BOOT_IN_USE);
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult noVmsContainBootableDisks(List<VM> vms) {
    List<String> vmsWithBoot = new ArrayList<>(vms.size());
    for (VM vm : vms) {
        Disk bootDisk = getDiskDao().getVmBootActiveDisk(vm.getId());
        if (bootDisk != null) {
            vmsWithBoot.add(vm.getName());
        }
    }
    if (!vmsWithBoot.isEmpty()) {
        addValidationMessageVariable("VmsName", StringUtils.join(vmsWithBoot.toArray(), ", "));
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VMS_BOOT_IN_USE);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private void lockImageInDb() {
    final DiskImage diskImage = (DiskImage) getOldDisk();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntityStatus(diskImage.getImage());
            getCompensationContext().stateChanged();
            diskImage.setImageStatus(ImageStatus.LOCKED);
            ImagesHandler.updateImageStatus(diskImage.getImageId(), ImageStatus.LOCKED);
            return null;
        }
    });
}
#method_after
private void lockImageInDb() {
    final DiskImage diskImage = (DiskImage) getOldDisk();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntityStatus(diskImage.getImage());
        getCompensationContext().stateChanged();
        diskImage.setImageStatus(ImageStatus.LOCKED);
        ImagesHandler.updateImageStatus(diskImage.getImageId(), ImageStatus.LOCKED);
        return null;
    });
}
#end_block

#method_before
private void propagateInternalCommandFailure(VdcReturnValueBase internalReturnValue) {
    getReturnValue().getExecuteFailedMessages().clear();
    getReturnValue().getExecuteFailedMessages().addAll(internalReturnValue.getExecuteFailedMessages());
    getReturnValue().setFault(internalReturnValue.getFault());
    getReturnValue().getCanDoActionMessages().clear();
    getReturnValue().getCanDoActionMessages().addAll(internalReturnValue.getCanDoActionMessages());
    getReturnValue().setCanDoAction(internalReturnValue.getCanDoAction());
}
#method_after
private void propagateInternalCommandFailure(VdcReturnValueBase internalReturnValue) {
    getReturnValue().getExecuteFailedMessages().clear();
    getReturnValue().getExecuteFailedMessages().addAll(internalReturnValue.getExecuteFailedMessages());
    getReturnValue().setFault(internalReturnValue.getFault());
    getReturnValue().getValidationMessages().clear();
    getReturnValue().getValidationMessages().addAll(internalReturnValue.getValidationMessages());
    getReturnValue().setValid(internalReturnValue.isValid());
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmInitEnabled().setEntity(getVm().getVmInit() != null);
    getModel().getVmInitModel().init(getVm().getStaticData());
    getModel().getVmType().setIsChangeable(true);
    getModel().getIsSoundcardEnabled().setIsChangeable(true);
    getModel().getInstanceTypes().setIsChangeable(!vm.isRunning());
    getModel().getVmId().setIsAvailable(true);
    getModel().getVmId().setIsChangeable(false);
    loadDataCenter();
    instanceTypeManager = new ExistingVmInstanceTypeManager(getModel(), vm);
    if (vm.getVmPoolId() != null) {
        instanceTypeManager.setAlwaysEnabledFieldUpdate(true);
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVmNumaNodesByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VmNumaNode> nodes = (List<VmNumaNode>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            ExistingVmModelBehavior.this.getModel().setVmNumaNodes(nodes);
            ExistingVmModelBehavior.this.getModel().updateNodeCount(nodes.size());
        }
    }));
    // load dedicated host names into host names list
    if (getVm().getDedicatedVmForVdsList().size() > 0) {
        Frontend.getInstance().runQuery(VdcQueryType.GetAllHostNamesPinnedToVmById, new IdQueryParameters(vm.getId()), new AsyncQuery(new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                setDedicatedHostsNames((List<String>) ((VdcQueryReturnValue) returnValue).getReturnValue());
            }
        }));
    }
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmInitEnabled().setEntity(getVm().getVmInit() != null);
    getModel().getVmInitModel().init(getVm().getStaticData());
    getModel().getVmType().setIsChangeable(true);
    getModel().getIsSoundcardEnabled().setIsChangeable(true);
    getModel().getInstanceTypes().setIsChangeable(!vm.isRunning());
    getModel().getVmId().setIsAvailable(true);
    getModel().getVmId().setIsChangeable(false);
    loadDataCenter();
    instanceTypeManager = new ExistingVmInstanceTypeManager(getModel(), vm);
    if (vm.getVmPoolId() != null) {
        instanceTypeManager.setAlwaysEnabledFieldUpdate(true);
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVmNumaNodesByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VmNumaNode> nodes = ((VdcQueryReturnValue) returnValue).getReturnValue();
            ExistingVmModelBehavior.this.getModel().setVmNumaNodes(nodes);
            ExistingVmModelBehavior.this.getModel().updateNodeCount(nodes.size());
        }
    }));
    // load dedicated host names into host names list
    if (getVm().getDedicatedVmForVdsList().size() > 0) {
        Frontend.getInstance().runQuery(VdcQueryType.GetAllHostNamesPinnedToVmById, new IdQueryParameters(vm.getId()), new AsyncQuery(new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                setDedicatedHostsNames((List<String>) ((VdcQueryReturnValue) returnValue).getReturnValue());
            }
        }));
    }
}
#end_block

#method_before
private void loadDataCenter() {
    // Preinitialize the VM compatibility version because it's needed during init
    Version newCustomCompatibilityVersion = ((ExistingVmModelBehavior) getModel().getBehavior()).getVm().getStaticData().getCustomCompatibilityVersion();
    if (newCustomCompatibilityVersion != null) {
        getModel().getCustomCompatibilityVersion().setItems(Collections.singletonList(newCustomCompatibilityVersion), newCustomCompatibilityVersion);
    }
    AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            if (returnValue != null) {
                StoragePool dataCenter = (StoragePool) returnValue;
                final List<StoragePool> dataCenters = new ArrayList<>(Arrays.asList(new StoragePool[] { dataCenter }));
                initClusters(dataCenters);
            } else {
                ExistingVmModelBehavior behavior = (ExistingVmModelBehavior) model.getBehavior();
                VM currentVm = behavior.vm;
                VDSGroup tempVar = new VDSGroup();
                tempVar.setId(currentVm.getVdsGroupId());
                tempVar.setName(currentVm.getVdsGroupName());
                tempVar.setCompatibilityVersion(currentVm.getVdsGroupCompatibilityVersion());
                tempVar.setStoragePoolId(currentVm.getStoragePoolId());
                VDSGroup cluster = tempVar;
                DataCenterWithCluster dataCenterWithCluster = new DataCenterWithCluster(null, cluster);
                model.getDataCenterWithClustersList().setItems(Arrays.asList(dataCenterWithCluster));
                model.getDataCenterWithClustersList().setSelectedItem(dataCenterWithCluster);
                behavior.initTemplate();
                behavior.initCdImage();
            }
        }
    }), vm.getStoragePoolId());
}
#method_after
private void loadDataCenter() {
    // Preinitialize the VM compatibility version because it's needed during init
    Version newCustomCompatibilityVersion = ((ExistingVmModelBehavior) getModel().getBehavior()).getVm().getStaticData().getCustomCompatibilityVersion();
    if (newCustomCompatibilityVersion != null) {
        getModel().getCustomCompatibilityVersion().setItems(Collections.singletonList(newCustomCompatibilityVersion), newCustomCompatibilityVersion);
    }
    AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            if (returnValue != null) {
                StoragePool dataCenter = (StoragePool) returnValue;
                final List<StoragePool> dataCenters = new ArrayList<>(Arrays.asList(new StoragePool[] { dataCenter }));
                initClusters(dataCenters);
            } else {
                ExistingVmModelBehavior behavior = (ExistingVmModelBehavior) model.getBehavior();
                VM currentVm = behavior.vm;
                Cluster cluster = new Cluster();
                cluster.setId(currentVm.getClusterId());
                cluster.setName(currentVm.getClusterName());
                cluster.setCompatibilityVersion(currentVm.getClusterCompatibilityVersion());
                cluster.setStoragePoolId(currentVm.getStoragePoolId());
                DataCenterWithCluster dataCenterWithCluster = new DataCenterWithCluster(null, cluster);
                model.getDataCenterWithClustersList().setItems(Arrays.asList(dataCenterWithCluster));
                model.getDataCenterWithClustersList().setSelectedItem(dataCenterWithCluster);
                behavior.initTemplate();
                behavior.initCdImage();
            }
        }
    }), vm.getStoragePoolId());
}
#end_block

#method_before
protected void initClusters(final List<StoragePool> dataCenters) {
    AsyncDataProvider.getInstance().getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
            List<VDSGroup> filteredClusters = AsyncDataProvider.getInstance().filterByArchitecture(clusters, vm.getClusterArch());
            model.setDataCentersAndClusters(model, dataCenters, filteredClusters, vm.getVdsGroupId());
            updateCompatibilityVersion();
            initTemplate();
            initCdImage();
        }
    }), true, false);
}
#method_after
protected void initClusters(final List<StoragePool> dataCenters) {
    AsyncDataProvider.getInstance().getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            List<Cluster> clusters = (List<Cluster>) returnValue;
            List<Cluster> filteredClusters = AsyncDataProvider.getInstance().filterByArchitecture(clusters, vm.getClusterArch());
            model.setDataCentersAndClusters(model, dataCenters, filteredClusters, vm.getClusterId());
            updateCompatibilityVersion();
            initTemplate();
            initCdImage();
        }
    }), true, false);
}
#end_block

#method_before
@Override
public void templateWithVersion_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    buildModel(vm.getStaticData(), new BuilderExecutor.BuilderExecutionFinished<VmBase, UnitVmModel>() {

        @Override
        public void finished(VmBase source, UnitVmModel destination) {
            getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
            updateCpuSharesSelection();
            updateRngDevice(getVm().getId());
            updateTimeZone(vm.getTimeZone());
            updateGraphics();
            getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
            // Storage domain and provisioning are not available for an existing VM.
            getModel().getStorageDomain().setIsChangeable(false);
            getModel().getProvisioning().setIsAvailable(false);
            getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
            getModel().getCpuPinning().setEntity(vm.getCpuPinning());
            getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
            if (isHotSetCpuSupported()) {
                // cancel related events while fetching data
                getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
                getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
                getModel().getThreadsPerCore().getSelectedItemChangedEvent().removeListener(getModel());
                getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
                AsyncDataProvider.getInstance().getHostById(new AsyncQuery(new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        runningOnHost = (VDS) returnValue;
                        hostCpu = calculateHostCpus();
                        updateNumOfSockets();
                    }
                }), vm.getRunOnVds());
            }
            updateCpuProfile(vm.getVdsGroupId(), vm.getVdsGroupCompatibilityVersion(), vm.getCpuProfileId());
        }
    });
}
#method_after
@Override
public void templateWithVersion_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    buildModel(vm.getStaticData(), new BuilderExecutor.BuilderExecutionFinished<VmBase, UnitVmModel>() {

        @Override
        public void finished(VmBase source, UnitVmModel destination) {
            getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
            updateCpuSharesSelection();
            updateRngDevice(getVm().getId());
            updateTimeZone(vm.getTimeZone());
            updateGraphics();
            getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
            // Storage domain and provisioning are not available for an existing VM.
            getModel().getStorageDomain().setIsChangeable(false);
            getModel().getProvisioning().setIsAvailable(false);
            getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
            getModel().getCpuPinning().setEntity(vm.getCpuPinning());
            getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
            if (isHotSetCpuSupported()) {
                // cancel related events while fetching data
                getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
                getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
                getModel().getThreadsPerCore().getSelectedItemChangedEvent().removeListener(getModel());
                getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
                AsyncDataProvider.getInstance().getHostById(new AsyncQuery(new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        runningOnHost = (VDS) returnValue;
                        hostCpu = calculateHostCpus();
                        updateNumOfSockets();
                    }
                }), vm.getRunOnVds());
            }
            updateCpuProfile(vm.getClusterId(), vm.getCompatibilityVersion(), vm.getCpuProfileId());
        }
    });
}
#end_block

#method_before
private void updateInstanceImages() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<InstanceImageLineModel> imageLineModels = new ArrayList<>();
            for (Disk disk : ((ArrayList<Disk>) returnValue)) {
                InstanceImageLineModel lineModel = new InstanceImageLineModel(getModel().getInstanceImages());
                lineModel.initialize(disk, getVm());
                imageLineModels.add(lineModel);
            }
            getModel().getInstanceImages().setItems(imageLineModels);
            getModel().getInstanceImages().setVm(getVm());
        }
    }), getVm().getId());
}
#method_after
private void updateInstanceImages() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<InstanceImageLineModel> imageLineModels = new ArrayList<>();
            for (Disk disk : (ArrayList<Disk>) returnValue) {
                InstanceImageLineModel lineModel = new InstanceImageLineModel(getModel().getInstanceImages());
                lineModel.initialize(disk, getVm());
                imageLineModels.add(lineModel);
            }
            getModel().getInstanceImages().setItems(imageLineModels);
            getModel().getInstanceImages().setVm(getVm());
        }
    }), getVm().getId());
}
#end_block

#method_before
@Override
public void updateMinAllocatedMemory() {
    if (getModel().getMinAllocatedMemory().getEntity() != null && getVm().getMemSizeMb() == getModel().getMinAllocatedMemory().getEntity()) {
        // it was the same => keep it the same
        getModel().getMinAllocatedMemory().setEntity(getModel().getMemSize().getEntity());
    } else {
        DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
        if (dataCenterWithCluster == null) {
            return;
        }
        VDSGroup cluster = dataCenterWithCluster.getCluster();
        if (cluster == null) {
            return;
        }
        if (getModel().getMemSize().getEntity() < vm.getVmMemSizeMb()) {
            double overCommitFactor = 100.0 / cluster.getMaxVdsMemoryOverCommit();
            getModel().getMinAllocatedMemory().setEntity((int) (getModel().getMemSize().getEntity() * overCommitFactor));
        } else {
            getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
        }
    }
}
#method_after
@Override
public void updateMinAllocatedMemory() {
    if (getModel().getMemSize().getEntity() == null) {
        return;
    }
    Cluster cluster = getModel().getSelectedCluster();
    if (cluster == null) {
        return;
    }
    double overCommitFactor = 100.0 / cluster.getMaxVdsMemoryOverCommit();
    getModel().getMinAllocatedMemory().setEntity((int) (getModel().getMemSize().getEntity() * overCommitFactor));
}
#end_block

#method_before
public boolean isHotSetCpuSupported() {
    VDSGroup selectedCluster = getModel().getSelectedCluster();
    Version compatibilityVersion = getModel().getCompatibilityVersion();
    Boolean hotplugEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HotPlugEnabled, compatibilityVersion.getValue());
    boolean hotplugCpuSupported = Boolean.parseBoolean(((Map<String, String>) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HotPlugCpuSupported, compatibilityVersion.getValue())).get(selectedCluster.getArchitecture().name()));
    return getVm().getStatus() == VMStatus.Up && hotplugEnabled && hotplugCpuSupported;
}
#method_after
public boolean isHotSetCpuSupported() {
    Cluster selectedCluster = getModel().getSelectedCluster();
    Version compatibilityVersion = getModel().getCompatibilityVersion();
    Boolean hotplugEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HotPlugEnabled, compatibilityVersion.getValue());
    boolean hotplugCpuSupported = Boolean.parseBoolean(((Map<String, String>) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HotPlugCpuSupported, compatibilityVersion.getValue())).get(selectedCluster.getArchitecture().name()));
    return getVm().getStatus() == VMStatus.Up && hotplugEnabled && hotplugCpuSupported;
}
#end_block

#method_before
@Override
public void startMonitoring() {
    allVmStatsOnlyRefresher.startMonitoring();
    final String hostname = vdsManager.getVdsHostname();
    resourceManager.subscribe(new EventSubscriber(hostname + "|*|VM_status|*") {

        @Override
        public void onSubscribe(Subscription sub) {
            subscription = sub;
            subscription.request(1);
        }

        @Override
        public void onNext(Map<String, Object> map) {
            try {
                printEventInDebug(map);
                List<Pair<VM, VmInternalData>> changedVms = new ArrayList<>();
                VmDevicesMonitoring.Change deviceChange = VmDevicesMonitoring.getInstance().createChange(vdsManager.getVdsId());
                convertEvent(changedVms, deviceChange, map);
                deviceChange.flush();
                if (!changedVms.isEmpty()) {
                    getVmsMonitoring(changedVms).perform();
                }
            } finally {
                subscription.request(1);
            }
        }

        private void printEventInDebug(Map<String, Object> map) {
            if (!log.isDebugEnabled()) {
                return;
            }
            StringBuilder sb = new StringBuilder();
            XmlRpcObjectDescriptor.toStringBuilder(map, sb);
            log.debug("processing event for host {} data:\n{}", vdsManager.getVdsName(), sb);
        }

        private VmsMonitoring getVmsMonitoring(List<Pair<VM, VmInternalData>> changedVms) {
            return new VmsMonitoring(vdsManager, changedVms, auditLogDirector, System.nanoTime());
        }

        @SuppressWarnings("unchecked")
        private void convertEvent(List<Pair<VM, VmInternalData>> changedVms, VmDevicesMonitoring.Change deviceChange, Map<String, Object> map) {
            Double notifyTime = VdsBrokerObjectsBuilder.removeNotifyTimeFromVmStatusEvent(map);
            for (Map.Entry<String, Object> entry : map.entrySet()) {
                Guid vmid = new Guid(entry.getKey());
                VM dbVm = dbFacade.getVmDao().get(vmid);
                VmInternalData vdsmVm;
                if (dbVm == null) {
                    vdsmVm = createVmInternalData(vmid, (Map<String, Object>) map.get(vmid.toString()), notifyTime);
                } else {
                    vdsmVm = createVmInternalData(dbVm, (Map<String, Object>) map.get(vmid.toString()), notifyTime);
                    // if dbVm runs on different host, monitoring expect it to be null
                    if (!vdsManager.getVdsId().equals(dbVm.getRunOnVds())) {
                        dbVm = null;
                    }
                }
                changedVms.add(new Pair<>(dbVm, vdsmVm));
                // VmDevicesMonitoring may be injected if this class is converted to a managed bean. Currently the injection
                // here is not performed by container and creates circular dependency during ResourceManager initialization.
                deviceChange.updateVmIfChanged(vdsmVm.getVmDynamic().getId(), vdsmVm.getVmDynamic().getHash());
            }
        }

        private VmInternalData createVmInternalData(Guid vmId, Map<String, Object> xmlRpcStruct, Double notifyTime) {
            VM fakeVm = new VM();
            fakeVm.setId(vmId);
            return createVmInternalData(fakeVm, xmlRpcStruct, notifyTime);
        }

        private VmInternalData createVmInternalData(VM dbVm, Map<String, Object> xmlRpcStruct, Double notifyTime) {
            // send a clone of vm dynamic to be overridden with new data
            VmDynamic clonedVmDynamic = new VmDynamic(dbVm.getDynamicData());
            VdsBrokerObjectsBuilder.updateVMDynamicData(clonedVmDynamic, xmlRpcStruct, vdsManager.getCopyVds());
            return new VmInternalData(clonedVmDynamic, dbVm.getStatisticsData(), notifyTime);
        }

        @Override
        public void onError(Throwable t) {
            // communication issue is delivered as a message so we need to request for more
            subscription.request(1);
        }

        @Override
        public void onComplete() {
        }
    });
}
#method_after
@Override
public void startMonitoring() {
    allVmStatsOnlyRefresher.startMonitoring();
    final String hostname = vdsManager.getVdsHostname();
    resourceManager.subscribe(new EventSubscriber(hostname + "|*|VM_status|*") {

        @Override
        public void onSubscribe(Subscription sub) {
            subscription = sub;
            subscription.request(1);
        }

        @Override
        public void onNext(Map<String, Object> map) {
            try {
                printEventInDebug(map);
                List<Pair<VM, VmInternalData>> changedVms = new ArrayList<>();
                convertEvent(changedVms, map);
                if (!changedVms.isEmpty()) {
                    getVmsMonitoring(changedVms).perform();
                    processDevices(changedVms.stream().map(pair -> pair.getSecond().getVmDynamic()), System.nanoTime());
                }
            } finally {
                subscription.request(1);
            }
        }

        private void printEventInDebug(Map<String, Object> map) {
            if (!log.isDebugEnabled()) {
                return;
            }
            StringBuilder sb = new StringBuilder();
            XmlRpcObjectDescriptor.toStringBuilder(map, sb);
            log.debug("processing event for host {} data:\n{}", vdsManager.getVdsName(), sb);
        }

        private VmsMonitoring getVmsMonitoring(List<Pair<VM, VmInternalData>> changedVms) {
            return new VmsMonitoring(vdsManager, changedVms, auditLogDirector, System.nanoTime());
        }

        @SuppressWarnings("unchecked")
        private void convertEvent(List<Pair<VM, VmInternalData>> changedVms, Map<String, Object> map) {
            Double notifyTime = VdsBrokerObjectsBuilder.removeNotifyTimeFromVmStatusEvent(map);
            for (Map.Entry<String, Object> entry : map.entrySet()) {
                Guid vmid = new Guid(entry.getKey());
                VM dbVm = dbFacade.getVmDao().get(vmid);
                VmInternalData vdsmVm;
                if (dbVm == null) {
                    vdsmVm = createVmInternalData(vmid, (Map<String, Object>) map.get(vmid.toString()), notifyTime);
                } else {
                    vdsmVm = createVmInternalData(dbVm, (Map<String, Object>) map.get(vmid.toString()), notifyTime);
                    // if dbVm runs on different host, monitoring expect it to be null
                    if (!vdsManager.getVdsId().equals(dbVm.getRunOnVds())) {
                        dbVm = null;
                    }
                }
                changedVms.add(new Pair<>(dbVm, vdsmVm));
            }
        }

        private VmInternalData createVmInternalData(Guid vmId, Map<String, Object> xmlRpcStruct, Double notifyTime) {
            VM fakeVm = new VM();
            fakeVm.setId(vmId);
            return createVmInternalData(fakeVm, xmlRpcStruct, notifyTime);
        }

        private VmInternalData createVmInternalData(VM dbVm, Map<String, Object> xmlRpcStruct, Double notifyTime) {
            // send a clone of vm dynamic to be overridden with new data
            VmDynamic clonedVmDynamic = new VmDynamic(dbVm.getDynamicData());
            VdsBrokerObjectsBuilder.updateVMDynamicData(clonedVmDynamic, xmlRpcStruct, vdsManager.getCopyVds());
            return new VmInternalData(clonedVmDynamic, dbVm.getStatisticsData(), notifyTime);
        }

        @Override
        public void onError(Throwable t) {
            // communication issue is delivered as a message so we need to request for more
            subscription.request(1);
        }

        @Override
        public void onComplete() {
        }
    });
}
#end_block

#method_before
private void initAttestation() {
    List<VDSGroup> vdsGroups = dbFacade.getVdsGroupDao().getTrustedClusters();
    List<VDS> trustedVdsList = new ArrayList<>();
    List<String> trustedVdsNames = new ArrayList<>();
    if (vdsGroups == null || vdsGroups.size() == 0) {
        return;
    }
    for (VDSGroup vdsGroup : vdsGroups) {
        List<VDS> vdssInGroup = dbFacade.getVdsDao().getAllForVdsGroupWithStatus(vdsGroup.getId(), VDSStatus.Up);
        if (vdssInGroup != null) {
            trustedVdsList.addAll(vdssInGroup);
        }
    }
    for (VDS vds : trustedVdsList) {
        trustedVdsNames.add(vds.getHostName());
        setNonOperational(NonOperationalReason.UNINITIALIZED, vds);
    }
    try {
        AttestThread attestThread = new AttestThread(trustedVdsNames);
        // start a thread to attest the hosts
        attestThread.start();
    } catch (Exception e) {
        log.error("Failed to initialize attestation cache", e);
    }
}
#method_after
private void initAttestation() {
    List<Cluster> clusters = dbFacade.getClusterDao().getTrustedClusters();
    List<VDS> trustedVdsList = new ArrayList<>();
    List<String> trustedVdsNames = new ArrayList<>();
    if (clusters == null || clusters.size() == 0) {
        return;
    }
    for (Cluster cluster : clusters) {
        List<VDS> hostsInCluster = dbFacade.getVdsDao().getAllForClusterWithStatus(cluster.getId(), VDSStatus.Up);
        if (hostsInCluster != null) {
            trustedVdsList.addAll(hostsInCluster);
        }
    }
    for (VDS vds : trustedVdsList) {
        trustedVdsNames.add(vds.getHostName());
        setNonOperational(NonOperationalReason.UNINITIALIZED, vds);
    }
    try {
        AttestThread attestThread = new AttestThread(trustedVdsNames);
        // start a thread to attest the hosts
        attestThread.start();
    } catch (Exception e) {
        log.error("Failed to initialize attestation cache", e);
    }
}
#end_block

#method_before
private VdcReturnValueBase notAllowToRunAction(VdcActionType actionType) {
    // Since reload of configuration values is not fully supported, we have to get this value from DB
    // and can not use the cached configuration.
    String mode = (dbFacade.getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion)).getOptionValue();
    if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
        return getErrorCommandReturnValue(EngineMessage.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
    } else if (EngineWorkingMode.PREPARE.name().equalsIgnoreCase(mode)) {
        return notAllowedInPrepForMaintMode(actionType);
    }
    return null;
}
#method_after
private VdcReturnValueBase notAllowToRunAction(VdcActionType actionType) {
    // Since reload of configuration values is not fully supported, we have to get this value from DB
    // and can not use the cached configuration.
    String mode = dbFacade.getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion).getOptionValue();
    if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
        return getErrorCommandReturnValue(EngineMessage.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
    } else if (EngineWorkingMode.PREPARE.name().equalsIgnoreCase(mode)) {
        return notAllowedInPrepForMaintMode(actionType);
    }
    return null;
}
#end_block

#method_before
private boolean isActionExternal(VdcActionType actionType) {
    return (actionType == VdcActionType.EndExternalJob || actionType == VdcActionType.EndExternalStep || actionType == VdcActionType.ClearExternalJob);
}
#method_after
private boolean isActionExternal(VdcActionType actionType) {
    return actionType == VdcActionType.EndExternalJob || actionType == VdcActionType.EndExternalStep || actionType == VdcActionType.ClearExternalJob;
}
#end_block

#method_before
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck, EngineContext engineContext) {
    if (isPerformUserCheck) {
        String sessionId = parameters.getSessionId();
        if (StringUtils.isEmpty(sessionId) || sessionDataContainer.getUser(sessionId, parameters.getRefresh()) == null) {
            return getErrorQueryReturnValue(EngineMessage.USER_IS_NOT_LOGGED_IN);
        }
    }
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = CommandsFactory.getQueryClass(actionType.name());
    if (clazz.isAnnotationPresent(DisableInMaintenanceMode.class)) {
        String mode = (dbFacade.getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion)).getOptionValue();
        if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
            return getErrorQueryReturnValue(EngineMessage.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters, engineContext);
    command.setInternalExecution(!isPerformUserCheck);
    command.execute();
    return command.getQueryReturnValue();
}
#method_after
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck, EngineContext engineContext) {
    if (isPerformUserCheck) {
        String sessionId = parameters.getSessionId();
        if (StringUtils.isEmpty(sessionId) || sessionDataContainer.getUser(sessionId, parameters.getRefresh()) == null) {
            return getErrorQueryReturnValue(EngineMessage.USER_IS_NOT_LOGGED_IN);
        }
    }
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = CommandsFactory.getQueryClass(actionType.name());
    if (clazz.isAnnotationPresent(DisableInMaintenanceMode.class)) {
        String mode = dbFacade.getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion).getOptionValue();
        if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
            return getErrorQueryReturnValue(EngineMessage.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters, engineContext);
    command.setInternalExecution(!isPerformUserCheck);
    command.execute();
    return command.getQueryReturnValue();
}
#end_block

#method_before
public void updateVm(Guid vmId) {
    vmsToUpdate.add(vmId.toString());
}
#method_after
public void updateVm(Guid vmId, String vdsmHash) {
    if (!VmDeviceCommonUtils.isOldClusterVersion(getGroupCompatibilityVersion(vdsId)) && isVmDevicesChanged(vmId, vdsmHash, fetchTime)) {
        lockTouchedVm(vmId);
        vmsToUpdate.add(vmId);
    }
}
#end_block

#method_before
public void updateDevice(VmDevice device) {
    updatedDevices.add(device);
}
#method_after
public void updateDevice(VmDevice device) {
    if (isVmDeviceChanged(device.getId(), fetchTime)) {
        lockTouchedVm(device.getVmId());
        devicesToUpdate.add(device);
    }
}
#end_block

#method_before
public void removeDevice(VmDeviceId deviceId) {
    removedDeviceIds.add(deviceId);
}
#method_after
public void removeDevice(VmDeviceId deviceId) {
    if (isVmDeviceChanged(deviceId, fetchTime)) {
        lockTouchedVm(deviceId.getVmId());
        removedDeviceIds.add(deviceId);
    }
}
#end_block

#method_before
public void flush() {
    VmDevicesMonitoring.this.flush(this);
}
#method_after
public void flush() {
    Map<String, Object>[] vmInfos = getVmInfo(vdsId, vmsToUpdate);
    if (vmInfos != null) {
        for (Map<String, Object> vmInfo : vmInfos) {
            processFullList(vmInfo);
        }
    }
    for (VmDevice deviceToUpdate : devicesToUpdate) {
        processDeviceUpdate(this, deviceToUpdate);
    }
    saveDevicesToDb(this);
    unlockTouchedVms();
}
#end_block

#method_before
@PostConstruct
private void init() {
    instance = this;
}
#method_after
@PostConstruct
private void init() {
    instance = this;
    long fetchTime = System.nanoTime();
    getVmDynamicDao().getAllDevicesHashes().forEach(pair -> vmDevicesStatuses.put(pair.getFirst(), new DevicesStatus(pair.getSecond(), fetchTime)));
}
#end_block

#method_before
public Change createChange(Guid vdsId) {
    return new Change(vdsId);
}
#method_after
public Change createChange(long fetchTime) {
    return new Change(fetchTime);
}
#end_block

#method_before
private boolean isVmDevicesChanged(Guid vmId, String vdsmHash) {
    if (vdsmHash != null) {
        String dbHash = vmDevicesHash.put(vmId, vdsmHash);
        return !Objects.equals(dbHash, vdsmHash);
    } else {
        return false;
    }
}
#method_after
private boolean isVmDevicesChanged(Guid vmId, String vdsmHash, long fetchTime) {
    if (vdsmHash == null) {
        return false;
    }
    // This operation is atomic
    synchronized (devicesStatusesLock) {
        DevicesStatus previousStatus = vmDevicesStatuses.get(vmId);
        boolean previousHashUpdate = previousStatus != null && UPDATE_HASH.equals(previousStatus.getHash());
        if (previousStatus == null || previousHashUpdate || fetchTimeBefore(previousStatus.getFetchTime(), fetchTime)) {
            vmDevicesStatuses.put(vmId, new DevicesStatus(vdsmHash, fetchTime));
            return previousStatus == null || !previousHashUpdate && !Objects.equals(previousStatus.getHash(), vdsmHash);
        } else {
            return false;
        }
    }
}
#end_block

#method_before
private Map<String, Object>[] getVmInfo(Change change) {
    if (change.vdsId == null || change.vmsToUpdate.isEmpty()) {
        return null;
    }
    Map<String, Object>[] result = new Map[0];
    // TODO refactor commands to use vdsId only - the whole vds object here is useless
    VDS vds = new VDS();
    vds.setId(change.vdsId);
    VDSReturnValue vdsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.FullList, new FullListVDSCommandParameters(vds, change.vmsToUpdate));
    if (vdsReturnValue.getSucceeded()) {
        result = (Map<String, Object>[]) (vdsReturnValue.getReturnValue());
    }
    return result;
}
#method_after
private Map<String, Object>[] getVmInfo(Guid vdsId, List<Guid> vms) {
    if (vdsId == null || vms.isEmpty()) {
        return null;
    }
    Map<String, Object>[] result = new Map[0];
    // TODO refactor commands to use vdsId only - the whole vds object here is useless
    VDS vds = new VDS();
    vds.setId(vdsId);
    List<String> vmIds = vms.stream().map(guid -> guid.toString()).collect(Collectors.toList());
    VDSReturnValue vdsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.FullList, new FullListVDSCommandParameters(vds, vmIds));
    if (vdsReturnValue.getSucceeded()) {
        result = (Map<String, Object>[]) vdsReturnValue.getReturnValue();
    }
    return result;
}
#end_block

#method_before
private void processVmDevices(Change change, Map<String, Object> vm) {
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    Set<Guid> processedDeviceIds = new HashSet<>();
    List<VmDevice> dbDevices = getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> dbDeviceMap = Entities.businessEntitiesById(dbDevices);
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map<String, Object> vdsmDevice = (Map<String, Object>) o;
        if (vdsmDevice.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, vdsmDevice);
            continue;
        }
        Guid deviceId = getDeviceId(vdsmDevice);
        VmDevice dbDevice = dbDeviceMap.get(new VmDeviceId(deviceId, vmId));
        String logicalName = getDeviceLogicalName(change.vdsId, vm, vdsmDevice);
        if (deviceId == null || dbDevice == null) {
            VmDevice newDevice = buildNewVmDevice(vmId, vdsmDevice, logicalName);
            change.addDevice(newDevice);
            deviceId = newDevice.getDeviceId();
        } else {
            dbDevice.setIsPlugged(Boolean.TRUE);
            dbDevice.setAddress(vdsmDevice.get(VdsProperties.Address).toString());
            dbDevice.setAlias(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.Alias)));
            dbDevice.setLogicalName(logicalName);
            dbDevice.setHostDevice(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.HostDev)));
            change.updateDevice(dbDevice);
        }
        processedDeviceIds.add(deviceId);
    }
    handleRemovedDevices(change, vmId, processedDeviceIds, dbDevices);
}
#method_after
private void processVmDevices(Change change, Map<String, Object> vmInfo) {
    Guid vmId = getVmId(vmInfo);
    Set<Guid> processedDeviceIds = new HashSet<>();
    List<VmDevice> dbDevices = getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> dbDeviceMap = Entities.businessEntitiesById(dbDevices);
    for (Object o : (Object[]) vmInfo.get(VdsProperties.Devices)) {
        Map<String, Object> vdsmDevice = (Map<String, Object>) o;
        if (vdsmDevice.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, vdsmDevice);
            continue;
        }
        Guid deviceId = getDeviceId(vdsmDevice);
        VmDevice dbDevice = dbDeviceMap.get(new VmDeviceId(deviceId, vmId));
        String logicalName = getDeviceLogicalName(change.getVdsId(), vmInfo, vdsmDevice);
        if (deviceId == null || dbDevice == null) {
            VmDevice newDevice = buildNewVmDevice(vmId, vdsmDevice, logicalName);
            change.addedDevices.add(newDevice);
            deviceId = newDevice.getDeviceId();
        } else {
            dbDevice.setIsPlugged(Boolean.TRUE);
            dbDevice.setAddress(vdsmDevice.get(VdsProperties.Address).toString());
            dbDevice.setAlias(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.Alias)));
            dbDevice.setLogicalName(logicalName);
            dbDevice.setHostDevice(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.HostDev)));
            change.updatedDevices.add(dbDevice);
        }
        processedDeviceIds.add(deviceId);
    }
    handleRemovedDevices(change, vmId, processedDeviceIds, dbDevices);
}
#end_block

#method_before
private static Guid getDeviceId(Map<String, Object> device) {
    String deviceId = (String) device.get(VdsProperties.DeviceId);
    return deviceId == null ? null : new Guid(deviceId);
}
#method_after
private static Guid getDeviceId(Map<String, Object> deviceInfo) {
    String deviceId = (String) deviceInfo.get(VdsProperties.DeviceId);
    return deviceId == null ? null : new Guid(deviceId);
}
#end_block

#method_before
private String getDeviceLogicalName(Guid vdsId, Map<String, Object> vm, Map<String, Object> device) {
    Guid deviceId = getDeviceId(device);
    if (deviceId != null && FeatureSupported.reportedDisksLogicalNames(getGroupCompatibilityVersion(vdsId)) && VmDeviceType.DISK.getName().equals(device.get(VdsProperties.Device))) {
        try {
            return getDeviceLogicalName((Map<String, Object>) vm.get(VdsProperties.GuestDiskMapping), deviceId);
        } catch (Exception e) {
            log.error("error while getting device name when processing, vm '{}', device info '{}' with exception, skipping '{}'", vm.get(VdsProperties.vm_guid), device, e.getMessage());
            log.error("Exception", e);
        }
    }
    return null;
}
#method_after
private String getDeviceLogicalName(Guid vdsId, Map<String, Object> vmInfo, Map<String, Object> device) {
    Guid deviceId = getDeviceId(device);
    if (deviceId != null && FeatureSupported.reportedDisksLogicalNames(getGroupCompatibilityVersion(vdsId)) && VmDeviceType.DISK.getName().equals(device.get(VdsProperties.Device))) {
        try {
            return getDeviceLogicalName((Map<String, Object>) vmInfo.get(VdsProperties.GuestDiskMapping), deviceId);
        } catch (Exception e) {
            log.error("error while getting device name when processing, vm '{}', device info '{}' with exception, skipping '{}'", vmInfo.get(VdsProperties.vm_guid), device, e.getMessage());
            log.error("Exception", e);
        }
    }
    return null;
}
#end_block

#method_before
private String getDeviceLogicalName(Map<String, Object> diskMapping, Guid deviceId) {
    if (diskMapping == null) {
        return null;
    }
    Map<String, Object> deviceMapping = null;
    String modifiedDeviceId = deviceId.toString().substring(0, 20);
    for (Map.Entry<String, Object> entry : diskMapping.entrySet()) {
        String serial = entry.getKey();
        if (serial != null && serial.contains(modifiedDeviceId)) {
            deviceMapping = (Map<String, Object>) entry.getValue();
            break;
        }
    }
    return deviceMapping == null ? null : (String) deviceMapping.get(VdsProperties.Name);
}
#method_after
private static String getDeviceLogicalName(Map<String, Object> diskMapping, Guid deviceId) {
    if (diskMapping == null) {
        return null;
    }
    Map<String, Object> deviceMapping = null;
    String modifiedDeviceId = deviceId.toString().substring(0, 20);
    for (Map.Entry<String, Object> entry : diskMapping.entrySet()) {
        String serial = entry.getKey();
        if (serial != null && serial.contains(modifiedDeviceId)) {
            deviceMapping = (Map<String, Object>) entry.getValue();
            break;
        }
    }
    return deviceMapping == null ? null : (String) deviceMapping.get(VdsProperties.Name);
}
#end_block

#method_before
private void handleRemovedDevices(Change change, Guid vmId, Set<Guid> libvirtDevices, List<VmDevice> dbDevices) {
    for (VmDevice device : dbDevices) {
        if (libvirtDevices.contains(device.getDeviceId())) {
            continue;
        }
        if (deviceWithoutAddress(device)) {
            continue;
        }
        if (device.getIsManaged()) {
            if (device.getIsPlugged()) {
                device.setIsPlugged(Boolean.FALSE);
                device.setAddress("");
                change.updateDevice(device);
                log.debug("VM '{}' managed pluggable device was unplugged : '{}'", vmId, device);
            } else if (!devicePluggable(device)) {
                log.error("VM '{}' managed non pluggable device was removed unexpectedly from libvirt: '{}'", vmId, device);
            }
        } else {
            change.removeDevice(device.getId());
            log.debug("VM '{}' unmanaged device was marked for remove : {1}", vmId, device);
        }
    }
}
#method_after
private void handleRemovedDevices(Change change, Guid vmId, Set<Guid> libvirtDevices, List<VmDevice> dbDevices) {
    for (VmDevice device : dbDevices) {
        if (libvirtDevices.contains(device.getDeviceId())) {
            continue;
        }
        if (deviceWithoutAddress(device)) {
            continue;
        }
        if (device.getIsManaged()) {
            if (device.getIsPlugged()) {
                device.setIsPlugged(Boolean.FALSE);
                device.setAddress("");
                change.updatedDevices.add(device);
                log.debug("VM '{}' managed pluggable device was unplugged : '{}'", vmId, device);
            } else if (!devicePluggable(device)) {
                log.error("VM '{}' managed non pluggable device was removed unexpectedly from libvirt: '{}'", vmId, device);
            }
        } else {
            change.removedDeviceIds.add(device.getId());
            log.debug("VM '{}' unmanaged device was marked for remove : {1}", vmId, device);
        }
    }
}
#end_block

#method_before
private void saveDevicesToDb(Change change) {
    getVmDeviceDao().updateAllInBatch(change.updatedDevices);
    if (!change.removedDeviceIds.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDeviceDao().removeAll(change.removedDeviceIds);
            return null;
        });
    }
    if (!change.addedDevices.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDeviceDao().saveAll(change.addedDevices);
            return null;
        });
    }
}
#method_after
private void saveDevicesToDb(Change change) {
    getVmDeviceDao().updateAllInBatch(change.updatedDevices);
    if (!change.removedDeviceIds.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDeviceDao().removeAll(change.removedDeviceIds);
            return null;
        });
    }
    if (!change.addedDevices.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDeviceDao().saveAll(change.addedDevices);
            return null;
        });
    }
    if (!change.touchedVms.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDynamicDao().updateDevicesHashes(change.touchedVms.stream().map(vmId -> new Pair<>(vmId, vmDevicesStatuses.get(vmId).getHash())).collect(Collectors.toList()));
            return null;
        });
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("poll")
public void poll() {
    if (vdsManager.isMonitoringNeeded()) {
        VmsListFetcher fetcher = getVmsFetcher();
        long fetchTime = System.nanoTime();
        if (fetcher.fetch()) {
            processDevices(fetcher);
            getVmsMonitoring(fetcher, fetchTime).perform();
        } else {
            log.info("Failed to fetch vms info for host '{}' - skipping VMs monitoring.", vdsManager.getVdsName());
        }
    }
}
#method_after
@OnTimerMethodAnnotation("poll")
public void poll() {
    if (vdsManager.isMonitoringNeeded()) {
        VmsListFetcher fetcher = getVmsFetcher();
        long fetchTime = System.nanoTime();
        if (fetcher.fetch()) {
            getVmsMonitoring(fetcher, fetchTime).perform();
            processDevices(fetcher.getVdsmVms().stream().map(VmInternalData::getVmDynamic), fetchTime);
        } else {
            log.info("Failed to fetch vms info for host '{}' - skipping VMs monitoring.", vdsManager.getVdsName());
        }
    }
}
#end_block

#method_before
private void refreshVmStats() {
    for (Pair<VM, VmInternalData> monitoredVm : monitoredVms) {
        // TODO filter out migratingTo VMs if no action is taken on them
        if (tryLockVmForUpdate(monitoredVm)) {
            VmAnalyzer vmAnalyzer = getVmAnalyzer(monitoredVm);
            vmAnalyzers.add(vmAnalyzer);
            vmAnalyzer.analyze();
        }
    }
    saveVmsToDb();
}
#method_after
private void refreshVmStats() {
    for (Pair<VM, VmInternalData> monitoredVm : monitoredVms) {
        // TODO filter out migratingTo VMs if no action is taken on them
        if (tryLockVmForUpdate(monitoredVm)) {
            VmAnalyzer vmAnalyzer = getVmAnalyzer(monitoredVm);
            vmAnalyzers.add(vmAnalyzer);
            vmAnalyzer.analyze();
        }
    }
    addUnmanagedVms();
    flush();
}
#end_block

#method_before
private void afterVMsRefreshTreatment() {
    Collection<Guid> movedToDownVms = new ArrayList<>();
    List<Guid> succeededToRunVms = new ArrayList<>();
    // now loop over the result and act
    for (VmAnalyzer vmAnalyzer : vmAnalyzers) {
        // rerun all vms from rerun list
        if (vmAnalyzer.isRerun()) {
            log.error("Rerun VM '{}'. Called from VDS '{}'", vmAnalyzer.getDbVm().getId(), vdsManager.getVdsName());
            getResourceManager().rerunFailedCommand(vmAnalyzer.getDbVm().getId(), vdsManager.getVdsId());
        }
        if (vmAnalyzer.isSuccededToRun()) {
            vdsManager.succeededToRunVm(vmAnalyzer.getDbVm().getId());
            succeededToRunVms.add(vmAnalyzer.getDbVm().getId());
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        if (vmAnalyzer.isAutoVmToRun() && !vmAnalyzer.isRerun()) {
            autoVmsToRun.add(vmAnalyzer.getDbVm().getId());
        }
        if (vmAnalyzer.isColdRebootVmToRun()) {
            coldRebootVmsToRun.add(vmAnalyzer.getDbVm().getId());
        }
        // process all vms that their ip changed.
        if (vmAnalyzer.isClientIpChanged()) {
            final VmDynamic vmDynamic = vmAnalyzer.getVdsmVm().getVmDynamic();
            getVdsEventListener().processOnClientIpChange(vmDynamic.getId(), vmDynamic.getClientIp());
        }
        // process all vms that powering up.
        if (vmAnalyzer.isPoweringUp()) {
            getVdsEventListener().processOnVmPoweringUp(vmAnalyzer.getVdsmVm().getVmDynamic().getId());
        }
        if (vmAnalyzer.isMovedToDown()) {
            movedToDownVms.add(vmAnalyzer.getDbVm().getId());
        }
        if (vmAnalyzer.isRemoveFromAsync()) {
            getResourceManager().removeAsyncRunningVm(vmAnalyzer.getDbVm().getId());
        }
        if (vmAnalyzer.isHostedEngineUnmanaged()) {
            // @since 3.6 - we take existing HE VM and reimport it
            importHostedEngineVM(getVmInfo(Collections.singletonList(vmAnalyzer.getVdsmVm().getVmDynamic().getId().toString()))[0]);
        }
    }
    getVdsEventListener().updateSlaPolicies(succeededToRunVms, vdsManager.getVdsId());
    // run all vms that crashed that marked with auto startup
    getVdsEventListener().runFailedAutoStartVMs(autoVmsToRun);
    // run all vms that went down as a part of cold reboot process
    getVdsEventListener().runColdRebootVms(coldRebootVmsToRun);
    // process all vms that went down
    getVdsEventListener().processOnVmStop(movedToDownVms, vdsManager.getVdsId());
    getVdsEventListener().refreshHostIfAnyVmHasHostDevices(succeededToRunVms, vdsManager.getVdsId());
}
#method_after
private void afterVMsRefreshTreatment() {
    Collection<Guid> movedToDownVms = new ArrayList<>();
    List<Guid> succeededToRunVms = new ArrayList<>();
    List<Guid> autoVmsToRun = new ArrayList<>();
    List<Guid> coldRebootVmsToRun = new ArrayList<>();
    // now loop over the result and act
    for (VmAnalyzer vmAnalyzer : vmAnalyzers) {
        // rerun all vms from rerun list
        if (vmAnalyzer.isRerun()) {
            log.error("Rerun VM '{}'. Called from VDS '{}'", vmAnalyzer.getDbVm().getId(), vdsManager.getVdsName());
            getResourceManager().rerunFailedCommand(vmAnalyzer.getDbVm().getId(), vdsManager.getVdsId());
        }
        if (vmAnalyzer.isSuccededToRun()) {
            vdsManager.succeededToRunVm(vmAnalyzer.getDbVm().getId());
            succeededToRunVms.add(vmAnalyzer.getDbVm().getId());
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        if (vmAnalyzer.isAutoVmToRun() && !vmAnalyzer.isRerun()) {
            autoVmsToRun.add(vmAnalyzer.getDbVm().getId());
        }
        if (vmAnalyzer.isColdRebootVmToRun()) {
            coldRebootVmsToRun.add(vmAnalyzer.getDbVm().getId());
        }
        // process all vms that their ip changed.
        if (vmAnalyzer.isClientIpChanged()) {
            final VmDynamic vmDynamic = vmAnalyzer.getVdsmVm().getVmDynamic();
            getVdsEventListener().processOnClientIpChange(vmDynamic.getId(), vmDynamic.getClientIp());
        }
        // process all vms that powering up.
        if (vmAnalyzer.isPoweringUp()) {
            getVdsEventListener().processOnVmPoweringUp(vmAnalyzer.getVdsmVm().getVmDynamic().getId());
        }
        if (vmAnalyzer.isMovedToDown()) {
            movedToDownVms.add(vmAnalyzer.getDbVm().getId());
        }
        if (vmAnalyzer.isRemoveFromAsync()) {
            getResourceManager().removeAsyncRunningVm(vmAnalyzer.getDbVm().getId());
        }
        if (vmAnalyzer.isHostedEngineUnmanaged()) {
            // @since 3.6 - we take existing HE VM and reimport it
            importHostedEngineVM(getVmInfo(Collections.singletonList(vmAnalyzer.getVdsmVm().getVmDynamic().getId().toString()))[0]);
        }
    }
    getVdsEventListener().updateSlaPolicies(succeededToRunVms, vdsManager.getVdsId());
    // run all vms that crashed that marked with auto startup
    getVdsEventListener().runFailedAutoStartVMs(autoVmsToRun);
    // run all vms that went down as a part of cold reboot process
    getVdsEventListener().runColdRebootVms(coldRebootVmsToRun);
    // process all vms that went down
    getVdsEventListener().processOnVmStop(movedToDownVms, vdsManager.getVdsId());
    getVdsEventListener().refreshHostIfAnyVmHasHostDevices(succeededToRunVms, vdsManager.getVdsId());
}
#end_block

#method_before
private void importHostedEngineVM(Map<String, Object> vmStruct) {
    VM vm = VdsBrokerObjectsBuilder.buildVmsDataFromExternalProvider(vmStruct);
    if (vm != null) {
        vm.setImages(VdsBrokerObjectsBuilder.buildDiskImagesFromDevices(vmStruct));
        vm.setInterfaces(VdsBrokerObjectsBuilder.buildVmNetworkInterfacesFromDevices(vmStruct));
        for (DiskImage diskImage : vm.getImages()) {
            vm.getDiskMap().put(Guid.newGuid(), diskImage);
        }
        vm.setVdsGroupId(getVdsManager().getVdsGroupId());
        vm.setRunOnVds(getVdsManager().getVdsId());
        getVdsEventListener().importHostedEngineVm(vm);
    }
}
#method_after
private void importHostedEngineVM(Map<String, Object> vmStruct) {
    VM vm = VdsBrokerObjectsBuilder.buildVmsDataFromExternalProvider(vmStruct);
    if (vm != null) {
        vm.setImages(VdsBrokerObjectsBuilder.buildDiskImagesFromDevices(vmStruct));
        vm.setInterfaces(VdsBrokerObjectsBuilder.buildVmNetworkInterfacesFromDevices(vmStruct));
        for (DiskImage diskImage : vm.getImages()) {
            vm.getDiskMap().put(Guid.newGuid(), diskImage);
        }
        vm.setClusterId(getVdsManager().getClusterId());
        vm.setRunOnVds(getVdsManager().getVdsId());
        getVdsEventListener().importHostedEngineVm(vm);
    }
}
#end_block

#method_before
// ***** DB interaction *****
private void saveVmGuestAgentNetworkDevices() {
    if (!vmGuestAgentNics.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (Guid vmId : vmGuestAgentNics.keySet()) {
                    getDbFacade().getVmGuestAgentInterfaceDao().removeAllForVm(vmId);
                }
                for (List<VmGuestAgentInterface> nics : vmGuestAgentNics.values()) {
                    if (nics != null) {
                        for (VmGuestAgentInterface nic : nics) {
                            getDbFacade().getVmGuestAgentInterfaceDao().save(nic);
                        }
                    }
                }
                return null;
            }
        });
    }
}
#method_after
// ***** DB interaction *****
private void saveVmGuestAgentNetworkDevices() {
    Map<Guid, List<VmGuestAgentInterface>> vmGuestAgentNics = vmAnalyzers.stream().filter(analyzer -> !analyzer.getVmGuestAgentNics().isEmpty()).map(analyzer -> new Pair<>(analyzer.getDbVm().getId(), analyzer.getVmGuestAgentNics())).collect(Collectors.toMap(Pair::getFirst, Pair::getSecond));
    if (!vmGuestAgentNics.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            for (Guid vmId : vmGuestAgentNics.keySet()) {
                getDbFacade().getVmGuestAgentInterfaceDao().removeAllForVm(vmId);
            }
            for (List<VmGuestAgentInterface> nics : vmGuestAgentNics.values()) {
                if (nics != null) {
                    for (VmGuestAgentInterface nic : nics) {
                        getDbFacade().getVmGuestAgentInterfaceDao().save(nic);
                    }
                }
            }
            return null;
        });
    }
}
#end_block

#method_before
private void saveVmJobsToDb() {
    getDbFacade().getVmJobDao().updateAllInBatch(vmJobsToUpdate.values());
    if (!vmJobIdsToRemove.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getDbFacade().getVmJobDao().removeAll(vmJobIdsToRemove);
                return null;
            }
        });
    }
}
#method_after
private void saveVmJobsToDb() {
    getDbFacade().getVmJobDao().updateAllInBatch(vmAnalyzers.stream().map(VmAnalyzer::getVmJobsToUpdate).flatMap(Collection::stream).collect(Collectors.toList()));
    List<Guid> vmJobIdsToRemove = vmAnalyzers.stream().map(VmAnalyzer::getVmJobIdsToRemove).flatMap(List::stream).collect(Collectors.toList());
    if (!vmJobIdsToRemove.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getDbFacade().getVmJobDao().removeAll(vmJobIdsToRemove);
            return null;
        });
    }
}
#end_block

#method_before
// ***** Helpers and sub-methods *****
protected Map<String, Object>[] getVmInfo(List<String> vmsToUpdate) {
    // TODO refactor commands to use vdsId only - the whole vds object here is useless
    VDS vds = new VDS();
    vds.setId(vdsManager.getVdsId());
    Map<String, Object>[] result = new Map[0];
    VDSReturnValue vdsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.FullList, new FullListVDSCommandParameters(vds, vmsToUpdate));
    if (vdsReturnValue.getSucceeded()) {
        result = (Map<String, Object>[]) (vdsReturnValue.getReturnValue());
    }
    return result;
}
#method_after
// ***** Helpers and sub-methods *****
protected Map<String, Object>[] getVmInfo(List<String> vmsToUpdate) {
    // TODO refactor commands to use vdsId only - the whole vds object here is useless
    VDS vds = new VDS();
    vds.setId(vdsManager.getVdsId());
    Map<String, Object>[] result = new Map[0];
    VDSReturnValue vdsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.FullList, new FullListVDSCommandParameters(vds, vmsToUpdate));
    if (vdsReturnValue.getSucceeded()) {
        result = (Map<String, Object>[]) vdsReturnValue.getReturnValue();
    }
    return result;
}
#end_block

#method_before
private Guid getVmId(Pair<VM, VmInternalData> pair) {
    return (pair.getFirst() != null) ? pair.getFirst().getId() : ((pair.getSecond() != null) ? pair.getSecond().getVmDynamic().getId() : null);
}
#method_after
private Guid getVmId(Pair<VM, VmInternalData> pair) {
    return (pair.getFirst() != null) ? pair.getFirst().getId() : pair.getSecond() != null ? pair.getSecond().getVmDynamic().getId() : null;
}
#end_block

#method_before
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<>();
    for (HostNetwork hostNetwork : getParameters().getNetworks()) {
        Map<String, Object> attributes = new HashMap<>();
        if (hostNetwork.isBonding()) {
            attributes.put("bonding", hostNetwork.getNicName());
        } else {
            attributes.put("nic", hostNetwork.getNicName());
        }
        if (hostNetwork.isVlan()) {
            attributes.put("vlan", hostNetwork.getVlan().toString());
        }
        if (hostNetwork.getMtu() == 0) {
            attributes.put(VdsProperties.MTU, NetworkUtils.getDefaultMtu().toString());
        } else {
            attributes.put(VdsProperties.MTU, String.valueOf(hostNetwork.getMtu()));
        }
        attributes.put("bridged", Boolean.toString(hostNetwork.isVmNetwork()));
        if (hostNetwork.isVmNetwork()) {
            attributes.put(VdsProperties.STP, hostNetwork.isStp() ? "yes" : "no");
        }
        if (hostNetwork.getBootProtocol() != null) {
            addBootProtocol(attributes, hostNetwork);
        }
        if (hostNetwork.isDefaultRoute()) {
            attributes.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (hostNetwork.hasProperties()) {
            attributes.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, hostNetwork.getProperties());
        }
        if (getParameters().getHostNetworkQosSupported() && hostNetwork.isQosConfiguredOnInterface()) {
            HostNetworkQosMapper qosMapper = new HostNetworkQosMapper(attributes);
            qosMapper.serialize(hostNetwork.getQos());
        }
        networks.put(hostNetwork.getNetworkName(), attributes);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#method_after
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<>();
    for (HostNetwork hostNetwork : getParameters().getNetworks()) {
        Map<String, Object> attributes = new HashMap<>();
        if (hostNetwork.isBonding()) {
            attributes.put("bonding", hostNetwork.getNicName());
        } else {
            attributes.put("nic", hostNetwork.getNicName());
        }
        if (hostNetwork.isVlan()) {
            attributes.put("vlan", hostNetwork.getVlan().toString());
        }
        if (hostNetwork.getMtu() == 0) {
            attributes.put(VdsProperties.MTU, NetworkUtils.getDefaultMtu());
        } else {
            attributes.put(VdsProperties.MTU, hostNetwork.getMtu());
        }
        attributes.put("bridged", Boolean.toString(hostNetwork.isVmNetwork()));
        if (hostNetwork.isVmNetwork()) {
            attributes.put(VdsProperties.STP, hostNetwork.isStp() ? "yes" : "no");
        }
        if (hostNetwork.getBootProtocol() != null) {
            addBootProtocol(attributes, hostNetwork);
        }
        if (hostNetwork.isDefaultRoute()) {
            attributes.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (hostNetwork.hasProperties()) {
            attributes.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, hostNetwork.getProperties());
        }
        if (getParameters().getHostNetworkQosSupported() && hostNetwork.isQosConfiguredOnInterface()) {
            HostNetworkQosMapper qosMapper = new HostNetworkQosMapper(attributes);
            qosMapper.serialize(hostNetwork.getQos());
        }
        networks.put(hostNetwork.getNetworkName(), attributes);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#end_block

#method_before
private void completeMissingDataInParameters() {
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    nicNameNicIdCompleter.completeLabels(getParameters().getLabels());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getExistingAttachments(), getNetworkBusinessEntityMap());
    NicLabelsCompleter labelsCompleter = new NicLabelsCompleter(getParameters(), getExistingAttachments(), getClusterNetworks(), getExistingNicsBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments();
}
#method_after
private void completeMissingDataInParameters() {
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    nicNameNicIdCompleter.completeLabels(getParameters().getLabels());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getExistingAttachments(), getNetworkBusinessEntityMap());
    NicLabelsCompleter labelsCompleter = new NicLabelsCompleter(getParameters(), getExistingAttachments(), getClusterNetworks(), getExistingNicsBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments();
    fillInUnsetIpConfigs();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        log.info("No changes were detected in setup networks for host '{}' (ID: '{}')", getVdsName(), getVdsId());
        setSucceeded(true);
        return;
    }
    int timeout = getSetupNetworksTimeout();
    FutureVDSCall<VDSReturnValue> setupNetworksTask = invokeSetupNetworksCommand(timeout);
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().rollbackOnFailure()) {
                throw new EngineException(EngineError.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock()) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                logMonitorLockReleased("Host setup networks");
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Host Setup networks command timed out for {} seconds", timeout);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        log.info("No changes were detected in setup networks for host '{}' (ID: '{}')", getVdsName(), getVdsId());
        setSucceeded(true);
        return;
    }
    int timeout = getSetupNetworksTimeout();
    FutureVDSCall<VDSReturnValue> setupNetworksTask = invokeSetupNetworksCommand(timeout);
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().rollbackOnFailure()) {
                throw new EngineException(EngineError.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock("Host setup networks")) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Host Setup networks command timed out for {} seconds", timeout);
    }
}
#end_block

#method_before
private UICommand getOnSaveCommand() {
    // $NON-NLS-1$
    UICommand onSaveCommand = UICommand.createDefaultOkUiCommand("OnSave", this);
    return onSaveCommand;
}
#method_after
private UICommand getOnSaveCommand() {
    // $NON-NLS-1$
    return UICommand.createDefaultOkUiCommand("OnSave", this);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (updateStorageDomainsInDb()) {
        // setting storage pool status to maintenance
        StoragePool storagePool = getStoragePool();
        getCompensationContext().snapshotEntity(storagePool);
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePool().setStoragePoolFormatType(masterStorageDomain.getStorageFormat());
                DbFacade.getInstance().getStoragePoolDao().update(getStoragePool());
                getCompensationContext().stateChanged();
                StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
                return null;
            }
        });
        // Following code performs only read operations, therefore no need for new transaction
        boolean result = false;
        retVal = null;
        for (VDS vds : getAllRunningVdssInPool()) {
            setVds(vds);
            for (Guid storageDomainId : getParameters().getStorages()) {
                // now the domain should have the mapping
                // with the pool in db
                StorageDomain storageDomain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(storageDomainId, getStoragePool().getId());
                StorageHelperDirector.getInstance().getItem(storageDomain.getStorageType()).connectStorageToDomainByVdsId(storageDomain, getVds().getId());
            }
            retVal = addStoragePoolInIrs();
            if (!retVal.getSucceeded() && retVal.getVdsError().getCode() == EngineError.StorageDomainAccessError) {
                log.warn("Error creating storage pool on vds '{}' - continuing", vds.getName());
                continue;
            } else {
                // storage pool creation succeeded or failed
                // but didn't throw exception
                result = retVal.getSucceeded();
                break;
            }
        }
        setSucceeded(result);
        if (!result) {
            if (retVal != null && retVal.getVdsError().getCode() != null) {
                throw new EngineException(retVal.getVdsError().getCode(), retVal.getVdsError().getMessage());
            } else {
                // command
                throw new EngineException(EngineError.ENGINE_ERROR_CREATING_STORAGE_POOL);
            }
        } else {
            registerOvfStoreDisks();
        }
    }
    // Create pool phase completed, no rollback is needed here, so compensation information needs to be cleared!
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    freeLock();
    // if create succeeded activate
    if (getSucceeded()) {
        activateStorageDomains();
    }
}
#method_after
@Override
protected void executeCommand() {
    if (updateStorageDomainsInDb()) {
        // setting storage pool status to maintenance
        StoragePool storagePool = getStoragePool();
        getCompensationContext().snapshotEntity(storagePool);
        TransactionSupport.executeInNewTransaction(() -> {
            getStoragePool().setStatus(StoragePoolStatus.Maintenance);
            getStoragePool().setStoragePoolFormatType(masterStorageDomain.getStorageFormat());
            DbFacade.getInstance().getStoragePoolDao().update(getStoragePool());
            getCompensationContext().stateChanged();
            StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
            return null;
        });
        // Following code performs only read operations, therefore no need for new transaction
        boolean result = false;
        retVal = null;
        for (VDS vds : getAllRunningVdssInPool()) {
            setVds(vds);
            for (Guid storageDomainId : getParameters().getStorages()) {
                // now the domain should have the mapping
                // with the pool in db
                StorageDomain storageDomain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(storageDomainId, getStoragePool().getId());
                StorageHelperDirector.getInstance().getItem(storageDomain.getStorageType()).connectStorageToDomainByVdsId(storageDomain, getVds().getId());
            }
            retVal = addStoragePoolInIrs();
            if (!retVal.getSucceeded() && retVal.getVdsError().getCode() == EngineError.StorageDomainAccessError) {
                log.warn("Error creating storage pool on vds '{}' - continuing", vds.getName());
                continue;
            } else {
                // storage pool creation succeeded or failed
                // but didn't throw exception
                result = retVal.getSucceeded();
                break;
            }
        }
        setSucceeded(result);
        if (!result) {
            if (retVal != null && retVal.getVdsError().getCode() != null) {
                throw new EngineException(retVal.getVdsError().getCode(), retVal.getVdsError().getMessage());
            } else {
                // command
                throw new EngineException(EngineError.ENGINE_ERROR_CREATING_STORAGE_POOL);
            }
        } else {
            registerOvfStoreDisks();
        }
    }
    // Create pool phase completed, no rollback is needed here, so compensation information needs to be cleared!
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().resetCompensation();
        return null;
    });
    freeLock();
    // if create succeeded activate
    if (getSucceeded()) {
        activateStorageDomains();
    }
}
#end_block

#method_before
private boolean updateStorageDomainsInDb() {
    boolean result = TransactionSupport.executeInNewTransaction(new TransactionMethod<Boolean>() {

        @Override
        public Boolean runInTransaction() {
            for (Guid storageDomainId : getParameters().getStorages()) {
                StorageDomain storageDomain = DbFacade.getInstance().getStorageDomainDao().get(storageDomainId);
                if (storageDomain != null) {
                    StoragePoolIsoMap mapFromDB = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(storageDomain.getId(), getStoragePool().getId()));
                    boolean existingInDb = mapFromDB != null;
                    if (existingInDb) {
                        getCompensationContext().snapshotEntity(mapFromDB);
                    }
                    final StorageDomainStatic staticDomain = storageDomain.getStorageStaticData();
                    boolean staticDomainChanged = false;
                    StorageFormatType requiredFormatType = VersionStorageFormatUtil.getRequiredForVersion(getStoragePool().getCompatibilityVersion(), storageDomain.getStorageType());
                    if (staticDomain.getStorageFormat().compareTo(requiredFormatType) < 0) {
                        if (!staticDomainChanged) {
                            getCompensationContext().snapshotEntity(staticDomain);
                        }
                        staticDomain.setStorageFormat(requiredFormatType);
                        staticDomainChanged = true;
                    }
                    storageDomain.setStoragePoolId(getStoragePool().getId());
                    if (masterStorageDomain == null && storageDomain.getStorageDomainType() == StorageDomainType.Data) {
                        if (!staticDomainChanged) {
                            getCompensationContext().snapshotEntity(staticDomain);
                        }
                        storageDomain.setStorageDomainType(StorageDomainType.Master);
                        staticDomainChanged = true;
                        masterStorageDomain = storageDomain;
                        // The update of storage pool should be without compensation,
                        // this is why we run it in a different SUPRESS transaction.
                        updateStoragePoolMasterDomainVersionInDiffTransaction();
                    }
                    if (staticDomainChanged) {
                        getStorageDomainStaticDao().update(staticDomain);
                    }
                    storageDomain.setStatus(StorageDomainStatus.Locked);
                    if (existingInDb) {
                        DbFacade.getInstance().getStoragePoolIsoMapDao().update(storageDomain.getStoragePoolIsoMapData());
                    } else {
                        DbFacade.getInstance().getStoragePoolIsoMapDao().save(storageDomain.getStoragePoolIsoMapData());
                        getCompensationContext().snapshotNewEntity(storageDomain.getStoragePoolIsoMapData());
                    }
                } else {
                    return false;
                }
            }
            getCompensationContext().stateChanged();
            return true;
        }
    });
    return result && masterStorageDomain != null;
}
#method_after
private boolean updateStorageDomainsInDb() {
    boolean result = TransactionSupport.executeInNewTransaction(() -> {
        for (Guid storageDomainId : getParameters().getStorages()) {
            StorageDomain storageDomain = DbFacade.getInstance().getStorageDomainDao().get(storageDomainId);
            if (storageDomain != null) {
                StoragePoolIsoMap mapFromDB = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(storageDomain.getId(), getStoragePool().getId()));
                boolean existingInDb = mapFromDB != null;
                if (existingInDb) {
                    getCompensationContext().snapshotEntity(mapFromDB);
                }
                final StorageDomainStatic staticDomain = storageDomain.getStorageStaticData();
                boolean staticDomainChanged = false;
                StorageFormatType requiredFormatType = VersionStorageFormatUtil.getRequiredForVersion(getStoragePool().getCompatibilityVersion(), storageDomain.getStorageType());
                if (staticDomain.getStorageFormat().compareTo(requiredFormatType) < 0) {
                    if (!staticDomainChanged) {
                        getCompensationContext().snapshotEntity(staticDomain);
                    }
                    staticDomain.setStorageFormat(requiredFormatType);
                    staticDomainChanged = true;
                }
                storageDomain.setStoragePoolId(getStoragePool().getId());
                if (masterStorageDomain == null && storageDomain.getStorageDomainType() == StorageDomainType.Data) {
                    if (!staticDomainChanged) {
                        getCompensationContext().snapshotEntity(staticDomain);
                    }
                    storageDomain.setStorageDomainType(StorageDomainType.Master);
                    staticDomainChanged = true;
                    masterStorageDomain = storageDomain;
                    // The update of storage pool should be without compensation,
                    // this is why we run it in a different SUPRESS transaction.
                    updateStoragePoolMasterDomainVersionInDiffTransaction();
                }
                if (staticDomainChanged) {
                    getStorageDomainStaticDao().update(staticDomain);
                }
                storageDomain.setStatus(StorageDomainStatus.Locked);
                if (existingInDb) {
                    DbFacade.getInstance().getStoragePoolIsoMapDao().update(storageDomain.getStoragePoolIsoMapData());
                } else {
                    DbFacade.getInstance().getStoragePoolIsoMapDao().save(storageDomain.getStoragePoolIsoMapData());
                    getCompensationContext().snapshotNewEntity(storageDomain.getStoragePoolIsoMapData());
                }
            } else {
                return false;
            }
        }
        getCompensationContext().stateChanged();
        return true;
    });
    return result && masterStorageDomain != null;
}
#end_block

#method_before
private boolean activateStorageDomains() {
    boolean returnValue = true;
    for (final Guid storageDomainId : getParameters().getStorages()) {
        StorageDomainPoolParametersBase activateParameters = new StorageDomainPoolParametersBase(storageDomainId, getStoragePool().getId());
        activateParameters.setSessionId(getParameters().getSessionId());
        activateParameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        returnValue = Backend.getInstance().runInternalAction(VdcActionType.ActivateStorageDomain, activateParameters).getSucceeded();
        // if activate domain failed then set domain status to inactive
        if (!returnValue) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    DbFacade.getInstance().getStoragePoolIsoMapDao().updateStatus(new StoragePoolIsoMapId(storageDomainId, getStoragePool().getId()), StorageDomainStatus.Inactive);
                    return null;
                }
            });
        }
    }
    return returnValue;
}
#method_after
private boolean activateStorageDomains() {
    boolean returnValue = true;
    for (final Guid storageDomainId : getParameters().getStorages()) {
        StorageDomainPoolParametersBase activateParameters = new StorageDomainPoolParametersBase(storageDomainId, getStoragePool().getId());
        activateParameters.setSessionId(getParameters().getSessionId());
        activateParameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        returnValue = Backend.getInstance().runInternalAction(VdcActionType.ActivateStorageDomain, activateParameters).getSucceeded();
        // if activate domain failed then set domain status to inactive
        if (!returnValue) {
            TransactionSupport.executeInNewTransaction(() -> {
                DbFacade.getInstance().getStoragePoolIsoMapDao().updateStatus(new StoragePoolIsoMapId(storageDomainId, getStoragePool().getId()), StorageDomainStatus.Inactive);
                return null;
            });
        }
    }
    return returnValue;
}
#end_block

#method_before
private void registerOvfStoreDisks() {
    for (final Guid storageDomainId : getParameters().getStorages()) {
        resetOvfStoreDisks();
        final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk(storageDomainId, getStoragePool().getId());
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                List<DiskImage> ovfStoreDiskImages = getAllOVFDisks(storageDomainId, getStoragePool().getId());
                registerAllOvfDisks(ovfStoreDiskImages, storageDomainId);
                // Update unregistered entities
                for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                    getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), storageDomainId);
                    getUnregisteredOVFDataDao().saveOVFData(ovf);
                    log.info("Adding OVF data of entity id '{}' and entity name '{}'", ovf.getEntityId(), ovf.getEntityName());
                }
                return null;
            }
        });
    }
}
#method_after
private void registerOvfStoreDisks() {
    for (final Guid storageDomainId : getParameters().getStorages()) {
        resetOvfStoreDisks();
        final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk(storageDomainId, getStoragePool().getId());
        TransactionSupport.executeInNewTransaction(() -> {
            List<DiskImage> ovfStoreDiskImages = getAllOVFDisks(storageDomainId, getStoragePool().getId());
            registerAllOvfDisks(ovfStoreDiskImages, storageDomainId);
            // Update unregistered entities
            for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), storageDomainId);
                getUnregisteredOVFDataDao().saveOVFData(ovf);
                log.info("Adding OVF data of entity id '{}' and entity name '{}'", ovf.getEntityId(), ovf.getEntityName());
            }
            return null;
        });
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    initializeStorageDomain();
    // save storage if got from parameters in order to save first empty
    // storage in db and use it later
    String storage = ((getStorageDomain().getStorage()) != null) ? getStorageDomain().getStorage() : "";
    // set domain storage to empty because not nullable in db and for shared
    // status to be locked
    getStorageDomain().setStorage("");
    addStorageDomainInDb();
    if (StringUtils.isEmpty(storage)) {
        storage = createVG();
    }
    getStorageDomain().setStorage(storage);
    if (StringUtils.isNotEmpty(getStorageDomain().getStorage()) && (addStorageDomainInIrs())) {
        DbFacade.getInstance().getStorageDomainStaticDao().update(getStorageDomain().getStorageStaticData());
        updateStorageDomainDynamicFromIrs();
        proceedVGLunsInDb();
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    initializeStorageDomain();
    // save storage if got from parameters in order to save first empty
    // storage in db and use it later
    String storage = (getStorageDomain().getStorage() != null) ? getStorageDomain().getStorage() : "";
    // set domain storage to empty because not nullable in db and for shared
    // status to be locked
    getStorageDomain().setStorage("");
    addStorageDomainInDb();
    if (StringUtils.isEmpty(storage)) {
        storage = createVG();
    }
    getStorageDomain().setStorage(storage);
    if (StringUtils.isNotEmpty(getStorageDomain().getStorage()) && addStorageDomainInIrs()) {
        DbFacade.getInstance().getStorageDomainStaticDao().update(getStorageDomain().getStorageStaticData());
        updateStorageDomainDynamicFromIrs();
        proceedVGLunsInDb();
        setSucceeded(true);
    }
}
#end_block

#method_before
protected void proceedVGLunsInDb() {
    final ArrayList<LUNs> luns = (ArrayList<LUNs>) runVdsCommand(VDSCommandType.GetVGInfo, new GetVGInfoVDSCommandParameters(getVds().getId(), getStorageDomain().getStorage())).getReturnValue();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (LUNs lun : luns) {
                proceedLUNInDb(lun, getStorageDomain().getStorageType(), getStorageDomain().getStorage());
            }
            return null;
        }
    });
}
#method_after
protected void proceedVGLunsInDb() {
    final ArrayList<LUNs> luns = (ArrayList<LUNs>) runVdsCommand(VDSCommandType.GetVGInfo, new GetVGInfoVDSCommandParameters(getVds().getId(), getStorageDomain().getStorage())).getReturnValue();
    TransactionSupport.executeInNewTransaction(() -> {
        for (LUNs lun : luns) {
            proceedLUNInDb(lun, getStorageDomain().getStorageType(), getStorageDomain().getStorage());
        }
        return null;
    });
}
#end_block

#method_before
@Override
protected boolean canAddDomain() {
    if (((getParameters().getLunIds() == null || getParameters().getLunIds().isEmpty()) && StringUtils.isEmpty(getStorageDomain().getStorage()))) {
        return failValidation(EngineMessage.ERROR_CANNOT_CREATE_STORAGE_DOMAIN_WITHOUT_VG_LV);
    }
    if (isLunsAlreadyInUse(getParameters().getLunIds())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canAddDomain() {
    if ((getParameters().getLunIds() == null || getParameters().getLunIds().isEmpty()) && StringUtils.isEmpty(getStorageDomain().getStorage())) {
        return failValidation(EngineMessage.ERROR_CANNOT_CREATE_STORAGE_DOMAIN_WITHOUT_VG_LV);
    }
    if (isLunsAlreadyInUse(getParameters().getLunIds())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setImageGroupId(getParameters().getDiskInfo().getId());
    if (Guid.isNullOrEmpty(getDestinationImageId())) {
        setDestinationImageId(Guid.newGuid());
    }
    newDiskImage = new DiskImage();
    newDiskImage.setImageId(getDestinationImageId());
    newDiskImage.setBoot(getParameters().getDiskInfo().isBoot());
    newDiskImage.setDiskInterface(getParameters().getDiskInfo().getDiskInterface());
    newDiskImage.setPropagateErrors(getParameters().getDiskInfo().getPropagateErrors());
    newDiskImage.setWipeAfterDelete(getParameters().getDiskInfo().isWipeAfterDelete());
    newDiskImage.setDiskAlias(getParameters().getDiskInfo().getDiskAlias());
    newDiskImage.setDiskDescription(getParameters().getDiskInfo().getDiskDescription());
    newDiskImage.setShareable(getParameters().getDiskInfo().isShareable());
    newDiskImage.setId(getImageGroupId());
    newDiskImage.setStoragePoolId(getParameters().getStoragePoolId());
    newDiskImage.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getStorageDomainId())));
    newDiskImage.setSize(getParameters().getDiskInfo().getSize());
    newDiskImage.setVolumeType(getParameters().getDiskInfo().getVolumeType());
    newDiskImage.setvolumeFormat(getParameters().getDiskInfo().getVolumeFormat());
    newDiskImage.setDescription("");
    newDiskImage.setCreationDate(new Date());
    newDiskImage.setLastModified(new Date());
    newDiskImage.setActive(true);
    newDiskImage.setImageStatus(ImageStatus.LOCKED);
    newDiskImage.setVmSnapshotId(getParameters().getVmSnapshotId());
    newDiskImage.setQuotaId(getParameters().getQuotaId());
    newDiskImage.setDiskProfileId(getParameters().getDiskProfileId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            if (!getParameters().isShouldRemainIllegalOnFailedExecution()) {
                addDiskImageToDb(newDiskImage, getCompensationContext(), Boolean.TRUE);
            } else {
                addDiskImageToDb(newDiskImage, null, Boolean.TRUE);
                getCompensationContext().snapshotEntityStatus(newDiskImage.getImage(), ImageStatus.ILLEGAL);
            }
            return null;
        }
    });
    freeLock();
    if (getParameters().isShouldRemainIllegalOnFailedExecution()) {
        getReturnValue().setActionReturnValue(newDiskImage);
    }
    processImageInIrs();
    getReturnValue().setActionReturnValue(newDiskImage);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    setImageGroupId(getParameters().getDiskInfo().getId());
    if (Guid.isNullOrEmpty(getDestinationImageId())) {
        setDestinationImageId(Guid.newGuid());
    }
    newDiskImage = new DiskImage();
    newDiskImage.setImageId(getDestinationImageId());
    newDiskImage.setBoot(getParameters().getDiskInfo().isBoot());
    newDiskImage.setDiskInterface(getParameters().getDiskInfo().getDiskInterface());
    newDiskImage.setPropagateErrors(getParameters().getDiskInfo().getPropagateErrors());
    newDiskImage.setWipeAfterDelete(getParameters().getDiskInfo().isWipeAfterDelete());
    newDiskImage.setDiskAlias(getParameters().getDiskInfo().getDiskAlias());
    newDiskImage.setDiskDescription(getParameters().getDiskInfo().getDiskDescription());
    newDiskImage.setShareable(getParameters().getDiskInfo().isShareable());
    newDiskImage.setId(getImageGroupId());
    newDiskImage.setStoragePoolId(getParameters().getStoragePoolId());
    newDiskImage.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getStorageDomainId())));
    newDiskImage.setSize(getParameters().getDiskInfo().getSize());
    newDiskImage.setVolumeType(getParameters().getDiskInfo().getVolumeType());
    newDiskImage.setvolumeFormat(getParameters().getDiskInfo().getVolumeFormat());
    newDiskImage.setDescription("");
    newDiskImage.setCreationDate(new Date());
    newDiskImage.setLastModified(new Date());
    newDiskImage.setActive(true);
    newDiskImage.setImageStatus(ImageStatus.LOCKED);
    newDiskImage.setVmSnapshotId(getParameters().getVmSnapshotId());
    newDiskImage.setQuotaId(getParameters().getQuotaId());
    newDiskImage.setDiskProfileId(getParameters().getDiskProfileId());
    TransactionSupport.executeInNewTransaction(() -> {
        if (!getParameters().isShouldRemainIllegalOnFailedExecution()) {
            addDiskImageToDb(newDiskImage, getCompensationContext(), Boolean.TRUE);
        } else {
            addDiskImageToDb(newDiskImage, null, Boolean.TRUE);
            getCompensationContext().snapshotEntityStatus(newDiskImage.getImage(), ImageStatus.ILLEGAL);
        }
        return null;
    });
    freeLock();
    if (getParameters().isShouldRemainIllegalOnFailedExecution()) {
        getReturnValue().setActionReturnValue(newDiskImage);
    }
    processImageInIrs();
    getReturnValue().setActionReturnValue(newDiskImage);
    setSucceeded(true);
}
#end_block

#method_before
private Guid updateActiveSnapshotId() {
    final Snapshot activeSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
    final Guid activeSnapshotId = activeSnapshot.getId();
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(activeSnapshot);
            getSnapshotDao().updateId(activeSnapshotId, newActiveSnapshotId);
            activeSnapshot.setId(newActiveSnapshotId);
            getCompensationContext().snapshotNewEntity(activeSnapshot);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    return activeSnapshotId;
}
#method_after
private Guid updateActiveSnapshotId() {
    final Snapshot activeSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
    final Guid activeSnapshotId = activeSnapshot.getId();
    TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
        getCompensationContext().snapshotEntity(activeSnapshot);
        getSnapshotDao().updateId(activeSnapshotId, newActiveSnapshotId);
        activeSnapshot.setId(newActiveSnapshotId);
        getCompensationContext().snapshotNewEntity(activeSnapshot);
        getCompensationContext().stateChanged();
        return null;
    });
    return activeSnapshotId;
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    if (CommandCoordinatorUtil.getChildCommandIds(getCommandId()).size() > 1) {
        log.info("There are still running CoCo tasks");
        return;
    }
    Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    // if the snapshot was not created in the DB
    // the command should also be handled as a failure
    boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess();
    boolean liveSnapshotRequired = isLiveSnapshotApplicable();
    boolean liveSnapshotSucceeded = false;
    if (taskGroupSucceeded) {
        getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
        if (liveSnapshotRequired) {
            liveSnapshotSucceeded = performLiveSnapshot(createdSnapshot);
        } else {
            // they are not going to be in use since no live snapshot is created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                logMemorySavingFailed();
                getSnapshotDao().removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
    } else {
        if (createdSnapshot != null) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // Note that the memory volumes might not have been created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        } else {
            log.warn("No snapshot was created for VM '{}' which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    thawVm();
    endActionOnDisks();
    setSucceeded(taskGroupSucceeded && (!liveSnapshotRequired || liveSnapshotSucceeded));
    getReturnValue().setEndActionTryAgain(false);
}
#method_after
@Override
protected void endVmCommand() {
    Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    // if the snapshot was not created in the DB
    // the command should also be handled as a failure
    boolean taskGroupSucceeded = createdSnapshot != null && getParameters().getTaskGroupSuccess();
    boolean liveSnapshotRequired = isLiveSnapshotApplicable();
    boolean liveSnapshotSucceeded = false;
    if (taskGroupSucceeded) {
        getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
        if (liveSnapshotRequired) {
            liveSnapshotSucceeded = performLiveSnapshot(createdSnapshot);
        } else {
            // they are not going to be in use since no live snapshot is created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                logMemorySavingFailed();
                getSnapshotDao().removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
    } else {
        if (createdSnapshot != null) {
            revertToActiveSnapshot(createdSnapshot.getId());
            // Note that the memory volumes might not have been created
            if (getParameters().isSaveMemory() && createdSnapshot.containsMemory()) {
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        } else {
            log.warn("No snapshot was created for VM '{}' which is in LOCKED status", getVmId());
        }
    }
    incrementVmGeneration();
    thawVm();
    endActionOnDisks();
    setSucceeded(taskGroupSucceeded && (!liveSnapshotRequired || liveSnapshotSucceeded));
    getReturnValue().setEndActionTryAgain(false);
}
#end_block

#method_before
protected boolean performLiveSnapshot(final Snapshot snapshot) {
    try {
        TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                runVdsCommand(VDSCommandType.Snapshot, buildLiveSnapshotParameters(snapshot));
                return null;
            }
        });
    } catch (EngineException e) {
        handleVdsLiveSnapshotFailure(e);
        return false;
    }
    return true;
}
#method_after
protected boolean performLiveSnapshot(final Snapshot snapshot) {
    try {
        TransactionSupport.executeInScope(TransactionScopeOption.Suppress, () -> {
            runVdsCommand(VDSCommandType.Snapshot, buildLiveSnapshotParameters(snapshot));
            return null;
        });
    } catch (EngineException e) {
        handleVdsLiveSnapshotFailure(e);
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean isMemorySnapshotSupported() {
    return FeatureSupported.memorySnapshot(getVm().getVdsGroupCompatibilityVersion()) && FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getVdsGroupCompatibilityVersion());
}
#method_after
private boolean isMemorySnapshotSupported() {
    return FeatureSupported.memorySnapshot(getVm().getClusterCompatibilityVersion()) && FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getClusterCompatibilityVersion());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateStaticDataDefaults();
    if (StringUtils.isEmpty(getStorageDomain().getStorage())) {
        getStorageDomain().setStorage((String) Backend.getInstance().runInternalAction(VdcActionType.AddStorageServerConnection, new StorageServerConnectionParametersBase(getStorageDomain().getStorageStaticData().getConnection(), getVds().getId())).getActionReturnValue());
    }
    addStorageDomainInDb();
    updateStorageDomainDynamicFromIrs();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    updateStaticDataDefaults();
    if (StringUtils.isEmpty(getStorageDomain().getStorage())) {
        getStorageDomain().setStorage(Backend.getInstance().runInternalAction(VdcActionType.AddStorageServerConnection, new StorageServerConnectionParametersBase(getStorageDomain().getStorageStaticData().getConnection(), getVds().getId())).getActionReturnValue());
    }
    addStorageDomainInDb();
    updateStorageDomainDynamicFromIrs();
    setSucceeded(true);
}
#end_block

#method_before
protected boolean concreteCheckExistingStorageDomain(Pair<StorageDomainStatic, Guid> domain) {
    boolean returnValue = false;
    StorageDomainStatic domainFromIrs = domain.getFirst();
    if (StringUtils.isEmpty(getStorageDomain().getStorageStaticData().getStorage()) && StringUtils.isEmpty(domainFromIrs.getStorage()) && domainFromIrs.getConnection() != null && getStorageDomain().getStorageStaticData().getConnection() != null) {
        returnValue = (StringUtils.equals(domainFromIrs.getConnection().getConnection(), getStorageDomain().getStorageStaticData().getConnection().getConnection()));
    } else if (!StringUtils.isEmpty(getStorageDomain().getStorageStaticData().getStorage()) && !StringUtils.isEmpty(domainFromIrs.getStorage())) {
        returnValue = (StringUtils.equals(domainFromIrs.getStorage(), getStorageDomain().getStorageStaticData().getStorage()));
    }
    if (!returnValue) {
        addValidationMessage(EngineMessage.ERROR_CANNOT_ADD_EXISTING_STORAGE_DOMAIN_CONNECTION_DATA_ILLEGAL);
    }
    return returnValue;
}
#method_after
protected boolean concreteCheckExistingStorageDomain(Pair<StorageDomainStatic, Guid> domain) {
    boolean returnValue = false;
    StorageDomainStatic domainFromIrs = domain.getFirst();
    if (StringUtils.isEmpty(getStorageDomain().getStorageStaticData().getStorage()) && StringUtils.isEmpty(domainFromIrs.getStorage()) && domainFromIrs.getConnection() != null && getStorageDomain().getStorageStaticData().getConnection() != null) {
        returnValue = StringUtils.equals(domainFromIrs.getConnection().getConnection(), getStorageDomain().getStorageStaticData().getConnection().getConnection());
    } else if (!StringUtils.isEmpty(getStorageDomain().getStorageStaticData().getStorage()) && !StringUtils.isEmpty(domainFromIrs.getStorage())) {
        returnValue = StringUtils.equals(domainFromIrs.getStorage(), getStorageDomain().getStorageStaticData().getStorage());
    }
    if (!returnValue) {
        addValidationMessage(EngineMessage.ERROR_CANNOT_ADD_EXISTING_STORAGE_DOMAIN_CONNECTION_DATA_ILLEGAL);
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getStorageDomain().getStorageType().isCinderDomain()) {
        detachCinderStorageDomain();
        return;
    }
    log.info("Start detach storage domain");
    changeStorageDomainStatusInTransaction(getStorageDomain().getStoragePoolIsoMapData(), StorageDomainStatus.Detaching);
    log.info(" Detach storage domain: before connect");
    connectHostsInUpToDomainStorageServer();
    log.info(" Detach storage domain: after connect");
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, new DetachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, getStoragePool().getMasterDomainVersion()));
    log.info(" Detach storage domain: after detach in vds");
    disconnectAllHostsInPool();
    log.info(" Detach storage domain: after disconnect storage");
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            detachStorageDomainWithEntities(getStorageDomain());
            StoragePoolIsoMap mapToRemove = getStorageDomain().getStoragePoolIsoMapData();
            getCompensationContext().snapshotEntity(mapToRemove);
            DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(mapToRemove.getStorageId(), mapToRemove.getStoragePoolId()));
            // when detaching SD for data center, we should remove any attachment to qos, which is part of the old
            // data center
            DbFacade.getInstance().getDiskProfileDao().nullifyQosForStorageDomain(getStorageDomain().getId());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (returnValue.getSucceeded() && getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
        // reset iso for this pool in vdsBroker cache
        runVdsCommand(VDSCommandType.ResetISOPath, new IrsBaseVDSCommandParameters(getParameters().getStoragePoolId()));
    }
    log.info("End detach storage domain");
    setSucceeded(returnValue.getSucceeded());
}
#method_after
@Override
protected void executeCommand() {
    if (getStorageDomain().getStorageType().isCinderDomain()) {
        detachCinderStorageDomain();
        return;
    }
    log.info("Start detach storage domain");
    changeStorageDomainStatusInTransaction(getStorageDomain().getStoragePoolIsoMapData(), StorageDomainStatus.Detaching);
    log.info(" Detach storage domain: before connect");
    connectHostsInUpToDomainStorageServer();
    log.info(" Detach storage domain: after connect");
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, new DetachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, getStoragePool().getMasterDomainVersion()));
    log.info(" Detach storage domain: after detach in vds");
    disconnectAllHostsInPool();
    log.info(" Detach storage domain: after disconnect storage");
    TransactionSupport.executeInNewTransaction(() -> {
        detachStorageDomainWithEntities(getStorageDomain());
        StoragePoolIsoMap mapToRemove = getStorageDomain().getStoragePoolIsoMapData();
        getCompensationContext().snapshotEntity(mapToRemove);
        DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(mapToRemove.getStorageId(), mapToRemove.getStoragePoolId()));
        // when detaching SD for data center, we should remove any attachment to qos, which is part of the old
        // data center
        DbFacade.getInstance().getDiskProfileDao().nullifyQosForStorageDomain(getStorageDomain().getId());
        getCompensationContext().stateChanged();
        return null;
    });
    if (returnValue.getSucceeded() && getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
        // reset iso for this pool in vdsBroker cache
        runVdsCommand(VDSCommandType.ResetISOPath, new IrsBaseVDSCommandParameters(getParameters().getStoragePoolId()));
    }
    log.info("End detach storage domain");
    setSucceeded(returnValue.getSucceeded());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    executeInNewTransaction(new TransactionMethod<Void>() {

        public Void runInTransaction() {
            setStorageDomainStatus(StorageDomainStatus.Locked, getCompensationContext());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    boolean supportForceExtendVG = Config.<Boolean>getValue(ConfigValues.SupportForceExtendVG, getStoragePool().getCompatibilityVersion().toString());
    runVdsCommand(VDSCommandType.ExtendStorageDomain, new ExtendStorageDomainVDSCommandParameters(getStoragePoolId(), getStorageDomain().getId(), getParameters().getLunIds(), getParameters().isForce(), supportForceExtendVG));
    executeInNewTransaction(new TransactionMethod<Void>() {

        public Void runInTransaction() {
            for (LUNs lun : getParameters().getLunsList()) {
                proceedLUNInDb(lun, getStorageDomain().getStorageType(), getStorageDomain().getStorage());
            }
            setStorageDomainStatus(StorageDomainStatus.Active, null);
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    executeInNewTransaction(() -> {
        setStorageDomainStatus(StorageDomainStatus.Locked, getCompensationContext());
        getCompensationContext().stateChanged();
        return null;
    });
    boolean supportForceExtendVG = Config.<Boolean>getValue(ConfigValues.SupportForceExtendVG, getStoragePool().getCompatibilityVersion().toString());
    runVdsCommand(VDSCommandType.ExtendStorageDomain, new ExtendStorageDomainVDSCommandParameters(getStoragePoolId(), getStorageDomain().getId(), getParameters().getLunIds(), getParameters().isForce(), supportForceExtendVG));
    executeInNewTransaction(() -> {
        for (LUNs lun : getParameters().getLunsList()) {
            proceedLUNInDb(lun, getStorageDomain().getStorageType(), getStorageDomain().getStorage());
        }
        setStorageDomainStatus(StorageDomainStatus.Active, null);
        getCompensationContext().resetCompensation();
        return null;
    });
    setSucceeded(true);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected boolean validate() {
    super.validate();
    if (isLunsAlreadyInUse(getParameters().getLunIds())) {
        return false;
    }
    if (!(checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getStorageDomain().getStorageType().isBlockDomain()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        return false;
    }
    final ConnectAllHostsToLunCommandReturnValue connectResult = (ConnectAllHostsToLunCommandReturnValue) runInternalAction(VdcActionType.ConnectAllHostsToLun, new ExtendSANStorageDomainParameters(getParameters().getStorageDomainId(), getParameters().getLunIds()));
    if (!connectResult.getSucceeded()) {
        addValidationMessage(EngineMessage.ERROR_CANNOT_EXTEND_CONNECTION_FAILED);
        if (connectResult.getFailedVds() != null) {
            getReturnValue().getValidationMessages().add(String.format("$hostName %1s", connectResult.getFailedVds().getName()));
        }
        String lunId = connectResult.getFailedLun() != null ? connectResult.getFailedLun().getLUNId() : "";
        getReturnValue().getValidationMessages().add(String.format("$lun %1s", lunId));
        return false;
    } else {
        // use luns list from connect command
        getParameters().setLunsList((ArrayList<LUNs>) connectResult.getActionReturnValue());
    }
    return true;
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected boolean validate() {
    super.validate();
    if (isLunsAlreadyInUse(getParameters().getLunIds())) {
        return false;
    }
    if (!(checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getStorageDomain().getStorageType().isBlockDomain()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        return false;
    }
    final ConnectAllHostsToLunCommandReturnValue connectResult = (ConnectAllHostsToLunCommandReturnValue) runInternalAction(VdcActionType.ConnectAllHostsToLun, new ExtendSANStorageDomainParameters(getParameters().getStorageDomainId(), getParameters().getLunIds()));
    if (!connectResult.getSucceeded()) {
        addValidationMessage(EngineMessage.ERROR_CANNOT_EXTEND_CONNECTION_FAILED);
        if (connectResult.getFailedVds() != null) {
            getReturnValue().getValidationMessages().add(String.format("$hostName %1s", connectResult.getFailedVds().getName()));
        }
        String lunId = connectResult.getFailedLun() != null ? connectResult.getFailedLun().getLUNId() : "";
        getReturnValue().getValidationMessages().add(String.format("$lun %1s", lunId));
        return false;
    } else {
        // use luns list from connect command
        getParameters().setLunsList(connectResult.getActionReturnValue());
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!isVmExist()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Arrays.asList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!isVmExist()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Collections.singletonList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#end_block

#method_before
protected boolean checkIfLunDiskCanBeAdded(DiskValidator diskValidator) {
    LunDisk lunDisk = ((LunDisk) getParameters().getDiskInfo());
    LUNs lun = lunDisk.getLun();
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (StorageServerConnections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getIqn()) || StringUtils.isEmpty(conn.getConnection()) || StringUtils.isEmpty(conn.getPort())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
        default:
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUNId()) != null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    if (getVm() != null && !(isVmNotLocked() && isVmNotInPreviewSnapshot())) {
        return false;
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    if (getVds() != null) {
        lunFromStorage = getLunDisk(lun, getVds());
        if (lunFromStorage == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_INVALID);
        }
    }
    if (!validate(diskValidator.isUsingScsiReservationValid(getVm(), lunDisk))) {
        return false;
    }
    return true;
}
#method_after
protected boolean checkIfLunDiskCanBeAdded(DiskValidator diskValidator) {
    LunDisk lunDisk = (LunDisk) getParameters().getDiskInfo();
    LUNs lun = lunDisk.getLun();
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (StorageServerConnections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getIqn()) || StringUtils.isEmpty(conn.getConnection()) || StringUtils.isEmpty(conn.getPort())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
        default:
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUNId()) != null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    if (getVm() != null && !(isVmNotLocked() && isVmNotInPreviewSnapshot())) {
        return false;
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    if (getVds() != null) {
        lunFromStorage = getLunDisk(lun, getVds());
        if (lunFromStorage == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_INVALID);
        }
    }
    if (!validate(diskValidator.isUsingScsiReservationValid(getVm(), lunDisk))) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void createDiskBasedOnLun() {
    final LUNs lun;
    if (lunFromStorage == null) {
        lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    } else {
        lun = lunFromStorage;
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            StorageDomainCommandBase.proceedLUNInDb(lun, lun.getLunType());
            getBaseDiskDao().save(getParameters().getDiskInfo());
            getDiskLunMapDao().save(new DiskLunMap(getParameters().getDiskInfo().getId(), lun.getLUNId()));
            if (getVm() != null) {
                addManagedDeviceForDisk(getParameters().getDiskInfo().getId(), ((LunDisk) getParameters().getDiskInfo()).isUsingScsiReservation());
            }
            return null;
        }
    });
    getReturnValue().setActionReturnValue(getParameters().getDiskInfo().getId());
    plugDiskToVmIfNeeded();
    setSucceeded(true);
}
#method_after
private void createDiskBasedOnLun() {
    final LUNs lun;
    if (lunFromStorage == null) {
        lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    } else {
        lun = lunFromStorage;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        StorageDomainCommandBase.proceedLUNInDb(lun, lun.getLunType());
        getBaseDiskDao().save(getParameters().getDiskInfo());
        getDiskLunMapDao().save(new DiskLunMap(getParameters().getDiskInfo().getId(), lun.getLUNId()));
        if (getVm() != null) {
            addManagedDeviceForDisk(getParameters().getDiskInfo().getId(), ((LunDisk) getParameters().getDiskInfo()).isUsingScsiReservation());
        }
        return null;
    });
    getReturnValue().setActionReturnValue(getParameters().getDiskInfo().getId());
    plugDiskToVmIfNeeded();
    setSucceeded(true);
}
#end_block

#method_before
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (isExecutedAsChildCommand()) {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    } else {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    ArrayList<Guid> taskList = isExecutedAsChildCommand() ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
    taskList.addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        getCompensationContext().snapshotNewEntity(addManagedDeviceForDisk(getParameters().getDiskInfo().getId()));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (isExecutedAsChildCommand()) {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    } else {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    ArrayList<Guid> taskList = isExecutedAsChildCommand() ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
    taskList.addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        getCompensationContext().snapshotNewEntity(addManagedDeviceForDisk(getParameters().getDiskInfo().getId()));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
private VdcActionParametersBase buildAddCinderDiskParameters() {
    AddDiskParameters parameters = new AddDiskParameters();
    parameters.setDiskInfo(getParameters().getDiskInfo());
    parameters.setPlugDiskToVm(getParameters().getPlugDiskToVm());
    parameters.setVmId(getParameters().getVmId());
    parameters.setStorageDomainId(getParameters().getStorageDomainId());
    parameters.setQuotaId(getQuotaId());
    if (getVm() != null) {
        parameters.setVmSnapshotId(getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE));
    }
    return parameters;
}
#method_after
private VdcActionParametersBase buildAddCinderDiskParameters() {
    AddDiskParameters parameters = new AddDiskParameters();
    parameters.setDiskInfo(getParameters().getDiskInfo());
    parameters.setPlugDiskToVm(getParameters().getPlugDiskToVm());
    parameters.setVmId(getParameters().getVmId());
    parameters.setStorageDomainId(getParameters().getStorageDomainId());
    parameters.setQuotaId(getQuotaId());
    parameters.setShouldBeEndedByParent(false);
    if (getVm() != null) {
        parameters.setVmSnapshotId(getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE));
    }
    return parameters;
}
#end_block

#method_before
private StorageFormatType updatePoolAndDomainsFormat(final Version spVersion) {
    final StoragePool storagePool = getStoragePool();
    final StorageFormatType targetFormat = VersionStorageFormatUtil.getPreferredForVersion(spVersion, getMasterDomain() == null ? null : getMasterDomain().getStorageType());
    storagePool.setCompatibilityVersion(spVersion);
    storagePool.setStoragePoolFormatType(targetFormat);
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getStoragePoolDao().updatePartial(storagePool);
            updateMemberDomainsFormat(targetFormat);
            if (FeatureSupported.ovfStoreOnAnyDomain(spVersion)) {
                getVmStaticDao().incrementDbGenerationForAllInStoragePool(storagePool.getId());
            }
            return null;
        }
    });
    return targetFormat;
}
#method_after
private StorageFormatType updatePoolAndDomainsFormat(final Version spVersion) {
    final StoragePool storagePool = getStoragePool();
    final StorageFormatType targetFormat = VersionStorageFormatUtil.getPreferredForVersion(spVersion, getMasterDomain() == null ? null : getMasterDomain().getStorageType());
    storagePool.setCompatibilityVersion(spVersion);
    storagePool.setStoragePoolFormatType(targetFormat);
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, () -> {
        getStoragePoolDao().updatePartial(storagePool);
        updateMemberDomainsFormat(targetFormat);
        if (FeatureSupported.ovfStoreOnAnyDomain(spVersion)) {
            getVmStaticDao().incrementDbGenerationForAllInStoragePool(storagePool.getId());
        }
        return null;
    });
    return targetFormat;
}
#end_block

#method_before
protected boolean checkAllClustersLevel() {
    boolean returnValue = true;
    List<VDSGroup> clusters = getVdsGroupDao().getAllForStoragePool(getStoragePool().getId());
    List<String> lowLevelClusters = new ArrayList<>();
    for (VDSGroup cluster : clusters) {
        if (getStoragePool().getCompatibilityVersion().compareTo(cluster.getCompatibilityVersion()) > 0) {
            lowLevelClusters.add(cluster.getName());
        }
    }
    if (!lowLevelClusters.isEmpty()) {
        returnValue = false;
        getReturnValue().getValidationMessages().add(String.format("$ClustersList %1$s", StringUtils.join(lowLevelClusters, ",")));
        getReturnValue().getValidationMessages().add(EngineMessage.ERROR_CANNOT_UPDATE_STORAGE_POOL_COMPATIBILITY_VERSION_BIGGER_THAN_CLUSTERS.toString());
    }
    return returnValue;
}
#method_after
protected boolean checkAllClustersLevel() {
    boolean returnValue = true;
    List<Cluster> clusters = getClusterDao().getAllForStoragePool(getStoragePool().getId());
    List<String> lowLevelClusters = new ArrayList<>();
    for (Cluster cluster : clusters) {
        if (getStoragePool().getCompatibilityVersion().compareTo(cluster.getCompatibilityVersion()) > 0) {
            lowLevelClusters.add(cluster.getName());
        }
    }
    if (!lowLevelClusters.isEmpty()) {
        returnValue = false;
        getReturnValue().getValidationMessages().add(String.format("$ClustersList %1$s", StringUtils.join(lowLevelClusters, ",")));
        getReturnValue().getValidationMessages().add(EngineMessage.ERROR_CANNOT_UPDATE_STORAGE_POOL_COMPATIBILITY_VERSION_BIGGER_THAN_CLUSTERS.toString());
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getParameters().isSkipChecks()) {
        return true;
    }
    if (!(checkStorageDomain())) {
        return false;
    }
    // when the execution is internal, proceed also if the domain is in unknown status.
    if (!((getParameters().getIsInternal() && checkStorageDomainStatus(StorageDomainStatus.Active, StorageDomainStatus.Unknown)) || checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getParameters().getIsInternal() && getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        List<StorageDomain> domains = getStorageDomainDao().getAllForStoragePool(getStorageDomain().getStoragePoolId());
        List<StorageDomain> activeDomains = filterDomainsByStatus(domains, StorageDomainStatus.Active);
        List<StorageDomain> dataDomains = activeDomains.stream().filter(d -> d.getStorageDomainType() == StorageDomainType.Data).collect(Collectors.toList());
        if (!activeDomains.isEmpty() && dataDomains.isEmpty()) {
            return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_NON_DATA_DOMAINS);
        }
        List<StorageDomain> busyDomains = domains.stream().filter(d -> d.getStatus().isStorageDomainInProcess()).collect(Collectors.toList());
        if (!busyDomains.isEmpty()) {
            return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_LOCKED_DOMAINS);
        }
    }
    if (!isRunningVmsWithIsoAttached()) {
        return false;
    }
    if (!getParameters().getIsInternal() && !getVmDao().getAllActiveForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DETECTED_ACTIVE_VMS);
    }
    if (getStoragePool().getSpmVdsId() != null) {
        // In case there are running tasks in the pool, it is impossible to deactivate the master storage domain
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(getStorageDomain().getStoragePoolId()).size() > 0) {
            return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_MASTER_DOMAIN_WITH_TASKS_ON_POOL);
        } else if (getStorageDomain().getStorageDomainType() != StorageDomainType.ISO && !getParameters().getIsInternal() && (getAsyncTaskDao().getAsyncTaskIdsByEntity(getParameters().getStorageDomainId()).size() > 0 || getCommandEntityDao().getCommandIdsByEntity(getParameters().getStorageDomainId()).size() > 0)) {
            return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_TASKS);
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getParameters().isSkipChecks()) {
        return true;
    }
    if (!checkStorageDomain()) {
        return false;
    }
    // when the execution is internal, proceed also if the domain is in unknown status.
    if (!((getParameters().getIsInternal() && checkStorageDomainStatus(StorageDomainStatus.Active, StorageDomainStatus.Unknown)) || checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getParameters().getIsInternal() && getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        List<StorageDomain> domains = getStorageDomainDao().getAllForStoragePool(getStorageDomain().getStoragePoolId());
        List<StorageDomain> activeDomains = filterDomainsByStatus(domains, StorageDomainStatus.Active);
        List<StorageDomain> dataDomains = activeDomains.stream().filter(d -> d.getStorageDomainType() == StorageDomainType.Data).collect(Collectors.toList());
        if (!activeDomains.isEmpty() && dataDomains.isEmpty()) {
            return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_NON_DATA_DOMAINS);
        }
        List<StorageDomain> busyDomains = domains.stream().filter(d -> d.getStatus().isStorageDomainInProcess()).collect(Collectors.toList());
        if (!busyDomains.isEmpty()) {
            return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_LOCKED_DOMAINS);
        }
    }
    if (!isRunningVmsWithIsoAttached()) {
        return false;
    }
    if (!getParameters().getIsInternal() && !getVmDao().getAllActiveForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DETECTED_ACTIVE_VMS);
    }
    if (getStoragePool().getSpmVdsId() != null) {
        // In case there are running tasks in the pool, it is impossible to deactivate the master storage domain
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(getStorageDomain().getStoragePoolId()).size() > 0) {
            return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_MASTER_DOMAIN_WITH_TASKS_ON_POOL);
        } else if (getStorageDomain().getStorageDomainType() != StorageDomainType.ISO && !getParameters().getIsInternal() && (getAsyncTaskDao().getAsyncTaskIdsByEntity(getParameters().getStorageDomainId()).size() > 0 || getCommandEntityDao().getCommandIdsByEntity(getParameters().getStorageDomainId()).size() > 0)) {
            return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_TASKS);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (isCinderStorageDomain()) {
        deactivateCinderStorageDomain();
        return;
    }
    final StoragePoolIsoMap map = getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setStatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, getParameters().isInactive() ? StorageDomainStatus.Locked : StorageDomainStatus.PreparingForMaintenance);
    final StorageDomain newMaster;
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        newMaster = electNewMaster();
        isLastMaster = proceedStorageDomainTreatmentByDomainType(newMaster, true);
    } else {
        newMaster = null;
        isLastMaster = false;
    }
    final Guid newMasterId = newMaster != null ? newMaster.getId() : Guid.Empty;
    if (isLastMaster) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getStoragePool());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePoolDao().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
        getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
        getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
    }
    if (!getParameters().isInactive()) {
        runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), newMasterId, getStoragePool().getMasterDomainVersion()));
    }
    freeLock();
    VDS spm = null;
    if (getStoragePool().getSpmVdsId() != null) {
        spm = getVdsDao().get(getStoragePool().getSpmVdsId());
    }
    if (isLastMaster) {
        if (spm != null) {
            final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
            if (!stopSpmReturnValue.getSucceeded()) {
                // no need to continue because DisconnectStoragePool will
                // fail if host is SPM
                log.error("Aborting execution due to failure to stop SPM");
                setSucceeded(false);
                return;
            }
            runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
        }
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    }
    if (!getParameters().isInactive()) {
        getEventQueue().submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), null, EventType.POOLREFRESH, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), isLastMaster, newMasterId);
                return null;
            }
        });
        if (spm != null) {
            getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
        }
    }
    executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            if (getParameters().isInactive()) {
                map.setStatus(StorageDomainStatus.Inactive);
            } else if (isLastMaster) {
                map.setStatus(StorageDomainStatus.Maintenance);
            } else {
                log.info("Domain '{}' will remain in '{}' status until deactivated on all hosts", getStorageDomain().getId(), map.getStatus());
            }
            getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getStatus());
            if (newMaster != null) {
                StoragePoolIsoMap mapOfNewMaster = newMaster.getStoragePoolIsoMapData();
                mapOfNewMaster.setStatus(StorageDomainStatus.Active);
                getStoragePoolIsoMapDao().updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getStatus());
            }
            return null;
        }
    });
    if (!getParameters().isSkipChecks()) {
        notifyAsyncTasks();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (isCinderStorageDomain()) {
        deactivateCinderStorageDomain();
        return;
    }
    final StoragePoolIsoMap map = getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setStatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, getParameters().isInactive() ? StorageDomainStatus.Locked : StorageDomainStatus.PreparingForMaintenance);
    final StorageDomain newMaster;
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        newMaster = electNewMaster();
        isLastMaster = proceedStorageDomainTreatmentByDomainType(newMaster, true);
    } else {
        newMaster = null;
        isLastMaster = false;
    }
    final Guid newMasterId = newMaster != null ? newMaster.getId() : Guid.Empty;
    if (isLastMaster) {
        executeInNewTransaction(() -> {
            getCompensationContext().snapshotEntityStatus(getStoragePool());
            getStoragePool().setStatus(StoragePoolStatus.Maintenance);
            getStoragePoolDao().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
            getCompensationContext().stateChanged();
            return null;
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
        getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
        getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
    }
    if (!getParameters().isInactive()) {
        runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), newMasterId, getStoragePool().getMasterDomainVersion()));
    }
    freeLock();
    VDS spm = null;
    if (getStoragePool().getSpmVdsId() != null) {
        spm = getVdsDao().get(getStoragePool().getSpmVdsId());
    }
    if (isLastMaster) {
        if (spm != null) {
            final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
            if (!stopSpmReturnValue.getSucceeded()) {
                // no need to continue because DisconnectStoragePool will
                // fail if host is SPM
                log.error("Aborting execution due to failure to stop SPM");
                setSucceeded(false);
                return;
            }
            runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
        }
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    }
    if (!getParameters().isInactive()) {
        getEventQueue().submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), null, EventType.POOLREFRESH, ""), () -> {
            runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), isLastMaster, newMasterId);
            return null;
        });
        if (spm != null) {
            getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
        }
    }
    executeInNewTransaction(() -> {
        if (getParameters().isInactive()) {
            map.setStatus(StorageDomainStatus.Inactive);
        } else if (isLastMaster) {
            map.setStatus(StorageDomainStatus.Maintenance);
        } else {
            log.info("Domain '{}' will remain in '{}' status until deactivated on all hosts", getStorageDomain().getId(), map.getStatus());
        }
        getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getStatus());
        if (newMaster != null) {
            StoragePoolIsoMap mapOfNewMaster = newMaster.getStoragePoolIsoMapData();
            mapOfNewMaster.setStatus(StorageDomainStatus.Active);
            getStoragePoolIsoMapDao().updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getStatus());
        }
        return null;
    });
    if (!getParameters().isSkipChecks()) {
        notifyAsyncTasks();
    }
    setSucceeded(true);
}
#end_block

#method_before
protected boolean proceedStorageDomainTreatmentByDomainType(final StorageDomain newMaster, final boolean lockNewMaster) {
    if (newMaster == null) {
        return true;
    }
    newMaster.getStorageStaticData().setLastTimeUsedAsMaster(System.currentTimeMillis());
    if (newMaster.getStorageDomainType() != StorageDomainType.Master) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                StoragePoolIsoMap newMasterMap = newMaster.getStoragePoolIsoMapData();
                getCompensationContext().snapshotEntityUpdated(newMaster.getStorageStaticData());
                newMaster.setStorageDomainType(StorageDomainType.Master);
                if (lockNewMaster) {
                    newMasterMap.setStatus(StorageDomainStatus.Unknown);
                    getCompensationContext().snapshotEntityStatus(newMasterMap);
                    newMaster.setStatus(StorageDomainStatus.Locked);
                    getStoragePoolIsoMapDao().updateStatus(newMasterMap.getId(), newMasterMap.getStatus());
                }
                updateStorageDomainStaticData(newMaster.getStorageStaticData());
                getCompensationContext().snapshotEntityUpdated(getStorageDomain().getStorageStaticData());
                getStorageDomain().setStorageDomainType(StorageDomainType.Data);
                updateStorageDomainStaticData(getStorageDomain().getStorageStaticData());
                getCompensationContext().stateChanged();
                return null;
            }
        });
    } else {
        updateStorageDomainStaticData(newMaster.getStorageStaticData());
    }
    updateStoragePoolMasterDomainVersionInDiffTransaction();
    return false;
}
#method_after
protected boolean proceedStorageDomainTreatmentByDomainType(final StorageDomain newMaster, final boolean lockNewMaster) {
    if (newMaster == null) {
        return true;
    }
    newMaster.getStorageStaticData().setLastTimeUsedAsMaster(System.currentTimeMillis());
    if (newMaster.getStorageDomainType() != StorageDomainType.Master) {
        executeInNewTransaction(() -> {
            StoragePoolIsoMap newMasterMap = newMaster.getStoragePoolIsoMapData();
            getCompensationContext().snapshotEntityUpdated(newMaster.getStorageStaticData());
            newMaster.setStorageDomainType(StorageDomainType.Master);
            if (lockNewMaster) {
                newMasterMap.setStatus(StorageDomainStatus.Unknown);
                getCompensationContext().snapshotEntityStatus(newMasterMap);
                newMaster.setStatus(StorageDomainStatus.Locked);
                getStoragePoolIsoMapDao().updateStatus(newMasterMap.getId(), newMasterMap.getStatus());
            }
            updateStorageDomainStaticData(newMaster.getStorageStaticData());
            getCompensationContext().snapshotEntityUpdated(getStorageDomain().getStorageStaticData());
            getStorageDomain().setStorageDomainType(StorageDomainType.Data);
            updateStorageDomainStaticData(getStorageDomain().getStorageStaticData());
            getCompensationContext().stateChanged();
            return null;
        });
    } else {
        updateStorageDomainStaticData(newMaster.getStorageStaticData());
    }
    updateStoragePoolMasterDomainVersionInDiffTransaction();
    return false;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getParameters().getIsInternal() ? getSucceeded() ? AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN : AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED : getSucceeded() ? (isLastMaster ? AuditLogType.USER_DEACTIVATED_LAST_MASTER_STORAGE_DOMAIN : AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN) : AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return getParameters().getIsInternal() ? getSucceeded() ? AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN : AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED : getSucceeded() ? isLastMaster ? AuditLogType.USER_DEACTIVATED_LAST_MASTER_STORAGE_DOMAIN : AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN : AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (isCinderStorageDomain()) {
            handleCinderDomain();
            return;
        }
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDao().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                connectHostsInUpToDomainStorageServer();
                // Forcibly detach only data storage domains.
                if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                    @SuppressWarnings("unchecked")
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                    // If the storage domain is already related to another Storage Pool, detach it by force.
                    Guid storagePoolId = domainFromIrs.getSecond();
                    if (storagePoolId != null) {
                        if (FeatureSupported.importDataStorageDomain(getStoragePool().getCompatibilityVersion())) {
                            // Master domain version is not relevant since force remove at
                            // DetachStorageDomainVdsCommand does not use it.
                            // Storage pool id can be empty
                            DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getStoragePoolIdFromVds(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                            detachParams.setForce(true);
                            detachParams.setDetachFromOldStoragePool(true);
                            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                            if (!returnValue.getSucceeded()) {
                                log.warn("Detaching Storage Domain '{}' from it's previous storage pool '{}'" + " has failed. The meta data of the Storage Domain might still" + " indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                                throw new EngineException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : EngineError.ENGINE, returnValue.getExceptionString());
                            }
                        }
                    }
                    createDefaultDiskProfile();
                }
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk(getParameters().getStorageDomainId(), getStoragePoolIdFromVds());
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                        map.setStatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getStatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        updateStorageDomainFormatIfNeeded(getStorageDomain());
                        List<DiskImage> ovfStoreDiskImages = getAllOVFDisks(getParameters().getStorageDomainId(), getStoragePoolIdFromVds());
                        registerAllOvfDisks(ovfStoreDiskImages, getParameters().getStorageDomainId());
                        // Update unregistered entities
                        for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                            getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                            getUnregisteredOVFDataDao().saveOVFData(ovf);
                            log.info("Adding OVF data of entity id '{}' and entity name '{}'", ovf.getEntityId(), ovf.getEntityName());
                        }
                        return null;
                    }
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (isCinderStorageDomain()) {
            handleCinderDomain();
            return;
        }
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Arrays.asList(getStorageDomain().getId()), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                getReturnValue().setFault(returnValue.getFault());
            }
        } else {
            map = getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(() -> {
                    map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                    getStoragePoolIsoMapDao().save(map);
                    getCompensationContext().snapshotNewEntity(map);
                    getCompensationContext().stateChanged();
                    return null;
                });
                connectHostsInUpToDomainStorageServer();
                // Forcibly detach only data storage domains.
                if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                    @SuppressWarnings("unchecked")
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                    // If the storage domain is already related to another Storage Pool, detach it by force.
                    Guid storagePoolId = domainFromIrs.getSecond();
                    if (storagePoolId != null) {
                        if (FeatureSupported.importDataStorageDomain(getStoragePool().getCompatibilityVersion())) {
                            // Master domain version is not relevant since force remove at
                            // DetachStorageDomainVdsCommand does not use it.
                            // Storage pool id can be empty
                            DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getStoragePoolIdFromVds(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                            detachParams.setForce(true);
                            detachParams.setDetachFromOldStoragePool(true);
                            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                            if (!returnValue.getSucceeded()) {
                                log.warn("Detaching Storage Domain '{}' from it's previous storage pool '{}'" + " has failed. The meta data of the Storage Domain might still" + " indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                                throw new EngineException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : EngineError.ENGINE, returnValue.getExceptionString());
                            }
                        }
                    }
                    createDefaultDiskProfile();
                }
                runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = getEntitiesFromStorageOvfDisk(getParameters().getStorageDomainId(), getStoragePoolIdFromVds());
                executeInNewTransaction(() -> {
                    final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                    map.setStatus(StorageDomainStatus.Maintenance);
                    getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getStatus());
                    if (sdType == StorageDomainType.Master) {
                        calcStoragePoolStatusByDomainsStatus();
                    }
                    // upgrade the domain format to the storage pool format
                    updateStorageDomainFormatIfNeeded(getStorageDomain());
                    List<DiskImage> ovfStoreDiskImages = getAllOVFDisks(getParameters().getStorageDomainId(), getStoragePoolIdFromVds());
                    registerAllOvfDisks(ovfStoreDiskImages, getParameters().getStorageDomainId());
                    // Update unregistered entities
                    for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                        getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                        getUnregisteredOVFDataDao().saveOVFData(ovf);
                        log.info("Adding OVF data of entity id '{}' and entity name '{}'", ovf.getEntityId(), ovf.getEntityName());
                    }
                    return null;
                });
                if (getParameters().getActivate()) {
                    attemptToActivateDomain();
                }
                setSucceeded(true);
            }
        }
    }
}
#end_block

#method_before
private void createDefaultDiskProfile() {
    if (FeatureSupported.storageQoS(getStoragePool().getCompatibilityVersion()) && getDiskProfileDao().getAllForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        final DiskProfile diskProfile = DiskProfileHelper.createDiskProfile(getStorageDomain().getId(), getStorageDomainName());
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Void runInTransaction() {
                getDiskProfileDao().save(diskProfile);
                getCompensationContext().snapshotNewEntity(diskProfile);
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
}
#method_after
private void createDefaultDiskProfile() {
    if (FeatureSupported.storageQoS(getStoragePool().getCompatibilityVersion()) && getDiskProfileDao().getAllForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        final DiskProfile diskProfile = DiskProfileHelper.createDiskProfile(getStorageDomain().getId(), getStorageDomainName());
        executeInNewTransaction(() -> {
            getDiskProfileDao().save(diskProfile);
            getCompensationContext().snapshotNewEntity(diskProfile);
            getCompensationContext().stateChanged();
            return null;
        });
    }
}
#end_block

#method_before
private void removeDataCenter() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(getStoragePool());
            getStoragePoolDao().remove(getStoragePool().getId());
            getCompensationContext().stateChanged();
            return null;
        }
    });
}
#method_after
private void removeDataCenter() {
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(getStoragePool());
        getStoragePoolDao().remove(getStoragePool().getId());
        getCompensationContext().stateChanged();
        return null;
    });
}
#end_block

#method_before
private void removeNetworks() {
    final List<Network> networks = getNetworkDao().getAllForDataCenter(getStoragePoolId());
    for (Network network : networks) {
        if (network.isExternal()) {
            for (VmNic nic : getVmNicDao().getAllForNetwork(network.getId())) {
                new ExternalNetworkManager(nic, network).deallocateIfExternal();
            }
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (final Network net : networks) {
                List<VnicProfile> profiles = getDbFacade().getVnicProfileDao().getAllForNetwork(net.getId());
                for (VnicProfile vnicProfile : profiles) {
                    getCompensationContext().snapshotEntity(vnicProfile);
                    getDbFacade().getVnicProfileDao().remove(vnicProfile.getId());
                }
                getCompensationContext().snapshotEntity(net);
                getNetworkDao().remove(net.getId());
            }
            getCompensationContext().stateChanged();
            return null;
        }
    });
}
#method_after
private void removeNetworks() {
    final List<Network> networks = getNetworkDao().getAllForDataCenter(getStoragePoolId());
    for (Network network : networks) {
        if (network.isExternal()) {
            for (VmNic nic : getVmNicDao().getAllForNetwork(network.getId())) {
                new ExternalNetworkManager(nic, network).deallocateIfExternal();
            }
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        for (final Network net : networks) {
            List<VnicProfile> profiles = getDbFacade().getVnicProfileDao().getAllForNetwork(net.getId());
            for (VnicProfile vnicProfile : profiles) {
                getCompensationContext().snapshotEntity(vnicProfile);
                getDbFacade().getVnicProfileDao().remove(vnicProfile.getId());
            }
            getCompensationContext().snapshotEntity(net);
            getNetworkDao().remove(net.getId());
        }
        getCompensationContext().stateChanged();
        return null;
    });
}
#end_block

#method_before
private boolean regularRemoveStorageDomains(List<StorageDomain> storageDomains) {
    boolean retVal = true;
    final StorageDomain masterDomain = storageDomains.stream().filter(s -> s.getStorageDomainType() == StorageDomainType.Master).findFirst().orElse(null);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(masterDomain.getStoragePoolIsoMapData());
            masterDomain.setStatus(StorageDomainStatus.Locked);
            getDbFacade().getStoragePoolIsoMapDao().update(masterDomain.getStoragePoolIsoMapData());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // destroying a pool is an SPM action. We need to connect all hosts
    // to the pool. Later on, during spm election, one of the hosts will
    // lock the pool
    // and the spm status will be FREE. Only then we can invoke the
    // destroy verb.
    connectAllHostToPoolAndDomain(masterDomain);
    List<VDS> vdss = getAllRunningVdssInPool();
    for (StorageDomain storageDomain : storageDomains) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            if (!removeDomainFromPool(storageDomain, vdss.get(0))) {
                log.error("Unable to detach storage domain '{}' '{}'", storageDomain.getStorageName(), storageDomain.getId());
                retVal = false;
            }
        }
    }
    handleDestroyStoragePoolCommand();
    handleMasterDomain(masterDomain);
    runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    setSucceeded(true);
    if (!getStoragePool().isLocal()) {
        for (VDS vds : vdss) {
            StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vds.getId());
        }
    } else {
        try {
            runVdsCommand(VDSCommandType.FormatStorageDomain, new FormatStorageDomainVDSCommandParameters(vdss.get(0).getId(), masterDomain.getId()));
        } catch (EngineException e) {
        // Do nothing, exception already printed at logs
        }
        StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vdss.get(0).getId());
        removeDomainFromDb(masterDomain);
    }
    return retVal;
}
#method_after
private boolean regularRemoveStorageDomains(List<StorageDomain> storageDomains) {
    boolean retVal = true;
    final StorageDomain masterDomain = storageDomains.stream().filter(s -> s.getStorageDomainType() == StorageDomainType.Master).findFirst().orElse(null);
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(masterDomain.getStoragePoolIsoMapData());
        masterDomain.setStatus(StorageDomainStatus.Locked);
        getDbFacade().getStoragePoolIsoMapDao().update(masterDomain.getStoragePoolIsoMapData());
        getCompensationContext().stateChanged();
        return null;
    });
    // destroying a pool is an SPM action. We need to connect all hosts
    // to the pool. Later on, during spm election, one of the hosts will
    // lock the pool
    // and the spm status will be FREE. Only then we can invoke the
    // destroy verb.
    connectAllHostToPoolAndDomain(masterDomain);
    List<VDS> vdss = getAllRunningVdssInPool();
    for (StorageDomain storageDomain : storageDomains) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            if (!removeDomainFromPool(storageDomain, vdss.get(0))) {
                log.error("Unable to detach storage domain '{}' '{}'", storageDomain.getStorageName(), storageDomain.getId());
                retVal = false;
            }
        }
    }
    handleDestroyStoragePoolCommand();
    handleMasterDomain(masterDomain);
    runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    setSucceeded(true);
    if (!getStoragePool().isLocal()) {
        for (VDS vds : vdss) {
            StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vds.getId());
        }
    } else {
        try {
            runVdsCommand(VDSCommandType.FormatStorageDomain, new FormatStorageDomainVDSCommandParameters(vdss.get(0).getId(), masterDomain.getId()));
        } catch (EngineException e) {
        // Do nothing, exception already printed at logs
        }
        StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vdss.get(0).getId());
        removeDomainFromDb(masterDomain);
    }
    return retVal;
}
#end_block

#method_before
private void handleMasterDomain(StorageDomain masterDomain) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            detachStorageDomainWithEntities(masterDomain);
            getCompensationContext().snapshotEntity(masterDomain.getStorageStaticData());
            masterDomain.setStorageDomainType(StorageDomainType.Data);
            getDbFacade().getStorageDomainStaticDao().update(masterDomain.getStorageStaticData());
            getCompensationContext().stateChanged();
            return null;
        }
    });
}
#method_after
private void handleMasterDomain(StorageDomain masterDomain) {
    TransactionSupport.executeInNewTransaction(() -> {
        detachStorageDomainWithEntities(masterDomain);
        getCompensationContext().snapshotEntity(masterDomain.getStorageStaticData());
        masterDomain.setStorageDomainType(StorageDomainType.Data);
        getDbFacade().getStorageDomainStaticDao().update(masterDomain.getStorageStaticData());
        getCompensationContext().stateChanged();
        return null;
    });
}
#end_block

#method_before
private void handleDestroyStoragePoolCommand() {
    try {
        runVdsCommand(VDSCommandType.DestroyStoragePool, new IrsBaseVDSCommandParameters(getStoragePool().getId()));
    } catch (EngineException e) {
        try {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
                    return null;
                }
            });
        } catch (Exception e1) {
            log.error("Failed destroy storage pool with id '{}' and after that failed to stop spm: {}", getStoragePoolId(), e1.getMessage());
            log.debug("Exception", e1);
        }
        throw e;
    }
}
#method_after
private void handleDestroyStoragePoolCommand() {
    try {
        runVdsCommand(VDSCommandType.DestroyStoragePool, new IrsBaseVDSCommandParameters(getStoragePool().getId()));
    } catch (EngineException e) {
        try {
            TransactionSupport.executeInNewTransaction(() -> {
                runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
                return null;
            });
        } catch (Exception e1) {
            log.error("Failed destroy storage pool with id '{}' and after that failed to stop spm: {}", getStoragePoolId(), e1.getMessage());
            log.debug("Exception", e1);
        }
        throw e;
    }
}
#end_block

#method_before
private void removeDomainFromDb(final StorageDomain domain) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            // Not compensation for remove domain as we don't want
            // to rollback a deleted domain - it will only cause more
            // problems if a domain got deleted in VDSM and not in backend
            // as it will be impossible to remove it.
            StorageHelperDirector.getInstance().getItem(domain.getStorageType()).storageDomainRemoved(domain.getStorageStaticData());
            getStorageDomainDao().remove(domain.getId());
            return null;
        }
    });
}
#method_after
private void removeDomainFromDb(final StorageDomain domain) {
    TransactionSupport.executeInNewTransaction(() -> {
        // Not compensation for remove domain as we don't want
        // to rollback a deleted domain - it will only cause more
        // problems if a domain got deleted in VDSM and not in backend
        // as it will be impossible to remove it.
        StorageHelperDirector.getInstance().getItem(domain.getStorageType()).storageDomainRemoved(domain.getStorageStaticData());
        getStorageDomainDao().remove(domain.getId());
        return null;
    });
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (DiskImage disk : disks) {
                // we force export template image to COW+Sparse but we don't update
                // the ovf so the import
                // will set the original format
                MoveOrCopyImageGroupParameters p = new MoveOrCopyImageGroupParameters(containerID, disk.getId(), disk.getImageId(), getParameters().getStorageDomainId(), getMoveOrCopyImageOperation());
                p.setParentCommand(getActionType());
                p.setParentParameters(getParameters());
                p.setEntityInfo(getParameters().getEntityInfo());
                p.setUseCopyCollapse(true);
                p.setCopyVolumeType(CopyVolumeType.SharedVol);
                p.setVolumeFormat(disk.getVolumeFormat());
                p.setVolumeType(disk.getVolumeType());
                p.setForceOverride(getParameters().getForceOverride());
                p.setRevertDbOperationScope(ImageDbOperationScope.NONE);
                p.setShouldLockImageOnRevert(false);
                p.setSourceDomainId(imageFromSourceDomainMap.get(disk.getId()).getStorageIds().get(0));
                VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, p);
                if (!vdcRetValue.getSucceeded()) {
                    throw new EngineException(vdcRetValue.getFault().getError(), vdcRetValue.getFault().getMessage());
                }
                getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
            }
            return null;
        }
    });
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(() -> {
        for (DiskImage disk : disks) {
            // we force export template image to COW+Sparse but we don't update
            // the ovf so the import
            // will set the original format
            MoveOrCopyImageGroupParameters p = new MoveOrCopyImageGroupParameters(containerID, disk.getId(), disk.getImageId(), getParameters().getStorageDomainId(), getMoveOrCopyImageOperation());
            p.setParentCommand(getActionType());
            p.setParentParameters(getParameters());
            p.setEntityInfo(getParameters().getEntityInfo());
            p.setUseCopyCollapse(true);
            p.setCopyVolumeType(CopyVolumeType.SharedVol);
            p.setVolumeFormat(disk.getVolumeFormat());
            p.setVolumeType(disk.getVolumeType());
            p.setForceOverride(getParameters().getForceOverride());
            p.setRevertDbOperationScope(ImageDbOperationScope.NONE);
            p.setShouldLockImageOnRevert(false);
            p.setSourceDomainId(imageFromSourceDomainMap.get(disk.getId()).getStorageIds().get(0));
            VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, p);
            if (!vdcRetValue.getSucceeded()) {
                throw new EngineException(vdcRetValue.getFault().getError(), vdcRetValue.getFault().getMessage());
            }
            getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        }
        return null;
    });
}
#end_block

#method_before
@Override
protected boolean validate() {
    FenceValidator fenceValidator = new FenceValidator();
    List<String> messages = getReturnValue().getValidationMessages();
    boolean valid = fenceValidator.isHostExists(getVds(), messages) && fenceValidator.isPowerManagementEnabledAndLegal(getVds(), getVdsGroup(), messages) && fenceValidator.isStartupTimeoutPassed(messages) && isQuietTimeFromLastActionPassed() && fenceValidator.isProxyHostAvailable(getVds(), messages);
    if (!valid) {
        handleError();
    }
    getReturnValue().setSucceeded(valid);
    return valid;
}
#method_after
@Override
protected boolean validate() {
    FenceValidator fenceValidator = new FenceValidator();
    List<String> messages = getReturnValue().getValidationMessages();
    boolean valid = fenceValidator.isHostExists(getVds(), messages) && fenceValidator.isPowerManagementEnabledAndLegal(getVds(), getCluster(), messages) && fenceValidator.isStartupTimeoutPassed(messages) && isQuietTimeFromLastActionPassed() && fenceValidator.isProxyHostAvailable(getVds(), messages);
    if (!valid) {
        handleError();
    }
    getReturnValue().setSucceeded(valid);
    return valid;
}
#end_block

#method_before
protected boolean isQuietTimeFromLastActionPassed() {
    // Check Quiet time between PM operations, this is done only if command is not internal.
    int secondsLeftToNextPmOp = (isInternalExecution()) ? 0 : DbFacade.getInstance().getAuditLogDao().getTimeToWaitForNextPmOp(getVds().getName(), AuditLogType.USER_VDS_RESTART.name());
    if (secondsLeftToNextPmOp > 0) {
        addValidationMessage(EngineMessage.VDS_FENCE_DISABLED_AT_QUIET_TIME);
        addValidationMessageVariable("seconds", secondsLeftToNextPmOp);
        return false;
    } else {
        return true;
    }
}
#method_after
protected boolean isQuietTimeFromLastActionPassed() {
    // Check Quiet time between PM operations, this is done only if command is not internal.
    int secondsLeftToNextPmOp = isInternalExecution() ? 0 : DbFacade.getInstance().getAuditLogDao().getTimeToWaitForNextPmOp(getVds().getName(), AuditLogType.USER_VDS_RESTART.name());
    if (secondsLeftToNextPmOp > 0) {
        addValidationMessage(EngineMessage.VDS_FENCE_DISABLED_AT_QUIET_TIME);
        addValidationMessageVariable("seconds", secondsLeftToNextPmOp);
        return false;
    } else {
        return true;
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (isCinderStorageDomain()) {
        activateCinderStorageDomain();
        return;
    }
    final StoragePoolIsoMap map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    // Master domain must not go through the Activating status.
    changeStorageDomainStatusInTransaction(map, (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) ? StorageDomainStatus.Locked : StorageDomainStatus.Activating);
    freeLock();
    log.info("ActivateStorage Domain. Before Connect all hosts to pool. Time: {}", new Date());
    List<Pair<Guid, Boolean>> hostsConnectionResults = connectHostsInUpToDomainStorageServer();
    if (isAllHostConnectionFailed(hostsConnectionResults)) {
        log.error("Cannot connect storage server, aborting Storage Domain activation.");
        setSucceeded(false);
        return;
    }
    syncStorageDomainInfo(hostsConnectionResults);
    runVdsCommand(VDSCommandType.ActivateStorageDomain, new ActivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId()));
    log.info("ActivateStorage Domain. After Connect all hosts to pool. Time: {}", new Date());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            map.setStatus(StorageDomainStatus.Active);
            DbFacade.getInstance().getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getStatus());
            if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
                calcStoragePoolStatusByDomainsStatus();
            }
            return null;
        }
    });
    refreshAllVdssInPool();
    log.info("ActivateStorage Domain. After change storage pool status in vds. Time: {}", new Date());
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
        IsoDomainListSyncronizer.getInstance().refresheIsoDomainWhenActivateDomain(getStorageDomain().getId(), getStoragePool().getId());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (isCinderStorageDomain()) {
        activateCinderStorageDomain();
        return;
    }
    final StoragePoolIsoMap map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    // Master domain must not go through the Activating status.
    changeStorageDomainStatusInTransaction(map, (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) ? StorageDomainStatus.Locked : StorageDomainStatus.Activating);
    freeLock();
    log.info("ActivateStorage Domain. Before Connect all hosts to pool. Time: {}", new Date());
    List<Pair<Guid, Boolean>> hostsConnectionResults = connectHostsInUpToDomainStorageServer();
    if (isAllHostConnectionFailed(hostsConnectionResults)) {
        log.error("Cannot connect storage server, aborting Storage Domain activation.");
        setSucceeded(false);
        return;
    }
    syncStorageDomainInfo(hostsConnectionResults);
    runVdsCommand(VDSCommandType.ActivateStorageDomain, new ActivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId()));
    log.info("ActivateStorage Domain. After Connect all hosts to pool. Time: {}", new Date());
    TransactionSupport.executeInNewTransaction(() -> {
        map.setStatus(StorageDomainStatus.Active);
        DbFacade.getInstance().getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getStatus());
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
            calcStoragePoolStatusByDomainsStatus();
        }
        return null;
    });
    refreshAllVdssInPool();
    log.info("ActivateStorage Domain. After change storage pool status in vds. Time: {}", new Date());
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
        IsoDomainListSyncronizer.getInstance().refresheIsoDomainWhenActivateDomain(getStorageDomain().getId(), getStoragePool().getId());
    }
    setSucceeded(true);
}
#end_block

#method_before
private void refreshAllVdssInPool() {
    final List<Guid> vdsIdsToSetNonOperational = new ArrayList<>();
    getEventQueue().submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), null, EventType.POOLREFRESH, ""), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            runSynchronizeOperation(new RefreshPoolSingleAsyncOperationFactory(), vdsIdsToSetNonOperational);
            return null;
        }
    });
    for (Guid vdsId : vdsIdsToSetNonOperational) {
        Map<String, String> customLogValues = Collections.singletonMap("StorageDomainNames", getStorageDomainName());
        SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(vdsId, STORAGE_DOMAIN_UNREACHABLE, customLogValues);
        tempVar.setStorageDomainId(getStorageDomain().getId());
        tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        runInternalAction(VdcActionType.SetNonOperationalVds, tempVar, ExecutionHandler.createInternalJobContext(getContext()));
    }
}
#method_after
private void refreshAllVdssInPool() {
    final List<Guid> vdsIdsToSetNonOperational = new ArrayList<>();
    getEventQueue().submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), null, EventType.POOLREFRESH, ""), () -> {
        runSynchronizeOperation(new RefreshPoolSingleAsyncOperationFactory(), vdsIdsToSetNonOperational);
        return null;
    });
    for (Guid vdsId : vdsIdsToSetNonOperational) {
        Map<String, String> customLogValues = Collections.singletonMap("StorageDomainNames", getStorageDomainName());
        SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(vdsId, STORAGE_DOMAIN_UNREACHABLE, customLogValues);
        tempVar.setStorageDomainId(getStorageDomain().getId());
        tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        runInternalAction(VdcActionType.SetNonOperationalVds, tempVar, ExecutionHandler.createInternalJobContext(getContext()));
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    StorageDomain newMasterDomain = loadTargetedMasterDomain();
    if (StorageHelperDirector.getInstance().getItem(newMasterDomain.getStorageType()).connectStorageToDomainByVdsId(newMasterDomain, getVds().getId())) {
        getEventQueue().submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getNewMasterDomainId(), null, EventType.RECOVERY, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                getParameters().setStorageDomainId(getMasterDomainIdFromDb());
                StoragePoolIsoMap domainPoolMap = new StoragePoolIsoMap(getParameters().getNewMasterDomainId(), getParameters().getStoragePoolId(), StorageDomainStatus.Active);
                DbFacade.getInstance().getStoragePoolIsoMapDao().save(domainPoolMap);
                getParameters().setVdsId(getVds().getId());
                VdcReturnValueBase returnVal = runInternalAction(VdcActionType.ReconstructMasterDomain, getParameters(), cloneContextAndDetachFromParent());
                boolean reconstructVerbExecuted = (returnVal.getActionReturnValue() != null) ? (Boolean) returnVal.getActionReturnValue() : false;
                getStoragePoolDao().updateStatus(getStoragePool().getId(), StoragePoolStatus.NonResponsive);
                if (!reconstructVerbExecuted) {
                    getStoragePoolIsoMapDao().remove(domainPoolMap.getId());
                }
                if (returnVal.getSucceeded()) {
                    updateStorageDomainFormatIfNeeded(loadTargetedMasterDomain());
                }
                setSucceeded(returnVal.getSucceeded());
                return new EventResult(reconstructVerbExecuted, EventType.RECONSTRUCT);
            }
        });
    } else {
        getReturnValue().setFault(new EngineFault(new EngineException(EngineError.StorageServerConnectionError, "Failed to connect storage"), EngineError.StorageServerConnectionError));
    }
}
#method_after
@Override
protected void executeCommand() {
    StorageDomain newMasterDomain = loadTargetedMasterDomain();
    if (StorageHelperDirector.getInstance().getItem(newMasterDomain.getStorageType()).connectStorageToDomainByVdsId(newMasterDomain, getVds().getId())) {
        getEventQueue().submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getNewMasterDomainId(), null, EventType.RECOVERY, ""), () -> {
            getParameters().setStorageDomainId(getMasterDomainIdFromDb());
            StoragePoolIsoMap domainPoolMap = new StoragePoolIsoMap(getParameters().getNewMasterDomainId(), getParameters().getStoragePoolId(), StorageDomainStatus.Active);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(domainPoolMap);
            getParameters().setVdsId(getVds().getId());
            VdcReturnValueBase returnVal = runInternalAction(VdcActionType.ReconstructMasterDomain, getParameters(), cloneContextAndDetachFromParent());
            boolean reconstructVerbExecuted = (returnVal.getActionReturnValue() != null) ? (Boolean) returnVal.getActionReturnValue() : false;
            getStoragePoolDao().updateStatus(getStoragePool().getId(), StoragePoolStatus.NonResponsive);
            if (!reconstructVerbExecuted) {
                getStoragePoolIsoMapDao().remove(domainPoolMap.getId());
            }
            if (returnVal.getSucceeded()) {
                updateStorageDomainFormatIfNeeded(loadTargetedMasterDomain());
            }
            setSucceeded(returnVal.getSucceeded());
            return new EventResult(reconstructVerbExecuted, EventType.RECONSTRUCT);
        });
    } else {
        getReturnValue().setFault(new EngineFault(new EngineException(EngineError.StorageServerConnectionError, "Failed to connect storage"), EngineError.StorageServerConnectionError));
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    attachNetwork(getVdsGroupId(), getNetworkCluster(), getNetwork());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    attachNetwork(getClusterId(), getNetworkCluster(), getNetwork());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean validate() {
    return networkNotAttachedToCluster() && vdsGroupExists() && changesAreClusterCompatible() && logicalNetworkExists() && validateAttachment();
}
#method_after
@Override
protected boolean validate() {
    return networkNotAttachedToCluster() && clusterExists() && changesAreClusterCompatible() && logicalNetworkExists() && validateAttachment();
}
#end_block

#method_before
private boolean validateAttachment() {
    final AttachNetworkClusterValidator attachNetworkClusterValidator = createNetworkClusterValidator();
    return validate(attachNetworkClusterValidator.networkBelongsToClusterDataCenter(getVdsGroup(), getPersistedNetwork())) && validateAttachment(attachNetworkClusterValidator);
}
#method_after
private boolean validateAttachment() {
    final AttachNetworkClusterValidator attachNetworkClusterValidator = createNetworkClusterValidator();
    return validate(attachNetworkClusterValidator.networkBelongsToClusterDataCenter(getCluster(), getPersistedNetwork())) && validateAttachment(attachNetworkClusterValidator);
}
#end_block

#method_before
private Version getClusterVersion() {
    return getVdsGroup().getCompatibilityVersion();
}
#method_after
private Version getClusterVersion() {
    return getCluster().getCompatibilityVersion();
}
#end_block

#method_before
private boolean changesAreClusterCompatible() {
    if (!getParameters().getNetwork().isVmNetwork()) {
        if (!FeatureSupported.nonVmNetwork(getVdsGroup().getCompatibilityVersion())) {
            addValidationMessage(EngineMessage.NON_VM_NETWORK_NOT_SUPPORTED_FOR_POOL_LEVEL);
            return false;
        }
    }
    return true;
}
#method_after
private boolean changesAreClusterCompatible() {
    if (!getParameters().getNetwork().isVmNetwork()) {
        if (!FeatureSupported.nonVmNetwork(getCluster().getCompatibilityVersion())) {
            addValidationMessage(EngineMessage.NON_VM_NETWORK_NOT_SUPPORTED_FOR_POOL_LEVEL);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void attachNetwork(Guid clusterId, NetworkCluster networkCluster, Network network) {
    getNetworkClusterDao().save(new NetworkCluster(clusterId, network.getId(), NetworkStatus.OPERATIONAL, false, networkCluster.isRequired(), false, false, false));
    List<VDS> hosts = vdsDao.getAllForVdsGroup(clusterId);
    List<Network> clusterNetworks = networkDao.getAllForCluster(clusterId);
    for (VDS host : hosts) {
        HostNetworkAttachmentsPersister persister = new HostNetworkAttachmentsPersister(this.networkAttachmentDao, host.getId(), interfaceDao.getAllInterfacesForVds(host.getId()), new CustomPropertiesForVdsNetworkInterface(), Collections.<NetworkAttachment>emptyList(), clusterNetworks);
        persister.persistNetworkAttachments();
    }
    if (network.getCluster().isDisplay()) {
        final DisplayNetworkClusterHelper displayNetworkClusterHelper = new DisplayNetworkClusterHelper(getNetworkClusterDao(), getVmDao(), networkCluster, network.getName(), auditLogDirector);
        if (displayNetworkClusterHelper.isDisplayToBeUpdated()) {
            displayNetworkClusterHelper.warnOnActiveVm();
        }
        getNetworkClusterDao().setNetworkExclusivelyAsDisplay(clusterId, network.getId());
    }
    if (network.getCluster().isMigration()) {
        getNetworkClusterDao().setNetworkExclusivelyAsMigration(clusterId, network.getId());
    }
    NetworkClusterHelper.setStatus(clusterId, network);
}
#method_after
private void attachNetwork(Guid clusterId, NetworkCluster networkCluster, Network network) {
    getNetworkClusterDao().save(new NetworkCluster(clusterId, network.getId(), NetworkStatus.OPERATIONAL, false, networkCluster.isRequired(), false, false, false));
    List<VDS> hosts = vdsDao.getAllForCluster(clusterId);
    List<Network> clusterNetworks = networkDao.getAllForCluster(clusterId);
    for (VDS host : hosts) {
        HostNetworkAttachmentsPersister persister = new HostNetworkAttachmentsPersister(this.networkAttachmentDao, host.getId(), interfaceDao.getAllInterfacesForVds(host.getId()), new CustomPropertiesForVdsNetworkInterface(), Collections.<NetworkAttachment>emptyList(), clusterNetworks);
        persister.persistNetworkAttachments();
    }
    if (network.getCluster().isDisplay()) {
        final DisplayNetworkClusterHelper displayNetworkClusterHelper = new DisplayNetworkClusterHelper(getNetworkClusterDao(), getVmDao(), networkCluster, network.getName(), auditLogDirector);
        if (displayNetworkClusterHelper.isDisplayToBeUpdated()) {
            displayNetworkClusterHelper.warnOnActiveVm();
        }
        getNetworkClusterDao().setNetworkExclusivelyAsDisplay(clusterId, network.getId());
    }
    if (network.getCluster().isMigration()) {
        getNetworkClusterDao().setNetworkExclusivelyAsMigration(clusterId, network.getId());
    }
    NetworkClusterHelper.setStatus(clusterId, network);
}
#end_block

#method_before
@Override
protected String getDescription() {
    String networkName = getNetworkName() == null ? "" : getNetworkName();
    String clusterName = getVdsGroup() == null ? "" : getVdsGroup().getName();
    return networkName + " - " + clusterName;
}
#method_after
@Override
protected String getDescription() {
    String networkName = getNetworkName() == null ? "" : getNetworkName();
    String clusterName = getCluster() == null ? "" : getCluster().getName();
    return networkName + " - " + clusterName;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP : AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.NETWORK_ATTACH_NETWORK_TO_CLUSTER : AuditLogType.NETWORK_ATTACH_NETWORK_TO_CLUSTER_FAILED;
}
#end_block

#method_before
@Override
protected boolean validate() {
    oldHost = getVdsDao().get(getVdsId());
    UpdateHostValidator validator = new UpdateHostValidator(getDbFacade(), oldHost, getParameters().getvds(), getParameters().isInstallHost());
    return validate(validator.hostExists()) && validate(validator.hostStatusValid()) && validate(validator.nameNotEmpty()) && validate(validator.nameLengthIsLegal()) && validate(validator.updateHostAddressAllowed()) && validate(validator.nameNotUsed()) && validate(validator.hostNameNotUsed()) && validate(validator.statusSupportedForHostInstallation()) && validate(validator.passwordProvidedForHostInstallation(getParameters().getAuthMethod(), getParameters().getPassword())) && validate(validator.updatePortAllowed()) && validate(validator.clusterNotChanged()) && validate(validator.changeProtocolAllowed()) && validate(validator.hostProviderExists()) && validate(validator.hostProviderTypeMatches()) && validateNetworkProviderConfiguration() && isPowerManagementLegal(getParameters().getVdsStaticData().isPmEnabled(), getParameters().getFenceAgents(), oldHost.getVdsGroupCompatibilityVersion().toString()) && validate(validator.protocolIsNotXmlrpc(getVdsGroup()));
}
#method_after
@Override
protected boolean validate() {
    oldHost = getVdsDao().get(getVdsId());
    UpdateHostValidator validator = new UpdateHostValidator(getDbFacade(), oldHost, getParameters().getvds(), getParameters().isInstallHost());
    return validate(validator.hostExists()) && validate(validator.hostStatusValid()) && validate(validator.nameNotEmpty()) && validate(validator.nameLengthIsLegal()) && validate(validator.updateHostAddressAllowed()) && validate(validator.nameNotUsed()) && validate(validator.hostNameNotUsed()) && validate(validator.statusSupportedForHostInstallation()) && validate(validator.passwordProvidedForHostInstallation(getParameters().getAuthMethod(), getParameters().getPassword())) && validate(validator.updatePortAllowed()) && validate(validator.clusterNotChanged()) && validate(validator.changeProtocolAllowed()) && validate(validator.hostProviderExists()) && validate(validator.hostProviderTypeMatches()) && validateNetworkProviderConfiguration() && isPowerManagementLegal(getParameters().getVdsStaticData().isPmEnabled(), getParameters().getFenceAgents(), oldHost.getClusterCompatibilityVersion().toString()) && validate(validator.protocolIsNotXmlrpc(getCluster()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateVdsData();
    if (needToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().isInstallHost()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().isReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        if (getVdsDao().get(getVdsId()).getStatus() == VDSStatus.InstallingOS) {
            // TODO: remove hack when reinstall api will provider override-firewall parameter.
            // https://bugzilla.redhat.com/show_bug.cgi?id=1177126 - for now we override firewall
            // configurations on each deploy for provisioned host to avoid wrong deployment.
            tempVar.setOverrideFirewall(true);
        } else {
            tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        }
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setActivateHost(getParameters().getActivateHost());
        tempVar.setNetworkProviderId(getParameters().getNetworkProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        ArrayList<VdcReturnValueBase> resultList = runInternalMultipleActions(actionType, new ArrayList<>(Arrays.asList(tempVar)));
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            VdcReturnValueBase vdcReturnValueBase = resultList.get(0);
            if (vdcReturnValueBase != null && !vdcReturnValueBase.isValid()) {
                ArrayList<String> validationMessages = vdcReturnValueBase.getValidationMessages();
                if (!validationMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getValidationMessages().addAll(validationMessages);
                    log.error("Installation/upgrade of Host '{}', '{}' failed: {}", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().translateErrorText(validationMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setValid(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(oldHost.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    // set clusters network to be operational (if needed)
    if (oldHost.getStatus() == VDSStatus.Up) {
        List<NetworkCluster> networkClusters = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(oldHost.getVdsGroupId());
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(oldHost.getVdsGroupId());
        for (NetworkCluster item : networkClusters) {
            for (Network net : networks) {
                if (net.getId().equals(item.getNetworkId())) {
                    NetworkClusterHelper.setStatus(oldHost.getVdsGroupId(), net);
                }
            }
        }
    }
    alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    testVdsPowerManagementStatus(getParameters().getVdsStaticData());
    checkKdumpIntegrationStatus();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    updateVdsData();
    if (needToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().isInstallHost()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().isReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        if (getVdsDao().get(getVdsId()).getStatus() == VDSStatus.InstallingOS) {
            // TODO: remove hack when reinstall api will provider override-firewall parameter.
            // https://bugzilla.redhat.com/show_bug.cgi?id=1177126 - for now we override firewall
            // configurations on each deploy for provisioned host to avoid wrong deployment.
            tempVar.setOverrideFirewall(true);
        } else {
            tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        }
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setActivateHost(getParameters().getActivateHost());
        tempVar.setNetworkProviderId(getParameters().getNetworkProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        ArrayList<VdcReturnValueBase> resultList = runInternalMultipleActions(actionType, new ArrayList<>(Arrays.asList(tempVar)));
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            VdcReturnValueBase vdcReturnValueBase = resultList.get(0);
            if (vdcReturnValueBase != null && !vdcReturnValueBase.isValid()) {
                ArrayList<String> validationMessages = vdcReturnValueBase.getValidationMessages();
                if (!validationMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getValidationMessages().addAll(validationMessages);
                    log.error("Installation/upgrade of Host '{}', '{}' failed: {}", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().translateErrorText(validationMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setValid(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(oldHost.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    // set clusters network to be operational (if needed)
    if (oldHost.getStatus() == VDSStatus.Up) {
        List<NetworkCluster> networkClusters = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(oldHost.getClusterId());
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(oldHost.getClusterId());
        for (NetworkCluster item : networkClusters) {
            for (Network net : networks) {
                if (net.getId().equals(item.getNetworkId())) {
                    NetworkClusterHelper.setStatus(oldHost.getClusterId(), net);
                }
            }
        }
    }
    alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    testVdsPowerManagementStatus(getParameters().getVdsStaticData());
    checkKdumpIntegrationStatus();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new EngineException(EngineError.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVdsStaticToDb();
            addVdsDynamicToDb();
            addVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getParameters().isProvisioned()) {
        HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(getHostProvider()));
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword(), getParameters().getDiscoverIp());
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVds(getParameters().getvds());
        logable.addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        auditLogDirector.log(logable, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(true);
            alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            testVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().isPending() && !getParameters().isProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setNetworkProviderId(getParameters().getNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        installVdsParameters.setEnableSerialConsole(getParameters().getEnableSerialConsole());
        Map<String, String> values = new HashMap<>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(() -> runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx)));
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new EngineException(EngineError.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVdsStaticToDb();
        addVdsDynamicToDb();
        addVdsStatisticsToDb();
        getCompensationContext().stateChanged();
        return null;
    });
    if (getParameters().isProvisioned()) {
        HostProviderProxy proxy = ProviderProxyFactory.getInstance().create(getHostProvider());
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword(), getParameters().getDiscoverIp());
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVds(getParameters().getvds());
        logable.addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        auditLogDirector.log(logable, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getCluster().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        initializeVds(true);
        alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
        testVdsPowerManagementStatus(getParameters().getVdsStaticData());
        setSucceeded(true);
        setActionReturnValue(getVdsIdRef());
        // If the installation failed, we don't want to compensate for the failure since it will remove the
        // host, but instead the host should be left in an "install failed" status.
        getCompensationContext().resetCompensation();
        return null;
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().isPending() && !getParameters().isProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setNetworkProviderId(getParameters().getNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        installVdsParameters.setEnableSerialConsole(getParameters().getEnableSerialConsole());
        Map<String, String> values = new HashMap<>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(() -> runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx)));
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
protected boolean isGlusterSupportEnabled() {
    return getVdsGroup() != null && getVdsGroup().supportsGlusterService() && getParameters().isGlusterPeerProbeNeeded();
}
#method_after
protected boolean isGlusterSupportEnabled() {
    return getCluster() != null && getCluster().supportsGlusterService() && getParameters().isGlusterPeerProbeNeeded();
}
#end_block

#method_before
private boolean removeDeprecatedOvirtEntry(final Guid oVirtId) {
    final VDS vds = DbFacade.getInstance().getVdsDao().get(oVirtId);
    if (vds == null || !VdsHandler.isPendingOvirt(vds)) {
        return false;
    }
    String vdsName = getParameters().getVdsStaticData().getName();
    log.info("Host '{}', id '{}' of type '{}' is being re-registered as Host '{}'", vds.getName(), vds.getId(), vds.getVdsType().name(), vdsName);
    VdcReturnValueBase result = TransactionSupport.executeInNewTransaction(new TransactionMethod<VdcReturnValueBase>() {

        @Override
        public VdcReturnValueBase runInTransaction() {
            return runInternalAction(VdcActionType.RemoveVds, new RemoveVdsParameters(oVirtId));
        }
    });
    if (!result.getSucceeded()) {
        String errors = result.isValid() ? result.getFault().getError().name() : StringUtils.join(result.getValidationMessages(), ",");
        log.warn("Failed to remove Host '{}', id '{}', re-registering it as Host '{}' fails with errors {}", vds.getName(), vds.getId(), vdsName, errors);
    } else {
        log.info("Host '{}' is now known as Host '{}'", vds.getName(), vdsName);
    }
    return result.getSucceeded();
}
#method_after
private boolean removeDeprecatedOvirtEntry(final Guid oVirtId) {
    final VDS vds = DbFacade.getInstance().getVdsDao().get(oVirtId);
    if (vds == null || !VdsHandler.isPendingOvirt(vds)) {
        return false;
    }
    String vdsName = getParameters().getVdsStaticData().getName();
    log.info("Host '{}', id '{}' of type '{}' is being re-registered as Host '{}'", vds.getName(), vds.getId(), vds.getVdsType().name(), vdsName);
    VdcReturnValueBase result = TransactionSupport.executeInNewTransaction(() -> runInternalAction(VdcActionType.RemoveVds, new RemoveVdsParameters(oVirtId)));
    if (!result.getSucceeded()) {
        String errors = result.isValid() ? result.getFault().getError().name() : StringUtils.join(result.getValidationMessages(), ",");
        log.warn("Failed to remove Host '{}', id '{}', re-registering it as Host '{}' fails with errors {}", vds.getName(), vds.getId(), vdsName, errors);
    } else {
        log.info("Host '{}' is now known as Host '{}'", vds.getName(), vdsName);
    }
    return result.getSucceeded();
}
#end_block

#method_before
private void addVdsStaticToDb() {
    getParameters().getVdsStaticData().setServerSslEnabled(Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication));
    VdsStatic vdsStatic = getParameters().getVdsStaticData();
    if (vdsStatic.getProtocol() == null) {
        VDSGroup cluster = getVdsGroup();
        if (cluster != null && FeatureSupported.jsonProtocol(cluster.getCompatibilityVersion())) {
            vdsStatic.setProtocol(VdsProtocol.STOMP);
        } else {
            vdsStatic.setProtocol(VdsProtocol.XML);
        }
    }
    DbFacade.getInstance().getVdsStaticDao().save(getParameters().getVdsStaticData());
    getCompensationContext().snapshotNewEntity(getParameters().getVdsStaticData());
    setVdsIdRef(getParameters().getVdsStaticData().getId());
    addFenceAgents();
    setVds(null);
}
#method_after
private void addVdsStaticToDb() {
    getParameters().getVdsStaticData().setServerSslEnabled(Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication));
    VdsStatic vdsStatic = getParameters().getVdsStaticData();
    if (vdsStatic.getProtocol() == null) {
        Cluster cluster = getCluster();
        if (cluster != null && FeatureSupported.jsonProtocol(cluster.getCompatibilityVersion())) {
            vdsStatic.setProtocol(VdsProtocol.STOMP);
        } else {
            vdsStatic.setProtocol(VdsProtocol.XML);
        }
    }
    DbFacade.getInstance().getVdsStaticDao().save(getParameters().getVdsStaticData());
    getCompensationContext().snapshotNewEntity(getParameters().getVdsStaticData());
    setVdsIdRef(getParameters().getVdsStaticData().getId());
    addFenceAgents();
    setVds(null);
}
#end_block

#method_before
@Override
protected boolean validate() {
    T params = getParameters();
    setVdsGroupId(params.getVdsStaticData().getVdsGroupId());
    params.setVdsForUniqueId(null);
    // Check if this is a valid cluster
    boolean returnValue = validateVdsGroup();
    if (returnValue) {
        HostValidator validator = getHostValidator();
        returnValue = validate(validator.nameNotEmpty()) && validate(validator.nameLengthIsLegal()) && validate(validator.hostNameIsValid()) && validate(validator.nameNotUsed()) && validate(validator.hostNameNotUsed()) && validate(validator.portIsValid()) && validate(validator.sshUserNameNotEmpty()) && validate(validator.validateSingleHostAttachedToLocalStorage()) && validate(validator.securityKeysExists()) && validate(validator.provisioningComputeResourceValid(params.isProvisioned(), params.getComputeResource())) && validate(validator.provisioningHostGroupValid(params.isProvisioned(), params.getHostGroup())) && validate(validator.passwordNotEmpty(params.isPending(), params.getAuthMethod(), params.getPassword())) && validate(validator.protocolIsNotXmlrpc(getVdsGroup()));
    }
    if (!(returnValue && isPowerManagementLegal(params.getVdsStaticData().isPmEnabled(), params.getFenceAgents(), getVdsGroup().getCompatibilityVersion().toString()) && canConnect(params.getvds()))) {
        return false;
    }
    if (params.getNetworkProviderId() != null && !validateNetworkProviderProperties(params.getNetworkProviderId(), params.getNetworkMappings())) {
        return false;
    }
    if (isGlusterSupportEnabled() && clusterHasNonInitializingServers()) {
        // allow simultaneous installation of hosts, but if a host has completed install, only
        // allow addition of another host if it can be peer probed to cluster.
        VDS upServer = getClusterUtils().getUpServer(getVdsGroupId());
        if (upServer == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    T params = getParameters();
    setClusterId(params.getVdsStaticData().getClusterId());
    params.setVdsForUniqueId(null);
    // Check if this is a valid cluster
    boolean returnValue = validateCluster();
    if (returnValue) {
        HostValidator validator = getHostValidator();
        returnValue = validate(validator.nameNotEmpty()) && validate(validator.nameLengthIsLegal()) && validate(validator.hostNameIsValid()) && validate(validator.nameNotUsed()) && validate(validator.hostNameNotUsed()) && validate(validator.portIsValid()) && validate(validator.sshUserNameNotEmpty()) && validate(validator.validateSingleHostAttachedToLocalStorage()) && validate(validator.securityKeysExists()) && validate(validator.provisioningComputeResourceValid(params.isProvisioned(), params.getComputeResource())) && validate(validator.provisioningHostGroupValid(params.isProvisioned(), params.getHostGroup())) && validate(validator.passwordNotEmpty(params.isPending(), params.getAuthMethod(), params.getPassword())) && validate(validator.protocolIsNotXmlrpc(getCluster()));
    }
    if (!(returnValue && isPowerManagementLegal(params.getVdsStaticData().isPmEnabled(), params.getFenceAgents(), getCluster().getCompatibilityVersion().toString()) && canConnect(params.getvds()))) {
        return false;
    }
    if (params.getNetworkProviderId() != null && !validateNetworkProviderProperties(params.getNetworkProviderId(), params.getNetworkMappings())) {
        return false;
    }
    if (isGlusterSupportEnabled() && clusterHasNonInitializingServers()) {
        // allow simultaneous installation of hosts, but if a host has completed install, only
        // allow addition of another host if it can be peer probed to cluster.
        VDS upServer = getClusterUtils().getUpServer(getClusterId());
        if (upServer == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
        }
    }
    return true;
}
#end_block

#method_before
private boolean clusterHasServers() {
    return getClusterUtils().hasServers(getVdsGroupId());
}
#method_after
private boolean clusterHasServers() {
    return getClusterUtils().hasServers(getClusterId());
}
#end_block

#method_before
private boolean clusterHasNonInitializingServers() {
    for (VDS vds : getVdsDao().getAllForVdsGroup(getVdsGroupId())) {
        if (vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.InstallingOS && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.Initializing && vds.getStatus() != VDSStatus.InstallFailed)
            return true;
    }
    return false;
}
#method_after
private boolean clusterHasNonInitializingServers() {
    for (VDS vds : getVdsDao().getAllForCluster(getClusterId())) {
        if (vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.InstallingOS && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.Initializing && vds.getStatus() != VDSStatus.InstallFailed) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
protected boolean canConnect(VDS vds) {
    // execute the connectivity and id uniqueness validation for VDS type hosts
    if (!getParameters().isPending() && !getParameters().isProvisioned() && Config.<Boolean>getValue(ConfigValues.InstallVds)) {
        try (final EngineSSHClient sshclient = getSSHClient()) {
            sshclient.connect();
            sshclient.authenticate();
            String hostUUID = getInstalledVdsIdIfExists(sshclient);
            if (hostUUID != null && getVdsDao().getAllWithUniqueId(hostUUID).size() != 0) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_VDS_WITH_SAME_UUID_EXIST);
            }
            return isValidGlusterPeer(sshclient, vds.getVdsGroupId());
        } catch (AuthenticationException e) {
            log.error("Failed to authenticate session with host '{}': {}", vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return failValidation(EngineMessage.VDS_CANNOT_AUTHENTICATE_TO_SERVER);
        } catch (SecurityException e) {
            log.error("Failed to connect to host '{}', fingerprint '{}': {}", vds.getName(), vds.getSshKeyFingerprint(), e.getMessage());
            log.debug("Exception", e);
            addValidationMessage(EngineMessage.VDS_SECURITY_CONNECTION_ERROR);
            addValidationMessageVariable("ErrorMessage", e.getMessage());
            return failValidation(EngineMessage.VDS_CANNOT_AUTHENTICATE_TO_SERVER);
        } catch (Exception e) {
            log.error("Failed to establish session with host '{}': {}", vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return failValidation(EngineMessage.VDS_CANNOT_CONNECT_TO_SERVER);
        }
    }
    return true;
}
#method_after
protected boolean canConnect(VDS vds) {
    // execute the connectivity and id uniqueness validation for VDS type hosts
    if (!getParameters().isPending() && !getParameters().isProvisioned() && Config.<Boolean>getValue(ConfigValues.InstallVds)) {
        try (final EngineSSHClient sshclient = getSSHClient()) {
            sshclient.connect();
            sshclient.authenticate();
            String hostUUID = getInstalledVdsIdIfExists(sshclient);
            if (hostUUID != null && getVdsDao().getAllWithUniqueId(hostUUID).size() != 0) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_VDS_WITH_SAME_UUID_EXIST);
            }
            return isValidGlusterPeer(sshclient, vds.getClusterId());
        } catch (AuthenticationException e) {
            log.error("Failed to authenticate session with host '{}': {}", vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return failValidation(EngineMessage.VDS_CANNOT_AUTHENTICATE_TO_SERVER);
        } catch (SecurityException e) {
            log.error("Failed to connect to host '{}', fingerprint '{}': {}", vds.getName(), vds.getSshKeyFingerprint(), e.getMessage());
            log.debug("Exception", e);
            addValidationMessage(EngineMessage.VDS_SECURITY_CONNECTION_ERROR);
            addValidationMessageVariable("ErrorMessage", e.getMessage());
            return failValidation(EngineMessage.VDS_CANNOT_AUTHENTICATE_TO_SERVER);
        } catch (Exception e) {
            log.error("Failed to establish session with host '{}': {}", vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return failValidation(EngineMessage.VDS_CANNOT_CONNECT_TO_SERVER);
        }
    }
    return true;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, getActionType().getActionGroup()));
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(getClusterId(), VdcObjectType.Cluster, getActionType().getActionGroup()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setVdsName(problematicVds.getName());
    if (problematicVds.getSpmStatus() == VdsSpmStatus.SPM) {
        activateDataCenter();
    }
    if ((getParameters()).getClearVMs()) {
        VdsActionParameters tempVar = new VdsActionParameters(problematicVds.getId());
        tempVar.setSessionId(getParameters().getSessionId());
        runInternalActionWithTasksContext(VdcActionType.ClearNonResponsiveVdsVms, tempVar);
    }
    setSucceeded(true);
    // Remove all alerts except NOT CONFIG alert
    AlertDirector.removeAllVdsAlerts(problematicVds.getId(), false);
}
#method_after
@Override
protected void executeCommand() {
    setVdsName(problematicVds.getName());
    if (problematicVds.getSpmStatus() == VdsSpmStatus.SPM) {
        activateDataCenter();
    }
    if (getParameters().getClearVMs()) {
        VdsActionParameters tempVar = new VdsActionParameters(problematicVds.getId());
        tempVar.setSessionId(getParameters().getSessionId());
        runInternalActionWithTasksContext(VdcActionType.ClearNonResponsiveVdsVms, tempVar);
    }
    setSucceeded(true);
    // Remove all alerts except NOT CONFIG alert
    AlertDirector.removeAllVdsAlerts(problematicVds.getId(), false);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
    freeLock();
    // update vm init
    VmHandler.updateVmInitFromDB(getVm().getStaticData(), true);
    // immediately after the execution of the previous steps
    if (!hasSnappableDisks() && snapshotsWithMemory.isEmpty()) {
        endSuccessfully();
    } else {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                moveOrCopyAllImageGroups();
                return null;
            }
        });
        if (!getReturnValue().getVdsmTaskIdList().isEmpty()) {
            setSucceeded(true);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
    freeLock();
    // update vm init
    VmHandler.updateVmInitFromDB(getVm().getStaticData(), true);
    // immediately after the execution of the previous steps
    if (!hasSnappableDisks() && snapshotsWithMemory.isEmpty()) {
        endSuccessfully();
    } else {
        TransactionSupport.executeInNewTransaction(() -> {
            moveOrCopyAllImageGroups();
            return null;
        });
        if (!getReturnValue().getVdsmTaskIdList().isEmpty()) {
            setSucceeded(true);
        }
    }
}
#end_block

#method_before
private void restoreVmConfigFromSnapshot() {
    getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(getSnapshotDao().getId(getVm().getId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED), SnapshotStatus.OK);
    snapshotsManager.attempToRestoreVmConfigurationFromSnapshot(getVm(), getDstSnapshot(), getSnapshotDao().getId(getVm().getId(), SnapshotType.ACTIVE), getImagesToPreview(), getCompensationContext(), getVm().getVdsGroupCompatibilityVersion(), getCurrentUser());
}
#method_after
private void restoreVmConfigFromSnapshot() {
    getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(getSnapshotDao().getId(getVm().getId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED), SnapshotStatus.OK);
    snapshotsManager.attempToRestoreVmConfigurationFromSnapshot(getVm(), getDstSnapshot(), getSnapshotDao().getId(getVm().getId(), SnapshotType.ACTIVE), getImagesToPreview(), getCompensationContext(), getVm().getClusterCompatibilityVersion(), getCurrentUser());
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = getParameters().isRestoreMemory() && FeatureSupported.memorySnapshot(getVm().getVdsGroupCompatibilityVersion()) && FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getVdsGroupCompatibilityVersion());
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(previousActiveSnapshot);
            getSnapshotDao().remove(previousActiveSnapshotId);
            snapshotsManager.addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), previousActiveSnapshot.getMemoryVolume(), getCompensationContext());
            snapshotsManager.addActiveSnapshot(newActiveSnapshotId, getVm(), restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, images, getCompensationContext());
            // being executed in the same transaction so we can restore the vm config and end the command.
            if (!filteredImages.isEmpty()) {
                getCompensationContext().stateChanged();
            } else {
                getVmStaticDao().incrementDbGeneration(getVm().getId());
                restoreVmConfigFromSnapshot();
            }
            return null;
        }
    });
    if (!filteredImages.isEmpty()) {
        VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = getParameters().isRestoreMemory() && FeatureSupported.memorySnapshot(getVm().getClusterCompatibilityVersion()) && FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getClusterCompatibilityVersion());
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(previousActiveSnapshot);
        getSnapshotDao().remove(previousActiveSnapshotId);
        snapshotsManager.addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), previousActiveSnapshot.getMemoryVolume(), getCompensationContext());
        snapshotsManager.addActiveSnapshot(newActiveSnapshotId, getVm(), restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, images, getCompensationContext());
        // being executed in the same transaction so we can restore the vm config and end the command.
        if (!filteredImages.isEmpty()) {
            getCompensationContext().stateChanged();
        } else {
            getVmStaticDao().incrementDbGeneration(getVm().getId());
            restoreVmConfigFromSnapshot();
        }
        return null;
    });
    if (!filteredImages.isEmpty()) {
        VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    }
    setSucceeded(true);
}
#end_block

#method_before
private RestoreAllCinderSnapshotsParameters buildCinderChildCommandParameters(List<CinderDisk> cinderDisksToRestore, List<CinderDisk> cinderDisksToRemove, List<CinderDisk> cinderVolumesToRemove, Guid removedSnapshotId) {
    RestoreAllCinderSnapshotsParameters restoreParams = new RestoreAllCinderSnapshotsParameters(getVmId(), cinderDisksToRestore, cinderDisksToRemove, cinderVolumesToRemove);
    restoreParams.setRemovedSnapshotId(removedSnapshotId);
    restoreParams.setSnapshot(getSnapshot());
    restoreParams.setParentHasTasks(!getReturnValue().getVdsmTaskIdList().isEmpty());
    restoreParams.setParentCommand(getActionType());
    restoreParams.setParentParameters(getParameters());
    return withRootCommandInfo(restoreParams);
}
#method_after
private RestoreAllCinderSnapshotsParameters buildCinderChildCommandParameters(List<CinderDisk> cinderDisksToRestore, List<CinderDisk> cinderDisksToRemove, List<CinderDisk> cinderVolumesToRemove, Guid removedSnapshotId) {
    RestoreAllCinderSnapshotsParameters restoreParams = new RestoreAllCinderSnapshotsParameters(getVmId(), cinderDisksToRestore, cinderDisksToRemove, cinderVolumesToRemove);
    restoreParams.setRemovedSnapshotId(removedSnapshotId);
    restoreParams.setSnapshot(getSnapshot());
    restoreParams.setParentHasTasks(!getReturnValue().getVdsmTaskIdList().isEmpty());
    restoreParams.setParentCommand(getActionType());
    restoreParams.setParentParameters(getParameters());
    restoreParams.setShouldBeEndedByParent(false);
    return withRootCommandInfo(restoreParams);
}
#end_block

#method_before
private void restoreConfiguration(Snapshot targetSnapshot) {
    SnapshotsManager snapshotsManager = new SnapshotsManager();
    removedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    snapshotsToRemove.add(removedSnapshotId);
    snapshotsManager.removeAllIllegalDisks(removedSnapshotId, getVmId());
    snapshotsManager.attempToRestoreVmConfigurationFromSnapshot(getVm(), targetSnapshot, targetSnapshot.getId(), null, getCompensationContext(), getVm().getVdsGroupCompatibilityVersion(), getCurrentUser());
    getSnapshotDao().remove(targetSnapshot.getId());
    // add active snapshot with status locked, so that other commands that depend on the VM's snapshots won't run in parallel
    snapshotsManager.addActiveSnapshot(targetSnapshot.getId(), getVm(), SnapshotStatus.LOCKED, targetSnapshot.getMemoryVolume(), getCompensationContext());
}
#method_after
private void restoreConfiguration(Snapshot targetSnapshot) {
    SnapshotsManager snapshotsManager = new SnapshotsManager();
    removedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    snapshotsToRemove.add(removedSnapshotId);
    snapshotsManager.removeAllIllegalDisks(removedSnapshotId, getVmId());
    snapshotsManager.attempToRestoreVmConfigurationFromSnapshot(getVm(), targetSnapshot, targetSnapshot.getId(), null, getCompensationContext(), getVm().getClusterCompatibilityVersion(), getCurrentUser());
    getSnapshotDao().remove(targetSnapshot.getId());
    // add active snapshot with status locked, so that other commands that depend on the VM's snapshots won't run in parallel
    snapshotsManager.addActiveSnapshot(targetSnapshot.getId(), getVm(), SnapshotStatus.LOCKED, targetSnapshot.getMemoryVolume(), getCompensationContext());
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    if (!validate(snapshotValidator.snapshotExists(getSnapshot())) || !validate(snapshotValidator.snapshotExists(getVmId(), getSnapshot().getId())) || !validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    if (Guid.Empty.equals(getSnapshot().getId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    VmValidator vmValidator = createVmValidator(getVm());
    MultipleStorageDomainsValidator storageValidator = createStorageDomainValidator();
    if (!validate(storageValidator.allDomainsExistAndActive()) || !validate(storageValidator.allDomainsWithinThresholds()) || !performImagesChecks() || !validate(vmValidator.vmDown()) || // if the user choose to commit a snapshot the vm can't have disk snapshots attached to other vms.
    (getSnapshot()).getType() == SnapshotType.REGULAR && !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    if (getSnapshot().getType() == SnapshotType.REGULAR && getSnapshot().getStatus() != SnapshotStatus.IN_PREVIEW) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_SNAPSHOT_NOT_IN_PREVIEW);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    if (!validate(snapshotValidator.snapshotExists(getSnapshot())) || !validate(snapshotValidator.snapshotExists(getVmId(), getSnapshot().getId())) || !validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    if (Guid.Empty.equals(getSnapshot().getId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    VmValidator vmValidator = createVmValidator(getVm());
    MultipleStorageDomainsValidator storageValidator = createStorageDomainValidator();
    if (!validate(storageValidator.allDomainsExistAndActive()) || !validate(storageValidator.allDomainsWithinThresholds()) || !performImagesChecks() || !validate(vmValidator.vmDown()) || // if the user choose to commit a snapshot the vm can't have disk snapshots attached to other vms.
    getSnapshot().getType() == SnapshotType.REGULAR && !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    if (getSnapshot().getType() == SnapshotType.REGULAR && getSnapshot().getStatus() != SnapshotStatus.IN_PREVIEW) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_SNAPSHOT_NOT_IN_PREVIEW);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnValue = performImageVdsmOperation();
    if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                processOldImageFromDb();
                addDiskImageToDb(newDiskImage, getCompensationContext(), Boolean.TRUE);
                setActionReturnValue(newDiskImage);
                setSucceeded(true);
                return null;
            }
        });
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnValue = performImageVdsmOperation();
    if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
        TransactionSupport.executeInNewTransaction(() -> {
            processOldImageFromDb();
            addDiskImageToDb(newDiskImage, getCompensationContext(), Boolean.TRUE);
            setActionReturnValue(newDiskImage);
            setSucceeded(true);
            return null;
        });
    }
}
#end_block

#method_before
protected boolean reconstructMaster() {
    isLastMaster = proceedStorageDomainTreatmentByDomainType(getNewMasterStorageDomain(), false);
    // To issue a reconstructMaster you need to set the domain inactive unless the selected domain is the current master
    if (getParameters().isInactive() && !getStorageDomain().getId().equals(getNewMasterStorageDomainId())) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.Inactive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (isLastMaster) {
        return stopSpm();
    }
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>getValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMasterStorageDomain().getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getVdsSpmId())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<StoragePoolIsoMap> domains = getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    setActionReturnValue(true);
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getVdsSpmId(), getStoragePool().getId(), getStoragePool().getName(), getNewMasterStorageDomainId(), domains, getStoragePool().getMasterDomainVersion())).getSucceeded();
}
#method_after
protected boolean reconstructMaster() {
    isLastMaster = proceedStorageDomainTreatmentByDomainType(getNewMasterStorageDomain(), false);
    // To issue a reconstructMaster you need to set the domain inactive unless the selected domain is the current master
    if (getParameters().isInactive() && !getStorageDomain().getId().equals(getNewMasterStorageDomainId())) {
        executeInNewTransaction(() -> {
            setStorageDomainStatus(StorageDomainStatus.Inactive, getCompensationContext());
            calcStoragePoolStatusByDomainsStatus();
            getCompensationContext().stateChanged();
            return null;
        });
    }
    if (isLastMaster) {
        return stopSpm();
    }
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>getValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMasterStorageDomain().getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getVdsSpmId())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<StoragePoolIsoMap> domains = getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    setActionReturnValue(true);
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getVdsSpmId(), getStoragePool().getId(), getStoragePool().getName(), getNewMasterStorageDomainId(), domains, getStoragePool().getMasterDomainVersion())).getSucceeded();
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    if (isLastMaster || !commandSucceeded) {
        log.warn("skipping connect and refresh for all hosts, last master '{}', command status '{}'", isLastMaster, commandSucceeded);
        return;
    }
    List<Callable<Void>> tasks = new ArrayList<>();
    for (final VDS vds : getAllRunningVdssInPool()) {
        tasks.add(new Callable<Void>() {

            @Override
            public Void call() {
                try {
                    if (!connectVdsToNewMaster(vds)) {
                        log.warn("failed to connect vds '{}' to the new master '{}'", vds.getId(), getNewMasterStorageDomainId());
                        return null;
                    }
                    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
                    try {
                        runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), getNewMasterStorageDomainId(), storagePoolIsoMap, true));
                    } catch (EngineException ex) {
                        if (EngineError.StoragePoolUnknown == ex.getVdsError().getCode()) {
                            VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), getNewMasterStorageDomainId(), storagePoolIsoMap));
                            if (!returnVal.getSucceeded()) {
                                log.error("Post reconstruct actions (connectPool) did not complete on host '{}' in the pool. error {}", vds.getId(), returnVal.getVdsError().getMessage());
                            }
                        } else {
                            log.error("Post reconstruct actions (refreshPool)" + " did not complete on host '{}' in the pool. error {}", vds.getId(), ex.getMessage());
                        }
                    }
                } catch (Exception e) {
                    log.error("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host '{}' in the pool: {}", vds.getId(), e.getMessage());
                    log.debug("Exception", e);
                }
                return null;
            }
        });
    }
    ThreadPoolUtil.invokeAll(tasks);
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    if (isLastMaster || !commandSucceeded) {
        log.warn("skipping connect and refresh for all hosts, last master '{}', command status '{}'", isLastMaster, commandSucceeded);
        return;
    }
    List<Callable<Void>> tasks = new ArrayList<>();
    for (final VDS vds : getAllRunningVdssInPool()) {
        tasks.add(() -> {
            try {
                if (!connectVdsToNewMaster(vds)) {
                    log.warn("failed to connect vds '{}' to the new master '{}'", vds.getId(), getNewMasterStorageDomainId());
                    return null;
                }
                List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
                try {
                    runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), getNewMasterStorageDomainId(), storagePoolIsoMap, true));
                } catch (EngineException ex) {
                    if (EngineError.StoragePoolUnknown == ex.getVdsError().getCode()) {
                        VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), getNewMasterStorageDomainId(), storagePoolIsoMap));
                        if (!returnVal.getSucceeded()) {
                            log.error("Post reconstruct actions (connectPool) did not complete on host '{}' in the pool. error {}", vds.getId(), returnVal.getVdsError().getMessage());
                        }
                    } else {
                        log.error("Post reconstruct actions (refreshPool)" + " did not complete on host '{}' in the pool. error {}", vds.getId(), ex.getMessage());
                    }
                }
            } catch (Exception e) {
                log.error("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host '{}' in the pool: {}", vds.getId(), e.getMessage());
                log.debug("Exception", e);
            }
            return null;
        });
    }
    ThreadPoolUtil.invokeAll(tasks);
}
#end_block

#method_before
protected void saveLUNsInDB(final List<LUNs> luns) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (LUNs lun : luns) {
                proceedLUNInDb(lun, getStorageDomain().getStorageType(), getStorageDomain().getStorage());
            }
            return null;
        }
    });
}
#method_after
protected void saveLUNsInDB(final List<LUNs> luns) {
    TransactionSupport.executeInNewTransaction(() -> {
        for (LUNs lun : luns) {
            proceedLUNInDb(lun, getStorageDomain().getStorageType(), getStorageDomain().getStorage());
        }
        return null;
    });
}
#end_block

#method_before
private void fillInUnsetIpConfigs() {
    for (NetworkAttachment networkAttachment : getParameters().getNetworkAttachments()) {
        if (networkAttachment.getIpConfiguration() == null) {
            IpConfiguration ipConfiguration = NetworkUtils.createDefaultIpConfiguration();
            networkAttachment.setIpConfiguration(ipConfiguration);
        }
    }
}
#method_after
private void fillInUnsetIpConfigs() {
    getParameters().getNetworkAttachments().stream().filter(attachment -> attachment.getIpConfiguration() == null).forEach(attachment -> attachment.setIpConfiguration(NetworkUtils.createDefaultIpConfiguration()));
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (Guid.isNullOrEmpty(commandId) ? 0 : commandId.hashCode());
    result = prime * result + ((commandType == null) ? 0 : commandType.hashCode());
    result = prime * result + (Guid.isNullOrEmpty(parentCommandId) ? 0 : parentCommandId.hashCode());
    result = prime * result + (Guid.isNullOrEmpty(rootCommandId) ? 0 : rootCommandId.hashCode());
    result = prime * result + data.hashCode();
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(commandId, commandType, parentCommandId, rootCommandId, data);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    CommandEntity other = (CommandEntity) obj;
    return Objects.equals(commandId, other.commandId) && commandType == other.commandType && Objects.equals(getGuid(parentCommandId), getGuid(other.parentCommandId)) && Objects.equals(getGuid(rootCommandId), getGuid(other.rootCommandId)) && Objects.equals(data, other.data);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof CommandEntity)) {
        return false;
    }
    CommandEntity other = (CommandEntity) obj;
    return Objects.equals(commandId, other.commandId) && commandType == other.commandType && Objects.equals(getGuid(parentCommandId), getGuid(other.parentCommandId)) && Objects.equals(getGuid(rootCommandId), getGuid(other.rootCommandId)) && Objects.equals(data, other.data);
}
#end_block

#method_before
public void setData(DataMap data) {
    this.data = data;
}
#method_after
public void setData(Map<String, Serializable> data) {
    this.data = data;
}
#end_block

#method_before
public DataMap getData() {
    return data;
}
#method_after
public Map<String, Serializable> getData() {
    return data;
}
#end_block

#method_before
public static CommandEntity buildCommandEntity(Guid userId, Guid commandId, Guid parentCommandId, Guid rootCommandId, Guid jobId, Guid stepId, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status, boolean callbackEnabled, VdcReturnValueBase returnValue, DataMap data) {
    CommandEntity entity = new CommandEntity();
    entity.setUserId(userId);
    entity.setId(commandId);
    entity.setParentCommandId(parentCommandId);
    entity.setRootCommandId(rootCommandId);
    entity.setJobId(jobId);
    entity.setStepId(stepId);
    entity.setCommandType(actionType);
    entity.setCommandParameters(params);
    entity.setCommandStatus(status);
    entity.setCallbackEnabled(callbackEnabled);
    entity.setReturnValue(returnValue);
    entity.setData(data);
    return entity;
}
#method_after
public static CommandEntity buildCommandEntity(Guid userId, Guid commandId, Guid parentCommandId, Guid rootCommandId, Guid jobId, Guid stepId, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status, boolean callbackEnabled, VdcReturnValueBase returnValue, Map<String, Serializable> data) {
    CommandEntity entity = new CommandEntity();
    entity.setUserId(userId);
    entity.setId(commandId);
    entity.setParentCommandId(parentCommandId);
    entity.setRootCommandId(rootCommandId);
    entity.setJobId(jobId);
    entity.setStepId(stepId);
    entity.setCommandType(actionType);
    entity.setCommandParameters(params);
    entity.setCommandStatus(status);
    entity.setCallbackEnabled(callbackEnabled);
    entity.setReturnValue(returnValue);
    entity.setData(data);
    return entity;
}
#end_block

#method_before
public static List<Guid> getChildCommandIds(Guid commandId) {
    return coco.getChildCommandIds(commandId);
}
#method_after
public static List<Guid> getChildCommandIds(Guid commandId, VdcActionType childActionType, CommandStatus status) {
    return coco.getChildCommandIds(commandId, childActionType, status);
}
#end_block

#method_before
public static DataMap getCommandData(Guid commandId) {
    CommandEntity cmdEntity = coco.getCommandEntity(commandId);
    return cmdEntity == null ? new DataMap() : cmdEntity.getData();
}
#method_after
public static Map<String, Serializable> getCommandData(Guid commandId) {
    CommandEntity cmdEntity = coco.getCommandEntity(commandId);
    return cmdEntity == null ? new HashMap<>() : cmdEntity.getData();
}
#end_block

#method_before
public static void updateCommandData(Guid commandId, DataMap data) {
    coco.updateCommandData(commandId, data);
}
#method_after
public static void updateCommandData(Guid commandId, Map<String, Serializable> data) {
    coco.updateCommandData(commandId, data);
}
#end_block

#method_before
public void updateCommandData(Guid commandId, DataMap data) {
    final CommandEntity cmdEntity = get(commandId);
    if (cmdEntity != null) {
        cmdEntity.setData(data);
        saveOrUpdateWithoutTransaction(cmdEntity);
    }
}
#method_after
public void updateCommandData(Guid commandId, Map<String, Serializable> data) {
    final CommandEntity cmdEntity = get(commandId);
    if (cmdEntity != null) {
        cmdEntity.setData(data);
        saveOrUpdateWithoutTransaction(cmdEntity);
    }
}
#end_block

#method_before
@Test
public void testParameterMapDeserialization() {
    StringBuilder buf = new StringBuilder("");
    buf.append("{\"@class\" : \"org.ovirt.engine.core.common.utils.DataMap\",");
    buf.append("\"version=0;uuid=7f2ae300-8f92-11e5-a61e-54ee755c6cc7\" : ");
    buf.append("[ \"org.ovirt.engine.core.common.action.VdcActionType\", \"DestroyImage\" ]");
    buf.append("}");
    DataMap data = new JsonObjectDeserializer().deserialize(buf.toString(), DataMap.class);
    assertNotNull(data);
    assertEquals(data.get(JsonObjectTestParameters.NEXT_COMMAND), VdcActionType.DestroyImage);
}
#method_after
@Test
public void testParameterMapDeserialization() {
    StringBuilder buf = new StringBuilder("");
    buf.append("{");
    buf.append("\"NEXT_COMMAND_TYPE\" : [ \"org.ovirt.engine.core.common.action.VdcActionType\", \"DestroyImage\" ]");
    buf.append("}");
    Map<String, Serializable> data = new JsonObjectDeserializer().deserialize(buf.toString(), HashMap.class);
    assertNotNull(data);
    assertEquals(data.get("NEXT_COMMAND_TYPE"), VdcActionType.DestroyImage);
}
#end_block

#method_before
private CommandBase<?> buildCommand(CommandEntity cmdEntity, CommandContext cmdContext) {
    CommandBase<?> command = null;
    if (cmdEntity != null) {
        if (cmdContext == null) {
            cmdContext = new CommandContext(new EngineContext()).withExecutionContext(new ExecutionContext());
        }
        if (CommandsFactory.hasConstructor(cmdEntity.getCommandType(), cmdEntity.getCommandParameters(), cmdContext)) {
            command = CommandsFactory.createCommand(cmdEntity.getCommandType(), cmdEntity.getCommandParameters(), cmdContext);
        } else {
            command = CommandsFactory.createCommand(cmdEntity.getCommandType(), cmdEntity.getCommandParameters());
        }
        command.setCommandStatus(cmdEntity.getCommandStatus(), false);
        command.setCommandData(cmdEntity.getData());
        if (!Guid.isNullOrEmpty(cmdEntity.getParentCommandId()) && !cmdEntity.getParentCommandId().equals(cmdEntity.getId()) && command.getParameters().getParentParameters() == null) {
            CommandBase<?> parentCommand = retrieveCommand(cmdEntity.getParentCommandId());
            if (parentCommand != null) {
                command.getParameters().setParentParameters(parentCommand.getParameters());
            }
        }
    }
    return command;
}
#method_after
private CommandBase<?> buildCommand(CommandEntity cmdEntity, CommandContext cmdContext) {
    CommandBase<?> command = null;
    if (cmdEntity != null) {
        if (cmdContext == null) {
            cmdContext = new CommandContext(new EngineContext()).withExecutionContext(new ExecutionContext());
        }
        command = CommandsFactory.createCommand(cmdEntity.getCommandType(), cmdEntity.getCommandParameters(), cmdContext);
        command.setCommandStatus(cmdEntity.getCommandStatus(), false);
        command.setCommandData(cmdEntity.getData());
        if (!Guid.isNullOrEmpty(cmdEntity.getParentCommandId()) && !cmdEntity.getParentCommandId().equals(cmdEntity.getId()) && command.getParameters().getParentParameters() == null) {
            CommandBase<?> parentCommand = retrieveCommand(cmdEntity.getParentCommandId());
            if (parentCommand != null) {
                command.getParameters().setParentParameters(parentCommand.getParameters());
            }
        }
    }
    return command;
}
#end_block

#method_before
public void updateCommandData(final Guid commandId, final DataMap data) {
    commandsCache.updateCommandData(commandId, data);
}
#method_after
public void updateCommandData(final Guid commandId, final Map<String, Serializable> data) {
    commandsCache.updateCommandData(commandId, data);
}
#end_block

#method_before
public List<Guid> getChildCommandIds(Guid cmdId) {
    initChildHierarchy();
    if (childHierarchy.containsKey(cmdId)) {
        return childHierarchy.get(cmdId);
    }
    return Collections.emptyList();
}
#method_after
public List<Guid> getChildCommandIds(Guid cmdId, VdcActionType childActionType, CommandStatus status) {
    List<Guid> childCmdIds = new ArrayList<>();
    for (Guid childCmdId : getChildCommandIds(cmdId)) {
        CommandEntity childCmdEntity = getCommandEntity(childCmdId);
        if (childCmdEntity != null && childCmdEntity.getCommandType().equals(childActionType) && (status == null || status.equals(childCmdEntity.getCommandStatus()))) {
            childCmdIds.add(childCmdId);
        }
    }
    return childCmdIds;
}
#end_block

#method_before
private void buildCmdHierarchy(CommandEntity cmdEntity) {
    if (!Guid.isNullOrEmpty(cmdEntity.getParentCommandId()) && !cmdEntity.getId().equals(cmdEntity.getParentCommandId())) {
        childHierarchy.putIfAbsent(cmdEntity.getParentCommandId(), new ArrayList<Guid>());
        if (!childHierarchy.get(cmdEntity.getParentCommandId()).contains(cmdEntity.getId())) {
            childHierarchy.get(cmdEntity.getParentCommandId()).add(cmdEntity.getId());
        }
    }
}
#method_after
private void buildCmdHierarchy(CommandEntity cmdEntity) {
    if (!Guid.isNullOrEmpty(cmdEntity.getParentCommandId()) && !cmdEntity.getId().equals(cmdEntity.getParentCommandId())) {
        childHierarchy.putIfAbsent(cmdEntity.getParentCommandId(), new ArrayList<>());
        if (!childHierarchy.get(cmdEntity.getParentCommandId()).contains(cmdEntity.getId())) {
            childHierarchy.get(cmdEntity.getParentCommandId()).add(cmdEntity.getId());
        }
    }
}
#end_block

#method_before
private VDSReturnValue runVdsCommand(VDSCommandType commandType, VDSParametersBase parameters) {
    return Backend.getInstance().getResourceManager().RunVdsCommand(commandType, parameters);
}
#method_after
private VDSReturnValue runVdsCommand(VDSCommandType commandType, VDSParametersBase parameters) {
    return Backend.getInstance().getResourceManager().runVdsCommand(commandType, parameters);
}
#end_block

#method_before
@Test
public void serializeParametersMap() {
    DataMap data = new DataMap();
    data.put(JsonObjectTestParameters.NEXT_COMMAND, VdcActionType.DestroyImage);
    JsonObjectSerializer serializer = new JsonObjectSerializer();
    Assert.assertTrue(serializer.serialize(data).length() > 0);
}
#method_after
@Test
public void serializeParametersMap() {
    Map<String, Serializable> data = new HashMap<>();
    data.put("NEXT_COMMAND_TYPE", VdcActionType.DestroyImage);
    JsonObjectSerializer serializer = new JsonObjectSerializer();
    Assert.assertTrue(serializer.serialize(data).length() > 0);
}
#end_block

#method_before
@Override
protected CommandEntity generateNewEntity() {
    DataMap data = new DataMap();
    data.put(NEXT_COMMAND, VdcActionType.DestroyImage);
    CommandEntity commandEntity = new CommandEntity();
    commandEntity.setCommandType(VdcActionType.AddBond);
    commandEntity.setCreatedAt(new Date(System.currentTimeMillis()));
    commandEntity.setId(Guid.newGuid());
    commandEntity.setCommandStatus(CommandStatus.ACTIVE);
    commandEntity.setData(data);
    VdcActionParametersBase params = new VdcActionParametersBase();
    commandEntity.setCommandParameters(params);
    return commandEntity;
}
#method_after
@Override
protected CommandEntity generateNewEntity() {
    Map<String, Serializable> data = new HashMap<>();
    data.put("NEXT_COMMAND_TYPE", VdcActionType.DestroyImage);
    CommandEntity commandEntity = new CommandEntity();
    commandEntity.setCommandType(VdcActionType.AddBond);
    commandEntity.setCreatedAt(new Date(System.currentTimeMillis()));
    commandEntity.setId(Guid.newGuid());
    commandEntity.setCommandStatus(CommandStatus.ACTIVE);
    commandEntity.setData(data);
    VdcActionParametersBase params = new VdcActionParametersBase();
    commandEntity.setCommandParameters(params);
    return commandEntity;
}
#end_block

#method_before
public VdcReturnValueBase executeAction() {
    determineExecutionReason();
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        actionAllowed = getReturnValue().getCanDoAction() || internalCanDoAction();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setCanDoAction(false);
        }
    } finally {
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase executeAction() {
    determineExecutionReason();
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        if (getCallback() != null || parentHasCallback()) {
            persistCommand(getParameters().getParentCommand(), getCallback() != null);
        }
        actionAllowed = getReturnValue().isValid() || internalValidate();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setValid(false);
        }
    } finally {
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#end_block

#method_before
private void clearAsyncTasksWithOutVdsmId() {
    if (!getReturnValue().getTaskPlaceHolderIdList().isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (Guid asyncTaskId : getReturnValue().getTaskPlaceHolderIdList()) {
                    AsyncTask task = CommandCoordinatorUtil.getAsyncTaskFromDb(asyncTaskId);
                    if (task != null && Guid.isNullOrEmpty(task.getVdsmTaskId())) {
                        CommandCoordinatorUtil.removeTaskFromDbByTaskId(task.getTaskId());
                    }
                }
                return null;
            }
        });
    }
}
#method_after
private void clearAsyncTasksWithOutVdsmId() {
    if (!getReturnValue().getTaskPlaceHolderIdList().isEmpty()) {
        TransactionSupport.executeInNewTransaction(() -> {
            for (Guid asyncTaskId : getReturnValue().getTaskPlaceHolderIdList()) {
                AsyncTask task = CommandCoordinatorUtil.getAsyncTaskFromDb(asyncTaskId);
                if (task != null && Guid.isNullOrEmpty(task.getVdsmTaskId())) {
                    CommandCoordinatorUtil.removeTaskFromDbByTaskId(task.getTaskId());
                }
            }
            return null;
        });
    }
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDao().getAllForCommandId(commandId);
            log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case DELETED_OR_UPDATED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case UPDATED_ONLY_ENTITY:
                        daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(() -> {
        Deserializer deserializer = SerializationFactory.getDeserializer();
        List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDao().getAllForCommandId(commandId);
        log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
        for (BusinessEntitySnapshot snapshot : entitySnapshots) {
            Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
            Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
            log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString());
            Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
            GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
            switch(snapshot.getSnapshotType()) {
                case CHANGED_STATUS_ONLY:
                    EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                    ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                    break;
                case DELETED_OR_UPDATED_ENTITY:
                    BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                    if (daoForEntity.get(entitySnapshot.getId()) == null) {
                        daoForEntity.save(entitySnapshot);
                    } else {
                        daoForEntity.update(entitySnapshot);
                    }
                    break;
                case UPDATED_ONLY_ENTITY:
                    daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                    break;
                case NEW_ENTITY_ID:
                    daoForEntity.remove(snapshotData);
                    break;
            }
        }
        cleanUpCompensationData();
        return null;
    });
}
#end_block

#method_before
@Override
public VdcReturnValueBase endAction() {
    if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
        startFinalizingStep();
    }
    try {
        initiateLockEndAction();
        setActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
    } finally {
        freeLockEndAction();
        if (getCommandShouldBeLogged()) {
            logCommand();
        }
    }
    return getReturnValue();
}
#method_after
@Override
public VdcReturnValueBase endAction() {
    boolean shouldEndAction = handleCommandExecutionEnded();
    if (shouldEndAction) {
        if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
            startFinalizingStep();
        }
        handleChildCommands();
        try {
            initiateLockEndAction();
            setActionState();
            handleTransactivity();
            TransactionSupport.executeInScope(endActionScope, this);
        } catch (TransactionRolledbackLocalException e) {
            log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
        } finally {
            freeLockEndAction();
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
        }
    } else {
        getReturnValue().setSucceeded(true);
    }
    return getReturnValue();
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            if (getCallback() == null) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            internalEndSuccessfully();
        } else {
            if (getCallback() == null) {
                setCommandStatus(CommandStatus.FAILED);
            }
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
            setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY);
        } else {
            internalEndWithFailure();
            setCommandStatus(CommandStatus.ENDED_WITH_FAILURE);
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#end_block

#method_before
protected List<QuotaConsumptionParameter> getQuotaConsumptionParameters() {
    // The enum markings prevent Quota dependencies unintentional inheritance.
    if (consumptionParameters == null) {
        switch(getActionType().getQuotaDependency()) {
            case NONE:
                return null;
            case STORAGE:
                consumptionParameters = getThisQuotaStorageDependent().getQuotaStorageConsumptionParameters();
                break;
            case VDS_GROUP:
                consumptionParameters = getThisQuotaVdsDependent().getQuotaVdsConsumptionParameters();
                break;
            default:
                consumptionParameters = getThisQuotaStorageDependent().getQuotaStorageConsumptionParameters();
                consumptionParameters.addAll(getThisQuotaVdsDependent().getQuotaVdsConsumptionParameters());
                break;
        }
    }
    return consumptionParameters;
}
#method_after
protected List<QuotaConsumptionParameter> getQuotaConsumptionParameters() {
    // The enum markings prevent Quota dependencies unintentional inheritance.
    if (consumptionParameters == null) {
        switch(getActionType().getQuotaDependency()) {
            case NONE:
                return null;
            case STORAGE:
                consumptionParameters = getThisQuotaStorageDependent().getQuotaStorageConsumptionParameters();
                break;
            case CLUSTER:
                consumptionParameters = getThisQuotaVdsDependent().getQuotaVdsConsumptionParameters();
                break;
            default:
                consumptionParameters = getThisQuotaStorageDependent().getQuotaStorageConsumptionParameters();
                consumptionParameters.addAll(getThisQuotaVdsDependent().getQuotaVdsConsumptionParameters());
                break;
        }
    }
    return consumptionParameters;
}
#end_block

#method_before
protected void logRollbackedTask() {
    String type = (getCurrentTaskHandler().getRevertTaskType() != null ? getCurrentTaskHandler().getRevertTaskType().name() : AsyncTaskType.unknown.name());
    log.error("Reverting task '{}', handler '{}'", type, getCurrentTaskHandler().getClass().getName());
}
#method_after
protected void logRollbackedTask() {
    String type = getCurrentTaskHandler().getRevertTaskType() != null ? getCurrentTaskHandler().getRevertTaskType().name() : AsyncTaskType.unknown.name();
    log.error("Reverting task '{}', handler '{}'", type, getCurrentTaskHandler().getClass().getName());
}
#end_block

#method_before
private boolean internalValidateAndSetQuota() {
    // Quota accounting is done only in the most external Command.
    if (!isQuotaDependant()) {
        return true;
    }
    QuotaConsumptionParametersWrapper quotaConsumptionParametersWrapper = new QuotaConsumptionParametersWrapper(this, getReturnValue().getCanDoActionMessages());
    quotaConsumptionParametersWrapper.setParameters(getQuotaConsumptionParameters());
    List<QuotaConsumptionParameter> quotaParams = quotaConsumptionParametersWrapper.getParameters();
    if (quotaParams == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". No Quota parameters available.");
    }
    // scenarios like this must set its QuotaConsumptionParameter to an empty list.
    if (quotaParams.isEmpty()) {
        return true;
    }
    if (getStoragePool() == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". Storage pool is not available for quota calculation. ");
    }
    boolean result = getQuotaManager().consume(quotaConsumptionParametersWrapper);
    setQuotaChanged(result);
    return result;
}
#method_after
private boolean internalValidateAndSetQuota() {
    // Quota accounting is done only in the most external Command.
    if (!isQuotaDependant()) {
        return true;
    }
    QuotaConsumptionParametersWrapper quotaConsumptionParametersWrapper = new QuotaConsumptionParametersWrapper(this, getReturnValue().getValidationMessages());
    quotaConsumptionParametersWrapper.setParameters(getQuotaConsumptionParameters());
    List<QuotaConsumptionParameter> quotaParams = quotaConsumptionParametersWrapper.getParameters();
    if (quotaParams == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". No Quota parameters available.");
    }
    // scenarios like this must set its QuotaConsumptionParameter to an empty list.
    if (quotaParams.isEmpty()) {
        return true;
    }
    if (getStoragePool() == null) {
        throw new InvalidQuotaParametersException("Command: " + this.getClass().getName() + ". Storage pool is not available for quota calculation. ");
    }
    boolean result = getQuotaManager().consume(quotaConsumptionParametersWrapper);
    setQuotaChanged(result);
    return result;
}
#end_block

#method_before
protected boolean validateObject(Object value) {
    List<String> messages = ValidationUtils.validateInputs(getValidationGroups(), value);
    if (!messages.isEmpty()) {
        getReturnValue().getCanDoActionMessages().addAll(messages);
        return false;
    }
    return true;
}
#method_after
protected boolean validateObject(Object value) {
    List<String> messages = ValidationUtils.validateInputs(getValidationGroups(), value);
    if (!messages.isEmpty()) {
        getReturnValue().getValidationMessages().addAll(messages);
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean isBackwardsCompatible() {
    boolean result = true;
    ActionVersionMap actionVersionMap = DbFacade.getInstance().getActionGroupDao().getActionVersionMapByActionType(getActionType());
    // cluster level ok check storage_pool level
    if (actionVersionMap != null && ((getVdsGroup() != null && getVdsGroup().getCompatibilityVersion().compareTo(new Version(actionVersionMap.getcluster_minimal_version())) < 0) || (!"*".equals(actionVersionMap.getstorage_pool_minimal_version()) && getStoragePool() != null && getStoragePool().getCompatibilityVersion().compareTo(new Version(actionVersionMap.getstorage_pool_minimal_version())) < 0))) {
        result = false;
        addCanDoActionMessage(EngineMessage.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    return result;
}
#method_after
protected boolean isBackwardsCompatible() {
    boolean result = true;
    ActionVersionMap actionVersionMap = DbFacade.getInstance().getActionGroupDao().getActionVersionMapByActionType(getActionType());
    // cluster level ok check storage_pool level
    if (actionVersionMap != null && ((getCluster() != null && getCluster().getCompatibilityVersion().compareTo(new Version(actionVersionMap.getClusterMinimalVersion())) < 0) || (!"*".equals(actionVersionMap.getStoragePoolMinimalVersion()) && getStoragePool() != null && getStoragePool().getCompatibilityVersion().compareTo(new Version(actionVersionMap.getStoragePoolMinimalVersion())) < 0))) {
        result = false;
        addValidationMessage(EngineMessage.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    return result;
}
#end_block

#method_before
protected boolean isUserAuthorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution()) {
        if (log.isDebugEnabled()) {
            log.debug("Permission check skipped for internal action {}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!MultiLevelAdministrationHandler.isMultilevelAdministrationOn()) {
        if (log.isDebugEnabled()) {
            log.debug("Permission check for action '{}' skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(EngineMessage.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debug("The set of objects to check is null or empty for action '{}'.", getActionType());
        }
        addCanDoActionMessage(EngineMessage.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    if (isQuotaDependant()) {
        addQuotaPermissionSubject(permSubjects);
    }
    if (log.isDebugEnabled()) {
        StringBuilder builder = getPermissionSubjectsAsStringBuilder(permSubjects);
        log.debug("Checking whether user '{}' or one of the groups he is member of, have the following permissions: {}", getCurrentUser().getId(), builder.toString());
    }
    // If we are here then we should grant the permission:
    return checkPermissions(permSubjects);
}
#method_after
protected boolean isUserAuthorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution()) {
        if (log.isDebugEnabled()) {
            log.debug("Permission check skipped for internal action {}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!MultiLevelAdministrationHandler.isMultilevelAdministrationOn()) {
        if (log.isDebugEnabled()) {
            log.debug("Permission check for action '{}' skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addValidationMessage(EngineMessage.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debug("The set of objects to check is null or empty for action '{}'.", getActionType());
        }
        addValidationMessage(EngineMessage.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    if (isQuotaDependant()) {
        addQuotaPermissionSubject(permSubjects);
    }
    if (log.isDebugEnabled()) {
        StringBuilder builder = getPermissionSubjectsAsStringBuilder(permSubjects);
        log.debug("Checking whether user '{}' or one of the groups he is member of, have the following permissions: {}", getCurrentUser().getId(), builder.toString());
    }
    // If we are here then we should grant the permission:
    return checkPermissions(permSubjects);
}
#end_block

#method_before
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getCanDoActionMessages())) {
            log.info("No permission found for user '{}' or one of the groups he is member of," + " when running action '{}', Required permissions are: Action type: '{}' Action group: '{}'" + " Object type: '{}'  Object ID: '{}'.", getCurrentUser().getId(), getActionType(), permSubject.getActionGroup().getRoleType().name(), permSubject.getActionGroup().name(), permSubject.getObjectType().getVdcObjectTranslation(), permSubject.getObjectId());
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkPermissions(final List<PermissionSubject> permSubjects) {
    for (PermissionSubject permSubject : permSubjects) {
        if (!checkSinglePermission(permSubject, getReturnValue().getValidationMessages())) {
            log.info("No permission found for user '{}' or one of the groups he is member of," + " when running action '{}', Required permissions are: Action type: '{}' Action group: '{}'" + " Object type: '{}'  Object ID: '{}'.", getCurrentUser().getId(), getActionType(), permSubject.getActionGroup().getRoleType().name(), permSubject.getActionGroup().name(), permSubject.getObjectType().getVdcObjectTranslation(), permSubject.getObjectId());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addCanDoActionMessage(validationResult.getMessage());
        for (String variableReplacement : validationResult.getVariableReplacements()) {
            addCanDoActionMessage(variableReplacement);
        }
    }
    return validationResult.isValid();
}
#method_after
protected boolean validate() {
    return true;
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (EngineException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new EngineFault(e, e.getVdsError().getCode()));
    } catch (OpenStackResponseException e) {
        // Adding a message to executeFailedMessages is needed only when the list is empty
        if (_returnValue.getExecuteFailedMessages().isEmpty()) {
            processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        }
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } catch (RuntimeException e) {
        processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            // set the status to SUCCEEDED if the status is ACTIVE
            if (getTaskType() == AsyncTaskType.notSupported && getReturnValue().getVdsmTaskIdList().isEmpty() && getCallback() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (EngineException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new EngineFault(e, e.getVdsError().getCode()));
    } catch (OpenStackResponseException e) {
        // Adding a message to executeFailedMessages is needed only when the list is empty
        if (_returnValue.getExecuteFailedMessages().isEmpty()) {
            processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        }
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } catch (RuntimeException e) {
        processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            // set the status to ENDED_SUCCESSFULLY if the status is ACTIVE
            if (getTaskType() == AsyncTaskType.notSupported && getReturnValue().getVdsmTaskIdList().isEmpty() && getCallback() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
private void executeActionInTransactionScope() {
    if (TransactionSupport.current() != null) {
        TransactionSupport.registerRollbackHandler(CommandBase.this);
    }
    // rollback the transaction.
    if (!executeWithoutTransaction()) {
        if (TransactionSupport.current() == null) {
            cancelTasks();
        }
        // we don't want to commit transaction here
        TransactionSupport.setRollbackOnly();
    }
}
#method_after
private void executeActionInTransactionScope() {
    registerRollbackHandler(new DefaultCommandTransactionCompletionListener());
    // rollback the transaction.
    if (!executeWithoutTransaction()) {
        if (TransactionSupport.current() == null) {
            cancelTasks();
        }
        // we don't want to commit transaction here
        TransactionSupport.setRollbackOnly();
    }
}
#end_block

#method_before
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (getCallback() != null || parentHasCallback()) {
        persistCommand(getParameters().getParentCommand(), getCallback() != null);
    }
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("Transaction was aborted in '{}'", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
            if (getSucceeded()) {
                if (getCommandShouldBeLogged()) {
                    logRenamedEntity();
                }
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (noAsyncOperations() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#method_after
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setValid(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("Transaction was aborted in '{}'", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
            if (getSucceeded()) {
                if (getCommandShouldBeLogged()) {
                    logRenamedEntity();
                }
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (noAsyncOperations() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#end_block

#method_before
public DataMap getCommandData() {
    return commandData;
}
#method_after
public Map<String, Serializable> getCommandData() {
    return commandData;
}
#end_block

#method_before
public void setCommandData(DataMap commandData) {
    this.commandData = commandData;
}
#method_after
public void setCommandData(Map<String, Serializable> commandData) {
    this.commandData = commandData;
}
#end_block

#method_before
public Guid persistAsyncTaskPlaceHolder(VdcActionType parentCommand, final String taskKey) {
    Guid taskId = Guid.Empty;
    try {
        AsyncTaskCreationInfo creationInfo = new AsyncTaskCreationInfo();
        if (!hasTaskHandlers()) {
            creationInfo.setTaskType(getTaskType());
        } else {
            creationInfo.setTaskType(getCurrentTaskHandler().getTaskType());
        }
        final AsyncTask task = createAsyncTask(creationInfo, parentCommand);
        taskId = task.getTaskId();
        TransactionScopeOption scopeOption = getTransactive() ? TransactionScopeOption.RequiresNew : TransactionScopeOption.Required;
        TransactionSupport.executeInScope(scopeOption, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                saveTaskAndPutInMap(taskKey, task);
                return null;
            }
        });
        addToReturnValueTaskPlaceHolderIdList(taskId);
    } catch (RuntimeException ex) {
        log.error("Error during persistAsyncTaskPlaceHolder for command '{}': {}", getClass().getName(), ex.getMessage());
        log.error("Exception", ex);
    }
    return taskId;
}
#method_after
public Guid persistAsyncTaskPlaceHolder(VdcActionType parentCommand, final String taskKey) {
    Guid taskId = Guid.Empty;
    try {
        AsyncTaskCreationInfo creationInfo = new AsyncTaskCreationInfo();
        if (!hasTaskHandlers()) {
            creationInfo.setTaskType(getTaskType());
        } else {
            creationInfo.setTaskType(getCurrentTaskHandler().getTaskType());
        }
        final AsyncTask task = createAsyncTask(creationInfo, parentCommand);
        taskId = task.getTaskId();
        TransactionScopeOption scopeOption = getTransactive() ? TransactionScopeOption.RequiresNew : TransactionScopeOption.Required;
        TransactionSupport.executeInScope(scopeOption, () -> {
            saveTaskAndPutInMap(taskKey, task);
            return null;
        });
        addToReturnValueTaskPlaceHolderIdList(taskId);
    } catch (RuntimeException ex) {
        log.error("Error during persistAsyncTaskPlaceHolder for command '{}': {}", getClass().getName(), ex.getMessage());
        log.error("Exception", ex);
    }
    return taskId;
}
#end_block

#method_before
protected Guid createTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return createTask(taskId, asyncTaskCreationInfo, parentCommand, null, // the map should be mutable
    new HashMap<Guid, VdcObjectType>());
}
#method_after
protected Guid createTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return createTask(taskId, asyncTaskCreationInfo, parentCommand, null, // the map should be mutable
    new HashMap<>());
}
#end_block

#method_before
protected boolean acquireLockInternal() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        EngineLock lock = buildLock();
        if (lock != null) {
            Pair<Boolean, Set<String>> lockAcquireResult = getLockManager().acquireLock(lock);
            if (lockAcquireResult.getFirst()) {
                log.info("Lock Acquired to object '{}'", lock);
                context.withLock(lock);
            } else {
                log.info("Failed to Acquire Lock to object '{}'", lock);
                getReturnValue().getCanDoActionMessages().addAll(extractVariableDeclarations(lockAcquireResult.getSecond()));
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean acquireLockInternal() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        EngineLock lock = buildLock();
        if (lock != null) {
            Pair<Boolean, Set<String>> lockAcquireResult = getLockManager().acquireLock(lock);
            if (lockAcquireResult.getFirst()) {
                log.info("Lock Acquired to object '{}'", lock);
                context.withLock(lock);
            } else {
                log.info("Failed to Acquire Lock to object '{}'", lock);
                getReturnValue().getValidationMessages().addAll(extractVariableDeclarations(lockAcquireResult.getSecond()));
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
protected List<String> extractVariableDeclarations(Iterable<String> appendedCanDoMsgs) {
    final List<String> result = new ArrayList<>();
    for (String appendedCanDoMsg : appendedCanDoMsgs) {
        result.addAll(Arrays.asList(appendedCanDoMsg.split("(?=\\$)")));
    }
    return result;
}
#method_after
protected List<String> extractVariableDeclarations(Iterable<String> appendedValidateMsgs) {
    final List<String> result = new ArrayList<>();
    for (String appendedValidateMsg : appendedValidateMsgs) {
        result.addAll(Arrays.asList(appendedValidateMsg.split("(?=\\$)")));
    }
    return result;
}
#end_block

#method_before
private void acquireLockAndWait() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        Map<String, Pair<String, String>> exclusiveLocks = getExclusiveLocks();
        if (exclusiveLocks != null) {
            EngineLock lock = new EngineLock(exclusiveLocks, null);
            getLockManager().acquireLockWait(lock);
            context.withLock(lock);
        }
    }
}
#method_after
private void acquireLockAndWait() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        Map<String, Pair<String, String>> exclusiveLocks = getExclusiveLocks();
        if (exclusiveLocks != null) {
            EngineLock lock = new EngineLock(exclusiveLocks, null);
            log.info("Before acquiring and wait lock '{}'", lock);
            getLockManager().acquireLockWait(lock);
            context.withLock(lock);
            log.info("Lock-wait acquired to object '{}'", lock);
        }
    }
}
#end_block

#method_before
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addCanDoActionMessage(validationResult.getMessage());
        for (String variableReplacement : validationResult.getVariableReplacements()) {
            addCanDoActionMessage(variableReplacement);
        }
    }
    return validationResult.isValid();
}
#method_after
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addValidationMessage(validationResult.getMessage());
        for (String variableReplacement : validationResult.getVariableReplacements()) {
            addValidationMessage(variableReplacement);
        }
    }
    return validationResult.isValid();
}
#end_block

#method_before
protected VDSReturnValue runVdsCommand(VDSCommandType commandType, VDSParametersBase parameters) throws EngineException {
    return getVdsBroker().RunVdsCommand(commandType, parameters);
}
#method_after
protected VDSReturnValue runVdsCommand(VDSCommandType commandType, VDSParametersBase parameters) throws EngineException {
    return getVdsBroker().runVdsCommand(commandType, parameters);
}
#end_block

#method_before
protected void propagateFailure(VdcReturnValueBase internalReturnValue) {
    getReturnValue().getExecuteFailedMessages().addAll(internalReturnValue.getExecuteFailedMessages());
    getReturnValue().setFault(internalReturnValue.getFault());
    getReturnValue().getCanDoActionMessages().addAll(internalReturnValue.getCanDoActionMessages());
    getReturnValue().setCanDoAction(internalReturnValue.getCanDoAction());
}
#method_after
protected void propagateFailure(VdcReturnValueBase internalReturnValue) {
    getReturnValue().getExecuteFailedMessages().addAll(internalReturnValue.getExecuteFailedMessages());
    getReturnValue().setFault(internalReturnValue.getFault());
    getReturnValue().getValidationMessages().addAll(internalReturnValue.getValidationMessages());
    getReturnValue().setValid(internalReturnValue.isValid());
}
#end_block

#method_before
public VdcActionParametersBase getParentParameters() {
    VdcActionParametersBase parentParameters = getParameters();
    if (parentHasCallback()) {
        if (!getParameters().getShouldBeEndedByParent() || getTaskType() == AsyncTaskType.notSupported) {
            parentParameters = getParameters().getParentParameters();
        }
    } else if (getParameters().getShouldBeEndedByParent()) {
        parentParameters = getParameters().getParentParameters();
    }
    return parentParameters;
}
#method_after
public VdcActionParametersBase getParentParameters() {
    // responsible to execute the parent endAction() and not the AsyncTaskManager
    if (parentHasCallback()) {
        return getParameters();
    }
    return getParameters().getParentParameters();
}
#end_block

#method_before
@Test
public void testGetUnregisteredDisks() {
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    StorageDomainDao storageDomainDaoMock = mock(StorageDomainDao.class);
    when(dbFacadeMock.getStorageDomainDao()).thenReturn(storageDomainDaoMock);
    StorageDomain storageDomain = new StorageDomain();
    when(storageDomainDaoMock.get(storageDomainId)).thenReturn(storageDomain);
    // Execute query
    getQuery().executeQueryCommand();
    // Assert the query's results
    @SuppressWarnings("unchecked")
    List<Disk> newDisks = (List<Disk>) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals(1, newDisks.size());
    assertEquals(importDiskId, newDisks.get(0).getId());
}
#method_after
@Test
public void testGetUnregisteredDisks() {
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    StorageDomainDao storageDomainDaoMock = mock(StorageDomainDao.class);
    when(dbFacadeMock.getStorageDomainDao()).thenReturn(storageDomainDaoMock);
    StorageDomain storageDomain = new StorageDomain();
    when(storageDomainDaoMock.get(storageDomainId)).thenReturn(storageDomain);
    // Execute query
    getQuery().executeQueryCommand();
    // Assert the query's results
    @SuppressWarnings("unchecked")
    List<Disk> newDisks = getQuery().getQueryReturnValue().getReturnValue();
    assertEquals(1, newDisks.size());
    assertEquals(importDiskId, newDisks.get(0).getId());
}
#end_block

#method_before
private void prepareMocks() {
    BackendInternal backendMock = mock(BackendInternal.class);
    VDSBrokerFrontend vdsBroker = mock(VDSBrokerFrontend.class);
    DiskImage existingDiskImage = mock(DiskImage.class);
    when(existingDiskImage.getId()).thenReturn(existingDiskId);
    List<DiskImage> existingDiskImages = Collections.singletonList(existingDiskImage);
    // Mock the get images List VDS command
    VDSReturnValue volListReturnValue = new VDSReturnValue();
    volListReturnValue.setSucceeded(true);
    volListReturnValue.setReturnValue(importDiskIds);
    doReturn(volListReturnValue).when(vdsBroker).runVdsCommand(eq(VDSCommandType.GetImagesList), any(GetImagesListVDSCommandParameters.class));
    // Mock the get unregistered disk query
    when(backendMock.runInternalQuery(eq(VdcQueryType.GetUnregisteredDisk), any(GetUnregisteredDiskQueryParameters.class), any(EngineContext.class))).thenAnswer(invocation -> {
        GetUnregisteredDiskQueryParameters params1 = (GetUnregisteredDiskQueryParameters) invocation.getArguments()[1];
        VdcQueryReturnValue unregDiskReturnValue = new VdcQueryReturnValue();
        unregDiskReturnValue.setSucceeded(true);
        DiskImage newDiskImage = mock(DiskImage.class);
        when(newDiskImage.getId()).thenReturn(params1.getDiskId());
        unregDiskReturnValue.setReturnValue(newDiskImage);
        return unregDiskReturnValue;
    });
    doReturn(storagePoolId).when(getQuery()).getStoragePoolId();
    doReturn(storageDomainId).when(getQuery()).getStorageDomainId();
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    DiskImageDao diskImageDaoMock = mock(DiskImageDao.class);
    StorageDomainDao storageDomainDaoMock = mock(StorageDomainDao.class);
    when(diskImageDaoMock.getAllSnapshotsForStorageDomain(eq(storageDomainId))).thenReturn(existingDiskImages);
    when(dbFacadeMock.getDiskImageDao()).thenReturn(diskImageDaoMock);
    StorageDomain storageDomain = new StorageDomain();
    when(storageDomainDaoMock.getForStoragePool(storageDomainId, storagePoolId)).thenReturn(storageDomain);
    // Return the mocked backend when getBackend() is called on the query
    doReturn(backendMock).when(getQuery()).getBackend();
    // Return the mocked vdsBroker when getVDSBroker() is called on the query
    doReturn(vdsBroker).when(getQuery()).getVdsBroker();
}
#method_after
private void prepareMocks() {
    BackendInternal backendMock = mock(BackendInternal.class);
    VDSBrokerFrontend vdsBroker = mock(VDSBrokerFrontend.class);
    DiskImage existingDiskImage = mock(DiskImage.class);
    when(existingDiskImage.getId()).thenReturn(existingDiskId);
    List<DiskImage> existingDiskImages = Collections.singletonList(existingDiskImage);
    // Mock the get images List VDS command
    VDSReturnValue volListReturnValue = new VDSReturnValue();
    volListReturnValue.setSucceeded(true);
    volListReturnValue.setReturnValue(importDiskIds);
    doReturn(volListReturnValue).when(vdsBroker).runVdsCommand(eq(VDSCommandType.GetImagesList), any(GetImagesListVDSCommandParameters.class));
    // Mock the get unregistered disk query
    when(backendMock.runInternalQuery(eq(VdcQueryType.GetUnregisteredDisk), any(GetUnregisteredDiskQueryParameters.class), any(EngineContext.class))).thenAnswer(invocation -> {
        GetUnregisteredDiskQueryParameters p = (GetUnregisteredDiskQueryParameters) invocation.getArguments()[1];
        VdcQueryReturnValue unregDiskReturnValue = new VdcQueryReturnValue();
        unregDiskReturnValue.setSucceeded(true);
        DiskImage newDiskImage = mock(DiskImage.class);
        when(newDiskImage.getId()).thenReturn(p.getDiskId());
        unregDiskReturnValue.setReturnValue(newDiskImage);
        return unregDiskReturnValue;
    });
    doReturn(storagePoolId).when(getQuery()).getStoragePoolId();
    doReturn(storageDomainId).when(getQuery()).getStorageDomainId();
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    DiskImageDao diskImageDaoMock = mock(DiskImageDao.class);
    StorageDomainDao storageDomainDaoMock = mock(StorageDomainDao.class);
    when(diskImageDaoMock.getAllSnapshotsForStorageDomain(eq(storageDomainId))).thenReturn(existingDiskImages);
    when(dbFacadeMock.getDiskImageDao()).thenReturn(diskImageDaoMock);
    StorageDomain storageDomain = new StorageDomain();
    when(storageDomainDaoMock.getForStoragePool(storageDomainId, storagePoolId)).thenReturn(storageDomain);
    // Return the mocked backend when getBackend() is called on the query
    doReturn(backendMock).when(getQuery()).getBackend();
    // Return the mocked vdsBroker when getVDSBroker() is called on the query
    doReturn(vdsBroker).when(getQuery()).getVdsBroker();
}
#end_block

#method_before
protected void sortStorageDomains(List<StorageDomain> domainsInPool, Collection<DiskImage> vmDisks) {
    Comparator<StorageDomain> comp = null;
    // When there is more than one comparator, a nested sort is performed.
    for (Comparator<StorageDomain> comparator : getStorageDomainComparators(domainsInPool, vmDisks)) {
        comp = (comp == null) ? comparator.reversed() : comp.thenComparing(comparator.reversed());
    }
    Collections.sort(domainsInPool, comp);
}
#method_after
protected void sortStorageDomains(List<StorageDomain> domainsInPool, Collection<DiskImage> vmDisks) {
    Comparator<StorageDomain> comp = null;
    // When there is more than one comparator, a nested sort is performed.
    for (Comparator<StorageDomain> comparator : getStorageDomainComparators(domainsInPool, vmDisks)) {
        // A reversed sort will be performed to get the "biggest" storage domain first.
        comp = (comp == null) ? comparator.reversed() : comp.thenComparing(comparator.reversed());
    }
    Collections.sort(domainsInPool, comp);
}
#end_block

#method_before
@Override
public String toString() {
    return Objects.toString(getFirst(), null) + '.' + Objects.toString(getSecond(), null);
}
#method_after
@Override
public String toString() {
    return Objects.toString(getFirst()) + '.' + Objects.toString(getSecond());
}
#end_block

#method_before
public EngineLock acquireMonitorLock(String lockReleaseMessage) {
    return this.vdsLocking.acquireMonitorLock(getVds(), lockReleaseMessage, log);
}
#method_after
public EngineLock acquireMonitorLock(String lockReleaseMessage) {
    return this.hostLocking.acquireMonitorLock(getVds(), lockReleaseMessage, log);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        if (!getModifiedInterfaces().isEmpty()) {
            updateModifiedInterfaces();
        }
        log.info("No changes were detected in setup networks for host '{}' (ID '{}')", getVdsName(), getVdsId());
        if (isInternalExecution()) {
            setActionReturnValue(SetupNetworksResolution.NO_CHANGES_DETECTED);
        }
        setSucceeded(true);
        return;
    }
    T bckndCmdParams = getParameters();
    final SetupNetworksVdsCommandParameters vdsCmdParams = new SetupNetworksVdsCommandParameters(getVds(), getNetworks(), getRemovedNetworks(), getBonds(), getRemovedBonds().keySet(), getInterfaces(), getParameters().getCustomProperties(), isManagementNetworkChanged());
    vdsCmdParams.setForce(bckndCmdParams.isForce());
    vdsCmdParams.setCheckConnectivity(bckndCmdParams.isCheckConnectivity());
    int timeout = bckndCmdParams.getConectivityTimeout() != null ? bckndCmdParams.getConectivityTimeout() : Config.<Integer>getValue(ConfigValues.NetworkConnectivityCheckTimeoutInSeconds);
    vdsCmdParams.setConectivityTimeout(timeout);
    FutureVDSCall<VDSReturnValue> setupNetworksTask = createFutureTask(vdsCmdParams);
    if (bckndCmdParams.isCheckConnectivity()) {
        pollInterruptively(setupNetworksTask);
    }
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().isCheckConnectivity()) {
                throw new EngineException(EngineError.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                // TODO MM: Dear code reviewer! Message for release lock wasn't present here, so I added it. Is that correct? Please advise.
                try (EngineLock monitoringLock = acquireMonitorLock("Setup Networks")) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Setup networks command timed out for {} seconds", timeout);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        if (!getModifiedInterfaces().isEmpty()) {
            updateModifiedInterfaces();
        }
        log.info("No changes were detected in setup networks for host '{}' (ID '{}')", getVdsName(), getVdsId());
        if (isInternalExecution()) {
            setActionReturnValue(SetupNetworksResolution.NO_CHANGES_DETECTED);
        }
        setSucceeded(true);
        return;
    }
    T bckndCmdParams = getParameters();
    final SetupNetworksVdsCommandParameters vdsCmdParams = new SetupNetworksVdsCommandParameters(getVds(), getNetworks(), getRemovedNetworks(), getBonds(), getRemovedBonds().keySet(), getInterfaces(), getParameters().getCustomProperties(), isManagementNetworkChanged());
    vdsCmdParams.setForce(bckndCmdParams.isForce());
    vdsCmdParams.setCheckConnectivity(bckndCmdParams.isCheckConnectivity());
    int timeout = bckndCmdParams.getConectivityTimeout() != null ? bckndCmdParams.getConectivityTimeout() : Config.<Integer>getValue(ConfigValues.NetworkConnectivityCheckTimeoutInSeconds);
    vdsCmdParams.setConectivityTimeout(timeout);
    FutureVDSCall<VDSReturnValue> setupNetworksTask = createFutureTask(vdsCmdParams);
    if (bckndCmdParams.isCheckConnectivity()) {
        pollInterruptively(setupNetworksTask);
    }
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().isCheckConnectivity()) {
                throw new EngineException(EngineError.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock("Setup Networks")) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Setup networks command timed out for {} seconds", timeout);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final VDS vds = getVds();
    // TODO MM: Dear code reviewer! Message for release lock "Activate" seems pretty ambiguous. Shall I provide more specific "Activate Vds"? Please advise.
    try (EngineLock monitoringLock = acquireMonitorLock("Activate")) {
        ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
        setSucceeded(setVdsStatus(VDSStatus.Unassigned).getSucceeded());
        if (getSucceeded()) {
            TransactionSupport.executeInNewTransaction(() -> {
                // set network to operational / non-operational
                List<Network> networks = getNetworkDao().getAllForCluster(vds.getClusterId());
                for (Network net : networks) {
                    NetworkClusterHelper.setStatus(vds.getClusterId(), net);
                }
                return null;
            });
            if (vds.getHighlyAvailableIsConfigured()) {
                SetHaMaintenanceModeVDSCommandParameters param = new SetHaMaintenanceModeVDSCommandParameters(vds, HaMaintenanceMode.LOCAL, false);
                if (!runVdsCommand(VDSCommandType.SetHaMaintenanceMode, param).getSucceeded()) {
                    haMaintenanceFailed = true;
                }
            }
            // Start glusterd service on the node, which would haven been stopped due to maintenance
            if (vds.getClusterSupportsGlusterService()) {
                runVdsCommand(VDSCommandType.ManageGlusterService, new GlusterServiceVDSParameters(vds.getId(), Arrays.asList("glusterd"), "restart"));
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    final VDS vds = getVds();
    try (EngineLock monitoringLock = acquireMonitorLock("Activate host")) {
        ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
        setSucceeded(setVdsStatus(VDSStatus.Unassigned).getSucceeded());
        if (getSucceeded()) {
            TransactionSupport.executeInNewTransaction(() -> {
                // set network to operational / non-operational
                List<Network> networks = getNetworkDao().getAllForCluster(vds.getClusterId());
                for (Network net : networks) {
                    NetworkClusterHelper.setStatus(vds.getClusterId(), net);
                }
                return null;
            });
            if (vds.getHighlyAvailableIsConfigured()) {
                SetHaMaintenanceModeVDSCommandParameters param = new SetHaMaintenanceModeVDSCommandParameters(vds, HaMaintenanceMode.LOCAL, false);
                if (!runVdsCommand(VDSCommandType.SetHaMaintenanceMode, param).getSucceeded()) {
                    haMaintenanceFailed = true;
                }
            }
            // Start glusterd service on the node, which would haven been stopped due to maintenance
            if (vds.getClusterSupportsGlusterService()) {
                runVdsCommand(VDSCommandType.ManageGlusterService, new GlusterServiceVDSParameters(vds.getId(), Arrays.asList("glusterd"), "restart"));
            }
        }
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getParameters().isRunSilent()) {
        return getSucceeded() ? (haMaintenanceFailed ? AuditLogType.VDS_ACTIVATE_MANUAL_HA_ASYNC : AuditLogType.VDS_ACTIVATE_ASYNC) : AuditLogType.VDS_ACTIVATE_FAILED_ASYNC;
    } else {
        return getSucceeded() ? (haMaintenanceFailed ? AuditLogType.VDS_ACTIVATE_MANUAL_HA : AuditLogType.VDS_ACTIVATE) : AuditLogType.VDS_ACTIVATE_FAILED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getParameters().isRunSilent()) {
        return getSucceeded() ? haMaintenanceFailed ? AuditLogType.VDS_ACTIVATE_MANUAL_HA_ASYNC : AuditLogType.VDS_ACTIVATE_ASYNC : AuditLogType.VDS_ACTIVATE_FAILED_ASYNC;
    } else {
        return getSucceeded() ? haMaintenanceFailed ? AuditLogType.VDS_ACTIVATE_MANUAL_HA : AuditLogType.VDS_ACTIVATE : AuditLogType.VDS_ACTIVATE_FAILED;
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!isVmExist()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Arrays.asList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!isVmExist()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Collections.singletonList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#end_block

#method_before
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (isExecutedAsChildCommand()) {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    } else {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    ArrayList<Guid> taskList = isExecutedAsChildCommand() ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
    taskList.addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        getCompensationContext().snapshotNewEntity(addManagedDeviceForDisk(getParameters().getDiskInfo().getId()));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (isExecutedAsChildCommand()) {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    } else {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    ArrayList<Guid> taskList = isExecutedAsChildCommand() ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
    taskList.addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        getCompensationContext().snapshotNewEntity(addManagedDeviceForDisk(getParameters().getDiskInfo().getId()));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
protected CreateVmVDSCommandParameters buildCreateVmParameters() {
    CreateVmVDSCommandParameters parameters = new CreateVmVDSCommandParameters(getVdsId(), getVm());
    return parameters;
}
#method_after
protected CreateVmVDSCommandParameters buildCreateVmParameters() {
    return new CreateVmVDSCommandParameters(getVdsId(), getVm());
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getFlow() == RunVmFlow.REMOVE_STATELESS_IMAGES) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (getFlow() == RunVmFlow.RESUME_PAUSE) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (isInternalExecution()) {
                if (getSucceeded()) {
                    boolean isStateless = isStatelessSnapshotExistsForVm();
                    if (isStateless) {
                        return AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS;
                    } else if (getFlow() == RunVmFlow.CREATE_STATELESS_IMAGES) {
                        return AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING;
                    } else {
                        return AuditLogType.VDS_INITIATED_RUN_VM;
                    }
                }
                return AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? isVmRunningOnNonDefaultVds() ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getVm().isRunAndPause() ? AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE : getTaskIdList().isEmpty() ? AuditLogType.USER_STARTED_VM : AuditLogType.USER_INITIATED_RUN_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getFlow() == RunVmFlow.REMOVE_STATELESS_IMAGES) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (getFlow() == RunVmFlow.RESUME_PAUSE) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (isInternalExecution()) {
                if (getSucceeded()) {
                    boolean isStateless = isStatelessSnapshotExistsForVm();
                    if (isStateless) {
                        return AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS;
                    } else if (getFlow() == RunVmFlow.CREATE_STATELESS_IMAGES) {
                        return AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING;
                    } else {
                        return AuditLogType.VDS_INITIATED_RUN_VM;
                    }
                }
                return AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? getActionReturnValue() == VMStatus.Up ? isVmRunningOnNonDefaultVds() ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getVm().isRunAndPause() ? AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE : getTaskIdList().isEmpty() ? AuditLogType.USER_STARTED_VM : AuditLogType.USER_INITIATED_RUN_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
protected boolean isVmRunningOnNonDefaultVds() {
    return getVm().getDedicatedVmForVdsList().isEmpty() == false && getVm().getDedicatedVmForVdsList().contains(getVm().getRunOnVds()) == false;
}
#method_after
protected boolean isVmRunningOnNonDefaultVds() {
    return !getVm().getDedicatedVmForVdsList().isEmpty() && !getVm().getDedicatedVmForVdsList().contains(getVm().getRunOnVds());
}
#end_block

#method_before
protected boolean isPayloadExists(VmDeviceType deviceType) {
    if (getVm().getVmPayload() != null && getVm().getVmPayload().getDeviceType().equals(deviceType)) {
        return true;
    }
    return false;
}
#method_after
protected boolean isPayloadExists(VmDeviceType deviceType) {
    return getVm().getVmPayload() != null && getVm().getVmPayload().getDeviceType().equals(deviceType);
}
#end_block

#method_before
@Mapping(from = PowerManagement.class, to = VdsStatic.class)
public static VdsStatic map(PowerManagement model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetEnabled()) {
        entity.setPmEnabled(model.isEnabled());
    }
    if (model.isSetAutomaticPmEnabled()) {
        entity.setDisablePowerManagementPolicy(!model.isAutomaticPmEnabled());
    }
    if (model.isSetPmProxies()) {
        List<FenceProxySourceType> fenceProxySources = new LinkedList<>();
        for (PmProxy pmProxy : model.getPmProxies().getPmProxies()) {
            fenceProxySources.add(FenceProxySourceType.forValue(pmProxy.getType()));
        }
        entity.setFenceProxySources(fenceProxySources);
    }
    if (model.isSetKdumpDetection()) {
        entity.setPmKdumpDetection(model.isKdumpDetection());
    }
    return entity;
}
#method_after
@Mapping(from = PowerManagement.class, to = VdsStatic.class)
public static VdsStatic map(PowerManagement model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetEnabled()) {
        entity.setPmEnabled(model.isEnabled());
    }
    if (model.isSetAutomaticPmEnabled()) {
        entity.setDisablePowerManagementPolicy(!model.isAutomaticPmEnabled());
    }
    if (model.isSetPmProxies()) {
        List<FenceProxySourceType> fenceProxySources = model.getPmProxies().getPmProxies().stream().map(pmProxy -> FenceProxySourceType.forValue(pmProxy.getType())).collect(toCollection(LinkedList::new));
        entity.setFenceProxySources(fenceProxySources);
    }
    if (model.isSetKdumpDetection()) {
        entity.setPmKdumpDetection(model.isKdumpDetection());
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getClusterId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getClusterId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    HostProtocol protocol = map(entity.getProtocol(), null);
    model.setProtocol(protocol != null ? protocol.value() : null);
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (entity.getExternalStatus() != null) {
        EntityExternalStatus entityExternalStatus = ExternalStatusMapper.map(entity.getExternalStatus(), null);
        Status hostStatus = new Status();
        hostStatus.setState(entityExternalStatus.value());
        model.setExternalStatus(hostStatus);
    }
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    } else if (status == HostStatus.MAINTENANCE || status == HostStatus.PREPARING_FOR_MAINTENANCE) {
        model.getStatus().setDetail(entity.getMaintenanceReason());
    }
    Spm spm = new Spm();
    spm.setPriority(entity.getVdsSpmPriority());
    if (entity.getSpmStatus() != null) {
        spm.setStatus(StatusUtils.create(map(entity.getSpmStatus(), null)));
    }
    model.setSpm(spm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.getHostOs()));
    model.setKsm(new Ksm());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), (Ssh) null));
    Cpu cpu = new Cpu();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    model.setKdumpStatus(map(entity.getKdumpStatus(), null));
    model.setSelinux(map(entity, (SELinux) null));
    model.setAutoNumaStatus(map(entity.getAutoNumaBalancing(), null));
    model.setNumaSupported(entity.isNumaSupport());
    model.setLiveSnapshotSupport(entity.getLiveSnapshotSupport());
    if (entity.getHostProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getHostProviderId().toString());
    }
    model.setUpdateAvailable(entity.isUpdateAvailable());
    HostDevicePassthrough devicePassthrough = model.getDevicePassthrough();
    if (devicePassthrough == null) {
        devicePassthrough = new HostDevicePassthrough();
        model.setDevicePassthrough(devicePassthrough);
    }
    devicePassthrough.setEnabled(entity.isHostDevicePassthroughEnabled());
    return model;
}
#method_after
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getClusterId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getClusterId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    HostProtocol protocol = map(entity.getProtocol(), null);
    model.setProtocol(protocol != null ? protocol.value() : null);
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (entity.getExternalStatus() != null) {
        EntityExternalStatus entityExternalStatus = ExternalStatusMapper.map(entity.getExternalStatus(), null);
        Status hostStatus = new Status();
        hostStatus.setState(entityExternalStatus.value());
        model.setExternalStatus(hostStatus);
    }
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    } else if (status == HostStatus.MAINTENANCE || status == HostStatus.PREPARING_FOR_MAINTENANCE) {
        model.getStatus().setDetail(entity.getMaintenanceReason());
    }
    Spm spm = new Spm();
    spm.setPriority(entity.getVdsSpmPriority());
    if (entity.getSpmStatus() != null) {
        spm.setStatus(StatusUtils.create(map(entity.getSpmStatus(), null)));
    }
    model.setSpm(spm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.getHostOs()));
    model.setKsm(new Ksm());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), null));
    Cpu cpu = new Cpu();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    model.setKdumpStatus(map(entity.getKdumpStatus(), null));
    model.setSelinux(map(entity, (SELinux) null));
    model.setAutoNumaStatus(map(entity.getAutoNumaBalancing(), null));
    model.setNumaSupported(entity.isNumaSupport());
    model.setLiveSnapshotSupport(entity.getLiveSnapshotSupport());
    if (entity.getHostProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getHostProviderId().toString());
    }
    model.setUpdateAvailable(entity.isUpdateAvailable());
    HostDevicePassthrough devicePassthrough = model.getDevicePassthrough();
    if (devicePassthrough == null) {
        devicePassthrough = new HostDevicePassthrough();
        model.setDevicePassthrough(devicePassthrough);
    }
    devicePassthrough.setEnabled(entity.isHostDevicePassthroughEnabled());
    return model;
}
#end_block

#method_before
protected boolean validateAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getValidationMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getValidationMessages()) && canAddVm(getReturnValue().getValidationMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean validateAddVmCommand() {
    boolean returnValue = areParametersLegal(getReturnValue().getValidationMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getValidationMessages()) && canAddVm(getReturnValue().getValidationMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#end_block

#method_before
protected boolean buildAndCheckDestStorageDomains() {
    boolean retValue = true;
    if (diskInfoDestinationMap.isEmpty()) {
        retValue = fillDestMap();
    } else {
        retValue = validateProvidedDestinations();
    }
    if (retValue && getImagesToCheckDestinationStorageDomains().size() != diskInfoDestinationMap.size()) {
        log.error("Can not find any default active domain for one of the disks of template with id '{}'", vmDisksSource.getId());
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        retValue = false;
    }
    return retValue && validateIsImagesOnDomains();
}
#method_after
protected boolean buildAndCheckDestStorageDomains() {
    boolean retValue;
    if (diskInfoDestinationMap.isEmpty()) {
        retValue = fillDestMap();
    } else {
        retValue = validateProvidedDestinations();
    }
    if (retValue && getImagesToCheckDestinationStorageDomains().size() != diskInfoDestinationMap.size()) {
        log.error("Can not find any default active domain for one of the disks of template with id '{}'", vmDisksSource.getId());
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        retValue = false;
    }
    return retValue && validateIsImagesOnDomains();
}
#end_block

#method_before
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        Collection<DiskImage> templateDisks = getImagesToCheckDestinationStorageDomains();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(templateDisks, true, false, true);
        for (DiskImage image : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, buildCreateSnapshotFromTemplateParameters(image));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new EngineException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(templateDisks);
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        Collection<DiskImage> templateDisks = getImagesToCheckDestinationStorageDomains();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(templateDisks, true, false, true);
        for (DiskImage image : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, buildCreateSnapshotFromTemplateParameters(image));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new EngineException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(templateDisks);
    }
    return true;
}
#end_block

#method_before
private boolean isMakeCreatorExplicitOwner() {
    return getParameters().isMakeCreatorExplicitOwner() || (getCurrentUser() != null && !checkUserAuthorization(getCurrentUser().getId(), ActionGroup.MANIPULATE_PERMISSIONS, getVmId(), VdcObjectType.VM));
}
#method_after
private boolean isMakeCreatorExplicitOwner() {
    return getParameters().isMakeCreatorExplicitOwner() || (getCurrentUser() != null && getParameters().getPoolId() == null && !checkUserAuthorization(getCurrentUser().getId(), ActionGroup.MANIPULATE_PERMISSIONS, getVmId(), VdcObjectType.VM));
}
#end_block

#method_before
public void setIconIds(VmStatic vmStatic) {
    if (getParameters().getVmLargeIcon() != null) {
        final VmIconIdSizePair iconIds = IconUtils.ensureIconPairInDatabase(getParameters().getVmLargeIcon());
        vmStatic.setLargeIconId(iconIds.getLarge());
        vmStatic.setSmallIconId(iconIds.getSmall());
        return;
    } else {
        if (vmStatic.getLargeIconId() == null || vmStatic.getSmallIconId() == null) {
            vmStatic.setSmallIconId(getVmTemplate().getSmallIconId());
            vmStatic.setLargeIconId(getVmTemplate().getLargeIconId());
        }
    }
}
#method_after
public void setIconIds(VmStatic vmStatic) {
    if (getParameters().getVmLargeIcon() != null) {
        final VmIconIdSizePair iconIds = IconUtils.ensureIconPairInDatabase(getParameters().getVmLargeIcon());
        vmStatic.setLargeIconId(iconIds.getLarge());
        vmStatic.setSmallIconId(iconIds.getSmall());
    } else {
        if (vmStatic.getLargeIconId() == null || vmStatic.getSmallIconId() == null) {
            vmStatic.setSmallIconId(getVmTemplate().getSmallIconId());
            vmStatic.setLargeIconId(getVmTemplate().getLargeIconId());
        }
    }
}
#end_block

#method_before
@Override
protected NetworkClusterModel createNetworkClusterModel(Cluster cluster) {
    if (cluster.getId().equals(this.cluster.getId())) {
        NetworkClusterModel networkClusterModel = new NetworkClusterModel(cluster);
        networkClusterModel.setAttached(true);
        networkClusterModel.setRequired(!(Boolean) getExport().getEntity());
        networkClusterModel.setIsChangeable(false);
        return networkClusterModel;
    } else {
        return super.createNetworkClusterModel(cluster);
    }
}
#method_after
@Override
protected NetworkClusterModel createNetworkClusterModel(Cluster cluster) {
    if (cluster.getId().equals(this.cluster.getId())) {
        NetworkClusterModel networkClusterModel = new NetworkClusterModel(cluster);
        networkClusterModel.setAttached(true);
        networkClusterModel.setRequired(!getExport().getEntity());
        networkClusterModel.setIsChangeable(false);
        return networkClusterModel;
    } else {
        return super.createNetworkClusterModel(cluster);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateStaticDataDefaults();
    if (StringUtils.isEmpty(getStorageDomain().getStorage())) {
        getStorageDomain().setStorage((String) Backend.getInstance().runInternalAction(VdcActionType.AddStorageServerConnection, new StorageServerConnectionParametersBase(getStorageDomain().getStorageStaticData().getConnection(), getVds().getId())).getActionReturnValue());
    }
    addStorageDomainInDb();
    updateStorageDomainDynamicFromIrs();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    updateStaticDataDefaults();
    if (StringUtils.isEmpty(getStorageDomain().getStorage())) {
        getStorageDomain().setStorage(Backend.getInstance().runInternalAction(VdcActionType.AddStorageServerConnection, new StorageServerConnectionParametersBase(getStorageDomain().getStorageStaticData().getConnection(), getVds().getId())).getActionReturnValue());
    }
    addStorageDomainInDb();
    updateStorageDomainDynamicFromIrs();
    setSucceeded(true);
}
#end_block

#method_before
protected Response performAction(VdcActionType task, VdcActionParametersBase params) {
    return performAction(task, params, (Action) null, false);
}
#method_after
protected Response performAction(VdcActionType task, VdcActionParametersBase params) {
    return performAction(task, params, null, false);
}
#end_block

#method_before
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
    GlusterVolumeEntity selectedVolume = (GlusterVolumeEntity) provideDetailModelEntity(getSelectedItem());
    getBrickListModel().setVolumeEntity(selectedVolume);
    getGeoRepListModel().setEntity(selectedVolume);
    getSnapshotListModel().setEntity(selectedVolume);
}
#method_after
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
    GlusterVolumeEntity selectedVolume = provideDetailModelEntity(getSelectedItem());
    getBrickListModel().setVolumeEntity(selectedVolume);
    getGeoRepListModel().setEntity(selectedVolume);
    getSnapshotListModel().setEntity(selectedVolume);
}
#end_block

#method_before
private void stopRebalance() {
    if (getSelectedItem() == null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceTitle());
    model.setHelpTag(HelpTag.volume_rebalance_stop);
    // $NON-NLS-1$
    model.setHashName("volume_rebalance_stop");
    model.setMessage(ConstantsManager.getInstance().getMessages().confirmStopVolumeRebalance(volumeEntity.getName()));
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onStopRebalance", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("CancelConfirmation", this);
    model.getCommands().add(cancelCommand);
}
#method_after
private void stopRebalance() {
    if (getSelectedItem() == null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    GlusterVolumeEntity volumeEntity = getSelectedItem();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceTitle());
    model.setHelpTag(HelpTag.volume_rebalance_stop);
    // $NON-NLS-1$
    model.setHashName("volume_rebalance_stop");
    model.setMessage(ConstantsManager.getInstance().getMessages().confirmStopVolumeRebalance(volumeEntity.getName()));
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onStopRebalance", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("CancelConfirmation", this);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void onStopRebalance() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null) {
        return;
    }
    model.startProgress();
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    GlusterVolumeRebalanceParameters param = new GlusterVolumeRebalanceParameters(volumeEntity.getId(), false, false);
    Frontend.getInstance().runAction(VdcActionType.StopRebalanceGlusterVolume, param, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) getConfirmWindow();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                showRebalanceStatus();
            }
        }
    });
}
#method_after
private void onStopRebalance() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null) {
        return;
    }
    model.startProgress();
    final GlusterVolumeEntity volumeEntity = getSelectedItem();
    GlusterVolumeRebalanceParameters param = new GlusterVolumeRebalanceParameters(volumeEntity.getId(), false, false);
    Frontend.getInstance().runAction(VdcActionType.StopRebalanceGlusterVolume, param, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) getConfirmWindow();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                showRebalanceStatus();
            }
        }
    });
}
#end_block

#method_before
private void showRebalanceStatus() {
    if (getSelectedItem() == null) {
        return;
    }
    final ConfirmationModel cModel = new ConfirmationModel();
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(cModel);
    cModel.setTitle(ConstantsManager.getInstance().getConstants().rebalanceStatusTitle());
    // $NON-NLS-1$
    cModel.startProgress(ConstantsManager.getInstance().getConstants().fetchingDataMessage());
    cModel.setHelpTag(HelpTag.volume_rebalance_status);
    // $NON-NLS-1$
    cModel.setHashName("volume_rebalance_status");
    // $NON-NLS-1$
    final UICommand rebalanceStatusOk = new UICommand("closeConfirmationWindow", VolumeListModel.this);
    rebalanceStatusOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    rebalanceStatusOk.setIsCancel(true);
    cModel.getCommands().add(rebalanceStatusOk);
    AsyncDataProvider.getInstance().getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            cModel.stopProgress();
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeTaskStatusEntity rebalanceStatusEntity = vdcValue.getReturnValue();
            if ((rebalanceStatusEntity == null) || !vdcValue.getSucceeded()) {
                cModel.setMessage(ConstantsManager.getInstance().getMessages().rebalanceStatusFailed(volumeEntity.getName()));
            } else {
                setConfirmWindow(null);
                if (getWindow() == null) {
                    VolumeRebalanceStatusModel rebalanceStatusModel = new VolumeRebalanceStatusModel(volumeEntity);
                    rebalanceStatusModel.setTitle(ConstantsManager.getInstance().getConstants().volumeRebalanceStatusTitle());
                    setWindow(rebalanceStatusModel);
                    rebalanceStatusModel.setHelpTag(HelpTag.volume_rebalance_status);
                    // $NON-NLS-1$
                    rebalanceStatusModel.setHashName("volume_rebalance_status");
                    rebalanceStatusModel.getVolume().setEntity(volumeEntity.getName());
                    rebalanceStatusModel.getCluster().setEntity(volumeEntity.getClusterName());
                    // $NON-NLS-1$
                    UICommand stopRebalanceFromStatus = new UICommand("stop_rebalance_from_status", VolumeListModel.this);
                    stopRebalanceFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRebalance());
                    rebalanceStatusModel.getCommands().add(stopRebalanceFromStatus);
                    rebalanceStatusModel.setStopReblanceFromStatus(stopRebalanceFromStatus);
                    // $NON-NLS-1$
                    UICommand cancelRebalance = new UICommand("CancelRebalanceStatus", VolumeListModel.this);
                    cancelRebalance.setTitle(ConstantsManager.getInstance().getConstants().close());
                    cancelRebalance.setIsCancel(true);
                    rebalanceStatusModel.getCommands().add(cancelRebalance);
                    rebalanceStatusModel.showStatus(rebalanceStatusEntity);
                } else {
                    VolumeRebalanceStatusModel statusModel = (VolumeRebalanceStatusModel) getWindow();
                    statusModel.getCommands().get(0).setIsExecutionAllowed(false);
                    statusModel.showStatus(rebalanceStatusEntity);
                }
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#method_after
private void showRebalanceStatus() {
    if (getSelectedItem() == null) {
        return;
    }
    final ConfirmationModel cModel = new ConfirmationModel();
    final GlusterVolumeEntity volumeEntity = getSelectedItem();
    setConfirmWindow(cModel);
    cModel.setTitle(ConstantsManager.getInstance().getConstants().rebalanceStatusTitle());
    // $NON-NLS-1$
    cModel.startProgress(ConstantsManager.getInstance().getConstants().fetchingDataMessage());
    cModel.setHelpTag(HelpTag.volume_rebalance_status);
    // $NON-NLS-1$
    cModel.setHashName("volume_rebalance_status");
    // $NON-NLS-1$
    final UICommand rebalanceStatusOk = new UICommand("closeConfirmationWindow", VolumeListModel.this);
    rebalanceStatusOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    rebalanceStatusOk.setIsCancel(true);
    cModel.getCommands().add(rebalanceStatusOk);
    AsyncDataProvider.getInstance().getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            cModel.stopProgress();
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeTaskStatusEntity rebalanceStatusEntity = vdcValue.getReturnValue();
            if ((rebalanceStatusEntity == null) || !vdcValue.getSucceeded()) {
                cModel.setMessage(ConstantsManager.getInstance().getMessages().rebalanceStatusFailed(volumeEntity.getName()));
            } else {
                setConfirmWindow(null);
                if (getWindow() == null) {
                    VolumeRebalanceStatusModel rebalanceStatusModel = new VolumeRebalanceStatusModel(volumeEntity);
                    rebalanceStatusModel.setTitle(ConstantsManager.getInstance().getConstants().volumeRebalanceStatusTitle());
                    setWindow(rebalanceStatusModel);
                    rebalanceStatusModel.setHelpTag(HelpTag.volume_rebalance_status);
                    // $NON-NLS-1$
                    rebalanceStatusModel.setHashName("volume_rebalance_status");
                    rebalanceStatusModel.getVolume().setEntity(volumeEntity.getName());
                    rebalanceStatusModel.getCluster().setEntity(volumeEntity.getClusterName());
                    // $NON-NLS-1$
                    UICommand stopRebalanceFromStatus = new UICommand("stop_rebalance_from_status", VolumeListModel.this);
                    stopRebalanceFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRebalance());
                    rebalanceStatusModel.getCommands().add(stopRebalanceFromStatus);
                    rebalanceStatusModel.setStopReblanceFromStatus(stopRebalanceFromStatus);
                    // $NON-NLS-1$
                    UICommand cancelRebalance = new UICommand("CancelRebalanceStatus", VolumeListModel.this);
                    cancelRebalance.setTitle(ConstantsManager.getInstance().getConstants().close());
                    cancelRebalance.setIsCancel(true);
                    rebalanceStatusModel.getCommands().add(cancelRebalance);
                    rebalanceStatusModel.showStatus(rebalanceStatusEntity);
                } else {
                    VolumeRebalanceStatusModel statusModel = (VolumeRebalanceStatusModel) getWindow();
                    statusModel.getCommands().get(0).setIsExecutionAllowed(false);
                    statusModel.showStatus(rebalanceStatusEntity);
                }
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#end_block

#method_before
private void showVolumeProfiling() {
    if (getSelectedItem() == null || getWindow() != null) {
        return;
    }
    GlusterVolumeEntity selectedVolume = (GlusterVolumeEntity) getSelectedItem();
    VolumeProfileStatisticsModel profileStatsModel = new VolumeProfileStatisticsModel(selectedVolume.getClusterId(), selectedVolume.getId(), selectedVolume.getName());
    setWindow(profileStatsModel);
    setHelpTag(HelpTag.volume_profile_statistics);
    // $NON-NLS-1$
    setHashName("volume_profile_statistics");
    // $NON-NLS-1$
    profileStatsModel.startProgress(ConstantsManager.getInstance().getConstants().fetchingDataMessage());
    // $NON-NLS-1$
    UICommand closeProfilingStats = new UICommand("closeProfileStats", VolumeListModel.this);
    closeProfilingStats.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeProfilingStats.setIsCancel(true);
    profileStatsModel.getCommands().add(closeProfilingStats);
    profileStatsModel.queryBackend(true);
    profileStatsModel.queryBackend(false);
}
#method_after
private void showVolumeProfiling() {
    if (getSelectedItem() == null || getWindow() != null) {
        return;
    }
    GlusterVolumeEntity selectedVolume = getSelectedItem();
    VolumeProfileStatisticsModel profileStatsModel = new VolumeProfileStatisticsModel(selectedVolume.getClusterId(), selectedVolume.getId(), selectedVolume.getName());
    setWindow(profileStatsModel);
    setHelpTag(HelpTag.volume_profile_statistics);
    // $NON-NLS-1$
    setHashName("volume_profile_statistics");
    // $NON-NLS-1$
    profileStatsModel.startProgress(ConstantsManager.getInstance().getConstants().fetchingDataMessage());
    // $NON-NLS-1$
    UICommand closeProfilingStats = new UICommand("closeProfileStats", VolumeListModel.this);
    closeProfilingStats.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeProfilingStats.setIsCancel(true);
    profileStatsModel.getCommands().add(closeProfilingStats);
    profileStatsModel.queryBackend(true);
    profileStatsModel.queryBackend(false);
}
#end_block

#method_before
public void configureClusterSnapshotOptions() {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final GlusterClusterSnapshotConfigModel clusterSnapshotConfigModel = new GlusterClusterSnapshotConfigModel();
    clusterSnapshotConfigModel.setHelpTag(HelpTag.configure_volume_snapshot);
    // $NON-NLS-1$
    clusterSnapshotConfigModel.setHashName("configure_volume_snapshot");
    clusterSnapshotConfigModel.setTitle(ConstantsManager.getInstance().getConstants().configureClusterSnapshotOptionsTitle());
    setWindow(clusterSnapshotConfigModel);
    AsyncDataProvider.getInstance().getClustersHavingHosts(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, final Object returnValue) {
            if (getSystemTreeSelectedItem() != null) {
                Cluster selectedCluster = (Cluster) getSystemTreeSelectedItem().getEntity();
                clusterSnapshotConfigModel.getClusters().setItems((List<Cluster>) returnValue, selectedCluster);
            } else {
                if (getSelectedItems() != null) {
                    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItems().get(0);
                    if (volumeEntity != null) {
                        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue1) {
                                clusterSnapshotConfigModel.getClusters().setItems((List<Cluster>) returnValue, (Cluster) returnValue1);
                            }
                        }), volumeEntity.getClusterId());
                    }
                } else {
                    clusterSnapshotConfigModel.getClusters().setItems((List<Cluster>) returnValue);
                }
            }
        }
    }));
    clusterSnapshotConfigModel.getClusterConfigOptions().setTitle(ConstantsManager.getInstance().getConstants().configureClusterSnapshotOptionsTitle());
    // $NON-NLS-1$
    UICommand updateCommand = new UICommand("confirmConfigureClusterSnapshotOptions", this);
    updateCommand.setTitle(constants.snapshotConfigUpdateButtonLabel());
    updateCommand.setIsDefault(true);
    clusterSnapshotConfigModel.getCommands().add(updateCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(constants.cancel());
    cancelCommand.setIsCancel(true);
    clusterSnapshotConfigModel.getCommands().add(cancelCommand);
}
#method_after
public void configureClusterSnapshotOptions() {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final GlusterClusterSnapshotConfigModel clusterSnapshotConfigModel = new GlusterClusterSnapshotConfigModel();
    clusterSnapshotConfigModel.setHelpTag(HelpTag.configure_volume_snapshot);
    // $NON-NLS-1$
    clusterSnapshotConfigModel.setHashName("configure_volume_snapshot");
    clusterSnapshotConfigModel.setTitle(ConstantsManager.getInstance().getConstants().configureClusterSnapshotOptionsTitle());
    setWindow(clusterSnapshotConfigModel);
    AsyncDataProvider.getInstance().getClustersHavingHosts(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, final Object returnValue) {
            if (getSystemTreeSelectedItem() != null) {
                Cluster selectedCluster = (Cluster) getSystemTreeSelectedItem().getEntity();
                clusterSnapshotConfigModel.getClusters().setItems((List<Cluster>) returnValue, selectedCluster);
            } else {
                if (getSelectedItems() != null) {
                    GlusterVolumeEntity volumeEntity = getSelectedItems().get(0);
                    if (volumeEntity != null) {
                        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue1) {
                                clusterSnapshotConfigModel.getClusters().setItems((List<Cluster>) returnValue, (Cluster) returnValue1);
                            }
                        }), volumeEntity.getClusterId());
                    }
                } else {
                    clusterSnapshotConfigModel.getClusters().setItems((List<Cluster>) returnValue);
                }
            }
        }
    }));
    clusterSnapshotConfigModel.getClusterConfigOptions().setTitle(ConstantsManager.getInstance().getConstants().configureClusterSnapshotOptionsTitle());
    // $NON-NLS-1$
    UICommand updateCommand = new UICommand("confirmConfigureClusterSnapshotOptions", this);
    updateCommand.setTitle(constants.snapshotConfigUpdateButtonLabel());
    updateCommand.setIsDefault(true);
    clusterSnapshotConfigModel.getCommands().add(updateCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(constants.cancel());
    cancelCommand.setIsCancel(true);
    clusterSnapshotConfigModel.getCommands().add(cancelCommand);
}
#end_block

#method_before
public void configureVolumeSnapshotOptions() {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItems().get(0);
    final GlusterVolumeSnapshotConfigModel volumeSnapshotConfigModel = new GlusterVolumeSnapshotConfigModel(volumeEntity);
    volumeSnapshotConfigModel.setHelpTag(HelpTag.configure_volume_snapshot);
    // $NON-NLS-1$
    volumeSnapshotConfigModel.setHashName("configure_volume_snapshot");
    volumeSnapshotConfigModel.setTitle(ConstantsManager.getInstance().getConstants().configureVolumeSnapshotOptionsTitle());
    setWindow(volumeSnapshotConfigModel);
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            volumeSnapshotConfigModel.getClusterName().setEntity(((Cluster) returnValue).getName());
        }
    }), volumeEntity.getClusterId());
    volumeSnapshotConfigModel.getVolumeName().setEntity(volumeEntity.getName());
    // $NON-NLS-1$
    UICommand updateCommand = new UICommand("confirmConfigureVolumeSnapshotOptions", this);
    updateCommand.setTitle(constants.snapshotConfigUpdateButtonLabel());
    updateCommand.setIsDefault(true);
    volumeSnapshotConfigModel.getCommands().add(updateCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(constants.cancel());
    cancelCommand.setIsCancel(true);
    volumeSnapshotConfigModel.getCommands().add(cancelCommand);
}
#method_after
public void configureVolumeSnapshotOptions() {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    GlusterVolumeEntity volumeEntity = getSelectedItems().get(0);
    final GlusterVolumeSnapshotConfigModel volumeSnapshotConfigModel = new GlusterVolumeSnapshotConfigModel(volumeEntity);
    volumeSnapshotConfigModel.setHelpTag(HelpTag.configure_volume_snapshot);
    // $NON-NLS-1$
    volumeSnapshotConfigModel.setHashName("configure_volume_snapshot");
    volumeSnapshotConfigModel.setTitle(ConstantsManager.getInstance().getConstants().configureVolumeSnapshotOptionsTitle());
    setWindow(volumeSnapshotConfigModel);
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            volumeSnapshotConfigModel.getClusterName().setEntity(((Cluster) returnValue).getName());
        }
    }), volumeEntity.getClusterId());
    volumeSnapshotConfigModel.getVolumeName().setEntity(volumeEntity.getName());
    // $NON-NLS-1$
    UICommand updateCommand = new UICommand("confirmConfigureVolumeSnapshotOptions", this);
    updateCommand.setTitle(constants.snapshotConfigUpdateButtonLabel());
    updateCommand.setIsDefault(true);
    volumeSnapshotConfigModel.getCommands().add(updateCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(constants.cancel());
    cancelCommand.setIsCancel(true);
    volumeSnapshotConfigModel.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void addReportedIpConfiguration(ReportedConfigurations result) {
    if (!isPrimaryAddressExist()) {
        return;
    }
    NetworkBootProtocol definedBootProtocol = getPrimaryAddress().getBootProtocol();
    result.add(ReportedConfigurationType.BOOT_PROTOCOL, iface.getBootProtocol(), definedBootProtocol);
    if (definedBootProtocol == NetworkBootProtocol.STATIC_IP && iface.getBootProtocol() == definedBootProtocol) {
        result.add(ReportedConfigurationType.NETMASK, iface.getSubnet(), getPrimaryAddress().getNetmask(), isNetworkSubnetInSync());
        result.add(ReportedConfigurationType.IP_ADDRESS, iface.getAddress(), getPrimaryAddress().getAddress());
        result.add(ReportedConfigurationType.GATEWAY, iface.getGateway(), getPrimaryAddress().getGateway());
    }
}
#method_after
private void addReportedIpConfiguration(ReportedConfigurations result) {
    if (!isPrimaryAddressExist()) {
        return;
    }
    NetworkBootProtocol definedBootProtocol = getPrimaryAddress().getBootProtocol();
    result.add(ReportedConfigurationType.BOOT_PROTOCOL, iface.getBootProtocol(), definedBootProtocol);
    if (definedBootProtocol == NetworkBootProtocol.STATIC_IP && iface.getBootProtocol() == definedBootProtocol) {
        result.add(ReportedConfigurationType.NETMASK, iface.getSubnet(), getPrimaryAddress().getNetmask(), isNetworkSubnetInSync());
        result.add(ReportedConfigurationType.IP_ADDRESS, iface.getAddress(), getPrimaryAddress().getAddress());
        result.add(ReportedConfigurationType.GATEWAY, iface.getGateway(), getPrimaryAddress().getGateway(), isGatewayInSync());
    }
}
#end_block

#method_before
private boolean refreshImageDomain(final StorageDomain storageDomain, final ImageFileType imageType) {
    final RepoFileMetaDataDao repoFileMetaDataDao = repoStorageDom;
    Provider provider = providerDao.get(new Guid(storageDomain.getStorage()));
    final OpenStackImageProviderProxy client = ProviderProxyFactory.getInstance().create(provider);
    Lock syncObject = getSyncObject(storageDomain.getId(), imageType);
    try {
        syncObject.lock();
        return (Boolean) TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, () -> {
            repoFileMetaDataDao.removeRepoDomainFileList(storageDomain.getId(), imageType);
            Integer totalListSize = Config.<Integer>getValue(ConfigValues.GlanceImageTotalListSize);
            List<RepoImage> repoImages = client.getAllImagesAsRepoImages(Config.<Integer>getValue(ConfigValues.GlanceImageListSize), totalListSize);
            if (repoImages.size() >= totalListSize) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.addCustomValue("imageDomain", storageDomain.getName());
                logable.addCustomValue("imageListSize", String.valueOf(repoImages.size()));
                auditLogDirector.log(logable, AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE);
            }
            for (RepoImage repoImage : repoImages) {
                repoImage.setRepoDomainId(storageDomain.getId());
                repoFileMetaDataDao.addRepoFileMap(repoImage);
            }
            return true;
        });
    } finally {
        syncObject.unlock();
    }
}
#method_after
private boolean refreshImageDomain(final StorageDomain storageDomain, final ImageFileType imageType) {
    final RepoFileMetaDataDao repoFileMetaDataDao = repoStorageDom;
    Provider provider = providerDao.get(new Guid(storageDomain.getStorage()));
    final OpenStackImageProviderProxy client = ProviderProxyFactory.getInstance().create(provider);
    Lock syncObject = getSyncObject(storageDomain.getId(), imageType);
    try {
        syncObject.lock();
        return TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, () -> {
            repoFileMetaDataDao.removeRepoDomainFileList(storageDomain.getId(), imageType);
            Integer totalListSize = Config.<Integer>getValue(ConfigValues.GlanceImageTotalListSize);
            List<RepoImage> repoImages = client.getAllImagesAsRepoImages(Config.<Integer>getValue(ConfigValues.GlanceImageListSize), totalListSize);
            if (repoImages.size() >= totalListSize) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.addCustomValue("imageDomain", storageDomain.getName());
                logable.addCustomValue("imageListSize", String.valueOf(repoImages.size()));
                auditLogDirector.log(logable, AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE);
            }
            for (RepoImage repoImage : repoImages) {
                repoImage.setRepoDomainId(storageDomain.getId());
                repoFileMetaDataDao.addRepoFileMap(repoImage);
            }
            return true;
        });
    } finally {
        syncObject.unlock();
    }
}
#end_block

#method_before
private boolean updateIsoListFromVDSM(Guid repoStoragePoolId, Guid repoStorageDomainId, Map<String, Map<String, Object>> fileStats) {
    FileListRefreshed fileListRefreshed = new FileListRefreshed() {

        @Override
        public void onFileListRefreshed(Guid poolId, Set<String> isoList) {
            VmHandler.refreshVmsToolsVersion(poolId, isoList);
        }
    };
    return refreshVdsmFileList(repoStoragePoolId, repoStorageDomainId, ImageFileType.ISO, fileStats, fileListRefreshed);
}
#method_after
private boolean updateIsoListFromVDSM(Guid repoStoragePoolId, Guid repoStorageDomainId, Map<String, Map<String, Object>> fileStats) {
    return refreshVdsmFileList(repoStoragePoolId, repoStorageDomainId, ImageFileType.ISO, fileStats, VmHandler::refreshVmsToolsVersion);
}
#end_block

#method_before
public void initBalloonSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            balloonSupportMap = (Map<Integer, Map<Version, Boolean>>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetBalloonSupportMap), callback);
}
#method_after
public void initBalloonSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            balloonSupportMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetBalloonSupportMap), callback);
}
#end_block

#method_before
@Override
protected void init() {
    T parameters = getParameters();
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (VmDeviceUtils.shouldOverrideSoundDevice(getParameters().getMasterVm(), getVm().getCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        VmHandler.updateDefaultTimeZone(parameterMasterVm);
        VmHandler.autoSelectUsbPolicy(getParameters().getMasterVm(), getCluster());
        VmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#method_after
@Override
protected void init() {
    T parameters = getParameters();
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (VmDeviceUtils.shouldOverrideSoundDevice(getParameters().getMasterVm(), getVm() == null ? CompatibilityVersionUtils.getEffective(parameterMasterVm, getCluster()) : getVm().getCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        VmHandler.updateDefaultTimeZone(parameterMasterVm);
        VmHandler.autoSelectUsbPolicy(getParameters().getMasterVm(), getCluster());
        VmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#end_block

#method_before
protected void separateCustomProperties(VmStatic parameterMasterVm) {
    if (getCluster() != null) {
        // Parses the custom properties field that was filled by frontend to
        // predefined and user defined fields
        VmPropertiesUtils.getInstance().separateCustomPropertiesToUserAndPredefined(getVm().getCompatibilityVersion(), parameterMasterVm);
    }
}
#method_after
protected void separateCustomProperties(VmStatic parameterMasterVm) {
    if (getCluster() != null) {
        // Parses the custom properties field that was filled by frontend to
        // predefined and user defined fields
        VmPropertiesUtils.getInstance().separateCustomPropertiesToUserAndPredefined(getVm() == null ? CompatibilityVersionUtils.getEffective(parameterMasterVm, getCluster()) : getVm().getCompatibilityVersion(), parameterMasterVm);
    }
}
#end_block

#method_before
private Set<Guid> getStorageGuidSet() {
    Set<Guid> destImageDomains = new HashSet<>();
    for (DiskImage diskImage : diskInfoDestinationMap.values()) {
        destImageDomains.add(diskImage.getStorageIds().get(0));
    }
    return destImageDomains;
}
#method_after
private Set<Guid> getStorageGuidSet() {
    return diskInfoDestinationMap.values().stream().map(d -> d.getStorageIds().get(0)).collect(Collectors.toSet());
}
#end_block

#method_before
protected void addVmTemplateImage(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, DiskImage diskImage) {
    // The return value of this action is the 'copyImage' task GUID:
    VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, buildChildCommandParameters(diskImage, Guid.newGuid()), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!retValue.getSucceeded()) {
        throw new EngineException(retValue.getFault().getError(), retValue.getFault().getMessage());
    }
    getReturnValue().getVdsmTaskIdList().addAll(retValue.getInternalVdsmTaskIdList());
    DiskImage newImage = (DiskImage) retValue.getActionReturnValue();
    srcDeviceIdToTargetDeviceIdMapping.put(diskImage.getId(), newImage.getId());
}
#method_after
protected void addVmTemplateImage(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, DiskImage diskImage) {
    // The return value of this action is the 'copyImage' task GUID:
    VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, buildChildCommandParameters(diskImage, Guid.newGuid()), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!retValue.getSucceeded()) {
        throw new EngineException(retValue.getFault().getError(), retValue.getFault().getMessage());
    }
    getReturnValue().getVdsmTaskIdList().addAll(retValue.getInternalVdsmTaskIdList());
    DiskImage newImage = retValue.getActionReturnValue();
    srcDeviceIdToTargetDeviceIdMapping.put(diskImage.getId(), newImage.getId());
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    for (DiskImage disk : getVm().getDiskList()) {
        list.add(new QuotaStorageConsumptionParameter(getQuotaIdForDisk(disk), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, disk.getStorageIds().get(0), (double) disk.getSizeInGigabytes()));
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    return getVm().getDiskList().stream().map(disk -> new QuotaStorageConsumptionParameter(getQuotaIdForDisk(disk), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, disk.getStorageIds().get(0), (double) disk.getSizeInGigabytes())).collect(Collectors.toList());
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getDisk() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    if (getVm() == null) {
        addValidationMessageVariable("diskAliases", getDiskAlias());
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_IS_NOT_VM_DISK);
    }
    if (getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Arrays.asList((DiskImage) getDisk()));
        if (!validate(diskImagesValidator.diskImagesNotLocked()) || !validate(diskImagesValidator.diskImagesNotIllegal())) {
            return false;
        }
        StorageDomainStatic sds = getStorageDomainStaticDao().get(((DiskImage) getDisk()).getStorageIds().get(0));
        if (!sds.getStorageType().isBlockDomain()) {
            addValidationMessageVariable("diskAlias", getDiskAlias());
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_ALIGNMENT_SCAN_STORAGE_TYPE);
        }
    }
    if (getVm().isRunningOrPaused()) {
        return failValidation(EngineMessage.ERROR_CANNOT_RUN_ALIGNMENT_SCAN_VM_IS_RUNNING);
    }
    if (getVdsIdInGroup() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    }
    StoragePool sp = getStoragePoolDao().get(getStoragePoolId());
    if (!validate(new StoragePoolValidator(sp).isUp())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getDisk() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    if (getVm() == null) {
        addValidationMessageVariable("diskAliases", getDiskAlias());
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_IS_NOT_VM_DISK);
    }
    if (getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Collections.singletonList((DiskImage) getDisk()));
        if (!validate(diskImagesValidator.diskImagesNotLocked()) || !validate(diskImagesValidator.diskImagesNotIllegal())) {
            return false;
        }
        StorageDomainStatic sds = getStorageDomainStaticDao().get(((DiskImage) getDisk()).getStorageIds().get(0));
        if (!sds.getStorageType().isBlockDomain()) {
            addValidationMessageVariable("diskAlias", getDiskAlias());
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_ALIGNMENT_SCAN_STORAGE_TYPE);
        }
    }
    if (getVm().isRunningOrPaused()) {
        return failValidation(EngineMessage.ERROR_CANNOT_RUN_ALIGNMENT_SCAN_VM_IS_RUNNING);
    }
    if (getVdsIdInGroup() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    }
    StoragePool sp = getStoragePoolDao().get(getStoragePoolId());
    if (!validate(new StoragePoolValidator(sp).isUp())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public VM getVm() {
    if (diskVm == null && getDisk() != null) {
        for (VM vm : getVmDao().getVmsListForDisk(getDisk().getId(), false)) {
            diskVm = vm;
            break;
        }
    }
    return diskVm;
}
#method_after
@Override
public VM getVm() {
    if (diskVm == null && getDisk() != null) {
        diskVm = getVmDao().getVmsListForDisk(getDisk().getId(), false).stream().findFirst().orElse(null);
    }
    return diskVm;
}
#end_block

#method_before
protected Disk getDisk() {
    if (diskToScan == null) {
        diskToScan = getDiskDao().get((Guid) getParameters().getDiskId());
    }
    return diskToScan;
}
#method_after
protected Disk getDisk() {
    if (diskToScan == null) {
        diskToScan = getDiskDao().get(getParameters().getDiskId());
    }
    return diskToScan;
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewSessionCommand())) {
        createGeoRepSession();
    } else if (command.equals(getRemoveSessionCommand())) {
        // $NON-NLS-1$//$NON-NLS-2$
        confirmGeoRepAction(constants.geoReplicationRemoveTitle(), HelpTag.volume_geo_rep_remove_confirmation, "volume_geo_rep_remove_confirmation", "removeGeoRepSession", constants.removeGeoRep());
    } else if (command.equals(getStartSessionCommand())) {
        startGeoRepSession();
    } else if (command.equals(getStopSessionCommand())) {
        // $NON-NLS-1$//$NON-NLS-2$
        confirmGeoRepAction(constants.geoReplicationStopTitle(), HelpTag.volume_geo_rep_stop_confirmation, "volume_geo_rep_stop_confirmation", "stopGeoRepSesssion", constants.stopGeoRep());
    } else if (command.equals(getPauseSessionCommand())) {
        // $NON-NLS-1$//$NON-NLS-2$
        confirmGeoRepAction(constants.geoReplicationPauseTitle(), HelpTag.volume_geo_rep_pause_confirmation, "volume_geo_rep_pause_confirmation", "pauseGeoRepSession", constants.pauseGeoRep());
    } else if (command.equals(getResumeSessionCommand())) {
        resumeGeoRepSession();
    } else if (command.equals(getSessionOptionsCommand())) {
        showSessionOptions();
    } else if (command.equals(getViewSessionDetailsCommand())) {
        showGeoRepSessionDetails((GlusterGeoRepSession) getSelectedItem());
    } else if (command.equals(getRefreshSessionsCommand())) {
        refreshSessions();
    } else if (command.getName().equalsIgnoreCase("onCreateSession")) {
        // $NON-NLS-1$
        onCreateSession();
    } else if (command.getName().equalsIgnoreCase("onStartGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.StartGlusterVolumeGeoRep);
    } else if (command.getName().equalsIgnoreCase("onStopGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.StopGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onPauseGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.PauseGlusterVolumeGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onResumeGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.ResumeGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onRemoveGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.DeleteGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("ok")) {
        // $NON-NLS-1$
        updateConfig();
    } else if (command.getName().equalsIgnoreCase("closeWindow")) {
        // $NON-NLS-1$
        closeWindow();
    } else if (command.getName().equalsIgnoreCase("stopGeoRepSesssion")) {
        // $NON-NLS-1$
        stopGeoRepSession();
    } else if (command.getName().equalsIgnoreCase("removeGeoRepSession")) {
        // $NON-NLS-1$
        removeGeoRepSession();
    } else if (command.getName().equalsIgnoreCase("pauseGeoRepSession")) {
        // $NON-NLS-1$
        pauseGeoRepSession();
    } else if (command.getName().equalsIgnoreCase("closeConfirmWindow")) {
        // $NON-NLS-1$
        closeConfirmWindow();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewSessionCommand())) {
        createGeoRepSession();
    } else if (command.equals(getRemoveSessionCommand())) {
        // $NON-NLS-1$//$NON-NLS-2$
        confirmGeoRepAction(constants.geoReplicationRemoveTitle(), HelpTag.volume_geo_rep_remove_confirmation, "volume_geo_rep_remove_confirmation", "removeGeoRepSession", constants.removeGeoRep());
    } else if (command.equals(getStartSessionCommand())) {
        startGeoRepSession();
    } else if (command.equals(getStopSessionCommand())) {
        // $NON-NLS-1$//$NON-NLS-2$
        confirmGeoRepAction(constants.geoReplicationStopTitle(), HelpTag.volume_geo_rep_stop_confirmation, "volume_geo_rep_stop_confirmation", "stopGeoRepSesssion", constants.stopGeoRep());
    } else if (command.equals(getPauseSessionCommand())) {
        // $NON-NLS-1$//$NON-NLS-2$
        confirmGeoRepAction(constants.geoReplicationPauseTitle(), HelpTag.volume_geo_rep_pause_confirmation, "volume_geo_rep_pause_confirmation", "pauseGeoRepSession", constants.pauseGeoRep());
    } else if (command.equals(getResumeSessionCommand())) {
        resumeGeoRepSession();
    } else if (command.equals(getSessionOptionsCommand())) {
        showSessionOptions();
    } else if (command.equals(getViewSessionDetailsCommand())) {
        showGeoRepSessionDetails(getSelectedItem());
    } else if (command.equals(getRefreshSessionsCommand())) {
        refreshSessions();
    } else if (command.getName().equalsIgnoreCase("onCreateSession")) {
        // $NON-NLS-1$
        onCreateSession();
    } else if (command.getName().equalsIgnoreCase("onStartGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.StartGlusterVolumeGeoRep);
    } else if (command.getName().equalsIgnoreCase("onStopGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.StopGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onPauseGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.PauseGlusterVolumeGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onResumeGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.ResumeGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onRemoveGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.DeleteGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("ok")) {
        // $NON-NLS-1$
        updateConfig();
    } else if (command.getName().equalsIgnoreCase("closeWindow")) {
        // $NON-NLS-1$
        closeWindow();
    } else if (command.getName().equalsIgnoreCase("stopGeoRepSesssion")) {
        // $NON-NLS-1$
        stopGeoRepSession();
    } else if (command.getName().equalsIgnoreCase("removeGeoRepSession")) {
        // $NON-NLS-1$
        removeGeoRepSession();
    } else if (command.getName().equalsIgnoreCase("pauseGeoRepSession")) {
        // $NON-NLS-1$
        pauseGeoRepSession();
    } else if (command.getName().equalsIgnoreCase("closeConfirmWindow")) {
        // $NON-NLS-1$
        closeConfirmWindow();
    }
}
#end_block

#method_before
private void fetchConfigForSession(GlusterGeoRepSession selectedSession) {
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeGeoRepConfigList, new IdQueryParameters(selectedSession.getId()), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue vdcQueryReturnValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeGeoReplicationSessionConfigModel geoRepConfigModel = (GlusterVolumeGeoReplicationSessionConfigModel) getWindow();
            geoRepConfigModel.stopProgress();
            boolean queryExecutionStatus = vdcQueryReturnValue.getSucceeded();
            geoRepConfigModel.updateCommandExecutabilities(queryExecutionStatus);
            if (!queryExecutionStatus) {
                geoRepConfigModel.setMessage(ConstantsManager.getInstance().getConstants().errorInFetchingVolumeOptionList());
            } else {
                List<GlusterGeoRepSessionConfiguration> sessionConfigs = (List<GlusterGeoRepSessionConfiguration>) vdcQueryReturnValue.getReturnValue();
                List<EntityModel<Pair<Boolean, GlusterGeoRepSessionConfiguration>>> sessionConfigEntities = new ArrayList<>();
                for (GlusterGeoRepSessionConfiguration currentSession : sessionConfigs) {
                    sessionConfigEntities.add(new EntityModel<>(new Pair<>(false, currentSession)));
                }
                geoRepConfigModel.getConfigsModel().setItems(sessionConfigEntities);
                geoRepConfigModel.copyConfigsToMap(sessionConfigs);
            }
        }
    }));
}
#method_after
private void fetchConfigForSession(GlusterGeoRepSession selectedSession) {
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeGeoRepConfigList, new IdQueryParameters(selectedSession.getId()), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue vdcQueryReturnValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeGeoReplicationSessionConfigModel geoRepConfigModel = (GlusterVolumeGeoReplicationSessionConfigModel) getWindow();
            geoRepConfigModel.stopProgress();
            boolean queryExecutionStatus = vdcQueryReturnValue.getSucceeded();
            geoRepConfigModel.updateCommandExecutabilities(queryExecutionStatus);
            if (!queryExecutionStatus) {
                geoRepConfigModel.setMessage(ConstantsManager.getInstance().getConstants().errorInFetchingVolumeOptionList());
            } else {
                List<GlusterGeoRepSessionConfiguration> sessionConfigs = vdcQueryReturnValue.getReturnValue();
                List<EntityModel<Pair<Boolean, GlusterGeoRepSessionConfiguration>>> sessionConfigEntities = new ArrayList<>();
                for (GlusterGeoRepSessionConfiguration currentSession : sessionConfigs) {
                    sessionConfigEntities.add(new EntityModel<>(new Pair<>(false, currentSession)));
                }
                geoRepConfigModel.getConfigsModel().setItems(sessionConfigEntities);
                geoRepConfigModel.copyConfigsToMap(sessionConfigs);
            }
        }
    }));
}
#end_block

#method_before
private void startGeoRepSession() {
    // $NON-NLS-1$//$NON-NLS-2$
    performGeoRepAction("onStartGeoRepSession", constants.geoReplicationStartTitle(), HelpTag.volume_geo_rep_start_confirmation, "volume_geo_rep_start_confirmation", constants.startGeoRep(), VdcActionType.StartGlusterVolumeGeoRep, constants.startGeoRepProgressText());
}
#method_after
private void startGeoRepSession() {
    // $NON-NLS-1$//$NON-NLS-2$
    performGeoRepAction("onStartGeoRepSession", constants.geoReplicationStartTitle(), HelpTag.volume_geo_rep_start_confirmation, "volume_geo_rep_start_confirmation", constants.startGeoRep(), VdcActionType.StartGlusterVolumeGeoRep);
}
#end_block

#method_before
private void stopGeoRepSession() {
    // $NON-NLS-1$//$NON-NLS-2$
    performGeoRepAction("onStopGeoRepSession", constants.geoReplicationStopTitle(), HelpTag.volume_geo_rep_stop_confirmation, "volume_geo_rep_stop_confirmation", constants.stopGeoRep(), VdcActionType.StopGeoRepSession, constants.stopGeoRepProgressText());
}
#method_after
private void stopGeoRepSession() {
    // $NON-NLS-1$//$NON-NLS-2$
    performGeoRepAction("onStopGeoRepSession", constants.geoReplicationStopTitle(), HelpTag.volume_geo_rep_stop_confirmation, "volume_geo_rep_stop_confirmation", constants.stopGeoRep(), VdcActionType.StopGeoRepSession);
}
#end_block

#method_before
private void pauseGeoRepSession() {
    // $NON-NLS-1$//$NON-NLS-2$
    performGeoRepAction("onPauseGeoRepSession", constants.geoReplicationPauseTitle(), HelpTag.volume_geo_rep_pause_confirmation, "volume_geo_rep_pause_confirmation", constants.pauseGeoRep(), VdcActionType.PauseGlusterVolumeGeoRepSession, constants.pauseGeoRepProgressText());
}
#method_after
private void pauseGeoRepSession() {
    // $NON-NLS-1$//$NON-NLS-2$
    performGeoRepAction("onPauseGeoRepSession", constants.geoReplicationPauseTitle(), HelpTag.volume_geo_rep_pause_confirmation, "volume_geo_rep_pause_confirmation", constants.pauseGeoRep(), VdcActionType.PauseGlusterVolumeGeoRepSession);
}
#end_block

#method_before
private void resumeGeoRepSession() {
    // $NON-NLS-1$//$NON-NLS-2$
    performGeoRepAction("onResumeGeoRepSession", constants.geoReplicationResumeTitle(), HelpTag.volume_geo_rep_resume_confirmation, "volume_geo_rep_resume_confirmation", constants.resumeGeoRep(), VdcActionType.ResumeGeoRepSession, constants.resumeGeoRepProgressText());
}
#method_after
private void resumeGeoRepSession() {
    // $NON-NLS-1$//$NON-NLS-2$
    performGeoRepAction("onResumeGeoRepSession", constants.geoReplicationResumeTitle(), HelpTag.volume_geo_rep_resume_confirmation, "volume_geo_rep_resume_confirmation", constants.resumeGeoRep(), VdcActionType.ResumeGeoRepSession);
}
#end_block

#method_before
private void removeGeoRepSession() {
    // $NON-NLS-1$//$NON-NLS-2$
    performGeoRepAction("onRemoveGeoRepSession", constants.geoReplicationRemoveTitle(), HelpTag.volume_geo_rep_remove_confirmation, "volume_geo_rep_remove_confirmation", constants.removeGeoRep(), VdcActionType.DeleteGeoRepSession, constants.removeGeoRepProgressText());
}
#method_after
private void removeGeoRepSession() {
    // $NON-NLS-1$//$NON-NLS-2$
    performGeoRepAction("onRemoveGeoRepSession", constants.geoReplicationRemoveTitle(), HelpTag.volume_geo_rep_remove_confirmation, "volume_geo_rep_remove_confirmation", constants.removeGeoRep(), VdcActionType.DeleteGeoRepSession);
}
#end_block

#method_before
private void performGeoRepAction(String commandName, String confirmTitle, HelpTag helpTag, String hashName, String action, VdcActionType actionType, String actionProgressText) {
    GlusterGeoRepSession selectedSession = getSelectedItem();
    if (selectedSession == null) {
        return;
    }
    initializeGeoRepActionConfirmation(confirmTitle, helpTag, hashName, constants.geoRepForceHelp(), messages.geoRepForceTitle(action), commandName, selectedSession.getMasterVolumeName(), selectedSession.getSlaveVolumeName(), selectedSession.getSlaveHostName(), null);
    onGeoRepSessionAction(actionType);
}
#method_after
private void performGeoRepAction(String commandName, String confirmTitle, HelpTag helpTag, String hashName, String action, VdcActionType actionType) {
    GlusterGeoRepSession selectedSession = getSelectedItem();
    if (selectedSession == null) {
        return;
    }
    initializeGeoRepActionConfirmation(confirmTitle, helpTag, hashName, constants.geoRepForceHelp(), messages.geoRepForceTitle(action), commandName, selectedSession.getMasterVolumeName(), selectedSession.getSlaveVolumeName(), selectedSession.getSlaveHostName(), null);
    onGeoRepSessionAction(actionType);
}
#end_block

#method_before
protected <P extends VdcActionParametersBase> P sessionize(P parameters) {
    String sessionId = getCurrent().getSessionId();
    parameters.setSessionId(sessionId);
    return parameters;
}
#method_after
protected <P extends VdcQueryParametersBase> P sessionize(P parameters) {
    String sessionId = getCurrent().getSessionId();
    parameters.setSessionId(sessionId);
    return parameters;
}
#end_block

#method_before
protected void initMainTable() {
    this.table = new ListModelObjectCellTable<>();
    AbstractImageResourceColumn<Object> isProblematicImportVmColumn = new AbstractImageResourceColumn<Object>() {

        @Override
        public ImageResource getValue(Object object) {
            ImportVmData importVmData = (ImportVmData) object;
            if (importVmData.getError() != null || importVmData.isNameExistsInTheSystem()) {
                return resources.errorImage();
            }
            if (importVmData.getWarning() != null) {
                return resources.alertImage();
            }
            return null;
        }

        @Override
        public SafeHtml getTooltip(Object object) {
            ImportVmData importVmData = (ImportVmData) object;
            String problem = null;
            if (importVmData.getError() != null) {
                problem = importVmData.getError();
            } else {
                problem = importVmData.isNameExistsInTheSystem() ? ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason() : importVmData.getWarning();
            }
            return problem != null ? SafeHtmlUtils.fromSafeConstant(problem) : null;
        }
    };
    // $NON-NLS-1$
    table.addColumn(isProblematicImportVmColumn, constants.empty(), "20px");
    AbstractTextColumn<Object> nameColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            String originalName = ((ImportVmData) object).getName();
            String givenName = ((ImportVmData) object).getVm().getName();
            return originalName.equals(givenName) ? givenName : // $NON-NLS-1$ //$NON-NLS-2$
            givenName + " (" + originalName + ")";
        }
    };
    // $NON-NLS-1$
    table.addColumn(nameColumn, constants.nameVm(), "150px");
    AbstractCheckboxColumn<Object> collapseSnapshotsColumn = new AbstractCheckboxColumn<Object>(new FieldUpdater<Object, Boolean>() {

        @Override
        public void update(int index, Object model, Boolean value) {
            ((ImportVmData) model).getCollapseSnapshots().setEntity(value);
            customSelectionCellFormatType.setEnabled(value);
            diskTable.asEditor().edit(importModel.getImportDiskListModel());
        }
    }) {

        @Override
        public Boolean getValue(Object model) {
            return ((ImportVmData) model).getCollapseSnapshots().getEntity();
        }

        @Override
        protected boolean canEdit(Object model) {
            return ((ImportVmData) model).getCollapseSnapshots().getIsChangable();
        }

        @Override
        protected String getDisabledMessage(Object model) {
            return ((ImportVmData) model).getCollapseSnapshots().getChangeProhibitionReason();
        }

        @Override
        public SafeHtml getTooltip(Object object) {
            SafeHtml superTooltip = super.getTooltip(object);
            if (superTooltip == null) {
                return SafeHtmlUtils.fromSafeConstant(constants.importAllocationModifiedCollapse());
            }
            return superTooltip;
        }
    };
    // $NON-NLS-1$
    table.addColumn(collapseSnapshotsColumn, constants.collapseSnapshots(), "10px");
    AbstractCheckboxColumn<Object> cloneVMColumn = new AbstractCheckboxColumn<Object>(new FieldUpdater<Object, Boolean>() {

        @Override
        public void update(int index, Object model, Boolean value) {
            ((ImportVmData) model).getClone().setEntity(value);
            table.asEditor().edit(importModel);
        }
    }) {

        @Override
        public Boolean getValue(Object model) {
            return ((ImportVmData) model).getClone().getEntity();
        }

        @Override
        protected boolean canEdit(Object model) {
            return ((ImportVmData) model).getClone().getIsChangable();
        }

        @Override
        protected String getDisabledMessage(Object model) {
            return ((ImportVmData) model).getClone().getChangeProhibitionReason();
        }
    };
    // $NON-NLS-1$
    table.addColumn(cloneVMColumn, constants.cloneVM(), "50px");
    AbstractTextColumn<Object> originColumn = new AbstractEnumColumn<Object, OriginType>() {

        @Override
        protected OriginType getRawValue(Object object) {
            return ((ImportVmData) object).getVm().getOrigin();
        }
    };
    // $NON-NLS-1$
    table.addColumn(originColumn, constants.originVm(), "100px");
    table.addColumn(new AbstractImageResourceColumn<Object>() {

        @Override
        public com.google.gwt.resources.client.ImageResource getValue(Object object) {
            return new VmTypeColumn().getValue(((ImportVmData) object).getVm());
        }
    }, constants.empty(), // $NON-NLS-1$
    "30px");
    AbstractTextColumn<Object> memoryColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            // $NON-NLS-1$
            return String.valueOf(((ImportVmData) object).getVm().getVmMemSizeMb()) + " MB";
        }
    };
    // $NON-NLS-1$
    table.addColumn(memoryColumn, constants.memoryVm(), "100px");
    AbstractTextColumn<Object> cpuColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportVmData) object).getVm().getNumOfCpus());
        }
    };
    // $NON-NLS-1$
    table.addColumn(cpuColumn, constants.cpusVm(), "50px");
    AbstractTextColumn<Object> archColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportVmData) object).getVm().getClusterArch());
        }
    };
    // $NON-NLS-1$
    table.addColumn(archColumn, constants.architectureVm(), "50px");
    AbstractTextColumn<Object> diskColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportVmData) object).getVm().getDiskMap().size());
        }
    };
    // $NON-NLS-1$
    table.addColumn(diskColumn, constants.disksVm(), "50px");
    isObjectInSystemColumn = new AbstractImageResourceColumn<Object>() {

        @Override
        public ImageResource getValue(Object object) {
            return ((ImportVmData) object).isExistsInSystem() ? resources.logNormalImage() : null;
        }
    };
    // $NON-NLS-1$
    table.addColumn(isObjectInSystemColumn, constants.vmInSetup(), "60px");
    table.getSelectionModel().addSelectionChangeHandler(new SelectionChangeEvent.Handler() {

        @Override
        public void onSelectionChange(SelectionChangeEvent event) {
            ImportVmData selectedObject = ((SingleSelectionModel<ImportVmData>) event.getSource()).getSelectedObject();
            customSelectionCellFormatType.setEnabled((Boolean) selectedObject.getCollapseSnapshots().getEntity());
        // diskTable.edit(importVmModel.getImportDiskListModel());
        }
    });
    ScrollPanel sp = new ScrollPanel();
    sp.add(table);
    splitLayoutPanel.add(sp);
    table.getElement().getStyle().setPosition(Position.RELATIVE);
}
#method_after
protected void initMainTable() {
    this.table = new ListModelObjectCellTable<>();
    AbstractImageResourceColumn<Object> isProblematicImportVmColumn = new AbstractImageResourceColumn<Object>() {

        @Override
        public ImageResource getValue(Object object) {
            ImportVmData importVmData = (ImportVmData) object;
            if (importVmData.getError() != null || importVmData.isNameExistsInTheSystem()) {
                return resources.errorImage();
            }
            if (importVmData.getWarning() != null) {
                return resources.alertImage();
            }
            return null;
        }

        @Override
        public SafeHtml getTooltip(Object object) {
            ImportVmData importVmData = (ImportVmData) object;
            String problem = null;
            if (importVmData.getError() != null) {
                problem = importVmData.getError();
            } else {
                problem = importVmData.isNameExistsInTheSystem() ? ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason() : importVmData.getWarning();
            }
            return problem != null ? SafeHtmlUtils.fromSafeConstant(problem) : null;
        }
    };
    // $NON-NLS-1$
    table.addColumn(isProblematicImportVmColumn, constants.empty(), "20px");
    AbstractTextColumn<Object> nameColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            String originalName = ((ImportVmData) object).getName();
            String givenName = ((ImportVmData) object).getVm().getName();
            return originalName.equals(givenName) ? givenName : // $NON-NLS-1$ //$NON-NLS-2$
            givenName + " (" + originalName + ")";
        }
    };
    // $NON-NLS-1$
    table.addColumn(nameColumn, constants.nameVm(), "150px");
    AbstractCheckboxColumn<Object> collapseSnapshotsColumn = new AbstractCheckboxColumn<Object>(new FieldUpdater<Object, Boolean>() {

        @Override
        public void update(int index, Object model, Boolean value) {
            ((ImportVmData) model).getCollapseSnapshots().setEntity(value);
            customSelectionCellFormatType.setEnabled(value);
            diskTable.asEditor().edit(importModel.getImportDiskListModel());
        }
    }) {

        @Override
        public Boolean getValue(Object model) {
            return ((ImportVmData) model).getCollapseSnapshots().getEntity();
        }

        @Override
        protected boolean canEdit(Object model) {
            return ((ImportVmData) model).getCollapseSnapshots().getIsChangable();
        }

        @Override
        protected String getDisabledMessage(Object model) {
            return ((ImportVmData) model).getCollapseSnapshots().getChangeProhibitionReason();
        }

        @Override
        public SafeHtml getTooltip(Object object) {
            SafeHtml superTooltip = super.getTooltip(object);
            if (superTooltip == null) {
                return SafeHtmlUtils.fromSafeConstant(constants.importAllocationModifiedCollapse());
            }
            return superTooltip;
        }
    };
    // $NON-NLS-1$
    table.addColumn(collapseSnapshotsColumn, constants.collapseSnapshots(), "10px");
    AbstractCheckboxColumn<Object> cloneVMColumn = new AbstractCheckboxColumn<Object>(new FieldUpdater<Object, Boolean>() {

        @Override
        public void update(int index, Object model, Boolean value) {
            ((ImportVmData) model).getClone().setEntity(value);
            table.asEditor().edit(importModel);
        }
    }) {

        @Override
        public Boolean getValue(Object model) {
            return ((ImportVmData) model).getClone().getEntity();
        }

        @Override
        protected boolean canEdit(Object model) {
            return ((ImportVmData) model).getClone().getIsChangable();
        }

        @Override
        protected String getDisabledMessage(Object model) {
            return ((ImportVmData) model).getClone().getChangeProhibitionReason();
        }
    };
    // $NON-NLS-1$
    table.addColumn(cloneVMColumn, constants.cloneVM(), "50px");
    AbstractTextColumn<Object> originColumn = new AbstractEnumColumn<Object, OriginType>() {

        @Override
        protected OriginType getRawValue(Object object) {
            return ((ImportVmData) object).getVm().getOrigin();
        }
    };
    // $NON-NLS-1$
    table.addColumn(originColumn, constants.originVm(), "100px");
    table.addColumn(new AbstractImageResourceColumn<Object>() {

        @Override
        public com.google.gwt.resources.client.ImageResource getValue(Object object) {
            return new VmTypeColumn().getValue(((ImportVmData) object).getVm());
        }
    }, constants.empty(), // $NON-NLS-1$
    "30px");
    AbstractTextColumn<Object> memoryColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            // $NON-NLS-1$
            return String.valueOf(((ImportVmData) object).getVm().getVmMemSizeMb()) + " MB";
        }
    };
    // $NON-NLS-1$
    table.addColumn(memoryColumn, constants.memoryVm(), "100px");
    AbstractTextColumn<Object> cpuColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportVmData) object).getVm().getNumOfCpus());
        }
    };
    // $NON-NLS-1$
    table.addColumn(cpuColumn, constants.cpusVm(), "50px");
    AbstractTextColumn<Object> archColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportVmData) object).getVm().getClusterArch());
        }
    };
    // $NON-NLS-1$
    table.addColumn(archColumn, constants.architectureVm(), "50px");
    AbstractTextColumn<Object> diskColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportVmData) object).getVm().getDiskMap().size());
        }
    };
    // $NON-NLS-1$
    table.addColumn(diskColumn, constants.disksVm(), "50px");
    isObjectInSystemColumn = new AbstractImageResourceColumn<Object>() {

        @Override
        public ImageResource getValue(Object object) {
            return ((ImportVmData) object).isExistsInSystem() ? resources.logNormalImage() : null;
        }
    };
    // $NON-NLS-1$
    table.addColumn(isObjectInSystemColumn, constants.vmInSetup(), "60px");
    table.getSelectionModel().addSelectionChangeHandler(new SelectionChangeEvent.Handler() {

        @Override
        public void onSelectionChange(SelectionChangeEvent event) {
            ImportVmData selectedObject = ((SingleSelectionModel<ImportVmData>) event.getSource()).getSelectedObject();
            customSelectionCellFormatType.setEnabled(selectedObject.getCollapseSnapshots().getEntity());
        }
    });
    ScrollPanel sp = new ScrollPanel();
    sp.add(table);
    splitLayoutPanel.add(sp);
    table.getElement().getStyle().setPosition(Position.RELATIVE);
}
#end_block

#method_before
private void addStorageDomainsColumn() {
    customSelectionCellStorageDomain = new CustomSelectionCell(new ArrayList<String>());
    customSelectionCellStorageDomain.setStyle(style.cellSelectBox());
    storageDomainsColumn = new Column<DiskImage, String>(customSelectionCellStorageDomain) {

        @Override
        public String getValue(DiskImage disk) {
            ImportDiskData importData = importModel.getDiskImportData(disk.getId());
            ArrayList<String> storageDomainsNameList = new ArrayList<>();
            StorageDomain selectedStorageDomain = null;
            if (importData != null && importData.getStorageDomains() != null) {
                for (StorageDomain storageDomain : importData.getStorageDomains()) {
                    storageDomainsNameList.add(new StorageDomainFreeSpaceRenderer<>().render(storageDomain));
                    if (importData.getSelectedStorageDomain() != null) {
                        if (storageDomain.getId().equals(importData.getSelectedStorageDomain().getId())) {
                            selectedStorageDomain = storageDomain;
                        }
                    }
                }
            }
            ((CustomSelectionCell) getCell()).setOptions(storageDomainsNameList);
            if (!storageDomainsNameList.isEmpty()) {
                if (selectedStorageDomain != null) {
                    return new StorageDomainFreeSpaceRenderer<>().render(selectedStorageDomain);
                } else {
                    return storageDomainsNameList.get(0);
                }
            }
            return "";
        }
    };
    storageDomainsColumn.setFieldUpdater(new FieldUpdater<DiskImage, String>() {

        @Override
        public void update(int index, DiskImage disk, String value) {
            // $NON-NLS-1$
            String storageDomainName = value.substring(0, value.lastIndexOf(" ("));
            importModel.getDiskImportData(disk.getId()).setSelectedStorageDomainString(storageDomainName);
            diskTable.asEditor().edit(importModel.getImportDiskListModel());
        }
    });
    // $NON-NLS-1$
    diskTable.addColumn(storageDomainsColumn, constants.storageDomainDisk(), "180px");
}
#method_after
private void addStorageDomainsColumn() {
    CustomSelectionCell customSelectionCellStorageDomain = new CustomSelectionCell(new ArrayList<String>());
    customSelectionCellStorageDomain.setStyle(style.cellSelectBox());
    Column<DiskImage, String> storageDomainsColumn = new Column<DiskImage, String>(customSelectionCellStorageDomain) {

        @Override
        public String getValue(DiskImage disk) {
            ImportDiskData importData = importModel.getDiskImportData(disk.getId());
            ArrayList<String> storageDomainsNameList = new ArrayList<>();
            StorageDomain selectedStorageDomain = null;
            if (importData != null && importData.getStorageDomains() != null) {
                for (StorageDomain storageDomain : importData.getStorageDomains()) {
                    storageDomainsNameList.add(new StorageDomainFreeSpaceRenderer<>().render(storageDomain));
                    if (importData.getSelectedStorageDomain() != null) {
                        if (storageDomain.getId().equals(importData.getSelectedStorageDomain().getId())) {
                            selectedStorageDomain = storageDomain;
                        }
                    }
                }
            }
            ((CustomSelectionCell) getCell()).setOptions(storageDomainsNameList);
            if (!storageDomainsNameList.isEmpty()) {
                if (selectedStorageDomain != null) {
                    return new StorageDomainFreeSpaceRenderer<>().render(selectedStorageDomain);
                } else {
                    return storageDomainsNameList.get(0);
                }
            }
            return "";
        }
    };
    storageDomainsColumn.setFieldUpdater(new FieldUpdater<DiskImage, String>() {

        @Override
        public void update(int index, DiskImage disk, String value) {
            // $NON-NLS-1$
            String storageDomainName = value.substring(0, value.lastIndexOf(" ("));
            importModel.getDiskImportData(disk.getId()).setSelectedStorageDomainString(storageDomainName);
            diskTable.asEditor().edit(importModel.getImportDiskListModel());
        }
    });
    // $NON-NLS-1$
    diskTable.addColumn(storageDomainsColumn, constants.storageDomainDisk(), "180px");
}
#end_block

#method_before
private void addStorageQuotaColumn() {
    if (!importModel.isQuotaEnabled()) {
        return;
    }
    if (quotaColumn != null) {
        return;
    }
    customSelectionCellQuota = new CustomSelectionCell(new ArrayList<String>());
    customSelectionCellQuota.setStyle(style.cellSelectBox());
    quotaColumn = new Column<DiskImage, String>(customSelectionCellQuota) {

        @Override
        public String getValue(DiskImage disk) {
            ImportDiskData importData = importModel.getDiskImportData(disk.getId());
            ArrayList<String> storageQuotaList = new ArrayList<>();
            Quota selectedQuota = null;
            if (importData != null && importData.getQuotaList() != null) {
                for (Quota quota : importData.getQuotaList()) {
                    storageQuotaList.add(quota.getQuotaName());
                    if (importData.getSelectedQuota() != null) {
                        if (quota.getId().equals(importData.getSelectedQuota().getId())) {
                            selectedQuota = quota;
                        }
                    }
                }
            }
            ((CustomSelectionCell) getCell()).setOptions(storageQuotaList);
            if (!storageQuotaList.isEmpty()) {
                if (selectedQuota != null) {
                    return selectedQuota.getQuotaName();
                } else {
                    return storageQuotaList.get(0);
                }
            }
            return "";
        }
    };
    quotaColumn.setFieldUpdater(new FieldUpdater<DiskImage, String>() {

        @Override
        public void update(int index, DiskImage disk, String value) {
            importModel.getDiskImportData(disk.getId()).setSelectedQuotaString(value);
        }
    });
    // $NON-NLS-1$
    diskTable.addColumn(quotaColumn, constants.quota(), "100px");
}
#method_after
private void addStorageQuotaColumn() {
    if (!importModel.isQuotaEnabled()) {
        return;
    }
    if (quotaColumn != null) {
        return;
    }
    CustomSelectionCell customSelectionCellQuota = new CustomSelectionCell(new ArrayList<String>());
    customSelectionCellQuota.setStyle(style.cellSelectBox());
    quotaColumn = new Column<DiskImage, String>(customSelectionCellQuota) {

        @Override
        public String getValue(DiskImage disk) {
            ImportDiskData importData = importModel.getDiskImportData(disk.getId());
            ArrayList<String> storageQuotaList = new ArrayList<>();
            Quota selectedQuota = null;
            if (importData != null && importData.getQuotaList() != null) {
                for (Quota quota : importData.getQuotaList()) {
                    storageQuotaList.add(quota.getQuotaName());
                    if (importData.getSelectedQuota() != null) {
                        if (quota.getId().equals(importData.getSelectedQuota().getId())) {
                            selectedQuota = quota;
                        }
                    }
                }
            }
            ((CustomSelectionCell) getCell()).setOptions(storageQuotaList);
            if (!storageQuotaList.isEmpty()) {
                if (selectedQuota != null) {
                    return selectedQuota.getQuotaName();
                } else {
                    return storageQuotaList.get(0);
                }
            }
            return "";
        }
    };
    quotaColumn.setFieldUpdater(new FieldUpdater<DiskImage, String>() {

        @Override
        public void update(int index, DiskImage disk, String value) {
            importModel.getDiskImportData(disk.getId()).setSelectedQuotaString(value);
        }
    });
    // $NON-NLS-1$
    diskTable.addColumn(quotaColumn, constants.quota(), "100px");
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public void edit(final ImportVmFromExportDomainModel object) {
    this.importModel = object;
    table.asEditor().edit(object);
    addStorageDomainsColumn();
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (args.propertyName.equals(object.ON_DISK_LOAD)) {
                addStorageQuotaColumn();
                table.redraw();
                diskTable.asEditor().edit(object.getImportDiskListModel());
            } else if (args.propertyName.equals("Message")) {
                // //$NON-NLS-1$
                message.setText(object.getMessage());
            } else if (args.propertyName.equals("InvalidVm")) {
                // //$NON-NLS-1$
                table.redraw();
            }
        }
    });
    SingleSelectionModel<Object> selectionModel = (SingleSelectionModel<Object>) table.getSelectionModel();
    selectionModel.addSelectionChangeHandler(new Handler() {

        @Override
        public void onSelectionChange(SelectionChangeEvent event) {
            if (!firstSelection) {
                object.setActiveDetailModel((HasEntity<?>) object.getDetailModels().get(0));
                setGeneralViewSelection(((ImportEntityData<?>) object.getSelectedItem()).getEntity());
                firstSelection = true;
            }
            splitLayoutPanel.clear();
            splitLayoutPanel.addSouth(subTabLayoutPanel, 230);
            ScrollPanel sp = new ScrollPanel();
            sp.add(table);
            splitLayoutPanel.add(sp);
            table.getElement().getStyle().setPosition(Position.RELATIVE);
        // subTabLayoutPanel.selectTab(0);
        }
    });
    initSubTabLayoutPanel();
    nicTable.asEditor().edit((SearchableListModel) object.getDetailModels().get(1));
    diskTable.asEditor().edit((SearchableListModel) object.getDetailModels().get(2));
    if (object.getDetailModels().size() > 3) {
        appTable.asEditor().edit((VmAppListModel) object.getDetailModels().get(3));
    }
    driver.edit(object);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public void edit(final ImportVmFromExportDomainModel object) {
    this.importModel = object;
    table.asEditor().edit(object);
    addStorageDomainsColumn();
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (args.propertyName.equals(object.ON_DISK_LOAD)) {
                addStorageQuotaColumn();
                table.redraw();
                diskTable.asEditor().edit(object.getImportDiskListModel());
            } else if (args.propertyName.equals("Message")) {
                // $NON-NLS-1$
                message.setText(object.getMessage());
            } else if (args.propertyName.equals("InvalidVm")) {
                // $NON-NLS-1$
                table.redraw();
            }
        }
    });
    SingleSelectionModel<Object> selectionModel = (SingleSelectionModel<Object>) table.getSelectionModel();
    selectionModel.addSelectionChangeHandler(new Handler() {

        @Override
        public void onSelectionChange(SelectionChangeEvent event) {
            if (!firstSelection) {
                object.setActiveDetailModel((HasEntity<?>) object.getDetailModels().get(0));
                setGeneralViewSelection(((ImportEntityData<?>) object.getSelectedItem()).getEntity());
                firstSelection = true;
            }
            splitLayoutPanel.clear();
            splitLayoutPanel.addSouth(subTabLayoutPanel, 230);
            ScrollPanel sp = new ScrollPanel();
            sp.add(table);
            splitLayoutPanel.add(sp);
            table.getElement().getStyle().setPosition(Position.RELATIVE);
        }
    });
    initSubTabLayoutPanel();
    nicTable.asEditor().edit((SearchableListModel) object.getDetailModels().get(1));
    diskTable.asEditor().edit((SearchableListModel) object.getDetailModels().get(2));
    if (object.getDetailModels().size() > 3) {
        appTable.asEditor().edit((VmAppListModel) object.getDetailModels().get(3));
    }
    driver.edit(object);
}
#end_block

#method_before
private void fetchCpuProfiles(Guid clusterId, final Guid cpuProfileId) {
    if (clusterId == null) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetCpuProfilesByClusterId, new IdQueryParameters(clusterId), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<CpuProfile> cpuProfiles = (List<CpuProfile>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            getModel().getCpuProfiles().setItems(cpuProfiles);
            if (cpuProfiles != null) {
                for (CpuProfile cpuProfile : cpuProfiles) {
                    if (cpuProfile.getId().equals(cpuProfileId)) {
                        getModel().getCpuProfiles().setSelectedItem(cpuProfile);
                        break;
                    }
                }
            }
        }
    }));
}
#method_after
private void fetchCpuProfiles(Guid clusterId, final Guid cpuProfileId) {
    if (clusterId == null) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetCpuProfilesByClusterId, new IdQueryParameters(clusterId), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<CpuProfile> cpuProfiles = ((VdcQueryReturnValue) returnValue).getReturnValue();
            getModel().getCpuProfiles().setItems(cpuProfiles);
            if (cpuProfiles != null) {
                for (CpuProfile cpuProfile : cpuProfiles) {
                    if (cpuProfile.getId().equals(cpuProfileId)) {
                        getModel().getCpuProfiles().setSelectedItem(cpuProfile);
                        break;
                    }
                }
            }
        }
    }));
}
#end_block

#method_before
protected void analyze() {
    proceedDownVms();
    proceedWatchdogEvents();
    proceedBalloonCheck();
    proceedGuaranteedMemoryCheck();
    updateRepository();
    prepareGuestAgentNetworkDevicesForUpdate();
    updateLunDisks();
    updateVmJobs();
    analyzeExternalVms();
    analyzeHostedEngineVm();
    if (vmDynamicToSave != null) {
        vmsMonitoring.addVmDynamicToList(vmDynamicToSave);
    }
}
#method_after
protected void analyze() {
    if (vdsmVm == null) {
        removeVmFromCache();
        return;
    }
    if (isUnmanagedVm()) {
        saveDynamic(vdsmVm.getVmDynamic());
        return;
    }
    proceedDownVms();
    proceedWatchdogEvents();
    proceedBalloonCheck();
    proceedGuaranteedMemoryCheck();
    updateRepository();
    prepareGuestAgentNetworkDevicesForUpdate();
    updateLunDisks();
    updateVmJobs();
}
#end_block

#method_before
void proceedDownVms() {
    if (vdsmVm != null && vdsmVm.getVmDynamic().getStatus() == VMStatus.Down) {
        VMStatus prevStatus = VMStatus.Unassigned;
        if (dbVm != null) {
            prevStatus = dbVm.getStatus();
            proceedVmBeforeDeletion();
            // when going to suspend, delete vm from cache later
            if (prevStatus == VMStatus.SavingState) {
                vmsMonitoring.getResourceManager().internalSetVmStatus(dbVm, VMStatus.Suspended);
            }
            clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
        } else {
            VmDynamic dynamicFromDb = getDbFacade().getVmDynamicDao().get(vdsmVm.getVmDynamic().getId());
            if (dynamicFromDb != null) {
                prevStatus = dynamicFromDb.getStatus();
            }
        }
        if (prevStatus != VMStatus.Unassigned) {
            vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.Destroy, new DestroyVmVDSCommandParameters(getVdsManager().getVdsId(), vdsmVm.getVmDynamic().getId(), null, false, false, 0, true));
            if (dbVm != null && prevStatus == VMStatus.SavingState) {
                afterSuspendTreatment(vdsmVm.getVmDynamic());
            } else if (prevStatus != VMStatus.MigratingFrom) {
                handleVmOnDown(dbVm, vdsmVm.getVmDynamic());
            }
        }
    }
}
#method_after
void proceedDownVms() {
    if (vdsmVm.getVmDynamic().getStatus() == VMStatus.Down) {
        VMStatus prevStatus = VMStatus.Unassigned;
        if (dbVm != null) {
            prevStatus = dbVm.getStatus();
            proceedVmBeforeDeletion();
            // when going to suspend, delete vm from cache later
            if (prevStatus == VMStatus.SavingState) {
                vmsMonitoring.getResourceManager().internalSetVmStatus(dbVm, VMStatus.Suspended);
            }
            clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
        } else {
            VmDynamic dynamicFromDb = getDbFacade().getVmDynamicDao().get(vdsmVm.getVmDynamic().getId());
            if (dynamicFromDb != null) {
                prevStatus = dynamicFromDb.getStatus();
            }
        }
        if (prevStatus != VMStatus.Unassigned) {
            vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.Destroy, new DestroyVmVDSCommandParameters(getVdsManager().getVdsId(), vdsmVm.getVmDynamic().getId(), null, false, false, 0, true));
            if (dbVm != null && prevStatus == VMStatus.SavingState) {
                afterSuspendTreatment(vdsmVm.getVmDynamic());
            } else if (prevStatus != VMStatus.MigratingFrom) {
                handleVmOnDown(dbVm, vdsmVm.getVmDynamic());
            }
        }
    }
}
#end_block

#method_before
// TODO Method with Side-Effect - move to VmsMonitoring
private void proceedVmBeforeDeletion() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
    if (dbVm.getStatus() == VMStatus.MigratingFrom) {
        // exit status that's OK, otherwise..
        if (vdsmVm.getVmDynamic() != null && vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal) {
            if (dbVm.getMigratingToVds() != null) {
                VDSReturnValue destoryReturnValue = vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(new Guid(dbVm.getMigratingToVds().toString()), dbVm.getId(), true, false, 0));
                if (destoryReturnValue.getSucceeded()) {
                    log.info("Stopped migrating VM: '{}' on VDS: '{}'", dbVm.getName(), dbVm.getMigratingToVds());
                } else {
                    log.info("Could not stop migrating VM: '{}' on VDS: '{}', Error: '{}'", dbVm.getName(), dbVm.getMigratingToVds(), destoryReturnValue.getExceptionString());
                }
            }
            // set vm status to down if source vm crushed
            ResourceManager.getInstance().internalSetVmStatus(dbVm, VMStatus.Down, vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
            saveDynamic(dbVm.getDynamicData());
            saveStatistics();
            saveVmInterfaces();
            type = AuditLogType.VM_MIGRATION_ABORT;
            logable.addCustomValue("MigrationError", vdsmVm.getVmDynamic().getExitMessage());
            vmsMonitoring.getResourceManager().removeAsyncRunningVm(vdsmVm.getVmDynamic().getId());
        }
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#method_after
// TODO Method with Side-Effect - move to VmsMonitoring
private void proceedVmBeforeDeletion() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
    if (dbVm.getStatus() == VMStatus.MigratingFrom) {
        // exit status that's OK, otherwise..
        if (vdsmVm != null && vdsmVm.getVmDynamic() != null && vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal) {
            if (dbVm.getMigratingToVds() != null) {
                VDSReturnValue destoryReturnValue = vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(new Guid(dbVm.getMigratingToVds().toString()), dbVm.getId(), true, false, 0));
                if (destoryReturnValue.getSucceeded()) {
                    log.info("Stopped migrating VM: '{}' on VDS: '{}'", dbVm.getName(), dbVm.getMigratingToVds());
                } else {
                    log.info("Could not stop migrating VM: '{}' on VDS: '{}', Error: '{}'", dbVm.getName(), dbVm.getMigratingToVds(), destoryReturnValue.getExceptionString());
                }
            }
            // set vm status to down if source vm crushed
            ResourceManager.getInstance().internalSetVmStatus(dbVm, VMStatus.Down, vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
            saveDynamic(dbVm.getDynamicData());
            saveStatistics();
            saveVmInterfaces();
            type = AuditLogType.VM_MIGRATION_ABORT;
            logable.addCustomValue("MigrationError", vdsmVm.getVmDynamic().getExitMessage());
            vmsMonitoring.getResourceManager().removeAsyncRunningVm(vdsmVm.getVmDynamic().getId());
        }
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#end_block

#method_before
private void proceedWatchdogEvents() {
    if (vdsmVm != null) {
        VmDynamic vmDynamic = vdsmVm.getVmDynamic();
        VM vmTo = dbVm;
        if (isNewWatchdogEvent(vmDynamic, vmTo)) {
            AuditLogableBase auditLogable = new AuditLogableBase();
            auditLogable.setVmId(vmDynamic.getId());
            auditLogable.addCustomValue("wdaction", vmDynamic.getLastWatchdogAction());
            // for the interpretation of vdsm's response see http://docs.python.org/2/library/time.html
            auditLogable.addCustomValue("wdevent", new Date(vmDynamic.getLastWatchdogEvent() * 1000).toString());
            auditLog(auditLogable, AuditLogType.WATCHDOG_EVENT);
        }
    }
}
#method_after
private void proceedWatchdogEvents() {
    VmDynamic vmDynamic = vdsmVm.getVmDynamic();
    VM vmTo = dbVm;
    if (isNewWatchdogEvent(vmDynamic, vmTo)) {
        AuditLogableBase auditLogable = new AuditLogableBase();
        auditLogable.setVmId(vmDynamic.getId());
        auditLogable.addCustomValue("wdaction", vmDynamic.getLastWatchdogAction());
        // for the interpretation of vdsm's response see http://docs.python.org/2/library/time.html
        auditLogable.addCustomValue("wdevent", new Date(vmDynamic.getLastWatchdogEvent() * 1000).toString());
        auditLog(auditLogable, AuditLogType.WATCHDOG_EVENT);
    }
}
#end_block

#method_before
private void proceedBalloonCheck() {
    if (getVdsManager().getCopyVds().isBalloonEnabled()) {
        if (dbVm == null || vdsmVm == null) {
            return;
        }
        VmBalloonInfo balloonInfo = vdsmVm.getVmStatistics().getVmBalloonInfo();
        if (balloonInfo == null) {
            return;
        }
        Guid vmId = vdsmVm.getVmDynamic().getId();
        /* last memory is null the first time we check it or when
               we're not getting the balloon info from vdsm
            */
        if (balloonInfo.getBalloonLastMemory() == null || balloonInfo.getBalloonLastMemory() == 0) {
            balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
            return;
        }
        if (isBalloonDeviceActiveOnVm(vdsmVm) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !isBalloonWorking(balloonInfo))) {
            vmBalloonDriverIsRequestedAndUnavailable(vmId);
        } else {
            vmBalloonDriverIsNotRequestedOrAvailable(vmId);
        }
        // save the current value for the next time we check it
        balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
        if (vdsmVm.getVmStatistics().getUsageMemPercent() != null && // guest agent is down
        vdsmVm.getVmStatistics().getUsageMemPercent() == 0 && // check if the device is present
        balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
            guestAgentIsDownAndBalloonInfalted(vmId);
        } else {
            guestAgentIsUpOrBalloonDeflated(vmId);
        }
    }
}
#method_after
private void proceedBalloonCheck() {
    if (getVdsManager().getCopyVds().isBalloonEnabled()) {
        if (dbVm == null) {
            return;
        }
        VmBalloonInfo balloonInfo = vdsmVm.getVmStatistics().getVmBalloonInfo();
        if (balloonInfo == null) {
            return;
        }
        Guid vmId = vdsmVm.getVmDynamic().getId();
        /* last memory is null the first time we check it or when
               we're not getting the balloon info from vdsm
            */
        if (balloonInfo.getBalloonLastMemory() == null || balloonInfo.getBalloonLastMemory() == 0) {
            balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
            return;
        }
        if (isBalloonDeviceActiveOnVm(vdsmVm) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !isBalloonWorking(balloonInfo))) {
            vmBalloonDriverIsRequestedAndUnavailable(vmId);
        } else {
            vmBalloonDriverIsNotRequestedOrAvailable(vmId);
        }
        // save the current value for the next time we check it
        balloonInfo.setBalloonLastMemory(balloonInfo.getCurrentMemory());
        if (vdsmVm.getVmStatistics().getUsageMemPercent() != null && // guest agent is down
        vdsmVm.getVmStatistics().getUsageMemPercent() == 0 && // check if the device is present
        balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
            guestAgentIsDownAndBalloonInfalted(vmId);
        } else {
            guestAgentIsUpOrBalloonDeflated(vmId);
        }
    }
}
#end_block

#method_before
private void proceedGuaranteedMemoryCheck() {
    if (dbVm != null && vdsmVm != null) {
        VmStatistics vmStatistics = vdsmVm.getVmStatistics();
        if (vmStatistics != null && vmStatistics.getVmBalloonInfo() != null && vmStatistics.getVmBalloonInfo().getCurrentMemory() != null && vmStatistics.getVmBalloonInfo().getCurrentMemory() > 0 && dbVm.getMinAllocatedMem() > vmStatistics.getVmBalloonInfo().getCurrentMemory() / TO_MEGA_BYTES) {
            AuditLogableBase auditLogable = new AuditLogableBase();
            auditLogable.addCustomValue("VmName", dbVm.getName());
            auditLogable.addCustomValue("VdsName", this.getVdsManager().getVdsName());
            auditLogable.addCustomValue("MemGuaranteed", String.valueOf(dbVm.getMinAllocatedMem()));
            auditLogable.addCustomValue("MemActual", Long.toString(vmStatistics.getVmBalloonInfo().getCurrentMemory() / TO_MEGA_BYTES));
            auditLog(auditLogable, AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE);
        }
    }
}
#method_after
private void proceedGuaranteedMemoryCheck() {
    if (dbVm != null) {
        VmStatistics vmStatistics = vdsmVm.getVmStatistics();
        if (vmStatistics != null && vmStatistics.getVmBalloonInfo() != null && vmStatistics.getVmBalloonInfo().getCurrentMemory() != null && vmStatistics.getVmBalloonInfo().getCurrentMemory() > 0 && dbVm.getMinAllocatedMem() > vmStatistics.getVmBalloonInfo().getCurrentMemory() / TO_MEGA_BYTES) {
            AuditLogableBase auditLogable = new AuditLogableBase();
            auditLogable.addCustomValue("VmName", dbVm.getName());
            auditLogable.addCustomValue("VdsName", this.getVdsManager().getVdsName());
            auditLogable.addCustomValue("MemGuaranteed", String.valueOf(dbVm.getMinAllocatedMem()));
            auditLogable.addCustomValue("MemActual", Long.toString(vmStatistics.getVmBalloonInfo().getCurrentMemory() / TO_MEGA_BYTES));
            auditLog(auditLogable, AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE);
        }
    }
}
#end_block

#method_before
private void updateRepository() {
    if (vdsmVm != null) {
        VmDynamic vdsmVmDynamic = vdsmVm.getVmDynamic();
        // if not migrating here and not down
        if (!inMigrationTo(vdsmVmDynamic, dbVm) && vdsmVmDynamic.getStatus() != VMStatus.Down) {
            if (dbVm != null) {
                if (!StringUtils.equals(vdsmVmDynamic.getClientIp(), dbVm.getClientIp())) {
                    clientIpChanged = true;
                }
            }
            if (dbVm != null) {
                logVmStatusTransition();
                if (dbVm.getStatus() != VMStatus.Up && vdsmVmDynamic.getStatus() == VMStatus.Up || dbVm.getStatus() != VMStatus.PoweringUp && vdsmVmDynamic.getStatus() == VMStatus.PoweringUp) {
                    poweringUp = true;
                }
                // "Up" as this means that the power down operation failed:
                if (dbVm.getStatus() == VMStatus.PoweringDown && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                // log vm recovered from error
                if (dbVm.getStatus() == VMStatus.Paused && dbVm.getVmPauseStatus().isError() && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_RECOVERED_FROM_PAUSE_ERROR);
                }
                if (isRunSucceeded(vdsmVmDynamic) || isMigrationSucceeded(vdsmVmDynamic)) {
                    // Vm moved to Up status - remove its record from Async
                    // reportedAndUnchangedVms handling
                    log.debug("removing VM '{}' from successful run VMs list", dbVm.getId());
                    succeededToRun = true;
                }
                afterMigrationFrom(vdsmVmDynamic, dbVm);
                if (dbVm.getStatus() != VMStatus.NotResponding && vdsmVmDynamic.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (vdsmVmDynamic.getStatus() == VMStatus.Paused) {
                    removeFromAsync = true;
                    if (dbVm.getStatus() != VMStatus.Paused) {
                        AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                        auditLog(logable, AuditLogType.VM_PAUSED);
                        // check exit message to determine why the VM is paused
                        if (vdsmVmDynamic.getPauseStatus().isError()) {
                            AuditLogType logType = vmPauseStatusToAuditLogType(vdsmVmDynamic.getPauseStatus());
                            logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (dbVm != null || vdsmVmDynamic.getStatus() != VMStatus.MigratingFrom) {
                if (updateVmRunTimeInfo()) {
                    saveDynamic(dbVm.getDynamicData());
                }
            }
            if (dbVm != null) {
                updateVmStatistics();
                stable = true;
                if (!getVdsManager().isInitialized()) {
                    vmsMonitoring.getResourceManager().removeVmFromDownVms(getVdsManager().getVdsId(), vdsmVmDynamic.getId());
                }
            }
        } else {
            if (vdsmVmDynamic.getStatus() == VMStatus.MigratingTo) {
                stable = true;
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(vdsmVmDynamic.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                saveDynamic(null);
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    if (dbVm != null && !stable) {
        removeVmFromCache();
    }
}
#method_after
private void updateRepository() {
    VmDynamic vdsmVmDynamic = vdsmVm.getVmDynamic();
    // if not migrating here and not down
    if (!inMigrationTo(vdsmVmDynamic, dbVm) && vdsmVmDynamic.getStatus() != VMStatus.Down) {
        if (dbVm != null) {
            if (!StringUtils.equals(vdsmVmDynamic.getClientIp(), dbVm.getClientIp())) {
                clientIpChanged = true;
            }
        }
        if (dbVm != null) {
            logVmStatusTransition();
            if (dbVm.getStatus() != VMStatus.Up && vdsmVmDynamic.getStatus() == VMStatus.Up || dbVm.getStatus() != VMStatus.PoweringUp && vdsmVmDynamic.getStatus() == VMStatus.PoweringUp) {
                poweringUp = true;
            }
            // "Up" as this means that the power down operation failed:
            if (dbVm.getStatus() == VMStatus.PoweringDown && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
            }
            // log vm recovered from error
            if (dbVm.getStatus() == VMStatus.Paused && dbVm.getVmPauseStatus().isError() && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                auditLog(logable, AuditLogType.VM_RECOVERED_FROM_PAUSE_ERROR);
            }
            if (isRunSucceeded(vdsmVmDynamic) || isMigrationSucceeded(vdsmVmDynamic)) {
                // Vm moved to Up status - remove its record from Async
                // reportedAndUnchangedVms handling
                log.debug("removing VM '{}' from successful run VMs list", dbVm.getId());
                succeededToRun = true;
            }
            afterMigrationFrom(vdsmVmDynamic, dbVm);
            if (dbVm.getStatus() != VMStatus.NotResponding && vdsmVmDynamic.getStatus() == VMStatus.NotResponding) {
                AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
            } else // check if vm is suspended and remove it from async list
            if (vdsmVmDynamic.getStatus() == VMStatus.Paused) {
                removeFromAsync = true;
                if (dbVm.getStatus() != VMStatus.Paused) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_PAUSED);
                    // check exit message to determine why the VM is paused
                    if (vdsmVmDynamic.getPauseStatus().isError()) {
                        AuditLogType logType = vmPauseStatusToAuditLogType(vdsmVmDynamic.getPauseStatus());
                        logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                        auditLog(logable, logType);
                    }
                }
            }
        }
        if (dbVm != null || vdsmVmDynamic.getStatus() != VMStatus.MigratingFrom) {
            if (updateVmRunTimeInfo()) {
                saveDynamic(dbVm.getDynamicData());
            }
        }
        if (dbVm != null) {
            updateVmStatistics();
            stable = true;
            if (!getVdsManager().isInitialized()) {
                vmsMonitoring.getResourceManager().removeVmFromDownVms(getVdsManager().getVdsId(), vdsmVmDynamic.getId());
            }
        }
    } else {
        if (vdsmVmDynamic.getStatus() == VMStatus.MigratingTo) {
            stable = true;
        }
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(vdsmVmDynamic.getId());
        if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
            saveDynamic(null);
        }
    }
    // compare between vm in cache and vm from vdsm
    if (dbVm != null && !stable) {
        removeVmFromCache();
    }
}
#end_block

#method_before
private void prepareGuestAgentNetworkDevicesForUpdate() {
    if (vdsmVm != null) {
        VmDynamic vdsmVmDynamic = vdsmVm.getVmDynamic();
        if (vdsmVmDynamic != null) {
            if (dbVm != null) {
                List<VmGuestAgentInterface> vmGuestAgentInterfaces = vdsmVm.getVmGuestAgentInterfaces();
                int guestAgentNicHash = vmGuestAgentInterfaces == null ? 0 : vmGuestAgentInterfaces.hashCode();
                if (guestAgentNicHash != vdsmVmDynamic.getGuestAgentNicsHash()) {
                    if (vmDynamicToSave == null) {
                        saveDynamic(dbVm.getDynamicData());
                    }
                    updateGuestAgentInterfacesChanges(vmDynamicToSave, vmGuestAgentInterfaces, guestAgentNicHash);
                }
            }
        }
    }
}
#method_after
private void prepareGuestAgentNetworkDevicesForUpdate() {
    VmDynamic vdsmVmDynamic = vdsmVm.getVmDynamic();
    if (vdsmVmDynamic != null) {
        if (dbVm != null) {
            List<VmGuestAgentInterface> vmGuestAgentInterfaces = vdsmVm.getVmGuestAgentInterfaces();
            int guestAgentNicHash = vmGuestAgentInterfaces == null ? 0 : vmGuestAgentInterfaces.hashCode();
            if (guestAgentNicHash != vdsmVmDynamic.getGuestAgentNicsHash()) {
                if (vmDynamicToSave == null) {
                    saveDynamic(dbVm.getDynamicData());
                }
                updateGuestAgentInterfacesChanges(vmDynamicToSave, vmGuestAgentInterfaces, guestAgentNicHash);
            }
        }
    }
}
#end_block

#method_before
protected void updateLunDisks() {
    // is updated by VDSM only once when running a VM.
    if (poweringUp && vdsmVm != null) {
        Map<String, LUNs> lunsMap = vdsmVm.getLunsMap();
        if (lunsMap.isEmpty()) {
            // LUNs list from getVmStats hasn't been updated yet or VDSM doesn't support LUNs list retrieval.
            return;
        }
        List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vdsmVm.getVmDynamic().getId(), true);
        for (Disk disk : vmDisks) {
            if (disk.getDiskStorageType() != DiskStorageType.LUN) {
                continue;
            }
            LUNs lunFromDB = ((LunDisk) disk).getLun();
            LUNs lunFromMap = lunsMap.get(lunFromDB.getId());
            // Hence, verify before updating.
            if (lunFromMap.getDeviceSize() != 0 && lunFromMap.getDeviceSize() != lunFromDB.getDeviceSize()) {
                // Found a mismatch - set LUN for update
                log.info("Updated LUN device size - ID: '{}', previous size: '{}', new size: '{}'.", lunFromDB.getLUNId(), lunFromDB.getDeviceSize(), lunFromMap.getDeviceSize());
                lunFromDB.setDeviceSize(lunFromMap.getDeviceSize());
                vmsMonitoring.getVmLunDisksToSave().add(lunFromDB);
            }
        }
    }
}
#method_after
protected void updateLunDisks() {
    // is updated by VDSM only once when running a VM.
    if (poweringUp) {
        Map<String, LUNs> lunsMap = vdsmVm.getLunsMap();
        if (lunsMap.isEmpty()) {
            // LUNs list from getVmStats hasn't been updated yet or VDSM doesn't support LUNs list retrieval.
            return;
        }
        List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vdsmVm.getVmDynamic().getId(), true);
        for (Disk disk : vmDisks) {
            if (disk.getDiskStorageType() != DiskStorageType.LUN) {
                continue;
            }
            LUNs lunFromDB = ((LunDisk) disk).getLun();
            LUNs lunFromMap = lunsMap.get(lunFromDB.getId());
            // Hence, verify before updating.
            if (lunFromMap.getDeviceSize() != 0 && lunFromMap.getDeviceSize() != lunFromDB.getDeviceSize()) {
                // Found a mismatch - set LUN for update
                log.info("Updated LUN device size - ID: '{}', previous size: '{}', new size: '{}'.", lunFromDB.getLUNId(), lunFromDB.getDeviceSize(), lunFromMap.getDeviceSize());
                lunFromDB.setDeviceSize(lunFromMap.getDeviceSize());
                vmsMonitoring.getVmLunDisksToSave().add(lunFromDB);
            }
        }
    }
}
#end_block

#method_before
protected void updateVmJobs() {
    if (vdsmVm != null) {
        Set<Guid> vmJobIdsToIgnore = new HashSet<>();
        Map<Guid, VmJob> jobsFromDb = new HashMap<>();
        for (VmJob job : getDbFacade().getVmJobDao().getAllForVm(vdsmVm.getVmDynamic().getId())) {
            // others are completely ignored for the time being
            if (vmsMonitoring.getExistingVmJobIds().contains(job.getId())) {
                jobsFromDb.put(job.getId(), job);
            }
        }
        if (vdsmVm.getVmStatistics().getVmJobs() == null) {
            // If no vmJobs key was returned, we can't presume anything about the jobs; save them all
            log.debug("No vmJob data returned from VDSM, preserving existing jobs");
            return;
        }
        for (VmJob jobFromVds : vdsmVm.getVmStatistics().getVmJobs()) {
            if (jobsFromDb.containsKey(jobFromVds.getId())) {
                if (jobsFromDb.get(jobFromVds.getId()).equals(jobFromVds)) {
                    // Same data, no update needed.  It would be nice if a caching
                    // layer would take care of this for us.
                    vmJobIdsToIgnore.add(jobFromVds.getId());
                    log.info("VM job '{}': In progress (no change)", jobFromVds.getId());
                } else {
                    vmsMonitoring.getVmJobsToUpdate().put(jobFromVds.getId(), jobFromVds);
                    log.info("VM job '{}': In progress, updating", jobFromVds.getId());
                }
            }
        }
        // Any existing jobs not saved need to be removed
        for (Guid id : jobsFromDb.keySet()) {
            if (!vmsMonitoring.getVmJobsToUpdate().containsKey(id) && !vmJobIdsToIgnore.contains(id)) {
                vmsMonitoring.getVmJobIdsToRemove().add(id);
                log.info("VM job '{}': Deleting", id);
            }
        }
    }
}
#method_after
protected void updateVmJobs() {
    Set<Guid> vmJobIdsToIgnore = new HashSet<>();
    Map<Guid, VmJob> jobsFromDb = new HashMap<>();
    for (VmJob job : getDbFacade().getVmJobDao().getAllForVm(vdsmVm.getVmDynamic().getId())) {
        // others are completely ignored for the time being
        if (vmsMonitoring.getExistingVmJobIds().contains(job.getId())) {
            jobsFromDb.put(job.getId(), job);
        }
    }
    if (vdsmVm.getVmStatistics().getVmJobs() == null) {
        // If no vmJobs key was returned, we can't presume anything about the jobs; save them all
        log.debug("No vmJob data returned from VDSM, preserving existing jobs");
        return;
    }
    for (VmJob jobFromVds : vdsmVm.getVmStatistics().getVmJobs()) {
        if (jobsFromDb.containsKey(jobFromVds.getId())) {
            if (jobsFromDb.get(jobFromVds.getId()).equals(jobFromVds)) {
                // Same data, no update needed.  It would be nice if a caching
                // layer would take care of this for us.
                vmJobIdsToIgnore.add(jobFromVds.getId());
                log.info("VM job '{}': In progress (no change)", jobFromVds.getId());
            } else {
                vmsMonitoring.getVmJobsToUpdate().put(jobFromVds.getId(), jobFromVds);
                log.info("VM job '{}': In progress, updating", jobFromVds.getId());
            }
        }
    }
    // Any existing jobs not saved need to be removed
    for (Guid id : jobsFromDb.keySet()) {
        if (!vmsMonitoring.getVmJobsToUpdate().containsKey(id) && !vmJobIdsToIgnore.contains(id)) {
            vmsMonitoring.getVmJobIdsToRemove().add(id);
            log.info("VM job '{}': Deleting", id);
        }
    }
}
#end_block

#method_before
private void initCinderDisksTable() {
    cinderDiskTable.enableColumnResizing();
    AbstractTextColumn<EntityModel> aliasColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            CinderDisk disk = (CinderDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    cinderDiskTable.addColumn(aliasColumn, constants.aliasVmDiskTable(), "100px");
    AbstractTextColumn<EntityModel> descriptionColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            CinderDisk disk = (CinderDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getDiskDescription();
        }
    };
    // $NON-NLS-1$
    cinderDiskTable.addColumn(descriptionColumn, constants.descriptionVmDiskTable(), "100px");
    AbstractDiskSizeColumn<EntityModel> sizeColumn = new AbstractDiskSizeColumn<EntityModel>(SizeConverter.SizeUnit.GiB) {

        @Override
        protected Long getRawValue(EntityModel object) {
            CinderDisk disk = (CinderDisk) ((DiskModel) object.getEntity()).getDisk();
            return (long) disk.getSizeInGigabytes();
        }
    };
    // $NON-NLS-1$
    cinderDiskTable.addColumn(sizeColumn, constants.provisionedSizeVmDiskTable(), "100px");
    AbstractTextColumn<EntityModel> interfaceColumn = new AbstractEnumColumn<EntityModel, DiskInterface>() {

        @Override
        protected DiskInterface getRawValue(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            return disk.getDiskInterface();
        }
    };
    // $NON-NLS-1$
    cinderDiskTable.addColumn(interfaceColumn, constants.interfaceVmDiskPopup(), "90px");
    AbstractTextColumn<EntityModel> cinderVolumeTypeColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            return disk.getCinderVolumeType();
        }
    };
    // $NON-NLS-1$
    cinderDiskTable.addColumn(cinderVolumeTypeColumn, constants.cinderVolumeTypeDisk(), "90px");
    cinderDiskTable.addColumn(DisksViewColumns.readOnlyCheckboxColumn, new ImageResourceHeader(resources.readOnlyDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.readOnly())), // $NON-NLS-1$
    "30px");
    cinderDiskTable.addColumn(new AbstractImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            return disk.isBoot() ? resources.bootableDiskIcon() : null;
        }

        @Override
        public SafeHtml getTooltip(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            if (disk.isBoot()) {
                return SafeHtmlUtils.fromSafeConstant(constants.bootableDisk());
            }
            return null;
        }
    }, new ImageResourceHeader(resources.bootableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.bootable())), // $NON-NLS-1$
    "30px");
    cinderDiskTable.addColumn(new AbstractImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            return disk.isShareable() ? resources.shareableDiskIcon() : null;
        }

        @Override
        public SafeHtml getTooltip(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            if (disk.isShareable()) {
                return SafeHtmlUtils.fromSafeConstant(constants.shareable());
            }
            return null;
        }
    }, new ImageResourceHeader(resources.shareableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.shareable())), // $NON-NLS-1$
    "30px");
    // $NON-NLS-1$
    cinderDiskTable.setWidth("100%", true);
    // $NON-NLS-1$
    cinderDiskTable.setHeight("100%");
}
#method_after
private void initCinderDisksTable() {
    cinderDiskTable.enableColumnResizing();
    AbstractTextColumn<EntityModel> aliasColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            CinderDisk disk = (CinderDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    cinderDiskTable.addColumn(aliasColumn, constants.aliasVmDiskTable(), "100px");
    AbstractTextColumn<EntityModel> descriptionColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            CinderDisk disk = (CinderDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getDiskDescription();
        }
    };
    // $NON-NLS-1$
    cinderDiskTable.addColumn(descriptionColumn, constants.descriptionVmDiskTable(), "100px");
    AbstractDiskSizeColumn<EntityModel> sizeColumn = new AbstractDiskSizeColumn<EntityModel>(SizeConverter.SizeUnit.GiB) {

        @Override
        protected Long getRawValue(EntityModel object) {
            CinderDisk disk = (CinderDisk) ((DiskModel) object.getEntity()).getDisk();
            return disk.getSizeInGigabytes();
        }
    };
    // $NON-NLS-1$
    cinderDiskTable.addColumn(sizeColumn, constants.provisionedSizeVmDiskTable(), "100px");
    AbstractTextColumn<EntityModel> interfaceColumn = new AbstractEnumColumn<EntityModel, DiskInterface>() {

        @Override
        protected DiskInterface getRawValue(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            return disk.getDiskInterface();
        }
    };
    // $NON-NLS-1$
    cinderDiskTable.addColumn(interfaceColumn, constants.interfaceVmDiskPopup(), "90px");
    AbstractTextColumn<EntityModel> cinderVolumeTypeColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            return disk.getCinderVolumeType();
        }
    };
    // $NON-NLS-1$
    cinderDiskTable.addColumn(cinderVolumeTypeColumn, constants.cinderVolumeTypeDisk(), "90px");
    cinderDiskTable.addColumn(DisksViewColumns.readOnlyCheckboxColumn, new ImageResourceHeader(resources.readOnlyDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.readOnly())), // $NON-NLS-1$
    "30px");
    cinderDiskTable.addColumn(new AbstractImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            return disk.isBoot() ? resources.bootableDiskIcon() : null;
        }

        @Override
        public SafeHtml getTooltip(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            if (disk.isBoot()) {
                return SafeHtmlUtils.fromSafeConstant(constants.bootableDisk());
            }
            return null;
        }
    }, new ImageResourceHeader(resources.bootableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.bootable())), // $NON-NLS-1$
    "30px");
    cinderDiskTable.addColumn(new AbstractImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            return disk.isShareable() ? resources.shareableDiskIcon() : null;
        }

        @Override
        public SafeHtml getTooltip(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            if (disk.isShareable()) {
                return SafeHtmlUtils.fromSafeConstant(constants.shareable());
            }
            return null;
        }
    }, new ImageResourceHeader(resources.shareableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.shareable())), // $NON-NLS-1$
    "30px");
    // $NON-NLS-1$
    cinderDiskTable.setWidth("100%", true);
    // $NON-NLS-1$
    cinderDiskTable.setHeight("100%");
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmInitEnabled().setEntity(getVm().getVmInit() != null);
    getModel().getVmInitModel().init(getVm().getStaticData());
    getModel().getVmType().setIsChangeable(true);
    getModel().getIsSoundcardEnabled().setIsChangeable(true);
    getModel().getInstanceTypes().setIsChangeable(!vm.isRunning());
    getModel().getVmId().setIsAvailable(true);
    getModel().getVmId().setIsChangeable(false);
    loadDataCenter();
    instanceTypeManager = new ExistingVmInstanceTypeManager(getModel(), vm);
    if (vm.getVmPoolId() != null) {
        instanceTypeManager.setAlwaysEnabledFieldUpdate(true);
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVmNumaNodesByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VmNumaNode> nodes = (List<VmNumaNode>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            ExistingVmModelBehavior.this.getModel().setVmNumaNodes(nodes);
            ExistingVmModelBehavior.this.getModel().updateNodeCount(nodes.size());
        }
    }));
    // load dedicated host names into host names list
    if (getVm().getDedicatedVmForVdsList().size() > 0) {
        Frontend.getInstance().runQuery(VdcQueryType.GetAllHostNamesPinnedToVmById, new IdQueryParameters(vm.getId()), new AsyncQuery(new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                setDedicatedHostsNames((List<String>) ((VdcQueryReturnValue) returnValue).getReturnValue());
            }
        }));
    }
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmInitEnabled().setEntity(getVm().getVmInit() != null);
    getModel().getVmInitModel().init(getVm().getStaticData());
    getModel().getVmType().setIsChangeable(true);
    getModel().getIsSoundcardEnabled().setIsChangeable(true);
    getModel().getInstanceTypes().setIsChangeable(!vm.isRunning());
    getModel().getVmId().setIsAvailable(true);
    getModel().getVmId().setIsChangeable(false);
    loadDataCenter();
    instanceTypeManager = new ExistingVmInstanceTypeManager(getModel(), vm);
    if (vm.getVmPoolId() != null) {
        instanceTypeManager.setAlwaysEnabledFieldUpdate(true);
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVmNumaNodesByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VmNumaNode> nodes = ((VdcQueryReturnValue) returnValue).getReturnValue();
            ExistingVmModelBehavior.this.getModel().setVmNumaNodes(nodes);
            ExistingVmModelBehavior.this.getModel().updateNodeCount(nodes.size());
        }
    }));
    // load dedicated host names into host names list
    if (getVm().getDedicatedVmForVdsList().size() > 0) {
        Frontend.getInstance().runQuery(VdcQueryType.GetAllHostNamesPinnedToVmById, new IdQueryParameters(vm.getId()), new AsyncQuery(new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                setDedicatedHostsNames((List<String>) ((VdcQueryReturnValue) returnValue).getReturnValue());
            }
        }));
    }
}
#end_block

#method_before
@Override
public void parseArguments(List<String> args) throws Exception {
    args.remove(0);
    Properties props = new Properties();
    try (InputStream in = AAAServiceImpl.class.getResourceAsStream("arguments.properties");
        Reader reader = new InputStreamReader(in, StandardCharsets.UTF_8)) {
        props.load(reader);
    }
    Map<String, String> substitutions = (Map) context.get(ContextKeys.CLI_PARSER_SUBSTITUTIONS);
    ArgumentsParser parser = new ArgumentsParser(props, "module");
    parser.getSubstitutions().putAll(substitutions);
    parser.parse(args);
    argModuleMap = parser.getParsedArgs();
    if ((Boolean) argModuleMap.get("help")) {
        System.out.format("Usage: %s", parser.getUsage());
        throw new ExitException("Help", 0);
    }
    if (!parser.getErrors().isEmpty()) {
        for (Throwable t : parser.getErrors()) {
            log.error(t.getMessage());
        }
        throw new ExitException("Parsing error", 1);
    }
    if (args.size() < 1) {
        log.error("Action not provided");
        throw new ExitException("Action not provided", 1);
    }
    try {
        action = Action.valueOf(args.get(0).toUpperCase().replace("-", "_"));
    } catch (IllegalArgumentException e) {
        log.error("Invalid action '{}'", args.get(0));
        throw new ExitException("Invalid action", 1);
    }
    argMap = action.parse(substitutions, props, args);
}
#method_after
@Override
public void parseArguments(List<String> args) throws Exception {
    args.remove(0);
    Properties props = new Properties();
    try (InputStream in = AAAServiceImpl.class.getResourceAsStream("arguments.properties");
        Reader reader = new InputStreamReader(in, StandardCharsets.UTF_8)) {
        props.load(reader);
    }
    Map<String, String> substitutions = context.get(ContextKeys.CLI_PARSER_SUBSTITUTIONS);
    ArgumentsParser parser = new ArgumentsParser(props, "module");
    parser.getSubstitutions().putAll(substitutions);
    parser.parse(args);
    argModuleMap = parser.getParsedArgs();
    if ((Boolean) argModuleMap.get("help")) {
        System.out.format("Usage: %s", parser.getUsage());
        throw new ExitException("Help", 0);
    }
    if (!parser.getErrors().isEmpty()) {
        for (Throwable t : parser.getErrors()) {
            log.error(t.getMessage());
        }
        throw new ExitException("Parsing error", 1);
    }
    if (args.size() < 1) {
        log.error("Action not provided");
        throw new ExitException("Action not provided", 1);
    }
    try {
        action = Action.valueOf(args.get(0).toUpperCase().replace("-", "_"));
    } catch (IllegalArgumentException e) {
        log.error("Invalid action '{}'", args.get(0));
        throw new ExitException("Invalid action", 1);
    }
    argMap = action.parse(substitutions, props, args);
}
#end_block

#method_before
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> userIds = new ArrayList<>();
    ArrayList<Guid> grpIds = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        DbUser user = (DbUser) item;
        if (user.isGroup()) {
            grpIds.add(user.getId());
        } else {
            userIds.add(user.getId());
        }
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<>();
    ArrayList<Guid> tagsToDetach = new ArrayList<>();
    if (model.getItems() != null && ((ArrayList<TagModel>) model.getItems()).size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<VdcActionParametersBase> usersToAttach = new ArrayList<>();
    ArrayList<VdcActionParametersBase> grpsToAttach = new ArrayList<>();
    for (Guid tag_id : tagsToAttach) {
        if (userIds.size() > 0) {
            usersToAttach.add(new AttachEntityToTagParameters(tag_id, userIds));
        }
        if (grpIds.size() > 0) {
            grpsToAttach.add(new AttachEntityToTagParameters(tag_id, grpIds));
        }
    }
    if (usersToAttach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.AttachUserToTag, usersToAttach);
    }
    if (grpsToAttach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.AttachUserGroupToTag, grpsToAttach);
    }
    ArrayList<VdcActionParametersBase> usersToDetach = new ArrayList<>();
    ArrayList<VdcActionParametersBase> grpsToDetach = new ArrayList<>();
    for (Guid tag_id : tagsToDetach) {
        if (userIds.size() > 0) {
            usersToDetach.add(new AttachEntityToTagParameters(tag_id, userIds));
        }
        if (grpIds.size() > 0) {
            grpsToDetach.add(new AttachEntityToTagParameters(tag_id, grpIds));
        }
    }
    if (usersToDetach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.DetachUserFromTag, usersToDetach);
    }
    if (grpsToDetach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.DetachUserGroupFromTag, grpsToDetach);
    }
    cancel();
}
#method_after
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> userIds = new ArrayList<>();
    ArrayList<Guid> grpIds = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        DbUser user = (DbUser) item;
        if (user.isGroup()) {
            grpIds.add(user.getId());
        } else {
            userIds.add(user.getId());
        }
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<>();
    ArrayList<Guid> tagsToDetach = new ArrayList<>();
    if (model.getItems() != null && model.getItems().size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<VdcActionParametersBase> usersToAttach = new ArrayList<>();
    ArrayList<VdcActionParametersBase> grpsToAttach = new ArrayList<>();
    for (Guid tag_id : tagsToAttach) {
        if (userIds.size() > 0) {
            usersToAttach.add(new AttachEntityToTagParameters(tag_id, userIds));
        }
        if (grpIds.size() > 0) {
            grpsToAttach.add(new AttachEntityToTagParameters(tag_id, grpIds));
        }
    }
    if (usersToAttach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.AttachUserToTag, usersToAttach);
    }
    if (grpsToAttach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.AttachUserGroupToTag, grpsToAttach);
    }
    ArrayList<VdcActionParametersBase> usersToDetach = new ArrayList<>();
    ArrayList<VdcActionParametersBase> grpsToDetach = new ArrayList<>();
    for (Guid tag_id : tagsToDetach) {
        if (userIds.size() > 0) {
            usersToDetach.add(new AttachEntityToTagParameters(tag_id, userIds));
        }
        if (grpIds.size() > 0) {
            grpsToDetach.add(new AttachEntityToTagParameters(tag_id, grpIds));
        }
    }
    if (usersToDetach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.DetachUserFromTag, usersToDetach);
    }
    if (grpsToDetach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.DetachUserGroupFromTag, grpsToDetach);
    }
    cancel();
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    if (getSelectedItem() != null) {
        DbUser adUser = (DbUser) getSelectedItem();
        userGroupListModel.setIsAvailable(!adUser.isGroup());
        userEventNotifierListModel.setIsAvailable(!adUser.isGroup());
    }
}
#method_after
@Override
protected void updateDetailsAvailability() {
    if (getSelectedItem() != null) {
        DbUser adUser = getSelectedItem();
        userGroupListModel.setIsAvailable(!adUser.isGroup());
        userEventNotifierListModel.setIsAvailable(!adUser.isGroup());
    }
}
#end_block

#method_before
public void onRemove() {
    List<DbUser> selectedItems = Linq.<DbUser>cast(getSelectedItems());
    ArrayList<VdcActionParametersBase> userPrms = new ArrayList<>();
    ArrayList<VdcActionParametersBase> groupPrms = new ArrayList<>();
    for (DbUser item : selectedItems) {
        if (!item.isGroup()) {
            userPrms.add(new IdParameters(item.getId()));
        } else {
            groupPrms.add(new IdParameters(item.getId()));
        }
    }
    IFrontendMultipleActionAsyncCallback lastCallback = new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                @Override
                public void execute() {
                    // Refresh user list.
                    syncSearch();
                    cancel();
                }
            });
        }
    };
    if (getUserOrGroup() == UserOrGroup.User) {
        if (userPrms.size() > 0) {
            Frontend.getInstance().runMultipleAction(VdcActionType.RemoveUser, userPrms, lastCallback);
        }
    } else if (getUserOrGroup() == UserOrGroup.Group) {
        if (groupPrms.size() > 0) {
            Frontend.getInstance().runMultipleAction(VdcActionType.RemoveGroup, groupPrms, lastCallback);
        }
    }
}
#method_after
public void onRemove() {
    List<DbUser> selectedItems = Linq.cast(getSelectedItems());
    ArrayList<VdcActionParametersBase> userPrms = new ArrayList<>();
    ArrayList<VdcActionParametersBase> groupPrms = new ArrayList<>();
    for (DbUser item : selectedItems) {
        if (!item.isGroup()) {
            userPrms.add(new IdParameters(item.getId()));
        } else {
            groupPrms.add(new IdParameters(item.getId()));
        }
    }
    IFrontendMultipleActionAsyncCallback lastCallback = new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                @Override
                public void execute() {
                    // Refresh user list.
                    syncSearch();
                    cancel();
                }
            });
        }
    };
    if (getUserOrGroup() == UserOrGroup.User) {
        if (userPrms.size() > 0) {
            Frontend.getInstance().runMultipleAction(VdcActionType.RemoveUser, userPrms, lastCallback);
        }
    } else if (getUserOrGroup() == UserOrGroup.Group) {
        if (groupPrms.size() > 0) {
            Frontend.getInstance().runMultipleAction(VdcActionType.RemoveGroup, groupPrms, lastCallback);
        }
    }
}
#end_block

#method_before
public void edit() {
    if (getWindow() != null) {
        return;
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) model;
            ArrayList<Network> networksByCluster = (ArrayList<Network>) ReturnValue;
            VdsNetworkInterface item = (VdsNetworkInterface) hostInterfaceListModel.getSelectedItem();
            ArrayList<Network> networksToAdd = new ArrayList<>();
            Network selectedNetwork = null;
            if (item.getVlanId() != null) {
                for (Network network : networksByCluster) {
                    if (Objects.equals(network.getName(), item.getNetworkName())) {
                        networksToAdd.add(network);
                        if (selectedNetwork == null) {
                            selectedNetwork = network;
                        }
                    }
                }
            } else {
                // creating dictionary of networks by name
                HashMap<String, Network> networkDictionary = new HashMap<>();
                for (Network network : networksByCluster) {
                    networkDictionary.put(network.getName(), network);
                }
                // creating list of attached networks.
                ArrayList<Network> attachedNetworks = new ArrayList<>();
                for (VdsNetworkInterface nic : hostInterfaceListModel.getAllItems()) {
                    if (nic.getNetworkName() != null && networkDictionary.containsKey(nic.getNetworkName())) {
                        attachedNetworks.add(networkDictionary.get(nic.getNetworkName()));
                    }
                }
                ArrayList<Network> unAttachedNetworks = Linq.except(networksByCluster, attachedNetworks);
                // adding selected network names to list.
                boolean isVlanSelected = false;
                boolean isManagementSelected = false;
                ArrayList<VdsNetworkInterface> selectedItems = hostInterfaceListModel.getSelectedItemsWithVlans();
                ArrayList<String> selectedNicsNetworks = new ArrayList<>();
                for (VdsNetworkInterface nic : selectedItems) {
                    if (!StringHelper.isNullOrEmpty(nic.getNetworkName())) {
                        if (nic.getIsManagement()) {
                            isManagementSelected = true;
                        }
                        selectedNicsNetworks.add(nic.getNetworkName());
                        if (!isVlanSelected && nic.getVlanId() != null) {
                            isVlanSelected = true;
                        }
                    }
                }
                for (String selectedNetworkName : selectedNicsNetworks) {
                    if (networkDictionary.containsKey(selectedNetworkName)) {
                        Network network = networkDictionary.get(selectedNetworkName);
                        networksToAdd.add(network);
                        attachedNetworks.remove(network);
                        if (selectedNetwork == null) {
                            selectedNetwork = network;
                        }
                    }
                }
                if (!isManagementSelected || isVlanSelected) {
                    for (Network unAttachedNetwork : unAttachedNetworks) {
                        if (isVlanSelected) {
                            if (unAttachedNetwork.getVlanId() != null) {
                                networksToAdd.add(unAttachedNetwork);
                            }
                        } else {
                            networksToAdd.add(unAttachedNetwork);
                        }
                    }
                }
            }
            Collections.sort(networksToAdd, new NameableComparator());
            // Add a 'none' option to networks.
            if (!StringHelper.isNullOrEmpty(item.getNetworkName())) {
                Network tempVar = new Network();
                tempVar.setId(Guid.Empty);
                // $NON-NLS-1$
                tempVar.setName("None");
                networksToAdd.add(0, tempVar);
            }
            HostInterfaceModel hostInterfaceModel = new HostInterfaceModel();
            hostInterfaceListModel.setWindow(hostInterfaceModel);
            hostInterfaceModel.setEntity(item.getName());
            hostInterfaceModel.setTitle(ConstantsManager.getInstance().getConstants().editNetworkInterfaceTitle());
            hostInterfaceModel.setHelpTag(HelpTag.edit_network_interface_hosts);
            // $NON-NLS-1$
            hostInterfaceModel.setHashName("edit_network_interface_hosts");
            hostInterfaceModel.setNetworks(hostInterfaceListModel.getSelectedItemsWithVlans());
            hostInterfaceModel.setNoneBootProtocolAvailable(!item.getIsManagement());
            hostInterfaceModel.setBootProtocol(!hostInterfaceModel.getNoneBootProtocolAvailable() && item.getBootProtocol() == NetworkBootProtocol.NONE ? NetworkBootProtocol.DHCP : item.getBootProtocol());
            hostInterfaceModel.getAddress().setEntity(item.getAddress());
            hostInterfaceModel.getSubnet().setEntity(item.getSubnet());
            hostInterfaceModel.getNetwork().setItems(networksToAdd);
            hostInterfaceModel.getName().setEntity(item.getName());
            hostInterfaceModel.getBondingOptions().setIsAvailable(false);
            if (item.getBonded() != null && item.getBonded().equals(true)) {
                hostInterfaceModel.getBondingOptions().setIsAvailable(true);
                Map.Entry<String, EntityModel<String>> defaultItem = null;
                RefObject<Map.Entry<String, EntityModel<String>>> tempRef_defaultItem = new RefObject<>(defaultItem);
                ArrayList<Map.Entry<String, EntityModel<String>>> list = AsyncDataProvider.getInstance().getBondingOptionList(tempRef_defaultItem);
                defaultItem = tempRef_defaultItem.argvalue;
                Map.Entry<String, EntityModel<String>> selectBondingOpt = new KeyValuePairCompat<>();
                boolean containsSelectBondingOpt = false;
                hostInterfaceModel.getBondingOptions().setItems(list);
                for (int i = 0; i < list.size(); i++) {
                    if (Objects.equals(list.get(i).getKey(), item.getBondOptions())) {
                        selectBondingOpt = list.get(i);
                        containsSelectBondingOpt = true;
                        break;
                    }
                }
                if (containsSelectBondingOpt == false) {
                    if (Objects.equals(item.getBondOptions(), AsyncDataProvider.getInstance().getDefaultBondingOption())) {
                        selectBondingOpt = defaultItem;
                    } else {
                        selectBondingOpt = list.get(list.size() - 1);
                        EntityModel<String> entityModel = selectBondingOpt.getValue();
                        entityModel.setEntity(item.getBondOptions());
                    }
                }
                hostInterfaceModel.getBondingOptions().setSelectedItem(selectBondingOpt);
            }
            if (selectedNetwork == null && networksToAdd.size() > 0) {
                selectedNetwork = networksToAdd.get(0);
            }
            hostInterfaceModel.getNetwork().setSelectedItem(selectedNetwork);
            hostInterfaceModel.getCheckConnectivity().setIsAvailable(!StringHelper.isNullOrEmpty(item.getNetworkName()) && item.getIsManagement());
            hostInterfaceModel.getCheckConnectivity().setIsChangeable(!StringHelper.isNullOrEmpty(item.getNetworkName()) && item.getIsManagement());
            hostInterfaceModel.getCheckConnectivity().setEntity(item.getIsManagement());
            if (networksToAdd.isEmpty()) {
                hostInterfaceModel.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoNetworksAvailablePleaseAddAdditionalNetworksMsg());
                // $NON-NLS-1$
                UICommand tempVar2 = new UICommand("Cancel", hostInterfaceListModel);
                tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                tempVar2.setIsDefault(true);
                tempVar2.setIsCancel(true);
                hostInterfaceModel.getCommands().add(tempVar2);
            } else {
                // $NON-NLS-1$
                UICommand tempVar3 = UICommand.createDefaultOkUiCommand("OnSave", hostInterfaceListModel);
                hostInterfaceModel.getCommands().add(tempVar3);
                // $NON-NLS-1$
                UICommand tempVar4 = UICommand.createCancelUiCommand("Cancel", hostInterfaceListModel);
                hostInterfaceModel.getCommands().add(tempVar4);
            }
        }
    };
    AsyncDataProvider.getInstance().getClusterNetworkList(_asyncQuery, getEntity().getClusterId());
}
#method_after
public void edit() {
    if (getWindow() != null) {
        return;
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) model;
            ArrayList<Network> networksByCluster = (ArrayList<Network>) ReturnValue;
            VdsNetworkInterface item = hostInterfaceListModel.getSelectedItem();
            ArrayList<Network> networksToAdd = new ArrayList<>();
            Network selectedNetwork = null;
            if (item.getVlanId() != null) {
                for (Network network : networksByCluster) {
                    if (Objects.equals(network.getName(), item.getNetworkName())) {
                        networksToAdd.add(network);
                        if (selectedNetwork == null) {
                            selectedNetwork = network;
                        }
                    }
                }
            } else {
                // creating dictionary of networks by name
                HashMap<String, Network> networkDictionary = new HashMap<>();
                for (Network network : networksByCluster) {
                    networkDictionary.put(network.getName(), network);
                }
                // creating list of attached networks.
                ArrayList<Network> attachedNetworks = new ArrayList<>();
                for (VdsNetworkInterface nic : hostInterfaceListModel.getAllItems()) {
                    if (nic.getNetworkName() != null && networkDictionary.containsKey(nic.getNetworkName())) {
                        attachedNetworks.add(networkDictionary.get(nic.getNetworkName()));
                    }
                }
                ArrayList<Network> unAttachedNetworks = Linq.except(networksByCluster, attachedNetworks);
                // adding selected network names to list.
                boolean isVlanSelected = false;
                boolean isManagementSelected = false;
                ArrayList<VdsNetworkInterface> selectedItems = hostInterfaceListModel.getSelectedItemsWithVlans();
                ArrayList<String> selectedNicsNetworks = new ArrayList<>();
                for (VdsNetworkInterface nic : selectedItems) {
                    if (!StringHelper.isNullOrEmpty(nic.getNetworkName())) {
                        if (nic.getIsManagement()) {
                            isManagementSelected = true;
                        }
                        selectedNicsNetworks.add(nic.getNetworkName());
                        if (!isVlanSelected && nic.getVlanId() != null) {
                            isVlanSelected = true;
                        }
                    }
                }
                for (String selectedNetworkName : selectedNicsNetworks) {
                    if (networkDictionary.containsKey(selectedNetworkName)) {
                        Network network = networkDictionary.get(selectedNetworkName);
                        networksToAdd.add(network);
                        attachedNetworks.remove(network);
                        if (selectedNetwork == null) {
                            selectedNetwork = network;
                        }
                    }
                }
                if (!isManagementSelected || isVlanSelected) {
                    for (Network unAttachedNetwork : unAttachedNetworks) {
                        if (isVlanSelected) {
                            if (unAttachedNetwork.getVlanId() != null) {
                                networksToAdd.add(unAttachedNetwork);
                            }
                        } else {
                            networksToAdd.add(unAttachedNetwork);
                        }
                    }
                }
            }
            Collections.sort(networksToAdd, new NameableComparator());
            // Add a 'none' option to networks.
            if (!StringHelper.isNullOrEmpty(item.getNetworkName())) {
                Network tempVar = new Network();
                tempVar.setId(Guid.Empty);
                // $NON-NLS-1$
                tempVar.setName("None");
                networksToAdd.add(0, tempVar);
            }
            HostInterfaceModel hostInterfaceModel = new HostInterfaceModel();
            hostInterfaceListModel.setWindow(hostInterfaceModel);
            hostInterfaceModel.setEntity(item.getName());
            hostInterfaceModel.setTitle(ConstantsManager.getInstance().getConstants().editNetworkInterfaceTitle());
            hostInterfaceModel.setHelpTag(HelpTag.edit_network_interface_hosts);
            // $NON-NLS-1$
            hostInterfaceModel.setHashName("edit_network_interface_hosts");
            hostInterfaceModel.setNetworks(hostInterfaceListModel.getSelectedItemsWithVlans());
            hostInterfaceModel.setNoneBootProtocolAvailable(!item.getIsManagement());
            hostInterfaceModel.setBootProtocol(!hostInterfaceModel.getNoneBootProtocolAvailable() && item.getBootProtocol() == NetworkBootProtocol.NONE ? NetworkBootProtocol.DHCP : item.getBootProtocol());
            hostInterfaceModel.getAddress().setEntity(item.getAddress());
            hostInterfaceModel.getSubnet().setEntity(item.getSubnet());
            hostInterfaceModel.getNetwork().setItems(networksToAdd);
            hostInterfaceModel.getName().setEntity(item.getName());
            hostInterfaceModel.getBondingOptions().setIsAvailable(false);
            if (item.getBonded() != null && item.getBonded().equals(true)) {
                hostInterfaceModel.getBondingOptions().setIsAvailable(true);
                Map.Entry<String, EntityModel<String>> defaultItem = null;
                RefObject<Map.Entry<String, EntityModel<String>>> tempRef_defaultItem = new RefObject<>(defaultItem);
                ArrayList<Map.Entry<String, EntityModel<String>>> list = AsyncDataProvider.getInstance().getBondingOptionList(tempRef_defaultItem);
                defaultItem = tempRef_defaultItem.argvalue;
                Map.Entry<String, EntityModel<String>> selectBondingOpt = new KeyValuePairCompat<>();
                boolean containsSelectBondingOpt = false;
                hostInterfaceModel.getBondingOptions().setItems(list);
                for (int i = 0; i < list.size(); i++) {
                    if (Objects.equals(list.get(i).getKey(), item.getBondOptions())) {
                        selectBondingOpt = list.get(i);
                        containsSelectBondingOpt = true;
                        break;
                    }
                }
                if (!containsSelectBondingOpt) {
                    if (Objects.equals(item.getBondOptions(), AsyncDataProvider.getInstance().getDefaultBondingOption())) {
                        selectBondingOpt = defaultItem;
                    } else {
                        selectBondingOpt = list.get(list.size() - 1);
                        EntityModel<String> entityModel = selectBondingOpt.getValue();
                        entityModel.setEntity(item.getBondOptions());
                    }
                }
                hostInterfaceModel.getBondingOptions().setSelectedItem(selectBondingOpt);
            }
            if (selectedNetwork == null && networksToAdd.size() > 0) {
                selectedNetwork = networksToAdd.get(0);
            }
            hostInterfaceModel.getNetwork().setSelectedItem(selectedNetwork);
            hostInterfaceModel.getCheckConnectivity().setIsAvailable(!StringHelper.isNullOrEmpty(item.getNetworkName()) && item.getIsManagement());
            hostInterfaceModel.getCheckConnectivity().setIsChangeable(!StringHelper.isNullOrEmpty(item.getNetworkName()) && item.getIsManagement());
            hostInterfaceModel.getCheckConnectivity().setEntity(item.getIsManagement());
            if (networksToAdd.isEmpty()) {
                hostInterfaceModel.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoNetworksAvailablePleaseAddAdditionalNetworksMsg());
                // $NON-NLS-1$
                UICommand tempVar2 = new UICommand("Cancel", hostInterfaceListModel);
                tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                tempVar2.setIsDefault(true);
                tempVar2.setIsCancel(true);
                hostInterfaceModel.getCommands().add(tempVar2);
            } else {
                // $NON-NLS-1$
                UICommand tempVar3 = UICommand.createDefaultOkUiCommand("OnSave", hostInterfaceListModel);
                hostInterfaceModel.getCommands().add(tempVar3);
                // $NON-NLS-1$
                UICommand tempVar4 = UICommand.createCancelUiCommand("Cancel", hostInterfaceListModel);
                hostInterfaceModel.getCommands().add(tempVar4);
            }
        }
    };
    AsyncDataProvider.getInstance().getClusterNetworkList(_asyncQuery, getEntity().getClusterId());
}
#end_block

#method_before
public void editManagementNetwork() {
    if (getWindow() != null) {
        return;
    }
    HostManagementNetworkModel managementNicModel = new HostManagementNetworkModel();
    setWindow(managementNicModel);
    managementNicModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
    managementNicModel.setHelpTag(HelpTag.edit_management_network);
    // $NON-NLS-1$
    managementNicModel.setHashName("edit_management_network");
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            final HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) model;
            ArrayList<Network> clusterNetworks = (ArrayList<Network>) ReturnValue;
            final VdsNetworkInterface item = (VdsNetworkInterface) hostInterfaceListModel.getSelectedItem();
            final HostManagementNetworkModel managementModel = (HostManagementNetworkModel) hostInterfaceListModel.getWindow();
            Network networkToEdit = Linq.findNetworkByName(clusterNetworks, item.getNetworkName());
            managementModel.setEntity(networkToEdit);
            managementModel.setNoneBootProtocolAvailable(!item.getIsManagement());
            managementModel.setBootProtocol(!managementModel.getNoneBootProtocolAvailable() && item.getBootProtocol() == NetworkBootProtocol.NONE ? NetworkBootProtocol.DHCP : item.getBootProtocol());
            managementModel.getAddress().setEntity(item.getAddress());
            managementModel.getSubnet().setEntity(item.getSubnet());
            managementModel.getGateway().setEntity(item.getGateway());
            final StringBuilder tmpDefaultInterfaceName = new StringBuilder();
            AsyncDataProvider.getInstance().getInterfaceOptionsForEditNetwork(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ArrayList<VdsNetworkInterface> interfaces = (ArrayList<VdsNetworkInterface>) returnValue;
                    String defaultInterfaceName = tmpDefaultInterfaceName.toString();
                    managementModel.getInterface().setItems(interfaces);
                    managementModel.getInterface().setSelectedItem(Linq.findInterfaceByNetworkName(interfaces, defaultInterfaceName));
                    if (item.getBonded() != null && item.getBonded().equals(true)) {
                        managementModel.getInterface().setTitle(ConstantsManager.getInstance().getConstants().interfaceListTitle());
                        managementModel.getInterface().getSelectedItemChangedEvent().addListener(hostInterfaceListModel);
                    }
                    managementModel.getCheckConnectivity().setIsAvailable(true);
                    managementModel.getCheckConnectivity().setIsChangeable(true);
                    // currently, always
                    managementModel.getCheckConnectivity().setEntity(item.getIsManagement());
                    // should be
                    // true
                    managementModel.getBondingOptions().setIsAvailable(false);
                    if (item.getBonded() != null && item.getBonded().equals(true)) {
                        managementModel.getBondingOptions().setIsAvailable(true);
                        Map.Entry<String, EntityModel<String>> defaultItem = null;
                        RefObject<Map.Entry<String, EntityModel<String>>> tempRef_defaultItem = new RefObject<>(defaultItem);
                        ArrayList<Map.Entry<String, EntityModel<String>>> list = AsyncDataProvider.getInstance().getBondingOptionList(tempRef_defaultItem);
                        defaultItem = tempRef_defaultItem.argvalue;
                        Map.Entry<String, EntityModel<String>> selectBondingOpt = new KeyValuePairCompat<>();
                        boolean containsSelectBondingOpt = false;
                        managementModel.getBondingOptions().setItems(list);
                        for (int i = 0; i < list.size(); i++) {
                            if (Objects.equals(list.get(i).getKey(), item.getBondOptions())) {
                                selectBondingOpt = list.get(i);
                                containsSelectBondingOpt = true;
                                break;
                            }
                        }
                        if (containsSelectBondingOpt == false) {
                            if (Objects.equals(item.getBondOptions(), AsyncDataProvider.getInstance().getDefaultBondingOption())) {
                                selectBondingOpt = defaultItem;
                            } else {
                                selectBondingOpt = list.get(list.size() - 1);
                                EntityModel<String> entityModel = selectBondingOpt.getValue();
                                entityModel.setEntity(item.getBondOptions());
                            }
                        }
                        managementModel.getBondingOptions().setSelectedItem(selectBondingOpt);
                    }
                    UICommand tempVar = // $NON-NLS-1$
                    UICommand.createDefaultOkUiCommand("OnEditManagementNetworkConfirmation", hostInterfaceListModel);
                    managementModel.getCommands().add(tempVar);
                    // $NON-NLS-1$
                    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", hostInterfaceListModel);
                    managementModel.getCommands().add(tempVar2);
                }
            }), getOriginalItems(), item, networkToEdit, getEntity().getId(), tmpDefaultInterfaceName);
        }
    };
    AsyncDataProvider.getInstance().getClusterNetworkList(_asyncQuery, getEntity().getClusterId());
}
#method_after
public void editManagementNetwork() {
    if (getWindow() != null) {
        return;
    }
    HostManagementNetworkModel managementNicModel = new HostManagementNetworkModel();
    setWindow(managementNicModel);
    managementNicModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
    managementNicModel.setHelpTag(HelpTag.edit_management_network);
    // $NON-NLS-1$
    managementNicModel.setHashName("edit_management_network");
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            final HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) model;
            ArrayList<Network> clusterNetworks = (ArrayList<Network>) ReturnValue;
            final VdsNetworkInterface item = hostInterfaceListModel.getSelectedItem();
            final HostManagementNetworkModel managementModel = (HostManagementNetworkModel) hostInterfaceListModel.getWindow();
            Network networkToEdit = Linq.findNetworkByName(clusterNetworks, item.getNetworkName());
            managementModel.setEntity(networkToEdit);
            managementModel.setNoneBootProtocolAvailable(!item.getIsManagement());
            managementModel.setBootProtocol(!managementModel.getNoneBootProtocolAvailable() && item.getBootProtocol() == NetworkBootProtocol.NONE ? NetworkBootProtocol.DHCP : item.getBootProtocol());
            managementModel.getAddress().setEntity(item.getAddress());
            managementModel.getSubnet().setEntity(item.getSubnet());
            managementModel.getGateway().setEntity(item.getGateway());
            final StringBuilder tmpDefaultInterfaceName = new StringBuilder();
            AsyncDataProvider.getInstance().getInterfaceOptionsForEditNetwork(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ArrayList<VdsNetworkInterface> interfaces = (ArrayList<VdsNetworkInterface>) returnValue;
                    String defaultInterfaceName = tmpDefaultInterfaceName.toString();
                    managementModel.getInterface().setItems(interfaces);
                    managementModel.getInterface().setSelectedItem(Linq.findInterfaceByNetworkName(interfaces, defaultInterfaceName));
                    if (item.getBonded() != null && item.getBonded().equals(true)) {
                        managementModel.getInterface().setTitle(ConstantsManager.getInstance().getConstants().interfaceListTitle());
                        managementModel.getInterface().getSelectedItemChangedEvent().addListener(hostInterfaceListModel);
                    }
                    managementModel.getCheckConnectivity().setIsAvailable(true);
                    managementModel.getCheckConnectivity().setIsChangeable(true);
                    // currently, always
                    managementModel.getCheckConnectivity().setEntity(item.getIsManagement());
                    // should be
                    // true
                    managementModel.getBondingOptions().setIsAvailable(false);
                    if (item.getBonded() != null && item.getBonded().equals(true)) {
                        managementModel.getBondingOptions().setIsAvailable(true);
                        Map.Entry<String, EntityModel<String>> defaultItem = null;
                        RefObject<Map.Entry<String, EntityModel<String>>> tempRef_defaultItem = new RefObject<>(defaultItem);
                        ArrayList<Map.Entry<String, EntityModel<String>>> list = AsyncDataProvider.getInstance().getBondingOptionList(tempRef_defaultItem);
                        defaultItem = tempRef_defaultItem.argvalue;
                        Map.Entry<String, EntityModel<String>> selectBondingOpt = new KeyValuePairCompat<>();
                        boolean containsSelectBondingOpt = false;
                        managementModel.getBondingOptions().setItems(list);
                        for (int i = 0; i < list.size(); i++) {
                            if (Objects.equals(list.get(i).getKey(), item.getBondOptions())) {
                                selectBondingOpt = list.get(i);
                                containsSelectBondingOpt = true;
                                break;
                            }
                        }
                        if (!containsSelectBondingOpt) {
                            if (Objects.equals(item.getBondOptions(), AsyncDataProvider.getInstance().getDefaultBondingOption())) {
                                selectBondingOpt = defaultItem;
                            } else {
                                selectBondingOpt = list.get(list.size() - 1);
                                EntityModel<String> entityModel = selectBondingOpt.getValue();
                                entityModel.setEntity(item.getBondOptions());
                            }
                        }
                        managementModel.getBondingOptions().setSelectedItem(selectBondingOpt);
                    }
                    UICommand tempVar = // $NON-NLS-1$
                    UICommand.createDefaultOkUiCommand("OnEditManagementNetworkConfirmation", hostInterfaceListModel);
                    managementModel.getCommands().add(tempVar);
                    // $NON-NLS-1$
                    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", hostInterfaceListModel);
                    managementModel.getCommands().add(tempVar2);
                }
            }), getOriginalItems(), item, networkToEdit, getEntity().getId(), tmpDefaultInterfaceName);
        }
    };
    AsyncDataProvider.getInstance().getClusterNetworkList(_asyncQuery, getEntity().getClusterId());
}
#end_block

#method_before
public void onEditManagementNetworkConfirmation(boolean isBond) {
    if (!isBond) {
        HostManagementNetworkModel model = (HostManagementNetworkModel) getWindow();
        if (!model.validate()) {
            return;
        }
        if (model.getCheckConnectivity().getEntity() == true) {
            onEditManagementNetwork();
            return;
        }
    } else {
        HostBondInterfaceModel model = (HostBondInterfaceModel) getWindow();
        if (!model.validate()) {
            return;
        }
        if (model.getCheckConnectivity().getEntity() == true) {
            onBond();
            return;
        }
    }
    ConfirmationModel confirmModel = new ConfirmationModel();
    setConfirmWindow(confirmModel);
    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().confirmTitle());
    confirmModel.getLatch().setEntity(true);
    confirmModel.getLatch().setIsAvailable(true);
    confirmModel.getLatch().setIsChangeable(true);
    if (!isBond) {
        // $NON-NLS-1$
        UICommand tempVar = UICommand.createDefaultOkUiCommand("OnEditManagementNetwork", this);
        confirmModel.getCommands().add(tempVar);
    } else {
        // $NON-NLS-1$
        UICommand tempVar2 = UICommand.createDefaultOkUiCommand("OnBond", this);
        confirmModel.getCommands().add(tempVar2);
    }
    // $NON-NLS-1$
    UICommand tempVar3 = UICommand.createCancelUiCommand("CancelConfirm", this);
    confirmModel.getCommands().add(tempVar3);
}
#method_after
public void onEditManagementNetworkConfirmation(boolean isBond) {
    if (!isBond) {
        HostManagementNetworkModel model = (HostManagementNetworkModel) getWindow();
        if (!model.validate()) {
            return;
        }
        if (model.getCheckConnectivity().getEntity()) {
            onEditManagementNetwork();
            return;
        }
    } else {
        HostBondInterfaceModel model = (HostBondInterfaceModel) getWindow();
        if (!model.validate()) {
            return;
        }
        if (model.getCheckConnectivity().getEntity()) {
            onBond();
            return;
        }
    }
    ConfirmationModel confirmModel = new ConfirmationModel();
    setConfirmWindow(confirmModel);
    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().confirmTitle());
    confirmModel.getLatch().setEntity(true);
    confirmModel.getLatch().setIsAvailable(true);
    confirmModel.getLatch().setIsChangeable(true);
    if (!isBond) {
        // $NON-NLS-1$
        UICommand tempVar = UICommand.createDefaultOkUiCommand("OnEditManagementNetwork", this);
        confirmModel.getCommands().add(tempVar);
    } else {
        // $NON-NLS-1$
        UICommand tempVar2 = UICommand.createDefaultOkUiCommand("OnBond", this);
        confirmModel.getCommands().add(tempVar2);
    }
    // $NON-NLS-1$
    UICommand tempVar3 = UICommand.createCancelUiCommand("CancelConfirm", this);
    confirmModel.getCommands().add(tempVar3);
}
#end_block

#method_before
public void onEditManagementNetwork() {
    HostManagementNetworkModel model = (HostManagementNetworkModel) getWindow();
    if (getConfirmWindow() != null) {
        ConfirmationModel confirmModel = (ConfirmationModel) getConfirmWindow();
        if (confirmModel.getLatch().getEntity() == true) {
            model.getCheckConnectivity().setEntity(true);
        }
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    VdsNetworkInterface nic = model.getInterface().getSelectedItem();
    Network network = model.getEntity();
    VdcActionType actionType = VdcActionType.UpdateNetworkToVdsInterface;
    UpdateNetworkToVdsParameters parameters = new UpdateNetworkToVdsParameters(getEntity().getId(), network, new ArrayList<>(Arrays.asList(new VdsNetworkInterface[] { nic })));
    Map.Entry<String, EntityModel<String>> bondingOption;
    if (model.getBondingOptions().getSelectedItem() != null) {
        bondingOption = model.getBondingOptions().getSelectedItem();
        if (!bondingOption.getKey().equals("custom")) {
            // $NON-NLS-1$
            parameters.setBondingOptions(StringHelper.isNullOrEmpty(bondingOption.getKey()) ? null : bondingOption.getKey());
        } else {
            EntityModel entityModel = bondingOption.getValue();
            if (entityModel.getEntity() != null) {
                parameters.setBondingOptions(entityModel.getEntity().toString());
            }
        }
    }
    if (nic.getBonded() == null || nic.getBonded() == false) {
        parameters.setBondingOptions(null);
    }
    if (network != null) {
        parameters.setOldNetworkName(network.getName());
    }
    parameters.setCheckConnectivity(model.getCheckConnectivity().getEntity());
    parameters.setBootProtocol(model.getBootProtocol());
    if (model.getIsStaticAddress()) {
        parameters.setAddress(model.getAddress().getEntity());
        parameters.setSubnet(model.getSubnet().getEntity());
        parameters.setGateway(model.getGateway().getEntity());
    }
    model.startProgress();
    setcurrentModel(model);
    Frontend.getInstance().runAction(actionType, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                EntityModel<Boolean> commitChanges = ((HostManagementNetworkModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                if (commitChanges.getEntity()) {
                    new SaveNetworkConfigAction(HostInterfaceListModel.this, hostInterfaceListModel.getcurrentModel(), getEntity()).execute();
                } else {
                    hostInterfaceListModel.getcurrentModel().stopProgress();
                    hostInterfaceListModel.cancel();
                    hostInterfaceListModel.search();
                }
            } else {
                hostInterfaceListModel.getcurrentModel().stopProgress();
            }
        }
    }, this);
    cancelConfirm();
}
#method_after
public void onEditManagementNetwork() {
    HostManagementNetworkModel model = (HostManagementNetworkModel) getWindow();
    if (getConfirmWindow() != null) {
        ConfirmationModel confirmModel = (ConfirmationModel) getConfirmWindow();
        if (confirmModel.getLatch().getEntity()) {
            model.getCheckConnectivity().setEntity(true);
        }
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    VdsNetworkInterface nic = model.getInterface().getSelectedItem();
    Network network = model.getEntity();
    VdcActionType actionType = VdcActionType.UpdateNetworkToVdsInterface;
    UpdateNetworkToVdsParameters parameters = new UpdateNetworkToVdsParameters(getEntity().getId(), network, new ArrayList<>(Arrays.asList(new VdsNetworkInterface[] { nic })));
    Map.Entry<String, EntityModel<String>> bondingOption;
    if (model.getBondingOptions().getSelectedItem() != null) {
        bondingOption = model.getBondingOptions().getSelectedItem();
        if (!bondingOption.getKey().equals("custom")) {
            // $NON-NLS-1$
            parameters.setBondingOptions(StringHelper.isNullOrEmpty(bondingOption.getKey()) ? null : bondingOption.getKey());
        } else {
            EntityModel entityModel = bondingOption.getValue();
            if (entityModel.getEntity() != null) {
                parameters.setBondingOptions(entityModel.getEntity().toString());
            }
        }
    }
    if (nic.getBonded() == null || !nic.getBonded()) {
        parameters.setBondingOptions(null);
    }
    if (network != null) {
        parameters.setOldNetworkName(network.getName());
    }
    parameters.setCheckConnectivity(model.getCheckConnectivity().getEntity());
    parameters.setBootProtocol(model.getBootProtocol());
    if (model.getIsStaticAddress()) {
        parameters.setAddress(model.getAddress().getEntity());
        parameters.setSubnet(model.getSubnet().getEntity());
        parameters.setGateway(model.getGateway().getEntity());
    }
    model.startProgress();
    setcurrentModel(model);
    Frontend.getInstance().runAction(actionType, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                EntityModel<Boolean> commitChanges = ((HostManagementNetworkModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                if (commitChanges.getEntity()) {
                    new SaveNetworkConfigAction(HostInterfaceListModel.this, hostInterfaceListModel.getcurrentModel(), getEntity()).execute();
                } else {
                    hostInterfaceListModel.getcurrentModel().stopProgress();
                    hostInterfaceListModel.cancel();
                    hostInterfaceListModel.search();
                }
            } else {
                hostInterfaceListModel.getcurrentModel().stopProgress();
            }
        }
    }, this);
    cancelConfirm();
}
#end_block

#method_before
public void onBond() {
    HostBondInterfaceModel model = (HostBondInterfaceModel) getWindow();
    if (getConfirmWindow() != null) {
        ConfirmationModel confirmModel = (ConfirmationModel) getConfirmWindow();
        if (confirmModel.getLatch().getEntity() == true) {
            model.getCheckConnectivity().setEntity(true);
        }
        cancelConfirm();
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    VDS host = getEntity();
    ArrayList<VdsNetworkInterface> selectedItems = getSelectedItems();
    Network net = model.getNetwork().getSelectedItem();
    // Interface interfaceWithNetwork = items.FirstOrDefault(a => !string.IsNullOrEmpty(a.network_name));
    VdsNetworkInterface interfaceWithNetwork = Linq.findInterfaceNetworkNameNotEmpty(selectedItems);
    // look for lines with vlans
    ArrayList<HostInterfaceLineModel> itemList = (ArrayList<HostInterfaceLineModel>) getItems();
    for (HostInterfaceLineModel lineModel : itemList) {
        if (lineModel.getIsSelected() && lineModel.getVlanSize() == 1) {
            interfaceWithNetwork = lineModel.getVLans().get(0).getInterface();
            // bond action is only enabled if there is one vlaned interface
            break;
        }
    }
    if (interfaceWithNetwork != null) {
        UpdateNetworkToVdsParameters parameters = new UpdateNetworkToVdsParameters(host.getId(), net, selectedItems);
        parameters.setCheckConnectivity(model.getCheckConnectivity().getEntity());
        parameters.setOldNetworkName(interfaceWithNetwork.getNetworkName());
        Map.Entry<String, EntityModel<String>> bondingOption;
        if (model.getBondingOptions().getSelectedItem() != null) {
            bondingOption = model.getBondingOptions().getSelectedItem();
            if (!bondingOption.getKey().equals("custom")) {
                // $NON-NLS-1$
                parameters.setBondingOptions(StringHelper.isNullOrEmpty(bondingOption.getKey()) ? null : bondingOption.getKey());
            } else {
                EntityModel entityModel = bondingOption.getValue();
                if (entityModel.getEntity() != null) {
                    parameters.setBondingOptions(entityModel.getEntity().toString());
                }
            }
        }
        parameters.setBootProtocol(model.getBootProtocol());
        parameters.setBondName(model.getBond().getSelectedItem());
        if (model.getIsStaticAddress()) {
            parameters.setAddress(model.getAddress().getEntity());
            parameters.setSubnet(model.getSubnet().getEntity());
            if (interfaceWithNetwork.getIsManagement()) {
                parameters.setGateway(model.getGateway().getEntity());
            }
        }
        model.startProgress();
        setcurrentModel(model);
        Frontend.getInstance().runAction(VdcActionType.UpdateNetworkToVdsInterface, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    EntityModel<Boolean> commitChanges = ((HostBondInterfaceModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                    if (commitChanges.getEntity()) {
                        new SaveNetworkConfigAction(HostInterfaceListModel.this, hostInterfaceListModel.getcurrentModel(), getEntity()).execute();
                    } else {
                        hostInterfaceListModel.getcurrentModel().stopProgress();
                        hostInterfaceListModel.cancel();
                        hostInterfaceListModel.search();
                    }
                } else {
                    hostInterfaceListModel.getcurrentModel().stopProgress();
                }
            }
        }, this);
    } else {
        String[] nics = new String[selectedItems.size()];
        for (int i = 0; i < selectedItems.size(); i++) {
            nics[i] = selectedItems.get(i).getName();
        }
        AddBondParameters parameters = new AddBondParameters(host.getId(), model.getBond().getSelectedItem(), net, nics);
        Map.Entry<String, EntityModel<String>> bondingOption;
        if (model.getBondingOptions().getSelectedItem() != null) {
            bondingOption = model.getBondingOptions().getSelectedItem();
            if (!bondingOption.getKey().equals("custom")) {
                // $NON-NLS-1$
                parameters.setBondingOptions(StringHelper.isNullOrEmpty(bondingOption.getKey()) ? null : bondingOption.getKey());
            } else {
                EntityModel entityModel = bondingOption.getValue();
                if (entityModel.getEntity() != null) {
                    parameters.setBondingOptions(entityModel.getEntity().toString());
                }
            }
        }
        parameters.setBootProtocol(model.getBootProtocol());
        if (model.getIsStaticAddress()) {
            parameters.setAddress(model.getAddress().getEntity());
            parameters.setSubnet(model.getSubnet().getEntity());
            parameters.setGateway(model.getGateway().getEntity());
        }
        model.startProgress();
        setcurrentModel(model);
        Frontend.getInstance().runAction(VdcActionType.AddBond, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    EntityModel<Boolean> commitChanges = ((HostBondInterfaceModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                    if (commitChanges.getEntity()) {
                        new SaveNetworkConfigAction(HostInterfaceListModel.this, hostInterfaceListModel.getcurrentModel(), getEntity()).execute();
                    } else {
                        hostInterfaceListModel.getcurrentModel().stopProgress();
                        hostInterfaceListModel.cancel();
                        hostInterfaceListModel.search();
                    }
                } else {
                    hostInterfaceListModel.getcurrentModel().stopProgress();
                }
            }
        }, this);
    }
}
#method_after
public void onBond() {
    HostBondInterfaceModel model = (HostBondInterfaceModel) getWindow();
    if (getConfirmWindow() != null) {
        ConfirmationModel confirmModel = (ConfirmationModel) getConfirmWindow();
        if (confirmModel.getLatch().getEntity()) {
            model.getCheckConnectivity().setEntity(true);
        }
        cancelConfirm();
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    VDS host = getEntity();
    ArrayList<VdsNetworkInterface> selectedItems = getSelectedItems();
    Network net = model.getNetwork().getSelectedItem();
    // Interface interfaceWithNetwork = items.FirstOrDefault(a => !string.IsNullOrEmpty(a.network_name));
    VdsNetworkInterface interfaceWithNetwork = Linq.findInterfaceNetworkNameNotEmpty(selectedItems);
    // look for lines with vlans
    ArrayList<HostInterfaceLineModel> itemList = (ArrayList<HostInterfaceLineModel>) getItems();
    for (HostInterfaceLineModel lineModel : itemList) {
        if (lineModel.getIsSelected() && lineModel.getVlanSize() == 1) {
            interfaceWithNetwork = lineModel.getVLans().get(0).getInterface();
            // bond action is only enabled if there is one vlaned interface
            break;
        }
    }
    if (interfaceWithNetwork != null) {
        UpdateNetworkToVdsParameters parameters = new UpdateNetworkToVdsParameters(host.getId(), net, selectedItems);
        parameters.setCheckConnectivity(model.getCheckConnectivity().getEntity());
        parameters.setOldNetworkName(interfaceWithNetwork.getNetworkName());
        Map.Entry<String, EntityModel<String>> bondingOption;
        if (model.getBondingOptions().getSelectedItem() != null) {
            bondingOption = model.getBondingOptions().getSelectedItem();
            if (!bondingOption.getKey().equals("custom")) {
                // $NON-NLS-1$
                parameters.setBondingOptions(StringHelper.isNullOrEmpty(bondingOption.getKey()) ? null : bondingOption.getKey());
            } else {
                EntityModel entityModel = bondingOption.getValue();
                if (entityModel.getEntity() != null) {
                    parameters.setBondingOptions(entityModel.getEntity().toString());
                }
            }
        }
        parameters.setBootProtocol(model.getBootProtocol());
        parameters.setBondName(model.getBond().getSelectedItem());
        if (model.getIsStaticAddress()) {
            parameters.setAddress(model.getAddress().getEntity());
            parameters.setSubnet(model.getSubnet().getEntity());
            if (interfaceWithNetwork.getIsManagement()) {
                parameters.setGateway(model.getGateway().getEntity());
            }
        }
        model.startProgress();
        setcurrentModel(model);
        Frontend.getInstance().runAction(VdcActionType.UpdateNetworkToVdsInterface, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    EntityModel<Boolean> commitChanges = ((HostBondInterfaceModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                    if (commitChanges.getEntity()) {
                        new SaveNetworkConfigAction(HostInterfaceListModel.this, hostInterfaceListModel.getcurrentModel(), getEntity()).execute();
                    } else {
                        hostInterfaceListModel.getcurrentModel().stopProgress();
                        hostInterfaceListModel.cancel();
                        hostInterfaceListModel.search();
                    }
                } else {
                    hostInterfaceListModel.getcurrentModel().stopProgress();
                }
            }
        }, this);
    } else {
        String[] nics = new String[selectedItems.size()];
        for (int i = 0; i < selectedItems.size(); i++) {
            nics[i] = selectedItems.get(i).getName();
        }
        AddBondParameters parameters = new AddBondParameters(host.getId(), model.getBond().getSelectedItem(), net, nics);
        Map.Entry<String, EntityModel<String>> bondingOption;
        if (model.getBondingOptions().getSelectedItem() != null) {
            bondingOption = model.getBondingOptions().getSelectedItem();
            if (!bondingOption.getKey().equals("custom")) {
                // $NON-NLS-1$
                parameters.setBondingOptions(StringHelper.isNullOrEmpty(bondingOption.getKey()) ? null : bondingOption.getKey());
            } else {
                EntityModel entityModel = bondingOption.getValue();
                if (entityModel.getEntity() != null) {
                    parameters.setBondingOptions(entityModel.getEntity().toString());
                }
            }
        }
        parameters.setBootProtocol(model.getBootProtocol());
        if (model.getIsStaticAddress()) {
            parameters.setAddress(model.getAddress().getEntity());
            parameters.setSubnet(model.getSubnet().getEntity());
            parameters.setGateway(model.getGateway().getEntity());
        }
        model.startProgress();
        setcurrentModel(model);
        Frontend.getInstance().runAction(VdcActionType.AddBond, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    EntityModel<Boolean> commitChanges = ((HostBondInterfaceModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                    if (commitChanges.getEntity()) {
                        new SaveNetworkConfigAction(HostInterfaceListModel.this, hostInterfaceListModel.getcurrentModel(), getEntity()).execute();
                    } else {
                        hostInterfaceListModel.getcurrentModel().stopProgress();
                        hostInterfaceListModel.cancel();
                        hostInterfaceListModel.search();
                    }
                } else {
                    hostInterfaceListModel.getcurrentModel().stopProgress();
                }
            }
        }, this);
    }
}
#end_block

#method_before
public void detach() {
    if (getWindow() != null) {
        return;
    }
    HostInterfaceModel model = new HostInterfaceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().detachNetworkInterfacesTitle());
    model.setHelpTag(HelpTag.detach_network_interfaces);
    // $NON-NLS-1$
    model.setHashName("detach_network_interfaces");
    VdsNetworkInterface nic = (VdsNetworkInterface) getSelectedItem();
    model.getName().setEntity(nic.getName());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnDetach", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
public void detach() {
    if (getWindow() != null) {
        return;
    }
    HostInterfaceModel model = new HostInterfaceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().detachNetworkInterfacesTitle());
    model.setHelpTag(HelpTag.detach_network_interfaces);
    // $NON-NLS-1$
    model.setHashName("detach_network_interfaces");
    VdsNetworkInterface nic = getSelectedItem();
    model.getName().setEntity(nic.getName());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnDetach", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void onDetach() {
    HostInterfaceModel model = (HostInterfaceModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    setcurrentModel(model);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) model;
            ArrayList<Network> networks = (ArrayList<Network>) ReturnValue;
            Network defaultNetwork = new Network();
            VdsNetworkInterface nic = (VdsNetworkInterface) getSelectedItem();
            defaultNetwork.setName(nic.getNetworkName());
            Network tempVar = Linq.findNetworkByName(networks, nic.getNetworkName());
            Network net = (tempVar != null) ? tempVar : defaultNetwork;
            hostInterfaceListModel.startProgress();
            Frontend.getInstance().runAction(VdcActionType.DetachNetworkFromVdsInterface, new AttachNetworkToVdsParameters(getEntity().getId(), net, nic), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        EntityModel<Boolean> commitChanges = ((HostInterfaceModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                        if (commitChanges.getEntity()) {
                            new SaveNetworkConfigAction(HostInterfaceListModel.this, getcurrentModel(), getEntity()).execute();
                        } else {
                            hostInterfaceListModel.getcurrentModel().stopProgress();
                            hostInterfaceListModel.cancel();
                            hostInterfaceListModel.search();
                        }
                    } else {
                        hostInterfaceListModel.getcurrentModel().stopProgress();
                        hostInterfaceListModel.cancel();
                    }
                }
            }, hostInterfaceListModel);
        }
    };
    AsyncDataProvider.getInstance().getClusterNetworkList(_asyncQuery, getEntity().getClusterId());
}
#method_after
public void onDetach() {
    HostInterfaceModel model = (HostInterfaceModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    setcurrentModel(model);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) model;
            ArrayList<Network> networks = (ArrayList<Network>) ReturnValue;
            Network defaultNetwork = new Network();
            VdsNetworkInterface nic = getSelectedItem();
            defaultNetwork.setName(nic.getNetworkName());
            Network tempVar = Linq.findNetworkByName(networks, nic.getNetworkName());
            Network net = (tempVar != null) ? tempVar : defaultNetwork;
            hostInterfaceListModel.startProgress();
            Frontend.getInstance().runAction(VdcActionType.DetachNetworkFromVdsInterface, new AttachNetworkToVdsParameters(getEntity().getId(), net, nic), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        EntityModel<Boolean> commitChanges = ((HostInterfaceModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                        if (commitChanges.getEntity()) {
                            new SaveNetworkConfigAction(HostInterfaceListModel.this, getcurrentModel(), getEntity()).execute();
                        } else {
                            hostInterfaceListModel.getcurrentModel().stopProgress();
                            hostInterfaceListModel.cancel();
                            hostInterfaceListModel.search();
                        }
                    } else {
                        hostInterfaceListModel.getcurrentModel().stopProgress();
                        hostInterfaceListModel.cancel();
                    }
                }
            }, hostInterfaceListModel);
        }
    };
    AsyncDataProvider.getInstance().getClusterNetworkList(_asyncQuery, getEntity().getClusterId());
}
#end_block

#method_before
private void updateActionAvailability() {
    VDS host = getEntity();
    VdsNetworkInterface selectedItem = (VdsNetworkInterface) getSelectedItem();
    ArrayList<VdsNetworkInterface> selectedItems = getSelectedItems();
    getEditCommand().setIsExecutionAllowed(host != null && host.getStatus() != VDSStatus.NonResponsive && selectedItem != null && selectedItems.size() == 1 && StringHelper.isNullOrEmpty(selectedItem.getBondName()) && !selectedItem.getIsManagement());
    getBondCommand().setIsExecutionAllowed(host != null && host.getStatus() != VDSStatus.NonResponsive && selectedItems.size() >= 2 && !isAnyBond(selectedItems) && Linq.findAllInterfaceNetworkNameNotEmpty(selectedItems).size() <= 1 && Linq.findAllInterfaceBondNameIsEmpty(selectedItems).size() == selectedItems.size() && Linq.findAllInterfaceVlanIdIsEmpty(selectedItems).size() == selectedItems.size());
    // to bond, selected lines must not have more that 1 networks (vlan or not)
    if (getItems() != null) {
        ArrayList<HostInterfaceLineModel> itemList = (ArrayList<HostInterfaceLineModel>) getItems();
        // total network count cannot be more than 1
        int totalNetworkCount = 0;
        for (HostInterfaceLineModel lineModel : itemList) {
            if (lineModel.getIsSelected()) {
                int lineNetworkCount = lineModel.getVlanSize() + (lineModel.getNetworkName() != null ? 1 : 0);
                if (lineNetworkCount > 1) {
                    // bailout
                    getBondCommand().setIsExecutionAllowed(false);
                    break;
                }
                totalNetworkCount += lineNetworkCount;
                if (totalNetworkCount > 1) {
                    // bailout
                    getBondCommand().setIsExecutionAllowed(false);
                    break;
                }
            }
        }
    }
    getDetachCommand().setIsExecutionAllowed(host != null && host.getStatus() != VDSStatus.NonResponsive && selectedItems.size() == 1 && selectedItem != null && !StringHelper.isNullOrEmpty(selectedItem.getNetworkName()) && !selectedItem.getIsManagement());
    getSaveNetworkConfigCommand().setIsExecutionAllowed(host != null && (host.getNetConfigDirty() == null ? false : host.getNetConfigDirty()));
    getEditManagementNetworkCommand().setIsExecutionAllowed(host != null && host.getStatus() != VDSStatus.NonResponsive && selectedItems.size() == 1 && selectedItem != null && selectedItem.getIsManagement());
    // available only on less than 3.1 Clusters
    if (host != null) {
        boolean isLessThan31 = host.getClusterCompatibilityVersion().compareTo(Version.v3_1) < 0;
        getSetupNetworksCommand().setIsAvailable(!isLessThan31);
        getSaveNetworkConfigCommand().setIsAvailable(true);
        getEditCommand().setIsAvailable(isLessThan31);
        getBondCommand().setIsAvailable(isLessThan31);
        getDetachCommand().setIsAvailable(isLessThan31);
        getEditManagementNetworkCommand().setIsAvailable(isLessThan31);
        setSelectionAvailable(isLessThan31);
        // disable subtab refresh for pre-3.1 clusters, to avoid interfering with row selection
        setIsTimerDisabled(isLessThan31);
        if (isLessThan31) {
            getTimer().stopWithNotification();
        } else {
            getTimer().startWithNotification();
        }
    }
}
#method_after
private void updateActionAvailability() {
    VDS host = getEntity();
    VdsNetworkInterface selectedItem = getSelectedItem();
    ArrayList<VdsNetworkInterface> selectedItems = getSelectedItems();
    getEditCommand().setIsExecutionAllowed(host != null && host.getStatus() != VDSStatus.NonResponsive && selectedItem != null && selectedItems.size() == 1 && StringHelper.isNullOrEmpty(selectedItem.getBondName()) && !selectedItem.getIsManagement());
    getBondCommand().setIsExecutionAllowed(host != null && host.getStatus() != VDSStatus.NonResponsive && selectedItems.size() >= 2 && !isAnyBond(selectedItems) && Linq.findAllInterfaceNetworkNameNotEmpty(selectedItems).size() <= 1 && Linq.findAllInterfaceBondNameIsEmpty(selectedItems).size() == selectedItems.size() && Linq.findAllInterfaceVlanIdIsEmpty(selectedItems).size() == selectedItems.size());
    // to bond, selected lines must not have more that 1 networks (vlan or not)
    if (getItems() != null) {
        ArrayList<HostInterfaceLineModel> itemList = (ArrayList<HostInterfaceLineModel>) getItems();
        // total network count cannot be more than 1
        int totalNetworkCount = 0;
        for (HostInterfaceLineModel lineModel : itemList) {
            if (lineModel.getIsSelected()) {
                int lineNetworkCount = lineModel.getVlanSize() + (lineModel.getNetworkName() != null ? 1 : 0);
                if (lineNetworkCount > 1) {
                    // bailout
                    getBondCommand().setIsExecutionAllowed(false);
                    break;
                }
                totalNetworkCount += lineNetworkCount;
                if (totalNetworkCount > 1) {
                    // bailout
                    getBondCommand().setIsExecutionAllowed(false);
                    break;
                }
            }
        }
    }
    getDetachCommand().setIsExecutionAllowed(host != null && host.getStatus() != VDSStatus.NonResponsive && selectedItems.size() == 1 && selectedItem != null && !StringHelper.isNullOrEmpty(selectedItem.getNetworkName()) && !selectedItem.getIsManagement());
    getSaveNetworkConfigCommand().setIsExecutionAllowed(host != null && (host.getNetConfigDirty() == null ? false : host.getNetConfigDirty()));
    getEditManagementNetworkCommand().setIsExecutionAllowed(host != null && host.getStatus() != VDSStatus.NonResponsive && selectedItems.size() == 1 && selectedItem != null && selectedItem.getIsManagement());
    // available only on less than 3.1 Clusters
    if (host != null) {
        boolean isLessThan31 = host.getClusterCompatibilityVersion().compareTo(Version.v3_1) < 0;
        getSetupNetworksCommand().setIsAvailable(!isLessThan31);
        getSaveNetworkConfigCommand().setIsAvailable(true);
        getEditCommand().setIsAvailable(isLessThan31);
        getBondCommand().setIsAvailable(isLessThan31);
        getDetachCommand().setIsAvailable(isLessThan31);
        getEditManagementNetworkCommand().setIsAvailable(isLessThan31);
        setSelectionAvailable(isLessThan31);
        // disable subtab refresh for pre-3.1 clusters, to avoid interfering with row selection
        setIsTimerDisabled(isLessThan31);
        if (isLessThan31) {
            getTimer().stopWithNotification();
        } else {
            getTimer().startWithNotification();
        }
    }
}
#end_block

#method_before
@Override
public void setItems(Collection value) {
    if (items != value) {
        itemsChanging(value, items);
        items = value;
        getItemsChangedEvent().raise(this, EventArgs.EMPTY);
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("Items"));
        UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
        if (items != null && selectedItem != null) {
            for (Object object : items) {
                UserPortalItemModel itemModel = (UserPortalItemModel) object;
                if (itemModel.getEntity().equals(selectedItem.getEntity())) {
                    this.selectedItem = itemModel;
                    break;
                }
            }
        }
        onSelectedItemChanged();
    }
}
#method_after
@Override
public void setItems(Collection value) {
    if (items != value) {
        itemsChanging(value, items);
        items = value;
        getItemsChangedEvent().raise(this, EventArgs.EMPTY);
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("Items"));
        UserPortalItemModel selectedItem = getSelectedItem();
        if (items != null && selectedItem != null) {
            for (Object object : items) {
                UserPortalItemModel itemModel = (UserPortalItemModel) object;
                if (itemModel.getEntity().equals(selectedItem.getEntity())) {
                    this.selectedItem = itemModel;
                    break;
                }
            }
        }
        onSelectedItemChanged();
    }
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    UserPortalItemModel item = (UserPortalItemModel) getSelectedItem();
    vmGeneralModel.setIsAvailable(item != null && !item.isPool());
    vmSnapshotListModel.setIsAvailable(item != null && !item.isPool());
    vmMonitorModel.setIsAvailable(item != null && !item.isPool());
    vmDiskListModel.setIsAvailable(item != null && !item.isPool());
    vmInterfaceListModel.setIsAvailable(item != null && !item.isPool());
    vmEventListModel.setIsAvailable(item != null && !item.isPool());
    poolGeneralModel.setIsAvailable(item != null && item.isPool());
    poolDiskListModel.setIsAvailable(item != null && item.isPool());
    poolInterfaceListModel.setIsAvailable(item != null && item.isPool());
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    UserPortalItemModel item = getSelectedItem();
    vmGeneralModel.setIsAvailable(item != null && !item.isPool());
    vmSnapshotListModel.setIsAvailable(item != null && !item.isPool());
    vmMonitorModel.setIsAvailable(item != null && !item.isPool());
    vmDiskListModel.setIsAvailable(item != null && !item.isPool());
    vmInterfaceListModel.setIsAvailable(item != null && !item.isPool());
    vmEventListModel.setIsAvailable(item != null && !item.isPool());
    poolGeneralModel.setIsAvailable(item != null && item.isPool());
    poolDiskListModel.setIsAvailable(item != null && item.isPool());
    poolInterfaceListModel.setIsAvailable(item != null && item.isPool());
}
#end_block

#method_before
private void cloneVm() {
    final UserPortalItemModel vm = (UserPortalItemModel) getSelectedItem();
    if (vm == null) {
        return;
    }
    CloneVmModel model = new CloneVmModel(vm.getVM(), constants);
    setWindow(model);
    model.initialize();
    model.setTitle(ConstantsManager.getInstance().getConstants().cloneVmTitle());
    model.setHelpTag(HelpTag.clone_vm);
    // $NON-NLS-1$
    model.setHashName("clone_vm");
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OnClone", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(cancelCommand);
}
#method_after
private void cloneVm() {
    final UserPortalItemModel vm = getSelectedItem();
    if (vm == null) {
        return;
    }
    CloneVmModel model = new CloneVmModel(vm.getVM(), constants);
    setWindow(model);
    model.initialize();
    model.setTitle(ConstantsManager.getInstance().getConstants().cloneVmTitle());
    model.setHelpTag(HelpTag.clone_vm);
    // $NON-NLS-1$
    model.setHashName("clone_vm");
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OnClone", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void newTemplate() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    UnitVmModel windowModel = new UnitVmModel(new UserPortalNewTemplateVmModelBehavior(vm), this);
    setWindow(windowModel);
    windowModel.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    windowModel.setHelpTag(HelpTag.new_template);
    // $NON-NLS-1$
    windowModel.setHashName("new_template");
    windowModel.setIsNew(true);
    windowModel.getVmType().setSelectedItem(vm.getVmType());
    windowModel.initialize(null);
    windowModel.getIsTemplatePublic().setEntity(false);
    windowModel.getCommands().add(// $NON-NLS-1$)
    UICommand.createDefaultOkUiCommand("OnNewTemplate", this));
    // $NON-NLS-1$
    windowModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
    windowModel.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
}
#method_after
private void newTemplate() {
    UserPortalItemModel selectedItem = getSelectedItem();
    if (selectedItem == null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    UnitVmModel windowModel = new UnitVmModel(new UserPortalNewTemplateVmModelBehavior(vm), this);
    setWindow(windowModel);
    windowModel.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    windowModel.setHelpTag(HelpTag.new_template);
    // $NON-NLS-1$
    windowModel.setHashName("new_template");
    windowModel.setIsNew(true);
    windowModel.getVmType().setSelectedItem(vm.getVmType());
    windowModel.initialize(null);
    windowModel.getIsTemplatePublic().setEntity(false);
    windowModel.getCommands().add(// $NON-NLS-1$)
    UICommand.createDefaultOkUiCommand("OnNewTemplate", this));
    // $NON-NLS-1$
    windowModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
    windowModel.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
}
#end_block

#method_before
private void onNewTemplate() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null) {
        cancel();
        return;
    }
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck(this);
    } else {
        model.startProgress();
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel vmModel = (UnitVmModel) userPortalListModel.getWindow();
                    vmModel.getName().getInvalidityReasons().clear();
                    vmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    vmModel.getName().setIsValid(false);
                    vmModel.setIsValid(false);
                    stopProgress(target);
                } else {
                    userPortalListModel.postNameUniqueCheck(userPortalListModel);
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    }
}
#method_after
private void onNewTemplate() {
    UserPortalItemModel selectedItem = getSelectedItem();
    if (selectedItem == null) {
        cancel();
        return;
    }
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck(this);
    } else {
        model.startProgress();
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel vmModel = (UnitVmModel) userPortalListModel.getWindow();
                    vmModel.getName().getInvalidityReasons().clear();
                    vmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    vmModel.getName().setIsValid(false);
                    vmModel.setIsValid(false);
                    stopProgress(target);
                } else {
                    userPortalListModel.postNameUniqueCheck(userPortalListModel);
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    }
}
#end_block

#method_before
private void postNameUniqueCheck(UserPortalListModel userPortalListModel) {
    UnitVmModel model = (UnitVmModel) userPortalListModel.getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) userPortalListModel.getSelectedItem();
    VM vm = (VM) selectedItem.getEntity();
    VM newVm = buildVmOnNewTemplate(model, vm);
    newVm.setMigrationDowntime(vm.getMigrationDowntime());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse(model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions(model.getCopyPermissions().getEntity());
    addVmTemplateParameters.setUpdateRngDevice(true);
    addVmTemplateParameters.setRngDevice(model.getIsRngEnabled().getEntity() ? model.generateRngDevice() : null);
    BuilderExecutor.build(model, addVmTemplateParameters, new UnitToGraphicsDeviceParamsBuilder());
    if (model.getIsSubTemplate().getEntity()) {
        addVmTemplateParameters.setBaseTemplateId(model.getBaseTemplate().getSelectedItem().getId());
        addVmTemplateParameters.setTemplateVersionName(model.getTemplateVersionName().getEntity());
    }
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            stopProgress(result.getState());
            cancel();
        }
    }, this);
}
#method_after
private void postNameUniqueCheck(UserPortalListModel userPortalListModel) {
    UnitVmModel model = (UnitVmModel) userPortalListModel.getWindow();
    UserPortalItemModel selectedItem = userPortalListModel.getSelectedItem();
    VM vm = (VM) selectedItem.getEntity();
    VM newVm = buildVmOnNewTemplate(model, vm);
    newVm.setMigrationDowntime(vm.getMigrationDowntime());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse(model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions(model.getCopyPermissions().getEntity());
    addVmTemplateParameters.setUpdateRngDevice(true);
    addVmTemplateParameters.setRngDevice(model.getIsRngEnabled().getEntity() ? model.generateRngDevice() : null);
    BuilderExecutor.build(model, addVmTemplateParameters, new UnitToGraphicsDeviceParamsBuilder());
    if (model.getIsSubTemplate().getEntity()) {
        addVmTemplateParameters.setBaseTemplateId(model.getBaseTemplate().getSelectedItem().getId());
        addVmTemplateParameters.setTemplateVersionName(model.getTemplateVersionName().getEntity());
    }
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            stopProgress(result.getState());
            cancel();
        }
    }, this);
}
#end_block

#method_before
private void runOnce() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            RunOnceModel runOnceModel = new UserPortalRunOnceModel((VM) result, UserPortalListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    };
    AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
}
#method_after
private void runOnce() {
    UserPortalItemModel selectedItem = getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            RunOnceModel runOnceModel = new UserPortalRunOnceModel((VM) result, UserPortalListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    };
    AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
}
#end_block

#method_before
private void updateActionAvailability() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    getEditCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool());
    getRemoveCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.RemoveVm));
    getRunOnceCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.RunVmOnce));
    getCloneVmCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.CloneVm));
    getChangeCdCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.ChangeDisk));
    getNewTemplateCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.AddVmTemplate));
}
#method_after
private void updateActionAvailability() {
    UserPortalItemModel selectedItem = getSelectedItem();
    getEditCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool());
    getRemoveCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.RemoveVm));
    getRunOnceCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.RunVmOnce));
    getCloneVmCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.CloneVm));
    getChangeCdCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.ChangeDisk));
    getNewTemplateCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.AddVmTemplate));
}
#end_block

#method_before
private void edit() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            editedVm = (VM) result;
            vmInitLoaded(editedVm);
        }
    };
    if (vm.isNextRunConfigurationExists()) {
        AsyncDataProvider.getInstance().getVmNextRunConfiguration(getVmInitQuery, vm.getId());
    } else {
        AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
    }
}
#method_after
private void edit() {
    UserPortalItemModel selectedItem = getSelectedItem();
    if (selectedItem == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            editedVm = (VM) result;
            vmInitLoaded(editedVm);
        }
    };
    if (vm.isNextRunConfigurationExists()) {
        AsyncDataProvider.getInstance().getVmNextRunConfiguration(getVmInitQuery, vm.getId());
    } else {
        AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
    }
}
#end_block

#method_before
private void changeCD() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        return;
    }
    final VM vm = (VM) selectedItem.getEntity();
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    ArrayList<String> defaultImages = new ArrayList<>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    model.getIsoImage().setItems(defaultImages);
    model.getIsoImage().setSelectedItem(Linq.firstOrNull(defaultImages));
    AsyncQuery getImagesQuery = new AsyncQuery();
    getImagesQuery.setModel(this);
    getImagesQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model1, Object result) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) model1;
            AttachCdModel _attachCdModel = (AttachCdModel) userPortalListModel.getWindow();
            List<String> images = (List<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrNull(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    };
    AsyncDataProvider.getInstance().getIrsImageList(getImagesQuery, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnChangeCD", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
private void changeCD() {
    UserPortalItemModel selectedItem = getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        return;
    }
    final VM vm = (VM) selectedItem.getEntity();
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    ArrayList<String> defaultImages = new ArrayList<>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    model.getIsoImage().setItems(defaultImages);
    model.getIsoImage().setSelectedItem(Linq.firstOrNull(defaultImages));
    AsyncQuery getImagesQuery = new AsyncQuery();
    getImagesQuery.setModel(this);
    getImagesQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model1, Object result) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) model1;
            AttachCdModel _attachCdModel = (AttachCdModel) userPortalListModel.getWindow();
            List<String> images = (List<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrNull(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    };
    AsyncDataProvider.getInstance().getIrsImageList(getImagesQuery, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnChangeCD", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onChangeCD() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        cancel();
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    AttachCdModel model = (AttachCdModel) getWindow();
    model.startProgress();
    String isoName = // $NON-NLS-1$
    model.getIsoImage().getSelectedItem().equals(ConsoleModel.getEjectLabel()) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            stopProgress(result.getState());
            cancel();
        }
    }, this);
}
#method_after
private void onChangeCD() {
    UserPortalItemModel selectedItem = getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        cancel();
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    AttachCdModel model = (AttachCdModel) getWindow();
    model.startProgress();
    String isoName = // $NON-NLS-1$
    model.getIsoImage().getSelectedItem().equals(ConsoleModel.getEjectLabel()) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            stopProgress(result.getState());
            cancel();
        }
    }, this);
}
#end_block

#method_before
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (!model.getIsNew() && selectedItem.getEntity() == null) {
        cancel();
        return;
    }
    settempVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem.getEntity()));
    if (!model.validate()) {
        return;
    }
    model.startProgress();
    // Check name uniqueness.
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) target;
            boolean isNameUnique = (Boolean) returnValue;
            String newName = model.getName().getEntity();
            String currentName = userPortalListModel.gettempVm().getName();
            if (!isNameUnique && newName.compareToIgnoreCase(currentName) != 0) {
                UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                unitModel.getName().getInvalidityReasons().clear();
                unitModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                unitModel.getName().setIsValid(false);
                unitModel.setIsValid(false);
                unitModel.setValidTab(TabName.GENERAL_TAB, false);
                stopProgress(target);
            } else {
                String selectedCpu = model.getCustomCpu().getSelectedItem();
                if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuTitle());
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuMessage());
                    confirmModel.setHelpTag(HelpTag.edit_unsupported_cpu);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_unsupported_cpu");
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("postVmNameUniqueCheck", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    userPortalListModel.postVmNameUniqueCheck();
                }
            }
        }
    }), model.getName().getEntity(), model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
}
#method_after
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = getSelectedItem();
    if (!model.getIsNew() && selectedItem.getEntity() == null) {
        cancel();
        return;
    }
    settempVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem.getEntity()));
    if (!model.validate()) {
        return;
    }
    model.startProgress();
    // Check name uniqueness.
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) target;
            boolean isNameUnique = (Boolean) returnValue;
            String newName = model.getName().getEntity();
            String currentName = userPortalListModel.gettempVm().getName();
            if (!isNameUnique && newName.compareToIgnoreCase(currentName) != 0) {
                UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                unitModel.getName().getInvalidityReasons().clear();
                unitModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                unitModel.getName().setIsValid(false);
                unitModel.setIsValid(false);
                unitModel.setValidTab(TabName.GENERAL_TAB, false);
                stopProgress(target);
            } else {
                String selectedCpu = model.getCustomCpu().getSelectedItem();
                if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuTitle());
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuMessage());
                    confirmModel.setHelpTag(HelpTag.edit_unsupported_cpu);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_unsupported_cpu");
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("postVmNameUniqueCheck", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    userPortalListModel.postVmNameUniqueCheck();
                }
            }
        }
    }), model.getName().getEntity(), model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
}
#end_block

#method_before
public void postVmNameUniqueCheck() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else {
        final VM selectedItem = (VM) getSelectedItem().getEntity();
        gettempVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == gettempVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != gettempVm().getNumOfSockets());
                        // currentl only hot plug memory is supported here (no hot unplug)
                        confirmModel.setMemoryPluggable(selectedItem.getMemSizeMb() < gettempVm().getMemSizeMb());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        // $NON-NLS-1$
                        confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm((UserPortalListModel) thisModel, false);
                    }
                }
            }));
        } else {
            updateExistingVm(this, false);
        }
    }
}
#method_after
public void postVmNameUniqueCheck() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else {
        final VM selectedItem = (VM) getSelectedItem().getEntity();
        gettempVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == gettempVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != gettempVm().getNumOfSockets());
                        // currentl only hot plug memory is supported here (no hot unplug)
                        confirmModel.setMemoryPluggable(selectedItem.getMemSizeMb() < gettempVm().getMemSizeMb());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        // $NON-NLS-1$
                        confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm((UserPortalListModel) thisModel, false);
                    }
                }
            }));
        } else {
            updateExistingVm(this, false);
        }
    }
}
#end_block

#method_before
private void updateExistingVm(UserPortalListModel userPortalListModel, final boolean applyCpuChangesLater) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) userPortalListModel.getSelectedItem();
    Guid oldClusterID = ((VM) selectedItem.getEntity()).getClusterId();
    Guid newClusterID = model.getSelectedCluster().getId();
    if (oldClusterID.equals(newClusterID) == false) {
        Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(newClusterID, gettempVm().getId(), model.getCustomCompatibilityVersion().getSelectedItem()), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    VmManagementParametersBase param = getUpdateVmParameters(applyCpuChangesLater);
                    Frontend.getInstance().runAction(VdcActionType.UpdateVm, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, gettempVm().getId()), this);
                } else {
                    getWindow().stopProgress();
                }
            }
        }, this);
    } else {
        VmManagementParametersBase param = getUpdateVmParameters(applyCpuChangesLater);
        Frontend.getInstance().runAction(VdcActionType.UpdateVm, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, gettempVm().getId()), this);
    }
}
#method_after
private void updateExistingVm(UserPortalListModel userPortalListModel, final boolean applyCpuChangesLater) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = userPortalListModel.getSelectedItem();
    Guid oldClusterID = ((VM) selectedItem.getEntity()).getClusterId();
    Guid newClusterID = model.getSelectedCluster().getId();
    if (oldClusterID.equals(newClusterID) == false) {
        Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(newClusterID, gettempVm().getId(), model.getCustomCompatibilityVersion().getSelectedItem()), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    VmManagementParametersBase param = getUpdateVmParameters(applyCpuChangesLater);
                    Frontend.getInstance().runAction(VdcActionType.UpdateVm, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, gettempVm().getId()), this);
                } else {
                    getWindow().stopProgress();
                }
            }
        }, this);
    } else {
        VmManagementParametersBase param = getUpdateVmParameters(applyCpuChangesLater);
        Frontend.getInstance().runAction(VdcActionType.UpdateVm, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, gettempVm().getId()), this);
    }
}
#end_block

#method_before
private void updateDataCenterWithCluster() {
    UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    final VM vm = (VM) selectedItem.getEntity();
    DataCenterWithCluster selectedDataCenterWithCluster = null;
    for (DataCenterWithCluster candidate : model.getDataCenterWithClustersList().getItems()) {
        if (model.getIsNew()) {
            selectedDataCenterWithCluster = candidate;
            break;
        }
        if (candidate.getDataCenter().getId().equals(vm.getStoragePoolId()) && candidate.getCluster().getId().equals(vm.getClusterId())) {
            selectedDataCenterWithCluster = candidate;
            break;
        }
    }
    if (!model.getIsNew() && selectedDataCenterWithCluster == null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, final Object loadedDataCenter) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) model;
                final UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object loadedCluster) {
                        DataCenterWithCluster newItem = new DataCenterWithCluster((StoragePool) loadedDataCenter, (Cluster) loadedCluster);
                        unitModel.getDataCenterWithClustersList().setItems(Arrays.asList(newItem));
                        unitModel.getDataCenterWithClustersList().setSelectedItem(newItem);
                    }
                }), vm.getClusterId());
            }
        };
        AsyncDataProvider.getInstance().getDataCenterById(_asyncQuery, vm.getStoragePoolId());
    } else {
        model.getDataCenterWithClustersList().setSelectedItem(selectedDataCenterWithCluster);
    }
    model.getDataCenterWithClustersList().setIsChangeable(vm.getStatus() == VMStatus.Down);
}
#method_after
private void updateDataCenterWithCluster() {
    UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = getSelectedItem();
    final VM vm = (VM) selectedItem.getEntity();
    DataCenterWithCluster selectedDataCenterWithCluster = null;
    for (DataCenterWithCluster candidate : model.getDataCenterWithClustersList().getItems()) {
        if (model.getIsNew()) {
            selectedDataCenterWithCluster = candidate;
            break;
        }
        if (candidate.getDataCenter().getId().equals(vm.getStoragePoolId()) && candidate.getCluster().getId().equals(vm.getClusterId())) {
            selectedDataCenterWithCluster = candidate;
            break;
        }
    }
    if (!model.getIsNew() && selectedDataCenterWithCluster == null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, final Object loadedDataCenter) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) model;
                final UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object loadedCluster) {
                        DataCenterWithCluster newItem = new DataCenterWithCluster((StoragePool) loadedDataCenter, (Cluster) loadedCluster);
                        unitModel.getDataCenterWithClustersList().setItems(Arrays.asList(newItem));
                        unitModel.getDataCenterWithClustersList().setSelectedItem(newItem);
                    }
                }), vm.getClusterId());
            }
        };
        AsyncDataProvider.getInstance().getDataCenterById(_asyncQuery, vm.getStoragePoolId());
    } else {
        model.getDataCenterWithClustersList().setSelectedItem(selectedDataCenterWithCluster);
    }
    model.getDataCenterWithClustersList().setIsChangeable(vm.getStatus() == VMStatus.Down);
}
#end_block

#method_before
private void vmModel_DefaultHost_ItemsChanged() {
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.getIsNew()) {
        UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
        VM vm = (VM) selectedItem.getEntity();
        VDS host = null;
        for (VDS item : model.getDefaultHost().getItems()) {
            if (vm.getDedicatedVmForVdsList().contains(item.getId())) {
                host = item;
                break;
            }
        }
        if (host == null) {
            model.getIsAutoAssign().setEntity(true);
        } else {
            model.getDefaultHost().setSelectedItems(new ArrayList<>(Arrays.asList(host)));
            model.getIsAutoAssign().setEntity(false);
        }
    }
}
#method_after
private void vmModel_DefaultHost_ItemsChanged() {
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.getIsNew()) {
        UserPortalItemModel selectedItem = getSelectedItem();
        VM vm = (VM) selectedItem.getEntity();
        VDS host = null;
        for (VDS item : model.getDefaultHost().getItems()) {
            if (vm.getDedicatedVmForVdsList().contains(item.getId())) {
                host = item;
                break;
            }
        }
        if (host == null) {
            model.getIsAutoAssign().setEntity(true);
        } else {
            model.getDefaultHost().setSelectedItems(new ArrayList<>(Arrays.asList(host)));
            model.getIsAutoAssign().setEntity(false);
        }
    }
}
#end_block

#method_before
private void vmModel_DisplayProtocol_ItemsChanged() {
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.getIsNew()) {
        UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
        DisplayType displayType = ((VM) selectedItem.getEntity()).getDefaultDisplayType();
        if (model.getDisplayType().getItems().contains(displayType)) {
            model.getDisplayType().setSelectedItem(displayType);
        }
    }
}
#method_after
private void vmModel_DisplayProtocol_ItemsChanged() {
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.getIsNew()) {
        UserPortalItemModel selectedItem = getSelectedItem();
        DisplayType displayType = ((VM) selectedItem.getEntity()).getDefaultDisplayType();
        if (model.getDisplayType().getItems().contains(displayType)) {
            model.getDisplayType().setSelectedItem(displayType);
        }
    }
}
#end_block

#method_before
private void updatePriority(UnitVmModel model) {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    VM vm = (VM) selectedItem.getEntity();
    int roundPriority = AsyncDataProvider.getInstance().getRoundedPriority(vm.getPriority(), cachedMaxPriority);
    EntityModel<Integer> priority = null;
    for (EntityModel<Integer> a : model.getPriority().getItems()) {
        int p = a.getEntity();
        if (p == roundPriority) {
            priority = a;
            break;
        }
    }
    ((UnitVmModel) model.getWindow()).getPriority().setSelectedItem(priority);
}
#method_after
private void updatePriority(UnitVmModel model) {
    UserPortalItemModel selectedItem = getSelectedItem();
    VM vm = (VM) selectedItem.getEntity();
    int roundPriority = AsyncDataProvider.getInstance().getRoundedPriority(vm.getPriority(), cachedMaxPriority);
    EntityModel<Integer> priority = null;
    for (EntityModel<Integer> a : model.getPriority().getItems()) {
        int p = a.getEntity();
        if (p == roundPriority) {
            priority = a;
            break;
        }
    }
    ((UnitVmModel) model.getWindow()).getPriority().setSelectedItem(priority);
}
#end_block

#method_before
private void vmModel_TimeZone_ItemsChanged() {
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.getIsNew()) {
        UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
        VM vm = (VM) selectedItem.getEntity();
        if (!StringHelper.isNullOrEmpty(vm.getTimeZone())) {
            model.getTimeZone().setSelectedItem(Linq.firstOrNull(model.getTimeZone().getItems(), new Linq.TimeZonePredicate(vm.getTimeZone())));
        }
    }
}
#method_after
private void vmModel_TimeZone_ItemsChanged() {
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.getIsNew()) {
        UserPortalItemModel selectedItem = getSelectedItem();
        VM vm = (VM) selectedItem.getEntity();
        if (!StringHelper.isNullOrEmpty(vm.getTimeZone())) {
            model.getTimeZone().setSelectedItem(Linq.firstOrNull(model.getTimeZone().getItems(), new Linq.TimeZonePredicate(vm.getTimeZone())));
        }
    }
}
#end_block

#method_before
public void onSelectHost() {
    MoveHost model = (MoveHost) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.setSelectedHosts(new ArrayList<MoveHostData>());
    for (EntityModel a : Linq.<EntityModel>cast(model.getItems())) {
        if (a.getIsSelected()) {
            model.getSelectedHosts().add((MoveHostData) a);
        }
    }
    Cluster cluster = (Cluster) model.getCluster().getSelectedItem();
    final List<VdcActionParametersBase> parameterList = new ArrayList<>();
    for (MoveHostData hostData : model.getSelectedHosts()) {
        VDS host = hostData.getEntity();
        // Try to change host's cluster as neccessary.
        if (host.getClusterId() != null && !host.getClusterId().equals(cluster.getId())) {
            parameterList.add(new ChangeVDSClusterParameters(cluster.getId(), host.getId()));
        }
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeVDSCluster, parameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            final ClusterGuideModel clusterGuideModel = (ClusterGuideModel) result.getState();
            List<MoveHostData> hosts = ((MoveHost) clusterGuideModel.getWindow()).getSelectedHosts();
            List<VdcReturnValueBase> retVals = result.getReturnValue();
            final List<VdcActionParametersBase> activateVdsParameterList = new ArrayList<>();
            if (retVals != null && hosts.size() == retVals.size()) {
                int i = 0;
                for (MoveHostData selectedHostData : hosts) {
                    VDS selectedHost = selectedHostData.getEntity();
                    if (selectedHost.getStatus() == VDSStatus.PendingApproval && retVals.get(i) != null && retVals.get(i).getSucceeded()) {
                        Frontend.getInstance().runAction(VdcActionType.ApproveVds, new ApproveVdsParameters(selectedHost.getId()));
                    } else if (selectedHostData.getActivateHost()) {
                        activateVdsParameterList.add(new VdsActionParameters(selectedHostData.getEntity().getId()));
                    }
                    i++;
                }
            }
            if (activateVdsParameterList.isEmpty()) {
                clusterGuideModel.getWindow().stopProgress();
                clusterGuideModel.cancel();
                clusterGuideModel.postAction();
            } else {
                final String searchString = getVdsSearchString((MoveHost) clusterGuideModel.getWindow());
                Timer timer = new Timer() {

                    public void run() {
                        checkVdsClusterChangeSucceeded(clusterGuideModel, searchString, parameterList, activateVdsParameterList);
                    }
                };
                timer.schedule(2000);
            }
        }
    }, this);
}
#method_after
public void onSelectHost() {
    MoveHost model = (MoveHost) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.setSelectedHosts(new ArrayList<MoveHostData>());
    for (EntityModel a : Linq.<EntityModel>cast(model.getItems())) {
        if (a.getIsSelected()) {
            model.getSelectedHosts().add((MoveHostData) a);
        }
    }
    Cluster cluster = model.getCluster().getSelectedItem();
    final List<VdcActionParametersBase> parameterList = new ArrayList<>();
    for (MoveHostData hostData : model.getSelectedHosts()) {
        VDS host = hostData.getEntity();
        // Try to change host's cluster as neccessary.
        if (host.getClusterId() != null && !host.getClusterId().equals(cluster.getId())) {
            parameterList.add(new ChangeVDSClusterParameters(cluster.getId(), host.getId()));
        }
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeVDSCluster, parameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            final ClusterGuideModel clusterGuideModel = (ClusterGuideModel) result.getState();
            List<MoveHostData> hosts = ((MoveHost) clusterGuideModel.getWindow()).getSelectedHosts();
            List<VdcReturnValueBase> retVals = result.getReturnValue();
            final List<VdcActionParametersBase> activateVdsParameterList = new ArrayList<>();
            if (retVals != null && hosts.size() == retVals.size()) {
                int i = 0;
                for (MoveHostData selectedHostData : hosts) {
                    VDS selectedHost = selectedHostData.getEntity();
                    if (selectedHost.getStatus() == VDSStatus.PendingApproval && retVals.get(i) != null && retVals.get(i).getSucceeded()) {
                        Frontend.getInstance().runAction(VdcActionType.ApproveVds, new ApproveVdsParameters(selectedHost.getId()));
                    } else if (selectedHostData.getActivateHost()) {
                        activateVdsParameterList.add(new VdsActionParameters(selectedHostData.getEntity().getId()));
                    }
                    i++;
                }
            }
            if (activateVdsParameterList.isEmpty()) {
                clusterGuideModel.getWindow().stopProgress();
                clusterGuideModel.cancel();
                clusterGuideModel.postAction();
            } else {
                final String searchString = getVdsSearchString((MoveHost) clusterGuideModel.getWindow());
                Timer timer = new Timer() {

                    public void run() {
                        checkVdsClusterChangeSucceeded(clusterGuideModel, searchString, parameterList, activateVdsParameterList);
                    }
                };
                timer.schedule(2000);
            }
        }
    }, this);
}
#end_block

#method_before
private void processVmsWithDevicesChange() {
    // Handle VM devices were changed (for 3.1 cluster and above)
    if (!VmDeviceCommonUtils.isOldClusterVersion(vdsManager.getGroupCompatibilityVersion())) {
        // get the new info from VDSM in one call, and then update them all
        if (!vmsWithChangedDevices.isEmpty()) {
            ArrayList<String> vmsToUpdate = new ArrayList<>(vmsWithChangedDevices.size());
            for (Pair<VM, VmInternalData> pair : vmsWithChangedDevices) {
                Guid vmId = pair.getFirst().getId();
                // this ensure the vmManager lock is taken
                if (vmDynamicToSave.containsKey(vmId)) {
                    vmDynamicToSave.get(vmId).setHash(pair.getSecond().getVmDynamic().getHash());
                    vmsToUpdate.add(vmId.toString());
                } else {
                    log.warn("VM '{}' not in changed list, skipping devices update.", vmId);
                }
            }
            updateVmDevices(vmsToUpdate);
        }
    }
}
#method_after
private void processVmsWithDevicesChange() {
    // Handle VM devices were changed (for 3.1 cluster and above)
    if (!VmDeviceCommonUtils.isOldClusterVersion(vdsManager.getGroupCompatibilityVersion())) {
        // get the new info from VDSM in one call, and then update them all
        if (!vmsWithChangedDevices.isEmpty()) {
            ArrayList<String> vmsToUpdate = new ArrayList<>(vmsWithChangedDevices.size());
            for (Pair<VM, VmInternalData> pair : vmsWithChangedDevices) {
                Guid vmId = pair.getFirst().getId();
                // update only if the vm marked to change, otherwise it might have skipped because data invalidated
                // this ensure the vmManager lock is taken
                VmAnalyzer vmAnalyzer = vmAnalyzers.stream().filter(analyzer -> vmId.equals(analyzer.getVdsmVm().getVmDynamic().getId())).findFirst().orElse(null);
                if (vmAnalyzer != null && vmAnalyzer.getVmDynamicToSave() != null) {
                    vmAnalyzer.getVmDynamicToSave().setHash(pair.getSecond().getVmDynamic().getHash());
                    vmsToUpdate.add(vmId.toString());
                } else {
                    log.warn("VM '{}' not in changed list, skipping devices update.", vmId);
                }
            }
            updateVmDevices(vmsToUpdate);
        }
    }
}
#end_block

#method_before
private void flush() {
    getDbFacade().getVmDynamicDao().updateAllInBatch(vmDynamicToSave.values());
    saveVmStatistics();
    saveVmInterfaceStatistics();
    getDbFacade().getDiskImageDynamicDao().updateAllDiskImageDynamicWithDiskIdByVmId(vmDiskImageDynamicToSave);
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    saveVmJobsToDb();
}
#method_after
private void flush() {
    saveVmDynamic();
    saveVmStatistics();
    saveVmInterfaceStatistics();
    getDbFacade().getDiskImageDynamicDao().updateAllDiskImageDynamicWithDiskIdByVmId(vmDiskImageDynamicToSave);
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    saveVmJobsToDb();
}
#end_block

#method_before
protected void updateTemplate() {
    final DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getModel().getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    // Filter according to system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        final StorageDomain storage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        AsyncDataProvider.getInstance().getTemplateListByDataCenter(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target1, Object returnValue1) {
                NewTemplateVmModelBehavior behavior1 = NewTemplateVmModelBehavior.this;
                AsyncDataProvider.getInstance().getTemplateListByStorage(new AsyncQuery(new Object[] { behavior1, returnValue1 }, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target2, Object returnValue2) {
                        Object[] array2 = (Object[]) target2;
                        NewTemplateVmModelBehavior behavior2 = (NewTemplateVmModelBehavior) array2[0];
                        ArrayList<VmTemplate> templatesByDataCenter = (ArrayList<VmTemplate>) array2[1];
                        ArrayList<VmTemplate> templatesByStorage = (ArrayList<VmTemplate>) returnValue2;
                        VmTemplate blankTemplate = Linq.firstOrNull(templatesByDataCenter, new Linq.IdPredicate<>(Guid.Empty));
                        if (blankTemplate != null) {
                            templatesByStorage.add(0, blankTemplate);
                        }
                        ArrayList<VmTemplate> templateList = AsyncDataProvider.getInstance().filterTemplatesByArchitecture(templatesByStorage, dataCenterWithCluster.getCluster().getArchitecture());
                        behavior2.postInitTemplate(templateList);
                    }
                }), storage.getId());
            }
        }), dataCenter.getId());
    } else {
        AsyncDataProvider.getInstance().getTemplateListByDataCenter(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                NewTemplateVmModelBehavior behavior = NewTemplateVmModelBehavior.this;
                ArrayList<VmTemplate> templates = (ArrayList<VmTemplate>) returnValue;
                behavior.postInitTemplate(AsyncDataProvider.getInstance().filterTemplatesByArchitecture(templates, dataCenterWithCluster.getCluster().getArchitecture()));
            }
        }), dataCenter.getId());
    }
}
#method_after
protected void updateTemplate() {
    final DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    // Filter according to system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        final StorageDomain storage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        AsyncDataProvider.getInstance().getTemplateListByDataCenter(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target1, Object returnValue1) {
                NewTemplateVmModelBehavior behavior1 = NewTemplateVmModelBehavior.this;
                AsyncDataProvider.getInstance().getTemplateListByStorage(new AsyncQuery(new Object[] { behavior1, returnValue1 }, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target2, Object returnValue2) {
                        Object[] array2 = (Object[]) target2;
                        NewTemplateVmModelBehavior behavior2 = (NewTemplateVmModelBehavior) array2[0];
                        ArrayList<VmTemplate> templatesByDataCenter = (ArrayList<VmTemplate>) array2[1];
                        ArrayList<VmTemplate> templatesByStorage = (ArrayList<VmTemplate>) returnValue2;
                        VmTemplate blankTemplate = Linq.firstOrNull(templatesByDataCenter, new Linq.IdPredicate<>(Guid.Empty));
                        if (blankTemplate != null) {
                            templatesByStorage.add(0, blankTemplate);
                        }
                        ArrayList<VmTemplate> templateList = AsyncDataProvider.getInstance().filterTemplatesByArchitecture(templatesByStorage, dataCenterWithCluster.getCluster().getArchitecture());
                        behavior2.postInitTemplate(templateList);
                    }
                }), storage.getId());
            }
        }), dataCenter.getId());
    } else {
        AsyncDataProvider.getInstance().getTemplateListByDataCenter(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                NewTemplateVmModelBehavior behavior = NewTemplateVmModelBehavior.this;
                ArrayList<VmTemplate> templates = (ArrayList<VmTemplate>) returnValue;
                behavior.postInitTemplate(AsyncDataProvider.getInstance().filterTemplatesByArchitecture(templates, dataCenterWithCluster.getCluster().getArchitecture()));
            }
        }), dataCenter.getId());
    }
}
#end_block

#method_before
private List<VdcActionParametersBase> buildImportVmFromExternalProviderParameters() {
    List<VdcActionParametersBase> prms = new ArrayList<>();
    for (Object item : getItems()) {
        ImportVmData importVmData = (ImportVmData) item;
        VM vm = importVmData.getVm();
        ImportVmFromExternalProviderParameters prm = new ImportVmFromExternalProviderParameters(vm, getStorage().getSelectedItem().getId(), getStoragePool().getId(), ((Cluster) getCluster().getSelectedItem()).getId());
        prm.setUrl(url);
        prm.setUsername(username);
        prm.setPassword(password);
        prm.setProxyHostId(proxyHostId);
        prm.setVirtioIsoName(getIso().getIsChangable() ? getIso().getSelectedItem() : null);
        prm.setExternalName(importVmData.getName());
        if (getClusterQuota().getSelectedItem() != null && getClusterQuota().getIsAvailable()) {
            prm.setQuotaId(((Quota) getClusterQuota().getSelectedItem()).getId());
        }
        CpuProfile cpuProfile = getCpuProfiles().getSelectedItem();
        if (cpuProfile != null) {
            prm.setCpuProfileId(cpuProfile.getId());
        }
        prm.setForceOverride(true);
        prm.setCopyCollapse((Boolean) importVmData.getCollapseSnapshots().getEntity());
        for (Map.Entry<Guid, Disk> entry : vm.getDiskMap().entrySet()) {
            DiskImage disk = (DiskImage) entry.getValue();
            ImportDiskData importDiskData = getDiskImportData(disk.getDiskAlias());
            disk.setVolumeType(getAllocation().getSelectedItem());
            disk.setvolumeFormat(AsyncDataProvider.getInstance().getDiskVolumeFormat(disk.getVolumeType(), getStorage().getSelectedItem().getStorageType()));
            if (getDiskImportData(disk.getDiskAlias()).getSelectedQuota() != null) {
                disk.setQuotaId(importDiskData.getSelectedQuota().getId());
            }
        }
        updateNetworkInterfacesForVm(vm);
        if (importVmData.isExistsInSystem() || (Boolean) importVmData.getClone().getEntity()) {
            prm.setImportAsNewEntity(true);
            prm.setCopyCollapse(true);
        }
        prms.add(prm);
    }
    return prms;
}
#method_after
private List<VdcActionParametersBase> buildImportVmFromExternalProviderParameters() {
    List<VdcActionParametersBase> prms = new ArrayList<>();
    for (Object item : getItems()) {
        ImportVmData importVmData = (ImportVmData) item;
        VM vm = importVmData.getVm();
        ImportVmFromExternalProviderParameters prm = new ImportVmFromExternalProviderParameters(vm, getStorage().getSelectedItem().getId(), getStoragePool().getId(), getCluster().getSelectedItem().getId());
        prm.setUrl(url);
        prm.setUsername(username);
        prm.setPassword(password);
        prm.setProxyHostId(proxyHostId);
        prm.setVirtioIsoName(getIso().getIsChangable() ? getIso().getSelectedItem() : null);
        prm.setExternalName(importVmData.getName());
        if (getClusterQuota().getSelectedItem() != null && getClusterQuota().getIsAvailable()) {
            prm.setQuotaId(getClusterQuota().getSelectedItem().getId());
        }
        CpuProfile cpuProfile = getCpuProfiles().getSelectedItem();
        if (cpuProfile != null) {
            prm.setCpuProfileId(cpuProfile.getId());
        }
        prm.setForceOverride(true);
        prm.setCopyCollapse(importVmData.getCollapseSnapshots().getEntity());
        for (Map.Entry<Guid, Disk> entry : vm.getDiskMap().entrySet()) {
            DiskImage disk = (DiskImage) entry.getValue();
            ImportDiskData importDiskData = getDiskImportData(disk.getDiskAlias());
            disk.setVolumeType(getAllocation().getSelectedItem());
            disk.setvolumeFormat(AsyncDataProvider.getInstance().getDiskVolumeFormat(disk.getVolumeType(), getStorage().getSelectedItem().getStorageType()));
            if (getDiskImportData(disk.getDiskAlias()).getSelectedQuota() != null) {
                disk.setQuotaId(importDiskData.getSelectedQuota().getId());
            }
        }
        updateNetworkInterfacesForVm(vm);
        if (importVmData.isExistsInSystem() || importVmData.getClone().getEntity()) {
            prm.setImportAsNewEntity(true);
            prm.setCopyCollapse(true);
        }
        prms.add(prm);
    }
    return prms;
}
#end_block

#method_before
public void guide() {
    ClusterGuideModel model = new ClusterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newClusterGuideMeTitle());
    model.setHelpTag(HelpTag.new_cluster___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_cluster_-_guide_me");
    if (getGuideContext() == null) {
        Cluster cluster = getSelectedItem();
        setGuideContext(cluster.getId());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel<Void> clusterListModel = (ClusterListModel<Void>) target;
            ClusterGuideModel model = (ClusterGuideModel) clusterListModel.getWindow();
            model.setEntity((Cluster) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", clusterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
public void guide() {
    ClusterGuideModel model = new ClusterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newClusterGuideMeTitle());
    model.setHelpTag(HelpTag.new_cluster___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_cluster_-_guide_me");
    if (getGuideContext() == null) {
        Cluster cluster = getSelectedItem();
        setGuideContext(cluster.getId());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel<Void> clusterListModel = (ClusterListModel<Void>) target;
            ClusterGuideModel model = (ClusterGuideModel) clusterListModel.getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", clusterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
private void addHosts(final MultipleHostsModel hostsModel) {
    hostsModel.startProgress();
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<>();
    for (Object object : hostsModel.getHosts().getItems()) {
        HostDetailModel hostDetailModel = (HostDetailModel) ((EntityModel) object).getEntity();
        VDS host = new VDS();
        host.setVdsName(hostDetailModel.getName());
        host.setHostName(hostDetailModel.getAddress());
        host.setSshKeyFingerprint(hostDetailModel.getFingerprint());
        host.setPort(54321);
        // TODO: get from UI, till then using defaults.
        host.setSshPort(22);
        // $NON-NLS-1$
        host.setSshUsername("root");
        host.setClusterId(hostsModel.getClusterModel().getClusterId());
        host.setPmEnabled(false);
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setPassword(hostDetailModel.getPassword());
        parameters.setOverrideFirewall(hostsModel.isConfigureFirewall());
        parametersList.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AddVds, parametersList, true, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            hostsModel.stopProgress();
            boolean isAllValidatePassed = true;
            for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                isAllValidatePassed = isAllValidatePassed && returnValueBase.isValid();
                if (!isAllValidatePassed) {
                    break;
                }
            }
            if (isAllValidatePassed) {
                cancel();
            }
        }
    }, null);
}
#method_after
private void addHosts(final MultipleHostsModel hostsModel) {
    hostsModel.startProgress();
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<>();
    for (Object object : hostsModel.getHosts().getItems()) {
        HostDetailModel hostDetailModel = (HostDetailModel) ((EntityModel) object).getEntity();
        VDS host = new VDS();
        host.setVdsName(hostDetailModel.getName());
        host.setHostName(hostDetailModel.getAddress());
        host.setSshKeyFingerprint(hostDetailModel.getFingerprint());
        host.setPort(54321);
        // TODO: get from UI, till then using defaults.
        host.setSshPort(22);
        // $NON-NLS-1$
        host.setSshUsername("root");
        host.setClusterId(hostsModel.getClusterModel().getClusterId());
        host.setPmEnabled(false);
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setPassword(hostDetailModel.getPassword());
        parameters.setOverrideFirewall(hostsModel.isConfigureFirewall());
        parametersList.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AddVds, parametersList, true, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            hostsModel.stopProgress();
            boolean isAllValidatePassed = true;
            for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                isAllValidatePassed = returnValueBase.isValid();
                if (!isAllValidatePassed) {
                    break;
                }
            }
            if (isAllValidatePassed) {
                cancel();
            }
        }
    }, null);
}
#end_block

#method_before
private List<VM> getVmsForDiskId() {
    if (listVms == null) {
        listVms = getVmDao().getVmsListForDisk((Guid) getParameters().getDiskId(), true);
    }
    return listVms;
}
#method_after
private List<VM> getVmsForDiskId() {
    if (listVms == null) {
        listVms = getVmDao().getVmsListForDisk(getParameters().getDiskId(), true);
    }
    return listVms;
}
#end_block

#method_before
private DiskImagesValidator createDiskImagesValidator(DiskImage disk) {
    return new DiskImagesValidator(Arrays.asList(disk));
}
#method_after
private DiskImagesValidator createDiskImagesValidator(DiskImage disk) {
    return new DiskImagesValidator(Collections.singletonList(disk));
}
#end_block

#method_before
private boolean canRemoveVmImageDisk() {
    if (!listVms.isEmpty()) {
        Guid storagePoolId = listVms.get(0).getStoragePoolId();
        StoragePool sp = getStoragePoolDao().get(storagePoolId);
        if (!validate(new StoragePoolValidator(sp).isUp())) {
            return false;
        }
        List<DiskImage> diskList = ImagesHandler.filterImageDisks(Arrays.asList(getDisk()), true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskList);
        if (!validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    for (VM vm : listVms) {
        if (!validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId())) || !validate(snapshotsValidator.vmNotInPreview(vm.getId()))) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean canRemoveVmImageDisk() {
    if (!listVms.isEmpty()) {
        Guid storagePoolId = listVms.get(0).getStoragePoolId();
        StoragePool sp = getStoragePoolDao().get(storagePoolId);
        if (!validate(new StoragePoolValidator(sp).isUp())) {
            return false;
        }
        List<DiskImage> diskList = ImagesHandler.filterImageDisks(Collections.singletonList(getDisk()), true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskList);
        if (!validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    for (VM vm : listVms) {
        if (!validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId())) || !validate(snapshotsValidator.vmNotInPreview(vm.getId()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void drawKnob() {
    // Abort if not attached
    if (!isAttached()) {
        return;
    }
    // Move the knob to the correct position
    Element knobElement = knobImage.getElement();
    int lineWidth = lineElement.getOffsetWidth();
    int knobWidth = knobElement.getOffsetWidth();
    int knobLeftOffset = (int) (lineLeftOffset + ((int) getKnobPercent() * lineWidth) - (knobWidth / 2));
    knobLeftOffset = Math.min(knobLeftOffset, lineLeftOffset + lineWidth - (knobWidth / 2) - 1);
    // $NON-NLS-1$ //$NON-NLS-2$
    DOM.setStyleAttribute(knobElement, "left", knobLeftOffset + "px");
}
#method_after
private void drawKnob() {
    // Abort if not attached
    if (!isAttached()) {
        return;
    }
    // Move the knob to the correct position
    Element knobElement = knobImage.getElement();
    int lineWidth = lineElement.getOffsetWidth();
    int knobWidth = knobElement.getOffsetWidth();
    int knobLeftOffset = lineLeftOffset + ((int) getKnobPercent() * lineWidth) - (knobWidth / 2);
    knobLeftOffset = Math.min(knobLeftOffset, lineLeftOffset + lineWidth - (knobWidth / 2) - 1);
    // $NON-NLS-1$ //$NON-NLS-2$
    DOM.setStyleAttribute(knobElement, "left", knobLeftOffset + "px");
}
#end_block

#method_before
private void updateAlerts() {
    setHasAnyAlert(false);
    setHasUpgradeAlert(false);
    setHasManualFenceAlert(false);
    setHasNoPowerManagementAlert(false);
    setHasReinstallAlertNonResponsive(false);
    setHasReinstallAlertInstallFailed(false);
    setHasReinstallAlertMaintenance(false);
    setHasNICsAlert(false);
    // Check the network alert presense.
    setHasNICsAlert(getEntity().getNetConfigDirty() == null ? false : getEntity().getNetConfigDirty());
    // Check manual fence alert presense.
    if (getEntity().getStatus() == VDSStatus.NonResponsive && !getEntity().isPmEnabled() && ((getEntity().getVmActive() == null ? 0 : getEntity().getVmActive()) > 0 || getEntity().getSpmStatus() == VdsSpmStatus.SPM)) {
        setHasManualFenceAlert(true);
    } else if (!getEntity().isPmEnabled()) {
        setHasNoPowerManagementAlert(true);
    }
    // Check the reinstall alert presence.
    if (getEntity().getStatus() == VDSStatus.NonResponsive) {
        setHasReinstallAlertNonResponsive(true);
    } else if (getEntity().getStatus() == VDSStatus.InstallFailed) {
        setHasReinstallAlertInstallFailed(true);
    } else if (getEntity().getStatus() == VDSStatus.Maintenance) {
        setHasReinstallAlertMaintenance(true);
    }
    setNonOperationalReasonEntity(getEntity().getNonOperationalReason() == NonOperationalReason.NONE ? null : (NonOperationalReason) getEntity().getNonOperationalReason());
    updateActionAvailability();
    setHasAnyAlert();
}
#method_after
private void updateAlerts() {
    setHasAnyAlert(false);
    setHasUpgradeAlert(false);
    setHasManualFenceAlert(false);
    setHasNoPowerManagementAlert(false);
    setHasReinstallAlertNonResponsive(false);
    setHasReinstallAlertInstallFailed(false);
    setHasReinstallAlertMaintenance(false);
    setHasNICsAlert(false);
    // Check the network alert presense.
    setHasNICsAlert(getEntity().getNetConfigDirty() == null ? false : getEntity().getNetConfigDirty());
    // Check manual fence alert presense.
    if (getEntity().getStatus() == VDSStatus.NonResponsive && !getEntity().isPmEnabled() && ((getEntity().getVmActive() == null ? 0 : getEntity().getVmActive()) > 0 || getEntity().getSpmStatus() == VdsSpmStatus.SPM)) {
        setHasManualFenceAlert(true);
    } else if (!getEntity().isPmEnabled()) {
        setHasNoPowerManagementAlert(true);
    }
    // Check the reinstall alert presence.
    if (getEntity().getStatus() == VDSStatus.NonResponsive) {
        setHasReinstallAlertNonResponsive(true);
    } else if (getEntity().getStatus() == VDSStatus.InstallFailed) {
        setHasReinstallAlertInstallFailed(true);
    } else if (getEntity().getStatus() == VDSStatus.Maintenance) {
        setHasReinstallAlertMaintenance(true);
    }
    setNonOperationalReasonEntity(getEntity().getNonOperationalReason() == NonOperationalReason.NONE ? null : getEntity().getNonOperationalReason());
    updateActionAvailability();
    setHasAnyAlert();
}
#end_block

#method_before
private void printBoolean(Object arg) throws IOException {
    String s;
    if (arg != null) {
        s = arg instanceof Boolean ? ((Boolean) arg).toString() : Boolean.toString(true);
    } else {
        s = Boolean.toString(false);
    }
    print(s);
}
#method_after
private void printBoolean(Object arg) throws IOException {
    String s;
    if (arg != null) {
        s = arg instanceof Boolean ? arg.toString() : Boolean.toString(true);
    } else {
        s = Boolean.toString(false);
    }
    print(s);
}
#end_block

#method_before
private void printCharacter(Object arg) throws IOException {
    if (arg == null) {
        print("null");
        return;
    }
    String s = null;
    if (arg instanceof Character) {
        s = ((Character) arg).toString();
    } else if (arg instanceof Byte) {
        byte i = ((Byte) arg).byteValue();
        if (Character.isValidCodePoint(i)) {
            s = new String(Character.toChars(i));
        } else {
            throw new IllegalArgumentException("invalid code  point " + i);
        }
    } else if (arg instanceof Short) {
        short i = ((Short) arg).shortValue();
        if (Character.isValidCodePoint(i)) {
            s = new String(Character.toChars(i));
        } else {
            throw new IllegalArgumentException("invalid code  point " + i);
        }
    } else if (arg instanceof Integer) {
        int i = ((Integer) arg).intValue();
        if (Character.isValidCodePoint(i)) {
            s = new String(Character.toChars(i));
        } else {
            throw new IllegalArgumentException("invalid code  point " + i);
        }
    } else {
        failConversion(c, arg);
    }
    print(s);
}
#method_after
private void printCharacter(Object arg) throws IOException {
    if (arg == null) {
        print("null");
        return;
    }
    String s = null;
    if (arg instanceof Character) {
        s = arg.toString();
    } else if (arg instanceof Byte) {
        byte i = ((Byte) arg).byteValue();
        if (Character.isValidCodePoint(i)) {
            s = new String(Character.toChars(i));
        } else {
            throw new IllegalArgumentException("invalid code  point " + i);
        }
    } else if (arg instanceof Short) {
        short i = ((Short) arg).shortValue();
        if (Character.isValidCodePoint(i)) {
            s = new String(Character.toChars(i));
        } else {
            throw new IllegalArgumentException("invalid code  point " + i);
        }
    } else if (arg instanceof Integer) {
        int i = ((Integer) arg).intValue();
        if (Character.isValidCodePoint(i)) {
            s = new String(Character.toChars(i));
        } else {
            throw new IllegalArgumentException("invalid code  point " + i);
        }
    } else {
        failConversion(c, arg);
    }
    print(s);
}
#end_block

#method_before
@Ignore
@Override
protected ProfileInstanceTypeEditor createWidget(VnicInstanceType value) {
    VnicProfileView profile = (VnicProfileView) value.getSelectedItem();
    ProfileInstanceTypeEditor item = new ProfileInstanceTypeEditor();
    item.edit(value);
    item.setElementId(elementId);
    // small workaround due to UiCommonEditorVisitor changing null selected value
    value.setSelectedItem(profile);
    return item;
}
#method_after
@Ignore
@Override
protected ProfileInstanceTypeEditor createWidget(VnicInstanceType value) {
    VnicProfileView profile = value.getSelectedItem();
    ProfileInstanceTypeEditor item = new ProfileInstanceTypeEditor();
    item.edit(value);
    item.setElementId(elementId);
    // small workaround due to UiCommonEditorVisitor changing null selected value
    value.setSelectedItem(profile);
    return item;
}
#end_block

#method_before
private void saveLocalStorage(TaskContext context) {
    this.context = context;
    StorageModel model = (StorageModel) getWindow();
    VDS host = model.getHost().getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    LocalStorageModel localModel = (LocalStorageModel) storageModel;
    path = (String) localModel.getPath().getEntity();
    storageDomain = new StorageDomainStatic();
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
            if (storages != null && storages.size() > 0) {
                String storageName = storages.get(0).getStorageName();
                onFinish(dataCenterGuideModel.context, false, dataCenterGuideModel.storageModel, ConstantsManager.getInstance().getMessages().createOperationFailedDcGuideMsg(storageName));
            } else {
                dataCenterGuideModel.saveNewLocalStorage();
            }
        }
    }), host.getStoragePoolId(), path);
}
#method_after
private void saveLocalStorage(TaskContext context) {
    this.context = context;
    StorageModel model = (StorageModel) getWindow();
    VDS host = model.getHost().getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    LocalStorageModel localModel = (LocalStorageModel) storageModel;
    path = localModel.getPath().getEntity();
    storageDomain = new StorageDomainStatic();
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) target;
            ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
            if (storages != null && storages.size() > 0) {
                String storageName = storages.get(0).getStorageName();
                onFinish(dataCenterGuideModel.context, false, dataCenterGuideModel.storageModel, ConstantsManager.getInstance().getMessages().createOperationFailedDcGuideMsg(storageName));
            } else {
                dataCenterGuideModel.saveNewLocalStorage();
            }
        }
    }), host.getStoragePoolId(), path);
}
#end_block

#method_before
public void saveNewNfsStorage() {
    StorageModel model = (StorageModel) getWindow();
    NfsStorageModel nfsModel = (NfsStorageModel) model.getCurrentStorageItem();
    VDS host = model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections tempVar = new StorageServerConnections();
    tempVar.setConnection(path);
    tempVar.setStorageType(nfsModel.getType());
    connection = tempVar;
    ArrayList<VdcActionType> actionTypes = new ArrayList<>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(VdcActionType.AddNFSStorageDomain);
    actionTypes.add(VdcActionType.DisconnectStorageServerConnection);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId()));
    StorageDomainManagementParameter tempVar2 = new StorageDomainManagementParameter(storageDomain);
    tempVar2.setVdsId(host.getId());
    parameters.add(tempVar2);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId()));
    IFrontendActionAsyncCallback callback1 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            dataCenterGuideModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
        }
    };
    IFrontendActionAsyncCallback callback2 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            dataCenterGuideModel.storageId = (Guid) vdcReturnValueBase.getActionReturnValue();
        }
    };
    IFrontendActionAsyncCallback callback3 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
            StorageModel storageModel = (StorageModel) dataCenterGuideModel.getWindow();
            // Attach storage to data center as neccessary.
            StoragePool dataCenter = storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                dataCenterGuideModel.attachStorageToDataCenter(dataCenterGuideModel.storageId, dataCenter.getId());
            }
            dataCenterGuideModel.onFinish(dataCenterGuideModel.context, true, dataCenterGuideModel.storageModel);
        }
    };
    IFrontendActionAsyncCallback failureCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
            dataCenterGuideModel.cleanConnection(dataCenterGuideModel.connection, dataCenterGuideModel.hostId);
            dataCenterGuideModel.onFinish(dataCenterGuideModel.context, false, dataCenterGuideModel.storageModel);
        }
    };
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, new ArrayList<>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2, callback3 })), failureCallback, this);
}
#method_after
public void saveNewNfsStorage() {
    StorageModel model = (StorageModel) getWindow();
    NfsStorageModel nfsModel = (NfsStorageModel) model.getCurrentStorageItem();
    VDS host = model.getHost().getSelectedItem();
    hostId = host.getId();
    // Create storage connection.
    StorageServerConnections tempVar = new StorageServerConnections();
    tempVar.setConnection(path);
    tempVar.setStorageType(nfsModel.getType());
    connection = tempVar;
    ArrayList<VdcActionType> actionTypes = new ArrayList<>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    actionTypes.add(VdcActionType.AddStorageServerConnection);
    actionTypes.add(VdcActionType.AddNFSStorageDomain);
    actionTypes.add(VdcActionType.DisconnectStorageServerConnection);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId()));
    StorageDomainManagementParameter tempVar2 = new StorageDomainManagementParameter(storageDomain);
    tempVar2.setVdsId(host.getId());
    parameters.add(tempVar2);
    parameters.add(new StorageServerConnectionParametersBase(connection, host.getId()));
    IFrontendActionAsyncCallback callback1 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            dataCenterGuideModel.storageDomain.setStorage((String) vdcReturnValueBase.getActionReturnValue());
        }
    };
    IFrontendActionAsyncCallback callback2 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
            VdcReturnValueBase vdcReturnValueBase = result.getReturnValue();
            dataCenterGuideModel.storageId = vdcReturnValueBase.getActionReturnValue();
        }
    };
    IFrontendActionAsyncCallback callback3 = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
            StorageModel storageModel = (StorageModel) dataCenterGuideModel.getWindow();
            // Attach storage to data center as neccessary.
            StoragePool dataCenter = storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                dataCenterGuideModel.attachStorageToDataCenter(dataCenterGuideModel.storageId, dataCenter.getId());
            }
            dataCenterGuideModel.onFinish(dataCenterGuideModel.context, true, dataCenterGuideModel.storageModel);
        }
    };
    IFrontendActionAsyncCallback failureCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
            dataCenterGuideModel.cleanConnection(dataCenterGuideModel.connection, dataCenterGuideModel.hostId);
            dataCenterGuideModel.onFinish(dataCenterGuideModel.context, false, dataCenterGuideModel.storageModel);
        }
    };
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, new ArrayList<>(Arrays.asList(new IFrontendActionAsyncCallback[] { callback1, callback2, callback3 })), failureCallback, this);
}
#end_block

#method_before
private void onSaveSanStorage() {
    ConfirmationModel confirmationModel = (ConfirmationModel) getConfirmWindow();
    if (confirmationModel != null && !confirmationModel.validate()) {
        return;
    }
    cancelConfirm();
    getWindow().startProgress();
    StorageModel model = (StorageModel) getWindow();
    SanStorageModel sanModel = (SanStorageModel) model.getCurrentStorageItem();
    VDS host = model.getHost().getSelectedItem();
    boolean force = sanModel.isForce();
    ArrayList<String> lunIds = new ArrayList<>();
    for (LunModel lun : sanModel.getAddedLuns()) {
        lunIds.add(lun.getLunId());
    }
    AddSANStorageDomainParameters params = new AddSANStorageDomainParameters(storageDomain);
    params.setVdsId(host.getId());
    params.setLunIds(lunIds);
    params.setForce(force);
    Frontend.getInstance().runAction(VdcActionType.AddSANStorageDomain, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
            StorageModel storageModel = (StorageModel) dataCenterGuideModel.getWindow();
            StoragePool dataCenter = storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                VdcReturnValueBase returnValue = result.getReturnValue();
                Guid storageId = (Guid) returnValue.getActionReturnValue();
                dataCenterGuideModel.attachStorageToDataCenter(storageId, dataCenter.getId());
            }
            dataCenterGuideModel.onFinish(dataCenterGuideModel.context, true, dataCenterGuideModel.storageModel);
        }
    }, this);
}
#method_after
private void onSaveSanStorage() {
    ConfirmationModel confirmationModel = (ConfirmationModel) getConfirmWindow();
    if (confirmationModel != null && !confirmationModel.validate()) {
        return;
    }
    cancelConfirm();
    getWindow().startProgress();
    StorageModel model = (StorageModel) getWindow();
    SanStorageModel sanModel = (SanStorageModel) model.getCurrentStorageItem();
    VDS host = model.getHost().getSelectedItem();
    boolean force = sanModel.isForce();
    ArrayList<String> lunIds = new ArrayList<>();
    for (LunModel lun : sanModel.getAddedLuns()) {
        lunIds.add(lun.getLunId());
    }
    AddSANStorageDomainParameters params = new AddSANStorageDomainParameters(storageDomain);
    params.setVdsId(host.getId());
    params.setLunIds(lunIds);
    params.setForce(force);
    Frontend.getInstance().runAction(VdcActionType.AddSANStorageDomain, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
            StorageModel storageModel = (StorageModel) dataCenterGuideModel.getWindow();
            StoragePool dataCenter = storageModel.getDataCenter().getSelectedItem();
            if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                VdcReturnValueBase returnValue = result.getReturnValue();
                Guid storageId = returnValue.getActionReturnValue();
                dataCenterGuideModel.attachStorageToDataCenter(storageId, dataCenter.getId());
            }
            dataCenterGuideModel.onFinish(dataCenterGuideModel.context, true, dataCenterGuideModel.storageModel);
        }
    }, this);
}
#end_block

#method_before
public void onSelectHost() {
    MoveHost model = (MoveHost) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.setSelectedHosts(new ArrayList<MoveHostData>());
    for (EntityModel a : Linq.<EntityModel>cast(model.getItems())) {
        if (a.getIsSelected()) {
            model.getSelectedHosts().add((MoveHostData) a);
        }
    }
    Cluster cluster = (Cluster) model.getCluster().getSelectedItem();
    final List<VdcActionParametersBase> parameterList = new ArrayList<>();
    for (MoveHostData hostData : model.getSelectedHosts()) {
        VDS host = hostData.getEntity();
        // Try to change host's cluster as neccessary.
        if (host.getClusterId() != null && !host.getClusterId().equals(cluster.getId())) {
            parameterList.add(new ChangeVDSClusterParameters(cluster.getId(), host.getId()));
        }
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeVDSCluster, parameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            final DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
            List<MoveHostData> hosts = ((MoveHost) dataCenterGuideModel.getWindow()).getSelectedHosts();
            List<VdcReturnValueBase> retVals = result.getReturnValue();
            final List<VdcActionParametersBase> activateVdsParameterList = new ArrayList<>();
            if (retVals != null && hosts.size() == retVals.size()) {
                int i = 0;
                for (MoveHostData selectedHostData : hosts) {
                    VDS selectedHost = selectedHostData.getEntity();
                    if (selectedHost.getStatus() == VDSStatus.PendingApproval && retVals.get(i) != null && retVals.get(i).getSucceeded()) {
                        Frontend.getInstance().runAction(VdcActionType.ApproveVds, new ApproveVdsParameters(selectedHost.getId()), null, this);
                    } else if (selectedHostData.getActivateHost()) {
                        activateVdsParameterList.add(new VdsActionParameters(selectedHostData.getEntity().getId()));
                    }
                    i++;
                }
            }
            if (activateVdsParameterList.isEmpty()) {
                dataCenterGuideModel.getWindow().stopProgress();
                dataCenterGuideModel.cancel();
                dataCenterGuideModel.postAction();
            } else {
                final String searchString = getVdsSearchString((MoveHost) dataCenterGuideModel.getWindow());
                Timer timer = new Timer() {

                    public void run() {
                        checkVdsClusterChangeSucceeded(dataCenterGuideModel, searchString, parameterList, activateVdsParameterList);
                    }
                };
                timer.schedule(2000);
            }
        }
    }, this);
}
#method_after
public void onSelectHost() {
    MoveHost model = (MoveHost) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.setSelectedHosts(new ArrayList<MoveHostData>());
    for (EntityModel a : Linq.<EntityModel>cast(model.getItems())) {
        if (a.getIsSelected()) {
            model.getSelectedHosts().add((MoveHostData) a);
        }
    }
    Cluster cluster = model.getCluster().getSelectedItem();
    final List<VdcActionParametersBase> parameterList = new ArrayList<>();
    for (MoveHostData hostData : model.getSelectedHosts()) {
        VDS host = hostData.getEntity();
        // Try to change host's cluster as neccessary.
        if (host.getClusterId() != null && !host.getClusterId().equals(cluster.getId())) {
            parameterList.add(new ChangeVDSClusterParameters(cluster.getId(), host.getId()));
        }
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeVDSCluster, parameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            final DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
            List<MoveHostData> hosts = ((MoveHost) dataCenterGuideModel.getWindow()).getSelectedHosts();
            List<VdcReturnValueBase> retVals = result.getReturnValue();
            final List<VdcActionParametersBase> activateVdsParameterList = new ArrayList<>();
            if (retVals != null && hosts.size() == retVals.size()) {
                int i = 0;
                for (MoveHostData selectedHostData : hosts) {
                    VDS selectedHost = selectedHostData.getEntity();
                    if (selectedHost.getStatus() == VDSStatus.PendingApproval && retVals.get(i) != null && retVals.get(i).getSucceeded()) {
                        Frontend.getInstance().runAction(VdcActionType.ApproveVds, new ApproveVdsParameters(selectedHost.getId()), null, this);
                    } else if (selectedHostData.getActivateHost()) {
                        activateVdsParameterList.add(new VdsActionParameters(selectedHostData.getEntity().getId()));
                    }
                    i++;
                }
            }
            if (activateVdsParameterList.isEmpty()) {
                dataCenterGuideModel.getWindow().stopProgress();
                dataCenterGuideModel.cancel();
                dataCenterGuideModel.postAction();
            } else {
                final String searchString = getVdsSearchString((MoveHost) dataCenterGuideModel.getWindow());
                Timer timer = new Timer() {

                    public void run() {
                        checkVdsClusterChangeSucceeded(dataCenterGuideModel, searchString, parameterList, activateVdsParameterList);
                    }
                };
                timer.schedule(2000);
            }
        }
    }, this);
}
#end_block

#method_before
private List<GlusterVolumeSnapshotEntity> prepareVolumeSnapshotsList(Guid clusterId, Map<String, Object> snapshots) {
    List<GlusterVolumeSnapshotEntity> newSnapshotsList = new ArrayList<>();
    for (Map.Entry<String, Object> entry : snapshots.entrySet()) {
        String volumeName = entry.getKey();
        Map<String, Object> snapshotInfo = (Map<String, Object>) entry.getValue();
        Object[] volumeSnapshots = (Object[]) snapshotInfo.get(SNAPSHOTS);
        GlusterVolumeEntity volumeEntity = getGlusterVolumeDao().getByName(clusterId, volumeName);
        for (Object snapshot : volumeSnapshots) {
            Map<String, Object> individualSnapshot = (Map<String, Object>) snapshot;
            GlusterVolumeSnapshotEntity newSnapshot = new GlusterVolumeSnapshotEntity();
            newSnapshot.setClusterId(clusterId);
            newSnapshot.setVolumeId(volumeEntity.getId());
            newSnapshot.setSnapshotId(Guid.createGuidFromString((String) individualSnapshot.get(SNAPSHOT_ID)));
            newSnapshot.setSnapshotName((String) individualSnapshot.get(NAME));
            newSnapshot.setDescription((String) individualSnapshot.get(DESCRIPTION));
            newSnapshot.setStatus(GlusterSnapshotStatus.from((String) individualSnapshot.get(SNAP_VOLUME_STATUS)));
            try {
                Map<String, Object> createTimeDetail = (Map<String, Object>) individualSnapshot.get(CREATETIME);
                long millis = ((Integer) createTimeDetail.get(EPOCH_TIME)).intValue() * 1000L;
                Date createDate = new Date(millis);
                // Convert to UTC
                DateFormat format = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");
                format.setTimeZone(TimeZone.getTimeZone("Etc/UTC"));
                String formattedCreateDate = format.format(createDate);
                newSnapshot.setCreatedAt(new Date(formattedCreateDate));
            } catch (Exception e) {
                log.info("Could not populate creation time for snapshot '{}' of volume '{}' on cluster '{}': {}", (String) snapshotInfo.get(NAME), volumeEntity.getName(), clusterId, e.getMessage());
                log.debug("Exception", e);
            }
            newSnapshotsList.add(newSnapshot);
        }
    }
    return newSnapshotsList;
}
#method_after
private List<GlusterVolumeSnapshotEntity> prepareVolumeSnapshotsList(Guid clusterId, Map<String, Object> snapshots) {
    List<GlusterVolumeSnapshotEntity> newSnapshotsList = new ArrayList<>();
    for (Map.Entry<String, Object> entry : snapshots.entrySet()) {
        String volumeName = entry.getKey();
        Map<String, Object> snapshotInfo = (Map<String, Object>) entry.getValue();
        Object[] volumeSnapshots = (Object[]) snapshotInfo.get(SNAPSHOTS);
        GlusterVolumeEntity volumeEntity = getGlusterVolumeDao().getByName(clusterId, volumeName);
        for (Object snapshot : volumeSnapshots) {
            Map<String, Object> individualSnapshot = (Map<String, Object>) snapshot;
            GlusterVolumeSnapshotEntity newSnapshot = new GlusterVolumeSnapshotEntity();
            newSnapshot.setClusterId(clusterId);
            newSnapshot.setVolumeId(volumeEntity.getId());
            newSnapshot.setSnapshotId(Guid.createGuidFromString((String) individualSnapshot.get(SNAPSHOT_ID)));
            newSnapshot.setSnapshotName((String) individualSnapshot.get(NAME));
            newSnapshot.setDescription((String) individualSnapshot.get(DESCRIPTION));
            newSnapshot.setStatus(GlusterSnapshotStatus.from((String) individualSnapshot.get(SNAP_VOLUME_STATUS)));
            try {
                Map<String, Object> createTimeDetail = (Map<String, Object>) individualSnapshot.get(CREATETIME);
                long millis = (Integer) createTimeDetail.get(EPOCH_TIME) * 1000L;
                Date createDate = new Date(millis);
                // Convert to UTC
                DateFormat format = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");
                format.setTimeZone(TimeZone.getTimeZone("Etc/UTC"));
                String formattedCreateDate = format.format(createDate);
                newSnapshot.setCreatedAt(new Date(formattedCreateDate));
            } catch (Exception e) {
                log.info("Could not populate creation time for snapshot '{}' of volume '{}' on cluster '{}': {}", snapshotInfo.get(NAME), volumeEntity.getName(), clusterId, e.getMessage());
                log.debug("Exception", e);
            }
            newSnapshotsList.add(newSnapshot);
        }
    }
    return newSnapshotsList;
}
#end_block

#method_before
public static Version getMinVersionByClusters(List<Cluster> source) {
    Version minVersion = source != null && source.size() > 0 ? source.get(0).getCompatibilityVersion() : null;
    if (minVersion != null) {
        for (Cluster cluster : source) {
            minVersion = cluster.getCompatibilityVersion().compareTo(minVersion) < 0 ? (Version) cluster.getCompatibilityVersion() : minVersion;
        }
    }
    return minVersion;
}
#method_after
public static Version getMinVersionByClusters(List<Cluster> source) {
    Version minVersion = source != null && source.size() > 0 ? source.get(0).getCompatibilityVersion() : null;
    if (minVersion != null) {
        for (Cluster cluster : source) {
            minVersion = cluster.getCompatibilityVersion().compareTo(minVersion) < 0 ? cluster.getCompatibilityVersion() : minVersion;
        }
    }
    return minVersion;
}
#end_block

#method_before
public double getDiskSize() {
    if (diskSize == 0) {
        for (Disk disk : getDiskMap().values()) {
            if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
                diskSize += ((DiskImage) disk).getSize() / Double.valueOf(1024 * 1024 * 1024);
            }
        }
    }
    return diskSize;
}
#method_after
public double getDiskSize() {
    if (diskSize == 0) {
        for (Disk disk : getDiskMap().values()) {
            if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
                diskSize += disk.getSize() / Double.valueOf(1024 * 1024 * 1024);
            }
        }
    }
    return diskSize;
}
#end_block

#method_before
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // update only if vdsm actually provides some value, otherwise engine has more information
    if (vm.getCurrentCd() != null) {
        setCurrentCd(vm.getCurrentCd());
    }
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    getDynamicData().setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setUtcDiff(vm.getUtcDiff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setExitReason(vm.getExitReason());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
    setGuestCpuCount(vm.getGuestCpuCount());
    getGraphicsInfos().putAll(vm.getGraphicsInfos());
    getDynamicData().setGuestMemoryBuffered(vm.getGuestMemoryBuffered());
    getDynamicData().setGuestMemoryCached(vm.getGuestMemoryCached());
    getDynamicData().setGuestMemoryFree(vm.getGuestMemoryFree());
    setGuestOsArch(vm.getGuestOsArch());
    setGuestOsCodename(vm.getGuestOsCodename());
    setGuestOsDistribution(vm.getGuestOsDistribution());
    setGuestOsKernelVersion(vm.getGuestOsKernelVersion());
    setGuestOsType(vm.getGuestOsType());
    setGuestOsVersion(vm.getGuestOsVersion());
    setGuestOsTimezoneName(vm.getGuestOsTimezoneName());
    setGuestOsTimezoneOffset(vm.getGuestOsTimezoneOffset());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#method_after
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // update only if vdsm actually provides some value, otherwise engine has more information
    if (vm.getCurrentCd() != null) {
        setCurrentCd(vm.getCurrentCd());
    }
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    getDynamicData().setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setUtcDiff(vm.getUtcDiff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setExitReason(vm.getExitReason());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
    setGuestCpuCount(vm.getGuestCpuCount());
    setGraphicsInfos(new HashMap<>(vm.getGraphicsInfos()));
    getDynamicData().setGuestMemoryBuffered(vm.getGuestMemoryBuffered());
    getDynamicData().setGuestMemoryCached(vm.getGuestMemoryCached());
    getDynamicData().setGuestMemoryFree(vm.getGuestMemoryFree());
    setGuestOsArch(vm.getGuestOsArch());
    setGuestOsCodename(vm.getGuestOsCodename());
    setGuestOsDistribution(vm.getGuestOsDistribution());
    setGuestOsKernelVersion(vm.getGuestOsKernelVersion());
    setGuestOsType(vm.getGuestOsType());
    setGuestOsVersion(vm.getGuestOsVersion());
    setGuestOsTimezoneName(vm.getGuestOsTimezoneName());
    setGuestOsTimezoneOffset(vm.getGuestOsTimezoneOffset());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#end_block

#method_before
public void onSave() {
    RoleModel model = (RoleModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    role = commandType != CommandType.Edit ? new Role() : getSelectedItem();
    role.setType(model.getIsAdminRole().getEntity() ? RoleType.ADMIN : RoleType.USER);
    if (!model.validate()) {
        return;
    }
    // if (!DataProvider.IsRoleNameUnique(name) && name.compareToIgnoreCase(role.getname()) != 0)
    // {
    // model.getName().setIsValid(false);
    // model.getName().getInvalidityReasons().add("Name must be unique.");
    // return;
    // }
    role.setName(model.getName().getEntity());
    role.setDescription(model.getDescription().getEntity());
    ArrayList<ActionGroup> actions = new ArrayList<>();
    HashMap<ActionGroup, ActionGroup> actionDistinctSet = new HashMap<>();
    for (SelectionTreeNodeModel sm : model.getPermissionGroupModels()) {
        for (SelectionTreeNodeModel smChild : sm.getChildren()) {
            if (smChild.getIsSelectedNullable() == null || smChild.getIsSelectedNullable()) {
                for (SelectionTreeNodeModel smGrandChild : smChild.getChildren()) {
                    if (smGrandChild.getIsSelectedNullable()) {
                        ActionGroup actionGroup = ActionGroup.valueOf(smGrandChild.getTitle());
                        if (actionDistinctSet.containsKey(actionGroup)) {
                            continue;
                        }
                        actionDistinctSet.put(actionGroup, actionGroup);
                        actions.add(actionGroup);
                    }
                }
            }
        }
    }
    VdcReturnValueBase returnValue;
    model.startProgress();
    if (commandType != CommandType.Edit) {
        // Add a new role.
        RoleWithActionGroupsParameters tempVar = new RoleWithActionGroupsParameters();
        tempVar.setRole(role);
        tempVar.setActionGroups(actions);
        Frontend.getInstance().runAction(VdcActionType.AddRoleWithActionGroups, tempVar, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                RoleListModel localModel = (RoleListModel) result.getState();
                localModel.postOnSaveNew(result.getReturnValue());
            }
        }, this);
    } else {
        detachActionGroup = Linq.except(publicAttachedActions, actions);
        attachActionGroup = Linq.except(actions, publicAttachedActions);
        Frontend.getInstance().runAction(VdcActionType.UpdateRole, new RolesOperationsParameters(role), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                RoleListModel roleListModel = (RoleListModel) result.getState();
                VdcReturnValueBase retVal = result.getReturnValue();
                if (retVal != null && retVal.getSucceeded()) {
                    if (roleListModel.detachActionGroup.size() > 0) {
                        ActionGroupsToRoleParameter tempVar2 = new ActionGroupsToRoleParameter();
                        tempVar2.setActionGroups(roleListModel.detachActionGroup);
                        tempVar2.setRoleId(roleListModel.role.getId());
                        Frontend.getInstance().runAction(VdcActionType.DetachActionGroupsFromRole, tempVar2);
                    }
                    if (roleListModel.attachActionGroup.size() > 0) {
                        ActionGroupsToRoleParameter tempVar3 = new ActionGroupsToRoleParameter();
                        tempVar3.setActionGroups(roleListModel.attachActionGroup);
                        tempVar3.setRoleId(roleListModel.role.getId());
                        Frontend.getInstance().runAction(VdcActionType.AttachActionGroupsToRole, tempVar3);
                    }
                    roleListModel.getWindow().stopProgress();
                    roleListModel.cancel();
                } else {
                    roleListModel.getWindow().stopProgress();
                }
            }
        }, this);
    }
}
#method_after
public void onSave() {
    RoleModel model = (RoleModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    role = commandType != CommandType.Edit ? new Role() : getSelectedItem();
    role.setType(model.getIsAdminRole().getEntity() ? RoleType.ADMIN : RoleType.USER);
    if (!model.validate()) {
        return;
    }
    role.setName(model.getName().getEntity());
    role.setDescription(model.getDescription().getEntity());
    ArrayList<ActionGroup> actions = new ArrayList<>();
    HashMap<ActionGroup, ActionGroup> actionDistinctSet = new HashMap<>();
    for (SelectionTreeNodeModel sm : model.getPermissionGroupModels()) {
        for (SelectionTreeNodeModel smChild : sm.getChildren()) {
            if (smChild.getIsSelectedNullable() == null || smChild.getIsSelectedNullable()) {
                for (SelectionTreeNodeModel smGrandChild : smChild.getChildren()) {
                    if (smGrandChild.getIsSelectedNullable()) {
                        ActionGroup actionGroup = ActionGroup.valueOf(smGrandChild.getTitle());
                        if (actionDistinctSet.containsKey(actionGroup)) {
                            continue;
                        }
                        actionDistinctSet.put(actionGroup, actionGroup);
                        actions.add(actionGroup);
                    }
                }
            }
        }
    }
    VdcReturnValueBase returnValue;
    model.startProgress();
    if (commandType != CommandType.Edit) {
        // Add a new role.
        RoleWithActionGroupsParameters tempVar = new RoleWithActionGroupsParameters();
        tempVar.setRole(role);
        tempVar.setActionGroups(actions);
        Frontend.getInstance().runAction(VdcActionType.AddRoleWithActionGroups, tempVar, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                RoleListModel localModel = (RoleListModel) result.getState();
                localModel.postOnSaveNew(result.getReturnValue());
            }
        }, this);
    } else {
        detachActionGroup = Linq.except(publicAttachedActions, actions);
        attachActionGroup = Linq.except(actions, publicAttachedActions);
        Frontend.getInstance().runAction(VdcActionType.UpdateRole, new RolesOperationsParameters(role), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                RoleListModel roleListModel = (RoleListModel) result.getState();
                VdcReturnValueBase retVal = result.getReturnValue();
                if (retVal != null && retVal.getSucceeded()) {
                    if (roleListModel.detachActionGroup.size() > 0) {
                        ActionGroupsToRoleParameter tempVar2 = new ActionGroupsToRoleParameter();
                        tempVar2.setActionGroups(roleListModel.detachActionGroup);
                        tempVar2.setRoleId(roleListModel.role.getId());
                        Frontend.getInstance().runAction(VdcActionType.DetachActionGroupsFromRole, tempVar2);
                    }
                    if (roleListModel.attachActionGroup.size() > 0) {
                        ActionGroupsToRoleParameter tempVar3 = new ActionGroupsToRoleParameter();
                        tempVar3.setActionGroups(roleListModel.attachActionGroup);
                        tempVar3.setRoleId(roleListModel.role.getId());
                        Frontend.getInstance().runAction(VdcActionType.AttachActionGroupsToRole, tempVar3);
                    }
                    roleListModel.getWindow().stopProgress();
                    roleListModel.cancel();
                } else {
                    roleListModel.getWindow().stopProgress();
                }
            }
        }, this);
    }
}
#end_block

#method_before
private Set<Guid> getVolumeChain() {
    List<String> vmIds = new ArrayList<>();
    vmIds.add(getParameters().getVmId().toString());
    VDS vds = getVdsDao().get(getParameters().getVdsId());
    Map[] vms = (Map[]) runVdsCommand(VDSCommandType.FullList, new FullListVDSCommandParameters(vds, vmIds)).getReturnValue();
    if (vms == null || vms.length == 0) {
        log.error("Failed to retrieve VM information");
        return null;
    }
    Map vm = (Map) vms[0];
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received incomplete VM information");
        return null;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    if (!vmId.equals(getParameters().getVmId())) {
        log.error("Invalid VM returned when querying status: expected '{}', got '{}'", getParameters().getVmId(), vmId);
        return null;
    }
    Set<Guid> images = new HashSet<>();
    DiskImage activeDiskImage = getParameters().getActiveImage();
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (VdsProperties.Disk.equals(device.get(VdsProperties.Type)) && activeDiskImage.getId().equals(Guid.createGuidFromString((String) device.get(VdsProperties.ImageId)))) {
            Object[] volumeChain = (Object[]) device.get("volumeChain");
            for (Object v : volumeChain) {
                Map<String, Object> volume = (Map<String, Object>) v;
                images.add(Guid.createGuidFromString((String) volume.get(VdsProperties.VolumeId)));
            }
            break;
        }
    }
    return images;
}
#method_after
private Set<Guid> getVolumeChain() {
    List<String> vmIds = new ArrayList<>();
    vmIds.add(getParameters().getVmId().toString());
    VDS vds = getVdsDao().get(getParameters().getVdsId());
    Map[] vms = (Map[]) runVdsCommand(VDSCommandType.FullList, new FullListVDSCommandParameters(vds, vmIds)).getReturnValue();
    if (vms == null || vms.length == 0) {
        log.error("Failed to retrieve VM information");
        return null;
    }
    Map vm = vms[0];
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received incomplete VM information");
        return null;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    if (!vmId.equals(getParameters().getVmId())) {
        log.error("Invalid VM returned when querying status: expected '{}', got '{}'", getParameters().getVmId(), vmId);
        return null;
    }
    Set<Guid> images = new HashSet<>();
    DiskImage activeDiskImage = getParameters().getActiveImage();
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (VdsProperties.Disk.equals(device.get(VdsProperties.Type)) && activeDiskImage.getId().equals(Guid.createGuidFromString((String) device.get(VdsProperties.ImageId)))) {
            Object[] volumeChain = (Object[]) device.get("volumeChain");
            for (Object v : volumeChain) {
                Map<String, Object> volume = (Map<String, Object>) v;
                images.add(Guid.createGuidFromString((String) volume.get(VdsProperties.VolumeId)));
            }
            break;
        }
    }
    return images;
}
#end_block

#method_before
@Override
protected void syncSearch() {
    super.syncSearch();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            ResourcesModel resourcesModel = (ResourcesModel) model;
            final ArrayList<VM> list = (ArrayList<VM>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            // Update calculated properties.
            int runningVMs = 0;
            int definedCPUs = 0;
            int usedCPUs = 0;
            int definedMemory = 0;
            int usedMemory = 0;
            long totalDisksSize = 0;
            long totalSnapshotsSize = 0;
            int numOfSnapshots = 0;
            for (VM vm : list) {
                definedCPUs += vm.getNumOfCpus();
                definedMemory += vm.getVmMemSizeMb();
                if (vm.isRunning()) {
                    runningVMs++;
                    usedCPUs += vm.getNumOfCpus();
                    usedMemory += vm.getVmMemSizeMb();
                }
                if (vm.getDiskList() != null) {
                    for (DiskImage disk : vm.getDiskList()) {
                        totalDisksSize += disk.getSizeInGigabytes();
                        totalSnapshotsSize += (long) disk.getActualDiskWithSnapshotsSize();
                        numOfSnapshots += disk.getSnapshots().size();
                    }
                }
            }
            getDefinedVMs().setEntity(list.size());
            getRunningVMs().setEntity(runningVMs);
            getRunningVMsPercentage().setEntity(list.isEmpty() ? 0 : runningVMs * 100 / list.size());
            getDefinedCPUs().setEntity(definedCPUs);
            getUsedCPUs().setEntity(usedCPUs);
            getUsedCPUsPercentage().setEntity(usedCPUs * 100 / definedCPUs);
            getDefinedMemory().setEntity(sizeParser(definedMemory));
            getUsedMemory().setEntity(sizeParser(usedMemory));
            getUsedMemoryPercentage().setEntity(usedMemory * 100 / definedMemory);
            // $NON-NLS-1$ //$NON-NLS-2$
            getTotalDisksSize().setEntity(totalDisksSize >= 1 ? totalDisksSize + "GB" : "<1GB");
            // $NON-NLS-1$ //$NON-NLS-2$
            getTotalSnapshotsSize().setEntity(totalSnapshotsSize >= 1 ? totalSnapshotsSize + "GB" : "<1GB");
            getNumOfSnapshots().setEntity(numOfSnapshots);
            Collections.sort(list, COMPARATOR);
            resourcesModel.setItems(list);
            // async Query for quota
            AsyncQuery _asyncQueryForQuota = new AsyncQuery();
            _asyncQueryForQuota.setModel(this);
            VdcQueryParametersBase parameters = new VdcQueryParametersBase();
            parameters.setRefresh(getIsQueryFirstTime());
            Frontend.getInstance().runQuery(VdcQueryType.GetQuotasConsumptionForCurrentUser, parameters, new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object ReturnValue) {
                    Map<Guid, QuotaUsagePerUser> quotaPerUserUsageEntityMap = (HashMap<Guid, QuotaUsagePerUser>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                    // calculate personal consumption
                    for (VM vm : list) {
                        // if vm is running and have a quota
                        if (vm.getStatus() != VMStatus.Down && vm.getStatus() != VMStatus.Suspended && vm.getStatus() != VMStatus.ImageIllegal && vm.getStatus() != VMStatus.ImageLocked && vm.getStatus() != VMStatus.PoweringDown && vm.getQuotaId() != null) {
                            QuotaUsagePerUser quotaUsagePerUser = quotaPerUserUsageEntityMap.get(vm.getQuotaId());
                            // add the vm cpu and mem to the user quota consumption
                            if (quotaUsagePerUser != null) {
                                quotaUsagePerUser.setMemoryUsageForUser(quotaUsagePerUser.getMemoryUsageForUser() + vm.getMemSizeMb());
                                quotaUsagePerUser.setVcpuUsageForUser(quotaUsagePerUser.getVcpuUsageForUser() + vm.getCpuPerSocket() * vm.getNumOfSockets());
                            }
                        }
                        // for each image of each disk of the vm - if it has a quota
                        for (DiskImage image : vm.getDiskList()) {
                            QuotaUsagePerUser quotaUsagePerUser = quotaPerUserUsageEntityMap.get(image.getQuotaId());
                            double imageSize = image.getImage().isActive() ? image.getSizeInGigabytes() : image.getActualSize();
                            // add the disk size to the user storage consumption
                            if (quotaUsagePerUser != null) {
                                quotaUsagePerUser.setStorageUsageForUser(quotaUsagePerUser.getStorageUsageForUser() + imageSize);
                            }
                        }
                    }
                    getUsedQuotaPercentage().setEntity(new ArrayList<>(quotaPerUserUsageEntityMap.values()));
                }
            }));
        }
    };
    // Items property will contain list of VMs.
    GetUserVmsByUserIdAndGroupsParameters getUserVmsByUserIdAndGroupsParameters = new GetUserVmsByUserIdAndGroupsParameters();
    getUserVmsByUserIdAndGroupsParameters.setIncludeDiskData(true);
    getUserVmsByUserIdAndGroupsParameters.setRefresh(getIsQueryFirstTime());
    Frontend.getInstance().runQuery(VdcQueryType.GetUserVmsByUserIdAndGroups, getUserVmsByUserIdAndGroupsParameters, _asyncQuery);
}
#method_after
@Override
protected void syncSearch() {
    super.syncSearch();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            ResourcesModel resourcesModel = (ResourcesModel) model;
            final ArrayList<VM> list = ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            // Update calculated properties.
            int runningVMs = 0;
            int definedCPUs = 0;
            int usedCPUs = 0;
            int definedMemory = 0;
            int usedMemory = 0;
            long totalDisksSize = 0;
            long totalSnapshotsSize = 0;
            int numOfSnapshots = 0;
            for (VM vm : list) {
                definedCPUs += vm.getNumOfCpus();
                definedMemory += vm.getVmMemSizeMb();
                if (vm.isRunning()) {
                    runningVMs++;
                    usedCPUs += vm.getNumOfCpus();
                    usedMemory += vm.getVmMemSizeMb();
                }
                if (vm.getDiskList() != null) {
                    for (DiskImage disk : vm.getDiskList()) {
                        totalDisksSize += disk.getSizeInGigabytes();
                        totalSnapshotsSize += (long) disk.getActualDiskWithSnapshotsSize();
                        numOfSnapshots += disk.getSnapshots().size();
                    }
                }
            }
            getDefinedVMs().setEntity(list.size());
            getRunningVMs().setEntity(runningVMs);
            getRunningVMsPercentage().setEntity(list.isEmpty() ? 0 : runningVMs * 100 / list.size());
            getDefinedCPUs().setEntity(definedCPUs);
            getUsedCPUs().setEntity(usedCPUs);
            getUsedCPUsPercentage().setEntity(usedCPUs * 100 / definedCPUs);
            getDefinedMemory().setEntity(sizeParser(definedMemory));
            getUsedMemory().setEntity(sizeParser(usedMemory));
            getUsedMemoryPercentage().setEntity(usedMemory * 100 / definedMemory);
            // $NON-NLS-1$ //$NON-NLS-2$
            getTotalDisksSize().setEntity(totalDisksSize >= 1 ? totalDisksSize + "GB" : "<1GB");
            // $NON-NLS-1$ //$NON-NLS-2$
            getTotalSnapshotsSize().setEntity(totalSnapshotsSize >= 1 ? totalSnapshotsSize + "GB" : "<1GB");
            getNumOfSnapshots().setEntity(numOfSnapshots);
            Collections.sort(list, COMPARATOR);
            resourcesModel.setItems(list);
            // async Query for quota
            AsyncQuery _asyncQueryForQuota = new AsyncQuery();
            _asyncQueryForQuota.setModel(this);
            VdcQueryParametersBase parameters = new VdcQueryParametersBase();
            parameters.setRefresh(getIsQueryFirstTime());
            Frontend.getInstance().runQuery(VdcQueryType.GetQuotasConsumptionForCurrentUser, parameters, new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object ReturnValue) {
                    Map<Guid, QuotaUsagePerUser> quotaPerUserUsageEntityMap = (HashMap<Guid, QuotaUsagePerUser>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                    // calculate personal consumption
                    for (VM vm : list) {
                        // if vm is running and have a quota
                        if (vm.getStatus() != VMStatus.Down && vm.getStatus() != VMStatus.Suspended && vm.getStatus() != VMStatus.ImageIllegal && vm.getStatus() != VMStatus.ImageLocked && vm.getStatus() != VMStatus.PoweringDown && vm.getQuotaId() != null) {
                            QuotaUsagePerUser quotaUsagePerUser = quotaPerUserUsageEntityMap.get(vm.getQuotaId());
                            // add the vm cpu and mem to the user quota consumption
                            if (quotaUsagePerUser != null) {
                                quotaUsagePerUser.setMemoryUsageForUser(quotaUsagePerUser.getMemoryUsageForUser() + vm.getMemSizeMb());
                                quotaUsagePerUser.setVcpuUsageForUser(quotaUsagePerUser.getVcpuUsageForUser() + vm.getCpuPerSocket() * vm.getNumOfSockets());
                            }
                        }
                        // for each image of each disk of the vm - if it has a quota
                        for (DiskImage image : vm.getDiskList()) {
                            QuotaUsagePerUser quotaUsagePerUser = quotaPerUserUsageEntityMap.get(image.getQuotaId());
                            double imageSize = image.getImage().isActive() ? image.getSizeInGigabytes() : image.getActualSize();
                            // add the disk size to the user storage consumption
                            if (quotaUsagePerUser != null) {
                                quotaUsagePerUser.setStorageUsageForUser(quotaUsagePerUser.getStorageUsageForUser() + imageSize);
                            }
                        }
                    }
                    getUsedQuotaPercentage().setEntity(new ArrayList<>(quotaPerUserUsageEntityMap.values()));
                }
            }));
        }
    };
    // Items property will contain list of VMs.
    GetUserVmsByUserIdAndGroupsParameters getUserVmsByUserIdAndGroupsParameters = new GetUserVmsByUserIdAndGroupsParameters();
    getUserVmsByUserIdAndGroupsParameters.setIncludeDiskData(true);
    getUserVmsByUserIdAndGroupsParameters.setRefresh(getIsQueryFirstTime());
    Frontend.getInstance().runQuery(VdcQueryType.GetUserVmsByUserIdAndGroups, getUserVmsByUserIdAndGroupsParameters, _asyncQuery);
}
#end_block

#method_before
public void proceedCommandExecution() {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList();
    Guid currentChildId = getCurrentChildId();
    VdcReturnValueBase vdcReturnValue = null;
    if (currentChildId != null) {
        switch(CommandCoordinatorUtil.getCommandStatus(currentChildId)) {
            case ACTIVE:
            case NOT_STARTED:
                log.info("Waiting on Live Merge command step '{}' to complete", getParameters().getCommandStep());
                return;
            case ENDED_SUCCESSFULLY:
            case SUCCEEDED:
                CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(currentChildId);
                if (cmdEntity.isCallbackEnabled() && !cmdEntity.isCallbackNotified()) {
                    log.info("Waiting on Live Merge command step '{}' to finalize", getParameters().getCommandStep());
                    return;
                }
                vdcReturnValue = CommandCoordinatorUtil.getCommandReturnValue(currentChildId);
                if (vdcReturnValue != null && vdcReturnValue.getSucceeded()) {
                    log.debug("Child command '{}' succeeded", getParameters().getCommandStep());
                    getParameters().setCommandStep(getParameters().getNextCommandStep());
                    break;
                } else {
                    log.error("Child command '{}' failed: {}", getParameters().getCommandStep(), vdcReturnValue != null ? vdcReturnValue.getExecuteFailedMessages() : "null return value");
                    setCommandStatus(CommandStatus.FAILED);
                    return;
                }
            case FAILED:
            case ENDED_WITH_FAILURE:
            case FAILED_RESTARTED:
                if (getParameters().getCommandStep() == RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE) {
                    // It's possible that the image was destroyed already if this is retry of Live
                    // Merge for the given volume.  Proceed to check if the image is present.
                    log.warn("Child command '{}' failed, proceeding to verify", getParameters().getCommandStep());
                    getParameters().setCommandStep(getParameters().getNextCommandStep());
                    break;
                }
                log.error("Failed child command status for step '{}'", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
            case UNKNOWN:
                log.error("Unknown child command status for step '{}'", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
        }
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(VdcActionType.MergeExtend, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(VdcActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (vdcReturnValue != null) {
                getParameters().setMergeStatusReturnValue((MergeStatusReturnValue) vdcReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = new Pair<>(VdcActionType.DestroyImage, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE_CHECK);
            break;
        case DESTROY_IMAGE_CHECK:
            nextCommand = new Pair<>(VdcActionType.DestroyImageCheck, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        CommandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
    // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
    }
}
#method_after
public void proceedCommandExecution() {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList();
    Guid currentChildId = getCurrentChildId();
    VdcReturnValueBase vdcReturnValue = null;
    if (currentChildId != null) {
        switch(CommandCoordinatorUtil.getCommandStatus(currentChildId)) {
            case ACTIVE:
            case NOT_STARTED:
                log.info("Waiting on Live Merge command step '{}' to complete", getParameters().getCommandStep());
                return;
            case ENDED_SUCCESSFULLY:
            case SUCCEEDED:
                CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(currentChildId);
                if (cmdEntity.isCallbackEnabled() && !cmdEntity.isCallbackNotified()) {
                    log.info("Waiting on Live Merge command step '{}' to finalize", getParameters().getCommandStep());
                    return;
                }
                vdcReturnValue = CommandCoordinatorUtil.getCommandReturnValue(currentChildId);
                if (vdcReturnValue != null && vdcReturnValue.getSucceeded()) {
                    log.debug("Child command '{}' succeeded", getParameters().getCommandStep());
                    getParameters().setCommandStep(getParameters().getNextCommandStep());
                    break;
                } else {
                    log.error("Child command '{}' failed: {}", getParameters().getCommandStep(), vdcReturnValue != null ? vdcReturnValue.getExecuteFailedMessages() : "null return value");
                    setCommandStatus(CommandStatus.FAILED);
                    return;
                }
            case FAILED:
            case ENDED_WITH_FAILURE:
            case FAILED_RESTARTED:
                if (getParameters().getCommandStep() == RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE) {
                    // It's possible that the image was destroyed already if this is retry of Live
                    // Merge for the given volume.  Proceed to check if the image is present.
                    log.warn("Child command '{}' failed, proceeding to verify", getParameters().getCommandStep());
                    getParameters().setCommandStep(getParameters().getNextCommandStep());
                    break;
                }
                log.error("Failed child command status for step '{}'", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
            case UNKNOWN:
                log.error("Unknown child command status for step '{}'", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
        }
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(VdcActionType.MergeExtend, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(VdcActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (vdcReturnValue != null) {
                getParameters().setMergeStatusReturnValue(vdcReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = new Pair<>(VdcActionType.DestroyImage, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE_CHECK);
            break;
        case DESTROY_IMAGE_CHECK:
            nextCommand = new Pair<>(VdcActionType.DestroyImageCheck, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        CommandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
    // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
    }
}
#end_block

#method_before
@Test
public void testActivateNic() throws Exception {
    BackendVmNicResource backendVmNicResource = (BackendVmNicResource) resource;
    setUpGetEntityExpectations(3);
    setAllContentHeaderExpectation();
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVmInterface, AddVmInterfaceParameters.class, new String[] { "VmId", "Interface.Id" }, new Object[] { VM_ID, NIC_ID }));
    verifyActionResponse(backendVmNicResource.activate(new Action()));
}
#method_after
@Test
public void testActivateNic() throws Exception {
    BackendVmNicResource backendVmNicResource = resource;
    setUpGetEntityExpectations(3);
    setAllContentHeaderExpectation();
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVmInterface, AddVmInterfaceParameters.class, new String[] { "VmId", "Interface.Id" }, new Object[] { VM_ID, NIC_ID }));
    verifyActionResponse(backendVmNicResource.activate(new Action()));
}
#end_block

#method_before
@Test
public void testDeactivateNic() throws Exception {
    BackendVmNicResource backendVmNicResource = (BackendVmNicResource) resource;
    setAllContentHeaderExpectation();
    setUpGetEntityExpectations(3);
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVmInterface, AddVmInterfaceParameters.class, new String[] { "VmId", "Interface.Id" }, new Object[] { VM_ID, NIC_ID }));
    verifyActionResponse(backendVmNicResource.deactivate(new Action()));
}
#method_after
@Test
public void testDeactivateNic() throws Exception {
    BackendVmNicResource backendVmNicResource = resource;
    setAllContentHeaderExpectation();
    setUpGetEntityExpectations(3);
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVmInterface, AddVmInterfaceParameters.class, new String[] { "VmId", "Interface.Id" }, new Object[] { VM_ID, NIC_ID }));
    verifyActionResponse(backendVmNicResource.deactivate(new Action()));
}
#end_block

#method_before
private void installHost() {
    try (final VdsDeploy deploy = new VdsDeploy("ovirt-host-deploy", getVds(), true)) {
        log.info("Before Installation host {}, {}", getVds().getId(), getVds().getName());
        T parameters = getParameters();
        deploy.setCorrelationId(getCorrelationId());
        deploy.addUnit(new VdsDeployMiscUnit(), new VdsDeployVdsmUnit(), new VdsDeployPKIUnit(), new VdsDeployKdumpUnit());
        if (parameters.getNetworkProviderId() != null) {
            Provider<?> provider = getDbFacade().getProviderDao().get(parameters.getNetworkProviderId());
            if (provider.getType() == ProviderType.OPENSTACK_NETWORK) {
                OpenstackNetworkProviderProperties agentProperties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
                if (StringUtils.isNotBlank(parameters.getNetworkMappings())) {
                    agentProperties.getAgentConfiguration().setNetworkMappings(parameters.getNetworkMappings());
                }
                deploy.addUnit(new VdsDeployOpenStackUnit(agentProperties));
            }
        }
        if (parameters.getOverrideFirewall()) {
            switch(getVds().getVdsType()) {
                case VDS:
                    deploy.addUnit(new VdsDeployIptablesUnit());
                    break;
                case oVirtNode:
                    log.warn("Installation of Host {} will ignore Firewall Override option, since it is not supported for Host type {}", getVds().getName(), getVds().getVdsType().name());
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getVdsType()));
            }
        }
        if (parameters.getEnableSerialConsole()) {
            /* in 3.6.0 we always enable serial console without user intervention. */
            if (FeatureSupported.virtioSerialConsole(getVds().getClusterCompatibilityVersion())) {
                deploy.addUnit(new VdsDeployVmconsoleUnit());
            } else {
                log.warn("Installation of Host {} will skip Virtio Serial Console, because it is not supported for clusterLevel {}", getVds().getName(), getVds().getClusterCompatibilityVersion());
            }
        }
        switch(getParameters().getAuthMethod()) {
            case Password:
                deploy.setPassword(parameters.getPassword());
                break;
            case PublicKey:
                deploy.useDefaultKeyPair();
                break;
            default:
                throw new Exception("Invalid authentication method value was sent to InstallVdsInternalCommand");
        }
        setVdsStatus(VDSStatus.Installing);
        deploy.execute();
        switch(deploy.getDeployStatus()) {
            case Failed:
                throw new VdsInstallException(VDSStatus.InstallFailed, StringUtils.EMPTY);
            case Incomplete:
                throw new VdsInstallException(VDSStatus.InstallFailed, "Partial installation");
            case Reboot:
                setVdsStatus(VDSStatus.Reboot);
                runSleepOnReboot(getStatusOnReboot());
                break;
            case Complete:
                try (ProtocolDetector detector = new ProtocolDetector(getVds(), resourceManager, getVdsStaticDao(), getVdsDynamicDao(), auditLogDirector)) {
                    if (detector.shouldCheckProtocolTofallback()) {
                        // we need to check whether we are connecting to vdsm which supports xmlrpc only
                        if (!detector.attemptConnection()) {
                            detector.stopConnection();
                            if (detector.attemptFallbackProtocol()) {
                                detector.setFallbackProtocol();
                            } else {
                                throw new VdsInstallException(VDSStatus.InstallFailed, "Host not reachable");
                            }
                        }
                    }
                }
                configureManagementNetwork();
                if (!getParameters().getActivateHost() && VDSStatus.Maintenance.equals(vdsInitialStatus)) {
                    setVdsStatus(VDSStatus.Maintenance);
                } else {
                    setVdsStatus(VDSStatus.Initializing);
                }
                break;
        }
        log.info("After Installation host {}, {}", getVds().getName(), getVds().getVdsType().name());
        setSucceeded(true);
    } catch (VdsInstallException e) {
        handleError(e, e.getStatus());
    } catch (Exception e) {
        handleError(e, VDSStatus.InstallFailed);
    }
}
#method_after
private void installHost() {
    try (final VdsDeploy deploy = new VdsDeploy("ovirt-host-deploy", getVds(), true)) {
        log.info("Before Installation host {}, {}", getVds().getId(), getVds().getName());
        T parameters = getParameters();
        deploy.setCorrelationId(getCorrelationId());
        deploy.addUnit(new VdsDeployMiscUnit(), new VdsDeployVdsmUnit(), new VdsDeployPKIUnit(), new VdsDeployKdumpUnit());
        if (parameters.getNetworkProviderId() != null) {
            Provider<?> provider = getDbFacade().getProviderDao().get(parameters.getNetworkProviderId());
            if (provider.getType() == ProviderType.OPENSTACK_NETWORK) {
                OpenstackNetworkProviderProperties agentProperties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
                if (StringUtils.isNotBlank(parameters.getNetworkMappings())) {
                    agentProperties.getAgentConfiguration().setNetworkMappings(parameters.getNetworkMappings());
                }
                deploy.addUnit(new VdsDeployOpenStackUnit(agentProperties));
            }
        }
        if (parameters.getOverrideFirewall()) {
            switch(getVds().getVdsType()) {
                case VDS:
                    deploy.addUnit(new VdsDeployIptablesUnit());
                    break;
                case oVirtNode:
                    log.warn("Installation of Host {} will ignore Firewall Override option, since it is not supported for Host type {}", getVds().getName(), getVds().getVdsType().name());
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getVdsType()));
            }
        }
        if (parameters.getEnableSerialConsole()) {
            /* in 3.6.0 we always enable serial console without user intervention. */
            if (FeatureSupported.virtioSerialConsole(getVds().getClusterCompatibilityVersion())) {
                deploy.addUnit(new VdsDeployVmconsoleUnit());
            } else {
                log.warn("Installation of Host {} will skip Virtio Serial Console, because it is not supported for clusterLevel {}", getVds().getName(), getVds().getClusterCompatibilityVersion());
            }
        }
        switch(getParameters().getAuthMethod()) {
            case Password:
                deploy.setPassword(parameters.getPassword());
                break;
            case PublicKey:
                deploy.useDefaultKeyPair();
                break;
            default:
                throw new Exception("Invalid authentication method value was sent to InstallVdsInternalCommand");
        }
        setVdsStatus(VDSStatus.Installing);
        deploy.execute();
        switch(deploy.getDeployStatus()) {
            case Failed:
                throw new VdsInstallException(VDSStatus.InstallFailed, StringUtils.EMPTY);
            case Incomplete:
                throw new VdsInstallException(VDSStatus.InstallFailed, "Partial installation");
            case Reboot:
                setVdsStatus(VDSStatus.Reboot);
                runSleepOnReboot(getStatusOnReboot());
                break;
            case Complete:
                try (ProtocolDetector detector = new ProtocolDetector(getVds(), resourceManager, getVdsStaticDao(), getVdsDynamicDao(), auditLogDirector)) {
                    if (detector.shouldCheckProtocolTofallback()) {
                        // we need to check whether we are connecting to vdsm which supports xmlrpc only
                        if (!detector.attemptConnection()) {
                            detector.stopConnection();
                            if (detector.attemptFallbackProtocol()) {
                                detector.setFallbackProtocol();
                            } else {
                                throw new VdsInstallException(VDSStatus.InstallFailed, "Host is not reachable");
                            }
                        }
                    }
                }
                configureManagementNetwork();
                if (!getParameters().getActivateHost() && VDSStatus.Maintenance.equals(vdsInitialStatus)) {
                    setVdsStatus(VDSStatus.Maintenance);
                } else {
                    setVdsStatus(VDSStatus.Initializing);
                }
                break;
        }
        log.info("After Installation host {}, {}", getVds().getName(), getVds().getVdsType().name());
        setSucceeded(true);
    } catch (VdsInstallException e) {
        handleError(e, e.getStatus());
    } catch (Exception e) {
        handleError(e, VDSStatus.InstallFailed);
    }
}
#end_block

#method_before
// TODO Method with Side-Effect - move to VmsMonitoring
private void proceedVmBeforeDeletion() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
    if (dbVm.getStatus() == VMStatus.MigratingFrom) {
        // exit status that's OK, otherwise..
        if (vdsmVm.getVmDynamic() != null && vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal) {
            if (dbVm.getMigratingToVds() != null) {
                VDSReturnValue destoryReturnValue = vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(new Guid(dbVm.getMigratingToVds().toString()), dbVm.getId(), true, false, 0));
                if (destoryReturnValue.getSucceeded()) {
                    log.info("Stopped migrating VM: '{}' on VDS: '{}'", dbVm.getName(), dbVm.getMigratingToVds());
                } else {
                    log.info("Could not stop migrating VM: '{}' on VDS: '{}', Error: '{}'", dbVm.getName(), dbVm.getMigratingToVds(), destoryReturnValue.getExceptionString());
                }
            }
            // set vm status to down if source vm crushed
            ResourceManager.getInstance().internalSetVmStatus(dbVm, VMStatus.Down, vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
            saveDynamic(dbVm.getDynamicData());
            saveStatistics();
            saveVmInterfaces();
            type = AuditLogType.VM_MIGRATION_ABORT;
            logable.addCustomValue("MigrationError", vdsmVm.getVmDynamic().getExitMessage());
            vmsMonitoring.getResourceManager().removeAsyncRunningVm(vdsmVm.getVmDynamic().getId());
        }
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#method_after
// TODO Method with Side-Effect - move to VmsMonitoring
private void proceedVmBeforeDeletion() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
    if (dbVm.getStatus() == VMStatus.MigratingFrom) {
        // exit status that's OK, otherwise..
        if (vdsmVm != null && vdsmVm.getVmDynamic() != null && vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal) {
            if (dbVm.getMigratingToVds() != null) {
                VDSReturnValue destoryReturnValue = vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(new Guid(dbVm.getMigratingToVds().toString()), dbVm.getId(), true, false, 0));
                if (destoryReturnValue.getSucceeded()) {
                    log.info("Stopped migrating VM: '{}' on VDS: '{}'", dbVm.getName(), dbVm.getMigratingToVds());
                } else {
                    log.info("Could not stop migrating VM: '{}' on VDS: '{}', Error: '{}'", dbVm.getName(), dbVm.getMigratingToVds(), destoryReturnValue.getExceptionString());
                }
            }
            // set vm status to down if source vm crushed
            ResourceManager.getInstance().internalSetVmStatus(dbVm, VMStatus.Down, vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
            saveDynamic(dbVm.getDynamicData());
            saveStatistics();
            saveVmInterfaces();
            type = AuditLogType.VM_MIGRATION_ABORT;
            logable.addCustomValue("MigrationError", vdsmVm.getVmDynamic().getExitMessage());
            vmsMonitoring.getResourceManager().removeAsyncRunningVm(vdsmVm.getVmDynamic().getId());
        }
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#end_block

#method_before
public Version getCompatibilityVersion() {
    return getCustomCompatibilityVersion() != null ? getCustomCompatibilityVersion() : getVdsGroupCompatibilityVersion();
}
#method_after
public Version getCompatibilityVersion() {
    return getCustomCompatibilityVersion() != null ? getCustomCompatibilityVersion() : getClusterCompatibilityVersion();
}
#end_block

#method_before
public double getDiskSize() {
    if (diskSize == 0) {
        for (Disk disk : getDiskMap().values()) {
            if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
                diskSize += ((DiskImage) disk).getSize() / Double.valueOf(1024 * 1024 * 1024);
            }
        }
    }
    return diskSize;
}
#method_after
public double getDiskSize() {
    if (diskSize == 0) {
        for (Disk disk : getDiskMap().values()) {
            if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
                diskSize += disk.getSize() / Double.valueOf(1024 * 1024 * 1024);
            }
        }
    }
    return diskSize;
}
#end_block

#method_before
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // update only if vdsm actually provides some value, otherwise engine has more information
    if (vm.getCurrentCd() != null) {
        setCurrentCd(vm.getCurrentCd());
    }
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    getDynamicData().setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setUtcDiff(vm.getUtcDiff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setExitReason(vm.getExitReason());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
    setGuestCpuCount(vm.getGuestCpuCount());
    setGraphicsInfos(vm.getGraphicsInfos());
    getDynamicData().setGuestMemoryBuffered(vm.getGuestMemoryBuffered());
    getDynamicData().setGuestMemoryCached(vm.getGuestMemoryCached());
    getDynamicData().setGuestMemoryFree(vm.getGuestMemoryFree());
    setGuestOsArch(vm.getGuestOsArch());
    setGuestOsCodename(vm.getGuestOsCodename());
    setGuestOsDistribution(vm.getGuestOsDistribution());
    setGuestOsKernelVersion(vm.getGuestOsKernelVersion());
    setGuestOsType(vm.getGuestOsType());
    setGuestOsVersion(vm.getGuestOsVersion());
    setGuestOsTimezoneName(vm.getGuestOsTimezoneName());
    setGuestOsTimezoneOffset(vm.getGuestOsTimezoneOffset());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#method_after
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // update only if vdsm actually provides some value, otherwise engine has more information
    if (vm.getCurrentCd() != null) {
        setCurrentCd(vm.getCurrentCd());
    }
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    getDynamicData().setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setUtcDiff(vm.getUtcDiff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setExitReason(vm.getExitReason());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
    setGuestCpuCount(vm.getGuestCpuCount());
    setGraphicsInfos(new HashMap<>(vm.getGraphicsInfos()));
    getDynamicData().setGuestMemoryBuffered(vm.getGuestMemoryBuffered());
    getDynamicData().setGuestMemoryCached(vm.getGuestMemoryCached());
    getDynamicData().setGuestMemoryFree(vm.getGuestMemoryFree());
    setGuestOsArch(vm.getGuestOsArch());
    setGuestOsCodename(vm.getGuestOsCodename());
    setGuestOsDistribution(vm.getGuestOsDistribution());
    setGuestOsKernelVersion(vm.getGuestOsKernelVersion());
    setGuestOsType(vm.getGuestOsType());
    setGuestOsVersion(vm.getGuestOsVersion());
    setGuestOsTimezoneName(vm.getGuestOsTimezoneName());
    setGuestOsTimezoneOffset(vm.getGuestOsTimezoneOffset());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    long temp;
    temp = (long) _actualDiskWithSnapthotsSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + (balloonEnabled ? 1231 : 1237);
    result = prime * result + ((cdPath == null) ? 0 : cdPath.hashCode());
    result = prime * result + ((configured == null) ? 0 : configured.hashCode());
    result = prime * result + ((diskMap == null) ? 0 : diskMap.hashCode());
    temp = (long) diskSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + ((floppyPath == null) ? 0 : floppyPath.hashCode());
    result = prime * result + ((initializationType == null) ? 0 : initializationType.hashCode());
    result = prime * result + ((privateGuestAgentVersion == null) ? 0 : privateGuestAgentVersion.hashCode());
    result = prime * result + ((runOnVdsName == null) ? 0 : runOnVdsName.hashCode());
    result = prime * result + ((snapshots == null) ? 0 : snapshots.hashCode());
    result = prime * result + ((spiceDriverVersion == null) ? 0 : spiceDriverVersion.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugePages ? 1231 : 1237);
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vmDynamic == null) ? 0 : vmDynamic.hashCode());
    result = prime * result + ((vmPayload == null) ? 0 : vmPayload.hashCode());
    result = prime * result + ((vmPoolId == null) ? 0 : vmPoolId.hashCode());
    result = prime * result + ((vmPoolName == null) ? 0 : vmPoolName.hashCode());
    result = prime * result + ((vmStatic == null) ? 0 : vmStatic.hashCode());
    result = prime * result + ((vmStatistics == null) ? 0 : vmStatistics.hashCode());
    result = prime * result + vmtCpuPerSocket;
    result = prime * result + ((vmtCreationDate == null) ? 0 : vmtCreationDate.hashCode());
    result = prime * result + ((vmtDescription == null) ? 0 : vmtDescription.hashCode());
    result = prime * result + vmtMemSizeMb;
    result = prime * result + ((vmtName == null) ? 0 : vmtName.hashCode());
    result = prime * result + vmtNumOfCpus;
    result = prime * result + vmtNumOfSockets;
    result = prime * result + vmtOsId;
    result = prime * result + ((vmtTimeZone == null) ? 0 : vmtTimeZone.hashCode());
    result = prime * result + vmtchildCount;
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    long temp;
    temp = (long) _actualDiskWithSnapthotsSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + (balloonEnabled ? 1231 : 1237);
    result = prime * result + ((cdPath == null) ? 0 : cdPath.hashCode());
    result = prime * result + ((configured == null) ? 0 : configured.hashCode());
    result = prime * result + ((diskMap == null) ? 0 : diskMap.hashCode());
    temp = (long) diskSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + ((floppyPath == null) ? 0 : floppyPath.hashCode());
    result = prime * result + ((initializationType == null) ? 0 : initializationType.hashCode());
    result = prime * result + ((privateGuestAgentVersion == null) ? 0 : privateGuestAgentVersion.hashCode());
    result = prime * result + ((runOnVdsName == null) ? 0 : runOnVdsName.hashCode());
    result = prime * result + ((snapshots == null) ? 0 : snapshots.hashCode());
    result = prime * result + ((spiceDriverVersion == null) ? 0 : spiceDriverVersion.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugePages ? 1231 : 1237);
    result = prime * result + ((clusterCompatibilityVersion == null) ? 0 : clusterCompatibilityVersion.hashCode());
    result = prime * result + ((clusterCpuName == null) ? 0 : clusterCpuName.hashCode());
    result = prime * result + ((clusterDescription == null) ? 0 : clusterDescription.hashCode());
    result = prime * result + ((clusterName == null) ? 0 : clusterName.hashCode());
    result = prime * result + ((vmDynamic == null) ? 0 : vmDynamic.hashCode());
    result = prime * result + ((vmPayload == null) ? 0 : vmPayload.hashCode());
    result = prime * result + ((vmPoolId == null) ? 0 : vmPoolId.hashCode());
    result = prime * result + ((vmPoolName == null) ? 0 : vmPoolName.hashCode());
    result = prime * result + ((vmStatic == null) ? 0 : vmStatic.hashCode());
    result = prime * result + ((vmStatistics == null) ? 0 : vmStatistics.hashCode());
    result = prime * result + vmtCpuPerSocket;
    result = prime * result + ((vmtCreationDate == null) ? 0 : vmtCreationDate.hashCode());
    result = prime * result + ((vmtDescription == null) ? 0 : vmtDescription.hashCode());
    result = prime * result + vmtMemSizeMb;
    result = prime * result + ((vmtName == null) ? 0 : vmtName.hashCode());
    result = prime * result + vmtNumOfCpus;
    result = prime * result + vmtNumOfSockets;
    result = prime * result + vmtOsId;
    result = prime * result + ((vmtTimeZone == null) ? 0 : vmtTimeZone.hashCode());
    result = prime * result + vmtchildCount;
    return result;
}
#end_block

#method_before
@Test
public void testSuccessfulSessionId() {
    when(params.getSessionId()).thenReturn("good_session_id");
    DbUser result = new DbUser();
    result.setId(Guid.newGuid());
    result.setLoginName("myUser");
    result.setDomain("myDomain");
    when(getQuery().getSessionUser("good_session_id")).thenReturn(result);
    getQuery().execute();
    assertTrue(getQuery().getQueryReturnValue().getSucceeded());
    assertTrue(getQuery().getQueryReturnValue().getReturnValue() instanceof DbUser);
    DbUser user = (DbUser) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("myDomain", user.getDomain());
    assertEquals("myUser", user.getLoginName());
}
#method_after
@Test
public void testSuccessfulSessionId() {
    when(params.getSessionId()).thenReturn("good_session_id");
    DbUser result = new DbUser();
    result.setId(Guid.newGuid());
    result.setLoginName("myUser");
    result.setDomain("myDomain");
    when(getQuery().getSessionUser("good_session_id")).thenReturn(result);
    getQuery().execute();
    assertTrue(getQuery().getQueryReturnValue().getSucceeded());
    assertTrue(getQuery().getQueryReturnValue().getReturnValue() instanceof DbUser);
    DbUser user = getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("myDomain", user.getDomain());
    assertEquals("myUser", user.getLoginName());
}
#end_block

#method_before
@BeforeClass
public static void initTestCase() throws Exception {
    if (dataSource == null) {
        try {
            dataSource = createDataSource();
            ejbRule.mockResource(ContainerManagedResourceType.DATA_SOURCE, dataSource);
            final IDataSet dataset = initDataSet();
            // load data from fixtures to DB
            DatabaseOperation.CLEAN_INSERT.execute(getConnection(), dataset);
            SimpleNamingContextBuilder builder = new SimpleNamingContextBuilder();
            builder.bind("java:/ENGINEDataSource", dataSource);
            builder.activate();
        } catch (Exception e) {
            LoggerFactory.getLogger(BaseDaoTestCase.class).error("Unable to init tests", e);
            System.exit(1);
        }
    }
}
#method_after
@BeforeClass
public static void initTestCase() throws Exception {
    if (dataSource == null) {
        try {
            dataSource = createDataSource();
            ejbRule.mockResource(ContainerManagedResourceType.DATA_SOURCE, dataSource);
            final IDataSet dataset = initDataSet();
            // load data from fixtures to DB
            DatabaseOperation.CLEAN_INSERT.execute(getConnection(), dataset);
            SimpleNamingContextBuilder builder = new SimpleNamingContextBuilder();
            builder.bind("java:/ENGINEDataSource", dataSource);
            builder.activate();
            initialized = true;
        } catch (Exception e) {
            /*
                 * note: without logging current maven setting does NOT produce stacktrace/message for following AssertionError.
                 * this error log is absolutely vital to actually see, what went wrong!
                 */
            LoggerFactory.getLogger(BaseDaoTestCase.class).error("Unable to init tests", e);
            /*
                 * note: re-throwing exception here is absolutely vital. Without it, all tests of first executed
                 * descendant test class will be normally executed. With added assumption using Assume then all tests
                 * will be skipped and successful tests execution will be pronounced. This exception will cause first of
                 * executed descendant test class fail and it's constructor will not be even reached.
                 */
            throw new AssertionError("Unable to init tests", e);
        }
    }
}
#end_block

#method_before
private static DataSource createDataSource() {
    DataSource result = null;
    Properties properties = new Properties();
    Config.setConfigUtils(new DBConfigUtils(false));
    InputStream is = null;
    try {
        String job = System.getProperty("JOB_NAME");
        if (job == null)
            job = "";
        String number = System.getProperty("BUILD_NUMBER");
        if (number == null)
            number = "";
        String schemaNamePostfix = job + number;
        is = BaseDaoTestCase.class.getResourceAsStream("/test-database.properties");
        properties.load(is);
        ClassLoader.getSystemClassLoader().loadClass(properties.getProperty("database.driver"));
        String dbUrl = properties.getProperty("database.url") + schemaNamePostfix;
        result = new SingleConnectionDataSource(dbUrl, properties.getProperty("database.username"), properties.getProperty("database.password"), true);
        initSql = properties.getProperty("database.initsql");
        loadDataFactory(properties.getProperty("database.testing.datafactory"));
        if (initSql != null && !initSql.isEmpty()) {
            needInitializationSql = true;
        }
    } catch (Exception error) {
        error.printStackTrace();
        throw new RuntimeException("Cannot create data source", error);
    } finally {
        if (is != null) {
            try {
                is.close();
            } catch (IOException e) {
            // ignore
            }
        }
    }
    return result;
}
#method_after
private static DataSource createDataSource() {
    DataSource result = null;
    Properties properties = new Properties();
    Config.setConfigUtils(new DBConfigUtils(false));
    InputStream is = null;
    try {
        String job = System.getProperty("JOB_NAME");
        if (job == null) {
            job = "";
        }
        String number = System.getProperty("BUILD_NUMBER");
        if (number == null) {
            number = "";
        }
        String schemaNamePostfix = job + number;
        is = BaseDaoTestCase.class.getResourceAsStream("/test-database.properties");
        properties.load(is);
        ClassLoader.getSystemClassLoader().loadClass(properties.getProperty("database.driver"));
        String dbUrl = properties.getProperty("database.url") + schemaNamePostfix;
        result = new SingleConnectionDataSource(dbUrl, properties.getProperty("database.username"), properties.getProperty("database.password"), true);
        initSql = properties.getProperty("database.initsql");
        loadDataFactory(properties.getProperty("database.testing.datafactory"));
        if (initSql != null && !initSql.isEmpty()) {
            needInitializationSql = true;
        }
    } catch (Exception error) {
        error.printStackTrace();
        throw new RuntimeException("Cannot create data source", error);
    } finally {
        if (is != null) {
            try {
                is.close();
            } catch (IOException e) {
            // ignore
            }
        }
    }
    return result;
}
#end_block

#method_before
public void guide() {
    ClusterGuideModel model = new ClusterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newClusterGuideMeTitle());
    model.setHelpTag(HelpTag.new_cluster___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_cluster_-_guide_me");
    if (getGuideContext() == null) {
        Cluster cluster = getSelectedItem();
        setGuideContext(cluster.getId());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel<Void> clusterListModel = (ClusterListModel<Void>) target;
            ClusterGuideModel model = (ClusterGuideModel) clusterListModel.getWindow();
            model.setEntity((Cluster) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", clusterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
public void guide() {
    ClusterGuideModel model = new ClusterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newClusterGuideMeTitle());
    model.setHelpTag(HelpTag.new_cluster___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_cluster_-_guide_me");
    if (getGuideContext() == null) {
        Cluster cluster = getSelectedItem();
        setGuideContext(cluster.getId());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel<Void> clusterListModel = (ClusterListModel<Void>) target;
            ClusterGuideModel model = (ClusterGuideModel) clusterListModel.getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", clusterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
public void onResetClusterEmulatedMachine() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> prms = new ArrayList<>();
    for (Cluster cluster : getSelectedItems()) {
        ManagementNetworkOnClusterOperationParameters currentParam = new ManagementNetworkOnClusterOperationParameters(cluster);
        currentParam.setForceResetEmulatedMachine(true);
        prms.add(currentParam);
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.UpdateCluster, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            model.stopProgress();
            cancel();
        }
    });
}
#method_after
public void onResetClusterEmulatedMachine() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> prms = new ArrayList<>();
    for (Cluster cluster : getSelectedItems()) {
        ManagementNetworkOnClusterOperationParameters currentParam = new ManagementNetworkOnClusterOperationParameters((cluster));
        currentParam.setForceResetEmulatedMachine(true);
        prms.add(currentParam);
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.UpdateCluster, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            model.stopProgress();
            cancel();
        }
    });
}
#end_block

#method_before
@Test
public void testQueryExecution() {
    // Set up the expected data
    VmTemplate expected = new VmTemplate();
    // Mock the Dao
    VmTemplateDao vmTemplateDaoMock = mock(VmTemplateDao.class);
    when(vmTemplateDaoMock.getTemplatesWithPermittedAction(getUser().getId(), getActionGroup())).thenReturn(Collections.singletonList(expected));
    when(getDbFacadeMockInstance().getVmTemplateDao()).thenReturn(vmTemplateDaoMock);
    getQuery().executeQueryCommand();
    @SuppressWarnings("unchecked")
    List<VmTemplate> actual = getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong number of VDS Groups", 1, actual.size());
    assertEquals("Wrong VDS Groups", expected, actual.get(0));
}
#method_after
@Test
public void testQueryExecution() {
    // Set up the expected data
    VmTemplate expected = new VmTemplate();
    // Mock the Dao
    VmTemplateDao vmTemplateDaoMock = mock(VmTemplateDao.class);
    when(vmTemplateDaoMock.getTemplatesWithPermittedAction(getUser().getId(), getActionGroup())).thenReturn(Collections.singletonList(expected));
    when(getDbFacadeMockInstance().getVmTemplateDao()).thenReturn(vmTemplateDaoMock);
    getQuery().executeQueryCommand();
    @SuppressWarnings("unchecked")
    List<VmTemplate> actual = getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong number of templates", 1, actual.size());
    assertEquals("Wrong templates", expected, actual.get(0));
}
#end_block

#method_before
@Override
public void init(ServletConfig config) throws ServletException {
    super.init(config);
    // Grab the app name from init parameter, so we can use it to build the path to symbol maps.
    final String applicationName = config.getInitParameter(APP_NAME);
    if (applicationName == null) {
        // $NON-NLS-1$
        throw new ServletException("Application name not specified");
    }
    File symbolMapDirectory = new File(EngineLocalConfig.getInstance().getUsrDir(), // $NON-NLS-1$ $NON-NLS-2$
    "/gwt-symbols/" + applicationName + "/symbolMaps");
    boolean symbolMapsDirectoryExists = symbolMapDirectory.exists() && symbolMapDirectory.isDirectory();
    File[] files = symbolMapDirectory.listFiles(new FilenameFilter() {

        @Override
        public boolean accept(File dir, String name) {
            // $NON-NLS-1$
            return name != null && name.toLowerCase().endsWith("symbolmap");
        }
    });
    if (!symbolMapsDirectoryExists || files == null || files.length == 0) {
        log.info(// $NON-NLS-1$
        "GWT symbolmaps are not installed, " + // $NON-NLS-1$
        "please install them to de-obfuscate the UI stack traces");
    } else {
        // Only set the symbolMaps directory if it passed the tests.
        // $NON-NLS-1$
        setSymbolMapsDirectory(symbolMapDirectory.getAbsolutePath());
    }
}
#method_after
@Override
public void init(ServletConfig config) throws ServletException {
    super.init(config);
    final String applicationName = getServletContext().getInitParameter(APP_NAME);
    if (applicationName == null) {
        // $NON-NLS-1$
        throw new ServletException("Application name not specified");
    }
    File symbolMapDirectory = new File(EngineLocalConfig.getInstance().getUsrDir(), // $NON-NLS-1$ $NON-NLS-2$
    "/gwt-symbols/" + applicationName + "/symbolMaps");
    boolean symbolMapsDirectoryExists = symbolMapDirectory.exists() && symbolMapDirectory.isDirectory();
    File[] files = symbolMapDirectory.listFiles(new FilenameFilter() {

        @Override
        public boolean accept(File dir, String name) {
            // $NON-NLS-1$
            return name != null && name.toLowerCase().endsWith("symbolmap");
        }
    });
    if (!symbolMapsDirectoryExists || files == null || files.length == 0) {
        log.info(// $NON-NLS-1$
        "GWT symbolmaps are not installed, " + // $NON-NLS-1$
        "please install them to de-obfuscate the UI stack traces");
    } else {
        // Only set the symbolMaps directory if it passed the tests.
        // $NON-NLS-1$
        setSymbolMapsDirectory(symbolMapDirectory.getAbsolutePath());
    }
}
#end_block

#method_before
private void logOnServer(LogRecord logRecord, String strongName, StackTraceDeobfuscator deobfuscator) {
    if (deobfuscator != null) {
        logRecord = RemoteLoggingServiceUtil.deobfuscateLogRecord(deobfuscator, logRecord, strongName);
    }
    log.error(logRecord.getMessage(), logRecord.getThrown());
}
#method_after
private void logOnServer(LogRecord logRecord, String strongName, StackTraceDeobfuscator deobfuscator) {
    if (deobfuscator != null) {
        logRecord = RemoteLoggingServiceUtil.deobfuscateLogRecord(deobfuscator, logRecord, strongName);
    }
    // $NON-NLS-1$
    log.error("Permutation name: " + strongName);
    log.error(logRecord.getMessage(), logRecord.getThrown());
}
#end_block

#method_before
@Override
public final void onBootstrap() {
    // $NON-NLS-1$
    Logger rootLogger = Logger.getLogger("");
    initLocalStorageLogHandler(rootLogger);
    initUncaughtExceptionHandler();
    // Perform actual bootstrap via deferred command to ensure that
    // UncaughtExceptionHandler is effective during the bootstrap
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            performBootstrap();
        }
    });
}
#method_after
@Override
public final void onBootstrap() {
    // $NON-NLS-1$
    Logger rootLogger = Logger.getLogger("");
    initLocalStorageLogHandler(rootLogger);
    // $NON-NLS-1$
    Logger remoteLogger = Logger.getLogger("remote");
    remoteLogger.addHandler(new SimpleRemoteLogHandler());
    initUncaughtExceptionHandler(rootLogger, remoteLogger);
    // Perform actual bootstrap via deferred command to ensure that
    // UncaughtExceptionHandler is effective during the bootstrap
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            performBootstrap();
        }
    });
}
#end_block

#method_before
void initUncaughtExceptionHandler() {
    // $NON-NLS-1$
    final Logger remoteLogger = Logger.getLogger("remote");
    remoteLogger.addHandler(new SimpleRemoteLogHandler());
    // Prevent uncaught exceptions from escaping application code
    GWT.setUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void onUncaughtException(Throwable t) {
            // $NON-NLS-1$
            remoteLogger.log(Level.SEVERE, "Uncaught exception: ", t);
            alertManager.showUncaughtExceptionAlert(t);
        }
    });
}
#method_after
void initUncaughtExceptionHandler(final Logger rootLogger, final Logger remoteLogger) {
    // Prevent uncaught exceptions from escaping application code
    GWT.setUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void onUncaughtException(Throwable t) {
            // $NON-NLS-1$
            rootLogger.log(Level.SEVERE, "Uncaught exception: ", t);
            // $NON-NLS-1$
            remoteLogger.log(Level.SEVERE, "Uncaught exception: ", t);
            alertManager.showUncaughtExceptionAlert(t);
        }
    });
}
#end_block

#method_before
private void processVmsWithDevicesChange() {
    // Handle VM devices were changed (for 3.1 cluster and above)
    if (!VmDeviceCommonUtils.isOldClusterVersion(vdsManager.getGroupCompatibilityVersion())) {
        // get the new info from VDSM in one call, and then update them all
        if (!vmsWithChangedDevices.isEmpty()) {
            ArrayList<String> vmsToUpdate = new ArrayList<>(vmsWithChangedDevices.size());
            for (Pair<VM, VmInternalData> pair : vmsWithChangedDevices) {
                Guid vmId = pair.getFirst().getId();
                // update only if the vm marked to change, otherwise it might have skipped because data invalidated
                // this ensure the vmManager lock is taken
                VmAnalyzer vmAnalyzer = vmAnalyzers.stream().filter(analyzer -> vmId.equals(analyzer.getVdsmVm().getVmDynamic().getId())).collect(Collectors.toList()).get(0);
                if (vmAnalyzer.getVmDynamicToSave() != null) {
                    vmAnalyzer.getVmDynamicToSave().setHash(pair.getSecond().getVmDynamic().getHash());
                    vmsToUpdate.add(vmId.toString());
                } else {
                    log.warn("VM '{}' not in changed list, skipping devices update.", vmId);
                }
            }
            updateVmDevices(vmsToUpdate);
        }
    }
}
#method_after
private void processVmsWithDevicesChange() {
    // Handle VM devices were changed (for 3.1 cluster and above)
    if (!VmDeviceCommonUtils.isOldClusterVersion(vdsManager.getGroupCompatibilityVersion())) {
        // get the new info from VDSM in one call, and then update them all
        if (!vmsWithChangedDevices.isEmpty()) {
            ArrayList<String> vmsToUpdate = new ArrayList<>(vmsWithChangedDevices.size());
            for (Pair<VM, VmInternalData> pair : vmsWithChangedDevices) {
                Guid vmId = pair.getFirst().getId();
                // update only if the vm marked to change, otherwise it might have skipped because data invalidated
                // this ensure the vmManager lock is taken
                VmAnalyzer vmAnalyzer = vmAnalyzers.stream().filter(analyzer -> vmId.equals(analyzer.getVdsmVm().getVmDynamic().getId())).findFirst().orElse(null);
                if (vmAnalyzer != null && vmAnalyzer.getVmDynamicToSave() != null) {
                    vmAnalyzer.getVmDynamicToSave().setHash(pair.getSecond().getVmDynamic().getHash());
                    vmsToUpdate.add(vmId.toString());
                } else {
                    log.warn("VM '{}' not in changed list, skipping devices update.", vmId);
                }
            }
            updateVmDevices(vmsToUpdate);
        }
    }
}
#end_block

#method_before
@Override
protected void init() {
    T parameters = getParameters();
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (VmDeviceUtils.shouldOverrideSoundDevice(getParameters().getMasterVm(), CompatibilityVersionUtils.getEffective(parameterMasterVm, getCluster()), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        VmHandler.updateDefaultTimeZone(parameterMasterVm);
        VmHandler.autoSelectUsbPolicy(getParameters().getMasterVm(), getCluster());
        VmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#method_after
@Override
protected void init() {
    T parameters = getParameters();
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (VmDeviceUtils.shouldOverrideSoundDevice(getParameters().getMasterVm(), getVm() == null ? CompatibilityVersionUtils.getEffective(parameterMasterVm, getCluster()) : getVm().getCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        VmHandler.updateDefaultTimeZone(parameterMasterVm);
        VmHandler.autoSelectUsbPolicy(getParameters().getMasterVm(), getCluster());
        VmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#end_block

#method_before
protected void separateCustomProperties(VmStatic parameterMasterVm) {
    if (getCluster() != null) {
        // Parses the custom properties field that was filled by frontend to
        // predefined and user defined fields
        VmPropertiesUtils.getInstance().separateCustomPropertiesToUserAndPredefined(CompatibilityVersionUtils.getEffective(parameterMasterVm, getCluster()), parameterMasterVm);
    }
}
#method_after
protected void separateCustomProperties(VmStatic parameterMasterVm) {
    if (getCluster() != null) {
        // Parses the custom properties field that was filled by frontend to
        // predefined and user defined fields
        VmPropertiesUtils.getInstance().separateCustomPropertiesToUserAndPredefined(getVm() == null ? CompatibilityVersionUtils.getEffective(parameterMasterVm, getCluster()) : getVm().getCompatibilityVersion(), parameterMasterVm);
    }
}
#end_block

