545
#method_before
public static CancelWorkRunnable forId(@NonNull final UUID id, @NonNull final WorkManagerImpl workManagerImpl) {
    return new CancelWorkRunnable() {

        private final SettableFuture<Void> mFuture = SettableFuture.create();

        @WorkerThread
        @Override
        public void run() {
            try {
                cancel(workManagerImpl, id.toString());
                reschedulePendingWorkers(workManagerImpl);
            } catch (Throwable exception) {
                mFuture.setException(exception);
            } finally {
                mFuture.set(null);
            }
        }

        @Override
        public ListenableFuture<Void> getFuture() {
            return mFuture;
        }
    };
}
#method_after
public static CancelWorkRunnable forId(@NonNull final UUID id, @NonNull final WorkManagerImpl workManagerImpl) {
    return new CancelWorkRunnable() {

        @WorkerThread
        @Override
        void runInternal() {
            cancel(workManagerImpl, id.toString());
            reschedulePendingWorkers(workManagerImpl);
        }
    };
}
#end_block

#method_before
public static CancelWorkRunnable forTag(@NonNull final String tag, @NonNull final WorkManagerImpl workManagerImpl) {
    return new CancelWorkRunnable() {

        private final SettableFuture<Void> mFuture = SettableFuture.create();

        @WorkerThread
        @Override
        public void run() {
            try {
                WorkDatabase workDatabase = workManagerImpl.getWorkDatabase();
                workDatabase.beginTransaction();
                try {
                    WorkSpecDao workSpecDao = workDatabase.workSpecDao();
                    List<String> workSpecIds = workSpecDao.getUnfinishedWorkWithTag(tag);
                    for (String workSpecId : workSpecIds) {
                        cancel(workManagerImpl, workSpecId);
                    }
                    workDatabase.setTransactionSuccessful();
                } finally {
                    workDatabase.endTransaction();
                }
                reschedulePendingWorkers(workManagerImpl);
            } catch (Throwable throwable) {
                mFuture.setException(throwable);
            } finally {
                mFuture.set(null);
            }
        }

        @Override
        public ListenableFuture<Void> getFuture() {
            return mFuture;
        }
    };
}
#method_after
public static CancelWorkRunnable forTag(@NonNull final String tag, @NonNull final WorkManagerImpl workManagerImpl) {
    return new CancelWorkRunnable() {

        @WorkerThread
        @Override
        void runInternal() {
            WorkDatabase workDatabase = workManagerImpl.getWorkDatabase();
            workDatabase.beginTransaction();
            try {
                WorkSpecDao workSpecDao = workDatabase.workSpecDao();
                List<String> workSpecIds = workSpecDao.getUnfinishedWorkWithTag(tag);
                for (String workSpecId : workSpecIds) {
                    cancel(workManagerImpl, workSpecId);
                }
                workDatabase.setTransactionSuccessful();
            } finally {
                workDatabase.endTransaction();
            }
            reschedulePendingWorkers(workManagerImpl);
        }
    };
}
#end_block

#method_before
public static CancelWorkRunnable forName(@NonNull final String name, @NonNull final WorkManagerImpl workManagerImpl, final boolean allowReschedule) {
    return new CancelWorkRunnable() {

        private final SettableFuture<Void> mFuture = SettableFuture.create();

        @WorkerThread
        @Override
        public void run() {
            try {
                WorkDatabase workDatabase = workManagerImpl.getWorkDatabase();
                workDatabase.beginTransaction();
                try {
                    WorkSpecDao workSpecDao = workDatabase.workSpecDao();
                    List<String> workSpecIds = workSpecDao.getUnfinishedWorkWithName(name);
                    for (String workSpecId : workSpecIds) {
                        cancel(workManagerImpl, workSpecId);
                    }
                    workDatabase.setTransactionSuccessful();
                } finally {
                    workDatabase.endTransaction();
                }
                if (allowReschedule) {
                    reschedulePendingWorkers(workManagerImpl);
                }
            } catch (Throwable throwable) {
                mFuture.setException(throwable);
            } finally {
                mFuture.set(null);
            }
        }

        @Override
        public ListenableFuture<Void> getFuture() {
            return mFuture;
        }
    };
}
#method_after
public static CancelWorkRunnable forName(@NonNull final String name, @NonNull final WorkManagerImpl workManagerImpl, final boolean allowReschedule) {
    return new CancelWorkRunnable() {

        @WorkerThread
        @Override
        void runInternal() {
            WorkDatabase workDatabase = workManagerImpl.getWorkDatabase();
            workDatabase.beginTransaction();
            try {
                WorkSpecDao workSpecDao = workDatabase.workSpecDao();
                List<String> workSpecIds = workSpecDao.getUnfinishedWorkWithName(name);
                for (String workSpecId : workSpecIds) {
                    cancel(workManagerImpl, workSpecId);
                }
                workDatabase.setTransactionSuccessful();
            } finally {
                workDatabase.endTransaction();
            }
            if (allowReschedule) {
                reschedulePendingWorkers(workManagerImpl);
            }
        }
    };
}
#end_block

#method_before
public static CancelWorkRunnable forAll(@NonNull final WorkManagerImpl workManagerImpl) {
    return new CancelWorkRunnable() {

        private final SettableFuture<Void> mFuture = SettableFuture.create();

        @Override
        public void run() {
            try {
                WorkDatabase workDatabase = workManagerImpl.getWorkDatabase();
                workDatabase.beginTransaction();
                try {
                    WorkSpecDao workSpecDao = workDatabase.workSpecDao();
                    List<String> workSpecIds = workSpecDao.getAllUnfinishedWork();
                    for (String workSpecId : workSpecIds) {
                        cancel(workManagerImpl, workSpecId);
                    }
                    workDatabase.setTransactionSuccessful();
                    // Update the last cancelled time in Preferences.
                    new Preferences(workManagerImpl.getApplicationContext()).setLastCancelAllTimeMillis(System.currentTimeMillis());
                } finally {
                    workDatabase.endTransaction();
                }
            // No need to call reschedule pending workers here as we just cancelled
            // everything.
            } catch (Throwable throwable) {
                mFuture.setException(throwable);
            } finally {
                mFuture.set(null);
            }
        }

        @Override
        public ListenableFuture<Void> getFuture() {
            return mFuture;
        }
    };
}
#method_after
public static CancelWorkRunnable forAll(@NonNull final WorkManagerImpl workManagerImpl) {
    return new CancelWorkRunnable() {

        @WorkerThread
        @Override
        void runInternal() {
            WorkDatabase workDatabase = workManagerImpl.getWorkDatabase();
            workDatabase.beginTransaction();
            try {
                WorkSpecDao workSpecDao = workDatabase.workSpecDao();
                List<String> workSpecIds = workSpecDao.getAllUnfinishedWork();
                for (String workSpecId : workSpecIds) {
                    cancel(workManagerImpl, workSpecId);
                }
                workDatabase.setTransactionSuccessful();
                // Update the last cancelled time in Preferences.
                new Preferences(workManagerImpl.getApplicationContext()).setLastCancelAllTimeMillis(System.currentTimeMillis());
            } finally {
                workDatabase.endTransaction();
            }
        // No need to call reschedule pending workers here as we just cancelled everything.
        }
    };
}
#end_block

#method_before
@NonNull
@Override
public ListenableFuture<Long> getLastCancelAllTimeMillis() {
    final SettableFuture<Long> future = SettableFuture.create();
    mWorkTaskExecutor.executeOnBackgroundThread(new Runnable() {

        @Override
        public void run() {
            try {
                future.set(mPreferences.getLastCancelAllTimeMillis());
            } catch (Throwable throwable) {
                future.setException(throwable);
            }
        }
    });
    return future;
}
#method_after
@NonNull
@Override
public ListenableFuture<Long> getLastCancelAllTimeMillis() {
    final SettableFuture<Long> future = SettableFuture.create();
    // Avoiding synthetic accessors.
    final Preferences preferences = mPreferences;
    mWorkTaskExecutor.executeOnBackgroundThread(new Runnable() {

        @Override
        public void run() {
            try {
                future.set(preferences.getLastCancelAllTimeMillis());
            } catch (Throwable throwable) {
                future.setException(throwable);
            }
        }
    });
    return future;
}
#end_block

#method_before
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/video/media");
}
#method_after
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/images/media");
}
#end_block

#method_before
public static Bitmap getThumbnail(ContentResolver cr, long origId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, true);
}
#method_after
public static Bitmap getThumbnail(ContentResolver cr, long origId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, false);
}
#end_block

#method_before
public static Bitmap getThumbnail(ContentResolver cr, long origId, long groupId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, groupId, kind, options, EXTERNAL_CONTENT_URI, true);
}
#method_after
public static Bitmap getThumbnail(ContentResolver cr, long origId, long groupId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, groupId, kind, options, EXTERNAL_CONTENT_URI, false);
}
#end_block

#method_before
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/video/thumbnails");
}
#method_after
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/images/thumbnails");
}
#end_block

#method_before
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/video/media");
}
#method_after
public static Uri getContentUri(String volumeName) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/audio/media");
}
#end_block

#method_before
public static Uri getContentUriForPath(String path) {
    // check internal storages
    if (path.startsWith(Environment.getRootDirectory()) || path.startsWith(Environment.getOemDirectory()) || path.startsWith(Environment.getProductDirectory()) || path.startsWith(Environment.getDataDirectory() + "/user")) {
        return INTERNAL_CONTENT_URI;
    }
    return EXTERNAL_CONTENT_URI;
}
#method_after
public static Uri getContentUriForPath(String path) {
    return (path.startsWith(Environment.getStorageDirectory().getAbsolutePath() + "/") ? EXTERNAL_CONTENT_URI : INTERNAL_CONTENT_URI);
}
#end_block

#method_before
public static final Uri getContentUri(String volumeName, long playlistId) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/audio/playlists/" + playlistId + "/members");
}
#method_after
public static final Uri getContentUri(String volumeName, long genreId) {
    return Uri.parse(CONTENT_AUTHORITY_SLASH + volumeName + "/audio/genres/" + genreId + "/members");
}
#end_block

#method_before
public static void cancelThumbnailRequest(ContentResolver cr, long origId, long groupId) {
    InternalThumbnails.cancelThumbnailRequest(cr, origId, EXTERNAL_CONTENT_URI, groupId);
}
#method_after
public static void cancelThumbnailRequest(ContentResolver cr, long origId) {
    InternalThumbnails.cancelThumbnailRequest(cr, origId, EXTERNAL_CONTENT_URI, InternalThumbnails.DEFAULT_GROUP_ID);
}
#end_block

#method_before
public static Bitmap getThumbnail(ContentResolver cr, long origId, long groupId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, groupId, kind, options, EXTERNAL_CONTENT_URI, true);
}
#method_after
public static Bitmap getThumbnail(ContentResolver cr, long origId, int kind, BitmapFactory.Options options) {
    return InternalThumbnails.getThumbnail(cr, origId, InternalThumbnails.DEFAULT_GROUP_ID, kind, options, EXTERNAL_CONTENT_URI, true);
}
#end_block

#method_before
@NonNull
public CommandButton build() {
    return new CommandButton(mCommand, mIconResId, mDisplayName, mExtras, mEnabled);
}
#method_after
@Override
@NonNull
public MediaSession2 build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new SessionCallback() {
        };
    }
    return new MediaSession2(mContext, mId, mSessionPlayer, mSessionActivity, mCallbackExecutor, mCallback);
}
#end_block

#method_before
@Override
public void onAttachedToWindowImpl() {
    // and closed in onDetachedFromWindow().
    if (mMediaPlayer == null) {
        mMediaPlayer = new VideoView2Player(mInstance.getContext());
        mSurfaceView.setMediaPlayer(mMediaPlayer);
        mTextureView.setMediaPlayer(mMediaPlayer);
        mCurrentView.assignSurfaceToMediaPlayer(mMediaPlayer);
        if (mMediaSession != null) {
            mMediaSession.updatePlayer(mMediaPlayer);
        }
    } else {
        if (!mCurrentView.assignSurfaceToMediaPlayer(mMediaPlayer)) {
            Log.w(TAG, "failed to assign surface");
        }
    }
    if (mMediaSession == null) {
        final Context context = mInstance.getContext();
        mMediaSession = new MediaSession2.Builder(context).setPlayer(mMediaPlayer).setId("VideoView2_" + mInstance.toString()).setSessionCallback(mCallbackExecutor, new MediaSessionCallback()).build();
    }
    attachMediaControlView();
    mMediaRouter = MediaRouter.getInstance(mInstance.getContext());
    // TODO: Revisit once ag/4207152 is merged.
    mMediaRouter.setMediaSessionCompat(mMediaSession.getSessionCompat());
    mMediaRouter.addCallback(mRouteSelector, mRouterCallback, MediaRouter.CALLBACK_FLAG_PERFORM_ACTIVE_SCAN);
}
#method_after
@Override
public void onAttachedToWindowImpl() {
    // and closed in onDetachedFromWindow().
    if (mMediaPlayer == null) {
        mMediaPlayer = new VideoView2Player(mInstance.getContext());
        mSurfaceView.setMediaPlayer(mMediaPlayer);
        mTextureView.setMediaPlayer(mMediaPlayer);
        mCurrentView.assignSurfaceToMediaPlayer(mMediaPlayer);
        if (mMediaSession != null) {
            mMediaSession.updatePlayer(mMediaPlayer);
        }
    } else {
        if (!mCurrentView.assignSurfaceToMediaPlayer(mMediaPlayer)) {
            Log.w(TAG, "failed to assign surface");
        }
    }
    ensureSessionWithPlayer(mMediaPlayer);
    attachMediaControlView();
    mMediaRouter = MediaRouter.getInstance(mInstance.getContext());
    // TODO: Revisit once ag/4207152 is merged.
    mMediaRouter.setMediaSessionCompat(mMediaSession.getSessionCompat());
    mMediaRouter.addCallback(mRouteSelector, mRouterCallback, MediaRouter.CALLBACK_FLAG_PERFORM_ACTIVE_SCAN);
}
#end_block

#method_before
void openVideo() {
    if (DEBUG) {
        Log.d(TAG, "openVideo()");
    }
    if (mMediaItem != null) {
        resetPlayer();
        if (isRemotePlayback()) {
            mRoutePlayer.setMediaItem(mMediaItem);
            return;
        }
    }
    try {
        if (mMediaPlayer == null) {
            mMediaPlayer = new VideoView2Player(mInstance.getContext());
        }
        mSurfaceView.setMediaPlayer(mMediaPlayer);
        mTextureView.setMediaPlayer(mMediaPlayer);
        if (!mCurrentView.assignSurfaceToMediaPlayer(mMediaPlayer)) {
            Log.w(TAG, "failed to assign surface");
        }
        mMediaPlayer.registerPlayerCallback(mCallbackExecutor, mMediaPlayerCallback);
        mMediaPlayer.setAudioAttributes(mAudioAttributes);
        if (mMediaSession == null) {
            final Context context = mInstance.getContext();
            mMediaSession = new MediaSession2.Builder(context).setPlayer(mMediaPlayer).setId("VideoView2_" + mInstance.toString()).setSessionCallback(mCallbackExecutor, new MediaSessionCallback()).build();
        } else {
            mMediaSession.updatePlayer(mMediaPlayer);
        }
        mMediaPlayer.setMediaItem(mMediaItem);
        final Context context = mInstance.getContext();
        mSubtitleController = new SubtitleController(context);
        mSubtitleController.registerRenderer(new ClosedCaptionRenderer(context));
        mSubtitleController.registerRenderer(new Cea708CaptionRenderer(context));
        mSubtitleController.setAnchor((SubtitleController.Anchor) mSubtitleAnchorView);
        // we don't set the target state here either, but preserve the
        // target state that was there before.
        mCurrentState = STATE_PREPARING;
        mMediaSession.getPlayer().prepare();
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, "Unable to open content: " + mMediaItem, ex);
        mCurrentState = STATE_ERROR;
        mTargetState = STATE_ERROR;
    }
}
#method_after
void openVideo() {
    if (DEBUG) {
        Log.d(TAG, "openVideo()");
    }
    if (mMediaItem != null) {
        resetPlayer();
        if (isRemotePlayback()) {
            mRoutePlayer.setMediaItem(mMediaItem);
            return;
        }
    }
    try {
        if (mMediaPlayer == null) {
            mMediaPlayer = new VideoView2Player(mInstance.getContext());
        }
        mSurfaceView.setMediaPlayer(mMediaPlayer);
        mTextureView.setMediaPlayer(mMediaPlayer);
        if (!mCurrentView.assignSurfaceToMediaPlayer(mMediaPlayer)) {
            Log.w(TAG, "failed to assign surface");
        }
        mMediaPlayer.registerPlayerCallback(mCallbackExecutor, mMediaPlayerCallback);
        mMediaPlayer.setAudioAttributes(mAudioAttributes);
        ensureSessionWithPlayer(mMediaPlayer);
        mMediaPlayer.setMediaItem(mMediaItem);
        final Context context = mInstance.getContext();
        mSubtitleController = new SubtitleController(context);
        mSubtitleController.registerRenderer(new ClosedCaptionRenderer(context));
        mSubtitleController.registerRenderer(new Cea708CaptionRenderer(context));
        mSubtitleController.setAnchor((SubtitleController.Anchor) mSubtitleAnchorView);
        // we don't set the target state here either, but preserve the
        // target state that was there before.
        mCurrentState = STATE_PREPARING;
        mMediaSession.getPlayer().prepare();
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, "Unable to open content: " + mMediaItem, ex);
        mCurrentState = STATE_ERROR;
        mTargetState = STATE_ERROR;
    }
}
#end_block

#method_before
boolean isRemotePlayback() {
    return mRoutePlayer != null && mMediaSession != null && (mMediaSession.getPlayerConnector() instanceof BaseRemoteMediaPlayerConnector);
}
#method_after
boolean isRemotePlayback() {
    return mRoutePlayer != null && mMediaSession != null && (mMediaSession.getPlayer() instanceof RemoteSessionPlayer2);
}
#end_block

#method_before
@Override
public void onPlayerStateChanged(@NonNull SessionPlayer2 player, @SessionPlayer2.PlayerState int state) {
    if (player != mMediaSession.getPlayer()) {
        if (DEBUG) {
            Log.w(TAG, "onPlayerStateChanged() is ignored. player mismatches.");
        }
    }
    switch(state) {
        case MediaPlayerConnector.PLAYER_STATE_IDLE:
            mCurrentState = STATE_IDLE;
            break;
        case MediaPlayerConnector.PLAYER_STATE_PLAYING:
            mCurrentState = STATE_PLAYING;
            break;
        case MediaPlayerConnector.PLAYER_STATE_PAUSED:
            mCurrentState = STATE_PAUSED;
            break;
        case MediaPlayerConnector.PLAYER_STATE_ERROR:
            mCurrentState = STATE_ERROR;
            break;
    }
}
#method_after
@Override
public void onPlayerStateChanged(@NonNull SessionPlayer2 player, @SessionPlayer2.PlayerState int state) {
    switch(state) {
        case SessionPlayer2.PLAYER_STATE_IDLE:
            mCurrentState = STATE_IDLE;
            break;
        case SessionPlayer2.PLAYER_STATE_PLAYING:
            mCurrentState = STATE_PLAYING;
            break;
        case SessionPlayer2.PLAYER_STATE_PAUSED:
            mCurrentState = STATE_PAUSED;
            break;
        case SessionPlayer2.PLAYER_STATE_ERROR:
            mCurrentState = STATE_ERROR;
            break;
    }
}
#end_block

#method_before
@Override
public final void testRunEnded(long elapsedTime, HashMap<String, Metric> runMetrics) {
    try {
        HashMap<String, Metric> rawValues = getRawMetricsOnly(runMetrics);
        // Add post-processed run metrics.
        Map<String, Metric.Builder> postprocessedResults = processRunMetrics(rawValues);
        addProcessedMetricsToExistingMetrics(postprocessedResults, runMetrics);
        // Add aggregated test metrics.
        Map<String, Metric.Builder> aggregateResults = aggregateTestMetrics(storedTestMetrics);
        addProcessedMetricsToExistingMetrics(aggregateResults, runMetrics);
        // Clear out the stored test metrics.
        storedTestMetrics.clear();
    } catch (RuntimeException e) {
        // Prevent exception from messing up the status reporting.
        CLog.e(e);
    }
    mForwarder.testRunEnded(elapsedTime, runMetrics);
}
#method_after
@Override
public final void testRunEnded(long elapsedTime, HashMap<String, Metric> runMetrics) {
    try {
        HashMap<String, Metric> rawValues = getRawMetricsOnly(runMetrics);
        // Add post-processed run metrics.
        Map<String, Metric.Builder> postprocessedResults = processRunMetrics(rawValues);
        addProcessedMetricsToExistingMetrics(postprocessedResults, runMetrics);
        // Add aggregated test metrics (results from post-processing all test metrics).
        Map<String, Metric.Builder> aggregateResults = processAllTestMetrics(storedTestMetrics);
        addProcessedMetricsToExistingMetrics(aggregateResults, runMetrics);
    } catch (RuntimeException e) {
        // Prevent exception from messing up the status reporting.
        CLog.e(e);
    } finally {
        // Clear out the stored test metrics.
        storedTestMetrics.clear();
    }
    mForwarder.testRunEnded(elapsedTime, runMetrics);
}
#end_block

#method_before
private void addProcessedMetricsToExistingMetrics(Map<String, Metric.Builder> processed, Map<String, Metric> existing) {
    // TODO: Implement this.
    for (Entry<String, Metric.Builder> newEntry : processed.entrySet()) {
        String newKey = newEntry.getKey();
        if (existing.containsKey(newKey)) {
            CLog.e("Key '%s' is already asssociated with a metric and will not be " + "replaced.", newKey);
            continue;
        }
        // Force the metric to 'processed' since generated in a post-processor.
        Metric newMetric = newEntry.getValue().setType(DataType.PROCESSED).build();
        existing.put(newKey, newMetric);
    }
}
#method_after
private void addProcessedMetricsToExistingMetrics(Map<String, Metric.Builder> processed, Map<String, Metric> existing) {
    for (Entry<String, Metric.Builder> newEntry : processed.entrySet()) {
        String newKey = newEntry.getKey();
        if (existing.containsKey(newKey)) {
            CLog.e("Key '%s' is already asssociated with a metric and will not be " + "replaced.", newKey);
            continue;
        }
        // Force the metric to 'processed' since generated in a post-processor.
        Metric newMetric = newEntry.getValue().setType(DataType.PROCESSED).build();
        existing.put(newKey, newMetric);
    }
}
#end_block

#method_before
public static DocString summarize(AhatInstance inst) {
    DocString formatted = new DocString();
    if (inst == null) {
        formatted.append("null");
        return formatted;
    }
    // Annotate new objects as new.
    if (inst.getBaseline().isPlaceHolder()) {
        formatted.append(DocString.added("new "));
    }
    // Annotate deleted objects as deleted.
    if (inst.isPlaceHolder()) {
        formatted.append(DocString.removed("del "));
    }
    // Annotate non-strongly reachable objects as such.
    Reachability reachability = inst.getReachability();
    if (reachability != Reachability.STRONG) {
        formatted.append(reachability.toString() + " ");
    }
    // Annotate roots as roots.
    if (inst.isRoot()) {
        formatted.append("root ");
    }
    DocString linkText = DocString.text(inst.toString());
    if (inst.isPlaceHolder()) {
        // Don't make links to placeholder objects.
        formatted.append(linkText);
    } else {
        URI objTarget = DocString.formattedUri("object?id=0x%x", inst.getId());
        formatted.appendLink(objTarget, linkText);
    }
    // Annotate Strings with their values.
    String stringValue = inst.asString(kMaxChars);
    if (stringValue != null) {
        formatted.appendFormat(" \"%s", stringValue);
        formatted.append(kMaxChars == stringValue.length() ? "..." : "\"");
    }
    // Annotate Reference with its referent
    AhatInstance referent = inst.getReferent();
    if (referent != null) {
        formatted.append(" for ");
        // It should not be possible for a referent to refer back to the
        // reference object, even indirectly, so there shouldn't be any issues
        // with infinite recursion here.
        formatted.append(summarize(referent));
    }
    // Annotate DexCache with its location.
    String dexCacheLocation = inst.getDexCacheLocation(kMaxChars);
    if (dexCacheLocation != null) {
        formatted.appendFormat(" for %s", dexCacheLocation);
        if (kMaxChars == dexCacheLocation.length()) {
            formatted.append("...");
        }
    }
    // Annotate bitmaps with a thumbnail.
    AhatInstance bitmap = inst.getAssociatedBitmapInstance();
    if (bitmap != null) {
        URI uri = DocString.formattedUri("bitmap?id=0x%x", bitmap.getId());
        formatted.appendThumbnail(uri, "bitmap image");
    }
    // Annotate $classOverhead arrays
    AhatClassObj cls = inst.getAssociatedClassForOverhead();
    if (cls != null) {
        formatted.append(" overhead for ");
        formatted.append(summarize(cls));
    }
    // Annotate BinderProxy with its interface name.
    String binderProxyInterface = inst.getBinderProxyInterfaceName();
    if (binderProxyInterface != null) {
        formatted.appendFormat(" for %s", binderProxyInterface);
    }
    // Annotate Binder services with their interface name.
    String binderStubInterface = inst.getBinderStubInterfaceName();
    if (binderStubInterface != null) {
        if (binderStubInterface.equals("")) {
            formatted.appendFormat(" binder token");
        } else {
            formatted.appendFormat(" binder service for %s", binderStubInterface);
        }
    }
    return formatted;
}
#method_after
public static DocString summarize(AhatInstance inst) {
    DocString formatted = new DocString();
    if (inst == null) {
        formatted.append("null");
        return formatted;
    }
    // Annotate new objects as new.
    if (inst.getBaseline().isPlaceHolder()) {
        formatted.append(DocString.added("new "));
    }
    // Annotate deleted objects as deleted.
    if (inst.isPlaceHolder()) {
        formatted.append(DocString.removed("del "));
    }
    // Annotate non-strongly reachable objects as such.
    Reachability reachability = inst.getReachability();
    if (reachability != Reachability.STRONG) {
        formatted.append(reachability.toString() + " ");
    }
    // Annotate roots as roots.
    if (inst.isRoot()) {
        formatted.append("root ");
    }
    DocString linkText = DocString.text(inst.toString());
    if (inst.isPlaceHolder()) {
        // Don't make links to placeholder objects.
        formatted.append(linkText);
    } else {
        URI objTarget = DocString.formattedUri("object?id=0x%x", inst.getId());
        formatted.appendLink(objTarget, linkText);
    }
    // Annotate Strings with their values.
    String stringValue = inst.asString(kMaxChars);
    if (stringValue != null) {
        formatted.appendFormat(" \"%s", stringValue);
        formatted.append(kMaxChars == stringValue.length() ? "..." : "\"");
    }
    // Annotate Reference with its referent
    AhatInstance referent = inst.getReferent();
    if (referent != null) {
        formatted.append(" for ");
        // It should not be possible for a referent to refer back to the
        // reference object, even indirectly, so there shouldn't be any issues
        // with infinite recursion here.
        formatted.append(summarize(referent));
    }
    // Annotate DexCache with its location.
    String dexCacheLocation = inst.getDexCacheLocation(kMaxChars);
    if (dexCacheLocation != null) {
        formatted.appendFormat(" for %s", dexCacheLocation);
        if (kMaxChars == dexCacheLocation.length()) {
            formatted.append("...");
        }
    }
    // Annotate bitmaps with a thumbnail.
    AhatInstance bitmap = inst.getAssociatedBitmapInstance();
    if (bitmap != null) {
        URI uri = DocString.formattedUri("bitmap?id=0x%x", bitmap.getId());
        formatted.appendThumbnail(uri, "bitmap image");
    }
    // Annotate $classOverhead arrays
    AhatClassObj cls = inst.getAssociatedClassForOverhead();
    if (cls != null) {
        formatted.append(" overhead for ");
        formatted.append(summarize(cls));
    }
    // Annotate BinderProxy with its interface name.
    String binderProxyInterface = inst.getBinderProxyInterfaceName();
    if (binderProxyInterface != null) {
        formatted.appendFormat(" for %s", binderProxyInterface);
    }
    // Annotate Binder tokens with their descriptor
    String binderTokenDescriptor = inst.getBinderTokenDescriptor();
    if (binderTokenDescriptor != null) {
        formatted.appendFormat(" binder token (%s)", binderTokenDescriptor);
    }
    // Annotate Binder services with their interface name.
    String binderStubInterface = inst.getBinderStubInterfaceName();
    if (binderStubInterface != null) {
        formatted.appendFormat(" binder service (%s)", binderStubInterface);
    }
    return formatted;
}
#end_block

#method_before
@Override
public String getBinderStubInterfaceName() {
    if (isInstanceOfClass("android.os.Binder")) {
        Value value = getField("mDescriptor");
        if (value != null) {
            AhatInstance inst = value.asAhatInstance();
            return inst.asString();
        } else {
            // Probably a binder token
            return "";
        }
    } else {
        return null;
    }
}
#method_after
@Override
public String getBinderStubInterfaceName() {
    String descriptor = getBinderDescriptor();
    if (descriptor == null || descriptor.isEmpty()) {
        // Binder interface stubs always have a non-empty descriptor
        return null;
    }
    // auto-generated descriptor$Stub class.
    if (isInstanceOfClass(descriptor + "$Stub")) {
        return descriptor;
    }
    return null;
}
#end_block

#method_before
@Test
public void binderStub() throws IOException {
    TestDump dump = TestDump.getTestDump();
    // Regular binder service returns the interface name
    AhatInstance binderService = dump.getDumpedAhatInstance("binderService");
    assertEquals("IDumpedManager", binderService.getBinderStubInterfaceName());
    // Binder tokens return an empty string
    AhatInstance binderToken = dump.getDumpedAhatInstance("binderToken");
    assertEquals("", binderToken.getBinderStubInterfaceName());
    // Random non-binder object returns null
    AhatInstance nonBinderObject = dump.getDumpedAhatInstance("anObject");
    assertNull(nonBinderObject.getBinderStubInterfaceName());
}
#method_after
@Test
public void binderStub() throws IOException {
    TestDump dump = TestDump.getTestDump();
    // Regular binder service returns the interface name and no token descriptor
    AhatInstance binderService = dump.getDumpedAhatInstance("binderService");
    assertEquals("DumpedStuff$IDumpedManager", binderService.getBinderStubInterfaceName());
    // Binder tokens aren't considered binder services
    AhatInstance binderToken = dump.getDumpedAhatInstance("binderToken");
    assertEquals(null, binderToken.getBinderStubInterfaceName());
    // Named binder tokens aren't considered binder services
    AhatInstance namedBinderToken = dump.getDumpedAhatInstance("namedBinderToken");
    assertEquals(null, namedBinderToken.getBinderStubInterfaceName());
    // Fake service returns null
    AhatInstance fakeService = dump.getDumpedAhatInstance("fakeBinderService");
    assertNull(fakeService.getBinderStubInterfaceName());
    // Random non-binder object returns null
    AhatInstance nonBinderObject = dump.getDumpedAhatInstance("anObject");
    assertNull(nonBinderObject.getBinderStubInterfaceName());
}
#end_block

#method_before
@Override
public void play() {
    SessionPlayer2 player;
    synchronized (mLock) {
        player = mPlayer;
    }
    if (player != null) {
        if (player.getPlayerState() == PLAYER_STATE_IDLE) {
            // Note: Ideally audio focus should be requested only when play() is called,
            // but it would be fine calling prepare() after the audio focus here because
            // play() will be triggered immediately after.
            player.prepare();
        }
        player.play();
    } else if (DEBUG) {
        Log.d(TAG, "API calls after the close()", new IllegalStateException());
    }
}
#method_after
@Override
public void play() {
    SessionPlayer2 player;
    synchronized (mLock) {
        player = mPlayer;
    }
    if (player != null) {
        if (player.getPlayerState() == PLAYER_STATE_IDLE) {
            player.prepare();
        }
        player.play();
    } else if (DEBUG) {
        Log.d(TAG, "API calls after the close()", new IllegalStateException());
    }
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> play() {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    if (mAudioFocusHandler.onPlayRequested()) {
        synchronized (mCallTypeAndFutures) {
            mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_PLAY, future));
            mPlayer.play();
        }
    } else {
        future.set(new CommandResult2(RESULT_CODE_ERROR_UNKNOWN, null));
    }
    return future;
}
#method_after
@Override
public ListenableFuture<CommandResult2> play() {
    // TODO: Make commands be executed sequentially
    if (mAudioFocusHandler.onPlayRequested()) {
        final SettableFuture<CommandResult2> future = SettableFuture.create();
        synchronized (mPendingCommands) {
            Object token = mPlayer._play();
            addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_PLAY, future, token);
        }
        return future;
    } else {
        return createFutureForResultCodeInternal(RESULT_CODE_ERROR_UNKNOWN);
    }
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> pause() {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    mAudioFocusHandler.onPauseRequested();
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_PAUSE, future));
        mPlayer.pause();
    }
    return future;
}
#method_after
@Override
public ListenableFuture<CommandResult2> pause() {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    // TODO: Make commands be executed sequentially
    mAudioFocusHandler.onPauseRequested();
    synchronized (mPendingCommands) {
        Object token = mPlayer._pause();
        addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_PAUSE, future, token);
    }
    return future;
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> prepare() {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_PREPARE, future));
        mPlayer.prepare();
    }
    // TODO: Changing buffering state is not correct. Think about changing MP2 event APIs for
    // the initial buffering for prepare case.
    setBufferingState(mPlayer.getCurrentMediaItem(), BUFFERING_STATE_BUFFERING_AND_STARVED);
    return future;
}
#method_after
@Override
public ListenableFuture<CommandResult2> prepare() {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mPendingCommands) {
        Object token = mPlayer._prepare();
        addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_PREPARE, future, token);
    }
    // TODO: Changing buffering state is not correct. Think about changing MP2 event APIs for
    // the initial buffering for prepare case.
    setBufferingState(mPlayer.getCurrentMediaItem(), BUFFERING_STATE_BUFFERING_AND_STARVED);
    return future;
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> seekTo(long position) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_SEEK_TO, future));
        mPlayer.seekTo(position);
    }
    return future;
}
#method_after
@Override
public ListenableFuture<CommandResult2> seekTo(long position) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mPendingCommands) {
        Object token = mPlayer._seekTo(position);
        addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SEEK_TO, future, token);
    }
    return future;
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> setPlaybackSpeed(float playbackSpeed) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_SET_PLAYBACK_PARAMS, future));
        mPlayer.setPlaybackParams(new PlaybackParams2.Builder(mPlayer.getPlaybackParams().getPlaybackParams()).setSpeed(playbackSpeed).build());
    }
    return future;
}
#method_after
@Override
public ListenableFuture<CommandResult2> setPlaybackSpeed(float playbackSpeed) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mPendingCommands) {
        Object token = mPlayer._setPlaybackParams(new PlaybackParams2.Builder(mPlayer.getPlaybackParams().getPlaybackParams()).setSpeed(playbackSpeed).build());
        addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_PLAYBACK_PARAMS, future, token);
    }
    return future;
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> setAudioAttributes(AudioAttributesCompat attr) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_SET_AUDIO_ATTRIBUTES, future));
        mPlayer.setAudioAttributes(attr);
    }
    return future;
}
#method_after
@Override
public ListenableFuture<CommandResult2> setAudioAttributes(AudioAttributesCompat attr) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mPendingCommands) {
        Object token = mPlayer._setAudioAttributes(attr);
        addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_AUDIO_ATTRIBUTES, future, token);
    }
    return future;
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> setMediaItem(MediaItem2 item) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE, future));
        mPlayer.setMediaItem(item);
    }
    return future;
}
#method_after
@Override
public ListenableFuture<CommandResult2> setMediaItem(@NonNull MediaItem2 item) {
    if (item == null) {
        throw new IllegalArgumentException("item shouldn't be null");
    }
    synchronized (mPlaylistLock) {
        mPlaylist.clear();
        mShuffledList.clear();
        mCurPlaylistItem = item;
        mNextPlaylistItem = null;
        mCurrentShuffleIdx = END_OF_PLAYLIST;
    }
    return setPlayerMediaItemsInternal(item, null);
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> setPlaylist(List<MediaItem2> list, MediaMetadata2 metadata) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public ListenableFuture<CommandResult2> setPlaylist(@NonNull final List<MediaItem2> playlist, @Nullable final MediaMetadata2 metadata) {
    if (playlist == null || playlist.isEmpty()) {
        throw new IllegalArgumentException("playlist shouldn't be null or empty");
    }
    MediaItem2 curItem;
    MediaItem2 nextItem;
    synchronized (mPlaylistLock) {
        mPlaylistMetadata = metadata;
        mPlaylist.clear();
        mShuffledList.clear();
        mPlaylist.addAll(playlist);
        applyShuffleModeLocked();
        mCurrentShuffleIdx = 0;
        updateAndGetCurrentNextItemIfNeededLocked();
        curItem = mCurPlaylistItem;
        nextItem = mNextPlaylistItem;
    }
    notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

        @Override
        public void callCallback(SessionPlayer2.PlayerCallback callback) {
            callback.onPlaylistChanged(XMediaPlayer.this, playlist, metadata);
        }
    });
    if (curItem != null) {
        return setPlayerMediaItemsInternal(curItem, nextItem);
    }
    return createFutureForResultCodeInternal(RESULT_CODE_NO_ERROR);
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> addPlaylistItem(int index, MediaItem2 item) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public ListenableFuture<CommandResult2> addPlaylistItem(int index, MediaItem2 item) {
    if (item == null) {
        throw new IllegalArgumentException("item shouldn't be null");
    }
    if (index < 0) {
        throw new IllegalArgumentException("index shouldn't be negative integer");
    }
    synchronized (mPlaylistLock) {
        if (mPlaylist.contains(item)) {
            throw new IllegalStateException("The item is already in the playlist: " + item);
        }
    }
    Pair<MediaItem2, MediaItem2> updatedCurNextItem;
    synchronized (mPlaylistLock) {
        index = clamp(index, mPlaylist.size());
        int addedShuffleIdx = index;
        mPlaylist.add(index, item);
        if (mShuffleMode == MediaPlaylistAgent.SHUFFLE_MODE_NONE) {
            mShuffledList.add(index, item);
        } else {
            // Add the item in random position of mShuffledList.
            addedShuffleIdx = (int) (Math.random() * (mShuffledList.size() + 1));
            mShuffledList.add(addedShuffleIdx, item);
        }
        if (addedShuffleIdx <= mCurrentShuffleIdx) {
            mCurrentShuffleIdx++;
        }
        updatedCurNextItem = updateAndGetCurrentNextItemIfNeededLocked();
    }
    final List<MediaItem2> playlist = getPlaylist();
    final MediaMetadata2 metadata = getPlaylistMetadata();
    notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

        @Override
        public void callCallback(SessionPlayer2.PlayerCallback callback) {
            callback.onPlaylistChanged(XMediaPlayer.this, playlist, metadata);
        }
    });
    if (updatedCurNextItem.second == null) {
        return createFutureForResultCodeInternal(RESULT_CODE_NO_ERROR);
    }
    return setNextMediaItemInternal(updatedCurNextItem.second);
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> removePlaylistItem(MediaItem2 item) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public ListenableFuture<CommandResult2> removePlaylistItem(MediaItem2 item) {
    if (item == null) {
        throw new IllegalArgumentException("item shouldn't be null");
    }
    int removedItemShuffleIdx;
    MediaItem2 curItem;
    MediaItem2 nextItem;
    Pair<MediaItem2, MediaItem2> updatedCurNextItem = null;
    synchronized (mPlaylistLock) {
        removedItemShuffleIdx = mShuffledList.indexOf(item);
        if (removedItemShuffleIdx >= 0) {
            mPlaylist.remove(item);
            mShuffledList.remove(removedItemShuffleIdx);
            if (removedItemShuffleIdx < mCurrentShuffleIdx) {
                mCurrentShuffleIdx--;
            }
            updatedCurNextItem = updateAndGetCurrentNextItemIfNeededLocked();
        }
        curItem = mCurPlaylistItem;
        nextItem = mNextPlaylistItem;
    }
    if (removedItemShuffleIdx >= 0) {
        final List<MediaItem2> playlist = getPlaylist();
        final MediaMetadata2 metadata = getPlaylistMetadata();
        notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

            @Override
            public void callCallback(SessionPlayer2.PlayerCallback callback) {
                callback.onPlaylistChanged(XMediaPlayer.this, playlist, metadata);
            }
        });
    }
    if (updatedCurNextItem != null) {
        if (updatedCurNextItem.first != null) {
            return setPlayerMediaItemsInternal(curItem, nextItem);
        } else if (updatedCurNextItem.second != null) {
            return setNextMediaItemInternal(nextItem);
        }
    }
    return createFutureForResultCodeInternal(RESULT_CODE_NO_ERROR);
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> replacePlaylistItem(int index, MediaItem2 item) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public ListenableFuture<CommandResult2> replacePlaylistItem(int index, MediaItem2 item) {
    if (item == null) {
        throw new IllegalArgumentException("item shouldn't be null");
    }
    if (index < 0) {
        throw new IllegalArgumentException("index shouldn't be negative integer");
    }
    synchronized (mPlaylistLock) {
        int itemIdx = mPlaylist.indexOf(item);
        if (itemIdx >= 0 && index == itemIdx) {
            throw new IllegalStateException("The item is already in the playlist: " + item);
        }
    }
    MediaItem2 curItem;
    MediaItem2 nextItem;
    Pair<MediaItem2, MediaItem2> updatedCurNextItem = null;
    synchronized (mPlaylistLock) {
        if (index >= mPlaylist.size()) {
            return createFutureForResultCodeInternal(RESULT_CODE_BAD_VALUE);
        }
        int shuffleIdx = mShuffledList.indexOf(mPlaylist.get(index));
        mShuffledList.set(shuffleIdx, item);
        mPlaylist.set(index, item);
        updatedCurNextItem = updateAndGetCurrentNextItemIfNeededLocked();
        curItem = mCurPlaylistItem;
        nextItem = mNextPlaylistItem;
    }
    // TODO: Should we notify current media item changed if it is replaced?
    final List<MediaItem2> playlist = getPlaylist();
    final MediaMetadata2 metadata = getPlaylistMetadata();
    notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

        @Override
        public void callCallback(SessionPlayer2.PlayerCallback callback) {
            callback.onPlaylistChanged(XMediaPlayer.this, playlist, metadata);
        }
    });
    if (updatedCurNextItem != null) {
        if (updatedCurNextItem.first != null) {
            return setPlayerMediaItemsInternal(curItem, nextItem);
        } else if (updatedCurNextItem.second != null) {
            return setNextMediaItemInternal(nextItem);
        }
    }
    return createFutureForResultCodeInternal(RESULT_CODE_NO_ERROR);
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> skipToPreviousItem() {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public ListenableFuture<CommandResult2> skipToPreviousItem() {
    MediaItem2 curItem;
    MediaItem2 nextItem;
    synchronized (mPlaylistLock) {
        int prevShuffleIdx = mCurrentShuffleIdx - 1;
        if (prevShuffleIdx < 0) {
            if (mRepeatMode == REPEAT_MODE_ALL || mRepeatMode == REPEAT_MODE_GROUP) {
                prevShuffleIdx = mShuffledList.size() - 1;
            } else {
                return createFutureForResultCodeInternal(RESULT_CODE_INVALID_OPERATION);
            }
        }
        mCurrentShuffleIdx = prevShuffleIdx;
        updateAndGetCurrentNextItemIfNeededLocked();
        curItem = mCurPlaylistItem;
        nextItem = mNextPlaylistItem;
    }
    return setPlayerMediaItemsInternal(curItem, nextItem);
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> skipToNextItem() {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public ListenableFuture<CommandResult2> skipToNextItem() {
    MediaItem2 curItem;
    MediaItem2 nextItem;
    synchronized (mPlaylistLock) {
        int nextShuffleIdx = mCurrentShuffleIdx + 1;
        if (nextShuffleIdx >= mShuffledList.size()) {
            if (mRepeatMode == REPEAT_MODE_ALL || mRepeatMode == REPEAT_MODE_GROUP) {
                nextShuffleIdx = 0;
            } else {
                return createFutureForResultCodeInternal(RESULT_CODE_INVALID_OPERATION);
            }
        }
        mCurrentShuffleIdx = nextShuffleIdx;
        updateAndGetCurrentNextItemIfNeededLocked();
        curItem = mCurPlaylistItem;
        nextItem = mNextPlaylistItem;
    }
    return curItem != null ? setPlayerMediaItemsInternal(curItem, nextItem) : skipToNextInternal();
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> skipToPlaylistItem(MediaItem2 item) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public ListenableFuture<CommandResult2> skipToPlaylistItem(MediaItem2 item) {
    MediaItem2 curItem;
    MediaItem2 nextItem;
    synchronized (mPlaylistLock) {
        int newShuffleIdx = mShuffledList.indexOf(item);
        if (newShuffleIdx < 0) {
            return createFutureForResultCodeInternal(RESULT_CODE_BAD_VALUE);
        }
        mCurrentShuffleIdx = newShuffleIdx;
        updateAndGetCurrentNextItemIfNeededLocked();
        curItem = mCurPlaylistItem;
        nextItem = mNextPlaylistItem;
    }
    return setPlayerMediaItemsInternal(curItem, nextItem);
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> updatePlaylistMetadata(MediaMetadata2 metadata) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public ListenableFuture<CommandResult2> updatePlaylistMetadata(final MediaMetadata2 metadata) {
    synchronized (mPlaylistLock) {
        mPlaylistMetadata = metadata;
    }
    notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

        @Override
        public void callCallback(SessionPlayer2.PlayerCallback callback) {
            callback.onPlaylistMetadataChanged(XMediaPlayer.this, metadata);
        }
    });
    return createFutureForResultCodeInternal(RESULT_CODE_NO_ERROR);
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> setRepeatMode(int repeatMode) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public ListenableFuture<CommandResult2> setRepeatMode(final int repeatMode) {
    if (repeatMode < SessionPlayer2.REPEAT_MODE_NONE || repeatMode > SessionPlayer2.REPEAT_MODE_GROUP) {
        return createFutureForResultCodeInternal(RESULT_CODE_BAD_VALUE);
    }
    boolean changed;
    synchronized (mPlaylistLock) {
        changed = mRepeatMode != repeatMode;
        mRepeatMode = repeatMode;
    }
    if (changed) {
        notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

            @Override
            public void callCallback(SessionPlayer2.PlayerCallback callback) {
                callback.onRepeatModeChanged(XMediaPlayer.this, repeatMode);
            }
        });
    }
    return createFutureForResultCodeInternal(RESULT_CODE_NO_ERROR);
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> setShuffleMode(int shuffleMode) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public ListenableFuture<CommandResult2> setShuffleMode(final int shuffleMode) {
    if (shuffleMode < SessionPlayer2.SHUFFLE_MODE_NONE || shuffleMode > SessionPlayer2.SHUFFLE_MODE_GROUP) {
        return createFutureForResultCodeInternal(RESULT_CODE_BAD_VALUE);
    }
    boolean changed;
    synchronized (mPlaylistLock) {
        changed = mShuffleMode != shuffleMode;
        mShuffleMode = shuffleMode;
    }
    if (changed) {
        notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

            @Override
            public void callCallback(SessionPlayer2.PlayerCallback callback) {
                callback.onShuffleModeChanged(XMediaPlayer.this, shuffleMode);
            }
        });
    }
    return createFutureForResultCodeInternal(RESULT_CODE_NO_ERROR);
}
#end_block

#method_before
@Override
public List<MediaItem2> getPlaylist() {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public List<MediaItem2> getPlaylist() {
    synchronized (mPlaylistLock) {
        return mPlaylist.isEmpty() ? null : new ArrayList<>(mPlaylist);
    }
}
#end_block

#method_before
@Override
public MediaMetadata2 getPlaylistMetadata() {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public MediaMetadata2 getPlaylistMetadata() {
    synchronized (mPlaylistLock) {
        return mPlaylistMetadata;
    }
}
#end_block

#method_before
@Override
public int getRepeatMode() {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public int getRepeatMode() {
    synchronized (mPlaylistLock) {
        return mRepeatMode;
    }
}
#end_block

#method_before
@Override
public int getShuffleMode() {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public int getShuffleMode() {
    synchronized (mPlaylistLock) {
        return mShuffleMode;
    }
}
#end_block

#method_before
@Override
public MediaItem2 getCurrentMediaItem() {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public MediaItem2 getCurrentMediaItem() {
    return mPlayer.getCurrentMediaItem();
}
#end_block

#method_before
public void reset() {
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.clear();
        mPlayer.reset();
    }
    synchronized (mStateLock) {
        mState = PLAYER_STATE_IDLE;
        mMediaItemToBuffState.clear();
    }
}
#method_after
public void reset() {
    mPlayer.reset();
    synchronized (mPendingCommands) {
        // Cancel the pending futures.
        for (PendingCommand c : mPendingCommands) {
            c.mFuture.cancel(true);
        }
        mPendingCommands.clear();
    }
    synchronized (mStateLock) {
        mState = PLAYER_STATE_IDLE;
        mMediaItemToBuffState.clear();
    }
    synchronized (mPlaylistLock) {
        mPlaylist.clear();
        mShuffledList.clear();
        mCurPlaylistItem = null;
        mNextPlaylistItem = null;
        mCurrentShuffleIdx = END_OF_PLAYLIST;
        mSetMediaItemCalled = false;
    }
}
#end_block

#method_before
public ListenableFuture<CommandResult2> setSurface(Surface surface) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_SET_SURFACE, future));
        mPlayer.setSurface(surface);
    }
    return future;
}
#method_after
public ListenableFuture<CommandResult2> setSurface(Surface surface) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mPendingCommands) {
        Object token = mPlayer._setSurface(surface);
        addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_SURFACE, future, token);
    }
    return future;
}
#end_block

#method_before
public ListenableFuture<CommandResult2> setPlayerVolume(float volume) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_SET_PLAYER_VOLUME, future));
        mPlayer.setPlayerVolume(volume);
    }
    return future;
}
#method_after
public ListenableFuture<CommandResult2> setPlayerVolume(float volume) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mPendingCommands) {
        Object token = mPlayer._setPlayerVolume(volume);
        addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_PLAYER_VOLUME, future, token);
    }
    return future;
}
#end_block

#method_before
public ListenableFuture<CommandResult2> setPlaybackParams(@NonNull PlaybackParams2 params) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_SET_PLAYBACK_PARAMS, future));
        mPlayer.setPlaybackParams(params);
    }
    return future;
}
#method_after
public ListenableFuture<CommandResult2> setPlaybackParams(@NonNull PlaybackParams2 params) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mPendingCommands) {
        Object token = mPlayer._setPlaybackParams(params);
        addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_PLAYBACK_PARAMS, future, token);
    }
    return future;
}
#end_block

#method_before
public ListenableFuture<CommandResult2> seekTo(long msec, @SeekMode int mode) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    int mp2SeekMode = sSeekModeMap.getOrDefault(mode, SEEK_NEXT_SYNC);
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_SEEK_TO, future));
        mPlayer.seekTo(msec, mp2SeekMode);
    }
    return future;
}
#method_after
public ListenableFuture<CommandResult2> seekTo(long msec, @SeekMode int mode) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    int mp2SeekMode = sSeekModeMap.getOrDefault(mode, SEEK_NEXT_SYNC);
    synchronized (mPendingCommands) {
        Object token = mPlayer._seekTo(msec, mp2SeekMode);
        addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SEEK_TO, future, token);
    }
    return future;
}
#end_block

#method_before
public ListenableFuture<CommandResult2> setAudioSessionId(int sessionId) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_SET_AUDIO_SESSION_ID, future));
        mPlayer.setAudioSessionId(sessionId);
    }
    return future;
}
#method_after
public ListenableFuture<CommandResult2> setAudioSessionId(int sessionId) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mPendingCommands) {
        Object token = mPlayer._setAudioSessionId(sessionId);
        addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_AUDIO_SESSION_ID, future, token);
    }
    return future;
}
#end_block

#method_before
public ListenableFuture<CommandResult2> attachAuxEffect(int effectId) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_ATTACH_AUX_EFFECT, future));
        mPlayer.attachAuxEffect(effectId);
    }
    return future;
}
#method_after
public ListenableFuture<CommandResult2> attachAuxEffect(int effectId) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mPendingCommands) {
        Object token = mPlayer._attachAuxEffect(effectId);
        addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_ATTACH_AUX_EFFECT, future, token);
    }
    return future;
}
#end_block

#method_before
public ListenableFuture<CommandResult2> setAuxEffectSendLevel(float level) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_SET_AUX_EFFECT_SEND_LEVEL, future));
        mPlayer.setAuxEffectSendLevel(level);
    }
    return future;
}
#method_after
public ListenableFuture<CommandResult2> setAuxEffectSendLevel(float level) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mPendingCommands) {
        Object token = mPlayer._setAuxEffectSendLevel(level);
        addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SET_AUX_EFFECT_SEND_LEVEL, future, token);
    }
    return future;
}
#end_block

#method_before
public ListenableFuture<CommandResult2> selectTrack(int index) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_SELECT_TRACK, future));
        mPlayer.selectTrack(index);
    }
    return future;
}
#method_after
public ListenableFuture<CommandResult2> selectTrack(int index) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mPendingCommands) {
        Object token = mPlayer._selectTrack(index);
        addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_SELECT_TRACK, future, token);
    }
    return future;
}
#end_block

#method_before
public ListenableFuture<CommandResult2> deselectTrack(int index) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_DESELECT_TRACK, future));
        mPlayer.deselectTrack(index);
    }
    return future;
}
#method_after
public ListenableFuture<CommandResult2> deselectTrack(int index) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mPendingCommands) {
        Object token = mPlayer._deselectTrack(index);
        addPendingCommandLocked(MediaPlayer2.CALL_COMPLETED_DESELECT_TRACK, future, token);
    }
    return future;
}
#end_block

#method_before
@Override
public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
    Pair<Integer, SettableFuture<CommandResult2>> pair;
    synchronized (mCallTypeAndFutures) {
        pair = mCallTypeAndFutures.pollFirst();
    }
    if (what != pair.first) {
        Log.w(TAG, "Call type does not match. expeced:" + pair.first + " actual:" + what);
        status = MediaPlayer2.CALL_STATUS_ERROR_UNKNOWN;
    }
    if (status == MediaPlayer2.CALL_STATUS_NO_ERROR) {
        switch(what) {
            case MediaPlayer2.CALL_COMPLETED_PREPARE:
            case MediaPlayer2.CALL_COMPLETED_PAUSE:
                setState(PLAYER_STATE_PAUSED);
                break;
            case MediaPlayer2.CALL_COMPLETED_PLAY:
                setState(PLAYER_STATE_PLAYING);
                break;
            case MediaPlayer2.CALL_COMPLETED_SEEK_TO:
                final long pos = mPlayer.getCurrentPosition();
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer2.PlayerCallback callback) {
                        callback.onSeekCompleted(XMediaPlayer.this, pos);
                    }
                });
                break;
            case MediaPlayer2.CALL_COMPLETED_SET_PLAYBACK_PARAMS:
                // TODO: Need to check if the speed value is really changed.
                final float speed = mPlayer.getPlaybackParams().getSpeed();
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer2.PlayerCallback callback) {
                        callback.onPlaybackSpeedChanged(XMediaPlayer.this, speed);
                    }
                });
                break;
        }
    }
    // TODO: more handling on listenable future. e.g. Canceling.
    Integer resultCode = sResultCodeMap.get(status);
    pair.second.set(new CommandResult2(resultCode == null ? RESULT_CODE_ERROR_UNKNOWN : resultCode, item));
}
#method_after
@Override
public void onCallCompleted(MediaPlayer2 mp, final MediaItem2 item, int what, int status) {
    PendingCommand expected;
    synchronized (mPendingCommands) {
        expected = mPendingCommands.pollFirst();
    }
    if (expected == null) {
        Log.i(TAG, "No matching call type for " + what + ". Possibly because of reset().");
        return;
    }
    if (what != expected.mCallType) {
        Log.w(TAG, "Call type does not match. expeced:" + expected.mCallType + " actual:" + what);
        status = MediaPlayer2.CALL_STATUS_ERROR_UNKNOWN;
    }
    if (status == MediaPlayer2.CALL_STATUS_NO_ERROR) {
        switch(what) {
            case MediaPlayer2.CALL_COMPLETED_PREPARE:
            case MediaPlayer2.CALL_COMPLETED_PAUSE:
                setState(PLAYER_STATE_PAUSED);
                break;
            case MediaPlayer2.CALL_COMPLETED_PLAY:
                setState(PLAYER_STATE_PLAYING);
                break;
            case MediaPlayer2.CALL_COMPLETED_SEEK_TO:
                final long pos = mPlayer.getCurrentPosition();
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer2.PlayerCallback callback) {
                        callback.onSeekCompleted(XMediaPlayer.this, pos);
                    }
                });
                break;
            case MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE:
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer2.PlayerCallback callback) {
                        callback.onCurrentMediaItemChanged(XMediaPlayer.this, item);
                    }
                });
                break;
            case MediaPlayer2.CALL_COMPLETED_SET_PLAYBACK_PARAMS:
                // TODO: Need to check if the speed value is really changed.
                final float speed = mPlayer.getPlaybackParams().getSpeed();
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer2.PlayerCallback callback) {
                        callback.onPlaybackSpeedChanged(XMediaPlayer.this, speed);
                    }
                });
                break;
        }
    }
    Integer resultCode = sResultCodeMap.get(status);
    expected.mFuture.set(new CommandResult2(resultCode == null ? RESULT_CODE_ERROR_UNKNOWN : resultCode, item));
    PendingCommand command;
    // TODO: Make commands be executed sequentially
    while (true) {
        synchronized (mPendingCommands) {
            command = mPendingCommands.peekFirst();
        }
        if (command == null || command.mCallType > CALL_COMPLETE_PLAYLIST_BASE) {
            break;
        }
        command.mFuture.set(new CommandResult2(CALL_COMPLETE_PLAYLIST_BASE - command.mCallType, item));
        synchronized (mPendingCommands) {
            mPendingCommands.removeFirst();
        }
    }
}
#end_block

#method_before
@NonNull
public CommandButton build() {
    return new CommandButton(mCommand, mIconResId, mDisplayName, mExtras, mEnabled);
}
#method_after
@Override
@NonNull
public MediaSession2 build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new SessionCallback() {
        };
    }
    return new MediaSession2(mContext, mId, mSessionPlayer, mSessionActivity, mCallbackExecutor, mCallback);
}
#end_block

#method_before
@Test
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.P)
public void testAudioFocus_setVolumeZeroWhenAudioAttributesIsMissing() throws Exception {
    prepareLooper();
    // Request an audio focus in advance.
    requestAudioFocus(AUDIOFOCUS_GAIN);
    initPlayer(null);
    mPlayer.play();
    assertNoAudioFocusChanges(AUDIOFOCUS_GAIN);
    assertEquals(0, mPlayer.getPlayerVolume(), 0.1f);
}
#method_after
@Test
public void testAudioFocus_setVolumeZeroWhenAudioAttributesIsMissing() throws Exception {
    prepareLooper();
    // Request an audio focus in advance.
    requestAudioFocus(AUDIOFOCUS_GAIN);
    initPlayer(null);
    mPlayer.play();
    assertNoAudioFocusChanges(AUDIOFOCUS_GAIN);
    assertEquals(0, mPlayer.getPlayerVolume(), 0.1f);
}
#end_block

#method_before
@Test
@LargeTest
public void testNullMedia2DataSourceIsRejected() throws Exception {
    assertNotEquals(XMediaPlayer.RESULT_CODE_NO_ERROR, mPlayer.setMediaItem((MediaItem2) null).get().getResultCode());
}
#method_after
@Test
@LargeTest
public void testNullMedia2DataSourceIsRejected() throws Exception {
    try {
        mPlayer.setMediaItem(null);
        fail();
    } catch (IllegalArgumentException e) {
    // Expected exception
    }
}
#end_block

#method_before
@Before
@CallSuper
public void setUp() throws Throwable {
    mInstrumentation = InstrumentationRegistry.getInstrumentation();
    mKeyguardManager = (KeyguardManager) mInstrumentation.getTargetContext().getSystemService(KEYGUARD_SERVICE);
    mActivity = mActivityRule.getActivity();
    setKeepScreenOn();
    try {
        mActivityRule.runOnUiThread(new Runnable() {

            public void run() {
                mPlayer = new XMediaPlayer(mActivity);
            }
        });
    } catch (Throwable e) {
        fail();
    }
    mContext = mActivityRule.getActivity();
    mResources = mContext.getResources();
    mExecutor = Executors.newFixedThreadPool(1);
}
#method_after
@Before
@CallSuper
public void setUp() throws Throwable {
    mInstrumentation = InstrumentationRegistry.getInstrumentation();
    mKeyguardManager = (KeyguardManager) mInstrumentation.getTargetContext().getSystemService(KEYGUARD_SERVICE);
    mActivity = mActivityRule.getActivity();
    setKeepScreenOn();
    try {
        mActivityRule.runOnUiThread(new Runnable() {

            public void run() {
                mPlayer = new XMediaPlayer(mActivity);
            }
        });
    } catch (Throwable e) {
        Log.e(TAG, "Failed to instantiate XMediaPlayer", e);
        fail(e.getMessage());
    }
    mContext = mActivityRule.getActivity();
    mResources = mContext.getResources();
    mExecutor = Executors.newFixedThreadPool(1);
}
#end_block

#method_before
@After
@CallSuper
public void tearDown() throws Exception {
    // Workaround of b/116077176
    Thread.sleep(1000);
    if (mPlayer != null) {
        mPlayer.close();
        mPlayer = null;
    }
    if (mExecutor != null) {
        mExecutor.shutdown();
        mExecutor = null;
    }
    mActivity = null;
    for (AssetFileDescriptor afd : mFdsToClose) {
        afd.close();
    }
    mFdsToClose.clear();
}
#method_after
@After
@CallSuper
public void tearDown() throws Exception {
    if (mPlayer != null) {
        mPlayer.close();
        mPlayer = null;
    }
    if (mExecutor != null) {
        mExecutor.shutdown();
        mExecutor = null;
    }
    mActivity = null;
    for (AssetFileDescriptor afd : mFdsToClose) {
        afd.close();
    }
    mFdsToClose.clear();
}
#end_block

#method_before
public void stopScan() {
    ITelephony telephony = getITelephony();
    if (telephony == null) {
        Rlog.e(TAG, "Failed to get the ITelephony instance.");
    }
    try {
        telephony.stopNetworkScan(mSubId, mScanId);
    } catch (IllegalArgumentException ex) {
        Rlog.d(TAG, "stopNetworkScan - no scan for UID and ScanID.");
    } catch (RemoteException ex) {
        Rlog.e(TAG, "stopNetworkScan  RemoteException", ex);
    } catch (RuntimeException ex) {
        Rlog.e(TAG, "stopNetworkScan  RuntimeException", ex);
    }
}
#method_after
public void stopScan() {
    ITelephony telephony = getITelephony();
    if (telephony == null) {
        Rlog.e(TAG, "Failed to get the ITelephony instance.");
    }
    try {
        telephony.stopNetworkScan(mSubId, mScanId);
    } catch (IllegalArgumentException ex) {
        Rlog.d(TAG, "stopNetworkScan - no active scan for ScanID=" + mScanId);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "stopNetworkScan  RemoteException", ex);
    } catch (RuntimeException ex) {
        Rlog.e(TAG, "stopNetworkScan  RuntimeException", ex);
    }
}
#end_block

#method_before
private int getAbsoluteVolumeIndex(int index) {
    /* Special handling for Bluetooth Absolute Volume scenario
             * If we send full audio gain, some accessories are too loud even at its lowest
             * volume. We are not able to enumerate all such accessories, so here is the
             * workaround from phone side.
             * Pre-scale volume at lowest volume steps 1 2 and 3.
             * For volume step 0, set audio gain to 0 as some accessories won't mute on their end.
             */
    if (index == 0) {
        // 0% for volume 0
        index = 0;
    } else if (index == 1) {
        // Pre-scale for volume 1
        index = (int) (mIndexMax * mContext.getResources().getFraction(com.android.internal.R.fraction.config_prescaleAbsoluteVolume_index1, 1, 1)) / 10;
    } else if (index == 2) {
        // Pre-scale for volume 2
        index = (int) (mIndexMax * mContext.getResources().getFraction(com.android.internal.R.fraction.config_prescaleAbsoluteVolume_index2, 1, 1)) / 10;
    } else if (index == 3) {
        // Pre-scale for volume 3
        index = (int) (mIndexMax * mContext.getResources().getFraction(com.android.internal.R.fraction.config_prescaleAbsoluteVolume_index3, 1, 1)) / 10;
    } else {
        // otherwise, full gain
        index = (mIndexMax + 5) / 10;
    }
    return index;
}
#method_after
private int getAbsoluteVolumeIndex(int index) {
    /* Special handling for Bluetooth Absolute Volume scenario
             * If we send full audio gain, some accessories are too loud even at its lowest
             * volume. We are not able to enumerate all such accessories, so here is the
             * workaround from phone side.
             * Pre-scale volume at lowest volume steps 1 2 and 3.
             * For volume step 0, set audio gain to 0 as some accessories won't mute on their end.
             */
    if (index == 0) {
        // 0% for volume 0
        index = 0;
    } else if (index > 0 && index <= 3) {
        // Pre-scale for volume steps 1 2 and 3
        index = (int) (mIndexMax * mPrescaleAbsoluteVolume[index - 1]) / 10;
    } else {
        // otherwise, full gain
        index = (mIndexMax + 5) / 10;
    }
    return index;
}
#end_block

#method_before
@Override
public void onBindViewHolder(PreferenceViewHolder holder) {
    super.onBindViewHolder(holder);
    if (Build.VERSION.SDK_INT >= VERSION_CODES.P) {
        holder.itemView.setAccessibilityHeading(true);
    } else // accordingly.
    if (Build.VERSION.SDK_INT <= 21) {
        final TypedValue value = new TypedValue();
        // Return if the attribute could not be resolved
        if (!getContext().getTheme().resolveAttribute(R.attr.colorAccent, value, true)) {
            return;
        }
        final TextView titleView = (TextView) holder.findViewById(android.R.id.title);
        if (titleView != null) {
            titleView.setTextColor(value.data);
        }
    }
}
#method_after
@Override
public void onBindViewHolder(PreferenceViewHolder holder) {
    super.onBindViewHolder(holder);
    if (Build.VERSION.SDK_INT >= VERSION_CODES.P) {
        holder.itemView.setAccessibilityHeading(true);
    } else if (Build.VERSION.SDK_INT < VERSION_CODES.LOLLIPOP) {
        // We can't safely look for colorAccent in the category layout XML below Lollipop, as it
        // only exists within AppCompat, and will crash if using a platform theme. We should
        // still try and parse the attribute here in case we are running inside
        // PreferenceFragmentCompat with an AppCompat theme, and to set the category title
        // accordingly.
        final TypedValue value = new TypedValue();
        if (!getContext().getTheme().resolveAttribute(R.attr.colorAccent, value, true)) {
            // Return if the attribute could not be resolved
            return;
        }
        final TextView titleView = (TextView) holder.findViewById(android.R.id.title);
        if (titleView == null) {
            return;
        }
        final int fallbackColor = ContextCompat.getColor(getContext(), R.color.preference_fallback_accent_color);
        // color.
        if (titleView.getCurrentTextColor() != fallbackColor) {
            return;
        }
        titleView.setTextColor(value.data);
    }
}
#end_block

#method_before
@Override
public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfoCompat info) {
    super.onInitializeAccessibilityNodeInfo(info);
    if (Build.VERSION.SDK_INT < 28) {
        CollectionItemInfoCompat existingItemInfo = info.getCollectionItemInfo();
        if (existingItemInfo == null) {
            return;
        }
        final CollectionItemInfoCompat newItemInfo = CollectionItemInfoCompat.obtain(existingItemInfo.getRowIndex(), existingItemInfo.getRowSpan(), existingItemInfo.getColumnIndex(), existingItemInfo.getColumnSpan(), true, /* heading */
        existingItemInfo.isSelected());
        info.setCollectionItemInfo(newItemInfo);
    }
}
#method_after
@Override
public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfoCompat info) {
    super.onInitializeAccessibilityNodeInfo(info);
    if (Build.VERSION.SDK_INT < VERSION_CODES.P) {
        CollectionItemInfoCompat existingItemInfo = info.getCollectionItemInfo();
        if (existingItemInfo == null) {
            return;
        }
        final CollectionItemInfoCompat newItemInfo = CollectionItemInfoCompat.obtain(existingItemInfo.getRowIndex(), existingItemInfo.getRowSpan(), existingItemInfo.getColumnIndex(), existingItemInfo.getColumnSpan(), true, /* heading */
        existingItemInfo.isSelected());
        info.setCollectionItemInfo(newItemInfo);
    }
}
#end_block

#method_before
public int getNetworkType() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.getNetworkType();
        } else {
            // This can happen when the ITelephony interface is not up yet.
            return NETWORK_TYPE_UNKNOWN;
        }
    } catch (RemoteException ex) {
        // This shouldn't happen in the normal case
        return NETWORK_TYPE_UNKNOWN;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return NETWORK_TYPE_UNKNOWN;
    }
}
#method_after
@NetworkType
public int getNetworkType() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.getNetworkType();
        } else {
            // This can happen when the ITelephony interface is not up yet.
            return NETWORK_TYPE_UNKNOWN;
        }
    } catch (RemoteException ex) {
        // This shouldn't happen in the normal case
        return NETWORK_TYPE_UNKNOWN;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return NETWORK_TYPE_UNKNOWN;
    }
}
#end_block

#method_before
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public int getDataNetworkType() {
    return getDataNetworkType(getSubId(SubscriptionManager.getDefaultDataSubscriptionId()));
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
@NetworkType
public int getDataNetworkType() {
    return getDataNetworkType(getSubId(SubscriptionManager.getDefaultDataSubscriptionId()));
}
#end_block

#method_before
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public int getVoiceNetworkType() {
    return getVoiceNetworkType(getSubId());
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
@NetworkType
public int getVoiceNetworkType() {
    return getVoiceNetworkType(getSubId());
}
#end_block

#method_before
@UnsupportedAppUsage
public String getIsimDomain() {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        // get the Isim Domain based on subId
        return info.getIsimDomain(getSubId());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#method_after
@SystemApi
@RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
public String getIsimDomain() {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        // get the Isim Domain based on subId
        return info.getIsimDomain(getSubId());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#end_block

#method_before
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public boolean setNetworkSelectionModeManual(String operatorNumeric, boolean persistSelection) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.setNetworkSelectionModeManual(getSubId(), operatorNumeric, persistSelection);
        }
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual NPE", ex);
    }
    return false;
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public boolean setNetworkSelectionModeManual(String operatorNumeric, boolean persistSelection) {
    return setNetworkSelectionModeManual(new OperatorInfo("", /* operatorAlphaLong */
    "", /* operatorAlphaShort */
    operatorNumeric), persistSelection);
}
#end_block

#method_before
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public boolean setNetworkSelectionModeManual(String operatorNumeric, boolean persistSelection) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.setNetworkSelectionModeManual(getSubId(), operatorNumeric, persistSelection);
        }
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual NPE", ex);
    }
    return false;
}
#method_after
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public boolean setNetworkSelectionModeManual(OperatorInfo operatorInfo, boolean persistSelection) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.setNetworkSelectionModeManual(getSubId(), operatorInfo, persistSelection);
        }
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual RemoteException", ex);
    }
    return false;
}
#end_block

#method_before
public String getAidForAppType(int appType) {
    return getAidForAppType(getSubId(), appType);
}
#method_after
@SystemApi
@RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
public String getAidForAppType(@UiccAppType int appType) {
    return getAidForAppType(getSubId(), appType);
}
#end_block

#method_before
@Override
public void onAttachedToWindowImpl() {
    // and closed in onDetachedFromWindow().
    if (mMediaPlayer == null) {
        mMediaPlayer = new VideoView2Player(mInstance.getContext());
        mSurfaceView.setMediaPlayer(mMediaPlayer);
        mTextureView.setMediaPlayer(mMediaPlayer);
        mCurrentView.assignSurfaceToMediaPlayer(mMediaPlayer);
        if (mMediaSession != null) {
            mMediaSession.updatePlayer(mMediaPlayer);
        }
    } else {
        if (!mCurrentView.assignSurfaceToMediaPlayer(mMediaPlayer)) {
            Log.w(TAG, "failed to assign surface");
        }
    }
    if (mMediaSession == null) {
        final Context context = mInstance.getContext();
        mMediaSession = new MediaSession2.Builder(context).setPlayer(mMediaPlayer).setId("VideoView2_" + mInstance.toString()).setSessionCallback(mCallbackExecutor, new MediaSessionCallback()).build();
    }
    attachMediaControlView();
    mMediaRouter = MediaRouter.getInstance(mInstance.getContext());
    // TODO: Revisit once ag/4207152 is merged.
    mMediaRouter.setMediaSessionCompat(mMediaSession.getSessionCompat());
    mMediaRouter.addCallback(mRouteSelector, mRouterCallback, MediaRouter.CALLBACK_FLAG_PERFORM_ACTIVE_SCAN);
}
#method_after
@Override
public void onAttachedToWindowImpl() {
    // and closed in onDetachedFromWindow().
    if (mMediaPlayer == null) {
        mMediaPlayer = new VideoView2Player(mInstance.getContext());
        mSurfaceView.setMediaPlayer(mMediaPlayer);
        mTextureView.setMediaPlayer(mMediaPlayer);
        mCurrentView.assignSurfaceToMediaPlayer(mMediaPlayer);
        if (mMediaSession != null) {
            mMediaSession.updatePlayer(mMediaPlayer);
        }
    } else {
        if (!mCurrentView.assignSurfaceToMediaPlayer(mMediaPlayer)) {
            Log.w(TAG, "failed to assign surface");
        }
    }
    ensureSessionWithPlayer(mMediaPlayer);
    attachMediaControlView();
    mMediaRouter = MediaRouter.getInstance(mInstance.getContext());
    // TODO: Revisit once ag/4207152 is merged.
    mMediaRouter.setMediaSessionCompat(mMediaSession.getSessionCompat());
    mMediaRouter.addCallback(mRouteSelector, mRouterCallback, MediaRouter.CALLBACK_FLAG_PERFORM_ACTIVE_SCAN);
}
#end_block

#method_before
void openVideo() {
    if (DEBUG) {
        Log.d(TAG, "openVideo()");
    }
    if (mMediaItem != null) {
        resetPlayer();
        if (isRemotePlayback()) {
            mRoutePlayer.setMediaItem(mMediaItem);
            return;
        }
    }
    try {
        if (mMediaPlayer == null) {
            mMediaPlayer = new VideoView2Player(mInstance.getContext());
        }
        mSurfaceView.setMediaPlayer(mMediaPlayer);
        mTextureView.setMediaPlayer(mMediaPlayer);
        if (!mCurrentView.assignSurfaceToMediaPlayer(mMediaPlayer)) {
            Log.w(TAG, "failed to assign surface");
        }
        mMediaPlayer.registerPlayerCallback(mCallbackExecutor, mMediaPlayerCallback);
        mMediaPlayer.setAudioAttributes(mAudioAttributes);
        if (mMediaSession == null) {
            final Context context = mInstance.getContext();
            mMediaSession = new MediaSession2.Builder(context).setPlayer(mMediaPlayer).setId("VideoView2_" + mInstance.toString()).setSessionCallback(mCallbackExecutor, new MediaSessionCallback()).build();
        } else {
            mMediaSession.updatePlayer(mMediaPlayer);
        }
        mMediaPlayer.setMediaItem(mMediaItem);
        final Context context = mInstance.getContext();
        mSubtitleController = new SubtitleController(context);
        mSubtitleController.registerRenderer(new ClosedCaptionRenderer(context));
        mSubtitleController.registerRenderer(new Cea708CaptionRenderer(context));
        mSubtitleController.setAnchor((SubtitleController.Anchor) mSubtitleAnchorView);
        // we don't set the target state here either, but preserve the
        // target state that was there before.
        mCurrentState = STATE_PREPARING;
        mMediaSession.prepare();
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, "Unable to open content: " + mMediaItem, ex);
        mCurrentState = STATE_ERROR;
        mTargetState = STATE_ERROR;
    }
}
#method_after
void openVideo() {
    if (DEBUG) {
        Log.d(TAG, "openVideo()");
    }
    if (mMediaItem != null) {
        resetPlayer();
        if (isRemotePlayback()) {
            mRoutePlayer.setMediaItem(mMediaItem);
            return;
        }
    }
    try {
        if (mMediaPlayer == null) {
            mMediaPlayer = new VideoView2Player(mInstance.getContext());
        }
        mSurfaceView.setMediaPlayer(mMediaPlayer);
        mTextureView.setMediaPlayer(mMediaPlayer);
        if (!mCurrentView.assignSurfaceToMediaPlayer(mMediaPlayer)) {
            Log.w(TAG, "failed to assign surface");
        }
        mMediaPlayer.registerPlayerCallback(mCallbackExecutor, mMediaPlayerCallback);
        mMediaPlayer.setAudioAttributes(mAudioAttributes);
        ensureSessionWithPlayer(mMediaPlayer);
        mMediaPlayer.setMediaItem(mMediaItem);
        final Context context = mInstance.getContext();
        mSubtitleController = new SubtitleController(context);
        mSubtitleController.registerRenderer(new ClosedCaptionRenderer(context));
        mSubtitleController.registerRenderer(new Cea708CaptionRenderer(context));
        mSubtitleController.setAnchor((SubtitleController.Anchor) mSubtitleAnchorView);
        // we don't set the target state here either, but preserve the
        // target state that was there before.
        mCurrentState = STATE_PREPARING;
        mMediaSession.prepare();
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, "Unable to open content: " + mMediaItem, ex);
        mCurrentState = STATE_ERROR;
        mTargetState = STATE_ERROR;
    }
}
#end_block

#method_before
boolean isRemotePlayback() {
    return mRoutePlayer != null && mMediaSession != null && (mMediaSession.getPlayerConnector() instanceof BaseRemoteMediaPlayerConnector);
}
#method_after
boolean isRemotePlayback() {
    return mRoutePlayer != null && mMediaSession != null && (mMediaSession.getPlayer() instanceof RemoteSessionPlayer2);
}
#end_block

#method_before
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
@Override
@NonNull
public final ListenableFuture<Payload> onStartWork() {
    mFuture = SettableFuture.create();
    getBackgroundExecutor().execute(new Runnable() {

        @Override
        public void run() {
            Result result = doWork();
            setResult(result);
            mFuture.set(new Payload(result, getOutputData()));
        }
    });
    return mFuture;
}
#method_after
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
@Override
@NonNull
public final ListenableFuture<Payload> onStartWork() {
    mFuture = SettableFuture.create();
    getBackgroundExecutor().execute(new Runnable() {

        @Override
        public void run() {
            Result result = doWork();
            mFuture.set(new Payload(result, getOutputData()));
        }
    });
    return mFuture;
}
#end_block

#method_before
@NonNull
@Override
public Result doWork() {
    String className = getInputData().getString(ARGUMENT_CLASS_NAME);
    if (TextUtils.isEmpty(className)) {
        Logger.error(TAG, "No worker to delegate to.");
        return FAILURE;
    }
    WorkerParameters paramsToPass = new WorkerParameters(getId(), getInputData(), getTags(), getRuntimeExtras(), getRunAttemptCount(), new SynchronousExecutor(), getWorkerFactory());
    mDelegate = getWorkerFactory().createWorker(getApplicationContext(), className, paramsToPass);
    if (mDelegate == null) {
        Logger.debug(TAG, "No worker to delegate to.");
        return FAILURE;
    }
    WorkDatabase workDatabase = getWorkDatabase();
    // We need to know what the real constraints are for the delegate.
    WorkSpec workSpec = workDatabase.workSpecDao().getWorkSpec(getId().toString());
    if (workSpec == null) {
        return FAILURE;
    }
    WorkConstraintsTracker workConstraintsTracker = new WorkConstraintsTracker(getApplicationContext(), this);
    // Start tracking
    workConstraintsTracker.replace(Collections.singletonList(workSpec));
    if (workConstraintsTracker.areAllConstraintsMet(getId().toString())) {
        Logger.debug(TAG, String.format("Constraints met for delegate %s", className));
        // that should cause a retry.
        try {
            ListenableFuture<Payload> innerFuture = mDelegate.onStartWork();
            if (mAreConstraintsUnmet) {
                return RETRY;
            } else {
                Payload payload = innerFuture.get();
                setResult(payload.getResult());
                setOutputData(payload.getOutputData());
                return payload.getResult();
            }
        } catch (Throwable exception) {
            Logger.debug(TAG, String.format("Delegated worker %s threw a runtime exception.", className), exception);
            synchronized (mLock) {
                if (mAreConstraintsUnmet) {
                    Logger.debug(TAG, "Constraints were unmet, Retrying.");
                    return RETRY;
                } else {
                    return FAILURE;
                }
            }
        }
    } else {
        Logger.debug(TAG, String.format("Constraints not met for delegate %s. Requesting retry.", className));
        return RETRY;
    }
}
#method_after
@NonNull
@Override
public Result doWork() {
    String className = getInputData().getString(ARGUMENT_CLASS_NAME);
    if (TextUtils.isEmpty(className)) {
        Logger.error(TAG, "No worker to delegate to.");
        return FAILURE;
    }
    WorkerParameters paramsToPass = new WorkerParameters(getId(), getInputData(), getTags(), getRuntimeExtras(), getRunAttemptCount(), new SynchronousExecutor(), getWorkerFactory());
    mDelegate = getWorkerFactory().createWorker(getApplicationContext(), className, paramsToPass);
    if (mDelegate == null) {
        Logger.debug(TAG, "No worker to delegate to.");
        return FAILURE;
    }
    WorkDatabase workDatabase = getWorkDatabase();
    // We need to know what the real constraints are for the delegate.
    WorkSpec workSpec = workDatabase.workSpecDao().getWorkSpec(getId().toString());
    if (workSpec == null) {
        return FAILURE;
    }
    WorkConstraintsTracker workConstraintsTracker = new WorkConstraintsTracker(getApplicationContext(), this);
    // Start tracking
    workConstraintsTracker.replace(Collections.singletonList(workSpec));
    if (workConstraintsTracker.areAllConstraintsMet(getId().toString())) {
        Logger.debug(TAG, String.format("Constraints met for delegate %s", className));
        // that should cause a retry.
        try {
            ListenableFuture<Payload> innerFuture = mDelegate.onStartWork();
            if (mAreConstraintsUnmet) {
                return RETRY;
            } else {
                Payload payload = innerFuture.get();
                setOutputData(payload.getOutputData());
                return payload.getResult();
            }
        } catch (Throwable exception) {
            Logger.debug(TAG, String.format("Delegated worker %s threw a runtime exception.", className), exception);
            synchronized (mLock) {
                if (mAreConstraintsUnmet) {
                    Logger.debug(TAG, "Constraints were unmet, Retrying.");
                    return RETRY;
                } else {
                    return FAILURE;
                }
            }
        }
    } else {
        Logger.debug(TAG, String.format("Constraints not met for delegate %s. Requesting retry.", className));
        return RETRY;
    }
}
#end_block

#method_before
private void runWorker() {
    if (tryCheckForInterruptionAndNotify()) {
        return;
    }
    mWorkDatabase.beginTransaction();
    try {
        mWorkSpec = mWorkSpecDao.getWorkSpec(mWorkSpecId);
        if (mWorkSpec == null) {
            Logger.error(TAG, String.format("Didn't find WorkSpec for id %s", mWorkSpecId));
            notifyListener(false);
            return;
        }
        // running, finished, or is blocked.
        if (mWorkSpec.state != ENQUEUED) {
            notifyIncorrectStatus();
            mWorkDatabase.setTransactionSuccessful();
            return;
        }
        // Needed for nested transactions, such as when we're in a dependent work request when
        // using a SynchronousExecutor.
        mWorkDatabase.setTransactionSuccessful();
    } finally {
        mWorkDatabase.endTransaction();
    }
    // Merge inputs.  This can be potentially expensive code, so this should not be done inside
    // a database transaction.
    Data input;
    if (mWorkSpec.isPeriodic()) {
        input = mWorkSpec.input;
    } else {
        InputMerger inputMerger = InputMerger.fromClassName(mWorkSpec.inputMergerClassName);
        if (inputMerger == null) {
            Logger.error(TAG, String.format("Could not create Input Merger %s", mWorkSpec.inputMergerClassName));
            setFailedAndNotify();
            return;
        }
        List<Data> inputs = new ArrayList<>();
        inputs.add(mWorkSpec.input);
        inputs.addAll(mWorkSpecDao.getInputsFromPrerequisites(mWorkSpecId));
        input = inputMerger.merge(inputs);
    }
    WorkerParameters params = new WorkerParameters(UUID.fromString(mWorkSpecId), input, mTags, mRuntimeExtras, mWorkSpec.runAttemptCount, mConfiguration.getExecutor(), mConfiguration.getWorkerFactory());
    // in test mode.
    if (mWorker == null) {
        mWorker = mConfiguration.getWorkerFactory().createWorker(mAppContext, mWorkSpec.workerClassName, params);
    }
    if (mWorker == null) {
        Logger.error(TAG, String.format("Could for create Worker %s", mWorkSpec.workerClassName));
        setFailedAndNotify();
        return;
    }
    if (mWorker.isUsed()) {
        Logger.error(TAG, String.format("Received an already-used Worker %s; WorkerFactory should return " + "new instances", mWorkSpec.workerClassName));
        setFailedAndNotify();
        return;
    }
    mWorker.setUsed();
    // may have modified the DB since we checked last at the top of this function.
    if (trySetRunning()) {
        if (tryCheckForInterruptionAndNotify()) {
            return;
        }
        final SettableFuture<NonBlockingWorker.Payload> future = SettableFuture.create();
        try {
            final ListenableFuture<NonBlockingWorker.Payload> innerFuture = mWorker.onStartWork();
            future.setFuture(innerFuture);
        } catch (Throwable e) {
            future.setException(e);
        }
        // Avoid synthetic accessors.
        final String workDescription = mWorkDescription;
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    onWorkFinished(future.get().getResult());
                } catch (InterruptedException | ExecutionException exception) {
                    Logger.error(TAG, String.format("%s failed because it threw an exception/error", workDescription), exception);
                    onWorkFinished(Result.FAILURE);
                }
            }
        }, mWorkTaskExecutor.getBackgroundExecutor());
    } else {
        notifyIncorrectStatus();
    }
}
#method_after
private void runWorker() {
    if (tryCheckForInterruptionAndNotify()) {
        return;
    }
    mWorkDatabase.beginTransaction();
    try {
        mWorkSpec = mWorkSpecDao.getWorkSpec(mWorkSpecId);
        if (mWorkSpec == null) {
            Logger.error(TAG, String.format("Didn't find WorkSpec for id %s", mWorkSpecId));
            notifyListener(false);
            return;
        }
        // running, finished, or is blocked.
        if (mWorkSpec.state != ENQUEUED) {
            notifyIncorrectStatus();
            mWorkDatabase.setTransactionSuccessful();
            return;
        }
        // Needed for nested transactions, such as when we're in a dependent work request when
        // using a SynchronousExecutor.
        mWorkDatabase.setTransactionSuccessful();
    } finally {
        mWorkDatabase.endTransaction();
    }
    // Merge inputs.  This can be potentially expensive code, so this should not be done inside
    // a database transaction.
    Data input;
    if (mWorkSpec.isPeriodic()) {
        input = mWorkSpec.input;
    } else {
        InputMerger inputMerger = InputMerger.fromClassName(mWorkSpec.inputMergerClassName);
        if (inputMerger == null) {
            Logger.error(TAG, String.format("Could not create Input Merger %s", mWorkSpec.inputMergerClassName));
            setFailedAndNotify();
            return;
        }
        List<Data> inputs = new ArrayList<>();
        inputs.add(mWorkSpec.input);
        inputs.addAll(mWorkSpecDao.getInputsFromPrerequisites(mWorkSpecId));
        input = inputMerger.merge(inputs);
    }
    WorkerParameters params = new WorkerParameters(UUID.fromString(mWorkSpecId), input, mTags, mRuntimeExtras, mWorkSpec.runAttemptCount, mConfiguration.getExecutor(), mConfiguration.getWorkerFactory());
    // in test mode.
    if (mWorker == null) {
        mWorker = mConfiguration.getWorkerFactory().createWorker(mAppContext, mWorkSpec.workerClassName, params);
    }
    if (mWorker == null) {
        Logger.error(TAG, String.format("Could for create Worker %s", mWorkSpec.workerClassName));
        setFailedAndNotify();
        return;
    }
    if (mWorker.isUsed()) {
        Logger.error(TAG, String.format("Received an already-used Worker %s; WorkerFactory should return " + "new instances", mWorkSpec.workerClassName));
        setFailedAndNotify();
        return;
    }
    mWorker.setUsed();
    // may have modified the DB since we checked last at the top of this function.
    if (trySetRunning()) {
        if (tryCheckForInterruptionAndNotify()) {
            return;
        }
        final SettableFuture<NonBlockingWorker.Payload> future = SettableFuture.create();
        try {
            final ListenableFuture<NonBlockingWorker.Payload> innerFuture = mWorker.onStartWork();
            future.setFuture(innerFuture);
        } catch (Throwable e) {
            future.setException(e);
        }
        // Avoid synthetic accessors.
        final String workDescription = mWorkDescription;
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    mPayload = future.get();
                } catch (InterruptedException | ExecutionException exception) {
                    Logger.error(TAG, String.format("%s failed because it threw an exception/error", workDescription), exception);
                    mPayload = new NonBlockingWorker.Payload(Result.FAILURE, Data.EMPTY);
                } finally {
                    onWorkFinished();
                }
            }
        }, mWorkTaskExecutor.getBackgroundExecutor());
    } else {
        notifyIncorrectStatus();
    }
}
#end_block

#method_before
void onWorkFinished(@NonNull Result result) {
    assertBackgroundExecutorThread();
    boolean isWorkFinished = false;
    if (!tryCheckForInterruptionAndNotify()) {
        try {
            mWorkDatabase.beginTransaction();
            State state = mWorkSpecDao.getState(mWorkSpecId);
            if (state == null) {
                // state can be null here with a REPLACE on beginUniqueWork().
                // Treat it as a failure, and rescheduleAndNotify() will
                // turn into a no-op. We still need to notify potential observers
                // holding on to wake locks on our behalf.
                notifyListener(false);
                isWorkFinished = true;
            } else if (state == RUNNING) {
                handleResult(result);
                // Update state after a call to handleResult()
                state = mWorkSpecDao.getState(mWorkSpecId);
                isWorkFinished = state.isFinished();
            } else if (!state.isFinished()) {
                rescheduleAndNotify();
            }
            mWorkDatabase.setTransactionSuccessful();
        } finally {
            mWorkDatabase.endTransaction();
        }
    }
    // that it should remove this job and AlarmManager should remove all related alarms.
    if (isWorkFinished) {
        for (Scheduler scheduler : mSchedulers) {
            scheduler.cancel(mWorkSpecId);
        }
    }
    Schedulers.schedule(mConfiguration, mWorkDatabase, mSchedulers);
}
#method_after
void onWorkFinished() {
    assertBackgroundExecutorThread();
    boolean isWorkFinished = false;
    if (!tryCheckForInterruptionAndNotify()) {
        try {
            mWorkDatabase.beginTransaction();
            State state = mWorkSpecDao.getState(mWorkSpecId);
            if (state == null) {
                // state can be null here with a REPLACE on beginUniqueWork().
                // Treat it as a failure, and rescheduleAndNotify() will
                // turn into a no-op. We still need to notify potential observers
                // holding on to wake locks on our behalf.
                notifyListener(false);
                isWorkFinished = true;
            } else if (state == RUNNING) {
                handleResult(mPayload.getResult());
                // Update state after a call to handleResult()
                state = mWorkSpecDao.getState(mWorkSpecId);
                isWorkFinished = state.isFinished();
            } else if (!state.isFinished()) {
                rescheduleAndNotify();
            }
            mWorkDatabase.setTransactionSuccessful();
        } finally {
            mWorkDatabase.endTransaction();
        }
    }
    // that it should remove this job and AlarmManager should remove all related alarms.
    if (isWorkFinished) {
        for (Scheduler scheduler : mSchedulers) {
            scheduler.cancel(mWorkSpecId);
        }
    }
    Schedulers.schedule(mConfiguration, mWorkDatabase, mSchedulers);
}
#end_block

#method_before
private void setFailedAndNotify() {
    mWorkDatabase.beginTransaction();
    try {
        recursivelyFailWorkAndDependents(mWorkSpecId);
        // be a permanent error where we couldn't find or create the worker class.
        if (mWorker != null) {
            // Update Data as necessary.
            Data output = mWorker.getOutputData();
            mWorkSpecDao.setOutput(mWorkSpecId, output);
        }
        mWorkDatabase.setTransactionSuccessful();
    } finally {
        mWorkDatabase.endTransaction();
        notifyListener(false);
    }
}
#method_after
private void setFailedAndNotify() {
    mWorkDatabase.beginTransaction();
    try {
        recursivelyFailWorkAndDependents(mWorkSpecId);
        // happen if we couldn't find or create the worker class.
        if (mPayload != null) {
            // Update Data as necessary.
            Data output = mPayload.getOutputData();
            mWorkSpecDao.setOutput(mWorkSpecId, output);
        }
        mWorkDatabase.setTransactionSuccessful();
    } finally {
        mWorkDatabase.endTransaction();
        notifyListener(false);
    }
}
#end_block

#method_before
private void setSucceededAndNotify() {
    mWorkDatabase.beginTransaction();
    try {
        mWorkSpecDao.setState(SUCCEEDED, mWorkSpecId);
        // Update Data as necessary.
        Data output = mWorker.getOutputData();
        mWorkSpecDao.setOutput(mWorkSpecId, output);
        // Unblock Dependencies and set Period Start Time
        long currentTimeMillis = System.currentTimeMillis();
        List<String> dependentWorkIds = mDependencyDao.getDependentWorkIds(mWorkSpecId);
        for (String dependentWorkId : dependentWorkIds) {
            if (mDependencyDao.hasCompletedAllPrerequisites(dependentWorkId)) {
                Logger.info(TAG, String.format("Setting status to enqueued for %s", dependentWorkId));
                mWorkSpecDao.setState(ENQUEUED, dependentWorkId);
                mWorkSpecDao.setPeriodStartTime(dependentWorkId, currentTimeMillis);
            }
        }
        mWorkDatabase.setTransactionSuccessful();
    } finally {
        mWorkDatabase.endTransaction();
        notifyListener(false);
    }
}
#method_after
private void setSucceededAndNotify() {
    mWorkDatabase.beginTransaction();
    try {
        mWorkSpecDao.setState(SUCCEEDED, mWorkSpecId);
        // Update Data as necessary.
        Data output = mPayload.getOutputData();
        mWorkSpecDao.setOutput(mWorkSpecId, output);
        // Unblock Dependencies and set Period Start Time
        long currentTimeMillis = System.currentTimeMillis();
        List<String> dependentWorkIds = mDependencyDao.getDependentWorkIds(mWorkSpecId);
        for (String dependentWorkId : dependentWorkIds) {
            if (mDependencyDao.hasCompletedAllPrerequisites(dependentWorkId)) {
                Logger.info(TAG, String.format("Setting status to enqueued for %s", dependentWorkId));
                mWorkSpecDao.setState(ENQUEUED, dependentWorkId);
                mWorkSpecDao.setPeriodStartTime(dependentWorkId, currentTimeMillis);
            }
        }
        mWorkDatabase.setTransactionSuccessful();
    } finally {
        mWorkDatabase.endTransaction();
        notifyListener(false);
    }
}
#end_block

#method_before
private long getCellInfoDelayTime(int failCount) {
    // This is to prevent the delay time overflow when fail count is large.
    if (failCount >= MAX_FAIL_COUNT) {
        failCount = MAX_FAIL_COUNT;
    }
    // Exponentially grow the delay time
    long delay = CELL_INFO_MIN_DELAY_MS * (long) Math.pow(2, failCount - 1);
    if (delay < CELL_INFO_MIN_DELAY_MS) {
        delay = CELL_INFO_MIN_DELAY_MS;
    } else if (delay > CELL_INFO_MAX_DELAY_MS) {
        delay = CELL_INFO_MAX_DELAY_MS;
    }
    return delay;
}
#method_after
@VisibleForTesting
public static long getCellInfoDelayTime(int failCount) {
    // Exponentially grow the delay time. Note we limit the fail count to MAX_FAIL_COUNT to
    // prevent overflow in Math.pow().
    long delay = CELL_INFO_MIN_DELAY_MS * (long) Math.pow(2, Math.min(failCount, MAX_FAIL_COUNT) - 1);
    return Math.min(Math.max(delay, CELL_INFO_MIN_DELAY_MS), CELL_INFO_MAX_DELAY_MS);
}
#end_block

#method_before
@MainThread
@NonNull
public static <In, Out> LiveData<Out> distinctUntilChanged(@NonNull LiveData<In> inputLiveData, @NonNull final Function<In, Out> mappingMethod, @NonNull final Executor executor) {
    final MediatorLiveData<Out> outputLiveData = new MediatorLiveData<>();
    outputLiveData.addSource(inputLiveData, new Observer<In>() {

        @Override
        public void onChanged(@Nullable final In input) {
            final Out previousOutput = outputLiveData.getValue();
            executor.execute(new Runnable() {

                @Override
                public void run() {
                    synchronized (outputLiveData) {
                        Out newOutput = mappingMethod.apply(input);
                        if (previousOutput == null && newOutput != null) {
                            outputLiveData.postValue(newOutput);
                        } else if (previousOutput != null && !previousOutput.equals(newOutput)) {
                            outputLiveData.postValue(newOutput);
                        }
                    }
                }
            });
        }
    });
    return outputLiveData;
}
#method_after
@MainThread
@NonNull
public static <X> LiveData<X> distinctUntilChanged(@NonNull LiveData<X> source) {
    final MediatorLiveData<X> outputLiveData = new MediatorLiveData<>();
    outputLiveData.addSource(source, new Observer<X>() {

        boolean mFirstTime = true;

        @Override
        public void onChanged(X currentValue) {
            final X previousValue = outputLiveData.getValue();
            if (mFirstTime || (previousValue == null && currentValue != null) || (previousValue != null && !previousValue.equals(currentValue))) {
                mFirstTime = false;
                outputLiveData.setValue(currentValue);
            }
        }
    });
    return outputLiveData;
}
#end_block

#method_before
@Test
public void testDistinctUntilChanged_dedupesValues() {
    Function<String, String> identityMapping = new Function<String, String>() {

        @Override
        public String apply(String input) {
            return input;
        }
    };
    MutableLiveData<String> originalLiveData = new MutableLiveData<>();
    LiveData<String> dedupedLiveData = Transformations.distinctUntilChanged(originalLiveData, identityMapping, mSynchronousExecutor);
    assertThat(dedupedLiveData.getValue(), is(nullValue()));
    CountingObserver<String> observer = new CountingObserver<>();
    dedupedLiveData.observe(mOwner, observer);
    assertThat(observer.mTimesUpdated, is(0));
    String value = "new value";
    originalLiveData.setValue(value);
    assertThat(dedupedLiveData.getValue(), is(value));
    assertThat(observer.mTimesUpdated, is(1));
    originalLiveData.setValue(value);
    assertThat(dedupedLiveData.getValue(), is(value));
    assertThat(observer.mTimesUpdated, is(1));
    String newerValue = "newer value";
    originalLiveData.setValue(newerValue);
    assertThat(dedupedLiveData.getValue(), is(newerValue));
    assertThat(observer.mTimesUpdated, is(2));
    dedupedLiveData.removeObservers(mOwner);
}
#method_after
@Test
public void testDistinctUntilChanged_dedupesValues() {
    MutableLiveData<String> originalLiveData = new MutableLiveData<>();
    LiveData<String> dedupedLiveData = Transformations.distinctUntilChanged(originalLiveData);
    assertThat(dedupedLiveData.getValue(), is(nullValue()));
    CountingObserver<String> observer = new CountingObserver<>();
    dedupedLiveData.observe(mOwner, observer);
    assertThat(observer.mTimesUpdated, is(0));
    String value = "new value";
    originalLiveData.setValue(value);
    assertThat(dedupedLiveData.getValue(), is(value));
    assertThat(observer.mTimesUpdated, is(1));
    originalLiveData.setValue(value);
    assertThat(dedupedLiveData.getValue(), is(value));
    assertThat(observer.mTimesUpdated, is(1));
    String newerValue = "newer value";
    originalLiveData.setValue(newerValue);
    assertThat(dedupedLiveData.getValue(), is(newerValue));
    assertThat(observer.mTimesUpdated, is(2));
    dedupedLiveData.removeObservers(mOwner);
}
#end_block

#method_before
@Override
@NonNull
@RequiresApi(api = 26)
public TextClassifier getTextClassifier() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P || mTextClassifierHelper == null) {
        return super.getTextClassifier();
    }
    return mTextClassifierHelper.getTextClassifier();
}
#method_after
@Override
@NonNull
@RequiresApi(api = 26)
public TextClassifier getTextClassifier() {
    // the super class's constructor.
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P || mTextClassifierHelper == null) {
        return super.getTextClassifier();
    }
    return mTextClassifierHelper.getTextClassifier();
}
#end_block

#method_before
@Override
@NonNull
@RequiresApi(api = 26)
public TextClassifier getTextClassifier() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P || mTextClassifierHelper == null) {
        return super.getTextClassifier();
    }
    return mTextClassifierHelper.getTextClassifier();
}
#method_after
@Override
@NonNull
@RequiresApi(api = 26)
public TextClassifier getTextClassifier() {
    // the super class's constructor.
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P || mTextClassifierHelper == null) {
        return super.getTextClassifier();
    }
    return mTextClassifierHelper.getTextClassifier();
}
#end_block

#method_before
public void setTextClassifier(@Nullable TextClassifier textClassifier) {
    mTextClassifier = textClassifier;
}
#method_after
@RequiresApi(api = 26)
public void setTextClassifier(@Nullable TextClassifier textClassifier) {
    mTextClassifier = textClassifier;
}
#end_block

#method_before
@NonNull
public TextClassifier getTextClassifier() {
    if (mTextClassifier == null) {
        final TextClassificationManager tcm = mTextView.getContext().getSystemService(TextClassificationManager.class);
        if (tcm != null) {
            return tcm.getTextClassifier();
        }
        return TextClassifier.NO_OP;
    }
    return mTextClassifier;
}
#method_after
@RequiresApi(api = 26)
@NonNull
public TextClassifier getTextClassifier() {
    if (mTextClassifier == null) {
        final TextClassificationManager tcm = mTextView.getContext().getSystemService(TextClassificationManager.class);
        if (tcm != null) {
            return tcm.getTextClassifier();
        }
        return TextClassifier.NO_OP;
    }
    return mTextClassifier;
}
#end_block

#method_before
@SdkSuppress(minSdkVersion = 26)
@Test
public void testGetTextClassifier() {
    AppCompatTextView textView = mContainer.findViewById(R.id.textview_simple);
    TextClassificationManager textClassificationManager = mActivity.getSystemService(TextClassificationManager.class);
    textClassificationManager.setTextClassifier(new DummyTextClassifier());
    assertEquals(DummyTextClassifier.class, textView.getTextClassifier().getClass());
}
#method_after
@SdkSuppress(minSdkVersion = 26)
@Test
public void testGetTextClassifier() {
    AppCompatTextView textView = mContainer.findViewById(R.id.textview_simple);
    textView.getTextClassifier();
    DummyTextClassifier dummyTextClassifier = new DummyTextClassifier();
    TextClassificationManager textClassificationManager = mActivity.getSystemService(TextClassificationManager.class);
    textClassificationManager.setTextClassifier(dummyTextClassifier);
    assertEquals(dummyTextClassifier, textView.getTextClassifier());
}
#end_block

#method_before
@SdkSuppress(minSdkVersion = 26)
@Test
public void testSetTextClassifier() {
    final AppCompatTextView editText = new AppCompatTextView(mActivityTestRule.getActivity());
    editText.setTextClassifier(new DummyTextClassifier());
    assertEquals(DummyTextClassifier.class, editText.getTextClassifier().getClass());
}
#method_after
@SdkSuppress(minSdkVersion = 26)
@Test
public void testSetTextClassifier() {
    final AppCompatTextView textview = new AppCompatTextView(mActivityTestRule.getActivity());
    DummyTextClassifier dummyTextClassifier = new DummyTextClassifier();
    textview.setTextClassifier(dummyTextClassifier);
    assertEquals(dummyTextClassifier, textview.getTextClassifier());
}
#end_block

#method_before
@SdkSuppress(minSdkVersion = 26)
@Test
public void testGetTextClassifier() {
    final AppCompatEditText editText = new AppCompatEditText(mActivityTestRule.getActivity());
    TextClassificationManager textClassificationManager = mActivityTestRule.getActivity().getSystemService(TextClassificationManager.class);
    textClassificationManager.setTextClassifier(new DummyTextClassifier());
    assertEquals(DummyTextClassifier.class, editText.getTextClassifier().getClass());
}
#method_after
@SdkSuppress(minSdkVersion = 26)
@Test
public void testGetTextClassifier() {
    final AppCompatEditText editText = new AppCompatEditText(mActivityTestRule.getActivity());
    editText.getTextClassifier();
    DummyTextClassifier dummyTextClassifier = new DummyTextClassifier();
    TextClassificationManager textClassificationManager = mActivityTestRule.getActivity().getSystemService(TextClassificationManager.class);
    textClassificationManager.setTextClassifier(dummyTextClassifier);
    assertEquals(dummyTextClassifier, editText.getTextClassifier());
}
#end_block

#method_before
@SdkSuppress(minSdkVersion = 26)
@Test
public void testSetTextClassifier() {
    final AppCompatEditText editText = new AppCompatEditText(mActivityTestRule.getActivity());
    editText.setTextClassifier(new DummyTextClassifier());
    assertEquals(DummyTextClassifier.class, editText.getTextClassifier().getClass());
}
#method_after
@SdkSuppress(minSdkVersion = 26)
@Test
public void testSetTextClassifier() {
    final AppCompatEditText editText = new AppCompatEditText(mActivityTestRule.getActivity());
    DummyTextClassifier dummyTextClassifier = new DummyTextClassifier();
    editText.setTextClassifier(dummyTextClassifier);
    assertEquals(dummyTextClassifier, editText.getTextClassifier());
}
#end_block

#method_before
@Override
public void tearDown(ITestDevice device, IBuildInfo buildInfo, Throwable e) throws DeviceNotAvailableException {
    int ownerId = firstNonNull(device.getPrimaryUserId(), device.getCurrentUser());
    device.switchUser(ownerId);
    for (Integer id : device.listUsers()) {
        if (id != ownerId && !device.removeUser(id)) {
            CLog.w("Failed to remove user %d", id);
        }
    }
}
#method_after
@Override
public void tearDown(ITestDevice device, IBuildInfo buildInfo, Throwable e) throws DeviceNotAvailableException {
    // treat current user as primary if no primary user found
    int ownerId = firstNonNull(device.getPrimaryUserId(), device.getCurrentUser());
    device.switchUser(ownerId);
    for (Integer id : device.listUsers()) {
        if (id != ownerId && !device.removeUser(id)) {
            CLog.w("Failed to remove user %d", id);
        }
    }
}
#end_block

#method_before
@Override
public void attachAuxEffect(int effectId) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public void attachAuxEffect(int effectId) {
    _attachAuxEffect(effectId);
}
#end_block

#method_before
@Override
public Object _attachAuxEffect(int effectId) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public Object _attachAuxEffect(final int effectId) {
    return addTask(new Task(CALL_COMPLETED_ATTACH_AUX_EFFECT, false) {

        @Override
        void process() {
            float auxEffectSendLevel;
            synchronized (mLock) {
                mAuxEffectId = effectId;
                auxEffectSendLevel = mAuxEffectSendLevel;
            }
            synchronized (mPlayerLock) {
                mPlayer.setAuxEffectInfo(new AuxEffectInfo(effectId, auxEffectSendLevel));
            }
        }
    });
}
#end_block

#method_before
@Override
public void setAuxEffectSendLevel(float level) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public void setAuxEffectSendLevel(float level) {
    _setAuxEffectSendLevel(level);
}
#end_block

#method_before
@Override
public Object _setAuxEffectSendLevel(float level) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public Object _setAuxEffectSendLevel(final float auxEffectSendLevel) {
    return addTask(new Task(CALL_COMPLETED_SET_AUX_EFFECT_SEND_LEVEL, false) {

        @Override
        void process() {
            int auxEffectId;
            synchronized (mLock) {
                auxEffectId = mAuxEffectId;
                mAuxEffectSendLevel = auxEffectSendLevel;
            }
            synchronized (mPlayerLock) {
                mPlayer.setAuxEffectInfo(new AuxEffectInfo(auxEffectId, auxEffectSendLevel));
            }
        }
    });
}
#end_block

#method_before
@Override
public void reset() {
    synchronized (mLock) {
        mMediaItem = null;
        mPrepared = false;
        mVideoWidth = 0;
        mVideoHeight = 0;
        mStartPlaybackTimeNs = -1;
        mPlayingTimeUs = 0;
    }
    // current data source description to suppress stale events before reset.
    synchronized (mPlayerLock) {
        mPlayer.stop(/* reset= */
        true);
    }
}
#method_after
@Override
public void reset() {
    synchronized (mLock) {
        mMediaItem = null;
        mPrepared = false;
        mVideoWidth = 0;
        mVideoHeight = 0;
        mStartPlaybackTimeNs = -1;
        mPlayingTimeUs = 0;
        mAuxEffectId = AuxEffectInfo.NO_AUX_EFFECT_ID;
        mAuxEffectSendLevel = 0f;
    }
    // current data source description to suppress stale events before reset.
    synchronized (mPlayerLock) {
        mPlayer.stop(/* reset= */
        true);
    }
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getWindow().setContentView(R.layout.car_alert_dialog);
    initializeViews();
    setBody(mBody);
    setPositiveButton(mPositiveButtonText);
    setNegativeButton(mNegativeButtonText);
    // setTitleInternal() should be called last because we want to center title and adjust
    // padding depending on body/button configuration.
    setTitleInternal(mTitle);
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getWindow().setContentView(R.layout.car_alert_dialog);
    initializeViews();
    setBody(mBody);
    setPositiveButton(mPositiveButtonText);
    setNegativeButton(mNegativeButtonText);
    setHeaderIcon(mIcon);
    setTitleInternal(mTitle);
    // setupHeader() should be called last because we want to center title and adjust
    // padding depending on icon/body/button configuration.
    setupHeader();
    Window window = getWindow();
    // Background dim animation.
    Resources res = getContext().getResources();
    TypedValue outValue = new TypedValue();
    res.getValue(R.dimen.car_dialog_background_dim, outValue, true);
    float dimAmount = outValue.getFloat();
    ValueAnimator backgroundDimAnimator = ValueAnimator.ofFloat(0f, dimAmount);
    backgroundDimAnimator.setDuration(res.getInteger(R.integer.car_dialog_enter_duration_ms));
    backgroundDimAnimator.addUpdateListener(animation -> window.setDimAmount((float) animation.getAnimatedValue()));
    backgroundDimAnimator.start();
}
#end_block

#method_before
private void setTitleInternal(CharSequence title) {
    boolean hasTitle = !TextUtils.isEmpty(title);
    boolean hasBody = mBodyView.getVisibility() == View.VISIBLE;
    boolean hasButton = mButtonPanel.getVisibility() == View.VISIBLE;
    mTitleView.setText(title);
    mTitleView.setVisibility(hasTitle ? View.VISIBLE : View.GONE);
    // If there's a title, then remove the padding at the top of the content view.
    int topPadding = hasTitle ? 0 : mTopPadding;
    // If there is only title, also remove the padding at the bottom so title is
    // vertically centered.
    int bottomPadding = !hasButton && !hasBody ? 0 : mContentView.getPaddingBottom();
    mContentView.setPaddingRelative(mContentView.getPaddingStart(), topPadding, mContentView.getPaddingEnd(), bottomPadding);
}
#method_after
private void setTitleInternal(CharSequence title) {
    boolean hasTitle = !TextUtils.isEmpty(title);
    mTitleView.setText(title);
    mTitleView.setVisibility(hasTitle ? View.VISIBLE : View.GONE);
}
#end_block

#method_before
private void initializeViews() {
    Window window = getWindow();
    mContentView = window.findViewById(R.id.content_view);
    mTitleView = window.findViewById(R.id.title);
    mBodyView = window.findViewById(R.id.body);
    mButtonPanel = window.findViewById(R.id.button_panel);
    mButtonPanelTouchDelegate = new ButtonPanelTouchDelegate(mButtonPanel);
    mButtonPanel.setTouchDelegate(mButtonPanelTouchDelegate);
    mPositiveButton = window.findViewById(R.id.positive_button);
    mNegativeButton = window.findViewById(R.id.negative_button);
    mPositiveButton.setOnClickListener(v -> onPositiveButtonClick());
    mNegativeButton.setOnClickListener(v -> onNegativeButtonClick());
}
#method_after
private void initializeViews() {
    Window window = getWindow();
    mContentView = window.findViewById(R.id.content_view);
    mHeaderView = window.findViewById(R.id.header_view);
    mIconView = window.findViewById(R.id.icon_view);
    mTitleView = window.findViewById(R.id.title);
    mBodyView = window.findViewById(R.id.body);
    mButtonPanel = window.findViewById(R.id.button_panel);
    mButtonPanelTouchDelegate = new ButtonPanelTouchDelegate(mButtonPanel);
    mButtonPanel.setTouchDelegate(mButtonPanelTouchDelegate);
    mPositiveButton = window.findViewById(R.id.positive_button);
    mNegativeButton = window.findViewById(R.id.negative_button);
    mPositiveButton.setOnClickListener(v -> onPositiveButtonClick());
    mNegativeButton.setOnClickListener(v -> onNegativeButtonClick());
}
#end_block

#method_before
@Override
public Dialog onCreateDialog(Bundle savedInstanceState) {
    Context context = getContext();
    Bundle args = getArguments();
    CarAlertDialog.Builder builder = new CarAlertDialog.Builder(context);
    if (args.getBoolean(HAS_TITLE_KEY)) {
        builder.setTitle(context.getString(R.string.alert_dialog_title));
    }
    if (args.getBoolean(HAS_IMAGE_KEY)) {
        int sampleIcon = android.R.drawable.sym_def_app_icon;
        builder.setImage(context.getResources().getDrawable(sampleIcon));
    }
    if (args.getBoolean(HAS_BODY_KEY)) {
        builder.setBody(context.getString(R.string.alert_dialog_body));
    }
    if (args.getBoolean(HAS_SINGLE_LINE_BODY_KEY)) {
        builder.setBody(context.getString(R.string.alert_dialog_body_single_line));
    }
    if (args.getBoolean(HAS_ACTION_1_KEY)) {
        builder.setPositiveButton(context.getString(R.string.alert_dialog_action1), /* listener= */
        null);
    }
    if (args.getBoolean(HAS_ACTION_2_KEY)) {
        builder.setNegativeButton(context.getString(R.string.alert_dialog_action2), /* listener= */
        null);
    }
    return builder.create();
}
#method_after
@Override
public Dialog onCreateDialog(Bundle savedInstanceState) {
    Context context = getContext();
    Bundle args = getArguments();
    CarAlertDialog.Builder builder = new CarAlertDialog.Builder(context);
    if (args.getBoolean(HAS_TITLE_KEY)) {
        builder.setTitle(context.getString(R.string.alert_dialog_title));
    }
    if (args.getBoolean(HAS_IMAGE_KEY)) {
        int sampleIcon = android.R.drawable.sym_def_app_icon;
        builder.setHeaderIcon(sampleIcon);
    }
    if (args.getBoolean(HAS_BODY_KEY)) {
        builder.setBody(context.getString(R.string.alert_dialog_body));
    }
    if (args.getBoolean(HAS_SINGLE_LINE_BODY_KEY)) {
        builder.setBody(context.getString(R.string.alert_dialog_body_single_line));
    }
    if (args.getBoolean(HAS_ACTION_1_KEY)) {
        builder.setPositiveButton(context.getString(R.string.alert_dialog_action1), /* listener= */
        null);
    }
    if (args.getBoolean(HAS_ACTION_2_KEY)) {
        builder.setNegativeButton(context.getString(R.string.alert_dialog_action2), /* listener= */
        null);
    }
    return builder.create();
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getWindow().setContentView(R.layout.car_alert_dialog);
    initializeViews();
    setBody(mBody);
    setPositiveButton(mPositiveButtonText);
    setNegativeButton(mNegativeButtonText);
    setImage(mImage);
    setTitleInternal(mTitle);
    // setupHeader() should be called last because we want to center title and adjust
    // padding depending on image/body/button configuration.
    setupHeader();
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getWindow().setContentView(R.layout.car_alert_dialog);
    initializeViews();
    setBody(mBody);
    setPositiveButton(mPositiveButtonText);
    setNegativeButton(mNegativeButtonText);
    setHeaderIcon(mIcon);
    setTitleInternal(mTitle);
    // setupHeader() should be called last because we want to center title and adjust
    // padding depending on icon/body/button configuration.
    setupHeader();
}
#end_block

#method_before
private void setupHeader() {
    boolean hasTitle = mTitleView.getVisibility() == View.VISIBLE;
    boolean hasImage = mImageView.getVisibility() == View.VISIBLE;
    boolean hasBody = mBodyView.getVisibility() == View.VISIBLE;
    boolean hasButton = mButtonPanel.getVisibility() == View.VISIBLE;
    boolean onlyTitle = !hasImage && !hasButton && !hasBody;
    // If there's a title, then remove the padding at the top of the content view.
    int topPadding = (hasTitle || hasImage) ? 0 : mTopPadding;
    // If there is only title, also remove the padding at the bottom so title is
    // vertically centered.
    int bottomPadding = onlyTitle ? 0 : mContentView.getPaddingBottom();
    mContentView.setPaddingRelative(mContentView.getPaddingStart(), topPadding, mContentView.getPaddingEnd(), bottomPadding);
    // Remove the Header padding if there's an image.
    int headerTopPadding = hasImage ? mHeaderView.getPaddingTop() : 0;
    int headerBottomPadding = hasImage ? mHeaderView.getPaddingBottom() : 0;
    mHeaderView.setPaddingRelative(mHeaderView.getPaddingStart(), headerTopPadding, mHeaderView.getPaddingEnd(), headerBottomPadding);
}
#method_after
private void setupHeader() {
    boolean hasTitle = mTitleView.getVisibility() == View.VISIBLE;
    boolean hasIcon = mIconView.getVisibility() == View.VISIBLE;
    boolean hasBody = mBodyView.getVisibility() == View.VISIBLE;
    boolean hasButton = mButtonPanel.getVisibility() == View.VISIBLE;
    boolean onlyTitle = !hasIcon && !hasButton && !hasBody;
    // If there's a title, then remove the padding at the top of the content view.
    int topPadding = (hasTitle || hasIcon) ? 0 : mTopPadding;
    // If there is only title, also remove the padding at the bottom so title is
    // vertically centered.
    int bottomPadding = onlyTitle ? 0 : mContentView.getPaddingBottom();
    mContentView.setPaddingRelative(mContentView.getPaddingStart(), topPadding, mContentView.getPaddingEnd(), bottomPadding);
    // Remove the Header padding if there's an icon.
    int headerTopPadding = hasIcon ? mHeaderView.getPaddingTop() : 0;
    int headerBottomPadding = hasIcon ? mHeaderView.getPaddingBottom() : 0;
    mHeaderView.setPaddingRelative(mHeaderView.getPaddingStart(), headerTopPadding, mHeaderView.getPaddingEnd(), headerBottomPadding);
}
#end_block

#method_before
private void initializeViews() {
    Window window = getWindow();
    mContentView = window.findViewById(R.id.content_view);
    mHeaderView = window.findViewById(R.id.header_view);
    mImageView = window.findViewById(R.id.image_view);
    mTitleView = window.findViewById(R.id.title);
    mBodyView = window.findViewById(R.id.body);
    mButtonPanel = window.findViewById(R.id.button_panel);
    mButtonPanelTouchDelegate = new ButtonPanelTouchDelegate(mButtonPanel);
    mButtonPanel.setTouchDelegate(mButtonPanelTouchDelegate);
    mPositiveButton = window.findViewById(R.id.positive_button);
    mNegativeButton = window.findViewById(R.id.negative_button);
    mPositiveButton.setOnClickListener(v -> onPositiveButtonClick());
    mNegativeButton.setOnClickListener(v -> onNegativeButtonClick());
}
#method_after
private void initializeViews() {
    Window window = getWindow();
    mContentView = window.findViewById(R.id.content_view);
    mHeaderView = window.findViewById(R.id.header_view);
    mIconView = window.findViewById(R.id.icon_view);
    mTitleView = window.findViewById(R.id.title);
    mBodyView = window.findViewById(R.id.body);
    mButtonPanel = window.findViewById(R.id.button_panel);
    mButtonPanelTouchDelegate = new ButtonPanelTouchDelegate(mButtonPanel);
    mButtonPanel.setTouchDelegate(mButtonPanelTouchDelegate);
    mPositiveButton = window.findViewById(R.id.positive_button);
    mNegativeButton = window.findViewById(R.id.negative_button);
    mPositiveButton.setOnClickListener(v -> onPositiveButtonClick());
    mNegativeButton.setOnClickListener(v -> onNegativeButtonClick());
}
#end_block

#method_before
@Override
public void close() {
    mPlayer.release();
    if (mHandlerThread != null) {
        mHandlerThread.quitSafely();
        mHandlerThread = null;
    }
}
#method_after
@Override
public void close() {
    clearEventCallback();
    clearDrmEventCallback();
    mPlayer.release();
    if (mHandlerThread != null) {
        mHandlerThread.quitSafely();
        mHandlerThread = null;
    }
}
#end_block

#method_before
@Override
@NonNull
public MediaItem2 getCurrentMediaItem() {
    return mPlayer.getFirst().getDSD();
}
#method_after
@Override
@Nullable
public MediaItem2 getCurrentMediaItem() {
    return mPlayer.getFirst().getDSD();
}
#end_block

#method_before
@Override
public void reset() {
    clearPendingCommands();
    mEndPositionHandler.removeCallbacksAndMessages(null);
    mTaskHandler.removeCallbacksAndMessages(null);
    // Make sure that the current task finishes.
    Task currentTask;
    synchronized (mTaskLock) {
        currentTask = mCurrentTask;
    }
    if (currentTask != null) {
        synchronized (currentTask) {
            try {
                currentTask.wait(RESET_TIMEOUT);
            } catch (InterruptedException e) {
            }
        }
    }
    mPlayer.reset();
}
#method_after
@Override
public void reset() {
    clearPendingCommands();
    mEndPositionHandler.removeCallbacksAndMessages(null);
    mTaskHandler.removeCallbacksAndMessages(null);
    // Make sure that the current task finishes.
    Task currentTask;
    synchronized (mTaskLock) {
        currentTask = mCurrentTask;
    }
    if (currentTask != null) {
        synchronized (currentTask) {
            try {
                while (!currentTask.mDone) {
                    currentTask.wait();
                }
            } catch (InterruptedException e) {
            }
        }
    }
    mPlayer.reset();
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void notifyMediaPlayer2Event(final Mp2EventNotifier notifier) {
    final Pair<Executor, EventCallback> record;
    synchronized (mLock) {
        record = mMp2EventCallbackRecord;
    }
    if (record != null) {
        record.first.execute(new Runnable() {

            @Override
            public void run() {
                notifier.notify(record.second);
            }
        });
    }
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void notifyMediaPlayer2Event(final Mp2EventNotifier notifier) {
    final Pair<Executor, EventCallback> record;
    synchronized (mLock) {
        record = mMp2EventCallbackRecord;
    }
    if (record != null) {
        try {
            record.first.execute(new Runnable() {

                @Override
                public void run() {
                    notifier.notify(record.second);
                }
            });
        } catch (RejectedExecutionException e) {
            // The given executor is shutting down.
            Log.w(TAG, "The given executor is shutting down. Ignoring the player event.");
        }
    }
}
#end_block

#method_before
@Override
public synchronized void run() {
    int status = CALL_STATUS_NO_ERROR;
    boolean skip;
    synchronized (mTaskLock) {
        skip = mSkip;
    }
    if (!skip) {
        try {
            if (mMediaCallType != CALL_COMPLETED_NOTIFY_WHEN_COMMAND_LABEL_REACHED && getState() == PLAYER_STATE_ERROR) {
                status = CALL_STATUS_INVALID_OPERATION;
            } else {
                process();
            }
        } catch (IllegalStateException e) {
            status = CALL_STATUS_INVALID_OPERATION;
        } catch (IllegalArgumentException e) {
            status = CALL_STATUS_BAD_VALUE;
        } catch (SecurityException e) {
            status = CALL_STATUS_PERMISSION_DENIED;
        } catch (IOException e) {
            status = CALL_STATUS_ERROR_IO;
        } catch (Exception e) {
            status = CALL_STATUS_ERROR_UNKNOWN;
        }
    } else {
        status = CALL_STATUS_SKIPPED;
    }
    mDSD = getCurrentMediaItem();
    if (!mNeedToWaitForEventToComplete || status != CALL_STATUS_NO_ERROR || skip) {
        sendCompleteNotification(status);
        synchronized (mTaskLock) {
            mCurrentTask = null;
            processPendingTask_l();
        }
    }
    // reset() might be waiting for this task. Notify that the task is done.
    this.notifyAll();
}
#method_after
@Override
public void run() {
    int status = CALL_STATUS_NO_ERROR;
    boolean skip;
    synchronized (mTaskLock) {
        skip = mSkip;
    }
    if (!skip) {
        try {
            if (mMediaCallType != CALL_COMPLETED_NOTIFY_WHEN_COMMAND_LABEL_REACHED && getState() == PLAYER_STATE_ERROR) {
                status = CALL_STATUS_INVALID_OPERATION;
            } else {
                process();
            }
        } catch (IllegalStateException e) {
            status = CALL_STATUS_INVALID_OPERATION;
        } catch (IllegalArgumentException e) {
            status = CALL_STATUS_BAD_VALUE;
        } catch (SecurityException e) {
            status = CALL_STATUS_PERMISSION_DENIED;
        } catch (IOException e) {
            status = CALL_STATUS_ERROR_IO;
        } catch (Exception e) {
            status = CALL_STATUS_ERROR_UNKNOWN;
        }
    } else {
        status = CALL_STATUS_SKIPPED;
    }
    mDSD = getCurrentMediaItem();
    if (!mNeedToWaitForEventToComplete || status != CALL_STATUS_NO_ERROR || skip) {
        sendCompleteNotification(status);
        synchronized (mTaskLock) {
            mCurrentTask = null;
            processPendingTask_l();
        }
    }
    // reset() might be waiting for this task. Notify that the task is done.
    synchronized (this) {
        mDone = true;
        this.notifyAll();
    }
}
#end_block

#method_before
@Test
@MediumTest
public void testReset() throws Exception {
    assertTrue(loadResource(R.raw.testmp3_2));
    AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
    mPlayer.setAudioAttributes(attributes);
    mPlayer.reset();
    assertNull(mPlayer.getAudioAttributes());
    assertNull(mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@LargeTest
public void testReset() throws Exception {
    assertTrue(loadResource(R.raw.testmp3_2));
    AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
    mPlayer.setAudioAttributes(attributes);
    mPlayer.reset();
    assertNull(mPlayer.getAudioAttributes());
    assertNull(mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
@Test
@MediumTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.P)
public void testReset() throws Exception {
    assertTrue(loadResource(R.raw.testmp3_2));
    AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
    mPlayer.setAudioAttributes(attributes);
    mPlayer.reset();
    assertNull(mPlayer.getAudioAttributes());
    assertNull(mPlayer.getCurrentMediaItem());
}
#method_after
@Test
@LargeTest
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.P)
public void testReset() throws Exception {
    assertTrue(loadResource(R.raw.testmp3_2));
    AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
    mPlayer.setAudioAttributes(attributes);
    mPlayer.reset();
    assertNull(mPlayer.getAudioAttributes());
    assertNull(mPlayer.getCurrentMediaItem());
}
#end_block

#method_before
private int getShade(Card card) {
    switch(card.getValue()) {
        case "2":
        case "6":
        case "10":
        case "A":
            return 2;
        case "3":
        case "7":
        case "J":
            return 3;
        case "4":
        case "8":
        case "Q":
            return 0;
        case "5":
        case "9":
        case "K":
            return 1;
    }
    throw new IllegalStateException(String.format("Card value cannot be %s (0x%s)", card.getValue(), card.getValue()));
}
#method_after
private int getShade(Card card) {
    switch(card.getValue()) {
        case "2":
        case "6":
        case "10":
        case "A":
            return 2;
        case "3":
        case "7":
        case "J":
            return 3;
        case "4":
        case "8":
        case "Q":
            return 0;
        case "5":
        case "9":
        case "K":
            return 1;
    }
    throw new IllegalStateException(String.format("Card value cannot be %s", card.getValue()));
}
#end_block

#method_before
private int getColor(Card card) {
    switch(card.getSuit()) {
        case "":
            return 0;
        case "":
            return 1;
        case "":
            return 2;
        case "":
            return 3;
    }
    throw new IllegalStateException(String.format("Card suit cannot be %s (0x%s)", card.getSuit(), card.getSuit()));
}
#method_after
private int getColor(Card card) {
    switch(card.getSuit()) {
        case "":
            return 0;
        case "":
            return 1;
        case "":
            return 2;
        case "":
            return 3;
    }
    throw new IllegalStateException(String.format("Card suit cannot be %s", card.getSuit()));
}
#end_block

#method_before
@Override
public void onCreate(Bundle bundle) {
    super.onCreate(bundle);
    setContentView(R.layout.activity_card_layout);
    mViewPager = findViewById(R.id.view_pager);
    Spinner orientationSelector = findViewById(R.id.orientation_spinner);
    mValueSelector = findViewById(R.id.value_spinner);
    mSuitSelector = findViewById(R.id.suit_spinner);
    mSmoothScrollCheckBox = findViewById(R.id.smooth_scroll_checkbox);
    mRotateCheckBox = findViewById(R.id.rotate_checkbox);
    mTranslateCheckBox = findViewById(R.id.translate_checkbox);
    mScaleCheckBox = findViewById(R.id.scale_checkbox);
    Button gotoPage = findViewById(R.id.jump_button);
    orientationSelector.setAdapter(createOrientationAdapter());
    mValueSelector.setAdapter(createAdapter(Card.VALUES));
    mSuitSelector.setAdapter(createAdapter(Card.SUITS));
    mViewPager.setPageTransformer(mAnimator);
    orientationSelector.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {

        @Override
        public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
            switch(parent.getSelectedItem().toString()) {
                case HORIZONTAL:
                    mViewPager.setOrientation(Orientation.HORIZONTAL);
                    break;
                case VERTICAL:
                    mViewPager.setOrientation(Orientation.VERTICAL);
                    break;
            }
        }

        @Override
        public void onNothingSelected(AdapterView<?> adapterView) {
        }
    });
    gotoPage.setOnClickListener(view -> {
        int suit = mSuitSelector.getSelectedItemPosition();
        int value = mValueSelector.getSelectedItemPosition();
        int targetPosition = suit * Card.VALUES.size() + value;
        boolean smoothScroll = mSmoothScrollCheckBox.isChecked();
        mViewPager.setCurrentItem(targetPosition, smoothScroll);
    });
}
#method_after
@Override
public void onCreate(Bundle bundle) {
    super.onCreate(bundle);
    setContentView(R.layout.activity_card_layout);
    mViewPager = findViewById(R.id.view_pager);
    mOrientationSelector = findViewById(R.id.orientation_spinner);
    mValueSelector = findViewById(R.id.value_spinner);
    mSuitSelector = findViewById(R.id.suit_spinner);
    mSmoothScrollCheckBox = findViewById(R.id.smooth_scroll_checkbox);
    mRotateCheckBox = findViewById(R.id.rotate_checkbox);
    mTranslateCheckBox = findViewById(R.id.translate_checkbox);
    mScaleCheckBox = findViewById(R.id.scale_checkbox);
    mGotoPage = findViewById(R.id.jump_button);
    mOrientationSelector.setAdapter(createOrientationAdapter());
    mValueSelector.setAdapter(createAdapter(Card.VALUES));
    mSuitSelector.setAdapter(createAdapter(Card.SUITS));
    mViewPager.setPageTransformer(mAnimator);
    mOrientationSelector.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {

        @Override
        public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
            switch(parent.getSelectedItem().toString()) {
                case HORIZONTAL:
                    mViewPager.setOrientation(Orientation.HORIZONTAL);
                    break;
                case VERTICAL:
                    mViewPager.setOrientation(Orientation.VERTICAL);
                    break;
            }
        }

        @Override
        public void onNothingSelected(AdapterView<?> adapterView) {
        }
    });
    mGotoPage.setOnClickListener(view -> {
        int suit = mSuitSelector.getSelectedItemPosition();
        int value = mValueSelector.getSelectedItemPosition();
        int targetPosition = suit * Card.VALUES.size() + value;
        boolean smoothScroll = mSmoothScrollCheckBox.isChecked();
        mViewPager.setCurrentItem(targetPosition, smoothScroll);
    });
}
#end_block

#method_before
@Test
@SmallTest
public void testSetWifi() {
    ImsCall mTestImsCall = new ImsCall(mContext, mTestCallProfile);
    assertFalse(mTestImsCall.isWifiCall());
    assertFalse(mTestImsCall.getRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
    mBundle.putString(ImsCallProfile.EXTRA_CALL_RAT_TYPE, ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN + "");
    assertTrue(mTestImsCall.isWifiCall());
    assertFalse(mTestImsCall.getRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
}
#method_after
@Test
@SmallTest
public void testSetWifi() {
    ImsCall mTestImsCall = new ImsCall(mContext, mTestCallProfile);
    assertFalse(mTestImsCall.isWifiCall());
    assertNotEquals(mTestImsCall.getRadioTechnology(), ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
    mBundle.putString(ImsCallProfile.EXTRA_CALL_RAT_TYPE, ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN + "");
    assertTrue(mTestImsCall.isWifiCall());
    assertNotEquals(mTestImsCall.getRadioTechnology(), ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
}
#end_block

#method_before
@Test
@SmallTest
public void testSetWifiAlt() {
    ImsCall mTestImsCall = new ImsCall(mContext, mTestCallProfile);
    assertFalse(mTestImsCall.isWifiCall());
    assertFalse(mTestImsCall.getRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
    mBundle.putString(ImsCallProfile.EXTRA_CALL_RAT_TYPE_ALT, ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN + "");
    assertTrue(mTestImsCall.isWifiCall());
    assertFalse(mTestImsCall.getRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
}
#method_after
@Test
@SmallTest
public void testSetWifiAlt() {
    ImsCall mTestImsCall = new ImsCall(mContext, mTestCallProfile);
    assertFalse(mTestImsCall.isWifiCall());
    assertNotEquals(mTestImsCall.getRadioTechnology(), ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
    mBundle.putString(ImsCallProfile.EXTRA_CALL_RAT_TYPE_ALT, ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN + "");
    assertTrue(mTestImsCall.isWifiCall());
    assertNotEquals(mTestImsCall.getRadioTechnology(), ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
}
#end_block

#method_before
@Test
@SmallTest
public void testSetLteNoWifi() {
    ImsCall mTestImsCall = new ImsCall(mContext, mTestCallProfile);
    assertFalse(mTestImsCall.isWifiCall());
    assertFalse(mTestImsCall.getRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
    mBundle.putString(ImsCallProfile.EXTRA_CALL_RAT_TYPE, ServiceState.RIL_RADIO_TECHNOLOGY_LTE + "");
    assertFalse(mTestImsCall.isWifiCall());
    assertTrue(mTestImsCall.getRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
}
#method_after
@Test
@SmallTest
public void testSetLteNoWifi() {
    ImsCall mTestImsCall = new ImsCall(mContext, mTestCallProfile);
    assertFalse(mTestImsCall.isWifiCall());
    assertNotEquals(mTestImsCall.getRadioTechnology(), ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
    mBundle.putString(ImsCallProfile.EXTRA_CALL_RAT_TYPE, ServiceState.RIL_RADIO_TECHNOLOGY_LTE + "");
    assertFalse(mTestImsCall.isWifiCall());
    assertEquals(mTestImsCall.getRadioTechnology(), ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
}
#end_block

#method_before
@Test
@SmallTest
public void testSetLteNoWifiAlt() {
    ImsCall mTestImsCall = new ImsCall(mContext, mTestCallProfile);
    assertFalse(mTestImsCall.isWifiCall());
    assertFalse(mTestImsCall.getRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
    mBundle.putString(ImsCallProfile.EXTRA_CALL_RAT_TYPE_ALT, ServiceState.RIL_RADIO_TECHNOLOGY_LTE + "");
    assertFalse(mTestImsCall.isWifiCall());
    assertTrue(mTestImsCall.getRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
}
#method_after
@Test
@SmallTest
public void testSetLteNoWifiAlt() {
    ImsCall mTestImsCall = new ImsCall(mContext, mTestCallProfile);
    assertFalse(mTestImsCall.isWifiCall());
    assertNotEquals(mTestImsCall.getRadioTechnology(), ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
    mBundle.putString(ImsCallProfile.EXTRA_CALL_RAT_TYPE_ALT, ServiceState.RIL_RADIO_TECHNOLOGY_LTE + "");
    assertFalse(mTestImsCall.isWifiCall());
    assertEquals(mTestImsCall.getRadioTechnology(), ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    Message onComplete;
    switch(msg.what) {
        case EVENT_RADIO_AVAILABLE:
            {
                handleRadioAvailable();
            }
            break;
        case EVENT_GET_DEVICE_IDENTITY_DONE:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                String[] respId = (String[]) ar.result;
                mImei = respId[0];
                mImeiSv = respId[1];
                mEsn = respId[2];
                mMeid = respId[3];
            }
            break;
        case EVENT_EMERGENCY_CALLBACK_MODE_ENTER:
            {
                handleEnterEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE:
            {
                handleExitEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_MODEM_RESET:
            {
                logd("Event EVENT_MODEM_RESET Received" + " isInEcm = " + isInEcm() + " isPhoneTypeGsm = " + isPhoneTypeGsm() + " mImsPhone = " + mImsPhone);
                if (isInEcm()) {
                    if (isPhoneTypeGsm()) {
                        if (mImsPhone != null) {
                            mImsPhone.handleExitEmergencyCallbackMode();
                        }
                    } else {
                        handleExitEmergencyCallbackMode(msg);
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            logd("Event EVENT_RUIM_RECORDS_LOADED Received");
            updateCurrentCarrierInProvider();
            break;
        case EVENT_RADIO_ON:
            logd("Event EVENT_RADIO_ON Received");
            handleRadioOn();
            break;
        case EVENT_RIL_CONNECTED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null && ar.result != null) {
                mRilVersion = (Integer) ar.result;
            } else {
                logd("Unexpected exception on EVENT_RIL_CONNECTED");
                mRilVersion = -1;
            }
            break;
        case EVENT_VOICE_RADIO_TECH_CHANGED:
        case EVENT_REQUEST_VOICE_RADIO_TECH_DONE:
            String what = (msg.what == EVENT_VOICE_RADIO_TECH_CHANGED) ? "EVENT_VOICE_RADIO_TECH_CHANGED" : "EVENT_REQUEST_VOICE_RADIO_TECH_DONE";
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                if ((ar.result != null) && (((int[]) ar.result).length != 0)) {
                    int newVoiceTech = ((int[]) ar.result)[0];
                    logd(what + ": newVoiceTech=" + newVoiceTech);
                    phoneObjectUpdater(newVoiceTech);
                } else {
                    loge(what + ": has no tech!");
                }
            } else {
                loge(what + ": exception=" + ar.exception);
            }
            break;
        case EVENT_UPDATE_PHONE_OBJECT:
            phoneObjectUpdater(msg.arg1);
            break;
        case EVENT_CARRIER_CONFIG_CHANGED:
            // registration changes.
            if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_switch_phone_on_voice_reg_state_change)) {
                mCi.getVoiceRadioTechnology(obtainMessage(EVENT_REQUEST_VOICE_RADIO_TECH_DONE));
            }
            // Force update IMS service if it is available, if it isn't the config will be
            // updated when ImsPhoneCallTracker opens a connection.
            ImsManager imsManager = ImsManager.getInstance(mContext, mPhoneId);
            if (imsManager.isServiceAvailable()) {
                imsManager.updateImsServiceConfig(true);
            } else {
                logd("ImsManager is not available to update CarrierConfig.");
            }
            // Update broadcastEmergencyCallStateChanges
            CarrierConfigManager configMgr = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
            PersistableBundle b = configMgr.getConfigForSubId(getSubId());
            if (b != null) {
                boolean broadcastEmergencyCallStateChanges = b.getBoolean(CarrierConfigManager.KEY_BROADCAST_EMERGENCY_CALL_STATE_CHANGES_BOOL);
                logd("broadcastEmergencyCallStateChanges = " + broadcastEmergencyCallStateChanges);
                setBroadcastEmergencyCallStateChanges(broadcastEmergencyCallStateChanges);
            } else {
                loge("didn't get broadcastEmergencyCallStateChanges from carrier config");
            }
            // Changing the cdma roaming settings based carrier config.
            if (b != null) {
                int config_cdma_roaming_mode = b.getInt(CarrierConfigManager.KEY_CDMA_ROAMING_MODE_INT);
                int current_cdma_roaming_mode = Settings.Global.getInt(getContext().getContentResolver(), Settings.Global.CDMA_ROAMING_MODE, TelephonyManager.CDMA_ROAMING_MODE_RADIO_DEFAULT);
                switch(config_cdma_roaming_mode) {
                    // when carrier's setting is turn off.
                    case TelephonyManager.CDMA_ROAMING_MODE_HOME:
                    case TelephonyManager.CDMA_ROAMING_MODE_AFFILIATED:
                    case TelephonyManager.CDMA_ROAMING_MODE_ANY:
                        logd("cdma_roaming_mode is going to changed to " + config_cdma_roaming_mode);
                        setCdmaRoamingPreference(config_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        break;
                    // previous user's setting
                    case TelephonyManager.CDMA_ROAMING_MODE_RADIO_DEFAULT:
                        if (current_cdma_roaming_mode != config_cdma_roaming_mode) {
                            logd("cdma_roaming_mode is going to changed to " + current_cdma_roaming_mode);
                            setCdmaRoamingPreference(current_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        }
                    default:
                        loge("Invalid cdma_roaming_mode settings: " + config_cdma_roaming_mode);
                }
            } else {
                loge("didn't get the cdma_roaming_mode changes from the carrier config.");
            }
            // Load the ERI based on carrier config. Carrier might have their specific ERI.
            prepareEri();
            mSST.pollState();
            break;
        case EVENT_SET_ROAMING_PREFERENCE_DONE:
            logd("cdma_roaming_mode change is done");
            break;
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            logd("EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED");
            mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
            break;
        case EVENT_REGISTERED_TO_NETWORK:
            logd("Event EVENT_REGISTERED_TO_NETWORK Received");
            if (isPhoneTypeGsm()) {
                syncClirSetting();
            }
            break;
        case EVENT_SIM_RECORDS_LOADED:
            updateCurrentCarrierInProvider();
            // Check if this is a different SIM than the previous one. If so unset the
            // voice mail number.
            String imsi = getVmSimImsi();
            String imsiFromSIM = getSubscriberId();
            if ((!isPhoneTypeGsm() || imsi != null) && imsiFromSIM != null && !imsiFromSIM.equals(imsi)) {
                storeVoiceMailNumber(null);
                setVmSimImsi(null);
            }
            mSimRecordsLoadedRegistrants.notifyRegistrants();
            break;
        case EVENT_GET_BASEBAND_VERSION_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            if (DBG)
                logd("Baseband version: " + ar.result);
            TelephonyManager.from(mContext).setBasebandVersionForPhone(getPhoneId(), (String) ar.result);
            break;
        case EVENT_GET_IMEI_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImei = (String) ar.result;
            break;
        case EVENT_GET_IMEISV_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImeiSv = (String) ar.result;
            break;
        case EVENT_USSD:
            ar = (AsyncResult) msg.obj;
            String[] ussdResult = (String[]) ar.result;
            if (ussdResult.length > 1) {
                try {
                    onIncomingUSSD(Integer.parseInt(ussdResult[0]), ussdResult[1]);
                } catch (NumberFormatException e) {
                    Rlog.w(LOG_TAG, "error parsing USSD");
                }
            }
            break;
        case EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
            {
                logd("Event EVENT_RADIO_OFF_OR_NOT_AVAILABLE Received");
                handleRadioOffOrNotAvailable();
                break;
            }
        case EVENT_SSN:
            logd("Event EVENT_SSN Received");
            if (isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                SuppServiceNotification not = (SuppServiceNotification) ar.result;
                mSsnRegistrants.notifyRegistrants(ar);
            }
            break;
        case EVENT_SET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            IccRecords r = mIccRecords.get();
            Cfu cfu = (Cfu) ar.userObj;
            if (ar.exception == null && r != null) {
                setVoiceCallForwardingFlag(1, msg.arg1 == 1, cfu.mSetCfNumber);
            }
            if (cfu.mOnComplete != null) {
                AsyncResult.forMessage(cfu.mOnComplete, ar.result, ar.exception);
                cfu.mOnComplete.sendToTarget();
            }
            break;
        case EVENT_SET_VM_NUMBER_DONE:
            ar = (AsyncResult) msg.obj;
            if ((isPhoneTypeGsm() && IccVmNotSupportedException.class.isInstance(ar.exception)) || (!isPhoneTypeGsm() && IccException.class.isInstance(ar.exception))) {
                storeVoiceMailNumber(mVmNumber);
                ar.exception = null;
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_GET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                handleCfuQueryResult((CallForwardInfo[]) ar.result);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SET_NETWORK_AUTOMATIC:
            // Automatic network selection from EF_CSP SIM record
            ar = (AsyncResult) msg.obj;
            if (mSST.mSS.getIsManualSelection()) {
                setNetworkSelectionModeAutomatic((Message) ar.result);
                logd("SET_NETWORK_SELECTION_AUTOMATIC: set to automatic");
            } else {
                // prevent duplicate request which will push current PLMN to low priority
                logd("SET_NETWORK_SELECTION_AUTOMATIC: already automatic, ignore");
            }
            break;
        case EVENT_ICC_RECORD_EVENTS:
            ar = (AsyncResult) msg.obj;
            processIccRecordEvents((Integer) ar.result);
            break;
        case EVENT_SET_CLIR_COMPLETE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                saveClirSetting(msg.arg1);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SS:
            ar = (AsyncResult) msg.obj;
            logd("Event EVENT_SS received");
            if (isPhoneTypeGsm()) {
                // SS data is already being handled through MMI codes.
                // So, this result if processed as MMI response would help
                // in re-using the existing functionality.
                GsmMmiCode mmi = new GsmMmiCode(this, mUiccApplication.get());
                mmi.processSsData(ar);
            }
            break;
        case EVENT_GET_RADIO_CAPABILITY:
            ar = (AsyncResult) msg.obj;
            RadioCapability rc = (RadioCapability) ar.result;
            if (ar.exception != null) {
                Rlog.d(LOG_TAG, "get phone radio capability fail, no need to change " + "mRadioCapability");
            } else {
                radioCapabilityUpdated(rc);
            }
            Rlog.d(LOG_TAG, "EVENT_GET_RADIO_CAPABILITY: phone rc: " + rc);
            break;
        case EVENT_VRS_OR_RAT_CHANGED:
            onVoiceRegStateOrRatChanged();
            break;
        default:
            super.handleMessage(msg);
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    Message onComplete;
    switch(msg.what) {
        case EVENT_RADIO_AVAILABLE:
            {
                handleRadioAvailable();
            }
            break;
        case EVENT_GET_DEVICE_IDENTITY_DONE:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                String[] respId = (String[]) ar.result;
                mImei = respId[0];
                mImeiSv = respId[1];
                mEsn = respId[2];
                mMeid = respId[3];
            }
            break;
        case EVENT_EMERGENCY_CALLBACK_MODE_ENTER:
            {
                handleEnterEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE:
            {
                handleExitEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_MODEM_RESET:
            {
                logd("Event EVENT_MODEM_RESET Received" + " isInEcm = " + isInEcm() + " isPhoneTypeGsm = " + isPhoneTypeGsm() + " mImsPhone = " + mImsPhone);
                if (isInEcm()) {
                    if (isPhoneTypeGsm()) {
                        if (mImsPhone != null) {
                            mImsPhone.handleExitEmergencyCallbackMode();
                        }
                    } else {
                        handleExitEmergencyCallbackMode(msg);
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            logd("Event EVENT_RUIM_RECORDS_LOADED Received");
            updateCurrentCarrierInProvider();
            break;
        case EVENT_RADIO_ON:
            logd("Event EVENT_RADIO_ON Received");
            handleRadioOn();
            break;
        case EVENT_RIL_CONNECTED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null && ar.result != null) {
                mRilVersion = (Integer) ar.result;
            } else {
                logd("Unexpected exception on EVENT_RIL_CONNECTED");
                mRilVersion = -1;
            }
            break;
        case EVENT_VOICE_RADIO_TECH_CHANGED:
        case EVENT_REQUEST_VOICE_RADIO_TECH_DONE:
            String what = (msg.what == EVENT_VOICE_RADIO_TECH_CHANGED) ? "EVENT_VOICE_RADIO_TECH_CHANGED" : "EVENT_REQUEST_VOICE_RADIO_TECH_DONE";
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                if ((ar.result != null) && (((int[]) ar.result).length != 0)) {
                    int newVoiceTech = ((int[]) ar.result)[0];
                    logd(what + ": newVoiceTech=" + newVoiceTech);
                    phoneObjectUpdater(newVoiceTech);
                } else {
                    loge(what + ": has no tech!");
                }
            } else {
                loge(what + ": exception=" + ar.exception);
            }
            break;
        case EVENT_UPDATE_PHONE_OBJECT:
            phoneObjectUpdater(msg.arg1);
            break;
        case EVENT_CARRIER_CONFIG_CHANGED:
            // registration changes.
            if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_switch_phone_on_voice_reg_state_change)) {
                mCi.getVoiceRadioTechnology(obtainMessage(EVENT_REQUEST_VOICE_RADIO_TECH_DONE));
            }
            // Force update IMS service if it is available, if it isn't the config will be
            // updated when ImsPhoneCallTracker opens a connection.
            ImsManager imsManager = ImsManager.getInstance(mContext, mPhoneId);
            if (imsManager.isServiceAvailable()) {
                imsManager.updateImsServiceConfig(true);
            } else {
                logd("ImsManager is not available to update CarrierConfig.");
            }
            // Update broadcastEmergencyCallStateChanges
            CarrierConfigManager configMgr = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
            PersistableBundle b = configMgr.getConfigForSubId(getSubId());
            if (b != null) {
                boolean broadcastEmergencyCallStateChanges = b.getBoolean(CarrierConfigManager.KEY_BROADCAST_EMERGENCY_CALL_STATE_CHANGES_BOOL);
                logd("broadcastEmergencyCallStateChanges = " + broadcastEmergencyCallStateChanges);
                setBroadcastEmergencyCallStateChanges(broadcastEmergencyCallStateChanges);
            } else {
                loge("didn't get broadcastEmergencyCallStateChanges from carrier config");
            }
            // Changing the cdma roaming settings based carrier config.
            if (b != null) {
                int config_cdma_roaming_mode = b.getInt(CarrierConfigManager.KEY_CDMA_ROAMING_MODE_INT);
                int current_cdma_roaming_mode = Settings.Global.getInt(getContext().getContentResolver(), Settings.Global.CDMA_ROAMING_MODE, TelephonyManager.CDMA_ROAMING_MODE_RADIO_DEFAULT);
                switch(config_cdma_roaming_mode) {
                    // when carrier's setting is turn off.
                    case TelephonyManager.CDMA_ROAMING_MODE_HOME:
                    case TelephonyManager.CDMA_ROAMING_MODE_AFFILIATED:
                    case TelephonyManager.CDMA_ROAMING_MODE_ANY:
                        logd("cdma_roaming_mode is going to changed to " + config_cdma_roaming_mode);
                        setCdmaRoamingPreference(config_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        break;
                    // previous user's setting
                    case TelephonyManager.CDMA_ROAMING_MODE_RADIO_DEFAULT:
                        if (current_cdma_roaming_mode != config_cdma_roaming_mode) {
                            logd("cdma_roaming_mode is going to changed to " + current_cdma_roaming_mode);
                            setCdmaRoamingPreference(current_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        }
                    default:
                        loge("Invalid cdma_roaming_mode settings: " + config_cdma_roaming_mode);
                }
            } else {
                loge("didn't get the cdma_roaming_mode changes from the carrier config.");
            }
            // Load the ERI based on carrier config. Carrier might have their specific ERI.
            prepareEri();
            mSST.pollState();
            break;
        case EVENT_SET_ROAMING_PREFERENCE_DONE:
            logd("cdma_roaming_mode change is done");
            break;
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            logd("EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED");
            mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
            break;
        case EVENT_REGISTERED_TO_NETWORK:
            logd("Event EVENT_REGISTERED_TO_NETWORK Received");
            if (isPhoneTypeGsm()) {
                syncClirSetting();
            }
            break;
        case EVENT_SIM_RECORDS_LOADED:
            updateCurrentCarrierInProvider();
            // Check if this is a different SIM than the previous one. If so unset the
            // voice mail number.
            String imsi = getVmSimImsi();
            String imsiFromSIM = getSubscriberId();
            if ((!isPhoneTypeGsm() || imsi != null) && imsiFromSIM != null && !imsiFromSIM.equals(imsi)) {
                storeVoiceMailNumber(null);
                setVmSimImsi(null);
            }
            updateVoiceMail();
            mSimRecordsLoadedRegistrants.notifyRegistrants();
            break;
        case EVENT_GET_BASEBAND_VERSION_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            if (DBG)
                logd("Baseband version: " + ar.result);
            TelephonyManager.from(mContext).setBasebandVersionForPhone(getPhoneId(), (String) ar.result);
            break;
        case EVENT_GET_IMEI_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImei = (String) ar.result;
            break;
        case EVENT_GET_IMEISV_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImeiSv = (String) ar.result;
            break;
        case EVENT_USSD:
            ar = (AsyncResult) msg.obj;
            String[] ussdResult = (String[]) ar.result;
            if (ussdResult.length > 1) {
                try {
                    onIncomingUSSD(Integer.parseInt(ussdResult[0]), ussdResult[1]);
                } catch (NumberFormatException e) {
                    Rlog.w(LOG_TAG, "error parsing USSD");
                }
            }
            break;
        case EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
            {
                logd("Event EVENT_RADIO_OFF_OR_NOT_AVAILABLE Received");
                handleRadioOffOrNotAvailable();
                break;
            }
        case EVENT_SSN:
            logd("Event EVENT_SSN Received");
            if (isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                SuppServiceNotification not = (SuppServiceNotification) ar.result;
                mSsnRegistrants.notifyRegistrants(ar);
            }
            break;
        case EVENT_SET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            IccRecords r = mIccRecords.get();
            Cfu cfu = (Cfu) ar.userObj;
            if (ar.exception == null && r != null) {
                setVoiceCallForwardingFlag(1, msg.arg1 == 1, cfu.mSetCfNumber);
            }
            if (cfu.mOnComplete != null) {
                AsyncResult.forMessage(cfu.mOnComplete, ar.result, ar.exception);
                cfu.mOnComplete.sendToTarget();
            }
            break;
        case EVENT_SET_VM_NUMBER_DONE:
            ar = (AsyncResult) msg.obj;
            if ((isPhoneTypeGsm() && IccVmNotSupportedException.class.isInstance(ar.exception)) || (!isPhoneTypeGsm() && IccException.class.isInstance(ar.exception))) {
                storeVoiceMailNumber(mVmNumber);
                ar.exception = null;
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_GET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                handleCfuQueryResult((CallForwardInfo[]) ar.result);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SET_NETWORK_AUTOMATIC:
            // Automatic network selection from EF_CSP SIM record
            ar = (AsyncResult) msg.obj;
            if (mSST.mSS.getIsManualSelection()) {
                setNetworkSelectionModeAutomatic((Message) ar.result);
                logd("SET_NETWORK_SELECTION_AUTOMATIC: set to automatic");
            } else {
                // prevent duplicate request which will push current PLMN to low priority
                logd("SET_NETWORK_SELECTION_AUTOMATIC: already automatic, ignore");
            }
            break;
        case EVENT_ICC_RECORD_EVENTS:
            ar = (AsyncResult) msg.obj;
            processIccRecordEvents((Integer) ar.result);
            break;
        case EVENT_SET_CLIR_COMPLETE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                saveClirSetting(msg.arg1);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SS:
            ar = (AsyncResult) msg.obj;
            logd("Event EVENT_SS received");
            if (isPhoneTypeGsm()) {
                // SS data is already being handled through MMI codes.
                // So, this result if processed as MMI response would help
                // in re-using the existing functionality.
                GsmMmiCode mmi = new GsmMmiCode(this, mUiccApplication.get());
                mmi.processSsData(ar);
            }
            break;
        case EVENT_GET_RADIO_CAPABILITY:
            ar = (AsyncResult) msg.obj;
            RadioCapability rc = (RadioCapability) ar.result;
            if (ar.exception != null) {
                Rlog.d(LOG_TAG, "get phone radio capability fail, no need to change " + "mRadioCapability");
            } else {
                radioCapabilityUpdated(rc);
            }
            Rlog.d(LOG_TAG, "EVENT_GET_RADIO_CAPABILITY: phone rc: " + rc);
            break;
        case EVENT_VRS_OR_RAT_CHANGED:
            ar = (AsyncResult) msg.obj;
            Pair<Integer, Integer> vrsRatPair = (Pair<Integer, Integer>) ar.result;
            onVoiceRegStateOrRatChanged(vrsRatPair.first, vrsRatPair.second);
            break;
        default:
            super.handleMessage(msg);
    }
}
#end_block

#method_before
@ServiceState.RilRadioTechnology
public int getCsCallRadioTech() {
    int vrat = ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN;
    if (mSST != null) {
        int vrs = mSST.mSS.getVoiceRegState();
        vrat = mSST.mSS.getRilVoiceRadioTechnology();
        logd("getCsCallRadioTech, current vrs=" + vrs + ", vrat=" + vrat);
        if (vrs != ServiceState.STATE_IN_SERVICE || ArrayUtils.contains(VOICE_PS_CALL_RADIO_TECHNOLOGY, vrat)) {
            vrat = ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN;
        }
    }
    logd("getCsCallRadioTech, result vrat=" + vrat);
    return vrat;
}
#method_after
@ServiceState.RilRadioTechnology
public int getCsCallRadioTech() {
    int calcVrat = ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN;
    if (mSST != null) {
        calcVrat = getCsCallRadioTech(mSST.mSS.getVoiceRegState(), mSST.mSS.getRilVoiceRadioTechnology());
    }
    return calcVrat;
}
#end_block

#method_before
@ServiceState.RilRadioTechnology
public int getCsCallRadioTech() {
    int vrat = ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN;
    if (mSST != null) {
        int vrs = mSST.mSS.getVoiceRegState();
        vrat = mSST.mSS.getRilVoiceRadioTechnology();
        logd("getCsCallRadioTech, current vrs=" + vrs + ", vrat=" + vrat);
        if (vrs != ServiceState.STATE_IN_SERVICE || ArrayUtils.contains(VOICE_PS_CALL_RADIO_TECHNOLOGY, vrat)) {
            vrat = ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN;
        }
    }
    logd("getCsCallRadioTech, result vrat=" + vrat);
    return vrat;
}
#method_after
@ServiceState.RilRadioTechnology
private int getCsCallRadioTech(int vrs, int vrat) {
    logd("getCsCallRadioTech, current vrs=" + vrs + ", vrat=" + vrat);
    int calcVrat = vrat;
    if (vrs != ServiceState.STATE_IN_SERVICE || ArrayUtils.contains(VOICE_PS_CALL_RADIO_TECHNOLOGY, vrat)) {
        calcVrat = ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN;
    }
    logd("getCsCallRadioTech, result calcVrat=" + calcVrat);
    return calcVrat;
}
#end_block

#method_before
private void onVoiceRegStateOrRatChanged() {
    logd("onVoiceRegStateOrRatChanged");
    mCT.dispatchCsCallRadioTech(getCsCallRadioTech());
}
#method_after
private void onVoiceRegStateOrRatChanged(int vrs, int vrat) {
    logd("onVoiceRegStateOrRatChanged");
    mCT.dispatchCsCallRadioTech(getCsCallRadioTech(vrs, vrat));
}
#end_block

#method_before
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    // carrier config gets a priority over ERI
    updateOperatorNameFromCarrierConfig();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    int combinedRegState = getCombinedRegState();
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled() && (combinedRegState == ServiceState.STATE_IN_SERVICE)) {
        // In Wi-Fi Calling mode show SPN or PLMN + WiFi Calling
        // 
        // 1) Show SPN + Wi-Fi Calling If SIM has SPN and SPN display condition
        // is satisfied or SPN override is enabled for this carrier
        // 
        // 2) Show PLMN + Wi-Fi Calling if there is no valid SPN in case 1
        String[] wfcSpnFormats = SubscriptionManager.getResourcesForSubId(mPhone.getContext(), mPhone.getSubId()).getStringArray(com.android.internal.R.array.wfcSpnFormats);
        int voiceIdx = 0;
        int dataIdx = 0;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS) : 0;
        boolean noService = false;
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE || combinedRegState == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            // Force display no service
            final boolean forceDisplayNoService = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_display_no_service_when_sim_unready) && !mIsSimReady;
            if (mEmergencyOnly && !forceDisplayNoService) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
                noService = true;
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (combinedRegState == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !noService && !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // Show SPN + Wi-Fi Calling If SIM has SPN and SPN display condition
            // is satisfied or SPN override is enabled for this carrier.
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // Show PLMN + Wi-Fi Calling if there is no valid SPN in the above case
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = mPhone.getSubId();
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlpha contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = mPhone.getSubId();
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE) {
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG) {
                log("updateSpnDisplay: radio is on but out of svc, set plmn='" + plmn + "'");
            }
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#method_after
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    // carrier config gets a priority over ERI
    updateOperatorNameFromCarrierConfig();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    int combinedRegState = getCombinedRegState();
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled() && (combinedRegState == ServiceState.STATE_IN_SERVICE)) {
        // In Wi-Fi Calling mode show SPN or PLMN + WiFi Calling
        // 
        // 1) Show SPN + Wi-Fi Calling If SIM has SPN and SPN display condition
        // is satisfied or SPN override is enabled for this carrier
        // 
        // 2) Show PLMN + Wi-Fi Calling if there is no valid SPN in case 1
        int voiceIdx = 0;
        int dataIdx = 0;
        boolean useRootLocale = false;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                    useRootLocale = b.getBoolean(CarrierConfigManager.KEY_WFC_SPN_USE_ROOT_LOCALE);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        String[] wfcSpnFormats = SubscriptionManager.getResourcesForSubId(mPhone.getContext(), mPhone.getSubId(), useRootLocale).getStringArray(com.android.internal.R.array.wfcSpnFormats);
        if (voiceIdx < 0 || voiceIdx >= wfcSpnFormats.length) {
            loge("updateSpnDisplay: KEY_WFC_SPN_FORMAT_IDX_INT out of bounds: " + voiceIdx);
            voiceIdx = 0;
        }
        if (dataIdx < 0 || dataIdx >= wfcSpnFormats.length) {
            loge("updateSpnDisplay: KEY_WFC_DATA_SPN_FORMAT_IDX_INT out of bounds: " + dataIdx);
            dataIdx = 0;
        }
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS) : 0;
        boolean noService = false;
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE || combinedRegState == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            // Force display no service
            final boolean forceDisplayNoService = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_display_no_service_when_sim_unready) && !mIsSimReady;
            if (mEmergencyOnly && !forceDisplayNoService) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
                noService = true;
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (combinedRegState == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !noService && !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // Show SPN + Wi-Fi Calling If SIM has SPN and SPN display condition
            // is satisfied or SPN override is enabled for this carrier.
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // Show PLMN + Wi-Fi Calling if there is no valid SPN in the above case
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = mPhone.getSubId();
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlpha contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = mPhone.getSubId();
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE) {
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG) {
                log("updateSpnDisplay: radio is on but out of svc, set plmn='" + plmn + "'");
            }
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#end_block

#method_before
@Test
@SmallTest
public void testSetWifi() {
    mConnectionUT = new ImsPhoneConnection(mImsPhone, mImsCall, mImsCT, mForeGroundCall, false);
    assertFalse(mConnectionUT.isWifi());
    // ImsCall.isWifiCall is tested elsewhere
    doReturn(true).when(mImsCall).isWifiCall();
    mBundle.putString(ImsCallProfile.EXTRA_CALL_RAT_TYPE, ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN + "");
    assertTrue(mConnectionUT.update(mImsCall, Call.State.ACTIVE));
    assertTrue(mConnectionUT.isWifi());
}
#method_after
@Test
@SmallTest
public void testSetWifi() {
    mConnectionUT = new ImsPhoneConnection(mImsPhone, mImsCall, mImsCT, mForeGroundCall, false);
    assertFalse(mConnectionUT.isWifi());
    // ImsCall.getRadioTechnology is tested elsewhere
    doReturn(ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN).when(mImsCall).getRadioTechnology();
    mBundle.putString(ImsCallProfile.EXTRA_CALL_RAT_TYPE, ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN + "");
    assertTrue(mConnectionUT.update(mImsCall, Call.State.ACTIVE));
    assertTrue(mConnectionUT.isWifi());
}
#end_block

#method_before
@Test
@SmallTest
public void testSetWifi2() {
    mConnectionUT = new ImsPhoneConnection(mImsPhone, mImsCall, mImsCT, mForeGroundCall, false);
    assertFalse(mConnectionUT.isWifi());
    // ImsCall.isWifiCall is tested elsewhere
    doReturn(true).when(mImsCall).isWifiCall();
    // Tests to make sure that the EXTRA_CALL_RAT_TYPE_ALT string is set correctly for newer
    // devices.
    mBundle.putString(ImsCallProfile.EXTRA_CALL_RAT_TYPE_ALT, ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN + "");
    assertTrue(mConnectionUT.update(mImsCall, Call.State.ACTIVE));
    assertTrue(mConnectionUT.isWifi());
}
#method_after
@Test
@SmallTest
public void testSetWifi2() {
    mConnectionUT = new ImsPhoneConnection(mImsPhone, mImsCall, mImsCT, mForeGroundCall, false);
    assertFalse(mConnectionUT.isWifi());
    // ImsCall.getRadioTechnology is tested elsewhere
    doReturn(ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN).when(mImsCall).getRadioTechnology();
    // Tests to make sure that the EXTRA_CALL_RAT_TYPE_ALT string is set correctly for newer
    // devices.
    mBundle.putString(ImsCallProfile.EXTRA_CALL_RAT_TYPE_ALT, ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN + "");
    assertTrue(mConnectionUT.update(mImsCall, Call.State.ACTIVE));
    assertTrue(mConnectionUT.isWifi());
}
#end_block

#method_before
@Test
@SmallTest
public void testSetLTE() {
    mConnectionUT = new ImsPhoneConnection(mImsPhone, mImsCall, mImsCT, mForeGroundCall, false);
    assertFalse(mConnectionUT.getCallRadioTech() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
    // ImsCall.getRadioTechnology is tested elsewhere
    doReturn(ServiceState.RIL_RADIO_TECHNOLOGY_LTE).when(mImsCall).getRadioTechnology();
    mBundle.putString(ImsCallProfile.EXTRA_CALL_RAT_TYPE, ServiceState.RIL_RADIO_TECHNOLOGY_LTE + "");
    assertTrue(mConnectionUT.update(mImsCall, Call.State.ACTIVE));
    assertTrue(mConnectionUT.getCallRadioTech() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
}
#method_after
@Test
@SmallTest
public void testSetLTE() {
    mConnectionUT = new ImsPhoneConnection(mImsPhone, mImsCall, mImsCT, mForeGroundCall, false);
    assertNotEquals(mConnectionUT.getCallRadioTech(), ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
    // ImsCall.getRadioTechnology is tested elsewhere
    doReturn(ServiceState.RIL_RADIO_TECHNOLOGY_LTE).when(mImsCall).getRadioTechnology();
    mBundle.putString(ImsCallProfile.EXTRA_CALL_RAT_TYPE, ServiceState.RIL_RADIO_TECHNOLOGY_LTE + "");
    assertTrue(mConnectionUT.update(mImsCall, Call.State.ACTIVE));
    assertEquals(mConnectionUT.getCallRadioTech(), ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
}
#end_block

#method_before
@Test
@SmallTest
public void testSetLTE2() {
    mConnectionUT = new ImsPhoneConnection(mImsPhone, mImsCall, mImsCT, mForeGroundCall, false);
    assertFalse(mConnectionUT.getCallRadioTech() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
    // ImsCall.getRadioTechnology is tested elsewhere
    doReturn(ServiceState.RIL_RADIO_TECHNOLOGY_LTE).when(mImsCall).getRadioTechnology();
    // Tests to make sure that the EXTRA_CALL_RAT_TYPE_ALT string is set correctly for newer
    // devices.
    mBundle.putString(ImsCallProfile.EXTRA_CALL_RAT_TYPE_ALT, ServiceState.RIL_RADIO_TECHNOLOGY_LTE + "");
    assertTrue(mConnectionUT.update(mImsCall, Call.State.ACTIVE));
    assertTrue(mConnectionUT.getCallRadioTech() == ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
}
#method_after
@Test
@SmallTest
public void testSetLTE2() {
    mConnectionUT = new ImsPhoneConnection(mImsPhone, mImsCall, mImsCT, mForeGroundCall, false);
    assertNotEquals(mConnectionUT.getCallRadioTech(), ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
    // ImsCall.getRadioTechnology is tested elsewhere
    doReturn(ServiceState.RIL_RADIO_TECHNOLOGY_LTE).when(mImsCall).getRadioTechnology();
    // Tests to make sure that the EXTRA_CALL_RAT_TYPE_ALT string is set correctly for newer
    // devices.
    mBundle.putString(ImsCallProfile.EXTRA_CALL_RAT_TYPE_ALT, ServiceState.RIL_RADIO_TECHNOLOGY_LTE + "");
    assertTrue(mConnectionUT.update(mImsCall, Call.State.ACTIVE));
    assertEquals(mConnectionUT.getCallRadioTech(), ServiceState.RIL_RADIO_TECHNOLOGY_LTE);
}
#end_block

#method_before
public void nvReadItem(int itemID, Message response) {
    mCi.nvReadItem(itemID, response);
}
#method_after
public void nvReadItem(int itemID, Message response, WorkSource workSource) {
    mCi.nvReadItem(itemID, response, workSource);
}
#end_block

#method_before
public void nvWriteItem(int itemID, String itemValue, Message response) {
    mCi.nvWriteItem(itemID, itemValue, response);
}
#method_after
public void nvWriteItem(int itemID, String itemValue, Message response, WorkSource workSource) {
    mCi.nvWriteItem(itemID, itemValue, response, workSource);
}
#end_block

#method_before
public void getModemActivityInfo(Message response) {
    mCi.getModemActivityInfo(response);
}
#method_after
public void getModemActivityInfo(Message response, WorkSource workSource) {
    mCi.getModemActivityInfo(response, workSource);
}
#end_block

#method_before
public void setAllowedCarriers(List<CarrierIdentifier> carriers, Message response) {
    mCi.setAllowedCarriers(carriers, response);
}
#method_after
public void setAllowedCarriers(List<CarrierIdentifier> carriers, Message response, WorkSource workSource) {
    mCi.setAllowedCarriers(carriers, response, workSource);
}
#end_block

#method_before
public void getAllowedCarriers(Message response) {
    mCi.getAllowedCarriers(response);
}
#method_after
public void getAllowedCarriers(Message response, WorkSource workSource) {
    mCi.getAllowedCarriers(response, workSource);
}
#end_block

#method_before
public void setSimPowerState(int state) {
    mCi.setSimCardPower(state, null);
}
#method_after
public void setSimPowerState(int state, WorkSource workSource) {
    mCi.setSimCardPower(state, null, workSource);
}
#end_block

#method_before
@ServiceState.RilRadioTechnology
public final int getCallRadioTech() {
    return mCallRadioTech;
}
#method_after
@ServiceState.RilRadioTechnology
public final int getCallRadioTech() {
    int voiceNetworkType = TelephonyManager.NETWORK_TYPE_UNKNOWN;
    Bundle extras = getExtras();
    if (extras != null) {
        voiceNetworkType = extras.getInt(TelecomManager.EXTRA_CALL_NETWORK_TYPE, TelephonyManager.NETWORK_TYPE_UNKNOWN);
    }
    return ServiceState.networkTypeToRilRadioTechnology(voiceNetworkType);
}
#end_block

#method_before
public final void setCallRadioTech(@ServiceState.RilRadioTechnology int vrat) {
    if (mCallRadioTech == vrat) {
        return;
    }
    mCallRadioTech = vrat;
    putExtra(TelecomManager.EXTRA_CALL_NETWORK_TYPE, ServiceState.rilRadioTechnologyToNetworkType(mCallRadioTech));
    // {@link #Listener.onExtrasChanged} event.
    if (getConference() != null) {
        getConference().setCallRadioTech(vrat);
    }
}
#method_after
public final void setCallRadioTech(@ServiceState.RilRadioTechnology int vrat) {
    putExtra(TelecomManager.EXTRA_CALL_NETWORK_TYPE, ServiceState.rilRadioTechnologyToNetworkType(vrat));
    // {@link #Listener.onExtrasChanged} event.
    if (getConference() != null) {
        getConference().setCallRadioTech(vrat);
    }
}
#end_block

#method_before
public final void setCallRadioTech(@ServiceState.RilRadioTechnology int vrat) {
    if (mCallRadioTech == vrat) {
        return;
    }
    mCallRadioTech = vrat;
    putExtra(TelecomManager.EXTRA_CALL_NETWORK_TYPE, ServiceState.rilRadioTechnologyToNetworkType(mCallRadioTech));
}
#method_after
public final void setCallRadioTech(@ServiceState.RilRadioTechnology int vrat) {
    putExtra(TelecomManager.EXTRA_CALL_NETWORK_TYPE, ServiceState.rilRadioTechnologyToNetworkType(vrat));
}
#end_block

#method_before
@ServiceState.RilRadioTechnology
public final int getCallRadioTech() {
    return mCallRadioTech;
}
#method_after
@ServiceState.RilRadioTechnology
public final int getCallRadioTech() {
    int voiceNetworkType = TelephonyManager.NETWORK_TYPE_UNKNOWN;
    Bundle extras = getExtras();
    if (extras != null) {
        voiceNetworkType = extras.getInt(TelecomManager.EXTRA_CALL_NETWORK_TYPE, TelephonyManager.NETWORK_TYPE_UNKNOWN);
    }
    return ServiceState.networkTypeToRilRadioTechnology(voiceNetworkType);
}
#end_block

#method_before
public static int presentationToOIR(int presentation) {
    switch(presentation) {
        case PhoneConstants.PRESENTATION_RESTRICTED:
            return ImsCallProfile.OIR_PRESENTATION_RESTRICTED;
        case PhoneConstants.PRESENTATION_ALLOWED:
            return ImsCallProfile.OIR_PRESENTATION_NOT_RESTRICTED;
        case PhoneConstants.PRESENTATION_PAYPHONE:
            return ImsCallProfile.OIR_PRESENTATION_PAYPHONE;
        case PhoneConstants.PRESENTATION_UNKNOWN:
            return ImsCallProfile.OIR_PRESENTATION_UNKNOWN;
        default:
            return ImsCallProfile.OIR_DEFAULT;
    }
}
#method_after
@UnsupportedAppUsage
public static int presentationToOIR(int presentation) {
    switch(presentation) {
        case PhoneConstants.PRESENTATION_RESTRICTED:
            return ImsCallProfile.OIR_PRESENTATION_RESTRICTED;
        case PhoneConstants.PRESENTATION_ALLOWED:
            return ImsCallProfile.OIR_PRESENTATION_NOT_RESTRICTED;
        case PhoneConstants.PRESENTATION_PAYPHONE:
            return ImsCallProfile.OIR_PRESENTATION_PAYPHONE;
        case PhoneConstants.PRESENTATION_UNKNOWN:
            return ImsCallProfile.OIR_PRESENTATION_UNKNOWN;
        default:
            return ImsCallProfile.OIR_DEFAULT;
    }
}
#end_block

#method_before
public static TelecomManager from(Context context) {
    return (TelecomManager) context.getSystemService(Context.TELECOM_SERVICE);
}
#method_after
@UnsupportedAppUsage
public static TelecomManager from(Context context) {
    return (TelecomManager) context.getSystemService(Context.TELECOM_SERVICE);
}
#end_block

#method_before
public PhoneAccountHandle getUserSelectedOutgoingPhoneAccount() {
    try {
        if (isServiceConnected()) {
            return getTelecomService().getUserSelectedOutgoingPhoneAccount();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelecomService#getUserSelectedOutgoingPhoneAccount", e);
    }
    return null;
}
#method_after
@UnsupportedAppUsage
public PhoneAccountHandle getUserSelectedOutgoingPhoneAccount() {
    try {
        if (isServiceConnected()) {
            return getTelecomService().getUserSelectedOutgoingPhoneAccount();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelecomService#getUserSelectedOutgoingPhoneAccount", e);
    }
    return null;
}
#end_block

#method_before
public void setUserSelectedOutgoingPhoneAccount(PhoneAccountHandle accountHandle) {
    try {
        if (isServiceConnected()) {
            getTelecomService().setUserSelectedOutgoingPhoneAccount(accountHandle);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelecomService#setUserSelectedOutgoingPhoneAccount");
    }
}
#method_after
@UnsupportedAppUsage
public void setUserSelectedOutgoingPhoneAccount(PhoneAccountHandle accountHandle) {
    try {
        if (isServiceConnected()) {
            getTelecomService().setUserSelectedOutgoingPhoneAccount(accountHandle);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelecomService#setUserSelectedOutgoingPhoneAccount");
    }
}
#end_block

#method_before
public PhoneAccountHandle getSimCallManager(int userId) {
    try {
        if (isServiceConnected()) {
            return getTelecomService().getSimCallManagerForUser(userId);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelecomService#getSimCallManagerForUser");
    }
    return null;
}
#method_after
@UnsupportedAppUsage
public PhoneAccountHandle getSimCallManager(int userId) {
    try {
        if (isServiceConnected()) {
            return getTelecomService().getSimCallManagerForUser(userId);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelecomService#getSimCallManagerForUser");
    }
    return null;
}
#end_block

#method_before
public List<PhoneAccountHandle> getCallCapablePhoneAccounts(boolean includeDisabledAccounts) {
    try {
        if (isServiceConnected()) {
            return getTelecomService().getCallCapablePhoneAccounts(includeDisabledAccounts, mContext.getOpPackageName());
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelecomService#getCallCapablePhoneAccounts(" + includeDisabledAccounts + ")", e);
    }
    return new ArrayList<>();
}
#method_after
@UnsupportedAppUsage
public List<PhoneAccountHandle> getCallCapablePhoneAccounts(boolean includeDisabledAccounts) {
    try {
        if (isServiceConnected()) {
            return getTelecomService().getCallCapablePhoneAccounts(includeDisabledAccounts, mContext.getOpPackageName());
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelecomService#getCallCapablePhoneAccounts(" + includeDisabledAccounts + ")", e);
    }
    return new ArrayList<>();
}
#end_block

#method_before
public boolean setDefaultDialer(String packageName) {
    try {
        if (isServiceConnected()) {
            return getTelecomService().setDefaultDialer(packageName);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException attempting to set the default dialer.", e);
    }
    return false;
}
#method_after
@UnsupportedAppUsage
public boolean setDefaultDialer(String packageName) {
    try {
        if (isServiceConnected()) {
            return getTelecomService().setDefaultDialer(packageName);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException attempting to set the default dialer.", e);
    }
    return false;
}
#end_block

#method_before
public String getSystemDialerPackage() {
    try {
        if (isServiceConnected()) {
            return getTelecomService().getSystemDialerPackage();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException attempting to get the system dialer package name.", e);
    }
    return null;
}
#method_after
@UnsupportedAppUsage
public String getSystemDialerPackage() {
    try {
        if (isServiceConnected()) {
            return getTelecomService().getSystemDialerPackage();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException attempting to get the system dialer package name.", e);
    }
    return null;
}
#end_block

#method_before
public int getCurrentTtyMode() {
    try {
        if (isServiceConnected()) {
            return getTelecomService().getCurrentTtyMode(mContext.getOpPackageName());
        }
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException attempting to get the current TTY mode.", e);
    }
    return TTY_MODE_OFF;
}
#method_after
@UnsupportedAppUsage
public int getCurrentTtyMode() {
    try {
        if (isServiceConnected()) {
            return getTelecomService().getCurrentTtyMode(mContext.getOpPackageName());
        }
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException attempting to get the current TTY mode.", e);
    }
    return TTY_MODE_OFF;
}
#end_block

#method_before
@Nullable
public PersistableBundle getConfigForSubId(int subId) {
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "Error getting config for subId " + subId + " ICarrierConfigLoader is null");
            return null;
        }
        return loader.getConfigForSubId(subId);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error getting config for subId " + subId + ": " + ex.toString());
    }
    return null;
}
#method_after
@Nullable
public PersistableBundle getConfigForSubId(int subId) {
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "Error getting config for subId " + subId + " ICarrierConfigLoader is null");
            return null;
        }
        return loader.getConfigForSubId(subId, mContext.getOpPackageName());
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error getting config for subId " + subId + ": " + ex.toString());
    }
    return null;
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    logMetricsEvent(MetricsEvent.ACTION_CAPTIVE_PORTAL_LOGIN_ACTIVITY);
    mCm = ConnectivityManager.from(this);
    mNetwork = getIntent().getParcelableExtra(ConnectivityManager.EXTRA_NETWORK);
    mCaptivePortal = getIntent().getParcelableExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL);
    mUserAgent = getIntent().getStringExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL_USER_AGENT);
    mUrl = getUrl();
    if (mUrl == null) {
        // getUrl() failed to parse the url provided in the intent: bail out in a way that
        // at least provides network access.
        done(Result.WANTED_AS_IS);
        return;
    }
    if (DBG) {
        Log.d(TAG, String.format("onCreate for %s", mUrl.toString()));
    }
    final String spec = getIntent().getStringExtra(EXTRA_CAPTIVE_PORTAL_PROBE_SPEC);
    try {
        mProbeSpec = CaptivePortalProbeSpec.parseSpecOrNull(spec);
    } catch (Exception e) {
        // Make extra sure that invalid configurations do not cause crashes
        mProbeSpec = null;
    }
    // Also initializes proxy system properties.
    mCm.bindProcessToNetwork(mNetwork);
    if (mNetwork != null) {
        mCm.setProcessDefaultNetworkForHostResolution(ResolvUtil.getNetworkWithUseLocalNameserversFlag(mNetwork));
    }
    // Proxy system properties must be initialized before setContentView is called because
    // setContentView initializes the WebView logic which in turn reads the system properties.
    setContentView(R.layout.activity_captive_portal_login);
    // Exit app if Network disappears.
    final NetworkCapabilities networkCapabilities = mCm.getNetworkCapabilities(mNetwork);
    if (networkCapabilities == null) {
        finishAndRemoveTask();
        return;
    }
    mNetworkCallback = new NetworkCallback() {

        @Override
        public void onLost(Network lostNetwork) {
            if (mNetwork.equals(lostNetwork))
                done(Result.UNWANTED);
        }
    };
    final NetworkRequest.Builder builder = new NetworkRequest.Builder();
    for (int transportType : networkCapabilities.getTransportTypes()) {
        builder.addTransportType(transportType);
    }
    mCm.registerNetworkCallback(builder.build(), mNetworkCallback);
    getActionBar().setDisplayShowHomeEnabled(false);
    // remove shadow
    getActionBar().setElevation(0);
    getActionBar().setTitle(getHeaderTitle());
    getActionBar().setSubtitle("");
    final WebView webview = getWebview();
    webview.clearCache(true);
    CookieManager.getInstance().setAcceptThirdPartyCookies(webview, true);
    WebSettings webSettings = webview.getSettings();
    webSettings.setJavaScriptEnabled(true);
    webSettings.setMixedContentMode(WebSettings.MIXED_CONTENT_COMPATIBILITY_MODE);
    webSettings.setUseWideViewPort(true);
    webSettings.setLoadWithOverviewMode(true);
    webSettings.setSupportZoom(true);
    webSettings.setBuiltInZoomControls(true);
    webSettings.setDisplayZoomControls(false);
    mWebViewClient = new MyWebViewClient();
    webview.setWebViewClient(mWebViewClient);
    webview.setWebChromeClient(new MyWebChromeClient());
    // Start initial page load so WebView finishes loading proxy settings.
    // Actual load of mUrl is initiated by MyWebViewClient.
    webview.loadData("", "text/html", null);
    mSwipeRefreshLayout = findViewById(R.id.swipe_refresh);
    mSwipeRefreshLayout.setOnRefreshListener(() -> {
        webview.reload();
        mSwipeRefreshLayout.setRefreshing(true);
    });
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    logMetricsEvent(MetricsEvent.ACTION_CAPTIVE_PORTAL_LOGIN_ACTIVITY);
    mCm = ConnectivityManager.from(this);
    mNetwork = getIntent().getParcelableExtra(ConnectivityManager.EXTRA_NETWORK);
    mCaptivePortal = getIntent().getParcelableExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL);
    mUserAgent = getIntent().getStringExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL_USER_AGENT);
    mUrl = getUrl();
    if (mUrl == null) {
        // getUrl() failed to parse the url provided in the intent: bail out in a way that
        // at least provides network access.
        done(Result.WANTED_AS_IS);
        return;
    }
    if (DBG) {
        Log.d(TAG, String.format("onCreate for %s", mUrl.toString()));
    }
    final String spec = getIntent().getStringExtra(EXTRA_CAPTIVE_PORTAL_PROBE_SPEC);
    try {
        mProbeSpec = CaptivePortalProbeSpec.parseSpecOrNull(spec);
    } catch (Exception e) {
        // Make extra sure that invalid configurations do not cause crashes
        mProbeSpec = null;
    }
    mNetworkCallback = new NetworkCallback() {

        @Override
        public void onLost(Network lostNetwork) {
            // If the network disappears while the app is up, exit.
            if (mNetwork.equals(lostNetwork))
                done(Result.UNWANTED);
        }
    };
    mCm.registerNetworkCallback(new NetworkRequest.Builder().build(), mNetworkCallback);
    // If the network has disappeared, exit.
    final NetworkCapabilities networkCapabilities = mCm.getNetworkCapabilities(mNetwork);
    if (networkCapabilities == null) {
        finishAndRemoveTask();
        return;
    }
    // Also initializes proxy system properties.
    mNetwork = mNetwork.getPrivateDnsBypassingCopy();
    mCm.bindProcessToNetwork(mNetwork);
    mCm.setProcessDefaultNetworkForHostResolution(mNetwork);
    // Proxy system properties must be initialized before setContentView is called because
    // setContentView initializes the WebView logic which in turn reads the system properties.
    setContentView(R.layout.activity_captive_portal_login);
    getActionBar().setDisplayShowHomeEnabled(false);
    // remove shadow
    getActionBar().setElevation(0);
    getActionBar().setTitle(getHeaderTitle());
    getActionBar().setSubtitle("");
    final WebView webview = getWebview();
    webview.clearCache(true);
    CookieManager.getInstance().setAcceptThirdPartyCookies(webview, true);
    WebSettings webSettings = webview.getSettings();
    webSettings.setJavaScriptEnabled(true);
    webSettings.setMixedContentMode(WebSettings.MIXED_CONTENT_COMPATIBILITY_MODE);
    webSettings.setUseWideViewPort(true);
    webSettings.setLoadWithOverviewMode(true);
    webSettings.setSupportZoom(true);
    webSettings.setBuiltInZoomControls(true);
    webSettings.setDisplayZoomControls(false);
    mWebViewClient = new MyWebViewClient();
    webview.setWebViewClient(mWebViewClient);
    webview.setWebChromeClient(new MyWebChromeClient());
    // Start initial page load so WebView finishes loading proxy settings.
    // Actual load of mUrl is initiated by MyWebViewClient.
    webview.loadData("", "text/html", null);
    mSwipeRefreshLayout = findViewById(R.id.swipe_refresh);
    mSwipeRefreshLayout.setOnRefreshListener(() -> {
        webview.reload();
        mSwipeRefreshLayout.setRefreshing(true);
    });
}
#end_block

#method_before
private void testForCaptivePortal() {
    // TODO: reuse NetworkMonitor facilities for consistent captive portal detection.
    new Thread(new Runnable() {

        public void run() {
            final Network network = ResolvUtil.makeNetworkWithPrivateDnsBypass(mNetwork);
            // Give time for captive portal to open.
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
            HttpURLConnection urlConnection = null;
            int httpResponseCode = 500;
            String locationHeader = null;
            try {
                urlConnection = (HttpURLConnection) network.openConnection(mUrl);
                urlConnection.setInstanceFollowRedirects(false);
                urlConnection.setConnectTimeout(SOCKET_TIMEOUT_MS);
                urlConnection.setReadTimeout(SOCKET_TIMEOUT_MS);
                urlConnection.setUseCaches(false);
                if (mUserAgent != null) {
                    urlConnection.setRequestProperty("User-Agent", mUserAgent);
                }
                // cannot read request header after connection
                String requestHeader = urlConnection.getRequestProperties().toString();
                urlConnection.getInputStream();
                httpResponseCode = urlConnection.getResponseCode();
                locationHeader = urlConnection.getHeaderField(HTTP_LOCATION_HEADER_NAME);
                if (DBG) {
                    Log.d(TAG, "probe at " + mUrl + " ret=" + httpResponseCode + " request=" + requestHeader + " headers=" + urlConnection.getHeaderFields());
                }
            } catch (IOException e) {
            } finally {
                if (urlConnection != null)
                    urlConnection.disconnect();
            }
            if (isDismissed(httpResponseCode, locationHeader, mProbeSpec)) {
                done(Result.DISMISSED);
            }
        }
    }).start();
}
#method_after
private void testForCaptivePortal() {
    // TODO: reuse NetworkMonitor facilities for consistent captive portal detection.
    new Thread(new Runnable() {

        public void run() {
            // Give time for captive portal to open.
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
            HttpURLConnection urlConnection = null;
            int httpResponseCode = 500;
            String locationHeader = null;
            try {
                urlConnection = (HttpURLConnection) mNetwork.openConnection(mUrl);
                urlConnection.setInstanceFollowRedirects(false);
                urlConnection.setConnectTimeout(SOCKET_TIMEOUT_MS);
                urlConnection.setReadTimeout(SOCKET_TIMEOUT_MS);
                urlConnection.setUseCaches(false);
                if (mUserAgent != null) {
                    urlConnection.setRequestProperty("User-Agent", mUserAgent);
                }
                // cannot read request header after connection
                String requestHeader = urlConnection.getRequestProperties().toString();
                urlConnection.getInputStream();
                httpResponseCode = urlConnection.getResponseCode();
                locationHeader = urlConnection.getHeaderField(HTTP_LOCATION_HEADER_NAME);
                if (DBG) {
                    Log.d(TAG, "probe at " + mUrl + " ret=" + httpResponseCode + " request=" + requestHeader + " headers=" + urlConnection.getHeaderFields());
                }
            } catch (IOException e) {
            } finally {
                if (urlConnection != null)
                    urlConnection.disconnect();
            }
            if (isDismissed(httpResponseCode, locationHeader, mProbeSpec)) {
                done(Result.DISMISSED);
            }
        }
    }).start();
}
#end_block

#method_before
@Override
public void onRouteAdded(MediaRouter router, MediaRouter.RouteInfo info) {
    refreshRoutes();
}
#method_after
@Override
public void onRouteAdded(MediaRouter router, MediaRouter.RouteInfo info) {
    // this point. So, the dialog can finally be dismissed.
    if (mIsSelectingDynamicRoute && mRouter.getSelectedRoute() == info) {
        mIsSelectingDynamicRoute = false;
        dismiss();
    } else {
        refreshRoutes();
    }
}
#end_block

#method_before
@Override
public void onRouteSelected(MediaRouter router, MediaRouter.RouteInfo route) {
    dismiss();
}
#method_after
@Override
public void onRouteSelected(MediaRouter router, MediaRouter.RouteInfo route) {
    // selected route of MediaRouter.
    if (mIsSelectingDynamicRoute) {
        return;
    }
    dismiss();
}
#end_block

#method_before
public void bindRouteView(final Item item) {
    final MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    mItemView.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View view) {
            route.select();
            mImageView.setVisibility(View.INVISIBLE);
            mProgressBar.setVisibility(View.VISIBLE);
        }
    });
    mTextView.setText(route.getName());
    mTextView.setTextColor(mTextColor);
    mImageView.setImageDrawable(getIconDrawable(route));
}
#method_after
public void bindRouteView(final Item item) {
    final MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    mItemView.setVisibility(View.VISIBLE);
    mProgressBar.setVisibility(View.INVISIBLE);
    mItemView.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View view) {
            if (route instanceof MediaRouter.DynamicGroupInfo) {
                mIsSelectingDynamicRoute = true;
            }
            route.select();
            mImageView.setVisibility(View.INVISIBLE);
            mProgressBar.setVisibility(View.VISIBLE);
        }
    });
    mTextView.setText(route.getName());
    mImageView.setImageDrawable(getIconDrawable(route));
}
#end_block

#method_before
public void setRouteSelector(@NonNull MediaRouteSelector selector) {
    if (selector == null) {
        throw new IllegalArgumentException("selector must not be null");
    }
    if (!mSelector.equals(selector)) {
        mSelector = selector;
        if (mAttachedToWindow) {
            mRouter.removeCallback(mCallback);
            mRouter.addCallback(selector, mCallback, MediaRouter.CALLBACK_FLAG_PERFORM_ACTIVE_SCAN);
        }
        updateRoutes();
    }
}
#method_after
public void setRouteSelector(@NonNull MediaRouteSelector selector) {
    if (selector == null) {
        throw new IllegalArgumentException("selector must not be null");
    }
    if (!mSelector.equals(selector)) {
        mSelector = selector;
        if (mAttachedToWindow) {
            mRouter.removeCallback(mCallback);
            mRouter.addCallback(selector, mCallback, MediaRouter.CALLBACK_FLAG_PERFORM_ACTIVE_SCAN);
            updateRoutes();
        }
    }
}
#end_block

#method_before
public boolean onFilterRoute(@NonNull MediaRouter.RouteInfo route) {
    return !route.isDefaultOrBluetooth() && route.isEnabled() && route.matchesSelector(mSelector) && !isSelectedRoute(route);
}
#method_after
public boolean onFilterRoute(@NonNull MediaRouter.RouteInfo route) {
    return !route.isDefaultOrBluetooth() && route.isEnabled() && route.matchesSelector(mSelector) && !(mSelectedRoute == route);
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.mr_cast_dialog);
    MediaRouterThemeHelper.setDialogBackgroundColor(mContext, this);
    mCloseButton = findViewById(R.id.mr_cast_close_button);
    mCloseButton.setColorFilter(COLOR_WHITE_ON_DARK_BACKGROUND);
    mCloseButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    mStopCastingButton = findViewById(R.id.mr_cast_stop_button);
    mStopCastingButton.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mStopCastingButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mSelectedRoute.isSelected()) {
                mRouter.unselect(MediaRouter.UNSELECT_REASON_STOPPED);
            }
            dismiss();
        }
    });
    mAdapter = new RecyclerAdapter();
    mRecyclerView = findViewById(R.id.mr_cast_list);
    mRecyclerView.setAdapter(mAdapter);
    mRecyclerView.setLayoutManager(new LinearLayoutManager(mContext));
    // Disable change animation.
    ((SimpleItemAnimator) mRecyclerView.getItemAnimator()).setSupportsChangeAnimations(false);
    mVolumeChangeListener = new VolumeChangeListener();
    mVolumeSliderColor = MediaRouterThemeHelper.getControllerColor(mContext, 0);
    mVolumeSliderHolderMap = new HashMap<>();
    mBeforeMuteVolumeMap = new HashMap<>();
    mMetadataBackground = findViewById(R.id.mr_cast_meta_background);
    mMetadataBlackScrim = findViewById(R.id.mr_cast_meta_black_scrim);
    mArtView = findViewById(R.id.mr_cast_meta_art);
    mTitleView = findViewById(R.id.mr_cast_meta_title);
    mTitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mSubtitleView = findViewById(R.id.mr_cast_meta_subtitle);
    mSubtitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    Resources res = mContext.getResources();
    mTitlePlaceholder = res.getString(R.string.mr_cast_dialog_title_view_placeholder);
    mCreated = true;
    updateLayout();
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.mr_cast_dialog);
    MediaRouterThemeHelper.setDialogBackgroundColor(mContext, this);
    mCloseButton = findViewById(R.id.mr_cast_close_button);
    mCloseButton.setColorFilter(COLOR_WHITE_ON_DARK_BACKGROUND);
    mCloseButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    mStopCastingButton = findViewById(R.id.mr_cast_stop_button);
    mStopCastingButton.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mStopCastingButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mSelectedRoute.isSelected()) {
                mRouter.unselect(MediaRouter.UNSELECT_REASON_STOPPED);
            }
            dismiss();
        }
    });
    mAdapter = new RecyclerAdapter();
    mRecyclerView = findViewById(R.id.mr_cast_list);
    mRecyclerView.setAdapter(mAdapter);
    mRecyclerView.setLayoutManager(new LinearLayoutManager(mContext));
    mVolumeChangeListener = new VolumeChangeListener();
    mVolumeSliderColor = MediaRouterThemeHelper.getControllerColor(mContext, 0);
    mVolumeSliderHolderMap = new HashMap<>();
    mBeforeMuteVolumeMap = new HashMap<>();
    mMetadataBackground = findViewById(R.id.mr_cast_meta_background);
    mMetadataBlackScrim = findViewById(R.id.mr_cast_meta_black_scrim);
    mArtView = findViewById(R.id.mr_cast_meta_art);
    mTitleView = findViewById(R.id.mr_cast_meta_title);
    mTitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mSubtitleView = findViewById(R.id.mr_cast_meta_subtitle);
    mSubtitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    Resources res = mContext.getResources();
    mTitlePlaceholder = res.getString(R.string.mr_cast_dialog_title_view_placeholder);
    mCreated = true;
    updateLayout();
}
#end_block

#method_before
void updateLayout() {
    int width = MediaRouteDialogHelper.getDialogWidth(mContext);
    int height = MediaRouteDialogHelper.getDialogHeight(mContext);
    getWindow().setLayout(width, height);
    mArtIconBitmap = null;
    mArtIconUri = null;
    updateArtIconIfNeeded();
    updateMetadataViews();
    refreshRoutesView();
}
#method_after
void updateLayout() {
    int width = MediaRouteDialogHelper.getDialogWidth(mContext);
    int height = MediaRouteDialogHelper.getDialogHeight(mContext);
    getWindow().setLayout(width, height);
    mArtIconBitmap = null;
    mArtIconUri = null;
    updateArtIconIfNeeded();
    updateMetadataViews();
    updateRoutesView();
}
#end_block

#method_before
@Override
public void onDetachedFromWindow() {
    super.onDetachedFromWindow();
    mAttachedToWindow = false;
    mRouter.removeCallback(mCallback);
    mHandler.removeMessages(MSG_UPDATE_ROUTES_VIEW);
    mHandler.removeMessages(MSG_UPDATE_ROUTE_VOLUME_BY_USER);
    setMediaSession(null);
}
#method_after
@Override
public void onDetachedFromWindow() {
    super.onDetachedFromWindow();
    mAttachedToWindow = false;
    mRouter.removeCallback(mCallback);
    mHandler.removeCallbacksAndMessages(null);
    setMediaSession(null);
}
#end_block

#method_before
void updateMetadataViews() {
    if (mArtIconIsLoaded && !isBitmapRecycled(mArtIconLoadedBitmap) && mArtIconLoadedBitmap != null) {
        mArtView.setVisibility(View.VISIBLE);
        mArtView.setImageBitmap(mArtIconLoadedBitmap);
        mArtView.setBackgroundColor(mArtIconBackgroundColor);
        // Blur will not be supported for SDK < 17 devices to avoid unnecessarily bloating
        // the size of this package (approximately two-fold). Instead, only the black scrim
        // will be placed on top of the metadata background.
        mMetadataBlackScrim.setVisibility(View.VISIBLE);
        if (Build.VERSION.SDK_INT >= 17) {
            Bitmap blurredBitmap = blurBitmap(mArtIconLoadedBitmap, BLUR_RADIUS, mContext);
            mMetadataBackground.setImageBitmap(blurredBitmap);
        } else {
            mMetadataBackground.setImageBitmap(Bitmap.createBitmap(mArtIconLoadedBitmap));
        }
    } else {
        if (isBitmapRecycled(mArtIconLoadedBitmap)) {
            Log.w(TAG, "Can't set artwork image with recycled bitmap: " + mArtIconLoadedBitmap);
        }
        mArtView.setVisibility(View.GONE);
        mMetadataBlackScrim.setVisibility(View.GONE);
        mMetadataBackground.setImageBitmap(null);
    }
    clearLoadedBitmap();
    CharSequence title = mDescription == null ? null : mDescription.getTitle();
    boolean hasTitle = !TextUtils.isEmpty(title);
    CharSequence subtitle = mDescription == null ? null : mDescription.getSubtitle();
    boolean hasSubtitle = !TextUtils.isEmpty(subtitle);
    if (hasTitle) {
        mTitleView.setText(title);
    } else {
        mTitleView.setText(mTitlePlaceholder);
    }
    if (hasSubtitle) {
        mSubtitleView.setText(subtitle);
        mSubtitleView.setVisibility(View.VISIBLE);
    } else {
        mSubtitleView.setVisibility(View.GONE);
    }
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void updateMetadataViews() {
    if (shouldDeferUpdateViews()) {
        mUpdateMetadataViewsDeferred = true;
        return;
    }
    mUpdateMetadataViewsDeferred = false;
    // Dismiss dialog if there's no non-default selected route.
    if (!mSelectedRoute.isSelected() || mSelectedRoute.isDefaultOrBluetooth()) {
        dismiss();
    }
    if (mArtIconIsLoaded && !isBitmapRecycled(mArtIconLoadedBitmap) && mArtIconLoadedBitmap != null) {
        mArtView.setVisibility(View.VISIBLE);
        mArtView.setImageBitmap(mArtIconLoadedBitmap);
        mArtView.setBackgroundColor(mArtIconBackgroundColor);
        // Blur will not be supported for SDK < 17 devices to avoid unnecessarily bloating
        // the size of this package (approximately two-fold). Instead, only the black scrim
        // will be placed on top of the metadata background.
        mMetadataBlackScrim.setVisibility(View.VISIBLE);
        if (Build.VERSION.SDK_INT >= 17) {
            Bitmap blurredBitmap = blurBitmap(mArtIconLoadedBitmap, BLUR_RADIUS, mContext);
            mMetadataBackground.setImageBitmap(blurredBitmap);
        } else {
            mMetadataBackground.setImageBitmap(Bitmap.createBitmap(mArtIconLoadedBitmap));
        }
    } else {
        if (isBitmapRecycled(mArtIconLoadedBitmap)) {
            Log.w(TAG, "Can't set artwork image with recycled bitmap: " + mArtIconLoadedBitmap);
        }
        mArtView.setVisibility(View.GONE);
        mMetadataBlackScrim.setVisibility(View.GONE);
        mMetadataBackground.setImageBitmap(null);
    }
    clearLoadedBitmap();
    CharSequence title = mDescription == null ? null : mDescription.getTitle();
    boolean hasTitle = !TextUtils.isEmpty(title);
    CharSequence subtitle = mDescription == null ? null : mDescription.getSubtitle();
    boolean hasSubtitle = !TextUtils.isEmpty(subtitle);
    if (hasTitle) {
        mTitleView.setText(title);
    } else {
        mTitleView.setText(mTitlePlaceholder);
    }
    if (hasSubtitle) {
        mSubtitleView.setText(subtitle);
        mSubtitleView.setVisibility(View.VISIBLE);
    } else {
        mSubtitleView.setVisibility(View.GONE);
    }
}
#end_block

#method_before
List<MediaRouter.RouteInfo> getMemberRoutes() {
    List<MediaRouter.RouteInfo> memberRoutes = new ArrayList<>();
    if (mSelectedRoute instanceof MediaRouter.DynamicGroupInfo) {
        memberRoutes.addAll(getDynamicGroup().getMemberRoutes());
    } else if (mSelectedRoute instanceof MediaRouter.RouteGroup) {
        memberRoutes.addAll(((MediaRouter.RouteGroup) mSelectedRoute).getMemberRoutes());
    }
    return memberRoutes;
}
#method_after
List<MediaRouter.RouteInfo> getMemberRoutes() {
    List<MediaRouter.RouteInfo> memberRoutes = new ArrayList<>();
    if (mSelectedRoute instanceof MediaRouter.DynamicGroupInfo) {
        memberRoutes.addAll(((MediaRouter.DynamicGroupInfo) mSelectedRoute).getMemberRoutes());
    } else if (mSelectedRoute instanceof MediaRouter.RouteGroup) {
        memberRoutes.addAll(((MediaRouter.RouteGroup) mSelectedRoute).getMemberRoutes());
    }
    return memberRoutes;
}
#end_block

#method_before
List<MediaRouter.RouteInfo> getGroupableRoutes() {
    List<MediaRouter.RouteInfo> groupableRoutes = new ArrayList<>();
    if (mSelectedRoute instanceof MediaRouter.DynamicGroupInfo) {
        groupableRoutes.addAll(getDynamicGroup().getGroupableRoutes());
    }
    return groupableRoutes;
}
#method_after
List<MediaRouter.RouteInfo> getGroupableRoutes() {
    List<MediaRouter.RouteInfo> groupableRoutes = new ArrayList<>();
    if (mSelectedRoute instanceof MediaRouter.DynamicGroupInfo) {
        MediaRouter.DynamicGroupInfo groupInfo = (MediaRouter.DynamicGroupInfo) mSelectedRoute;
        groupableRoutes.addAll(groupInfo.getGroupableRoutes());
    }
    return groupableRoutes;
}
#end_block

#method_before
List<MediaRouter.RouteInfo> getTransferableRoutes() {
    List<MediaRouter.RouteInfo> transferableRoutes = new ArrayList<>();
    if (mSelectedRoute instanceof MediaRouter.DynamicGroupInfo) {
        transferableRoutes.addAll(getDynamicGroup().getTransferableRoutes());
    } else {
        transferableRoutes.addAll(mSelectedRoute.getProvider().getRoutes());
    }
    return transferableRoutes;
}
#method_after
List<MediaRouter.RouteInfo> getTransferableRoutes() {
    List<MediaRouter.RouteInfo> transferableRoutes = new ArrayList<>();
    if (mSelectedRoute instanceof MediaRouter.DynamicGroupInfo) {
        MediaRouter.DynamicGroupInfo groupInfo = (MediaRouter.DynamicGroupInfo) mSelectedRoute;
        transferableRoutes.addAll(groupInfo.getTransferableRoutes());
    } else {
        transferableRoutes.addAll(mSelectedRoute.getProvider().getRoutes());
    }
    return transferableRoutes;
}
#end_block

#method_before
void updateRoutesView() {
    // in the process of selecting route.
    if (mRouteForVolumeUpdatingByUser != null || mIsSelectingRoute) {
        return;
    }
    if (!mSelectedRoute.isSelected() || mSelectedRoute.isDefaultOrBluetooth()) {
        dismiss();
        return;
    }
    if (!mCreated) {
        return;
    }
    // Get ungroupable routes which are positioning at groupable routes section.
    // This can happen when dynamically added routes can't be grouped with some of other routes
    // at groupable routes section.
    mUngroupableRoutes.clear();
    mUngroupableRoutes.addAll(MediaRouteDialogHelper.getItemsRemoved(mGroupableRoutes, getGroupableRoutes()));
    mLastUpdateTime = SystemClock.uptimeMillis();
    mAnimationNeeded = true;
    mAdapter.notifyDataSetChanged();
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void updateRoutesView() {
    if (mAttachedToWindow) {
        if (SystemClock.uptimeMillis() - mLastUpdateTime >= UPDATE_ROUTES_VIEW_DELAY_MS) {
            if (shouldDeferUpdateViews()) {
                mUpdateRoutesViewDeferred = true;
                return;
            }
            mUpdateRoutesViewDeferred = false;
            // Dismiss dialog if there's no non-default selected route.
            if (!mSelectedRoute.isSelected() || mSelectedRoute.isDefaultOrBluetooth()) {
                dismiss();
            }
            mLastUpdateTime = SystemClock.uptimeMillis();
            mAdapter.notifyAdapterDataSetChanged();
        } else {
            mHandler.removeMessages(MSG_UPDATE_ROUTES_VIEW);
            mHandler.sendEmptyMessageAtTime(MSG_UPDATE_ROUTES_VIEW, mLastUpdateTime + UPDATE_ROUTES_VIEW_DELAY_MS);
        }
    }
}
#end_block

#method_before
void updateRoutes() {
    mMemberRoutes.clear();
    mGroupableRoutes.clear();
    mTransferableRoutes.clear();
    mMemberRoutes.addAll(getMemberRoutes());
    mGroupableRoutes.addAll(getGroupableRoutes());
    mTransferableRoutes.addAll(getTransferableRoutes());
    // Sort routes.
    Collections.sort(mMemberRoutes, RouteComparator.sInstance);
    Collections.sort(mGroupableRoutes, RouteComparator.sInstance);
    Collections.sort(mTransferableRoutes, RouteComparator.sInstance);
    // Filter routes.
    onFilterRoutes(mGroupableRoutes);
    onFilterRoutes(mTransferableRoutes);
    if (mAttachedToWindow) {
        mAnimationNeeded = false;
        mAdapter.setItems();
    }
}
#method_after
void updateRoutes() {
    mMemberRoutes.clear();
    mGroupableRoutes.clear();
    mTransferableRoutes.clear();
    mMemberRoutes.addAll(getMemberRoutes());
    mGroupableRoutes.addAll(getGroupableRoutes());
    mTransferableRoutes.addAll(getTransferableRoutes());
    // Sort routes.
    Collections.sort(mMemberRoutes, RouteComparator.sInstance);
    Collections.sort(mGroupableRoutes, RouteComparator.sInstance);
    Collections.sort(mTransferableRoutes, RouteComparator.sInstance);
    // Filter routes.
    onFilterRoutes(mGroupableRoutes);
    onFilterRoutes(mTransferableRoutes);
    mAdapter.setItems();
}
#end_block

#method_before
void setItems() {
    mItems.clear();
    MediaRouter.DynamicGroupInfo dynamicGroup = getDynamicGroup();
    if (!mMemberRoutes.isEmpty()) {
        // actual group, group volume doesn't have to be displayed.
        if (isSelectedRouteActualGroup()) {
            mItems.add(new Item(mSelectedRoute, ITEM_TYPE_GROUP_VOLUME));
        }
        for (MediaRouter.RouteInfo memberRoute : mMemberRoutes) {
            mItems.add(new Item(memberRoute, ITEM_TYPE_ROUTE));
        }
    } else {
        mItems.add(new Item(mSelectedRoute, ITEM_TYPE_ROUTE));
    }
    if (!mGroupableRoutes.isEmpty()) {
        // Check if there's any route exists who is groupable but not member route.
        boolean exists = false;
        for (MediaRouter.RouteInfo groupableRoute : mGroupableRoutes) {
            if (!mMemberRoutes.contains(groupableRoute)) {
                exists = true;
                break;
            }
        }
        if (exists) {
            String title = dynamicGroup == null ? mContext.getString(R.string.mr_dialog_groupable_header) : dynamicGroup.getController().getGroupableSelectionTitle();
            mItems.add(new Item(title, ITEM_TYPE_HEADER));
            for (MediaRouter.RouteInfo groupableRoute : mGroupableRoutes) {
                if (!mMemberRoutes.contains(groupableRoute)) {
                    mItems.add(new Item(groupableRoute, ITEM_TYPE_ROUTE));
                }
            }
        }
    }
    if (!mTransferableRoutes.isEmpty()) {
        // Check if there's any route exists who is transferable but not selected route.
        boolean exists = false;
        for (MediaRouter.RouteInfo transferableRoute : mTransferableRoutes) {
            if (!mSelectedRoute.getId().equals(transferableRoute.getId())) {
                exists = true;
                break;
            }
        }
        if (exists) {
            String title = dynamicGroup == null ? mContext.getString(R.string.mr_dialog_transferable_header) : dynamicGroup.getController().getTransferableSectionTitle();
            mItems.add(new Item(title, ITEM_TYPE_HEADER));
            for (MediaRouter.RouteInfo transferableRoute : mTransferableRoutes) {
                if (!mSelectedRoute.getId().equals(transferableRoute.getId())) {
                    mItems.add(new Item(transferableRoute, ITEM_TYPE_GROUP));
                }
            }
        }
    }
    notifyDataSetChanged();
}
#method_after
void setItems() {
    mItems.clear();
    MediaRouter.DynamicGroupInfo groupInfo = null;
    if (mSelectedRoute instanceof MediaRouter.DynamicGroupInfo) {
        groupInfo = (MediaRouter.DynamicGroupInfo) mSelectedRoute;
    }
    if (!mMemberRoutes.isEmpty()) {
        if (isGroupVolumeNeeded()) {
            mItems.add(new Item(mSelectedRoute, ITEM_TYPE_GROUP_VOLUME));
        }
        for (MediaRouter.RouteInfo memberRoute : mMemberRoutes) {
            mItems.add(new Item(memberRoute, ITEM_TYPE_ROUTE));
        }
    } else {
        mItems.add(new Item(mSelectedRoute, ITEM_TYPE_ROUTE));
    }
    if (!mGroupableRoutes.isEmpty()) {
        // Check if there's any route exists who is groupable but not member route.
        boolean exists = false;
        for (MediaRouter.RouteInfo groupableRoute : mGroupableRoutes) {
            if (!mMemberRoutes.contains(groupableRoute)) {
                exists = true;
                break;
            }
        }
        if (exists) {
            String title = groupInfo == null ? mContext.getString(R.string.mr_dialog_groupable_header) : groupInfo.getController().getGroupableSelectionTitle();
            mItems.add(new Item(title, ITEM_TYPE_HEADER));
            for (MediaRouter.RouteInfo groupableRoute : mGroupableRoutes) {
                if (!mMemberRoutes.contains(groupableRoute)) {
                    mItems.add(new Item(groupableRoute, ITEM_TYPE_ROUTE));
                }
            }
        }
    }
    if (!mTransferableRoutes.isEmpty()) {
        // Check if there's any route exists who is transferable but not selected route.
        boolean exists = false;
        for (MediaRouter.RouteInfo transferableRoute : mTransferableRoutes) {
            if (mSelectedRoute != transferableRoute) {
                exists = true;
                break;
            }
        }
        if (exists) {
            String title = groupInfo == null ? mContext.getString(R.string.mr_dialog_transferable_header) : groupInfo.getController().getTransferableSectionTitle();
            mItems.add(new Item(title, ITEM_TYPE_HEADER));
            for (MediaRouter.RouteInfo transferableRoute : mTransferableRoutes) {
                if (mSelectedRoute != transferableRoute) {
                    mItems.add(new Item(transferableRoute, ITEM_TYPE_GROUP));
                }
            }
        }
    }
    notifyAdapterDataSetChanged();
}
#end_block

#method_before
private Drawable getDefaultIconDrawable(MediaRouter.RouteInfo route) {
    // If the type of the receiver device is specified, use it.
    switch(route.getDeviceType()) {
        case MediaRouter.RouteInfo.DEVICE_TYPE_TV:
            return MediaRouterThemeHelper.getTvDrawableIcon(mContext);
        case MediaRouter.RouteInfo.DEVICE_TYPE_SPEAKER:
            return MediaRouterThemeHelper.getSpeakerDrawableIcon(mContext);
    }
    // Otherwise, make the best guess based on other route information.
    if (route instanceof MediaRouter.RouteGroup) {
        // Only speakers can be grouped for now.
        return MediaRouterThemeHelper.getSpeakerGroupDrawableIcon(mContext);
    }
    return MediaRouterThemeHelper.getDefaultDrawableIcon(mContext);
}
#method_after
private Drawable getDefaultIconDrawable(MediaRouter.RouteInfo route) {
    // If the type of the receiver device is specified, use it.
    switch(route.getDeviceType()) {
        case MediaRouter.RouteInfo.DEVICE_TYPE_TV:
            return mTvIcon;
        case MediaRouter.RouteInfo.DEVICE_TYPE_SPEAKER:
            return mSpeakerIcon;
    }
    // Otherwise, make the best guess based on other route information.
    if (route instanceof MediaRouter.RouteGroup) {
        // Only speakers can be grouped for now.
        return mSpeakerGroupIcon;
    }
    return mDefaultIcon;
}
#end_block

#method_before
private boolean isEnabled(MediaRouter.RouteInfo route) {
    // Ungroupable route which is in groupable section has to be disabled.
    if (mUngroupableRoutes.contains(route)) {
        return false;
    }
    // Selected route which is not unselectable has to be disabled.
    if (isSelected(route)) {
        MediaRouter.DynamicGroupInfo dynamicGroup = getDynamicGroup();
        if (dynamicGroup != null) {
            return dynamicGroup.getUnselectableRoutes().contains(route);
        }
    }
    return true;
}
#method_after
private boolean isEnabled(MediaRouter.RouteInfo route) {
    // Ungroupable route that is in groupable section has to be disabled.
    if (mUngroupableRoutes.contains(route)) {
        return false;
    }
    // Selected route that can't be unselected has to be disabled.
    if (isSelected(route) && mSelectedRoute instanceof MediaRouter.DynamicGroupInfo) {
        MediaRouter.DynamicGroupInfo groupInfo = (MediaRouter.DynamicGroupInfo) mSelectedRoute;
        return groupInfo.getUnselectableRoutes().contains(route);
    }
    return true;
}
#end_block

#method_before
public void bindRouteViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    bindRouteVolumeSliderHolder(route);
    // Get icons for route and checkbox.
    Drawable routeIcon = getIconDrawable(route);
    if (mSelectedRoute instanceof MediaRouter.DynamicGroupInfo) {
        boolean selected = isSelected(route);
        boolean enabled = isEnabled(route);
        // icon if selected.
        if (selected) {
            mCheckBox.setChecked(true);
            mProgressBar.setVisibility(View.INVISIBLE);
            mImageView.setVisibility(View.VISIBLE);
        } else {
            mCheckBox.setChecked(false);
        }
        // layout.
        if (enabled) {
            mCheckBox.setEnabled(true);
            if (mAnimationNeeded) {
                animateLayoutHeight(mVolumeSliderLayout, selected ? mExpandedLayoutHeight : mCollapsedLayoutHeight);
            } else {
                setLayoutHeight(mVolumeSliderLayout, selected ? mExpandedLayoutHeight : mCollapsedLayoutHeight);
            }
            mCheckBox.setOnClickListener(mCheckBoxClickListener);
        } else {
            mCheckBox.setEnabled(false);
            setLayoutHeight(mVolumeSliderLayout, mCollapsedLayoutHeight);
        }
        // Set alpha of route icon, text view, checkbox icon according to enabled state.
        int alpha = enabled ? 0xFF : (int) (0xFF * mDisabledAlpha);
        // Apply alpha to route icon and set it to mImageView.
        routeIcon = routeIcon.mutate();
        routeIcon.setAlpha(alpha);
        mImageView.setImageDrawable(routeIcon);
        // Apply alpha to text color and set it to mTextView.
        int textColor = ColorUtils.setAlphaComponent(mTextColor, alpha);
        mTextView.setText(route.getName());
        mTextView.setTextColor(textColor);
        // Apply alpha to checkbox icon and set it to mCheckBox.
        Drawable checkBoxIcon = MediaRouterThemeHelper.getCheckBoxDrawableIcon(mContext);
        checkBoxIcon = checkBoxIcon.mutate();
        checkBoxIcon.setAlpha(alpha);
        mCheckBox.setVisibility(View.VISIBLE);
        mCheckBox.setButtonDrawable(checkBoxIcon);
    } else {
        mImageView.setImageDrawable(routeIcon);
        mTextView.setText(route.getName());
        mTextView.setTextColor(mTextColor);
        mCheckBox.setVisibility(View.GONE);
    }
}
#method_after
public void bindRouteViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    bindRouteVolumeSliderHolder(route);
    // Get icons for route and checkbox.
    mImageView.setImageDrawable(getIconDrawable(route));
    mTextView.setText(route.getName());
    if (mSelectedRoute instanceof MediaRouter.DynamicGroupInfo) {
        mCheckBox.setVisibility(View.VISIBLE);
        boolean selected = isSelected(route);
        boolean enabled = isEnabled(route);
        // Set checked state of checkbox and replace progress bar with route type icon.
        mCheckBox.setChecked(selected);
        mProgressBar.setVisibility(View.INVISIBLE);
        mImageView.setVisibility(View.VISIBLE);
        // layout.
        if (enabled) {
            mCheckBox.setEnabled(true);
            mCheckBox.setOnClickListener(mCheckBoxClickListener);
            int layoutHeight = mVolumeSliderLayout.getLayoutParams().height;
            boolean isAnimating = layoutHeight > mCollapsedLayoutHeight && layoutHeight < mExpandedLayoutHeight;
            if (isAnimating) {
                animateLayoutHeight(mVolumeSliderLayout, selected ? mExpandedLayoutHeight : mCollapsedLayoutHeight);
            } else {
                setLayoutHeight(mVolumeSliderLayout, selected ? mExpandedLayoutHeight : mCollapsedLayoutHeight);
            }
            mItemView.setAlpha(1.0f);
        } else {
            mCheckBox.setEnabled(false);
            setLayoutHeight(mVolumeSliderLayout, mCollapsedLayoutHeight);
            mItemView.setAlpha(mDisabledAlpha);
        }
    } else {
        mCheckBox.setVisibility(View.GONE);
        mProgressBar.setVisibility(View.INVISIBLE);
        mImageView.setVisibility(View.VISIBLE);
        setLayoutHeight(mVolumeSliderLayout, mExpandedLayoutHeight);
        mItemView.setAlpha(1.0f);
    }
}
#end_block

#method_before
public void bindGroupViewHolder(Item item) {
    final MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    mRoute = route;
    mImageView.setVisibility(View.VISIBLE);
    mProgressBar.setVisibility(View.INVISIBLE);
    mItemView.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View view) {
            mIsSelectingRoute = true;
            mRoute.select();
            mImageView.setVisibility(View.INVISIBLE);
            mProgressBar.setVisibility(View.VISIBLE);
        }
    });
    mImageView.setImageDrawable(getIconDrawable(route));
    mTextView.setText(route.getName());
    mTextView.setTextColor(mTextColor);
}
#method_after
public void bindGroupViewHolder(Item item) {
    final MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    mRoute = route;
    mImageView.setVisibility(View.VISIBLE);
    mProgressBar.setVisibility(View.INVISIBLE);
    boolean enabled = isEnabled(route);
    mItemView.setAlpha(enabled ? 1.0f : mDisabledAlpha);
    mItemView.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View view) {
            mIsSelectingRoute = true;
            mRoute.select();
            mImageView.setVisibility(View.INVISIBLE);
            mProgressBar.setVisibility(View.VISIBLE);
        }
    });
    mImageView.setImageDrawable(getIconDrawable(route));
    mTextView.setText(route.getName());
}
#end_block

#method_before
@Override
public void onRouteAdded(MediaRouter router, MediaRouter.RouteInfo info) {
    // transferable routes aren't set at this point.
    if (mIsSelectingRoute && mSelectedRoute instanceof MediaRouter.DynamicGroupInfo && mRouter.getSelectedRoute() == info) {
        mSelectedRoute = info;
        return;
    }
    refreshRoutesView();
}
#method_after
@Override
public void onRouteAdded(MediaRouter router, MediaRouter.RouteInfo info) {
    // initialized yet.
    if (isSelectingDynamicRoute() && mRouter.getSelectedRoute() == info) {
        mSelectedRoute = info;
        return;
    }
    updateRoutesView();
}
#end_block

#method_before
@Override
public void onRouteRemoved(MediaRouter router, MediaRouter.RouteInfo info) {
    refreshRoutesView();
}
#method_after
@Override
public void onRouteRemoved(MediaRouter router, MediaRouter.RouteInfo info) {
    updateRoutesView();
}
#end_block

#method_before
@Override
public void onRouteSelected(MediaRouter router, MediaRouter.RouteInfo route) {
    // provider, because passed selected route is not dynamic group route yet.
    if (mIsSelectingRoute && mSelectedRoute instanceof MediaRouter.DynamicGroupInfo) {
        return;
    }
    mSelectedRoute = route;
    mIsSelectingRoute = false;
    updateRoutes();
}
#method_after
@Override
public void onRouteSelected(MediaRouter router, MediaRouter.RouteInfo route) {
    // Defer updating because dynamic group route of selecting route isn't published yet.
    if (isSelectingDynamicRoute()) {
        return;
    }
    mSelectedRoute = route;
    mIsSelectingRoute = false;
    // Since updates of views are deferred when selecting the route,
    // call updateViewsIfNeeded to ensure that views are updated properly.
    updateViewsIfNeeded();
    updateRoutes();
}
#end_block

#method_before
@Override
public void onRouteUnselected(MediaRouter router, MediaRouter.RouteInfo route) {
    refreshRoutesView();
}
#method_after
@Override
public void onRouteUnselected(MediaRouter router, MediaRouter.RouteInfo route) {
    updateRoutesView();
}
#end_block

#method_before
@Override
public void onRouteChanged(MediaRouter router, MediaRouter.RouteInfo route) {
    if (mRouteForVolumeUpdatingByUser != null) {
        mHasChangedRoute = true;
        return;
    }
    // holding by calling updateRoutes.
    if (mIsSelectingRoute && mSelectedRoute.getId().equals(route.getId())) {
        mIsSelectingRoute = false;
        updateRoutes();
    } else {
        refreshRoutesView();
    }
}
#method_after
@Override
public void onRouteChanged(MediaRouter router, MediaRouter.RouteInfo route) {
    if (mIsSelectingRoute && mSelectedRoute == route) {
        // Not only dynamic group route of selecting route is published but also its
        // member/groupable/transferable routes are initialized at this point.
        mIsSelectingRoute = false;
        updateViewsIfNeeded();
        updateRoutes();
    } else {
        updateRoutesView();
    }
}
#end_block

#method_before
@Before
public void setup() {
    MockitoAnnotations.initMocks(this);
    mContext = RuntimeEnvironment.application;
    mController = spy(new AngleEnabledAppPreferenceController(mContext, mFragment));
    mPreference = new Preference(mContext);
    ReflectionHelpers.setField(mController, "mPackageManager", /* field name */
    mPackageManager);
    when(mPreferenceScreen.findPreference(mController.getPreferenceKey())).thenReturn(mPreference);
    mController.displayPreference(mPreferenceScreen);
}
#method_after
@Before
public void setup() {
    MockitoAnnotations.initMocks(this);
    mContext = RuntimeEnvironment.application;
    mController = spy(new AngleEnabledAppPreferenceController(mContext, mFragment));
    when(mPreferenceScreen.findPreference(mController.getPreferenceKey())).thenReturn(mPreference);
    mController.displayPreference(mPreferenceScreen);
}
#end_block

#method_before
@Test
public void updateState_foobarAppSelected_shouldUpdateSummaryWithAngleEnabledAppLabel() {
    final String angleEnabledApp = "foobar";
    final ContentResolver contentResolver = mContext.getContentResolver();
    Settings.Global.putString(contentResolver, Settings.Global.ANGLE_ENABLED_APP, angleEnabledApp);
    mController.updateState(mPreference);
    verify(mPreference).setSummary(mContext.getString(R.string.angle_enabled_app_set, angleEnabledApp));
}
#method_after
@Test
public void updateState_foobarAppSelected_shouldUpdateSummaryWithAngleEnabledAppLabel() {
    final String angleEnabledApp = "foobar";
    final ContentResolver contentResolver = mContext.getContentResolver();
    Settings.Global.putString(contentResolver, Settings.Global.ANGLE_ENABLED_APP, angleEnabledApp);
    mController.updateState(mPreference);
    assertThat(mPreference.getSummary()).isEqualTo(mContext.getString(R.string.angle_enabled_app_set, angleEnabledApp));
}
#end_block

#method_before
@Test
public void updateState_noAppSelected_shouldUpdateSummaryWithNoAppSelected() {
    final String angleEnabledApp = null;
    final ContentResolver contentResolver = mContext.getContentResolver();
    Settings.Global.putString(contentResolver, Settings.Global.ANGLE_ENABLED_APP, angleEnabledApp);
    mController.updateState(mPreference);
    verify(mPreference).setSummary(mContext.getString(R.string.angle_enabled_app_not_set));
}
#method_after
@Test
public void updateState_noAppSelected_shouldUpdateSummaryWithNoAppSelected() {
    final String angleEnabledApp = null;
    final ContentResolver contentResolver = mContext.getContentResolver();
    Settings.Global.putString(contentResolver, Settings.Global.ANGLE_ENABLED_APP, angleEnabledApp);
    mController.updateState(mPreference);
    assertThat(mPreference.getSummary()).isEqualTo(mContext.getString(R.string.angle_enabled_app_not_set));
}
#end_block

#method_before
@Test
public void onActivityResult_foobarAppSelected_shouldUpdateSummaryWithAngleEnabledLabel() {
    Intent activityResultIntent = new Intent(mContext, AppPicker.class);
    final String appLabel = "foobar";
    activityResultIntent.setAction(appLabel);
    final boolean result = mController.onActivityResult(REQUEST_CODE_ANGLE_ENABLED_APP, Activity.RESULT_OK, activityResultIntent);
    assertThat(result).isTrue();
    verify(mPreference).setSummary(mContext.getString(R.string.angle_enabled_app_set, appLabel));
}
#method_after
@Test
public void onActivityResult_foobarAppSelected_shouldUpdateSummaryWithAngleEnabledLabel() {
    Intent activityResultIntent = new Intent(mContext, AppPicker.class);
    final String appLabel = "foobar";
    activityResultIntent.setAction(appLabel);
    final boolean result = mController.onActivityResult(REQUEST_CODE_ANGLE_ENABLED_APP, Activity.RESULT_OK, activityResultIntent);
    assertThat(result).isTrue();
    assertThat(mPreference.getSummary()).isEqualTo(mContext.getString(R.string.angle_enabled_app_set, appLabel));
}
#end_block

#method_before
@Test
public void onDeveloperOptionsSwitchDisabled_shouldDisablePreference() {
    mController.onDeveloperOptionsSwitchDisabled();
    verify(mPreference).setEnabled(false);
    verify(mPreference).setSummary(mContext.getString(R.string.angle_enabled_app_not_set));
}
#method_after
@Test
public void onDeveloperOptionsSwitchDisabled_shouldDisablePreference() {
    mController.onDeveloperOptionsSwitchDisabled();
    assertThat(mPreference.isEnabled()).isFalse();
    assertThat(mPreference.getSummary()).isEqualTo(mContext.getString(R.string.angle_enabled_app_not_set));
}
#end_block

#method_before
public void init(KeyGenerationParameters param) {
    this.param = (RSAKeyGenerationParameters) param;
    this.iterations = getNumberOfIterations(this.param.getStrength(), this.param.getCertainty());
}
#method_after
public void init(KeyGenerationParameters param) {
    this.param = (RSAKeyGenerationParameters) param;
}
#end_block

#method_before
protected boolean isProbablePrime(BigInteger x) {
    /*
         * Primes class for FIPS 186-4 C.3 primality checking
         */
    return !Primes.hasAnySmallFactors(x) && Primes.isMRProbablePrime(x, param.getRandom(), iterations);
}
#method_after
protected boolean isProbablePrime(BigInteger x) {
    int iterations = getNumberOfIterations(x.bitLength(), param.getCertainty());
    /*
         * Primes class for FIPS 186-4 C.3 primality checking
         */
    return !Primes.hasAnySmallFactors(x) && Primes.isMRProbablePrime(x, param.getRandom(), iterations);
}
#end_block

#method_before
@SuppressLint("NewApi")
void loadFromAttributes(AttributeSet attrs, int defStyleAttr) {
    final Context context = mView.getContext();
    final AppCompatDrawableManager drawableManager = AppCompatDrawableManager.get();
    // First read the TextAppearance style id
    TintTypedArray a = TintTypedArray.obtainStyledAttributes(context, attrs, R.styleable.AppCompatTextHelper, defStyleAttr, 0);
    final int ap = a.getResourceId(R.styleable.AppCompatTextHelper_android_textAppearance, -1);
    // Now read the compound drawable and grab any tints
    if (a.hasValue(R.styleable.AppCompatTextHelper_android_drawableLeft)) {
        mDrawableLeftTint = createTintInfo(context, drawableManager, a.getResourceId(R.styleable.AppCompatTextHelper_android_drawableLeft, 0));
    }
    if (a.hasValue(R.styleable.AppCompatTextHelper_android_drawableTop)) {
        mDrawableTopTint = createTintInfo(context, drawableManager, a.getResourceId(R.styleable.AppCompatTextHelper_android_drawableTop, 0));
    }
    if (a.hasValue(R.styleable.AppCompatTextHelper_android_drawableRight)) {
        mDrawableRightTint = createTintInfo(context, drawableManager, a.getResourceId(R.styleable.AppCompatTextHelper_android_drawableRight, 0));
    }
    if (a.hasValue(R.styleable.AppCompatTextHelper_android_drawableBottom)) {
        mDrawableBottomTint = createTintInfo(context, drawableManager, a.getResourceId(R.styleable.AppCompatTextHelper_android_drawableBottom, 0));
    }
    if (Build.VERSION.SDK_INT >= 17) {
        if (a.hasValue(R.styleable.AppCompatTextHelper_android_drawableStart)) {
            mDrawableStartTint = createTintInfo(context, drawableManager, a.getResourceId(R.styleable.AppCompatTextHelper_android_drawableStart, 0));
        }
        if (a.hasValue(R.styleable.AppCompatTextHelper_android_drawableEnd)) {
            mDrawableEndTint = createTintInfo(context, drawableManager, a.getResourceId(R.styleable.AppCompatTextHelper_android_drawableEnd, 0));
        }
    }
    a.recycle();
    // PasswordTransformationMethod wipes out all other TransformationMethod instances
    // in TextView's constructor, so we should only set a new transformation method
    // if we don't have a PasswordTransformationMethod currently...
    final boolean hasPwdTm = mView.getTransformationMethod() instanceof PasswordTransformationMethod;
    boolean allCaps = false;
    boolean allCapsSet = false;
    ColorStateList textColor = null;
    ColorStateList textColorHint = null;
    ColorStateList textColorLink = null;
    // First check TextAppearance's textAllCaps value
    if (ap != -1) {
        a = TintTypedArray.obtainStyledAttributes(context, ap, R.styleable.TextAppearance);
        if (!hasPwdTm && a.hasValue(R.styleable.TextAppearance_textAllCaps)) {
            allCapsSet = true;
            allCaps = a.getBoolean(R.styleable.TextAppearance_textAllCaps, false);
        }
        updateTypefaceAndStyle(context, a);
        if (Build.VERSION.SDK_INT < 23) {
            // so let's re-set using our own inflater
            if (a.hasValue(R.styleable.TextAppearance_android_textColor)) {
                textColor = a.getColorStateList(R.styleable.TextAppearance_android_textColor);
            }
            if (a.hasValue(R.styleable.TextAppearance_android_textColorHint)) {
                textColorHint = a.getColorStateList(R.styleable.TextAppearance_android_textColorHint);
            }
            if (a.hasValue(R.styleable.TextAppearance_android_textColorLink)) {
                textColorLink = a.getColorStateList(R.styleable.TextAppearance_android_textColorLink);
            }
        }
        a.recycle();
    }
    // Now read the style's values
    a = TintTypedArray.obtainStyledAttributes(context, attrs, R.styleable.TextAppearance, defStyleAttr, 0);
    if (!hasPwdTm && a.hasValue(R.styleable.TextAppearance_textAllCaps)) {
        allCapsSet = true;
        allCaps = a.getBoolean(R.styleable.TextAppearance_textAllCaps, false);
    }
    if (Build.VERSION.SDK_INT < 23) {
        // so let's re-set using our own inflater
        if (a.hasValue(R.styleable.TextAppearance_android_textColor)) {
            textColor = a.getColorStateList(R.styleable.TextAppearance_android_textColor);
        }
        if (a.hasValue(R.styleable.TextAppearance_android_textColorHint)) {
            textColorHint = a.getColorStateList(R.styleable.TextAppearance_android_textColorHint);
        }
        if (a.hasValue(R.styleable.TextAppearance_android_textColorLink)) {
            textColorLink = a.getColorStateList(R.styleable.TextAppearance_android_textColorLink);
        }
    }
    // In P, when the text size attribute is 0, this would not be set. Fix this here.
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P && a.hasValue(R.styleable.TextAppearance_android_textSize)) {
        if (a.getDimensionPixelSize(R.styleable.TextAppearance_android_textSize, -1) == 0) {
            mView.setTextSize(TypedValue.COMPLEX_UNIT_PX, 0.0f);
        }
    }
    updateTypefaceAndStyle(context, a);
    a.recycle();
    if (textColor != null) {
        mView.setTextColor(textColor);
    }
    if (textColorHint != null) {
        mView.setHintTextColor(textColorHint);
    }
    if (textColorLink != null) {
        mView.setLinkTextColor(textColorLink);
    }
    if (!hasPwdTm && allCapsSet) {
        setAllCaps(allCaps);
    }
    if (mFontTypeface != null) {
        mView.setTypeface(mFontTypeface, mStyle);
    }
    mAutoSizeTextHelper.loadFromAttributes(attrs, defStyleAttr);
    if (PLATFORM_SUPPORTS_AUTOSIZE) {
        // Delegate auto-size functionality to the framework implementation.
        if (mAutoSizeTextHelper.getAutoSizeTextType() != TextViewCompat.AUTO_SIZE_TEXT_TYPE_NONE) {
            final int[] autoSizeTextSizesInPx = mAutoSizeTextHelper.getAutoSizeTextAvailableSizes();
            if (autoSizeTextSizesInPx.length > 0) {
                if (mView.getAutoSizeStepGranularity() != AppCompatTextViewAutoSizeHelper.UNSET_AUTO_SIZE_UNIFORM_CONFIGURATION_VALUE) {
                    // Configured with granularity, preserve details.
                    mView.setAutoSizeTextTypeUniformWithConfiguration(mAutoSizeTextHelper.getAutoSizeMinTextSize(), mAutoSizeTextHelper.getAutoSizeMaxTextSize(), mAutoSizeTextHelper.getAutoSizeStepGranularity(), TypedValue.COMPLEX_UNIT_PX);
                } else {
                    mView.setAutoSizeTextTypeUniformWithPresetSizes(autoSizeTextSizesInPx, TypedValue.COMPLEX_UNIT_PX);
                }
            }
        }
    }
    // Read line and baseline heights attributes.
    a = TintTypedArray.obtainStyledAttributes(context, attrs, R.styleable.AppCompatTextView);
    final int firstBaselineToTopHeight = a.getDimensionPixelSize(R.styleable.AppCompatTextView_firstBaselineToTopHeight, -1);
    final int lastBaselineToBottomHeight = a.getDimensionPixelSize(R.styleable.AppCompatTextView_lastBaselineToBottomHeight, -1);
    final int lineHeight = a.getDimensionPixelSize(R.styleable.AppCompatTextView_lineHeight, -1);
    // Load compat compound drawables, allowing vector backport
    Drawable drawableLeft = null;
    final int drawableLeftId = a.getResourceId(R.styleable.AppCompatTextView_drawableLeftCompat, -1);
    if (drawableLeftId != -1) {
        drawableLeft = AppCompatResources.getDrawable(context, drawableLeftId);
    }
    Drawable drawableTop = null;
    final int drawableTopId = a.getResourceId(R.styleable.AppCompatTextView_drawableTopCompat, -1);
    if (drawableTopId != -1) {
        drawableTop = AppCompatResources.getDrawable(context, drawableTopId);
    }
    Drawable drawableRight = null;
    final int drawableRightId = a.getResourceId(R.styleable.AppCompatTextView_drawableRightCompat, -1);
    if (drawableRightId != -1) {
        drawableRight = AppCompatResources.getDrawable(context, drawableRightId);
    }
    Drawable drawableBottom = null;
    final int drawableBottomId = a.getResourceId(R.styleable.AppCompatTextView_drawableBottomCompat, -1);
    if (drawableBottomId != -1) {
        drawableBottom = AppCompatResources.getDrawable(context, drawableBottomId);
    }
    Drawable drawableStart = null;
    final int drawableStartId = a.getResourceId(R.styleable.AppCompatTextView_drawableStartCompat, -1);
    if (drawableStartId != -1) {
        drawableStart = AppCompatResources.getDrawable(context, drawableStartId);
    }
    Drawable drawableEnd = null;
    final int drawableEndId = a.getResourceId(R.styleable.AppCompatTextView_drawableEndCompat, -1);
    if (drawableEndId != -1) {
        drawableEnd = AppCompatResources.getDrawable(context, drawableEndId);
    }
    final Drawable[] existing = mView.getCompoundDrawablesRelative();
    final boolean ltr = ViewCompat.getLayoutDirection(mView) == LAYOUT_DIRECTION_LTR;
    Drawable start = existing[0];
    if (drawableStart != null) {
        start = drawableStart;
    } else if (ltr && drawableLeft != null) {
        start = drawableLeft;
    } else if (!ltr && drawableRight != null) {
        start = drawableRight;
    }
    Drawable end = existing[2];
    if (drawableEnd != null) {
        end = drawableEnd;
    } else if (ltr && drawableRight != null) {
        end = drawableRight;
    } else if (!ltr && drawableLeft != null) {
        end = drawableLeft;
    }
    mView.setCompoundDrawablesRelativeWithIntrinsicBounds(start, drawableTop != null ? drawableTop : existing[1], end, drawableBottom != null ? drawableBottom : existing[3]);
    a.recycle();
    if (firstBaselineToTopHeight != -1) {
        TextViewCompat.setFirstBaselineToTopHeight(mView, firstBaselineToTopHeight);
    }
    if (lastBaselineToBottomHeight != -1) {
        TextViewCompat.setLastBaselineToBottomHeight(mView, lastBaselineToBottomHeight);
    }
    if (lineHeight != -1) {
        TextViewCompat.setLineHeight(mView, lineHeight);
    }
}
#method_after
@SuppressLint("NewApi")
void loadFromAttributes(AttributeSet attrs, int defStyleAttr) {
    final Context context = mView.getContext();
    final AppCompatDrawableManager drawableManager = AppCompatDrawableManager.get();
    // First read the TextAppearance style id
    TintTypedArray a = TintTypedArray.obtainStyledAttributes(context, attrs, R.styleable.AppCompatTextHelper, defStyleAttr, 0);
    final int ap = a.getResourceId(R.styleable.AppCompatTextHelper_android_textAppearance, -1);
    // Now read the compound drawable and grab any tints
    if (a.hasValue(R.styleable.AppCompatTextHelper_android_drawableLeft)) {
        mDrawableLeftTint = createTintInfo(context, drawableManager, a.getResourceId(R.styleable.AppCompatTextHelper_android_drawableLeft, 0));
    }
    if (a.hasValue(R.styleable.AppCompatTextHelper_android_drawableTop)) {
        mDrawableTopTint = createTintInfo(context, drawableManager, a.getResourceId(R.styleable.AppCompatTextHelper_android_drawableTop, 0));
    }
    if (a.hasValue(R.styleable.AppCompatTextHelper_android_drawableRight)) {
        mDrawableRightTint = createTintInfo(context, drawableManager, a.getResourceId(R.styleable.AppCompatTextHelper_android_drawableRight, 0));
    }
    if (a.hasValue(R.styleable.AppCompatTextHelper_android_drawableBottom)) {
        mDrawableBottomTint = createTintInfo(context, drawableManager, a.getResourceId(R.styleable.AppCompatTextHelper_android_drawableBottom, 0));
    }
    if (Build.VERSION.SDK_INT >= 17) {
        if (a.hasValue(R.styleable.AppCompatTextHelper_android_drawableStart)) {
            mDrawableStartTint = createTintInfo(context, drawableManager, a.getResourceId(R.styleable.AppCompatTextHelper_android_drawableStart, 0));
        }
        if (a.hasValue(R.styleable.AppCompatTextHelper_android_drawableEnd)) {
            mDrawableEndTint = createTintInfo(context, drawableManager, a.getResourceId(R.styleable.AppCompatTextHelper_android_drawableEnd, 0));
        }
    }
    a.recycle();
    // PasswordTransformationMethod wipes out all other TransformationMethod instances
    // in TextView's constructor, so we should only set a new transformation method
    // if we don't have a PasswordTransformationMethod currently...
    final boolean hasPwdTm = mView.getTransformationMethod() instanceof PasswordTransformationMethod;
    boolean allCaps = false;
    boolean allCapsSet = false;
    ColorStateList textColor = null;
    ColorStateList textColorHint = null;
    ColorStateList textColorLink = null;
    String fontVariation = null;
    // First check TextAppearance's textAllCaps value
    if (ap != -1) {
        a = TintTypedArray.obtainStyledAttributes(context, ap, R.styleable.TextAppearance);
        if (!hasPwdTm && a.hasValue(R.styleable.TextAppearance_textAllCaps)) {
            allCapsSet = true;
            allCaps = a.getBoolean(R.styleable.TextAppearance_textAllCaps, false);
        }
        updateTypefaceAndStyle(context, a);
        if (Build.VERSION.SDK_INT < 23) {
            // so let's re-set using our own inflater
            if (a.hasValue(R.styleable.TextAppearance_android_textColor)) {
                textColor = a.getColorStateList(R.styleable.TextAppearance_android_textColor);
            }
            if (a.hasValue(R.styleable.TextAppearance_android_textColorHint)) {
                textColorHint = a.getColorStateList(R.styleable.TextAppearance_android_textColorHint);
            }
            if (a.hasValue(R.styleable.TextAppearance_android_textColorLink)) {
                textColorLink = a.getColorStateList(R.styleable.TextAppearance_android_textColorLink);
            }
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O && a.hasValue(R.styleable.TextAppearance_fontVariationSettings)) {
            fontVariation = a.getString(R.styleable.TextAppearance_fontVariationSettings);
        }
        a.recycle();
    }
    // Now read the style's values
    a = TintTypedArray.obtainStyledAttributes(context, attrs, R.styleable.TextAppearance, defStyleAttr, 0);
    if (!hasPwdTm && a.hasValue(R.styleable.TextAppearance_textAllCaps)) {
        allCapsSet = true;
        allCaps = a.getBoolean(R.styleable.TextAppearance_textAllCaps, false);
    }
    if (Build.VERSION.SDK_INT < 23) {
        // so let's re-set using our own inflater
        if (a.hasValue(R.styleable.TextAppearance_android_textColor)) {
            textColor = a.getColorStateList(R.styleable.TextAppearance_android_textColor);
        }
        if (a.hasValue(R.styleable.TextAppearance_android_textColorHint)) {
            textColorHint = a.getColorStateList(R.styleable.TextAppearance_android_textColorHint);
        }
        if (a.hasValue(R.styleable.TextAppearance_android_textColorLink)) {
            textColorLink = a.getColorStateList(R.styleable.TextAppearance_android_textColorLink);
        }
    }
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O && a.hasValue(R.styleable.TextAppearance_fontVariationSettings)) {
        fontVariation = a.getString(R.styleable.TextAppearance_fontVariationSettings);
    }
    // In P, when the text size attribute is 0, this would not be set. Fix this here.
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P && a.hasValue(R.styleable.TextAppearance_android_textSize)) {
        if (a.getDimensionPixelSize(R.styleable.TextAppearance_android_textSize, -1) == 0) {
            mView.setTextSize(TypedValue.COMPLEX_UNIT_PX, 0.0f);
        }
    }
    updateTypefaceAndStyle(context, a);
    a.recycle();
    if (textColor != null) {
        mView.setTextColor(textColor);
    }
    if (textColorHint != null) {
        mView.setHintTextColor(textColorHint);
    }
    if (textColorLink != null) {
        mView.setLinkTextColor(textColorLink);
    }
    if (!hasPwdTm && allCapsSet) {
        setAllCaps(allCaps);
    }
    if (mFontTypeface != null) {
        mView.setTypeface(mFontTypeface, mStyle);
    }
    if (fontVariation != null) {
        mView.setFontVariationSettings(fontVariation);
    }
    mAutoSizeTextHelper.loadFromAttributes(attrs, defStyleAttr);
    if (PLATFORM_SUPPORTS_AUTOSIZE) {
        // Delegate auto-size functionality to the framework implementation.
        if (mAutoSizeTextHelper.getAutoSizeTextType() != TextViewCompat.AUTO_SIZE_TEXT_TYPE_NONE) {
            final int[] autoSizeTextSizesInPx = mAutoSizeTextHelper.getAutoSizeTextAvailableSizes();
            if (autoSizeTextSizesInPx.length > 0) {
                if (mView.getAutoSizeStepGranularity() != AppCompatTextViewAutoSizeHelper.UNSET_AUTO_SIZE_UNIFORM_CONFIGURATION_VALUE) {
                    // Configured with granularity, preserve details.
                    mView.setAutoSizeTextTypeUniformWithConfiguration(mAutoSizeTextHelper.getAutoSizeMinTextSize(), mAutoSizeTextHelper.getAutoSizeMaxTextSize(), mAutoSizeTextHelper.getAutoSizeStepGranularity(), TypedValue.COMPLEX_UNIT_PX);
                } else {
                    mView.setAutoSizeTextTypeUniformWithPresetSizes(autoSizeTextSizesInPx, TypedValue.COMPLEX_UNIT_PX);
                }
            }
        }
    }
    // Read line and baseline heights attributes.
    a = TintTypedArray.obtainStyledAttributes(context, attrs, R.styleable.AppCompatTextView);
    // Load compat compound drawables, allowing vector backport
    Drawable drawableLeft = null, drawableTop = null, drawableRight = null, drawableBottom = null, drawableStart = null, drawableEnd = null;
    final int drawableLeftId = a.getResourceId(R.styleable.AppCompatTextView_drawableLeftCompat, -1);
    if (drawableLeftId != -1) {
        drawableLeft = drawableManager.getDrawable(context, drawableLeftId);
    }
    final int drawableTopId = a.getResourceId(R.styleable.AppCompatTextView_drawableTopCompat, -1);
    if (drawableTopId != -1) {
        drawableTop = drawableManager.getDrawable(context, drawableTopId);
    }
    final int drawableRightId = a.getResourceId(R.styleable.AppCompatTextView_drawableRightCompat, -1);
    if (drawableRightId != -1) {
        drawableRight = drawableManager.getDrawable(context, drawableRightId);
    }
    final int drawableBottomId = a.getResourceId(R.styleable.AppCompatTextView_drawableBottomCompat, -1);
    if (drawableBottomId != -1) {
        drawableBottom = drawableManager.getDrawable(context, drawableBottomId);
    }
    final int drawableStartId = a.getResourceId(R.styleable.AppCompatTextView_drawableStartCompat, -1);
    if (drawableStartId != -1) {
        drawableStart = drawableManager.getDrawable(context, drawableStartId);
    }
    final int drawableEndId = a.getResourceId(R.styleable.AppCompatTextView_drawableEndCompat, -1);
    if (drawableEndId != -1) {
        drawableEnd = drawableManager.getDrawable(context, drawableEndId);
    }
    setCompoundDrawables(drawableLeft, drawableTop, drawableRight, drawableBottom, drawableStart, drawableEnd);
    final int firstBaselineToTopHeight = a.getDimensionPixelSize(R.styleable.AppCompatTextView_firstBaselineToTopHeight, -1);
    final int lastBaselineToBottomHeight = a.getDimensionPixelSize(R.styleable.AppCompatTextView_lastBaselineToBottomHeight, -1);
    final int lineHeight = a.getDimensionPixelSize(R.styleable.AppCompatTextView_lineHeight, -1);
    a.recycle();
    if (firstBaselineToTopHeight != -1) {
        TextViewCompat.setFirstBaselineToTopHeight(mView, firstBaselineToTopHeight);
    }
    if (lastBaselineToBottomHeight != -1) {
        TextViewCompat.setLastBaselineToBottomHeight(mView, lastBaselineToBottomHeight);
    }
    if (lineHeight != -1) {
        TextViewCompat.setLineHeight(mView, lineHeight);
    }
}
#end_block

#method_before
void onSetTextAppearance(Context context, int resId) {
    final TintTypedArray a = TintTypedArray.obtainStyledAttributes(context, resId, R.styleable.TextAppearance);
    if (a.hasValue(R.styleable.TextAppearance_textAllCaps)) {
        // This breaks away slightly from the logic in TextView.setTextAppearance that serves
        // as an "overlay" on the current state of the TextView. Since android:textAllCaps
        // may have been set to true in this text appearance, we need to make sure that
        // app:textAllCaps has the chance to override it
        setAllCaps(a.getBoolean(R.styleable.TextAppearance_textAllCaps, false));
    }
    if (Build.VERSION.SDK_INT < 23 && a.hasValue(R.styleable.TextAppearance_android_textColor)) {
        // If we're running on < API 23, the text color may contain theme references
        // so let's re-set using our own inflater
        final ColorStateList textColor = a.getColorStateList(R.styleable.TextAppearance_android_textColor);
        if (textColor != null) {
            mView.setTextColor(textColor);
        }
    }
    // For SDK <= P, when the text size attribute is 0, this would not be set. Fix this here.
    if (a.hasValue(R.styleable.TextAppearance_android_textSize)) {
        if (a.getDimensionPixelSize(R.styleable.TextAppearance_android_textSize, -1) == 0) {
            mView.setTextSize(TypedValue.COMPLEX_UNIT_PX, 0.0f);
        }
    }
    updateTypefaceAndStyle(context, a);
    a.recycle();
    if (mFontTypeface != null) {
        mView.setTypeface(mFontTypeface, mStyle);
    }
}
#method_after
void onSetTextAppearance(Context context, int resId) {
    final TintTypedArray a = TintTypedArray.obtainStyledAttributes(context, resId, R.styleable.TextAppearance);
    if (a.hasValue(R.styleable.TextAppearance_textAllCaps)) {
        // This breaks away slightly from the logic in TextView.setTextAppearance that serves
        // as an "overlay" on the current state of the TextView. Since android:textAllCaps
        // may have been set to true in this text appearance, we need to make sure that
        // app:textAllCaps has the chance to override it
        setAllCaps(a.getBoolean(R.styleable.TextAppearance_textAllCaps, false));
    }
    if (Build.VERSION.SDK_INT < 23 && a.hasValue(R.styleable.TextAppearance_android_textColor)) {
        // If we're running on < API 23, the text color may contain theme references
        // so let's re-set using our own inflater
        final ColorStateList textColor = a.getColorStateList(R.styleable.TextAppearance_android_textColor);
        if (textColor != null) {
            mView.setTextColor(textColor);
        }
    }
    // For SDK <= P, when the text size attribute is 0, this would not be set. Fix this here.
    if (a.hasValue(R.styleable.TextAppearance_android_textSize)) {
        if (a.getDimensionPixelSize(R.styleable.TextAppearance_android_textSize, -1) == 0) {
            mView.setTextSize(TypedValue.COMPLEX_UNIT_PX, 0.0f);
        }
    }
    updateTypefaceAndStyle(context, a);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O && a.hasValue(R.styleable.TextAppearance_fontVariationSettings)) {
        final String fontVariation = a.getString(R.styleable.TextAppearance_fontVariationSettings);
        if (fontVariation != null) {
            mView.setFontVariationSettings(fontVariation);
        }
    }
    a.recycle();
    if (mFontTypeface != null) {
        mView.setTypeface(mFontTypeface, mStyle);
    }
}
#end_block

#method_before
@TargetApi(JELLY_BEAN_MR1)
@Override
public void setCompoundDrawablesRelativeWithIntrinsicBounds(int start, int top, int end, int bottom) {
    final Context context = getContext();
    setCompoundDrawablesRelativeWithIntrinsicBounds(start != 0 ? AppCompatResources.getDrawable(context, start) : null, top != 0 ? AppCompatResources.getDrawable(context, top) : null, end != 0 ? AppCompatResources.getDrawable(context, end) : null, bottom != 0 ? AppCompatResources.getDrawable(context, bottom) : null);
}
#method_after
@RequiresApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
@Override
public void setCompoundDrawablesRelativeWithIntrinsicBounds(int start, int top, int end, int bottom) {
    final Context context = getContext();
    setCompoundDrawablesRelativeWithIntrinsicBounds(start != 0 ? AppCompatResources.getDrawable(context, start) : null, top != 0 ? AppCompatResources.getDrawable(context, top) : null, end != 0 ? AppCompatResources.getDrawable(context, end) : null, bottom != 0 ? AppCompatResources.getDrawable(context, bottom) : null);
}
#end_block

#method_before
private void setMediaSession(MediaSessionCompat.Token sessionToken) {
    if (mMediaController != null) {
        mMediaController.unregisterCallback(mControllerCallback);
        mMediaController = null;
    }
    if (sessionToken == null) {
        return;
    }
    if (!mAttachedToWindow) {
        return;
    }
    try {
        mMediaController = new MediaControllerCompat(mContext, sessionToken);
    } catch (RemoteException e) {
        Log.e(TAG, "Error creating media controller in setMediaSession.", e);
    }
    if (mMediaController != null) {
        mMediaController.registerCallback(mControllerCallback);
    }
    MediaMetadataCompat metadata = mMediaController == null ? null : mMediaController.getMetadata();
    mDescription = metadata == null ? null : metadata.getDescription();
    updateArtIconIfNeeded();
    updateMetadata();
}
#method_after
private void setMediaSession(MediaSessionCompat.Token sessionToken) {
    if (mMediaController != null) {
        mMediaController.unregisterCallback(mControllerCallback);
        mMediaController = null;
    }
    if (sessionToken == null) {
        return;
    }
    if (!mAttachedToWindow) {
        return;
    }
    try {
        mMediaController = new MediaControllerCompat(mContext, sessionToken);
    } catch (RemoteException e) {
        Log.e(TAG, "Error creating media controller in setMediaSession.", e);
    }
    if (mMediaController != null) {
        mMediaController.registerCallback(mControllerCallback);
    }
    MediaMetadataCompat metadata = mMediaController == null ? null : mMediaController.getMetadata();
    mDescription = metadata == null ? null : metadata.getDescription();
    updateArtIconIfNeeded();
    updateMetadataViews();
}
#end_block

#method_before
public void setRouteSelector(@NonNull MediaRouteSelector selector) {
    if (selector == null) {
        throw new IllegalArgumentException("selector must not be null");
    }
    if (!mSelector.equals(selector)) {
        mSelector = selector;
        if (mAttachedToWindow) {
            mRouter.removeCallback(mCallback);
            mRouter.addCallback(selector, mCallback, MediaRouter.CALLBACK_FLAG_PERFORM_ACTIVE_SCAN);
        }
        refreshRoutes();
    }
}
#method_after
public void setRouteSelector(@NonNull MediaRouteSelector selector) {
    if (selector == null) {
        throw new IllegalArgumentException("selector must not be null");
    }
    if (!mSelector.equals(selector)) {
        mSelector = selector;
        if (mAttachedToWindow) {
            mRouter.removeCallback(mCallback);
            mRouter.addCallback(selector, mCallback, MediaRouter.CALLBACK_FLAG_PERFORM_ACTIVE_SCAN);
            updateRoutes();
        }
    }
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.mr_cast_dialog);
    mCloseButton = findViewById(R.id.mr_cast_close_button);
    mCloseButton.setColorFilter(COLOR_WHITE_ON_DARK_BACKGROUND);
    mCloseButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    mStopCastingButton = findViewById(R.id.mr_cast_stop_button);
    mStopCastingButton.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mStopCastingButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mSelectedRoute.isSelected()) {
                mRouter.unselect(MediaRouter.UNSELECT_REASON_STOPPED);
            }
            dismiss();
        }
    });
    mAdapter = new RecyclerAdapter();
    mRecyclerView = findViewById(R.id.mr_cast_list);
    mRecyclerView.setAdapter(mAdapter);
    mRecyclerView.setLayoutManager(new LinearLayoutManager(mContext));
    mVolumeChangeListener = new VolumeChangeListener();
    mVolumeSliderColor = MediaRouterThemeHelper.getControllerColor(mContext, 0);
    mVolumeSliderHolderMap = new HashMap<>();
    mBeforeMuteVolumeMap = new HashMap<>();
    mMetadataLayout = findViewById(R.id.mr_cast_meta);
    mArtView = findViewById(R.id.mr_cast_meta_art);
    mTitleView = findViewById(R.id.mr_cast_meta_title);
    mTitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mSubtitleView = findViewById(R.id.mr_cast_meta_subtitle);
    mSubtitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    Resources res = mContext.getResources();
    mTitlePlaceholder = res.getString(R.string.mr_cast_dialog_title_view_placeholder);
    mCreated = true;
    updateLayout();
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.mr_cast_dialog);
    MediaRouterThemeHelper.setDialogBackgroundColor(mContext, this);
    mCloseButton = findViewById(R.id.mr_cast_close_button);
    mCloseButton.setColorFilter(COLOR_WHITE_ON_DARK_BACKGROUND);
    mCloseButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    mStopCastingButton = findViewById(R.id.mr_cast_stop_button);
    mStopCastingButton.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mStopCastingButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mSelectedRoute.isSelected()) {
                mRouter.unselect(MediaRouter.UNSELECT_REASON_STOPPED);
            }
            dismiss();
        }
    });
    mAdapter = new RecyclerAdapter();
    mRecyclerView = findViewById(R.id.mr_cast_list);
    mRecyclerView.setAdapter(mAdapter);
    mRecyclerView.setLayoutManager(new LinearLayoutManager(mContext));
    mVolumeChangeListener = new VolumeChangeListener();
    mVolumeSliderColor = MediaRouterThemeHelper.getControllerColor(mContext, 0);
    mVolumeSliderHolderMap = new HashMap<>();
    mBeforeMuteVolumeMap = new HashMap<>();
    mMetadataBackground = findViewById(R.id.mr_cast_meta_background);
    mMetadataBlackScrim = findViewById(R.id.mr_cast_meta_black_scrim);
    mArtView = findViewById(R.id.mr_cast_meta_art);
    mTitleView = findViewById(R.id.mr_cast_meta_title);
    mTitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mSubtitleView = findViewById(R.id.mr_cast_meta_subtitle);
    mSubtitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    Resources res = mContext.getResources();
    mTitlePlaceholder = res.getString(R.string.mr_cast_dialog_title_view_placeholder);
    mCreated = true;
    updateLayout();
}
#end_block

#method_before
void updateLayout() {
    int width = MediaRouteDialogHelper.getDialogWidth(mContext);
    int height = MediaRouteDialogHelper.getDialogHeight(mContext);
    getWindow().setLayout(width, height);
    mArtIconBitmap = null;
    mArtIconUri = null;
    updateArtIconIfNeeded();
    updateMetadata();
    updateRecyclerView();
}
#method_after
void updateLayout() {
    int width = MediaRouteDialogHelper.getDialogWidth(mContext);
    int height = MediaRouteDialogHelper.getDialogHeight(mContext);
    getWindow().setLayout(width, height);
    mArtIconBitmap = null;
    mArtIconUri = null;
    updateArtIconIfNeeded();
    updateMetadataViews();
    updateRoutesView();
}
#end_block

#method_before
@Override
public void onAttachedToWindow() {
    super.onAttachedToWindow();
    mAttachedToWindow = true;
    mRouter.addCallback(mSelector, mCallback, MediaRouter.CALLBACK_FLAG_PERFORM_ACTIVE_SCAN);
    refreshRoutes();
    setMediaSession(mRouter.getMediaSessionToken());
}
#method_after
@Override
public void onAttachedToWindow() {
    super.onAttachedToWindow();
    mAttachedToWindow = true;
    mRouter.addCallback(mSelector, mCallback, MediaRouter.CALLBACK_FLAG_PERFORM_ACTIVE_SCAN);
    updateRoutes();
    setMediaSession(mRouter.getMediaSessionToken());
}
#end_block

#method_before
@Override
public void onDetachedFromWindow() {
    super.onDetachedFromWindow();
    mAttachedToWindow = false;
    mRouter.removeCallback(mCallback);
    mHandler.removeMessages(MSG_UPDATE_ROUTES);
    setMediaSession(null);
}
#method_after
@Override
public void onDetachedFromWindow() {
    super.onDetachedFromWindow();
    mAttachedToWindow = false;
    mRouter.removeCallback(mCallback);
    mHandler.removeCallbacksAndMessages(null);
    setMediaSession(null);
}
#end_block

#method_before
void updateRoutes(List<MediaRouter.RouteInfo> routes) {
    mLastUpdateTime = SystemClock.uptimeMillis();
    mRoutes.clear();
    mRoutes.addAll(routes);
    mAdapter.setItems();
}
#method_after
void updateRoutes() {
    ArrayList<MediaRouter.RouteInfo> routes = new ArrayList<>(mRouter.getRoutes());
    onFilterRoutes(routes);
    Collections.sort(routes, MediaRouteChooserDialog.RouteComparator.sInstance);
    mRoutes.clear();
    mRoutes.addAll(routes);
    mAdapter.setItems();
}
#end_block

#method_before
boolean isSelectedRoute(MediaRouter.RouteInfo route) {
    if (route.isSelected()) {
        return true;
    }
    // If currently casting on a group and route is a member of the group
    if (mSelectedRoute instanceof MediaRouter.RouteGroup) {
        List<MediaRouter.RouteInfo> memberRoutes = ((MediaRouter.RouteGroup) mSelectedRoute).getRoutes();
        for (MediaRouter.RouteInfo memberRoute : memberRoutes) {
            if (memberRoute.getId().equals(route.getId())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
boolean isSelectedRoute(MediaRouter.RouteInfo route) {
    if (route.isSelected()) {
        return true;
    }
    // If currently casting on a group and route is a member of the group
    if (mSelectedRoute instanceof MediaRouter.RouteGroup) {
        List<MediaRouter.RouteInfo> memberRoutes = ((MediaRouter.RouteGroup) mSelectedRoute).getMemberRoutes();
        for (MediaRouter.RouteInfo memberRoute : memberRoutes) {
            if (memberRoute.getId().equals(route.getId())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
void setItems() {
    mItems.clear();
    // Add Group Volume item only when currently casting on a group
    if (mSelectedRoute instanceof MediaRouter.RouteGroup) {
        mItems.add(new Item(mSelectedRoute, ITEM_TYPE_GROUP_VOLUME));
        List<MediaRouter.RouteInfo> routes = ((MediaRouter.RouteGroup) mSelectedRoute).getRoutes();
        for (MediaRouter.RouteInfo route : routes) {
            mItems.add(new Item(route, ITEM_TYPE_ROUTE));
        }
    } else {
        mItems.add(new Item(mSelectedRoute, ITEM_TYPE_ROUTE));
    }
    mAvailableRoutes.clear();
    mAvailableGroups.clear();
    for (MediaRouter.RouteInfo route : mRoutes) {
        // If route is current selected route, skip
        if (isSelectedRoute(route)) {
            continue;
        }
        if (route instanceof MediaRouter.RouteGroup) {
            mAvailableGroups.add(route);
        } else {
            mAvailableRoutes.add(route);
        }
    }
    // Add list items of available routes section to mItems
    if (mAvailableRoutes.size() > 0) {
        mItems.add(new Item(mContext.getString(R.string.mr_dialog_groupable_header), ITEM_TYPE_HEADER));
        for (MediaRouter.RouteInfo route : mAvailableRoutes) {
            mItems.add(new Item(route, ITEM_TYPE_ROUTE));
        }
    }
    // Add list items of available groups section to mItems
    if (mAvailableGroups.size() > 0) {
        mItems.add(new Item(mContext.getString(R.string.mr_dialog_transferable_header), ITEM_TYPE_HEADER));
        for (MediaRouter.RouteInfo route : mAvailableGroups) {
            mItems.add(new Item(route, ITEM_TYPE_GROUP));
        }
    }
    notifyDataSetChanged();
}
#method_after
void setItems() {
    mItems.clear();
    // Add Group Volume item only when currently casting on a group
    if (mSelectedRoute instanceof MediaRouter.RouteGroup) {
        mItems.add(new Item(mSelectedRoute, ITEM_TYPE_GROUP_VOLUME));
        List<MediaRouter.RouteInfo> routes = ((MediaRouter.RouteGroup) mSelectedRoute).getMemberRoutes();
        for (MediaRouter.RouteInfo route : routes) {
            mItems.add(new Item(route, ITEM_TYPE_ROUTE));
        }
    } else {
        mItems.add(new Item(mSelectedRoute, ITEM_TYPE_ROUTE));
    }
    mAvailableRoutes.clear();
    mAvailableGroups.clear();
    for (MediaRouter.RouteInfo route : mRoutes) {
        // If route is current selected route, skip
        if (isSelectedRoute(route)) {
            continue;
        }
        if (route instanceof MediaRouter.RouteGroup) {
            mAvailableGroups.add(route);
        } else {
            mAvailableRoutes.add(route);
        }
    }
    // Add list items of available routes section to mItems
    if (mAvailableRoutes.size() > 0) {
        mItems.add(new Item(mContext.getString(R.string.mr_dialog_groupable_header), ITEM_TYPE_HEADER));
        for (MediaRouter.RouteInfo route : mAvailableRoutes) {
            mItems.add(new Item(route, ITEM_TYPE_ROUTE));
        }
    }
    // Add list items of available groups section to mItems
    if (mAvailableGroups.size() > 0) {
        mItems.add(new Item(mContext.getString(R.string.mr_dialog_transferable_header), ITEM_TYPE_HEADER));
        for (MediaRouter.RouteInfo route : mAvailableGroups) {
            mItems.add(new Item(route, ITEM_TYPE_GROUP));
        }
    }
    notifyDataSetChanged();
}
#end_block

#method_before
@Override
public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    View view;
    switch(viewType) {
        case ITEM_TYPE_GROUP_VOLUME:
            view = mInflater.inflate(R.layout.mr_cast_group_volume_item, parent, false);
            return new GroupVolumeViewHolder(view);
        case ITEM_TYPE_HEADER:
            view = mInflater.inflate(R.layout.mr_dialog_header_item, parent, false);
            return new HeaderViewHolder(view);
        case ITEM_TYPE_ROUTE:
            view = mInflater.inflate(R.layout.mr_cast_route_item, parent, false);
            return new RouteViewHolder(view);
        case ITEM_TYPE_GROUP:
            view = mInflater.inflate(R.layout.mr_cast_group_item, parent, false);
            return new GroupViewHolder(view);
        default:
            Log.w(TAG, "Cannot create ViewHolder because of wrong view type");
            return null;
    }
}
#method_after
@Override
public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    View view;
    switch(viewType) {
        case ITEM_TYPE_GROUP_VOLUME:
            view = mInflater.inflate(R.layout.mr_cast_group_volume_item, parent, false);
            return new GroupVolumeViewHolder(view);
        case ITEM_TYPE_HEADER:
            view = mInflater.inflate(R.layout.mr_cast_header_item, parent, false);
            return new HeaderViewHolder(view);
        case ITEM_TYPE_ROUTE:
            view = mInflater.inflate(R.layout.mr_cast_route_item, parent, false);
            return new RouteViewHolder(view);
        case ITEM_TYPE_GROUP:
            view = mInflater.inflate(R.layout.mr_cast_group_item, parent, false);
            return new GroupViewHolder(view);
        default:
            Log.w(TAG, "Cannot create ViewHolder because of wrong view type");
            return null;
    }
}
#end_block

#method_before
public void bindHeaderViewHolder(Item item) {
    String headerName = item.getData().toString();
    mTextView.setText(headerName.toUpperCase());
}
#method_after
public void bindHeaderViewHolder(Item item) {
    String headerName = item.getData().toString();
    mTextView.setText(headerName);
}
#end_block

#method_before
@Override
public void onRouteAdded(MediaRouter router, MediaRouter.RouteInfo info) {
    refreshRoutes();
}
#method_after
@Override
public void onRouteAdded(MediaRouter router, MediaRouter.RouteInfo info) {
    updateRoutesView();
}
#end_block

#method_before
@Override
public void onRouteRemoved(MediaRouter router, MediaRouter.RouteInfo info) {
    refreshRoutes();
}
#method_after
@Override
public void onRouteRemoved(MediaRouter router, MediaRouter.RouteInfo info) {
    updateRoutesView();
}
#end_block

#method_before
@Override
public void onRouteSelected(MediaRouter router, MediaRouter.RouteInfo route) {
    mSelectedRoute = route;
    mIsSelectingRoute = false;
    updateRecyclerView();
}
#method_after
@Override
public void onRouteSelected(MediaRouter router, MediaRouter.RouteInfo route) {
    mSelectedRoute = route;
    mIsSelectingRoute = false;
    // Since updates of views are deferred when selecting the route,
    // call updateViewsIfNeeded to ensure that views are updated properly.
    updateViewsIfNeeded();
    updateRoutes();
}
#end_block

#method_before
@Override
public void onRouteUnselected(MediaRouter router, MediaRouter.RouteInfo route) {
    updateRecyclerView();
}
#method_after
@Override
public void onRouteUnselected(MediaRouter router, MediaRouter.RouteInfo route) {
    updateRoutesView();
}
#end_block

#method_before
@Override
public void onRouteChanged(MediaRouter router, MediaRouter.RouteInfo route) {
    if (mRouteForVolumeUpdatingByUser != null) {
        return;
    }
    int pos = mAdapter.getAdapterPositionByRoute(route);
    if (pos != RecyclerView.NO_POSITION) {
        mAdapter.notifyItemChanged(pos);
    }
}
#method_after
@Override
public void onRouteChanged(MediaRouter router, MediaRouter.RouteInfo route) {
    updateRoutesView();
}
#end_block

#method_before
@Override
public void onMetadataChanged(MediaMetadataCompat metadata) {
    mDescription = metadata == null ? null : metadata.getDescription();
    updateArtIconIfNeeded();
    updateMetadata();
}
#method_after
@Override
public void onMetadataChanged(MediaMetadataCompat metadata) {
    mDescription = metadata == null ? null : metadata.getDescription();
    updateArtIconIfNeeded();
    updateMetadataViews();
}
#end_block

#method_before
@Override
protected void onPostExecute(Bitmap art) {
    mFetchArtTask = null;
    if (!ObjectsCompat.equals(mArtIconBitmap, mIconBitmap) || !ObjectsCompat.equals(mArtIconUri, mIconUri)) {
        mArtIconBitmap = mIconBitmap;
        mArtIconLoadedBitmap = art;
        mArtIconUri = mIconUri;
        mArtIconBackgroundColor = mBackgroundColor;
        mArtIconIsLoaded = true;
        // Loaded bitmap will be applied on the next update
        updateMetadata();
    }
}
#method_after
@Override
protected void onPostExecute(Bitmap art) {
    mFetchArtTask = null;
    if (!ObjectsCompat.equals(mArtIconBitmap, mIconBitmap) || !ObjectsCompat.equals(mArtIconUri, mIconUri)) {
        mArtIconBitmap = mIconBitmap;
        mArtIconLoadedBitmap = art;
        mArtIconUri = mIconUri;
        mArtIconBackgroundColor = mBackgroundColor;
        mArtIconIsLoaded = true;
        // Loaded bitmap will be applied on the next update
        updateMetadataViews();
    }
}
#end_block

#method_before
public void onServiceConnected(int profile, BluetoothProfile proxy) {
    if (V)
        Log.d(TAG, "Bluetooth service connected");
    mService = (BluetoothHeadset) proxy;
    // We just bound to the service, so refresh the UI for any connected HFP devices.
    List<BluetoothDevice> deviceList = mService.getConnectedDevices();
    while (!deviceList.isEmpty()) {
        BluetoothDevice nextDevice = deviceList.remove(0);
        CachedBluetoothDevice device = mDeviceManager.findDevice(nextDevice);
        // we may add a new device here, but generally this should not happen
        if (device == null) {
            Log.w(TAG, "HeadsetProfile found new device: " + nextDevice);
            device = mDeviceManager.addDevice(mLocalAdapter, mProfileManager, nextDevice);
        }
        device.onProfileStateChanged(HeadsetProfile.this, BluetoothProfile.STATE_CONNECTED);
        device.refresh();
    }
    mProfileManager.callServiceConnectedListeners();
    mIsProfileReady = true;
}
#method_after
public void onServiceConnected(int profile, BluetoothProfile proxy) {
    Log.d(TAG, "Bluetooth service connected");
    mService = (BluetoothHeadset) proxy;
    // We just bound to the service, so refresh the UI for any connected HFP devices.
    List<BluetoothDevice> deviceList = mService.getConnectedDevices();
    while (!deviceList.isEmpty()) {
        BluetoothDevice nextDevice = deviceList.remove(0);
        CachedBluetoothDevice device = mDeviceManager.findDevice(nextDevice);
        // we may add a new device here, but generally this should not happen
        if (device == null) {
            Log.w(TAG, "HeadsetProfile found new device: " + nextDevice);
            device = mDeviceManager.addDevice(mLocalAdapter, mProfileManager, nextDevice);
        }
        device.onProfileStateChanged(HeadsetProfile.this, BluetoothProfile.STATE_CONNECTED);
        device.refresh();
    }
    mProfileManager.callServiceConnectedListeners();
    mIsProfileReady = true;
}
#end_block

#method_before
public void onServiceDisconnected(int profile) {
    if (V)
        Log.d(TAG, "Bluetooth service disconnected");
    mProfileManager.callServiceDisconnectedListeners();
    mIsProfileReady = false;
}
#method_after
public void onServiceDisconnected(int profile) {
    Log.d(TAG, "Bluetooth service disconnected");
    mProfileManager.callServiceDisconnectedListeners();
    mIsProfileReady = false;
}
#end_block

#method_before
public boolean connect(BluetoothDevice device) {
    if (mService == null)
        return false;
    return mService.connect(device);
}
#method_after
public boolean connect(BluetoothDevice device) {
    if (mService == null) {
        return false;
    }
    return mService.connect(device);
}
#end_block

#method_before
public boolean disconnect(BluetoothDevice device) {
    if (mService == null)
        return false;
    // Downgrade priority as user is disconnecting the headset.
    if (mService.getPriority(device) > BluetoothProfile.PRIORITY_ON) {
        mService.setPriority(device, BluetoothProfile.PRIORITY_ON);
    }
    return mService.disconnect(device);
}
#method_after
public boolean disconnect(BluetoothDevice device) {
    if (mService == null) {
        return false;
    }
    // Downgrade priority as user is disconnecting the headset.
    if (mService.getPriority(device) > BluetoothProfile.PRIORITY_ON) {
        mService.setPriority(device, BluetoothProfile.PRIORITY_ON);
    }
    return mService.disconnect(device);
}
#end_block

#method_before
public int getConnectionStatus(BluetoothDevice device) {
    if (mService == null)
        return BluetoothProfile.STATE_DISCONNECTED;
    return mService.getConnectionState(device);
}
#method_after
public int getConnectionStatus(BluetoothDevice device) {
    if (mService == null) {
        return BluetoothProfile.STATE_DISCONNECTED;
    }
    return mService.getConnectionState(device);
}
#end_block

#method_before
public boolean setActiveDevice(BluetoothDevice device) {
    if (mService == null)
        return false;
    return mService.setActiveDevice(device);
}
#method_after
public boolean setActiveDevice(BluetoothDevice device) {
    if (mService == null) {
        return false;
    }
    return mService.setActiveDevice(device);
}
#end_block

#method_before
public BluetoothDevice getActiveDevice() {
    if (mService == null)
        return null;
    return mService.getActiveDevice();
}
#method_after
public BluetoothDevice getActiveDevice() {
    if (mService == null) {
        return null;
    }
    return mService.getActiveDevice();
}
#end_block

#method_before
public boolean isAudioOn() {
    if (mService == null)
        return false;
    return mService.isAudioOn();
}
#method_after
public boolean isAudioOn() {
    if (mService == null) {
        return false;
    }
    return mService.isAudioOn();
}
#end_block

#method_before
public int getAudioState(BluetoothDevice device) {
    if (mService == null)
        return BluetoothHeadset.STATE_AUDIO_DISCONNECTED;
    return mService.getAudioState(device);
}
#method_after
public int getAudioState(BluetoothDevice device) {
    if (mService == null) {
        return BluetoothHeadset.STATE_AUDIO_DISCONNECTED;
    }
    return mService.getAudioState(device);
}
#end_block

#method_before
public boolean isPreferred(BluetoothDevice device) {
    if (mService == null)
        return false;
    return mService.getPriority(device) > BluetoothProfile.PRIORITY_OFF;
}
#method_after
public boolean isPreferred(BluetoothDevice device) {
    if (mService == null) {
        return false;
    }
    return mService.getPriority(device) > BluetoothProfile.PRIORITY_OFF;
}
#end_block

#method_before
public int getPreferred(BluetoothDevice device) {
    if (mService == null)
        return BluetoothProfile.PRIORITY_OFF;
    return mService.getPriority(device);
}
#method_after
public int getPreferred(BluetoothDevice device) {
    if (mService == null) {
        return BluetoothProfile.PRIORITY_OFF;
    }
    return mService.getPriority(device);
}
#end_block

#method_before
public void setPreferred(BluetoothDevice device, boolean preferred) {
    if (mService == null)
        return;
    if (preferred) {
        if (mService.getPriority(device) < BluetoothProfile.PRIORITY_ON) {
            mService.setPriority(device, BluetoothProfile.PRIORITY_ON);
        }
    } else {
        mService.setPriority(device, BluetoothProfile.PRIORITY_OFF);
    }
}
#method_after
public void setPreferred(BluetoothDevice device, boolean preferred) {
    if (mService == null) {
        return;
    }
    if (preferred) {
        if (mService.getPriority(device) < BluetoothProfile.PRIORITY_ON) {
            mService.setPriority(device, BluetoothProfile.PRIORITY_ON);
        }
    } else {
        mService.setPriority(device, BluetoothProfile.PRIORITY_OFF);
    }
}
#end_block

#method_before
public List<BluetoothDevice> getConnectedDevices() {
    if (mService == null)
        return new ArrayList<BluetoothDevice>(0);
    return mService.getDevicesMatchingConnectionStates(new int[] { BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_DISCONNECTING });
}
#method_after
public List<BluetoothDevice> getConnectedDevices() {
    if (mService == null) {
        return new ArrayList<BluetoothDevice>(0);
    }
    return mService.getDevicesMatchingConnectionStates(new int[] { BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_DISCONNECTING });
}
#end_block

#method_before
protected void finalize() {
    if (V)
        Log.d(TAG, "finalize()");
    if (mService != null) {
        try {
            BluetoothAdapter.getDefaultAdapter().closeProfileProxy(BluetoothProfile.HEADSET, mService);
            mService = null;
        } catch (Throwable t) {
            Log.w(TAG, "Error cleaning up HID proxy", t);
        }
    }
}
#method_after
protected void finalize() {
    Log.d(TAG, "finalize()");
    if (mService != null) {
        try {
            BluetoothAdapter.getDefaultAdapter().closeProfileProxy(BluetoothProfile.HEADSET, mService);
            mService = null;
        } catch (Throwable t) {
            Log.w(TAG, "Error cleaning up HID proxy", t);
        }
    }
}
#end_block

#method_before
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    // carrier config gets a priority over ERI
    updateOperatorNameFromCarrierConfig();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    int combinedRegState = getCombinedRegState();
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled() && (combinedRegState == ServiceState.STATE_IN_SERVICE)) {
        // In Wi-Fi Calling mode show SPN or PLMN + WiFi Calling
        // 
        // 1) Show SPN + Wi-Fi Calling If SIM has SPN and SPN display condition
        // is satisfied or SPN override is enabled for this carrier
        // 
        // 2) Show PLMN + Wi-Fi Calling if there is no valid SPN in case 1
        int voiceIdx = 0;
        int dataIdx = 0;
        boolean useRootLocale = false;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                    useRootLocale = b.getBoolean(CarrierConfigManager.KEY_WFC_SPN_USE_ROOT_LOCALE);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        String[] wfcSpnFormats = SubscriptionManager.getResourcesForSubId(mPhone.getContext(), mPhone.getSubId(), useRootLocale).getStringArray(com.android.internal.R.array.wfcSpnFormats);
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS) : 0;
        boolean noService = false;
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE || combinedRegState == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            // Force display no service
            final boolean forceDisplayNoService = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_display_no_service_when_sim_unready) && !mIsSimReady;
            if (mEmergencyOnly && !forceDisplayNoService) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
                noService = true;
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (combinedRegState == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !noService && !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // Show SPN + Wi-Fi Calling If SIM has SPN and SPN display condition
            // is satisfied or SPN override is enabled for this carrier.
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // Show PLMN + Wi-Fi Calling if there is no valid SPN in the above case
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = mPhone.getSubId();
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlpha contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = mPhone.getSubId();
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE) {
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG) {
                log("updateSpnDisplay: radio is on but out of svc, set plmn='" + plmn + "'");
            }
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#method_after
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    // carrier config gets a priority over ERI
    updateOperatorNameFromCarrierConfig();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    int combinedRegState = getCombinedRegState();
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled() && (combinedRegState == ServiceState.STATE_IN_SERVICE)) {
        // In Wi-Fi Calling mode show SPN or PLMN + WiFi Calling
        // 
        // 1) Show SPN + Wi-Fi Calling If SIM has SPN and SPN display condition
        // is satisfied or SPN override is enabled for this carrier
        // 
        // 2) Show PLMN + Wi-Fi Calling if there is no valid SPN in case 1
        int voiceIdx = 0;
        int dataIdx = 0;
        boolean useRootLocale = false;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                    useRootLocale = b.getBoolean(CarrierConfigManager.KEY_WFC_SPN_USE_ROOT_LOCALE);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        String[] wfcSpnFormats = SubscriptionManager.getResourcesForSubId(mPhone.getContext(), mPhone.getSubId(), useRootLocale).getStringArray(com.android.internal.R.array.wfcSpnFormats);
        if (voiceIdx < 0 || voiceIdx >= wfcSpnFormats.length) {
            loge("updateSpnDisplay: KEY_WFC_SPN_FORMAT_IDX_INT out of bounds: " + voiceIdx);
            voiceIdx = 0;
        }
        if (dataIdx < 0 || dataIdx >= wfcSpnFormats.length) {
            loge("updateSpnDisplay: KEY_WFC_DATA_SPN_FORMAT_IDX_INT out of bounds: " + dataIdx);
            dataIdx = 0;
        }
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS) : 0;
        boolean noService = false;
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE || combinedRegState == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            // Force display no service
            final boolean forceDisplayNoService = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_display_no_service_when_sim_unready) && !mIsSimReady;
            if (mEmergencyOnly && !forceDisplayNoService) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
                noService = true;
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (combinedRegState == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !noService && !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // Show SPN + Wi-Fi Calling If SIM has SPN and SPN display condition
            // is satisfied or SPN override is enabled for this carrier.
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // Show PLMN + Wi-Fi Calling if there is no valid SPN in the above case
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = mPhone.getSubId();
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlpha contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = mPhone.getSubId();
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE) {
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG) {
                log("updateSpnDisplay: radio is on but out of svc, set plmn='" + plmn + "'");
            }
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    findViewById(R.id.enqueue_infinite_work_charging).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            WorkManager.getInstance().enqueue(new OneTimeWorkRequest.Builder(InfiniteWorker.class).setConstraints(new Constraints.Builder().setRequiresCharging(true).build()).build());
        }
    });
    findViewById(R.id.enqueue_infinite_work_network).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            WorkManager.getInstance().enqueue(new OneTimeWorkRequest.Builder(InfiniteWorker.class).setConstraints(new Constraints.Builder().setRequiredNetworkType(NetworkType.CONNECTED).build()).build());
        }
    });
    findViewById(R.id.sherlock_holmes).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            startActivity(new Intent(MainActivity.this, AnalyzeSherlockHolmesActivity.class));
        }
    });
    findViewById(R.id.image_processing).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            startActivity(new Intent(MainActivity.this, ImageProcessingActivity.class));
        }
    });
    findViewById(R.id.image_uri).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (Build.VERSION.SDK_INT < 24) {
                return;
            }
            WorkManager.getInstance().enqueue(ToastWorker.create("Image URI Updated!").setConstraints(new Constraints.Builder().addContentUriTrigger(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, true).build()).build());
        }
    });
    final EditText delayInMs = findViewById(R.id.delay_in_ms);
    findViewById(R.id.schedule_delay).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            String delayString = delayInMs.getText().toString();
            long delay = Long.parseLong(delayString);
            Log.d(TAG, "Enqueuing job with delay of " + delay + " ms");
            WorkManager.getInstance().enqueue(ToastWorker.create("Delayed Job Ran!").setInitialDelay(delay, TimeUnit.MILLISECONDS).build());
        }
    });
    findViewById(R.id.enqueue_periodic_work).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            Data input = new Data.Builder().putString(ToastWorker.ARG_MESSAGE, "Periodic work").build();
            PeriodicWorkRequest request = new PeriodicWorkRequest.Builder(ToastWorker.class, 15, TimeUnit.MINUTES).setInputData(input).build();
            WorkManager.getInstance().enqueue(request);
        }
    });
    findViewById(R.id.begin_unique_work_loop).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            CheckBox keep = findViewById(R.id.keep);
            ExistingWorkPolicy policy = keep.isChecked() ? KEEP : REPLACE;
            for (int i = 0; i < 50; i += 1) {
                WorkManager.getInstance().beginUniqueWork(UNIQUE_WORK_NAME, policy, OneTimeWorkRequest.from(SleepWorker.class)).enqueue();
            }
        }
    });
    findViewById(R.id.enqueue_lots_of_work).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            for (int i = 0; i < NUM_WORKERS; i += 1) {
                // Exceed Scheduler.MAX_SCHEDULER_LIMIT (100)
                WorkManager.getInstance().beginWith(OneTimeWorkRequest.from(SleepWorker.class)).enqueue();
            }
        }
    });
    findViewById(R.id.exploding_work).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View view) {
            WorkManager wm = WorkManager.getInstance();
            List<WorkContinuation> leaves = new ArrayList<>();
            for (int i = 0; i < 10; ++i) {
                OneTimeWorkRequest workRequest = createTestWorker();
                WorkContinuation continuation = wm.beginWith(workRequest);
                for (int j = 0; j < 10; ++j) {
                    OneTimeWorkRequest primaryDependent = createTestWorker();
                    WorkContinuation primaryContinuation = continuation.then(primaryDependent);
                    for (int k = 0; k < 10; ++k) {
                        OneTimeWorkRequest secondaryDependent = createTestWorker();
                        leaves.add(primaryContinuation.then(secondaryDependent));
                    }
                }
            }
            WorkContinuation.combine(leaves).then(createTestWorker()).enqueue();
        }

        private OneTimeWorkRequest createTestWorker() {
            return new OneTimeWorkRequest.Builder(TestWorker.class).build();
        }
    });
    findViewById(R.id.replace_completed_work).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View view) {
            WorkManager workManager = WorkManager.getInstance();
            workManager.getStatusesForUniqueWork(REPLACE_COMPLETED_WORK).observe(MainActivity.this, new Observer<List<WorkStatus>>() {

                private int mCount;

                @Override
                public void onChanged(@Nullable List<WorkStatus> workStatuses) {
                    boolean isEmpty = workStatuses == null || workStatuses.isEmpty();
                    if (!isEmpty) {
                        WorkStatus status = workStatuses.get(0);
                        if (status.getState().isFinished()) {
                            if (mCount < NUM_WORKERS) {
                                // Enqueue another worker.
                                workManager.beginUniqueWork(REPLACE_COMPLETED_WORK, ExistingWorkPolicy.REPLACE, OneTimeWorkRequest.from(TestWorker.class)).enqueue();
                                mCount += 1;
                            }
                        }
                    }
                }
            });
            workManager.beginUniqueWork(REPLACE_COMPLETED_WORK, ExistingWorkPolicy.REPLACE, OneTimeWorkRequest.from(TestWorker.class)).enqueue();
        }
    });
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    findViewById(R.id.enqueue_infinite_work_charging).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            WorkManager.getInstance().enqueue(new OneTimeWorkRequest.Builder(InfiniteWorker.class).setConstraints(new Constraints.Builder().setRequiresCharging(true).build()).build());
        }
    });
    findViewById(R.id.enqueue_infinite_work_network).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            WorkManager.getInstance().enqueue(new OneTimeWorkRequest.Builder(InfiniteWorker.class).setConstraints(new Constraints.Builder().setRequiredNetworkType(NetworkType.CONNECTED).build()).build());
        }
    });
    findViewById(R.id.sherlock_holmes).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            startActivity(new Intent(MainActivity.this, AnalyzeSherlockHolmesActivity.class));
        }
    });
    findViewById(R.id.image_processing).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            startActivity(new Intent(MainActivity.this, ImageProcessingActivity.class));
        }
    });
    findViewById(R.id.image_uri).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (Build.VERSION.SDK_INT < 24) {
                return;
            }
            WorkManager.getInstance().enqueue(ToastWorker.create("Image URI Updated!").setConstraints(new Constraints.Builder().addContentUriTrigger(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, true).build()).build());
        }
    });
    final EditText delayInMs = findViewById(R.id.delay_in_ms);
    findViewById(R.id.schedule_delay).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            String delayString = delayInMs.getText().toString();
            long delay = Long.parseLong(delayString);
            Log.d(TAG, "Enqueuing job with delay of " + delay + " ms");
            WorkManager.getInstance().enqueue(ToastWorker.create("Delayed Job Ran!").setInitialDelay(delay, TimeUnit.MILLISECONDS).build());
        }
    });
    findViewById(R.id.enqueue_periodic_work).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            Data input = new Data.Builder().putString(ToastWorker.ARG_MESSAGE, "Periodic work").build();
            PeriodicWorkRequest request = new PeriodicWorkRequest.Builder(ToastWorker.class, 15, TimeUnit.MINUTES).setInputData(input).build();
            WorkManager.getInstance().enqueue(request);
        }
    });
    findViewById(R.id.begin_unique_work_loop).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            CheckBox keep = findViewById(R.id.keep);
            ExistingWorkPolicy policy = keep.isChecked() ? KEEP : REPLACE;
            for (int i = 0; i < 50; i += 1) {
                WorkManager.getInstance().beginUniqueWork(UNIQUE_WORK_NAME, policy, OneTimeWorkRequest.from(SleepWorker.class)).enqueue();
            }
        }
    });
    findViewById(R.id.enqueue_lots_of_work).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            for (int i = 0; i < NUM_WORKERS; i += 1) {
                // Exceed Scheduler.MAX_SCHEDULER_LIMIT (100)
                WorkManager.getInstance().beginWith(OneTimeWorkRequest.from(SleepWorker.class)).enqueue();
            }
        }
    });
    findViewById(R.id.exploding_work).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View view) {
            WorkManager wm = WorkManager.getInstance();
            List<WorkContinuation> leaves = new ArrayList<>();
            for (int i = 0; i < 10; ++i) {
                OneTimeWorkRequest workRequest = createTestWorker();
                WorkContinuation continuation = wm.beginWith(workRequest);
                for (int j = 0; j < 10; ++j) {
                    OneTimeWorkRequest primaryDependent = createTestWorker();
                    WorkContinuation primaryContinuation = continuation.then(primaryDependent);
                    for (int k = 0; k < 10; ++k) {
                        OneTimeWorkRequest secondaryDependent = createTestWorker();
                        leaves.add(primaryContinuation.then(secondaryDependent));
                    }
                }
            }
            WorkContinuation.combine(leaves).then(createTestWorker()).enqueue();
        }

        private OneTimeWorkRequest createTestWorker() {
            return new OneTimeWorkRequest.Builder(TestWorker.class).build();
        }
    });
    findViewById(R.id.replace_completed_work).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View view) {
            WorkManager workManager = WorkManager.getInstance();
            workManager.getStatusesForUniqueWork(REPLACE_COMPLETED_WORK).observe(MainActivity.this, new Observer<List<WorkStatus>>() {

                private int mCount;

                @Override
                public void onChanged(@Nullable List<WorkStatus> workStatuses) {
                    if (workStatuses == null) {
                        return;
                    }
                    if (!workStatuses.isEmpty()) {
                        WorkStatus status = workStatuses.get(0);
                        if (status.getState().isFinished()) {
                            if (mCount < NUM_WORKERS) {
                                // Enqueue another worker.
                                workManager.beginUniqueWork(REPLACE_COMPLETED_WORK, ExistingWorkPolicy.REPLACE, OneTimeWorkRequest.from(TestWorker.class)).enqueue();
                                mCount += 1;
                            }
                        }
                    }
                }
            });
            workManager.beginUniqueWork(REPLACE_COMPLETED_WORK, ExistingWorkPolicy.REPLACE, OneTimeWorkRequest.from(TestWorker.class)).enqueue();
        }
    });
}
#end_block

#method_before
void onWorkFinished(@NonNull Result result) {
    assertBackgroundExecutorThread();
    boolean isWorkFinished = false;
    if (!tryCheckForInterruptionAndNotify()) {
        try {
            mWorkDatabase.beginTransaction();
            State state = mWorkSpecDao.getState(mWorkSpecId);
            if (state == null) {
                // state can be null here with a REPLACE on beginUniqueWork().
                // Treat it as a failure, and rescheduleAndNotify() will
                // turn into a no-op. We still need to notify potential observers
                // holding on to wake locks on our behalf.
                notifyListener(false);
            } else if (state == RUNNING) {
                handleResult(result);
                // Update state after a call to handleResult()
                state = mWorkSpecDao.getState(mWorkSpecId);
                isWorkFinished = state.isFinished();
            } else if (!state.isFinished()) {
                rescheduleAndNotify();
            }
            mWorkDatabase.setTransactionSuccessful();
        } finally {
            mWorkDatabase.endTransaction();
        }
    }
    // that it should remove this job and AlarmManager should remove all related alarms.
    if (isWorkFinished) {
        for (Scheduler scheduler : mSchedulers) {
            scheduler.cancel(mWorkSpecId);
        }
    }
    Schedulers.schedule(mConfiguration, mWorkDatabase, mSchedulers);
}
#method_after
void onWorkFinished(@NonNull Result result) {
    assertBackgroundExecutorThread();
    boolean isWorkFinished = false;
    if (!tryCheckForInterruptionAndNotify()) {
        try {
            mWorkDatabase.beginTransaction();
            State state = mWorkSpecDao.getState(mWorkSpecId);
            if (state == null) {
                // state can be null here with a REPLACE on beginUniqueWork().
                // Treat it as a failure, and rescheduleAndNotify() will
                // turn into a no-op. We still need to notify potential observers
                // holding on to wake locks on our behalf.
                notifyListener(false);
            } else if (state == RUNNING) {
                handleResult(result);
            } else if (!state.isFinished()) {
                rescheduleAndNotify();
            }
            // Update state after a call to handleResult()
            state = mWorkSpecDao.getState(mWorkSpecId);
            isWorkFinished = state.isFinished();
            mWorkDatabase.setTransactionSuccessful();
        } finally {
            mWorkDatabase.endTransaction();
        }
    }
    // that it should remove this job and AlarmManager should remove all related alarms.
    if (isWorkFinished) {
        for (Scheduler scheduler : mSchedulers) {
            scheduler.cancel(mWorkSpecId);
        }
    }
    Schedulers.schedule(mConfiguration, mWorkDatabase, mSchedulers);
}
#end_block

#method_before
@Override
public void onCreate() {
    super.onCreate();
    registerReceiver(mBondStatusReceiver, new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED));
    mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
    mBluetoothAdapter = mBluetoothManager.getAdapter();
    mScanner = mBluetoothAdapter.getBluetoothLeScanner();
    mHandler = new Handler();
    mContext = this;
    mTaskQueue = new TestTaskQueue(getClass().getName() + "_taskHandlerThread");
}
#method_after
@Override
public void onCreate() {
    super.onCreate();
    registerReceiver(mBondStatusReceiver, new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED));
    mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
    mBluetoothAdapter = mBluetoothManager.getAdapter();
    mScanner = mBluetoothAdapter.getBluetoothLeScanner();
    mHandler = new Handler();
    mTaskQueue = new TestTaskQueue(getClass().getName() + "_taskHandlerThread");
}
#end_block

#method_before
@Override
public int onStartCommand(final Intent intent, int flags, int startId) {
    if (!mBluetoothAdapter.isEnabled()) {
        notifyBluetoothDisabled();
    } else {
        mTaskQueue.addTask(new Runnable() {

            @Override
            public void run() {
                onTestFinish(intent.getAction());
            }
        }, 1500);
    }
    return START_NOT_STICKY;
}
#method_after
@Override
public int onStartCommand(final Intent intent, int flags, int startId) {
    if (!mBluetoothAdapter.isEnabled()) {
        notifyBluetoothDisabled();
    } else {
        mTaskQueue.addTask(new Runnable() {

            @Override
            public void run() {
                onTestFinish(intent.getAction());
            }
        }, EXECUTION_DELAY);
    }
    return START_NOT_STICKY;
}
#end_block

#method_before
private void notifyError(String message) {
    showMessage(message);
    Log.i(TAG, message);
    Intent intent = new Intent(BLE_CLIENT_ERROR);
    sendBroadcast(intent);
}
#method_after
private void notifyError(String message) {
    showMessage(message);
    Log.e(TAG, message);
    Intent intent = new Intent(BLE_CLIENT_ERROR);
    sendBroadcast(intent);
}
#end_block

#method_before
private void notifyServicesDiscovered() {
    showMessage("Service discovered");
    // Find the LE_COC_PSM characteristics
    if (DEBUG) {
        Log.d(TAG, "notifyServicesDiscovered: Reading the PSM char. next");
    }
    readCharacteristic(LE_PSM_CHARACTERISTIC_UUID);
}
#method_after
private void notifyServicesDiscovered() {
    showMessage("Service discovered");
    // Find the LE_COC_PSM characteristics
    if (DEBUG) {
        Log.d(TAG, "notifyServicesDiscovered: Next step is to read the PSM char.");
    }
    readCharacteristic(LE_PSM_CHARACTERISTIC_UUID);
}
#end_block

#method_before
private BluetoothGattService getService() {
    BluetoothGattService service = null;
    if (mBluetoothGatt != null) {
        service = mBluetoothGatt.getService(SERVICE_UUID);
        if (service == null) {
            showMessage("Service not found");
        }
    }
    return service;
}
#method_after
private BluetoothGattService getService() {
    BluetoothGattService service = null;
    if (mBluetoothGatt != null) {
        service = mBluetoothGatt.getService(SERVICE_UUID);
        if (service == null) {
            showMessage("GATT Service not found");
        }
    }
    return service;
}
#end_block

#method_before
private void handleMessageRead(Message msg) {
    byte[] buf = (byte[]) msg.obj;
    int len = msg.arg1;
    if (len <= 0) {
        return;
    }
    mTotalReadLen += len;
    if (DEBUG) {
        Log.d(TAG, "handleMessageRead: receive buffer of length=" + len + ", mTotalReadLen=" + mTotalReadLen + ", mNextReadExpectedLen=" + mNextReadExpectedLen);
    }
    if (mNextReadExpectedLen == mTotalReadLen) {
        if (!checkReadBufContents(len, buf)) {
            mNextReadExpectedLen = -1;
            return;
        }
        showMessage("Read " + len + "bytes");
        if (DEBUG) {
            Log.d(TAG, "handleMessageRead: broadcast intent " + mNextReadCompletionIntent);
        }
        Intent intent = new Intent(mNextReadCompletionIntent);
        sendBroadcast(intent);
        mNextReadExpectedLen = -1;
        mNextReadCompletionIntent = null;
        mTotalReadLen = 0;
    } else if (mNextReadExpectedLen > mTotalReadLen) {
        if (!checkReadBufContents(len, buf)) {
            mNextReadExpectedLen = -1;
            return;
        }
    } else if (mNextReadExpectedLen < mTotalReadLen) {
        Log.e(TAG, "handleMessageRead: Unexpected receive buffer of length=" + len + ", expected len=" + mNextReadExpectedLen);
    }
}
#method_after
private void handleMessageRead(Message msg) {
    byte[] buf = (byte[]) msg.obj;
    int len = msg.arg1;
    if (len <= 0) {
        return;
    }
    mTotalReadLen += len;
    if (DEBUG) {
        Log.d(TAG, "handleMessageRead: receive buffer of length=" + len + ", mTotalReadLen=" + mTotalReadLen + ", mNextReadExpectedLen=" + mNextReadExpectedLen);
    }
    if (mNextReadExpectedLen == mTotalReadLen) {
        if (!checkReadBufContent(buf, len)) {
            mNextReadExpectedLen = -1;
            return;
        }
        showMessage("Read " + len + " bytes");
        if (DEBUG) {
            Log.d(TAG, "handleMessageRead: broadcast intent " + mNextReadCompletionIntent);
        }
        Intent intent = new Intent(mNextReadCompletionIntent);
        sendBroadcast(intent);
        mNextReadExpectedLen = -1;
        mNextReadCompletionIntent = null;
        mTotalReadLen = 0;
    } else if (mNextReadExpectedLen > mTotalReadLen) {
        if (!checkReadBufContent(buf, len)) {
            mNextReadExpectedLen = -1;
            return;
        }
    } else if (mNextReadExpectedLen < mTotalReadLen) {
        Log.e(TAG, "handleMessageRead: Unexpected receive buffer of length=" + len + ", expected len=" + mNextReadExpectedLen);
    }
}
#end_block

#method_before
public synchronized void connect(BluetoothDevice device, boolean secure) {
    if (!mBle) {
        connect(device, secure, 0);
    } else {
        Log.e(TAG, "connect: Error: LE cannot call this method!");
    }
}
#method_after
public synchronized void connect(BluetoothDevice device, boolean secure) {
    if (!mBleTransport) {
        connect(device, secure, 0);
    } else {
        Log.e(TAG, "connect: Error: LE cannot call this method!");
    }
}
#end_block

#method_before
public synchronized void connect(BluetoothDevice device, boolean secure, int psm) {
    if (D)
        Log.d(TAG, "connect to: " + device + ", psm: " + psm + ", ble: " + mBle);
    // Cancel any thread attempting to make a connection
    if (mState == STATE_CONNECTING) {
        if (mConnectThread != null) {
            mConnectThread.cancel();
            mConnectThread = null;
        }
    }
    // Cancel any thread currently running a connection
    if (mConnectedThread != null) {
        mConnectedThread.cancel();
        mConnectedThread = null;
    }
    // Start the thread to connect with the given device
    mConnectThread = new ConnectThread(device, secure, psm);
    mConnectThread.start();
    setState(STATE_CONNECTING);
}
#method_after
public synchronized void connect(BluetoothDevice device, boolean secure, int psm) {
    if (D)
        Log.d(TAG, "connect to: " + device + ", psm: " + psm + ", ble: " + mBleTransport);
    // Cancel any thread attempting to make a connection
    if (mState == STATE_CONNECTING) {
        if (mConnectThread != null) {
            mConnectThread.cancel();
            mConnectThread = null;
        }
    }
    // Cancel any thread currently running a connection
    if (mConnectedThread != null) {
        mConnectedThread.cancel();
        mConnectedThread = null;
    }
    // Start the thread to connect with the given device
    mConnectThread = new ConnectThread(device, secure, psm);
    mConnectThread.start();
    setState(STATE_CONNECTING);
}
#end_block

#method_before
private BluetoothSocket connectThreadCommon(BluetoothDevice device, boolean secure, int psm) {
    BluetoothSocket tmp = null;
    mSocketType = secure ? "Secure" : "Insecure";
    // given BluetoothDevice
    try {
        if (mBle) {
            if (secure) {
                tmp = device.createL2capCocSocket(BluetoothDevice.TRANSPORT_LE, psm);
            } else {
                tmp = device.createInsecureL2capCocSocket(BluetoothDevice.TRANSPORT_LE, psm);
            }
        } else {
            if (secure) {
                tmp = device.createRfcommSocketToServiceRecord(mUuid);
            } else {
                tmp = device.createInsecureRfcommSocketToServiceRecord(mUuid);
            }
        }
    } catch (IOException e) {
        Log.e(TAG, "Socket Type: " + mSocketType + "create() failed", e);
    }
    mSocketConnectionType = tmp.getConnectionType();
    return tmp;
}
#method_after
private BluetoothSocket connectThreadCommon(BluetoothDevice device, boolean secure, int psm) {
    BluetoothSocket tmp = null;
    mSocketType = secure ? "Secure" : "Insecure";
    // given BluetoothDevice
    try {
        if (mBleTransport) {
            if (secure) {
                tmp = device.createL2capChannel(psm);
            } else {
                tmp = device.createInsecureL2capChannel(psm);
            }
        } else {
            if (secure) {
                tmp = device.createRfcommSocketToServiceRecord(mUuid);
            } else {
                tmp = device.createInsecureRfcommSocketToServiceRecord(mUuid);
            }
        }
    } catch (IOException e) {
        Log.e(TAG, "Socket Type: " + mSocketType + "create() failed", e);
    }
    mSocketConnectionType = tmp.getConnectionType();
    return tmp;
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.pass_fail_list);
    setPassFailButtonClickListeners();
    setInfoResources(R.string.ble_coc_secure_client_test_list_name, R.string.ble_coc_secure_client_test_list_info, -1);
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    List<String> disabledTest = new ArrayList<String>();
    // TODO: Any need to remove certain test based on supported features?
    setTestListAdapter(new ManifestTestListAdapter(this, getClass().getName(), disabledTest.toArray(new String[disabledTest.size()])));
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.pass_fail_list);
    setPassFailButtonClickListeners();
    setInfoResources(R.string.ble_coc_secure_client_test_list_name, R.string.ble_coc_secure_client_test_list_info, -1);
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    List<String> disabledTest = new ArrayList<String>();
    setTestListAdapter(new ManifestTestListAdapter(this, getClass().getName(), disabledTest.toArray(new String[disabledTest.size()])));
}
#end_block

#method_before
@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    String action = intent.getAction();
    if (action != null) {
        if (DEBUG) {
            Log.d(TAG, "onStartCommand: action=" + action);
        }
        mTaskQueue.addTask(new Runnable() {

            @Override
            public void run() {
                onTestFinish(intent.getAction());
            }
        }, 1500);
    }
    return START_NOT_STICKY;
}
#method_after
@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    String action = intent.getAction();
    if (action != null) {
        if (DEBUG) {
            Log.d(TAG, "onStartCommand: action=" + action);
        }
        mTaskQueue.addTask(new Runnable() {

            @Override
            public void run() {
                onTestFinish(intent.getAction());
            }
        }, EXECUTION_DELAY);
    }
    return START_NOT_STICKY;
}
#end_block

#method_before
private void leCheckConnectionType() {
    if (mChatService == null) {
        Log.e(TAG, "leCheckConnectionType: no LE Coc connection");
        return;
    }
    int type = mChatService.getSocketConnectionType();
    if (type != BluetoothSocket.TYPE_L2CAP) {
        Log.e(TAG, "leCheckConnectionType: invalid connection type=" + type);
        return;
    }
    showMessage("LE Coc Connection Type Checked");
    Intent intent = new Intent(BLE_CONNECTION_TYPE_CHECKED);
    sendBroadcast(intent);
}
#method_after
private void leCheckConnectionType() {
    if (mChatService == null) {
        Log.e(TAG, "leCheckConnectionType: no LE Coc connection");
        return;
    }
    int type = mChatService.getSocketConnectionType();
    if (type != BluetoothSocket.TYPE_L2CAP) {
        Log.e(TAG, "leCheckConnectionType: invalid connection type=" + type);
        return;
    }
    showMessage("LE CoC Connection Type Checked");
    Intent intent = new Intent(BLE_CONNECTION_TYPE_CHECKED);
    sendBroadcast(intent);
}
#end_block

#method_before
private void handleMessageRead(Message msg) {
    byte[] buf = (byte[]) msg.obj;
    int len = msg.arg1;
    if (len <= 0) {
        return;
    }
    mTotalReadLen += len;
    if (DEBUG) {
        Log.d(TAG, "handleMessageRead: receive buffer of length=" + len + ", mTotalReadLen=" + mTotalReadLen + ", mNextReadExpectedLen=" + mNextReadExpectedLen);
    }
    if (mNextReadExpectedLen == mTotalReadLen) {
        if (!checkReadBufContents(len, buf)) {
            mNextReadExpectedLen = -1;
            return;
        }
        showMessage("Read " + len + "bytes");
        if (DEBUG) {
            Log.d(TAG, "handleMessageRead: broadcast intent " + mNextReadCompletionIntent);
        }
        Intent intent = new Intent(mNextReadCompletionIntent);
        sendBroadcast(intent);
        mNextReadExpectedLen = -1;
        mNextReadCompletionIntent = null;
        mTotalReadLen = 0;
    } else if (mNextReadExpectedLen > mTotalReadLen) {
        if (!checkReadBufContents(len, buf)) {
            mNextReadExpectedLen = -1;
            return;
        }
    } else if (mNextReadExpectedLen < mTotalReadLen) {
        Log.e(TAG, "handleMessageRead: Unexpected receive buffer of length=" + len + ", expected len=" + mNextReadExpectedLen);
    }
}
#method_after
private void handleMessageRead(Message msg) {
    byte[] buf = (byte[]) msg.obj;
    int len = msg.arg1;
    if (len <= 0) {
        return;
    }
    mTotalReadLen += len;
    if (DEBUG) {
        Log.d(TAG, "handleMessageRead: receive buffer of length=" + len + ", mTotalReadLen=" + mTotalReadLen + ", mNextReadExpectedLen=" + mNextReadExpectedLen);
    }
    if (mNextReadExpectedLen == mTotalReadLen) {
        if (!checkReadBufContent(buf, len)) {
            mNextReadExpectedLen = -1;
            return;
        }
        showMessage("Read " + len + " bytes");
        if (DEBUG) {
            Log.d(TAG, "handleMessageRead: broadcast intent " + mNextReadCompletionIntent);
        }
        Intent intent = new Intent(mNextReadCompletionIntent);
        sendBroadcast(intent);
        mNextReadExpectedLen = -1;
        mNextReadCompletionIntent = null;
        mTotalReadLen = 0;
    } else if (mNextReadExpectedLen > mTotalReadLen) {
        if (!checkReadBufContent(buf, len)) {
            mNextReadExpectedLen = -1;
            return;
        }
    } else if (mNextReadExpectedLen < mTotalReadLen) {
        Log.e(TAG, "handleMessageRead: Unexpected receive buffer of length=" + len + ", expected len=" + mNextReadExpectedLen);
    }
}
#end_block

#method_before
private void handleMessageWrite(Message msg) {
    byte[] buffer = (byte[]) msg.obj;
    int len = buffer.length;
    showMessage("LE Coc Server wrote " + len + " bytes" + ", mNextWriteExpectedLen=" + mNextWriteExpectedLen);
    if (len == mNextWriteExpectedLen) {
        if (mNextWriteCompletionIntent != null) {
            Intent intent = new Intent(mNextWriteCompletionIntent);
            sendBroadcast(intent);
        }
    } else {
        Log.d(TAG, "handleMessageWrite: unrecognized length=" + len);
    }
    mNextWriteCompletionIntent = null;
    mNextWriteExpectedLen = -1;
}
#method_after
private void handleMessageWrite(Message msg) {
    byte[] buffer = (byte[]) msg.obj;
    int len = buffer.length;
    showMessage("LE CoC Server wrote " + len + " bytes" + ", mNextWriteExpectedLen=" + mNextWriteExpectedLen);
    if (len == mNextWriteExpectedLen) {
        if (mNextWriteCompletionIntent != null) {
            Intent intent = new Intent(mNextWriteCompletionIntent);
            sendBroadcast(intent);
        }
    } else {
        Log.d(TAG, "handleMessageWrite: unrecognized length=" + len);
    }
    mNextWriteCompletionIntent = null;
    mNextWriteExpectedLen = -1;
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.pass_fail_list);
    setPassFailButtonClickListeners();
    setInfoResources(R.string.ble_coc_insecure_client_test_list_name, R.string.ble_coc_insecure_client_test_list_info, -1);
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    List<String> disabledTest = new ArrayList<String>();
    // TODO: Any need to remove certain test based on supported features?
    setTestListAdapter(new ManifestTestListAdapter(this, getClass().getName(), disabledTest.toArray(new String[disabledTest.size()])));
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.pass_fail_list);
    setPassFailButtonClickListeners();
    setInfoResources(R.string.ble_coc_insecure_client_test_list_name, R.string.ble_coc_insecure_client_test_list_info, -1);
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    List<String> disabledTest = new ArrayList<String>();
    setTestListAdapter(new ManifestTestListAdapter(this, getClass().getName(), disabledTest.toArray(new String[disabledTest.size()])));
}
#end_block

#method_before
public BluetoothLeAdvertiser getBluetoothLeAdvertiser() {
    if (!getLeAccess()) {
        return null;
    }
    if (!isMultipleAdvertisementSupported()) {
        Log.e(TAG, "Bluetooth LE advertising not supported");
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}
#method_after
public BluetoothLeAdvertiser getBluetoothLeAdvertiser() {
    if (!getLeAccess()) {
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
@AdapterState
public int getLeState() {
    int state = BluetoothAdapter.STATE_OFF;
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            state = mService.getState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    if (VDBG) {
        Log.d(TAG, "getLeState() returning " + BluetoothAdapter.nameForState(state));
    }
    return state;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
@AdapterState
@UnsupportedAppUsage
public int getLeState() {
    int state = BluetoothAdapter.STATE_OFF;
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            state = mService.getState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    if (VDBG) {
        Log.d(TAG, "getLeState() returning " + BluetoothAdapter.nameForState(state));
    }
    return state;
}
#end_block

#method_before
public boolean disable(boolean persist) {
    try {
        return mManagerService.disable(ActivityThread.currentPackageName(), persist);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@UnsupportedAppUsage
public boolean disable(boolean persist) {
    try {
        return mManagerService.disable(ActivityThread.currentPackageName(), persist);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#end_block

#method_before
public boolean factoryReset() {
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.factoryReset();
        }
        SystemProperties.set("persist.bluetooth.factoryreset", "true");
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
@UnsupportedAppUsage
public boolean factoryReset() {
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.factoryReset();
        }
        SystemProperties.set("persist.bluetooth.factoryreset", "true");
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public ParcelUuid[] getUuids() {
    if (getState() != STATE_ON) {
        return null;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getUuids();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return null;
}
#method_after
@UnsupportedAppUsage
public ParcelUuid[] getUuids() {
    if (getState() != STATE_ON) {
        return null;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getUuids();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return null;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public int getIoCapability() {
    if (getState() != STATE_ON)
        return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getIoCapability();
    } catch (RemoteException e) {
        Log.e(TAG, e.getMessage(), e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
@IoCapability
public int getIoCapability() {
    if (getState() != STATE_ON)
        return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getIoCapability();
    } catch (RemoteException e) {
        Log.e(TAG, e.getMessage(), e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH_PRIVILEGED)
public boolean setIoCapability(int capability) {
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.setIoCapability(capability);
    } catch (RemoteException e) {
        Log.e(TAG, e.getMessage(), e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH_PRIVILEGED)
public boolean setIoCapability(@IoCapability int capability) {
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.setIoCapability(capability);
    } catch (RemoteException e) {
        Log.e(TAG, e.getMessage(), e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public int getLeIoCapability() {
    if (getState() != STATE_ON)
        return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getLeIoCapability();
    } catch (RemoteException e) {
        Log.e(TAG, e.getMessage(), e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
@IoCapability
public int getLeIoCapability() {
    if (getState() != STATE_ON)
        return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getLeIoCapability();
    } catch (RemoteException e) {
        Log.e(TAG, e.getMessage(), e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return BluetoothAdapter.IO_CAPABILITY_UNKNOWN;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH_PRIVILEGED)
public boolean setLeIoCapability(int capability) {
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.setLeIoCapability(capability);
    } catch (RemoteException e) {
        Log.e(TAG, e.getMessage(), e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH_PRIVILEGED)
public boolean setLeIoCapability(@IoCapability int capability) {
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.setLeIoCapability(capability);
    } catch (RemoteException e) {
        Log.e(TAG, e.getMessage(), e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public boolean setScanMode(@ScanMode int mode, int duration) {
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.setScanMode(mode, duration);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#method_after
@UnsupportedAppUsage
public boolean setScanMode(@ScanMode int mode, int duration) {
    if (getState() != STATE_ON) {
        return false;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.setScanMode(mode, duration);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
#end_block

#method_before
public boolean setScanMode(int mode) {
    if (getState() != STATE_ON) {
        return false;
    }
    /* getDiscoverableTimeout() to use the latest from NV than use 0 */
    return setScanMode(mode, getDiscoverableTimeout());
}
#method_after
@UnsupportedAppUsage
public boolean setScanMode(int mode) {
    if (getState() != STATE_ON) {
        return false;
    }
    /* getDiscoverableTimeout() to use the latest from NV than use 0 */
    return setScanMode(mode, getDiscoverableTimeout());
}
#end_block

#method_before
public int getDiscoverableTimeout() {
    if (getState() != STATE_ON) {
        return -1;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getDiscoverableTimeout();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return -1;
}
#method_after
@UnsupportedAppUsage
public int getDiscoverableTimeout() {
    if (getState() != STATE_ON) {
        return -1;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getDiscoverableTimeout();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return -1;
}
#end_block

#method_before
public void setDiscoverableTimeout(int timeout) {
    if (getState() != STATE_ON) {
        return;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            mService.setDiscoverableTimeout(timeout);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
}
#method_after
@UnsupportedAppUsage
public void setDiscoverableTimeout(int timeout) {
    if (getState() != STATE_ON) {
        return;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            mService.setDiscoverableTimeout(timeout);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
}
#end_block

#method_before
public int getConnectionState() {
    if (getState() != STATE_ON) {
        return BluetoothAdapter.STATE_DISCONNECTED;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getAdapterConnectionState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "getConnectionState:", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return BluetoothAdapter.STATE_DISCONNECTED;
}
#method_after
@UnsupportedAppUsage
public int getConnectionState() {
    if (getState() != STATE_ON) {
        return BluetoothAdapter.STATE_DISCONNECTED;
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.getAdapterConnectionState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "getConnectionState:", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return BluetoothAdapter.STATE_DISCONNECTED;
}
#end_block

#method_before
public BluetoothServerSocket listenUsingRfcommOn(int channel, boolean mitm, boolean min16DigitPin) throws IOException {
    BluetoothServerSocket socket = new BluetoothServerSocket(BluetoothSocket.TYPE_RFCOMM, true, true, channel, mitm, min16DigitPin);
    int errno = socket.mSocket.bindListen();
    if (channel == SOCKET_CHANNEL_AUTO_STATIC_NO_SDP) {
        socket.setChannel(socket.mSocket.getPort());
    }
    if (errno != 0) {
        // socket.mSocket.throwErrnoNative(errno);
        throw new IOException("Error: " + errno);
    }
    return socket;
}
#method_after
@UnsupportedAppUsage
public BluetoothServerSocket listenUsingRfcommOn(int channel, boolean mitm, boolean min16DigitPin) throws IOException {
    BluetoothServerSocket socket = new BluetoothServerSocket(BluetoothSocket.TYPE_RFCOMM, true, true, channel, mitm, min16DigitPin);
    int errno = socket.mSocket.bindListen();
    if (channel == SOCKET_CHANNEL_AUTO_STATIC_NO_SDP) {
        socket.setChannel(socket.mSocket.getPort());
    }
    if (errno != 0) {
        // socket.mSocket.throwErrnoNative(errno);
        throw new IOException("Error: " + errno);
    }
    return socket;
}
#end_block

#method_before
public BluetoothServerSocket listenUsingEncryptedRfcommWithServiceRecord(String name, UUID uuid) throws IOException {
    return createNewRfcommSocketAndRecord(name, uuid, false, true);
}
#method_after
@UnsupportedAppUsage
public BluetoothServerSocket listenUsingEncryptedRfcommWithServiceRecord(String name, UUID uuid) throws IOException {
    return createNewRfcommSocketAndRecord(name, uuid, false, true);
}
#end_block

#method_before
IBluetoothManager getBluetoothManager() {
    return mManagerService;
}
#method_after
@UnsupportedAppUsage
/*package*/
IBluetoothManager getBluetoothManager() {
    return mManagerService;
}
#end_block

#method_before
IBluetooth getBluetoothService(IBluetoothManagerCallback cb) {
    synchronized (mProxyServiceStateCallbacks) {
        if (cb == null) {
            Log.w(TAG, "getBluetoothService() called with no BluetoothManagerCallback");
        } else if (!mProxyServiceStateCallbacks.contains(cb)) {
            mProxyServiceStateCallbacks.add(cb);
        }
    }
    return mService;
}
#method_after
@UnsupportedAppUsage
/*package*/
IBluetooth getBluetoothService(IBluetoothManagerCallback cb) {
    synchronized (mProxyServiceStateCallbacks) {
        if (cb == null) {
            Log.w(TAG, "getBluetoothService() called with no BluetoothManagerCallback");
        } else if (!mProxyServiceStateCallbacks.contains(cb)) {
            mProxyServiceStateCallbacks.add(cb);
        }
    }
    return mService;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
public BluetoothServerSocket listenUsingL2capCoc(int transport) throws IOException {
    if (transport != BluetoothDevice.TRANSPORT_LE) {
        throw new IllegalArgumentException("Unsupported transport: " + transport);
    }
    BluetoothServerSocket socket = new BluetoothServerSocket(BluetoothSocket.TYPE_L2CAP_LE, true, true, SOCKET_CHANNEL_AUTO_STATIC_NO_SDP, false, false);
    int errno = socket.mSocket.bindListen();
    if (errno != 0) {
        throw new IOException("Error: " + errno);
    }
    int assignedPsm = socket.mSocket.getPort();
    if (assignedPsm == 0) {
        throw new IOException("Error: Unable to assign PSM value");
    }
    if (DBG) {
        Log.d(TAG, "listenUsingL2capCoc: set assigned PSM to " + assignedPsm);
    }
    socket.setChannel(assignedPsm);
    return socket;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
public BluetoothServerSocket listenUsingL2capCoc(int transport) throws IOException {
    Log.e(TAG, "listenUsingL2capCoc: PLEASE USE THE OFFICIAL API, listenUsingL2capChannel");
    return listenUsingL2capChannel();
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
public BluetoothServerSocket listenUsingInsecureL2capCoc(int transport) throws IOException {
    if (transport != BluetoothDevice.TRANSPORT_LE) {
        throw new IllegalArgumentException("Unsupported transport: " + transport);
    }
    BluetoothServerSocket socket = new BluetoothServerSocket(BluetoothSocket.TYPE_L2CAP_LE, false, false, SOCKET_CHANNEL_AUTO_STATIC_NO_SDP, false, false);
    int errno = socket.mSocket.bindListen();
    if (errno != 0) {
        throw new IOException("Error: " + errno);
    }
    int assignedPsm = socket.mSocket.getPort();
    if (assignedPsm == 0) {
        throw new IOException("Error: Unable to assign PSM value");
    }
    if (DBG) {
        Log.d(TAG, "listenUsingInsecureL2capOn: set assigned PSM to " + assignedPsm);
    }
    socket.setChannel(assignedPsm);
    return socket;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
public BluetoothServerSocket listenUsingInsecureL2capCoc(int transport) throws IOException {
    Log.e(TAG, "listenUsingInsecureL2capCoc: PLEASE USE THE OFFICIAL API, " + "listenUsingInsecureL2capChannel");
    return listenUsingInsecureL2capChannel();
}
#end_block

#method_before
/**
 * Wait until the data in sending queue is emptied. A polling version
 * for flush implementation. Used to ensure the writing data afterwards will
 * be packed in new RFCOMM frame.
 *
 * @throws IOException if an i/o error occurs.
 */
void flush() throws IOException {
    if (mSocketOS == null)
        throw new IOException("flush is called on null OutputStream");
    if (VDBG)
        Log.d(TAG, "flush: " + mSocketOS);
    mSocketOS.flush();
}
#method_after
@UnsupportedAppUsage
/*package*/
void flush() throws IOException {
    if (mSocketOS == null)
        throw new IOException("flush is called on null OutputStream");
    if (VDBG)
        Log.d(TAG, "flush: " + mSocketOS);
    mSocketOS.flush();
}
#end_block

#method_before
public int getConnectionType() {
    return mType;
}
#method_after
public int getConnectionType() {
    if (mType == TYPE_L2CAP_LE) {
        // Treat the LE CoC to be the same type as L2CAP.
        return TYPE_L2CAP;
    }
    return mType;
}
#end_block

#method_before
static IBluetooth getService() {
    synchronized (BluetoothDevice.class) {
        if (sService == null) {
            BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
            sService = adapter.getBluetoothService(sStateChangeCallback);
        }
    }
    return sService;
}
#method_after
@UnsupportedAppUsage
static IBluetooth getService() {
    synchronized (BluetoothDevice.class) {
        if (sService == null) {
            BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
            sService = adapter.getBluetoothService(sStateChangeCallback);
        }
    }
    return sService;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
public String getName() {
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get Remote Device name");
        return null;
    }
    try {
        return service.getRemoteName(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
public String getName() {
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get Remote Device name");
        return null;
    }
    try {
        String name = service.getRemoteName(this);
        if (name != null) {
            return name.replaceAll("[\\t\\n\\r]+", " ");
        }
        return null;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
#end_block

#method_before
public String getAlias() {
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get Remote Device Alias");
        return null;
    }
    try {
        return service.getRemoteAlias(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
#method_after
@UnsupportedAppUsage
public String getAlias() {
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get Remote Device Alias");
        return null;
    }
    try {
        return service.getRemoteAlias(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
#end_block

#method_before
public boolean setAlias(String alias) {
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot set Remote Device name");
        return false;
    }
    try {
        return service.setRemoteAlias(this, alias);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@UnsupportedAppUsage
public boolean setAlias(String alias) {
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot set Remote Device name");
        return false;
    }
    try {
        return service.setRemoteAlias(this, alias);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#end_block

#method_before
public String getAliasName() {
    String name = getAlias();
    if (name == null) {
        name = getName();
    }
    return name;
}
#method_after
@UnsupportedAppUsage
public String getAliasName() {
    String name = getAlias();
    if (name == null) {
        name = getName();
    }
    return name;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
public int getBatteryLevel() {
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "Bluetooth disabled. Cannot get remote device battery level");
        return BATTERY_LEVEL_UNKNOWN;
    }
    try {
        return service.getBatteryLevel(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return BATTERY_LEVEL_UNKNOWN;
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
@UnsupportedAppUsage
public int getBatteryLevel() {
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "Bluetooth disabled. Cannot get remote device battery level");
        return BATTERY_LEVEL_UNKNOWN;
    }
    try {
        return service.getBatteryLevel(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return BATTERY_LEVEL_UNKNOWN;
}
#end_block

#method_before
public boolean createBond(int transport) {
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot create bond to Remote Device");
        return false;
    }
    if (TRANSPORT_AUTO > transport || transport > TRANSPORT_LE) {
        throw new IllegalArgumentException(transport + " is not a valid Bluetooth transport");
    }
    try {
        Log.i(TAG, "createBond() for device " + getAddress() + " called by pid: " + Process.myPid() + " tid: " + Process.myTid());
        return service.createBond(this, transport);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@UnsupportedAppUsage
public boolean createBond(int transport) {
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot create bond to Remote Device");
        return false;
    }
    if (TRANSPORT_AUTO > transport || transport > TRANSPORT_LE) {
        throw new IllegalArgumentException(transport + " is not a valid Bluetooth transport");
    }
    try {
        Log.i(TAG, "createBond() for device " + getAddress() + " called by pid: " + Process.myPid() + " tid: " + Process.myTid());
        return service.createBond(this, transport);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#end_block

#method_before
public boolean isBondingInitiatedLocally() {
    final IBluetooth service = sService;
    if (service == null) {
        Log.w(TAG, "BT not enabled, isBondingInitiatedLocally failed");
        return false;
    }
    try {
        return service.isBondingInitiatedLocally(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@UnsupportedAppUsage
public boolean isBondingInitiatedLocally() {
    final IBluetooth service = sService;
    if (service == null) {
        Log.w(TAG, "BT not enabled, isBondingInitiatedLocally failed");
        return false;
    }
    try {
        return service.isBondingInitiatedLocally(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#end_block

#method_before
public boolean setPasskey(int passkey) {
    /*
        try {
            return sService.setPasskey(this, true, 4, passkey);
        } catch (RemoteException e) {Log.e(TAG, "", e);}*/
    return false;
}
#method_after
@UnsupportedAppUsage
public boolean setPasskey(int passkey) {
    /*
        try {
            return sService.setPasskey(this, true, 4, passkey);
        } catch (RemoteException e) {Log.e(TAG, "", e);}*/
    return false;
}
#end_block

#method_before
public boolean cancelPairingUserInput() {
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot create pairing user input");
        return false;
    }
    try {
        return service.cancelBondProcess(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@UnsupportedAppUsage
public boolean cancelPairingUserInput() {
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot create pairing user input");
        return false;
    }
    try {
        return service.cancelBondProcess(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#end_block

#method_before
public boolean isBluetoothDock() {
    /*
        try {
            return sService.isBluetoothDock(this);
        } catch (RemoteException e) {Log.e(TAG, "", e);}*/
    return false;
}
#method_after
@UnsupportedAppUsage
public boolean isBluetoothDock() {
    /*
        try {
            return sService.isBluetoothDock(this);
        } catch (RemoteException e) {Log.e(TAG, "", e);}*/
    return false;
}
#end_block

#method_before
public int getPhonebookAccessPermission() {
    final IBluetooth service = sService;
    if (service == null) {
        return ACCESS_UNKNOWN;
    }
    try {
        return service.getPhonebookAccessPermission(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return ACCESS_UNKNOWN;
}
#method_after
@UnsupportedAppUsage
public int getPhonebookAccessPermission() {
    final IBluetooth service = sService;
    if (service == null) {
        return ACCESS_UNKNOWN;
    }
    try {
        return service.getPhonebookAccessPermission(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return ACCESS_UNKNOWN;
}
#end_block

#method_before
public int getMessageAccessPermission() {
    final IBluetooth service = sService;
    if (service == null) {
        return ACCESS_UNKNOWN;
    }
    try {
        return service.getMessageAccessPermission(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return ACCESS_UNKNOWN;
}
#method_after
@UnsupportedAppUsage
public int getMessageAccessPermission() {
    final IBluetooth service = sService;
    if (service == null) {
        return ACCESS_UNKNOWN;
    }
    try {
        return service.getMessageAccessPermission(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return ACCESS_UNKNOWN;
}
#end_block

#method_before
public boolean setMessageAccessPermission(int value) {
    final IBluetooth service = sService;
    if (service == null) {
        return false;
    }
    try {
        return service.setMessageAccessPermission(this, value);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@UnsupportedAppUsage
public boolean setMessageAccessPermission(int value) {
    final IBluetooth service = sService;
    if (service == null) {
        return false;
    }
    try {
        return service.setMessageAccessPermission(this, value);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#end_block

#method_before
public boolean setSimAccessPermission(int value) {
    final IBluetooth service = sService;
    if (service == null) {
        return false;
    }
    try {
        return service.setSimAccessPermission(this, value);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#method_after
@UnsupportedAppUsage
public boolean setSimAccessPermission(int value) {
    final IBluetooth service = sService;
    if (service == null) {
        return false;
    }
    try {
        return service.setSimAccessPermission(this, value);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
#end_block

#method_before
public BluetoothSocket createRfcommSocket(int channel) throws IOException {
    if (!isBluetoothEnabled()) {
        Log.e(TAG, "Bluetooth is not enabled");
        throw new IOException();
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, true, true, this, channel, null);
}
#method_after
@UnsupportedAppUsage
public BluetoothSocket createRfcommSocket(int channel) throws IOException {
    if (!isBluetoothEnabled()) {
        Log.e(TAG, "Bluetooth is not enabled");
        throw new IOException();
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, true, true, this, channel, null);
}
#end_block

#method_before
public BluetoothSocket createInsecureRfcommSocket(int port) throws IOException {
    if (!isBluetoothEnabled()) {
        Log.e(TAG, "Bluetooth is not enabled");
        throw new IOException();
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, false, false, this, port, null);
}
#method_after
@UnsupportedAppUsage
public BluetoothSocket createInsecureRfcommSocket(int port) throws IOException {
    if (!isBluetoothEnabled()) {
        Log.e(TAG, "Bluetooth is not enabled");
        throw new IOException();
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, false, false, this, port, null);
}
#end_block

#method_before
public BluetoothSocket createScoSocket() throws IOException {
    if (!isBluetoothEnabled()) {
        Log.e(TAG, "Bluetooth is not enabled");
        throw new IOException();
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_SCO, -1, true, true, this, -1, null);
}
#method_after
@UnsupportedAppUsage
public BluetoothSocket createScoSocket() throws IOException {
    if (!isBluetoothEnabled()) {
        Log.e(TAG, "Bluetooth is not enabled");
        throw new IOException();
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_SCO, -1, true, true, this, -1, null);
}
#end_block

#method_before
public static byte[] convertPinToBytes(String pin) {
    if (pin == null) {
        return null;
    }
    byte[] pinBytes;
    try {
        pinBytes = pin.getBytes("UTF-8");
    } catch (UnsupportedEncodingException uee) {
        // this should not happen
        Log.e(TAG, "UTF-8 not supported?!?");
        return null;
    }
    if (pinBytes.length <= 0 || pinBytes.length > 16) {
        return null;
    }
    return pinBytes;
}
#method_after
@UnsupportedAppUsage
public static byte[] convertPinToBytes(String pin) {
    if (pin == null) {
        return null;
    }
    byte[] pinBytes;
    try {
        pinBytes = pin.getBytes("UTF-8");
    } catch (UnsupportedEncodingException uee) {
        // this should not happen
        Log.e(TAG, "UTF-8 not supported?!?");
        return null;
    }
    if (pinBytes.length <= 0 || pinBytes.length > 16) {
        return null;
    }
    return pinBytes;
}
#end_block

#method_before
public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport, boolean opportunistic, int phy, Handler handler) {
    if (callback == null) {
        throw new NullPointerException("callback is null");
    }
    // TODO(Bluetooth) check whether platform support BLE
    // Do the check here or in GattServer?
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    IBluetoothManager managerService = adapter.getBluetoothManager();
    try {
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null) {
            // BLE is not supported
            return null;
        }
        BluetoothGatt gatt = new BluetoothGatt(iGatt, this, transport, opportunistic, phy);
        gatt.connect(autoConnect, callback, handler);
        return gatt;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
#method_after
@UnsupportedAppUsage
public BluetoothGatt connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport, boolean opportunistic, int phy, Handler handler) {
    if (callback == null) {
        throw new NullPointerException("callback is null");
    }
    // TODO(Bluetooth) check whether platform support BLE
    // Do the check here or in GattServer?
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    IBluetoothManager managerService = adapter.getBluetoothManager();
    try {
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null) {
            // BLE is not supported
            return null;
        }
        BluetoothGatt gatt = new BluetoothGatt(iGatt, this, transport, opportunistic, phy);
        gatt.connect(autoConnect, callback, handler);
        return gatt;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
public BluetoothSocket createL2capCocSocket(int transport, int psm) throws IOException {
    if (!isBluetoothEnabled()) {
        Log.e(TAG, "createL2capCocSocket: Bluetooth is not enabled");
        throw new IOException();
    }
    if (transport != BluetoothDevice.TRANSPORT_LE) {
        throw new IllegalArgumentException("Unsupported transport: " + transport);
    }
    if (DBG)
        Log.d(TAG, "createL2capCocSocket: transport=" + transport + ", psm=" + psm);
    return new BluetoothSocket(BluetoothSocket.TYPE_L2CAP_LE, -1, true, true, this, psm, null);
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
public BluetoothSocket createL2capCocSocket(int transport, int psm) throws IOException {
    Log.e(TAG, "createL2capCocSocket: PLEASE USE THE OFFICIAL API, createL2capChannel");
    return createL2capChannel(psm);
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
public BluetoothSocket createInsecureL2capCocSocket(int transport, int psm) throws IOException {
    if (!isBluetoothEnabled()) {
        Log.e(TAG, "createInsecureL2capCocSocket: Bluetooth is not enabled");
        throw new IOException();
    }
    if (transport != BluetoothDevice.TRANSPORT_LE) {
        throw new IllegalArgumentException("Unsupported transport: " + transport);
    }
    if (DBG) {
        Log.d(TAG, "createInsecureL2capCocSocket: transport=" + transport + ", psm=" + psm);
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_L2CAP_LE, -1, false, false, this, psm, null);
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
public BluetoothSocket createInsecureL2capCocSocket(int transport, int psm) throws IOException {
    Log.e(TAG, "createL2capCocSocket: PLEASE USE THE OFFICIAL API, createInsecureL2capChannel");
    return createInsecureL2capChannel(psm);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
@Override
public void navigate(@NonNull Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions) {
    if (mFragmentManager.isStateSaved()) {
        Log.i(TAG, "Ignoring navigate() call: FragmentManager has already" + " saved its state");
        return;
    }
    final Fragment frag = destination.createFragment(args);
    final FragmentTransaction ft = mFragmentManager.beginTransaction();
    int enterAnim = navOptions != null ? navOptions.getEnterAnim() : -1;
    int exitAnim = navOptions != null ? navOptions.getExitAnim() : -1;
    int popEnterAnim = navOptions != null ? navOptions.getPopEnterAnim() : -1;
    int popExitAnim = navOptions != null ? navOptions.getPopExitAnim() : -1;
    if (enterAnim != -1 || exitAnim != -1 || popEnterAnim != -1 || popExitAnim != -1) {
        enterAnim = enterAnim != -1 ? enterAnim : 0;
        exitAnim = exitAnim != -1 ? exitAnim : 0;
        popEnterAnim = popEnterAnim != -1 ? popEnterAnim : 0;
        popExitAnim = popExitAnim != -1 ? popExitAnim : 0;
        ft.setCustomAnimations(enterAnim, exitAnim, popEnterAnim, popExitAnim);
    }
    ft.replace(mContainerId, frag);
    ft.setPrimaryNavigationFragment(frag);
    @IdRes
    final int destId = destination.getId();
    final boolean initialNavigation = mBackStack.isEmpty();
    final boolean isClearTask = navOptions != null && navOptions.shouldClearTask();
    // TODO Build first class singleTop behavior for fragments
    final boolean isSingleTopReplacement = navOptions != null && !initialNavigation && navOptions.shouldLaunchSingleTop() && mBackStack.peekLast() == destId;
    int backStackEffect;
    if (initialNavigation || isClearTask) {
        backStackEffect = BACK_STACK_DESTINATION_ADDED;
    } else if (isSingleTopReplacement) {
        // Single Top means we only want one instance on the back stack
        if (mBackStack.size() > 1) {
            // If the Fragment to be replaced is on the FragmentManager's
            // back stack, a simple replace() isn't enough so we
            // remove it from the back stack and put our replacement
            // on the back stack in its place
            mFragmentManager.popBackStack();
            ft.addToBackStack(Integer.toString(destId));
            mIsPendingBackStackOperation = true;
        }
        backStackEffect = BACK_STACK_UNCHANGED;
    } else {
        ft.addToBackStack(Integer.toString(destId));
        mIsPendingBackStackOperation = true;
        backStackEffect = BACK_STACK_DESTINATION_ADDED;
    }
    NavigatorExtras navigatorExtras = navOptions != null ? navOptions.getNavigatorExtras() : null;
    if (navigatorExtras instanceof Extras) {
        Extras extras = (Extras) navigatorExtras;
        for (Map.Entry<View, String> sharedElement : extras.getSharedElements().entrySet()) {
            ft.addSharedElement(sharedElement.getKey(), sharedElement.getValue());
        }
    }
    ft.setReorderingAllowed(true);
    ft.commit();
    // The commit succeeded, update our view of the world
    if (backStackEffect == BACK_STACK_DESTINATION_ADDED) {
        mBackStack.add(destId);
    }
    dispatchOnNavigatorNavigated(destId, backStackEffect);
}
#method_after
@SuppressWarnings("deprecation")
@Override
public void navigate(@NonNull Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
    if (mFragmentManager.isStateSaved()) {
        Log.i(TAG, "Ignoring navigate() call: FragmentManager has already" + " saved its state");
        return;
    }
    final Fragment frag = destination.createFragment(args);
    final FragmentTransaction ft = mFragmentManager.beginTransaction();
    int enterAnim = navOptions != null ? navOptions.getEnterAnim() : -1;
    int exitAnim = navOptions != null ? navOptions.getExitAnim() : -1;
    int popEnterAnim = navOptions != null ? navOptions.getPopEnterAnim() : -1;
    int popExitAnim = navOptions != null ? navOptions.getPopExitAnim() : -1;
    if (enterAnim != -1 || exitAnim != -1 || popEnterAnim != -1 || popExitAnim != -1) {
        enterAnim = enterAnim != -1 ? enterAnim : 0;
        exitAnim = exitAnim != -1 ? exitAnim : 0;
        popEnterAnim = popEnterAnim != -1 ? popEnterAnim : 0;
        popExitAnim = popExitAnim != -1 ? popExitAnim : 0;
        ft.setCustomAnimations(enterAnim, exitAnim, popEnterAnim, popExitAnim);
    }
    ft.replace(mContainerId, frag);
    ft.setPrimaryNavigationFragment(frag);
    @IdRes
    final int destId = destination.getId();
    final boolean initialNavigation = mBackStack.isEmpty();
    final boolean isClearTask = navOptions != null && navOptions.shouldClearTask();
    // TODO Build first class singleTop behavior for fragments
    final boolean isSingleTopReplacement = navOptions != null && !initialNavigation && navOptions.shouldLaunchSingleTop() && mBackStack.peekLast() == destId;
    int backStackEffect;
    if (initialNavigation || isClearTask) {
        backStackEffect = BACK_STACK_DESTINATION_ADDED;
    } else if (isSingleTopReplacement) {
        // Single Top means we only want one instance on the back stack
        if (mBackStack.size() > 1) {
            // If the Fragment to be replaced is on the FragmentManager's
            // back stack, a simple replace() isn't enough so we
            // remove it from the back stack and put our replacement
            // on the back stack in its place
            mFragmentManager.popBackStack();
            ft.addToBackStack(Integer.toString(destId));
            mIsPendingBackStackOperation = true;
        }
        backStackEffect = BACK_STACK_UNCHANGED;
    } else {
        ft.addToBackStack(Integer.toString(destId));
        mIsPendingBackStackOperation = true;
        backStackEffect = BACK_STACK_DESTINATION_ADDED;
    }
    if (navigatorExtras instanceof Extras) {
        Extras extras = (Extras) navigatorExtras;
        for (Map.Entry<View, String> sharedElement : extras.getSharedElements().entrySet()) {
            ft.addSharedElement(sharedElement.getKey(), sharedElement.getValue());
        }
    }
    ft.setReorderingAllowed(true);
    ft.commit();
    // The commit succeeded, update our view of the world
    if (backStackEffect == BACK_STACK_DESTINATION_ADDED) {
        mBackStack.add(destId);
    }
    dispatchOnNavigatorNavigated(destId, backStackEffect);
}
#end_block

#method_before
@NonNull
public Map<View, String> getSharedElements() {
    return Collections.unmodifiableMap(new LinkedHashMap<>(mSharedElements));
}
#method_after
@NonNull
public Map<View, String> getSharedElements() {
    return Collections.unmodifiableMap(mSharedElements);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
@Override
public void navigate(@NonNull Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions) {
    if (destination.getIntent() == null) {
        throw new IllegalStateException("Destination " + destination.getId() + " does not have an Intent set.");
    }
    Intent intent = new Intent(destination.getIntent());
    if (args != null) {
        intent.putExtras(args);
        String dataPattern = destination.getDataPattern();
        if (!TextUtils.isEmpty(dataPattern)) {
            // Fill in the data pattern with the args to build a valid URI
            StringBuffer data = new StringBuffer();
            Pattern fillInPattern = Pattern.compile("\\{(.+?)\\}");
            Matcher matcher = fillInPattern.matcher(dataPattern);
            while (matcher.find()) {
                String argName = matcher.group(1);
                if (args.containsKey(argName)) {
                    matcher.appendReplacement(data, "");
                    data.append(Uri.encode(args.getString(argName)));
                } else {
                    throw new IllegalArgumentException("Could not find " + argName + " in " + args + " to fill data pattern " + dataPattern);
                }
            }
            matcher.appendTail(data);
            intent.setData(Uri.parse(data.toString()));
        }
    }
    if (navOptions != null && navOptions.shouldClearTask()) {
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
    }
    if (navOptions != null && navOptions.shouldLaunchDocument() && Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT);
    } else if (!(mContext instanceof Activity)) {
        // If we're not launching from an Activity context we have to launch in a new task.
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    }
    if (navOptions != null && navOptions.shouldLaunchSingleTop()) {
        intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
    }
    if (mHostActivity != null) {
        final Intent hostIntent = mHostActivity.getIntent();
        if (hostIntent != null) {
            final int hostCurrentId = hostIntent.getIntExtra(EXTRA_NAV_CURRENT, 0);
            if (hostCurrentId != 0) {
                intent.putExtra(EXTRA_NAV_SOURCE, hostCurrentId);
            }
        }
    }
    final int destId = destination.getId();
    intent.putExtra(EXTRA_NAV_CURRENT, destId);
    NavOptions.addPopAnimationsToIntent(intent, navOptions);
    if (navOptions != null && mHostActivity != null) {
        int enterAnim = navOptions.getEnterAnim();
        int exitAnim = navOptions.getExitAnim();
        if (enterAnim != -1 || exitAnim != -1) {
            enterAnim = enterAnim != -1 ? enterAnim : 0;
            exitAnim = exitAnim != -1 ? exitAnim : 0;
            mHostActivity.overridePendingTransition(enterAnim, exitAnim);
        }
    }
    NavigatorExtras navigatorExtras = navOptions != null ? navOptions.getNavigatorExtras() : null;
    if (navigatorExtras instanceof Extras) {
        Extras extras = (Extras) navigatorExtras;
        ActivityCompat.startActivity(mContext, intent, extras.getActivityOptions().toBundle());
    } else {
        mContext.startActivity(intent);
    }
    // You can't pop the back stack from the caller of a new Activity,
    // so we don't add this navigator to the controller's back stack
    dispatchOnNavigatorNavigated(destId, BACK_STACK_UNCHANGED);
}
#method_after
@SuppressWarnings("deprecation")
@Override
public void navigate(@NonNull Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
    if (destination.getIntent() == null) {
        throw new IllegalStateException("Destination " + destination.getId() + " does not have an Intent set.");
    }
    Intent intent = new Intent(destination.getIntent());
    if (args != null) {
        intent.putExtras(args);
        String dataPattern = destination.getDataPattern();
        if (!TextUtils.isEmpty(dataPattern)) {
            // Fill in the data pattern with the args to build a valid URI
            StringBuffer data = new StringBuffer();
            Pattern fillInPattern = Pattern.compile("\\{(.+?)\\}");
            Matcher matcher = fillInPattern.matcher(dataPattern);
            while (matcher.find()) {
                String argName = matcher.group(1);
                if (args.containsKey(argName)) {
                    matcher.appendReplacement(data, "");
                    data.append(Uri.encode(args.getString(argName)));
                } else {
                    throw new IllegalArgumentException("Could not find " + argName + " in " + args + " to fill data pattern " + dataPattern);
                }
            }
            matcher.appendTail(data);
            intent.setData(Uri.parse(data.toString()));
        }
    }
    if (navOptions != null && navOptions.shouldClearTask()) {
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
    }
    if (navOptions != null && navOptions.shouldLaunchDocument() && Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT);
    } else if (!(mContext instanceof Activity)) {
        // If we're not launching from an Activity context we have to launch in a new task.
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    }
    if (navOptions != null && navOptions.shouldLaunchSingleTop()) {
        intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
    }
    if (mHostActivity != null) {
        final Intent hostIntent = mHostActivity.getIntent();
        if (hostIntent != null) {
            final int hostCurrentId = hostIntent.getIntExtra(EXTRA_NAV_CURRENT, 0);
            if (hostCurrentId != 0) {
                intent.putExtra(EXTRA_NAV_SOURCE, hostCurrentId);
            }
        }
    }
    final int destId = destination.getId();
    intent.putExtra(EXTRA_NAV_CURRENT, destId);
    NavOptions.addPopAnimationsToIntent(intent, navOptions);
    if (navOptions != null && mHostActivity != null) {
        int enterAnim = navOptions.getEnterAnim();
        int exitAnim = navOptions.getExitAnim();
        if (enterAnim != -1 || exitAnim != -1) {
            enterAnim = enterAnim != -1 ? enterAnim : 0;
            exitAnim = exitAnim != -1 ? exitAnim : 0;
            mHostActivity.overridePendingTransition(enterAnim, exitAnim);
        }
    }
    if (navigatorExtras instanceof Extras) {
        Extras extras = (Extras) navigatorExtras;
        ActivityCompat.startActivity(mContext, intent, extras.getActivityOptions().toBundle());
    } else {
        mContext.startActivity(intent);
    }
    // You can't pop the back stack from the caller of a new Activity,
    // so we don't add this navigator to the controller's back stack
    dispatchOnNavigatorNavigated(destId, BACK_STACK_UNCHANGED);
}
#end_block

#method_before
private void onGraphCreated() {
    if (mNavigatorStateToRestore != null) {
        ArrayList<String> navigatorNames = mNavigatorStateToRestore.getStringArrayList(KEY_NAVIGATOR_STATE_NAMES);
        if (navigatorNames != null) {
            for (String name : navigatorNames) {
                Navigator navigator = mNavigatorProvider.getNavigator(name);
                Bundle bundle = mNavigatorStateToRestore.getBundle(name);
                if (bundle != null) {
                    navigator.onRestoreState(bundle);
                }
            }
        }
    }
    if (mBackStackToRestore != null) {
        for (int destinationId : mBackStackToRestore) {
            NavDestination node = findDestination(destinationId);
            if (node == null) {
                throw new IllegalStateException("unknown destination during restore: " + mContext.getResources().getResourceName(destinationId));
            }
            mBackStack.add(node);
        }
        mBackStackToRestore = null;
    }
    if (mGraph != null && mBackStack.isEmpty()) {
        boolean deepLinked = mActivity != null && onHandleDeepLink(mActivity.getIntent());
        if (!deepLinked) {
            // Navigate to the first destination in the graph
            // if we haven't deep linked to a destination
            mGraph.navigate(null, null);
        }
    }
}
#method_after
private void onGraphCreated() {
    if (mNavigatorStateToRestore != null) {
        ArrayList<String> navigatorNames = mNavigatorStateToRestore.getStringArrayList(KEY_NAVIGATOR_STATE_NAMES);
        if (navigatorNames != null) {
            for (String name : navigatorNames) {
                Navigator navigator = mNavigatorProvider.getNavigator(name);
                Bundle bundle = mNavigatorStateToRestore.getBundle(name);
                if (bundle != null) {
                    navigator.onRestoreState(bundle);
                }
            }
        }
    }
    if (mBackStackToRestore != null) {
        for (int destinationId : mBackStackToRestore) {
            NavDestination node = findDestination(destinationId);
            if (node == null) {
                throw new IllegalStateException("unknown destination during restore: " + mContext.getResources().getResourceName(destinationId));
            }
            mBackStack.add(node);
        }
        mBackStackToRestore = null;
    }
    if (mGraph != null && mBackStack.isEmpty()) {
        boolean deepLinked = mActivity != null && onHandleDeepLink(mActivity.getIntent());
        if (!deepLinked) {
            // Navigate to the first destination in the graph
            // if we haven't deep linked to a destination
            mGraph.navigate(null, null, null);
        }
    }
}
#end_block

#method_before
public boolean onHandleDeepLink(@Nullable Intent intent) {
    if (intent == null) {
        return false;
    }
    Bundle extras = intent.getExtras();
    int[] deepLink = extras != null ? extras.getIntArray(KEY_DEEP_LINK_IDS) : null;
    Bundle bundle = new Bundle();
    Bundle deepLinkExtras = extras != null ? extras.getBundle(KEY_DEEP_LINK_EXTRAS) : null;
    if (deepLinkExtras != null) {
        bundle.putAll(deepLinkExtras);
    }
    if ((deepLink == null || deepLink.length == 0) && intent.getData() != null) {
        Pair<NavDestination, Bundle> matchingDeepLink = mGraph.matchDeepLink(intent.getData());
        if (matchingDeepLink != null) {
            deepLink = matchingDeepLink.first.buildDeepLinkIds();
            bundle.putAll(matchingDeepLink.second);
        }
    }
    if (deepLink == null || deepLink.length == 0) {
        return false;
    }
    bundle.putParcelable(KEY_DEEP_LINK_INTENT, intent);
    int flags = intent.getFlags();
    if ((flags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (flags & Intent.FLAG_ACTIVITY_CLEAR_TASK) == 0) {
        // Someone called us with NEW_TASK, but we don't know what state our whole
        // task stack is in, so we need to manually restart the whole stack to
        // ensure we're in a predictably good state.
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
        TaskStackBuilder taskStackBuilder = TaskStackBuilder.create(mContext).addNextIntentWithParentStack(intent);
        taskStackBuilder.startActivities();
        if (mActivity != null) {
            mActivity.finish();
        }
        return true;
    }
    if ((flags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
        // Start with a cleared task starting at our root when we're on our own task
        if (!mBackStack.isEmpty()) {
            navigate(mGraph.getStartDestination(), bundle, new NavOptions.Builder().setPopUpTo(mGraph.getId(), true).setEnterAnim(0).setExitAnim(0).build());
        }
        int index = 0;
        while (index < deepLink.length) {
            int destinationId = deepLink[index++];
            NavDestination node = findDestination(destinationId);
            if (node == null) {
                throw new IllegalStateException("unknown destination during deep link: " + NavDestination.getDisplayName(mContext, destinationId));
            }
            node.navigate(bundle, new NavOptions.Builder().setEnterAnim(0).setExitAnim(0).build());
        }
        return true;
    }
    // Assume we're on another apps' task and only start the final destination
    NavGraph graph = mGraph;
    for (int i = 0; i < deepLink.length; i++) {
        int destinationId = deepLink[i];
        NavDestination node = i == 0 ? mGraph : graph.findNode(destinationId);
        if (node == null) {
            throw new IllegalStateException("unknown destination during deep link: " + NavDestination.getDisplayName(mContext, destinationId));
        }
        if (i != deepLink.length - 1) {
            // We're not at the final NavDestination yet, so keep going through the chain
            graph = (NavGraph) node;
        } else {
            // Navigate to the last NavDestination, clearing any existing destinations
            node.navigate(bundle, new NavOptions.Builder().setPopUpTo(mGraph.getId(), true).setEnterAnim(0).setExitAnim(0).build());
        }
    }
    return true;
}
#method_after
public boolean onHandleDeepLink(@Nullable Intent intent) {
    if (intent == null) {
        return false;
    }
    Bundle extras = intent.getExtras();
    int[] deepLink = extras != null ? extras.getIntArray(KEY_DEEP_LINK_IDS) : null;
    Bundle bundle = new Bundle();
    Bundle deepLinkExtras = extras != null ? extras.getBundle(KEY_DEEP_LINK_EXTRAS) : null;
    if (deepLinkExtras != null) {
        bundle.putAll(deepLinkExtras);
    }
    if ((deepLink == null || deepLink.length == 0) && intent.getData() != null) {
        Pair<NavDestination, Bundle> matchingDeepLink = mGraph.matchDeepLink(intent.getData());
        if (matchingDeepLink != null) {
            deepLink = matchingDeepLink.first.buildDeepLinkIds();
            bundle.putAll(matchingDeepLink.second);
        }
    }
    if (deepLink == null || deepLink.length == 0) {
        return false;
    }
    bundle.putParcelable(KEY_DEEP_LINK_INTENT, intent);
    int flags = intent.getFlags();
    if ((flags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && (flags & Intent.FLAG_ACTIVITY_CLEAR_TASK) == 0) {
        // Someone called us with NEW_TASK, but we don't know what state our whole
        // task stack is in, so we need to manually restart the whole stack to
        // ensure we're in a predictably good state.
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
        TaskStackBuilder taskStackBuilder = TaskStackBuilder.create(mContext).addNextIntentWithParentStack(intent);
        taskStackBuilder.startActivities();
        if (mActivity != null) {
            mActivity.finish();
        }
        return true;
    }
    if ((flags & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
        // Start with a cleared task starting at our root when we're on our own task
        if (!mBackStack.isEmpty()) {
            navigate(mGraph.getStartDestination(), bundle, new NavOptions.Builder().setPopUpTo(mGraph.getId(), true).setEnterAnim(0).setExitAnim(0).build());
        }
        int index = 0;
        while (index < deepLink.length) {
            int destinationId = deepLink[index++];
            NavDestination node = findDestination(destinationId);
            if (node == null) {
                throw new IllegalStateException("unknown destination during deep link: " + NavDestination.getDisplayName(mContext, destinationId));
            }
            node.navigate(bundle, new NavOptions.Builder().setEnterAnim(0).setExitAnim(0).build(), null);
        }
        return true;
    }
    // Assume we're on another apps' task and only start the final destination
    NavGraph graph = mGraph;
    for (int i = 0; i < deepLink.length; i++) {
        int destinationId = deepLink[i];
        NavDestination node = i == 0 ? mGraph : graph.findNode(destinationId);
        if (node == null) {
            throw new IllegalStateException("unknown destination during deep link: " + NavDestination.getDisplayName(mContext, destinationId));
        }
        if (i != deepLink.length - 1) {
            // We're not at the final NavDestination yet, so keep going through the chain
            graph = (NavGraph) node;
        } else {
            // Navigate to the last NavDestination, clearing any existing destinations
            node.navigate(bundle, new NavOptions.Builder().setPopUpTo(mGraph.getId(), true).setEnterAnim(0).setExitAnim(0).build(), null);
        }
    }
    return true;
}
#end_block

#method_before
public void navigate(@NonNull NavDirections directions, @NonNull NavigatorExtras navigatorExtras) {
    navigate(directions.getActionId(), directions.getArguments(), null, navigatorExtras);
}
#method_after
@SuppressWarnings("deprecation")
public void navigate(@IdRes int resId, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
    NavDestination currentNode = mBackStack.isEmpty() ? mGraph : mBackStack.peekLast();
    if (currentNode == null) {
        throw new IllegalStateException("no current navigation node");
    }
    @IdRes
    int destId = resId;
    final NavAction navAction = currentNode.getAction(resId);
    if (navAction != null) {
        if (navOptions == null) {
            navOptions = navAction.getNavOptions();
        }
        destId = navAction.getDestinationId();
    }
    if (destId == 0 && navOptions != null && navOptions.getPopUpTo() != 0) {
        popBackStack(navOptions.getPopUpTo(), navOptions.isPopUpToInclusive());
        return;
    }
    if (destId == 0) {
        throw new IllegalArgumentException("Destination id == 0 can only be used" + " in conjunction with navOptions.popUpTo != 0");
    }
    NavDestination node = findDestination(destId);
    if (node == null) {
        final String dest = NavDestination.getDisplayName(mContext, destId);
        throw new IllegalArgumentException("navigation destination " + dest + (navAction != null ? " referenced from action " + NavDestination.getDisplayName(mContext, resId) : "") + " is unknown to this NavController");
    }
    if (navOptions != null) {
        if (navOptions.shouldClearTask()) {
            // Start with a clean slate
            popBackStack(mGraph.getId(), true);
        } else if (navOptions.getPopUpTo() != 0) {
            popBackStack(navOptions.getPopUpTo(), navOptions.isPopUpToInclusive());
        }
    }
    node.navigate(args, navOptions, navigatorExtras);
}
#end_block

#method_before
public static TestCoverageStatusEntity getTestCoverageStatus(TestCoverageStatusEntity status, Key testRunKey, String link, List<String> emailAddresses, List<Message> messages) throws IOException {
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    String testName = status.getTestName();
    double previousPct;
    double coveragePct;
    if (status == null || status.getTotalLineCount() <= 0 || status.getCoveredLineCount() < 0) {
        previousPct = 0;
    } else {
        previousPct = ((double) status.getCoveredLineCount()) / status.getTotalLineCount();
    }
    Entity testRun;
    try {
        testRun = datastore.get(testRunKey);
    } catch (EntityNotFoundException e) {
        logger.log(Level.WARNING, "Test run not found: " + testRunKey);
        return null;
    }
    TestRunEntity testRunEntity = TestRunEntity.fromEntity(testRun);
    if (testRunEntity == null || !testRunEntity.isHasCodeCoverage()) {
        return null;
    }
    CodeCoverageEntity codeCoverageEntity = testRunEntity.getCodeCoverageEntity();
    if (codeCoverageEntity.getTotalLineCount() <= 0 || codeCoverageEntity.getCoveredLineCount() < 0) {
        coveragePct = 0;
    } else {
        coveragePct = ((double) codeCoverageEntity.getCoveredLineCount()) / codeCoverageEntity.getTotalLineCount();
    }
    Set<String> buildIdList = new HashSet<>();
    Query deviceQuery = new Query(DeviceInfoEntity.KIND).setAncestor(testRun.getKey());
    List<DeviceInfoEntity> devices = new ArrayList<>();
    for (Entity device : datastore.prepare(deviceQuery).asIterable()) {
        DeviceInfoEntity deviceEntity = DeviceInfoEntity.fromEntity(device);
        if (deviceEntity == null) {
            continue;
        }
        devices.add(deviceEntity);
        buildIdList.add(deviceEntity.getBuildId());
    }
    String deviceBuild = StringUtils.join(buildIdList, ", ");
    String footer = EmailHelper.getEmailFooter(testRunEntity, devices, link);
    String subject = null;
    String body = null;
    String subjectSuffix = " @ " + deviceBuild;
    if (coveragePct >= GOOD_THRESHOLD && previousPct < GOOD_THRESHOLD) {
        // Coverage entered the good zone
        subject = "Congratulations! " + testName + " has exceeded " + FORMATTER.format(GOOD_THRESHOLD * 100) + "% coverage" + subjectSuffix;
        body = "Hello,<br><br>The " + testName + " has achieved " + FORMATTER.format(coveragePct * 100) + "% code coverage on device build ID(s): " + deviceBuild + "." + footer;
    } else if (coveragePct < GOOD_THRESHOLD && previousPct >= GOOD_THRESHOLD) {
        // Coverage dropped out of the good zone
        subject = "Warning! " + testName + " has dropped below " + FORMATTER.format(GOOD_THRESHOLD * 100) + "% coverage" + subjectSuffix;
        ;
        body = "Hello,<br><br>The test " + testName + " has dropped to " + FORMATTER.format(coveragePct * 100) + "% code coverage on device build ID(s): " + deviceBuild + "." + footer;
    } else if (coveragePct <= BAD_THRESHOLD && previousPct > BAD_THRESHOLD) {
        // Coverage entered into the bad zone
        subject = "Warning! " + testName + " has dropped below " + FORMATTER.format(BAD_THRESHOLD * 100) + "% coverage" + subjectSuffix;
        body = "Hello,<br><br>The test " + testName + " has dropped to " + FORMATTER.format(coveragePct * 100) + "% code coverage on device build ID(s): " + deviceBuild + "." + footer;
    } else if (coveragePct > BAD_THRESHOLD && previousPct <= BAD_THRESHOLD) {
        // Coverage emerged from the bad zone
        subject = "Congratulations! " + testName + " has exceeded " + FORMATTER.format(BAD_THRESHOLD * 100) + "% coverage" + subjectSuffix;
        body = "Hello,<br><br>The test " + testName + " has achived " + FORMATTER.format(coveragePct * 100) + "% code coverage on device build ID(s): " + deviceBuild + "." + footer;
    } else if (coveragePct - previousPct < -CHANGE_ALERT_THRESHOLD) {
        // Send a coverage drop alert
        subject = "Warning! " + testName + "'s code coverage has decreased by more than " + FORMATTER.format(CHANGE_ALERT_THRESHOLD * 100) + "%" + subjectSuffix;
        body = "Hello,<br><br>The test " + testName + " has dropped from " + FORMATTER.format(previousPct * 100) + "% code coverage to " + FORMATTER.format(coveragePct * 100) + "% code coverage on device build ID(s): " + deviceBuild + "." + footer;
    } else if (coveragePct - previousPct > CHANGE_ALERT_THRESHOLD) {
        // Send a coverage improvement alert
        subject = testName + "'s code coverage has increased by more than " + FORMATTER.format(CHANGE_ALERT_THRESHOLD * 100) + "%" + subjectSuffix;
        body = "Hello,<br><br>The test " + testName + " has increased from " + FORMATTER.format(previousPct * 100) + "% code coverage to " + FORMATTER.format(coveragePct * 100) + "% code coverage on device build ID(s): " + deviceBuild + "." + footer;
    }
    if (subject != null && body != null) {
        try {
            messages.add(EmailHelper.composeEmail(emailAddresses, subject, body));
        } catch (MessagingException | UnsupportedEncodingException e) {
            logger.log(Level.WARNING, "Error composing email : ", e);
        }
    }
    return new TestCoverageStatusEntity(testName, testRunEntity.getStartTimestamp(), codeCoverageEntity.getCoveredLineCount(), codeCoverageEntity.getTotalLineCount());
}
#method_after
public static TestCoverageStatusEntity getTestCoverageStatus(TestCoverageStatusEntity status, Key testRunKey, String link, List<String> emailAddresses, List<Message> messages) throws IOException {
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    String testName = status.getTestName();
    double previousPct;
    double coveragePct;
    if (status == null || status.getTotalLineCount() <= 0 || status.getCoveredLineCount() < 0) {
        previousPct = 0;
    } else {
        previousPct = ((double) status.getCoveredLineCount()) / status.getTotalLineCount();
    }
    Entity testRun;
    try {
        testRun = datastore.get(testRunKey);
    } catch (EntityNotFoundException e) {
        logger.log(Level.WARNING, "Test run not found: " + testRunKey);
        return null;
    }
    TestRunEntity testRunEntity = TestRunEntity.fromEntity(testRun);
    if (testRunEntity == null || !testRunEntity.hasCodeCoverage()) {
        return null;
    }
    CodeCoverageEntity codeCoverageEntity = testRunEntity.getCodeCoverageEntity();
    if (codeCoverageEntity.getTotalLineCount() <= 0 || codeCoverageEntity.getCoveredLineCount() < 0) {
        coveragePct = 0;
    } else {
        coveragePct = ((double) codeCoverageEntity.getCoveredLineCount()) / codeCoverageEntity.getTotalLineCount();
    }
    Set<String> buildIdList = new HashSet<>();
    Query deviceQuery = new Query(DeviceInfoEntity.KIND).setAncestor(testRun.getKey());
    List<DeviceInfoEntity> devices = new ArrayList<>();
    for (Entity device : datastore.prepare(deviceQuery).asIterable()) {
        DeviceInfoEntity deviceEntity = DeviceInfoEntity.fromEntity(device);
        if (deviceEntity == null) {
            continue;
        }
        devices.add(deviceEntity);
        buildIdList.add(deviceEntity.getBuildId());
    }
    String deviceBuild = StringUtils.join(buildIdList, ", ");
    String footer = EmailHelper.getEmailFooter(testRunEntity, devices, link);
    String subject = null;
    String body = null;
    String subjectSuffix = " @ " + deviceBuild;
    if (coveragePct >= GOOD_THRESHOLD && previousPct < GOOD_THRESHOLD) {
        // Coverage entered the good zone
        subject = "Congratulations! " + testName + " has exceeded " + FORMATTER.format(GOOD_THRESHOLD * 100) + "% coverage" + subjectSuffix;
        body = "Hello,<br><br>The " + testName + " has achieved " + FORMATTER.format(coveragePct * 100) + "% code coverage on device build ID(s): " + deviceBuild + "." + footer;
    } else if (coveragePct < GOOD_THRESHOLD && previousPct >= GOOD_THRESHOLD) {
        // Coverage dropped out of the good zone
        subject = "Warning! " + testName + " has dropped below " + FORMATTER.format(GOOD_THRESHOLD * 100) + "% coverage" + subjectSuffix;
        ;
        body = "Hello,<br><br>The test " + testName + " has dropped to " + FORMATTER.format(coveragePct * 100) + "% code coverage on device build ID(s): " + deviceBuild + "." + footer;
    } else if (coveragePct <= BAD_THRESHOLD && previousPct > BAD_THRESHOLD) {
        // Coverage entered into the bad zone
        subject = "Warning! " + testName + " has dropped below " + FORMATTER.format(BAD_THRESHOLD * 100) + "% coverage" + subjectSuffix;
        body = "Hello,<br><br>The test " + testName + " has dropped to " + FORMATTER.format(coveragePct * 100) + "% code coverage on device build ID(s): " + deviceBuild + "." + footer;
    } else if (coveragePct > BAD_THRESHOLD && previousPct <= BAD_THRESHOLD) {
        // Coverage emerged from the bad zone
        subject = "Congratulations! " + testName + " has exceeded " + FORMATTER.format(BAD_THRESHOLD * 100) + "% coverage" + subjectSuffix;
        body = "Hello,<br><br>The test " + testName + " has achived " + FORMATTER.format(coveragePct * 100) + "% code coverage on device build ID(s): " + deviceBuild + "." + footer;
    } else if (coveragePct - previousPct < -CHANGE_ALERT_THRESHOLD) {
        // Send a coverage drop alert
        subject = "Warning! " + testName + "'s code coverage has decreased by more than " + FORMATTER.format(CHANGE_ALERT_THRESHOLD * 100) + "%" + subjectSuffix;
        body = "Hello,<br><br>The test " + testName + " has dropped from " + FORMATTER.format(previousPct * 100) + "% code coverage to " + FORMATTER.format(coveragePct * 100) + "% code coverage on device build ID(s): " + deviceBuild + "." + footer;
    } else if (coveragePct - previousPct > CHANGE_ALERT_THRESHOLD) {
        // Send a coverage improvement alert
        subject = testName + "'s code coverage has increased by more than " + FORMATTER.format(CHANGE_ALERT_THRESHOLD * 100) + "%" + subjectSuffix;
        body = "Hello,<br><br>The test " + testName + " has increased from " + FORMATTER.format(previousPct * 100) + "% code coverage to " + FORMATTER.format(coveragePct * 100) + "% code coverage on device build ID(s): " + deviceBuild + "." + footer;
    }
    if (subject != null && body != null) {
        try {
            messages.add(EmailHelper.composeEmail(emailAddresses, subject, body));
        } catch (MessagingException | UnsupportedEncodingException e) {
            logger.log(Level.WARNING, "Error composing email : ", e);
        }
    }
    return new TestCoverageStatusEntity(testName, testRunEntity.getStartTimestamp(), codeCoverageEntity.getCoveredLineCount(), codeCoverageEntity.getTotalLineCount());
}
#end_block

#method_before
static void updateInternalIccState(Context context, IccCardConstants.State state, String reason, int phoneId) {
    TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
    telephonyManager.setSimStateForPhone(phoneId, state.toString());
    SubscriptionInfoUpdater subInfoUpdator = PhoneFactory.getSubscriptionInfoUpdater();
    if (subInfoUpdator != null) {
        subInfoUpdator.updateInternalIccState(UiccProfile.getIccStateIntentString(state), reason, phoneId);
    } else {
        Rlog.e(LOG_TAG, "subInfoUpdate is null.");
    }
}
#method_after
static void updateInternalIccState(Context context, IccCardConstants.State state, String reason, int phoneId) {
    TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
    telephonyManager.setSimStateForPhone(phoneId, state.toString());
    SubscriptionInfoUpdater subInfoUpdator = PhoneFactory.getSubscriptionInfoUpdater();
    if (subInfoUpdator != null) {
        subInfoUpdator.updateInternalIccState(getIccStateIntentString(state), reason, phoneId);
    } else {
        Rlog.e(LOG_TAG, "subInfoUpdate is null.");
    }
}
#end_block

#method_before
public static void insertTestReport(TestReportMessage report) {
    List<Entity> testEntityList = new ArrayList<>();
    List<Entity> branchEntityList = new ArrayList<>();
    List<Entity> buildTargetEntityList = new ArrayList<>();
    List<Entity> coverageEntityList = new ArrayList<>();
    List<Entity> profilingPointRunEntityList = new ArrayList<>();
    if (!report.hasStartTimestamp() || !report.hasEndTimestamp() || !report.hasTest() || !report.hasHostInfo() || !report.hasBuildInfo()) {
        // missing information
        return;
    }
    long startTimestamp = report.getStartTimestamp();
    long endTimestamp = report.getEndTimestamp();
    String testName = report.getTest().toStringUtf8();
    String testBuildId = report.getBuildInfo().getId().toStringUtf8();
    String hostName = report.getHostInfo().getHostname().toStringUtf8();
    TestEntity testEntity = new TestEntity(testName);
    Key testRunKey = KeyFactory.createKey(testEntity.getOldKey(), TestRunEntity.KIND, report.getStartTimestamp());
    long passCount = 0;
    long failCount = 0;
    long coveredLineCount = 0;
    long totalLineCount = 0;
    Set<Key> buildTargetKeys = new HashSet<>();
    Set<Key> branchKeys = new HashSet<>();
    List<TestCaseRunEntity> testCases = new ArrayList<>();
    List<Key> profilingPointKeys = new ArrayList<>();
    List<String> links = new ArrayList<>();
    // Process test cases
    for (TestCaseReportMessage testCase : report.getTestCaseList()) {
        String testCaseName = testCase.getName().toStringUtf8();
        TestCaseResult result = testCase.getTestResult();
        // Track global pass/fail counts
        if (result == TestCaseResult.TEST_CASE_RESULT_PASS) {
            ++passCount;
        } else if (result != TestCaseResult.TEST_CASE_RESULT_SKIP) {
            ++failCount;
        }
        if (testCase.getSystraceCount() > 0 && testCase.getSystraceList().get(0).getUrlCount() > 0) {
            String systraceLink = testCase.getSystraceList().get(0).getUrl(0).toStringUtf8();
            links.add(systraceLink);
        }
        // Process coverage data for test case
        for (CoverageReportMessage coverage : testCase.getCoverageList()) {
            CoverageEntity coverageEntity = CoverageEntity.fromCoverageReport(testRunKey, testCaseName, coverage);
            if (coverageEntity == null) {
                logger.log(Level.WARNING, "Invalid coverage report in test run " + testRunKey);
            } else {
                coveredLineCount += coverageEntity.getCoveredCount();
                totalLineCount += coverageEntity.getTotalCount();
                coverageEntityList.add(coverageEntity.toEntity());
            }
        }
        // Process profiling data for test case
        for (ProfilingReportMessage profiling : testCase.getProfilingList()) {
            ProfilingPointRunEntity profilingPointRunEntity = ProfilingPointRunEntity.fromProfilingReport(testRunKey, profiling);
            if (profilingPointRunEntity == null) {
                logger.log(Level.WARNING, "Invalid profiling report in test run " + testRunKey);
            } else {
                profilingPointRunEntityList.add(profilingPointRunEntity.toEntity());
                profilingPointKeys.add(profilingPointRunEntity.getKey());
                testEntity.setHasProfilingData(true);
            }
        }
        int lastIndex = testCases.size() - 1;
        if (lastIndex < 0 || testCases.get(lastIndex).isFull()) {
            testCases.add(new TestCaseRunEntity());
            ++lastIndex;
        }
        TestCaseRunEntity testCaseEntity = testCases.get(lastIndex);
        testCaseEntity.addTestCase(testCaseName, result.getNumber());
    }
    List<Entity> testCasePuts = new ArrayList<>();
    for (TestCaseRunEntity testCaseEntity : testCases) {
        testCasePuts.add(testCaseEntity.toEntity());
    }
    List<Key> testCaseKeys = datastore.put(testCasePuts);
    List<Long> testCaseIds = new ArrayList<>();
    for (Key key : testCaseKeys) {
        testCaseIds.add(key.getId());
    }
    // Process device information
    long testRunType = 0;
    for (AndroidDeviceInfoMessage device : report.getDeviceInfoList()) {
        DeviceInfoEntity deviceInfoEntity = DeviceInfoEntity.fromDeviceInfoMessage(testRunKey, device);
        if (deviceInfoEntity == null) {
            logger.log(Level.WARNING, "Invalid device info in test run " + testRunKey);
        } else {
            // Run type on devices must be the same, else set to OTHER
            TestRunType runType = TestRunType.fromBuildId(deviceInfoEntity.getBuildId());
            if (runType == null) {
                testRunType = TestRunType.OTHER.getNumber();
            } else {
                testRunType = runType.getNumber();
            }
            testEntityList.add(deviceInfoEntity.toEntity());
            BuildTargetEntity target = new BuildTargetEntity(deviceInfoEntity.getBuildFlavor());
            if (buildTargetKeys.add(target.key)) {
                buildTargetEntityList.add(target.toEntity());
            }
            BranchEntity branch = new BranchEntity(deviceInfoEntity.getBranch());
            if (branchKeys.add(branch.key)) {
                branchEntityList.add(branch.toEntity());
            }
        }
    }
    // Overall run type should be determined by the device builds unless test build is OTHER
    if (testRunType == TestRunType.OTHER.getNumber()) {
        testRunType = TestRunType.fromBuildId(testBuildId).getNumber();
    } else if (TestRunType.fromBuildId(testBuildId) == TestRunType.OTHER) {
        testRunType = TestRunType.OTHER.getNumber();
    }
    // Process global coverage data
    for (CoverageReportMessage coverage : report.getCoverageList()) {
        CoverageEntity coverageEntity = CoverageEntity.fromCoverageReport(testRunKey, new String(), coverage);
        if (coverageEntity == null) {
            logger.log(Level.WARNING, "Invalid coverage report in test run " + testRunKey);
        } else {
            coveredLineCount += coverageEntity.getCoveredCount();
            totalLineCount += coverageEntity.getTotalCount();
            coverageEntityList.add(coverageEntity.toEntity());
        }
    }
    // Process global API coverage data
    for (ApiCoverageReportMessage apiCoverage : report.getApiCoverageList()) {
        HalInterfaceMessage halInterfaceMessage = apiCoverage.getHalInterface();
        List<String> halApiList = apiCoverage.getHalApiList().stream().map(h -> h.toStringUtf8()).collect(Collectors.toList());
        List<String> coveredHalApiList = apiCoverage.getCoveredHalApiList().stream().map(h -> h.toStringUtf8()).collect(Collectors.toList());
        ApiCoverageEntity apiCoverageEntity = new ApiCoverageEntity(testRunKey, halInterfaceMessage.getHalPackageName().toStringUtf8(), halInterfaceMessage.getHalVersionMajor(), halInterfaceMessage.getHalVersionMinor(), halInterfaceMessage.getHalInterfaceName().toStringUtf8(), halApiList, coveredHalApiList);
        com.googlecode.objectify.Key apiCoverageEntityKey = apiCoverageEntity.save();
        if (apiCoverageEntityKey == null) {
            logger.log(Level.WARNING, "Invalid API coverage report in test run " + testRunKey);
        }
    }
    // Process global profiling data
    for (ProfilingReportMessage profiling : report.getProfilingList()) {
        ProfilingPointRunEntity profilingPointRunEntity = ProfilingPointRunEntity.fromProfilingReport(testRunKey, profiling);
        if (profilingPointRunEntity == null) {
            logger.log(Level.WARNING, "Invalid profiling report in test run " + testRunKey);
        } else {
            profilingPointRunEntityList.add(profilingPointRunEntity.toEntity());
            profilingPointKeys.add(profilingPointRunEntity.getKey());
            testEntity.setHasProfilingData(true);
        }
    }
    // Process log data
    for (LogMessage log : report.getLogList()) {
        if (log.hasUrl()) {
            links.add(log.getUrl().toStringUtf8());
        }
    }
    // Process url resource
    for (UrlResourceMessage resource : report.getLinkResourceList()) {
        if (resource.hasUrl()) {
            links.add(resource.getUrl().toStringUtf8());
        }
    }
    boolean hasCodeCoverage = totalLineCount > 0 && coveredLineCount >= 0;
    TestRunEntity testRunEntity = new TestRunEntity(testEntity.getOldKey(), testRunType, startTimestamp, endTimestamp, testBuildId, hostName, passCount, failCount, hasCodeCoverage);
    testEntityList.add(testRunEntity.toEntity());
    CodeCoverageEntity codeCoverageEntity = new CodeCoverageEntity(testRunEntity.getKey(), coveredLineCount, totalLineCount, testCaseIds, links);
    testEntityList.add(codeCoverageEntity.toEntity());
    Entity test = testEntity.toEntity();
    if (datastoreTransactionalRetry(test, testEntityList)) {
        List<List<Entity>> auxiliaryEntityList = Arrays.asList(profilingPointRunEntityList, coverageEntityList, branchEntityList, buildTargetEntityList);
        int indexCount = 0;
        for (List<Entity> entityList : auxiliaryEntityList) {
            switch(indexCount) {
                case 0:
                case 1:
                    if (entityList.size() > MAX_ENTITY_SIZE_PER_TRANSACTION) {
                        List<List<Entity>> partitionedList = Lists.partition(entityList, MAX_ENTITY_SIZE_PER_TRANSACTION);
                        partitionedList.forEach(subEntityList -> {
                            datastoreTransactionalRetry(new Entity(NULL_ENTITY_KIND), subEntityList);
                        });
                    } else {
                        datastoreTransactionalRetry(new Entity(NULL_ENTITY_KIND), entityList);
                    }
                    break;
                case 2:
                case 3:
                    datastoreTransactionalRetryWithXG(new Entity(NULL_ENTITY_KIND), entityList, true);
                    break;
                default:
                    break;
            }
            indexCount++;
        }
        if (testRunEntity.getType() == TestRunType.POSTSUBMIT.getNumber()) {
            VtsAlertJobServlet.addTask(testRunKey);
            if (testRunEntity.isHasCodeCoverage()) {
                VtsCoverageAlertJobServlet.addTask(testRunKey);
            }
            if (profilingPointKeys.size() > 0) {
                VtsProfilingStatsJobServlet.addTasks(profilingPointKeys);
            }
        } else {
            logger.log(Level.WARNING, "The alert email was not sent as testRunEntity type is not POSTSUBMIT!" + " \n " + " testRunEntity type => " + testRunEntity.getType());
        }
    }
}
#method_after
public static void insertTestReport(TestReportMessage report) {
    List<Entity> testEntityList = new ArrayList<>();
    List<Entity> branchEntityList = new ArrayList<>();
    List<Entity> buildTargetEntityList = new ArrayList<>();
    List<Entity> coverageEntityList = new ArrayList<>();
    List<Entity> profilingPointRunEntityList = new ArrayList<>();
    if (!report.hasStartTimestamp() || !report.hasEndTimestamp() || !report.hasTest() || !report.hasHostInfo() || !report.hasBuildInfo()) {
        // missing information
        return;
    }
    long startTimestamp = report.getStartTimestamp();
    long endTimestamp = report.getEndTimestamp();
    String testName = report.getTest().toStringUtf8();
    String testBuildId = report.getBuildInfo().getId().toStringUtf8();
    String hostName = report.getHostInfo().getHostname().toStringUtf8();
    TestEntity testEntity = new TestEntity(testName);
    Key testRunKey = KeyFactory.createKey(testEntity.getOldKey(), TestRunEntity.KIND, report.getStartTimestamp());
    long passCount = 0;
    long failCount = 0;
    long coveredLineCount = 0;
    long totalLineCount = 0;
    Set<Key> buildTargetKeys = new HashSet<>();
    Set<Key> branchKeys = new HashSet<>();
    List<TestCaseRunEntity> testCases = new ArrayList<>();
    List<Key> profilingPointKeys = new ArrayList<>();
    List<String> links = new ArrayList<>();
    // Process test cases
    for (TestCaseReportMessage testCase : report.getTestCaseList()) {
        String testCaseName = testCase.getName().toStringUtf8();
        TestCaseResult result = testCase.getTestResult();
        // Track global pass/fail counts
        if (result == TestCaseResult.TEST_CASE_RESULT_PASS) {
            ++passCount;
        } else if (result != TestCaseResult.TEST_CASE_RESULT_SKIP) {
            ++failCount;
        }
        if (testCase.getSystraceCount() > 0 && testCase.getSystraceList().get(0).getUrlCount() > 0) {
            String systraceLink = testCase.getSystraceList().get(0).getUrl(0).toStringUtf8();
            links.add(systraceLink);
        }
        // Process coverage data for test case
        for (CoverageReportMessage coverage : testCase.getCoverageList()) {
            CoverageEntity coverageEntity = CoverageEntity.fromCoverageReport(testRunKey, testCaseName, coverage);
            if (coverageEntity == null) {
                logger.log(Level.WARNING, "Invalid coverage report in test run " + testRunKey);
            } else {
                coveredLineCount += coverageEntity.getCoveredCount();
                totalLineCount += coverageEntity.getTotalCount();
                coverageEntityList.add(coverageEntity.toEntity());
            }
        }
        // Process profiling data for test case
        for (ProfilingReportMessage profiling : testCase.getProfilingList()) {
            ProfilingPointRunEntity profilingPointRunEntity = ProfilingPointRunEntity.fromProfilingReport(testRunKey, profiling);
            if (profilingPointRunEntity == null) {
                logger.log(Level.WARNING, "Invalid profiling report in test run " + testRunKey);
            } else {
                profilingPointRunEntityList.add(profilingPointRunEntity.toEntity());
                profilingPointKeys.add(profilingPointRunEntity.getKey());
                testEntity.setHasProfilingData(true);
            }
        }
        int lastIndex = testCases.size() - 1;
        if (lastIndex < 0 || testCases.get(lastIndex).isFull()) {
            testCases.add(new TestCaseRunEntity());
            ++lastIndex;
        }
        TestCaseRunEntity testCaseEntity = testCases.get(lastIndex);
        testCaseEntity.addTestCase(testCaseName, result.getNumber());
    }
    List<Entity> testCasePuts = new ArrayList<>();
    for (TestCaseRunEntity testCaseEntity : testCases) {
        testCasePuts.add(testCaseEntity.toEntity());
    }
    List<Key> testCaseKeys = datastore.put(testCasePuts);
    List<Long> testCaseIds = new ArrayList<>();
    for (Key key : testCaseKeys) {
        testCaseIds.add(key.getId());
    }
    // Process device information
    long testRunType = 0;
    for (AndroidDeviceInfoMessage device : report.getDeviceInfoList()) {
        DeviceInfoEntity deviceInfoEntity = DeviceInfoEntity.fromDeviceInfoMessage(testRunKey, device);
        if (deviceInfoEntity == null) {
            logger.log(Level.WARNING, "Invalid device info in test run " + testRunKey);
        } else {
            // Run type on devices must be the same, else set to OTHER
            TestRunType runType = TestRunType.fromBuildId(deviceInfoEntity.getBuildId());
            if (runType == null) {
                testRunType = TestRunType.OTHER.getNumber();
            } else {
                testRunType = runType.getNumber();
            }
            testEntityList.add(deviceInfoEntity.toEntity());
            BuildTargetEntity target = new BuildTargetEntity(deviceInfoEntity.getBuildFlavor());
            if (buildTargetKeys.add(target.key)) {
                buildTargetEntityList.add(target.toEntity());
            }
            BranchEntity branch = new BranchEntity(deviceInfoEntity.getBranch());
            if (branchKeys.add(branch.key)) {
                branchEntityList.add(branch.toEntity());
            }
        }
    }
    // Overall run type should be determined by the device builds unless test build is OTHER
    if (testRunType == TestRunType.OTHER.getNumber()) {
        testRunType = TestRunType.fromBuildId(testBuildId).getNumber();
    } else if (TestRunType.fromBuildId(testBuildId) == TestRunType.OTHER) {
        testRunType = TestRunType.OTHER.getNumber();
    }
    // Process global coverage data
    for (CoverageReportMessage coverage : report.getCoverageList()) {
        CoverageEntity coverageEntity = CoverageEntity.fromCoverageReport(testRunKey, new String(), coverage);
        if (coverageEntity == null) {
            logger.log(Level.WARNING, "Invalid coverage report in test run " + testRunKey);
        } else {
            coveredLineCount += coverageEntity.getCoveredCount();
            totalLineCount += coverageEntity.getTotalCount();
            coverageEntityList.add(coverageEntity.toEntity());
        }
    }
    // Process global API coverage data
    for (ApiCoverageReportMessage apiCoverage : report.getApiCoverageList()) {
        HalInterfaceMessage halInterfaceMessage = apiCoverage.getHalInterface();
        List<String> halApiList = apiCoverage.getHalApiList().stream().map(h -> h.toStringUtf8()).collect(Collectors.toList());
        List<String> coveredHalApiList = apiCoverage.getCoveredHalApiList().stream().map(h -> h.toStringUtf8()).collect(Collectors.toList());
        ApiCoverageEntity apiCoverageEntity = new ApiCoverageEntity(testRunKey, halInterfaceMessage.getHalPackageName().toStringUtf8(), halInterfaceMessage.getHalVersionMajor(), halInterfaceMessage.getHalVersionMinor(), halInterfaceMessage.getHalInterfaceName().toStringUtf8(), halApiList, coveredHalApiList);
        com.googlecode.objectify.Key apiCoverageEntityKey = apiCoverageEntity.save();
        if (apiCoverageEntityKey == null) {
            logger.log(Level.WARNING, "Invalid API coverage report in test run " + testRunKey);
        }
    }
    // Process global profiling data
    for (ProfilingReportMessage profiling : report.getProfilingList()) {
        ProfilingPointRunEntity profilingPointRunEntity = ProfilingPointRunEntity.fromProfilingReport(testRunKey, profiling);
        if (profilingPointRunEntity == null) {
            logger.log(Level.WARNING, "Invalid profiling report in test run " + testRunKey);
        } else {
            profilingPointRunEntityList.add(profilingPointRunEntity.toEntity());
            profilingPointKeys.add(profilingPointRunEntity.getKey());
            testEntity.setHasProfilingData(true);
        }
    }
    // Process log data
    for (LogMessage log : report.getLogList()) {
        if (log.hasUrl()) {
            links.add(log.getUrl().toStringUtf8());
        }
    }
    // Process url resource
    for (UrlResourceMessage resource : report.getLinkResourceList()) {
        if (resource.hasUrl()) {
            links.add(resource.getUrl().toStringUtf8());
        }
    }
    boolean hasCodeCoverage = totalLineCount > 0 && coveredLineCount >= 0;
    TestRunEntity testRunEntity = new TestRunEntity(testEntity.getOldKey(), testRunType, startTimestamp, endTimestamp, testBuildId, hostName, passCount, failCount, hasCodeCoverage, testCaseIds, links);
    testEntityList.add(testRunEntity.toEntity());
    CodeCoverageEntity codeCoverageEntity = new CodeCoverageEntity(testRunEntity.getKey(), coveredLineCount, totalLineCount);
    testEntityList.add(codeCoverageEntity.toEntity());
    Entity test = testEntity.toEntity();
    if (datastoreTransactionalRetry(test, testEntityList)) {
        List<List<Entity>> auxiliaryEntityList = Arrays.asList(profilingPointRunEntityList, coverageEntityList, branchEntityList, buildTargetEntityList);
        int indexCount = 0;
        for (List<Entity> entityList : auxiliaryEntityList) {
            switch(indexCount) {
                case 0:
                case 1:
                    if (entityList.size() > MAX_ENTITY_SIZE_PER_TRANSACTION) {
                        List<List<Entity>> partitionedList = Lists.partition(entityList, MAX_ENTITY_SIZE_PER_TRANSACTION);
                        partitionedList.forEach(subEntityList -> {
                            datastoreTransactionalRetry(new Entity(NULL_ENTITY_KIND), subEntityList);
                        });
                    } else {
                        datastoreTransactionalRetry(new Entity(NULL_ENTITY_KIND), entityList);
                    }
                    break;
                case 2:
                case 3:
                    datastoreTransactionalRetryWithXG(new Entity(NULL_ENTITY_KIND), entityList, true);
                    break;
                default:
                    break;
            }
            indexCount++;
        }
        if (testRunEntity.getType() == TestRunType.POSTSUBMIT.getNumber()) {
            VtsAlertJobServlet.addTask(testRunKey);
            if (testRunEntity.isHasCodeCoverage()) {
                VtsCoverageAlertJobServlet.addTask(testRunKey);
            }
            if (profilingPointKeys.size() > 0) {
                VtsProfilingStatsJobServlet.addTasks(profilingPointKeys);
            }
        } else {
            logger.log(Level.WARNING, "The alert email was not sent as testRunEntity type is not POSTSUBMIT!" + " \n " + " testRunEntity type => " + testRunEntity.getType());
        }
    }
}
#end_block

#method_before
public static TestRunDetails processTestDetails(TestRunMetadata metadata) {
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    TestRunDetails details = new TestRunDetails();
    List<Key> gets = new ArrayList<>();
    for (long testCaseId : metadata.testRun.getCodeCoverageEntity(false).getTestCaseIds()) {
        gets.add(KeyFactory.createKey(TestCaseRunEntity.KIND, testCaseId));
    }
    Map<Key, Entity> entityMap = datastore.get(gets);
    for (int i = 0; i < 1; i++) {
        for (Key key : entityMap.keySet()) {
            TestCaseRunEntity testCaseRun = TestCaseRunEntity.fromEntity(entityMap.get(key));
            if (testCaseRun == null) {
                continue;
            }
            details.addTestCase(testCaseRun);
        }
    }
    return details;
}
#method_after
public static TestRunDetails processTestDetails(TestRunMetadata metadata) {
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    TestRunDetails details = new TestRunDetails();
    List<Key> gets = new ArrayList<>();
    for (long testCaseId : metadata.testRun.getTestCaseIds()) {
        gets.add(KeyFactory.createKey(TestCaseRunEntity.KIND, testCaseId));
    }
    Map<Key, Entity> entityMap = datastore.get(gets);
    for (int i = 0; i < 1; i++) {
        for (Key key : entityMap.keySet()) {
            TestCaseRunEntity testCaseRun = TestCaseRunEntity.fromEntity(entityMap.get(key));
            if (testCaseRun == null) {
                continue;
            }
            details.addTestCase(testCaseRun);
        }
    }
    return details;
}
#end_block

#method_before
public void processReport() {
    if (getSize() > 0) {
        processDeviceInfos();
        processProfilingPoints();
    }
    testRuns.sort((t1, t2) -> new Long(t2.getStartTimestamp()).compareTo(t1.getStartTimestamp()));
    generateToTBreakdown();
    headerRow = new String[testRuns.size() + 1];
    headerRow[0] = StringUtils.join(HEADER_NAMES, "<br>");
    summaryGrid = new String[SUMMARY_NAMES.length][testRuns.size() + 1];
    for (int i = 0; i < SUMMARY_NAMES.length; i++) {
        summaryGrid[i][0] = "<b>" + SUMMARY_NAMES[i] + "</b>";
    }
    timeGrid = new String[TIME_INFO_NAMES.length][testRuns.size() + 1];
    for (int i = 0; i < TIME_INFO_NAMES.length; i++) {
        timeGrid[i][0] = "<b>" + TIME_INFO_NAMES[i] + "</b>";
    }
    durationGrid = new String[DURATION_INFO_NAMES.length][testRuns.size() + 1];
    for (int i = 0; i < DURATION_INFO_NAMES.length; i++) {
        durationGrid[i][0] = "<b>" + DURATION_INFO_NAMES[i] + "</b>";
    }
    resultsGrid = new String[testCaseNameMap.size()][testRuns.size() + 1];
    // first column for results grid
    for (String testCaseName : testCaseNameMap.keySet()) {
        resultsGrid[testCaseNameMap.get(testCaseName)][0] = testCaseName;
    }
    // Iterate through the test runs
    for (int col = 0; col < testRuns.size(); col++) {
        TestRunEntity testRun = testRuns.get(col);
        CodeCoverageEntity codeCoverageEntity = testRun.getCodeCoverageEntity(false);
        // Process the device information
        List<DeviceInfoEntity> devices = deviceInfoMap.get(testRun.getKey());
        List<String> buildIdList = new ArrayList<>();
        List<String> buildAliasList = new ArrayList<>();
        List<String> buildFlavorList = new ArrayList<>();
        List<String> productVariantList = new ArrayList<>();
        List<String> abiInfoList = new ArrayList<>();
        for (DeviceInfoEntity deviceInfoEntity : devices) {
            buildAliasList.add(deviceInfoEntity.getBranch());
            buildFlavorList.add(deviceInfoEntity.getBuildFlavor());
            productVariantList.add(deviceInfoEntity.getProduct());
            buildIdList.add(deviceInfoEntity.getBuildId());
            String abi = "";
            String abiName = deviceInfoEntity.getAbiName();
            String abiBitness = deviceInfoEntity.getAbiBitness();
            if (abiName.length() > 0) {
                abi += abiName;
                if (abiBitness.length() > 0) {
                    abi += " (" + abiBitness + " bit)";
                }
            }
            abiInfoList.add(abi);
        }
        String buildAlias = StringUtils.join(buildAliasList, ",");
        String buildFlavor = StringUtils.join(buildFlavorList, ",");
        String productVariant = StringUtils.join(productVariantList, ",");
        String buildIds = StringUtils.join(buildIdList, ",");
        String abiInfo = StringUtils.join(abiInfoList, ",");
        String vtsBuildId = testRun.getTestBuildId();
        int totalCount = 0;
        int passCount = (int) testRun.getPassCount();
        int nonpassCount = (int) testRun.getFailCount();
        TestCaseResult aggregateStatus = TestCaseResult.UNKNOWN_RESULT;
        long totalLineCount = codeCoverageEntity.getTotalLineCount();
        long coveredLineCount = codeCoverageEntity.getCoveredLineCount();
        // Process test case results
        for (TestCaseRunEntity testCaseEntity : testCaseRunMap.get(testRun.getKey())) {
            // Update the aggregated test run status
            totalCount += testCaseEntity.testCases.size();
            for (TestCase testCase : testCaseEntity.testCases) {
                int result = testCase.result;
                String name = testCase.name;
                if (result == TestCaseResult.TEST_CASE_RESULT_PASS.getNumber()) {
                    if (aggregateStatus == TestCaseResult.UNKNOWN_RESULT) {
                        aggregateStatus = TestCaseResult.TEST_CASE_RESULT_PASS;
                    }
                } else if (result != TestCaseResult.TEST_CASE_RESULT_SKIP.getNumber()) {
                    aggregateStatus = TestCaseResult.TEST_CASE_RESULT_FAIL;
                }
                String systraceUrl = null;
                if (testCaseEntity.getSystraceUrl() != null) {
                    String url = testCaseEntity.getSystraceUrl();
                    LinkDisplay validatedLink = UrlUtil.processUrl(url);
                    if (validatedLink != null) {
                        systraceUrl = validatedLink.url;
                    } else {
                        logger.log(Level.WARNING, "Invalid systrace URL : " + url);
                    }
                }
                int index = testCaseNameMap.get(name);
                String classNames = "test-case-status ";
                String glyph = "";
                TestCaseResult testCaseResult = TestCaseResult.valueOf(result);
                if (testCaseResult != null)
                    classNames += testCaseResult.toString();
                else
                    classNames += TestCaseResult.UNKNOWN_RESULT.toString();
                if (systraceUrl != null) {
                    classNames += " width-1";
                    glyph += "<a href=\"" + systraceUrl + "\" " + "class=\"waves-effect waves-light btn red right inline-btn\">" + "<i class=\"material-icons inline-icon\">info_outline</i></a>";
                }
                resultsGrid[index][col + 1] = "<div class=\"" + classNames + "\">&nbsp;</div>" + glyph;
            }
        }
        String passInfo;
        try {
            double passPct = Math.round((100 * passCount / (passCount + nonpassCount)) * 100f) / 100f;
            passInfo = Double.toString(passPct) + "%";
        } catch (ArithmeticException e) {
            passInfo = " - ";
        }
        // Process coverage metadata
        String coverageInfo;
        String coveragePctInfo;
        try {
            double coveragePct = Math.round((100 * coveredLineCount / totalLineCount) * 100f) / 100f;
            coveragePctInfo = Double.toString(coveragePct) + "%" + "<a href=\"/show_coverage?testName=" + testName + "&startTime=" + testRun.getStartTimestamp() + "\" class=\"waves-effect waves-light btn red right inline-btn\">" + "<i class=\"material-icons inline-icon\">menu</i></a>";
            coverageInfo = coveredLineCount + "/" + totalLineCount;
        } catch (ArithmeticException e) {
            coveragePctInfo = " - ";
            coverageInfo = " - ";
        }
        // Process log information
        String linkSummary = " - ";
        List<String[]> linkEntries = new ArrayList<>();
        logInfoMap.put(Integer.toString(col), linkEntries);
        if (codeCoverageEntity.getLogLinks() != null) {
            for (String rawUrl : codeCoverageEntity.getLogLinks()) {
                LinkDisplay validatedLink = UrlUtil.processUrl(rawUrl);
                if (validatedLink == null) {
                    logger.log(Level.WARNING, "Invalid logging URL : " + rawUrl);
                    continue;
                }
                String[] logInfo = new String[] { validatedLink.name, // TODO: process the name from the URL
                validatedLink.url };
                linkEntries.add(logInfo);
            }
        }
        if (linkEntries.size() > 0) {
            linkSummary = Integer.toString(linkEntries.size());
            linkSummary += "<i class=\"waves-effect waves-light btn red right inline-btn" + " info-btn material-icons inline-icon\"" + " data-col=\"" + Integer.toString(col) + "\"" + ">launch</i>";
        }
        String icon = "<div class='status-icon " + aggregateStatus.toString() + "'>&nbsp</div>";
        String hostname = testRun.getHostName();
        // Populate the header row
        headerRow[col + 1] = "<span class='valign-wrapper'><b>" + buildIds + "</b>" + icon + "</span>" + buildAlias + "<br>" + buildFlavor + "<br>" + productVariant + "<br>" + abiInfo + "<br>" + vtsBuildId + "<br>" + hostname;
        // Populate the test summary grid
        summaryGrid[0][col + 1] = Integer.toString(totalCount);
        summaryGrid[1][col + 1] = Integer.toString(passCount);
        summaryGrid[2][col + 1] = Integer.toString(nonpassCount);
        summaryGrid[3][col + 1] = passInfo;
        summaryGrid[4][col + 1] = coverageInfo;
        summaryGrid[5][col + 1] = coveragePctInfo;
        summaryGrid[6][col + 1] = linkSummary;
        // Populate the test time info grid
        timeGrid[0][col + 1] = Long.toString(testRun.getStartTimestamp());
        timeGrid[1][col + 1] = Long.toString(testRun.getEndTimestamp());
        // Populate the test duration info grid
        durationGrid[0][col + 1] = Long.toString(testRun.getEndTimestamp() - testRun.getStartTimestamp());
    }
    profilingPointNames = profilingPointNameSet.toArray(new String[profilingPointNameSet.size()]);
    Arrays.sort(profilingPointNames);
}
#method_after
public void processReport() {
    if (getSize() > 0) {
        processDeviceInfos();
        processProfilingPoints();
    }
    testRuns.sort((t1, t2) -> new Long(t2.getStartTimestamp()).compareTo(t1.getStartTimestamp()));
    generateToTBreakdown();
    headerRow = new String[testRuns.size() + 1];
    headerRow[0] = StringUtils.join(HEADER_NAMES, "<br>");
    summaryGrid = new String[SUMMARY_NAMES.length][testRuns.size() + 1];
    for (int i = 0; i < SUMMARY_NAMES.length; i++) {
        summaryGrid[i][0] = "<b>" + SUMMARY_NAMES[i] + "</b>";
    }
    timeGrid = new String[TIME_INFO_NAMES.length][testRuns.size() + 1];
    for (int i = 0; i < TIME_INFO_NAMES.length; i++) {
        timeGrid[i][0] = "<b>" + TIME_INFO_NAMES[i] + "</b>";
    }
    durationGrid = new String[DURATION_INFO_NAMES.length][testRuns.size() + 1];
    for (int i = 0; i < DURATION_INFO_NAMES.length; i++) {
        durationGrid[i][0] = "<b>" + DURATION_INFO_NAMES[i] + "</b>";
    }
    resultsGrid = new String[testCaseNameMap.size()][testRuns.size() + 1];
    // first column for results grid
    for (String testCaseName : testCaseNameMap.keySet()) {
        resultsGrid[testCaseNameMap.get(testCaseName)][0] = testCaseName;
    }
    // Iterate through the test runs
    for (int col = 0; col < testRuns.size(); col++) {
        TestRunEntity testRun = testRuns.get(col);
        CodeCoverageEntity codeCoverageEntity = testRun.getCodeCoverageEntity();
        // Process the device information
        List<DeviceInfoEntity> devices = deviceInfoMap.get(testRun.getKey());
        List<String> buildIdList = new ArrayList<>();
        List<String> buildAliasList = new ArrayList<>();
        List<String> buildFlavorList = new ArrayList<>();
        List<String> productVariantList = new ArrayList<>();
        List<String> abiInfoList = new ArrayList<>();
        for (DeviceInfoEntity deviceInfoEntity : devices) {
            buildAliasList.add(deviceInfoEntity.getBranch());
            buildFlavorList.add(deviceInfoEntity.getBuildFlavor());
            productVariantList.add(deviceInfoEntity.getProduct());
            buildIdList.add(deviceInfoEntity.getBuildId());
            String abi = "";
            String abiName = deviceInfoEntity.getAbiName();
            String abiBitness = deviceInfoEntity.getAbiBitness();
            if (abiName.length() > 0) {
                abi += abiName;
                if (abiBitness.length() > 0) {
                    abi += " (" + abiBitness + " bit)";
                }
            }
            abiInfoList.add(abi);
        }
        String buildAlias = StringUtils.join(buildAliasList, ",");
        String buildFlavor = StringUtils.join(buildFlavorList, ",");
        String productVariant = StringUtils.join(productVariantList, ",");
        String buildIds = StringUtils.join(buildIdList, ",");
        String abiInfo = StringUtils.join(abiInfoList, ",");
        String vtsBuildId = testRun.getTestBuildId();
        int totalCount = 0;
        int passCount = (int) testRun.getPassCount();
        int nonpassCount = (int) testRun.getFailCount();
        TestCaseResult aggregateStatus = TestCaseResult.UNKNOWN_RESULT;
        long totalLineCount = 0;
        long coveredLineCount = 0;
        if (testRun.isHasCodeCoverage()) {
            totalLineCount = codeCoverageEntity.getTotalLineCount();
            coveredLineCount = codeCoverageEntity.getCoveredLineCount();
        }
        // Process test case results
        for (TestCaseRunEntity testCaseEntity : testCaseRunMap.get(testRun.getKey())) {
            // Update the aggregated test run status
            totalCount += testCaseEntity.testCases.size();
            for (TestCase testCase : testCaseEntity.testCases) {
                int result = testCase.result;
                String name = testCase.name;
                if (result == TestCaseResult.TEST_CASE_RESULT_PASS.getNumber()) {
                    if (aggregateStatus == TestCaseResult.UNKNOWN_RESULT) {
                        aggregateStatus = TestCaseResult.TEST_CASE_RESULT_PASS;
                    }
                } else if (result != TestCaseResult.TEST_CASE_RESULT_SKIP.getNumber()) {
                    aggregateStatus = TestCaseResult.TEST_CASE_RESULT_FAIL;
                }
                String systraceUrl = null;
                if (testCaseEntity.getSystraceUrl() != null) {
                    String url = testCaseEntity.getSystraceUrl();
                    LinkDisplay validatedLink = UrlUtil.processUrl(url);
                    if (validatedLink != null) {
                        systraceUrl = validatedLink.url;
                    } else {
                        logger.log(Level.WARNING, "Invalid systrace URL : " + url);
                    }
                }
                int index = testCaseNameMap.get(name);
                String classNames = "test-case-status ";
                String glyph = "";
                TestCaseResult testCaseResult = TestCaseResult.valueOf(result);
                if (testCaseResult != null)
                    classNames += testCaseResult.toString();
                else
                    classNames += TestCaseResult.UNKNOWN_RESULT.toString();
                if (systraceUrl != null) {
                    classNames += " width-1";
                    glyph += "<a href=\"" + systraceUrl + "\" " + "class=\"waves-effect waves-light btn red right inline-btn\">" + "<i class=\"material-icons inline-icon\">info_outline</i></a>";
                }
                resultsGrid[index][col + 1] = "<div class=\"" + classNames + "\">&nbsp;</div>" + glyph;
            }
        }
        String passInfo;
        try {
            double passPct = Math.round((100 * passCount / (passCount + nonpassCount)) * 100f) / 100f;
            passInfo = Double.toString(passPct) + "%";
        } catch (ArithmeticException e) {
            passInfo = " - ";
        }
        // Process coverage metadata
        String coverageInfo;
        String coveragePctInfo;
        try {
            double coveragePct = Math.round((100 * coveredLineCount / totalLineCount) * 100f) / 100f;
            coveragePctInfo = Double.toString(coveragePct) + "%" + "<a href=\"/show_coverage?testName=" + testName + "&startTime=" + testRun.getStartTimestamp() + "\" class=\"waves-effect waves-light btn red right inline-btn\">" + "<i class=\"material-icons inline-icon\">menu</i></a>";
            coverageInfo = coveredLineCount + "/" + totalLineCount;
        } catch (ArithmeticException e) {
            coveragePctInfo = " - ";
            coverageInfo = " - ";
        }
        // Process log information
        String linkSummary = " - ";
        List<String[]> linkEntries = new ArrayList<>();
        logInfoMap.put(Integer.toString(col), linkEntries);
        if (testRun.getLogLinks() != null) {
            for (String rawUrl : testRun.getLogLinks()) {
                LinkDisplay validatedLink = UrlUtil.processUrl(rawUrl);
                if (validatedLink == null) {
                    logger.log(Level.WARNING, "Invalid logging URL : " + rawUrl);
                    continue;
                }
                String[] logInfo = new String[] { validatedLink.name, // TODO: process the name from the URL
                validatedLink.url };
                linkEntries.add(logInfo);
            }
        }
        if (linkEntries.size() > 0) {
            linkSummary = Integer.toString(linkEntries.size());
            linkSummary += "<i class=\"waves-effect waves-light btn red right inline-btn" + " info-btn material-icons inline-icon\"" + " data-col=\"" + Integer.toString(col) + "\"" + ">launch</i>";
        }
        String icon = "<div class='status-icon " + aggregateStatus.toString() + "'>&nbsp</div>";
        String hostname = testRun.getHostName();
        // Populate the header row
        headerRow[col + 1] = "<span class='valign-wrapper'><b>" + buildIds + "</b>" + icon + "</span>" + buildAlias + "<br>" + buildFlavor + "<br>" + productVariant + "<br>" + abiInfo + "<br>" + vtsBuildId + "<br>" + hostname;
        // Populate the test summary grid
        summaryGrid[0][col + 1] = Integer.toString(totalCount);
        summaryGrid[1][col + 1] = Integer.toString(passCount);
        summaryGrid[2][col + 1] = Integer.toString(nonpassCount);
        summaryGrid[3][col + 1] = passInfo;
        summaryGrid[4][col + 1] = coverageInfo;
        summaryGrid[5][col + 1] = coveragePctInfo;
        summaryGrid[6][col + 1] = linkSummary;
        // Populate the test time info grid
        timeGrid[0][col + 1] = Long.toString(testRun.getStartTimestamp());
        timeGrid[1][col + 1] = Long.toString(testRun.getEndTimestamp());
        // Populate the test duration info grid
        durationGrid[0][col + 1] = Long.toString(testRun.getEndTimestamp() - testRun.getStartTimestamp());
    }
    profilingPointNames = profilingPointNameSet.toArray(new String[profilingPointNameSet.size()]);
    Arrays.sort(profilingPointNames);
}
#end_block

#method_before
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
    if (SystemProperty.environment.value() == SystemProperty.Environment.Value.Production) {
        response.setStatus(HttpServletResponse.SC_NOT_ACCEPTABLE);
        return;
    }
    UserService userService = UserServiceFactory.getUserService();
    User currentUser = userService.getCurrentUser();
    String pathInfo = request.getPathInfo();
    String[] pathParts = pathInfo.split("/");
    if (pathParts.length > 1) {
        // Read the json output
        Reader postJsonReader = new InputStreamReader(request.getInputStream());
        Gson gson = new GsonBuilder().create();
        String testType = pathParts[1];
        if (testType.equalsIgnoreCase("report")) {
            TestReportDataObject trdObj = gson.fromJson(postJsonReader, TestReportDataObject.class);
            logger.log(Level.INFO, "trdObj => " + trdObj);
            trdObj.testList.forEach(test -> {
                test.testRunList.forEach(testRun -> {
                    TestEntity testEntity = new TestEntity(testRun.testName);
                    Key testRunKey = KeyFactory.createKey(testEntity.getOldKey(), TestRunEntity.KIND, testRun.startTimestamp);
                    List<TestCaseReference> failingTestCases = new ArrayList<>();
                    for (int idx = 0; idx < testRun.failingTestcaseIds.size(); idx++) {
                        failingTestCases.add(new TestCaseReference(testRun.failingTestcaseIds.get(idx), testRun.failingTestcaseOffsets.get(idx)));
                    }
                    TestStatusEntity testStatusEntity = new TestStatusEntity(testRun.testName, testRun.startTimestamp, (int) testRun.passCount, failingTestCases.size(), failingTestCases);
                    datastore.put(testStatusEntity.toEntity());
                    testRun.coverageList.forEach(testRunCoverage -> {
                        CoverageEntity coverageEntity = new CoverageEntity(testRunKey, testRunCoverage.group, testRunCoverage.coveredLineCount, testRunCoverage.totalLineCount, testRunCoverage.filePath, testRunCoverage.projectName, testRunCoverage.projectVersion, testRunCoverage.lineCoverage);
                        datastore.put(coverageEntity.toEntity());
                    });
                    testRun.profilingList.forEach(testRunProfile -> {
                        ProfilingPointRunEntity profilingEntity = new ProfilingPointRunEntity(testRunKey, testRunProfile.name, testRunProfile.type, testRunProfile.regressionMode, testRunProfile.labels, testRunProfile.values, testRunProfile.xLabel, testRunProfile.yLabel, testRunProfile.options);
                        datastore.put(profilingEntity.toEntity());
                    });
                    TestCaseRunEntity testCaseEntity = new TestCaseRunEntity();
                    testRun.testCaseRunList.forEach(testCaseRun -> {
                        for (int idx = 0; idx < testCaseRun.testCaseNames.size(); idx++) {
                            testCaseEntity.addTestCase(testCaseRun.testCaseNames.get(idx), testCaseRun.results.get(idx));
                        }
                    });
                    datastore.put(testCaseEntity.toEntity());
                    testRun.deviceInfoList.forEach(deviceInfo -> {
                        DeviceInfoEntity deviceInfoEntity = new DeviceInfoEntity(testRunKey, deviceInfo.branch, deviceInfo.product, deviceInfo.buildFlavor, deviceInfo.buildId, deviceInfo.abiBitness, deviceInfo.abiName);
                        ;
                        datastore.put(deviceInfoEntity.toEntity());
                    });
                    testRun.buildTargetList.forEach(buildTarget -> {
                        BuildTargetEntity buildTargetEntity = new BuildTargetEntity(buildTarget.targetName);
                        datastore.put(buildTargetEntity.toEntity());
                    });
                    testRun.branchList.forEach(branch -> {
                        BranchEntity branchEntity = new BranchEntity(branch.branchName);
                        datastore.put(branchEntity.toEntity());
                    });
                    boolean hasCodeCoverage = testRun.totalLineCount > 0 && testRun.coveredLineCount >= 0;
                    TestRunEntity testRunEntity = new TestRunEntity(testEntity.getOldKey(), testRun.type, testRun.startTimestamp, testRun.endTimestamp, testRun.testBuildId, testRun.hostName, testRun.passCount, testRun.failCount, hasCodeCoverage);
                    datastore.put(testRunEntity.toEntity());
                    CodeCoverageEntity codeCoverageEntity = new CodeCoverageEntity(testRunEntity.getKey(), testRun.coveredLineCount, testRun.totalLineCount, testRun.testCaseIds, testRun.links);
                    datastore.put(codeCoverageEntity.toEntity());
                    Entity newTestEntity = testEntity.toEntity();
                    Transaction txn = datastore.beginTransaction();
                    try {
                        // Check if test already exists in the datastore
                        try {
                            Entity oldTest = datastore.get(testEntity.getOldKey());
                            TestEntity oldTestEntity = TestEntity.fromEntity(oldTest);
                            if (oldTestEntity == null || !oldTestEntity.equals(testEntity)) {
                                datastore.put(newTestEntity);
                            }
                        } catch (EntityNotFoundException e) {
                            datastore.put(newTestEntity);
                        }
                        txn.commit();
                    } catch (ConcurrentModificationException | DatastoreFailureException | DatastoreTimeoutException e) {
                        logger.log(Level.WARNING, "Retrying test run insert: " + newTestEntity.getKey());
                    } finally {
                        if (txn.isActive()) {
                            logger.log(Level.WARNING, "Transaction rollback forced for run: " + testRunEntity.getKey());
                            txn.rollback();
                        }
                    }
                });
            });
        } else {
            TestPlanReportDataObject tprdObj = gson.fromJson(postJsonReader, TestPlanReportDataObject.class);
            tprdObj.testPlanList.forEach(testPlan -> {
                Entity testPlanEntity = new TestPlanEntity(testPlan.testPlanName).toEntity();
                List<Key> testRunKeys = new ArrayList<>();
                for (int idx = 0; idx < testPlan.testModules.size(); idx++) {
                    String test = testPlan.testModules.get(idx);
                    long time = testPlan.testTimes.get(idx);
                    Key parentKey = KeyFactory.createKey(TestEntity.KIND, test);
                    Key testRunKey = KeyFactory.createKey(parentKey, TestRunEntity.KIND, time);
                    testRunKeys.add(testRunKey);
                }
                Map<Key, Entity> testRuns = datastore.get(testRunKeys);
                long passCount = 0;
                long failCount = 0;
                long startTimestamp = -1;
                long endTimestamp = -1;
                String testBuildId = null;
                long type = 0;
                Set<DeviceInfoEntity> devices = new HashSet<>();
                for (Key testRunKey : testRuns.keySet()) {
                    TestRunEntity testRun = TestRunEntity.fromEntity(testRuns.get(testRunKey));
                    if (testRun == null) {
                        // not a valid test run
                        continue;
                    }
                    passCount += testRun.getPassCount();
                    failCount += testRun.getFailCount();
                    if (startTimestamp < 0 || testRunKey.getId() < startTimestamp) {
                        startTimestamp = testRunKey.getId();
                    }
                    if (endTimestamp < 0 || testRun.getEndTimestamp() > endTimestamp) {
                        endTimestamp = testRun.getEndTimestamp();
                    }
                    type = testRun.getType();
                    testBuildId = testRun.getTestBuildId();
                    Query deviceInfoQuery = new Query(DeviceInfoEntity.KIND).setAncestor(testRunKey);
                    for (Entity deviceInfoEntity : datastore.prepare(deviceInfoQuery).asIterable()) {
                        DeviceInfoEntity device = DeviceInfoEntity.fromEntity(deviceInfoEntity);
                        if (device == null) {
                            // invalid entity
                            continue;
                        }
                        devices.add(device);
                    }
                }
                if (startTimestamp < 0 || testBuildId == null || type == 0) {
                    logger.log(Level.WARNING, "Couldn't infer test run information from runs.");
                    return;
                }
                TestPlanRunEntity testPlanRun = new TestPlanRunEntity(testPlanEntity.getKey(), testPlan.testPlanName, type, startTimestamp, endTimestamp, testBuildId, passCount, failCount, 0L, 0L, testRunKeys);
                // Create the device infos.
                for (DeviceInfoEntity device : devices) {
                    datastore.put(device.copyWithParent(testPlanRun.key).toEntity());
                }
                datastore.put(testPlanRun.toEntity());
                Transaction txn = datastore.beginTransaction();
                try {
                    // Check if test already exists in the database
                    try {
                        datastore.get(testPlanEntity.getKey());
                    } catch (EntityNotFoundException e) {
                        datastore.put(testPlanEntity);
                    }
                    txn.commit();
                } catch (ConcurrentModificationException | DatastoreFailureException | DatastoreTimeoutException e) {
                    logger.log(Level.WARNING, "Retrying test plan insert: " + testPlanEntity.getKey());
                } finally {
                    if (txn.isActive()) {
                        logger.log(Level.WARNING, "Transaction rollback forced for plan run: " + testPlanRun.key);
                        txn.rollback();
                    }
                }
            });
        }
    } else {
        logger.log(Level.WARNING, "URL path parameter is omitted!");
    }
    response.setStatus(HttpServletResponse.SC_OK);
}
#method_after
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
    if (SystemProperty.environment.value() == SystemProperty.Environment.Value.Production) {
        response.setStatus(HttpServletResponse.SC_NOT_ACCEPTABLE);
        return;
    }
    UserService userService = UserServiceFactory.getUserService();
    User currentUser = userService.getCurrentUser();
    String pathInfo = request.getPathInfo();
    String[] pathParts = pathInfo.split("/");
    if (pathParts.length > 1) {
        // Read the json output
        Reader postJsonReader = new InputStreamReader(request.getInputStream());
        Gson gson = new GsonBuilder().create();
        String testType = pathParts[1];
        if (testType.equalsIgnoreCase("report")) {
            TestReportDataObject trdObj = gson.fromJson(postJsonReader, TestReportDataObject.class);
            logger.log(Level.INFO, "trdObj => " + trdObj);
            trdObj.testList.forEach(test -> {
                test.testRunList.forEach(testRun -> {
                    TestEntity testEntity = new TestEntity(testRun.testName);
                    Key testRunKey = KeyFactory.createKey(testEntity.getOldKey(), TestRunEntity.KIND, testRun.startTimestamp);
                    List<TestCaseReference> failingTestCases = new ArrayList<>();
                    for (int idx = 0; idx < testRun.failingTestcaseIds.size(); idx++) {
                        failingTestCases.add(new TestCaseReference(testRun.failingTestcaseIds.get(idx), testRun.failingTestcaseOffsets.get(idx)));
                    }
                    TestStatusEntity testStatusEntity = new TestStatusEntity(testRun.testName, testRun.startTimestamp, (int) testRun.passCount, failingTestCases.size(), failingTestCases);
                    datastore.put(testStatusEntity.toEntity());
                    testRun.coverageList.forEach(testRunCoverage -> {
                        CoverageEntity coverageEntity = new CoverageEntity(testRunKey, testRunCoverage.group, testRunCoverage.coveredLineCount, testRunCoverage.totalLineCount, testRunCoverage.filePath, testRunCoverage.projectName, testRunCoverage.projectVersion, testRunCoverage.lineCoverage);
                        datastore.put(coverageEntity.toEntity());
                    });
                    testRun.profilingList.forEach(testRunProfile -> {
                        ProfilingPointRunEntity profilingEntity = new ProfilingPointRunEntity(testRunKey, testRunProfile.name, testRunProfile.type, testRunProfile.regressionMode, testRunProfile.labels, testRunProfile.values, testRunProfile.xLabel, testRunProfile.yLabel, testRunProfile.options);
                        datastore.put(profilingEntity.toEntity());
                    });
                    TestCaseRunEntity testCaseEntity = new TestCaseRunEntity();
                    testRun.testCaseRunList.forEach(testCaseRun -> {
                        for (int idx = 0; idx < testCaseRun.testCaseNames.size(); idx++) {
                            testCaseEntity.addTestCase(testCaseRun.testCaseNames.get(idx), testCaseRun.results.get(idx));
                        }
                    });
                    datastore.put(testCaseEntity.toEntity());
                    testRun.deviceInfoList.forEach(deviceInfo -> {
                        DeviceInfoEntity deviceInfoEntity = new DeviceInfoEntity(testRunKey, deviceInfo.branch, deviceInfo.product, deviceInfo.buildFlavor, deviceInfo.buildId, deviceInfo.abiBitness, deviceInfo.abiName);
                        ;
                        datastore.put(deviceInfoEntity.toEntity());
                    });
                    testRun.buildTargetList.forEach(buildTarget -> {
                        BuildTargetEntity buildTargetEntity = new BuildTargetEntity(buildTarget.targetName);
                        datastore.put(buildTargetEntity.toEntity());
                    });
                    testRun.branchList.forEach(branch -> {
                        BranchEntity branchEntity = new BranchEntity(branch.branchName);
                        datastore.put(branchEntity.toEntity());
                    });
                    boolean hasCodeCoverage = testRun.totalLineCount > 0 && testRun.coveredLineCount >= 0;
                    TestRunEntity testRunEntity = new TestRunEntity(testEntity.getOldKey(), testRun.type, testRun.startTimestamp, testRun.endTimestamp, testRun.testBuildId, testRun.hostName, testRun.passCount, testRun.failCount, hasCodeCoverage, testRun.testCaseIds, testRun.links);
                    datastore.put(testRunEntity.toEntity());
                    CodeCoverageEntity codeCoverageEntity = new CodeCoverageEntity(testRunEntity.getKey(), testRun.coveredLineCount, testRun.totalLineCount);
                    datastore.put(codeCoverageEntity.toEntity());
                    Entity newTestEntity = testEntity.toEntity();
                    Transaction txn = datastore.beginTransaction();
                    try {
                        // Check if test already exists in the datastore
                        try {
                            Entity oldTest = datastore.get(testEntity.getOldKey());
                            TestEntity oldTestEntity = TestEntity.fromEntity(oldTest);
                            if (oldTestEntity == null || !oldTestEntity.equals(testEntity)) {
                                datastore.put(newTestEntity);
                            }
                        } catch (EntityNotFoundException e) {
                            datastore.put(newTestEntity);
                        }
                        txn.commit();
                    } catch (ConcurrentModificationException | DatastoreFailureException | DatastoreTimeoutException e) {
                        logger.log(Level.WARNING, "Retrying test run insert: " + newTestEntity.getKey());
                    } finally {
                        if (txn.isActive()) {
                            logger.log(Level.WARNING, "Transaction rollback forced for run: " + testRunEntity.getKey());
                            txn.rollback();
                        }
                    }
                });
            });
        } else {
            TestPlanReportDataObject tprdObj = gson.fromJson(postJsonReader, TestPlanReportDataObject.class);
            tprdObj.testPlanList.forEach(testPlan -> {
                Entity testPlanEntity = new TestPlanEntity(testPlan.testPlanName).toEntity();
                List<Key> testRunKeys = new ArrayList<>();
                for (int idx = 0; idx < testPlan.testModules.size(); idx++) {
                    String test = testPlan.testModules.get(idx);
                    long time = testPlan.testTimes.get(idx);
                    Key parentKey = KeyFactory.createKey(TestEntity.KIND, test);
                    Key testRunKey = KeyFactory.createKey(parentKey, TestRunEntity.KIND, time);
                    testRunKeys.add(testRunKey);
                }
                Map<Key, Entity> testRuns = datastore.get(testRunKeys);
                long passCount = 0;
                long failCount = 0;
                long startTimestamp = -1;
                long endTimestamp = -1;
                String testBuildId = null;
                long type = 0;
                Set<DeviceInfoEntity> devices = new HashSet<>();
                for (Key testRunKey : testRuns.keySet()) {
                    TestRunEntity testRun = TestRunEntity.fromEntity(testRuns.get(testRunKey));
                    if (testRun == null) {
                        // not a valid test run
                        continue;
                    }
                    passCount += testRun.getPassCount();
                    failCount += testRun.getFailCount();
                    if (startTimestamp < 0 || testRunKey.getId() < startTimestamp) {
                        startTimestamp = testRunKey.getId();
                    }
                    if (endTimestamp < 0 || testRun.getEndTimestamp() > endTimestamp) {
                        endTimestamp = testRun.getEndTimestamp();
                    }
                    type = testRun.getType();
                    testBuildId = testRun.getTestBuildId();
                    Query deviceInfoQuery = new Query(DeviceInfoEntity.KIND).setAncestor(testRunKey);
                    for (Entity deviceInfoEntity : datastore.prepare(deviceInfoQuery).asIterable()) {
                        DeviceInfoEntity device = DeviceInfoEntity.fromEntity(deviceInfoEntity);
                        if (device == null) {
                            // invalid entity
                            continue;
                        }
                        devices.add(device);
                    }
                }
                if (startTimestamp < 0 || testBuildId == null || type == 0) {
                    logger.log(Level.WARNING, "Couldn't infer test run information from runs.");
                    return;
                }
                TestPlanRunEntity testPlanRun = new TestPlanRunEntity(testPlanEntity.getKey(), testPlan.testPlanName, type, startTimestamp, endTimestamp, testBuildId, passCount, failCount, 0L, 0L, testRunKeys);
                // Create the device infos.
                for (DeviceInfoEntity device : devices) {
                    datastore.put(device.copyWithParent(testPlanRun.key).toEntity());
                }
                datastore.put(testPlanRun.toEntity());
                Transaction txn = datastore.beginTransaction();
                try {
                    // Check if test already exists in the database
                    try {
                        datastore.get(testPlanEntity.getKey());
                    } catch (EntityNotFoundException e) {
                        datastore.put(testPlanEntity);
                    }
                    txn.commit();
                } catch (ConcurrentModificationException | DatastoreFailureException | DatastoreTimeoutException e) {
                    logger.log(Level.WARNING, "Retrying test plan insert: " + testPlanEntity.getKey());
                } finally {
                    if (txn.isActive()) {
                        logger.log(Level.WARNING, "Transaction rollback forced for plan run: " + testPlanRun.key);
                        txn.rollback();
                    }
                }
            });
        }
    } else {
        logger.log(Level.WARNING, "URL path parameter is omitted!");
    }
    response.setStatus(HttpServletResponse.SC_OK);
}
#end_block

#method_before
public static void processTestRun(TestResults testResults, Entity testRun) {
    TestRunEntity testRunEntity = TestRunEntity.fromEntity(testRun);
    if (testRunEntity == null) {
        return;
    }
    CodeCoverageEntity codeCoverageEntity = testRunEntity.getCodeCoverageEntity(false);
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    List<Key> gets = new ArrayList<>();
    for (long testCaseId : codeCoverageEntity.getTestCaseIds()) {
        gets.add(KeyFactory.createKey(TestCaseRunEntity.KIND, testCaseId));
    }
    List<Entity> testCases = new ArrayList<>();
    Map<Key, Entity> entityMap = datastore.get(gets);
    for (Key key : gets) {
        if (entityMap.containsKey(key)) {
            testCases.add(entityMap.get(key));
        }
    }
    testResults.addTestRun(testRun, testCases);
}
#method_after
public static void processTestRun(TestResults testResults, Entity testRun) {
    TestRunEntity testRunEntity = TestRunEntity.fromEntity(testRun);
    if (testRunEntity == null) {
        return;
    }
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    List<Key> gets = new ArrayList<>();
    for (long testCaseId : testRunEntity.getTestCaseIds()) {
        gets.add(KeyFactory.createKey(TestCaseRunEntity.KIND, testCaseId));
    }
    List<Entity> testCases = new ArrayList<>();
    Map<Key, Entity> entityMap = datastore.get(gets);
    for (Key key : gets) {
        if (entityMap.containsKey(key)) {
            testCases.add(entityMap.get(key));
        }
    }
    testResults.addTestRun(testRun, testCases);
}
#end_block

#method_before
private List<com.googlecode.objectify.Key<TestRunEntity>> getTestCoverageStatusEntityKeyList(List<TestCoverageStatusEntity> testCoverageStatusEntityList) {
    return testCoverageStatusEntityList.stream().map(testCoverageStatusEntity -> {
        com.googlecode.objectify.Key testKey = com.googlecode.objectify.Key.create(TestEntity.class, testCoverageStatusEntity.getTestName());
        return com.googlecode.objectify.Key.create(testKey, TestRunEntity.class, testCoverageStatusEntity.getUpdatedTimestamp());
    }).collect(Collectors.toList());
}
#method_after
private List<Key<TestRunEntity>> getTestCoverageStatusEntityKeyList(List<TestCoverageStatusEntity> testCoverageStatusEntityList) {
    return testCoverageStatusEntityList.stream().map(testCoverageStatusEntity -> {
        com.googlecode.objectify.Key testKey = com.googlecode.objectify.Key.create(TestEntity.class, testCoverageStatusEntity.getTestName());
        return com.googlecode.objectify.Key.create(testKey, TestRunEntity.class, testCoverageStatusEntity.getUpdatedTimestamp());
    }).collect(Collectors.toList());
}
#end_block

#method_before
private RequestDispatcher getCoverageDispatcher(HttpServletRequest request, HttpServletResponse response) {
    String COVERAGE_OVERVIEW_JSP = "WEB-INF/jsp/show_coverage_overview.jsp";
    RequestDispatcher dispatcher = null;
    boolean unfiltered = request.getParameter("unfiltered") != null;
    boolean showPresubmit = request.getParameter("showPresubmit") != null;
    boolean showPostsubmit = request.getParameter("showPostsubmit") != null;
    // If no params are specified, set to default of postsubmit-only.
    if (!(showPresubmit || showPostsubmit)) {
        showPostsubmit = true;
    }
    // If unfiltered, set showPre- and Post-submit to true for accurate UI.
    if (unfiltered) {
        showPostsubmit = true;
        showPresubmit = true;
    }
    // Add test names to list
    List<String> resultNames = new ArrayList<>();
    for (VtsReportMessage.TestCaseResult r : VtsReportMessage.TestCaseResult.values()) {
        resultNames.add(r.name());
    }
    Map<String, String[]> parameterMap = request.getParameterMap();
    List<TestCoverageStatusEntity> testCoverageStatusEntityList = TestCoverageStatusEntity.getAllTestCoverage();
    List<com.googlecode.objectify.Key<TestRunEntity>> testCoverageStatusEntityKeyList = this.getTestCoverageStatusEntityKeyList(testCoverageStatusEntityList);
    Map<com.googlecode.objectify.Key<TestRunEntity>, TestRunEntity> keyTestRunEntityMap = ofy().load().keys(() -> testCoverageStatusEntityKeyList.iterator());
    List<com.googlecode.objectify.Key<CodeCoverageEntity>> codeCoverageEntityKeyList = new ArrayList<>();
    Map<Long, TestRunEntity> testRunEntityMap = new HashMap<>();
    for (Map.Entry<com.googlecode.objectify.Key<TestRunEntity>, TestRunEntity> entry : keyTestRunEntityMap.entrySet()) {
        com.googlecode.objectify.Key codeCoverageEntityKey = com.googlecode.objectify.Key.create(entry.getKey(), CodeCoverageEntity.class, entry.getValue().getId());
        codeCoverageEntityKeyList.add(codeCoverageEntityKey);
        testRunEntityMap.put(entry.getValue().getId(), entry.getValue());
    }
    Map<com.googlecode.objectify.Key<CodeCoverageEntity>, CodeCoverageEntity> keyCodeCoverageEntityMap = ofy().load().keys(() -> codeCoverageEntityKeyList.iterator());
    Map<Long, CodeCoverageEntity> codeCoverageEntityMap = new HashMap<>();
    for (Map.Entry<com.googlecode.objectify.Key<CodeCoverageEntity>, CodeCoverageEntity> entry : keyCodeCoverageEntityMap.entrySet()) {
        codeCoverageEntityMap.put(entry.getValue().getId(), entry.getValue());
    }
    int coveredLines = 0;
    int uncoveredLines = 0;
    int passCount = 0;
    int failCount = 0;
    for (Map.Entry<Long, CodeCoverageEntity> entry : codeCoverageEntityMap.entrySet()) {
        TestRunEntity testRunEntity = testRunEntityMap.get(entry.getKey());
        CodeCoverageEntity codeCoverageEntity = entry.getValue();
        coveredLines += codeCoverageEntity.getCoveredLineCount();
        uncoveredLines += codeCoverageEntity.getTotalLineCount() - codeCoverageEntity.getCoveredLineCount();
        passCount += testRunEntity.getPassCount();
        failCount += testRunEntity.getFailCount();
    }
    FilterUtil.setAttributes(request, parameterMap);
    int[] testStats = new int[VtsReportMessage.TestCaseResult.values().length];
    testStats[VtsReportMessage.TestCaseResult.TEST_CASE_RESULT_PASS.getNumber()] = passCount;
    testStats[VtsReportMessage.TestCaseResult.TEST_CASE_RESULT_FAIL.getNumber()] = failCount;
    response.setStatus(HttpServletResponse.SC_OK);
    request.setAttribute("resultNames", resultNames);
    request.setAttribute("resultNamesJson", new Gson().toJson(resultNames));
    request.setAttribute("testRunEntityList", testRunEntityMap.values());
    request.setAttribute("codeCoverageEntityList", codeCoverageEntityMap.values().toArray());
    request.setAttribute("coveredLines", new Gson().toJson(coveredLines));
    request.setAttribute("uncoveredLines", new Gson().toJson(uncoveredLines));
    request.setAttribute("testStats", new Gson().toJson(testStats));
    request.setAttribute("unfiltered", unfiltered);
    request.setAttribute("showPresubmit", showPresubmit);
    request.setAttribute("showPostsubmit", showPostsubmit);
    request.setAttribute("branches", new Gson().toJson(DeviceInfoEntity.getAllBranches()));
    request.setAttribute("devices", new Gson().toJson(DeviceInfoEntity.getAllBuildFlavors()));
    dispatcher = request.getRequestDispatcher(COVERAGE_OVERVIEW_JSP);
    return dispatcher;
}
#method_after
private RequestDispatcher getCoverageDispatcher(HttpServletRequest request, HttpServletResponse response) {
    String COVERAGE_OVERVIEW_JSP = "WEB-INF/jsp/show_coverage_overview.jsp";
    RequestDispatcher dispatcher = null;
    boolean unfiltered = request.getParameter("unfiltered") != null;
    boolean showPresubmit = request.getParameter("showPresubmit") != null;
    boolean showPostsubmit = request.getParameter("showPostsubmit") != null;
    // If no params are specified, set to default of postsubmit-only.
    if (!(showPresubmit || showPostsubmit)) {
        showPostsubmit = true;
    }
    // If unfiltered, set showPre- and Post-submit to true for accurate UI.
    if (unfiltered) {
        showPostsubmit = true;
        showPresubmit = true;
    }
    // Add test names to list
    List<String> resultNames = new ArrayList<>();
    for (VtsReportMessage.TestCaseResult r : VtsReportMessage.TestCaseResult.values()) {
        resultNames.add(r.name());
    }
    Map<String, String[]> parameterMap = request.getParameterMap();
    List<TestCoverageStatusEntity> testCoverageStatusEntityList = TestCoverageStatusEntity.getAllTestCoverage();
    List<com.googlecode.objectify.Key<TestRunEntity>> testCoverageStatusEntityKeyList = this.getTestCoverageStatusEntityKeyList(testCoverageStatusEntityList);
    Map<Key<TestRunEntity>, TestRunEntity> keyTestRunEntityMap = ofy().load().keys(() -> testCoverageStatusEntityKeyList.iterator());
    List<com.googlecode.objectify.Key<CodeCoverageEntity>> codeCoverageEntityKeyList = new ArrayList<>();
    Map<Long, TestRunEntity> testRunEntityMap = new HashMap<>();
    for (Map.Entry<com.googlecode.objectify.Key<TestRunEntity>, TestRunEntity> entry : keyTestRunEntityMap.entrySet()) {
        com.googlecode.objectify.Key codeCoverageEntityKey = com.googlecode.objectify.Key.create(entry.getKey(), CodeCoverageEntity.class, entry.getValue().getId());
        codeCoverageEntityKeyList.add(codeCoverageEntityKey);
        testRunEntityMap.put(entry.getValue().getId(), entry.getValue());
    }
    Map<com.googlecode.objectify.Key<CodeCoverageEntity>, CodeCoverageEntity> keyCodeCoverageEntityMap = ofy().load().keys(() -> codeCoverageEntityKeyList.iterator());
    Map<Long, CodeCoverageEntity> codeCoverageEntityMap = new HashMap<>();
    for (Map.Entry<com.googlecode.objectify.Key<CodeCoverageEntity>, CodeCoverageEntity> entry : keyCodeCoverageEntityMap.entrySet()) {
        codeCoverageEntityMap.put(entry.getValue().getId(), entry.getValue());
    }
    int coveredLines = 0;
    int uncoveredLines = 0;
    int passCount = 0;
    int failCount = 0;
    for (Map.Entry<Long, CodeCoverageEntity> entry : codeCoverageEntityMap.entrySet()) {
        TestRunEntity testRunEntity = testRunEntityMap.get(entry.getKey());
        CodeCoverageEntity codeCoverageEntity = entry.getValue();
        coveredLines += codeCoverageEntity.getCoveredLineCount();
        uncoveredLines += codeCoverageEntity.getTotalLineCount() - codeCoverageEntity.getCoveredLineCount();
        passCount += testRunEntity.getPassCount();
        failCount += testRunEntity.getFailCount();
    }
    FilterUtil.setAttributes(request, parameterMap);
    int[] testStats = new int[VtsReportMessage.TestCaseResult.values().length];
    testStats[VtsReportMessage.TestCaseResult.TEST_CASE_RESULT_PASS.getNumber()] = passCount;
    testStats[VtsReportMessage.TestCaseResult.TEST_CASE_RESULT_FAIL.getNumber()] = failCount;
    response.setStatus(HttpServletResponse.SC_OK);
    request.setAttribute("resultNames", resultNames);
    request.setAttribute("resultNamesJson", new Gson().toJson(resultNames));
    request.setAttribute("testRunEntityList", testRunEntityMap.values());
    request.setAttribute("codeCoverageEntityMap", codeCoverageEntityMap);
    request.setAttribute("coveredLines", new Gson().toJson(coveredLines));
    request.setAttribute("uncoveredLines", new Gson().toJson(uncoveredLines));
    request.setAttribute("testStats", new Gson().toJson(testStats));
    request.setAttribute("unfiltered", unfiltered);
    request.setAttribute("showPresubmit", showPresubmit);
    request.setAttribute("showPostsubmit", showPostsubmit);
    // DeviceInfoEntity.getAllBranches()
    request.setAttribute("branches", new Gson().toJson(new ArrayList<>()));
    // DeviceInfoEntity.getAllBuildFlavors()
    request.setAttribute("devices", new Gson().toJson(new ArrayList<>()));
    dispatcher = request.getRequestDispatcher(COVERAGE_OVERVIEW_JSP);
    return dispatcher;
}
#end_block

#method_before
private DataTable getCoverageDataTable(String testName) {
    Datastore datastore = DatastoreOptions.getDefaultInstance().getService();
    DataTable dataTable = new DataTable();
    ArrayList<ColumnDescription> cd = new ArrayList<>();
    ColumnDescription startDate = new ColumnDescription("startDate", ValueType.DATETIME, "Date");
    startDate.setPattern("yyyy-MM-dd");
    cd.add(startDate);
    cd.add(new ColumnDescription("coveredLineCount", ValueType.NUMBER, "Covered Source Code Line Count"));
    cd.add(new ColumnDescription("totalLineCount", ValueType.NUMBER, "Total Source Code Line Count"));
    cd.add(new ColumnDescription("percentage", ValueType.NUMBER, "Coverage Ratio (%)"));
    dataTable.addColumns(cd);
    Calendar cal = Calendar.getInstance();
    cal.add(Calendar.MONTH, -6);
    Long startTime = cal.getTime().getTime() * 1000;
    Long endTime = Calendar.getInstance().getTime().getTime() * 1000;
    com.google.cloud.datastore.Key startKey = datastore.newKeyFactory().setKind(TestRunEntity.KIND).addAncestors(PathElement.of(TestEntity.KIND, testName), PathElement.of(TestRunEntity.KIND, startTime)).newKey(startTime);
    com.google.cloud.datastore.Key endKey = datastore.newKeyFactory().setKind(TestRunEntity.KIND).addAncestors(PathElement.of(TestEntity.KIND, testName), PathElement.of(TestRunEntity.KIND, endTime)).newKey(endTime);
    Filter codeCoverageFilter = CompositeFilter.and(PropertyFilter.lt("__key__", endKey), PropertyFilter.gt("__key__", startKey));
    List<CodeCoverageEntity> codeCoverageEntityList = ofy().load().type(CodeCoverageEntity.class).filter(codeCoverageFilter).limit(10).list();
    DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern("yyyy-MM-dd");
    Map<String, List<CodeCoverageEntity>> codeCoverageEntityListMap = codeCoverageEntityList.stream().collect(Collectors.groupingBy(v -> dateTimeFormatter.print(v.getId() / 1000)));
    codeCoverageEntityListMap.forEach((key, entityList) -> {
        GregorianCalendar gCal = new GregorianCalendar();
        gCal.setTimeZone(TimeZone.getTimeZone("GMT"));
        gCal.setTimeInMillis(entityList.get(0).getId() / 1000);
        Long sumCoveredLine = entityList.stream().mapToLong(val -> val.getCoveredLineCount()).sum();
        Long sumTotalLine = entityList.stream().mapToLong(val -> val.getTotalLineCount()).sum();
        BigDecimal coveredLineNum = new BigDecimal(sumCoveredLine);
        BigDecimal totalLineNum = new BigDecimal(sumTotalLine);
        BigDecimal totalPercent = new BigDecimal(100);
        float percentage = coveredLineNum.multiply(totalPercent).divide(totalLineNum, 2, RoundingMode.HALF_DOWN).floatValue();
        TableRow tableRow = new TableRow();
        tableRow.addCell(new DateTimeValue(gCal));
        tableRow.addCell(new NumberValue(sumCoveredLine));
        tableRow.addCell(new NumberValue(sumTotalLine));
        tableRow.addCell(new NumberValue(percentage));
        try {
            dataTable.addRow(tableRow);
        } catch (TypeMismatchException e) {
            logger.log(Level.WARNING, "Invalid type! ");
        }
    });
    return dataTable;
}
#method_after
private DataTable getCoverageDataTable(String testName) {
    Datastore datastore = DatastoreOptions.getDefaultInstance().getService();
    DataTable dataTable = new DataTable();
    ArrayList<ColumnDescription> cd = new ArrayList<>();
    ColumnDescription startDate = new ColumnDescription("startDate", ValueType.DATETIME, "Date");
    startDate.setPattern("yyyy-MM-dd");
    cd.add(startDate);
    cd.add(new ColumnDescription("coveredLineCount", ValueType.NUMBER, "Covered Source Code Line Count"));
    cd.add(new ColumnDescription("totalLineCount", ValueType.NUMBER, "Total Source Code Line Count"));
    cd.add(new ColumnDescription("percentage", ValueType.NUMBER, "Coverage Ratio (%)"));
    dataTable.addColumns(cd);
    Calendar cal = Calendar.getInstance();
    cal.add(Calendar.MONTH, -6);
    Long startTime = cal.getTime().getTime() * 1000;
    Long endTime = Calendar.getInstance().getTime().getTime() * 1000;
    com.google.cloud.datastore.Key startKey = datastore.newKeyFactory().setKind(TestRunEntity.KIND).addAncestors(PathElement.of(TestEntity.KIND, testName), PathElement.of(TestRunEntity.KIND, startTime)).newKey(startTime);
    com.google.cloud.datastore.Key endKey = datastore.newKeyFactory().setKind(TestRunEntity.KIND).addAncestors(PathElement.of(TestEntity.KIND, testName), PathElement.of(TestRunEntity.KIND, endTime)).newKey(endTime);
    Filter codeCoverageFilter = CompositeFilter.and(PropertyFilter.lt("__key__", endKey), PropertyFilter.gt("__key__", startKey));
    List<CodeCoverageEntity> codeCoverageEntityList = ofy().load().type(CodeCoverageEntity.class).filter(codeCoverageFilter).limit(10).list();
    DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern("yyyy-MM-dd");
    Map<String, List<CodeCoverageEntity>> codeCoverageEntityListMap = codeCoverageEntityList.stream().collect(Collectors.groupingBy(v -> dateTimeFormatter.print(v.getId() / 1000)));
    codeCoverageEntityListMap.forEach((key, entityList) -> {
        GregorianCalendar gCal = new GregorianCalendar();
        gCal.setTimeZone(TimeZone.getTimeZone("GMT"));
        gCal.setTimeInMillis(entityList.get(0).getId() / 1000);
        Long sumCoveredLine = entityList.stream().mapToLong(val -> val.getCoveredLineCount()).sum();
        Long sumTotalLine = entityList.stream().mapToLong(val -> val.getTotalLineCount()).sum();
        float percentage = 0;
        if (sumTotalLine > 0) {
            BigDecimal coveredLineNum = new BigDecimal(sumCoveredLine);
            BigDecimal totalLineNum = new BigDecimal(sumTotalLine);
            BigDecimal totalPercent = new BigDecimal(100);
            percentage = coveredLineNum.multiply(totalPercent).divide(totalLineNum, 2, RoundingMode.HALF_DOWN).floatValue();
        }
        TableRow tableRow = new TableRow();
        tableRow.addCell(new DateTimeValue(gCal));
        tableRow.addCell(new NumberValue(sumCoveredLine));
        tableRow.addCell(new NumberValue(sumTotalLine));
        tableRow.addCell(new NumberValue(percentage));
        try {
            dataTable.addRow(tableRow);
        } catch (TypeMismatchException e) {
            logger.log(Level.WARNING, "Invalid type! ");
        }
    });
    return dataTable;
}
#end_block

#method_before
private TestRunDetails getTestRunDetails(String test, String timeString) {
    long timestamp;
    try {
        timestamp = Long.parseLong(timeString);
        if (timestamp <= 0)
            throw new NumberFormatException();
        timestamp = timestamp > 0 ? timestamp : null;
    } catch (NumberFormatException e) {
        return null;
    }
    CodeCoverageEntity codeCoverageEntity = CodeCoverageEntity.getByTestNameId(test, timestamp);
    return getTestRunDetails(codeCoverageEntity);
}
#method_after
private TestRunDetails getTestRunDetails(String test, String timeString) {
    long timestamp;
    try {
        timestamp = Long.parseLong(timeString);
        if (timestamp <= 0)
            throw new NumberFormatException();
        timestamp = timestamp > 0 ? timestamp : null;
    } catch (NumberFormatException e) {
        return null;
    }
    TestRunEntity testRunEntity = TestRunEntity.getByTestNameId(test, timestamp);
    return getTestRunDetails(testRunEntity);
}
#end_block

#method_before
private TestRunDetails getLatestTestRunDetails(String testName) {
    com.googlecode.objectify.Key testKey = com.googlecode.objectify.Key.create(TestEntity.class, testName);
    TestRunEntity testRun = ofy().load().type(TestRunEntity.class).ancestor(testKey).filter("type", 2).orderKey(true).first().now();
    if (testRun == null)
        return null;
    CodeCoverageEntity codeCoverageEntity = testRun.getCodeCoverageEntity(false);
    return getTestRunDetails(codeCoverageEntity);
}
#method_after
private TestRunDetails getLatestTestRunDetails(String testName) {
    com.googlecode.objectify.Key testKey = com.googlecode.objectify.Key.create(TestEntity.class, testName);
    TestRunEntity testRun = ofy().load().type(TestRunEntity.class).ancestor(testKey).filter("type", 2).orderKey(true).first().now();
    if (testRun == null)
        return null;
    return getTestRunDetails(testRun);
}
#end_block

#method_before
private TestRunDetails getTestRunDetails(CodeCoverageEntity codeCoverageEntity) {
    TestRunDetails details = new TestRunDetails();
    List<com.googlecode.objectify.Key<TestCaseRunEntity>> testCaseKeyList = new ArrayList<>();
    if (Objects.isNull(codeCoverageEntity.getTestCaseIds())) {
        return details;
    } else {
        for (long testCaseId : codeCoverageEntity.getTestCaseIds()) {
            testCaseKeyList.add(com.googlecode.objectify.Key.create(TestCaseRunEntity.class, testCaseId));
        }
        Map<com.googlecode.objectify.Key<TestCaseRunEntity>, TestCaseRunEntity> testCaseRunEntityKeyMap = ofy().load().keys(() -> testCaseKeyList.iterator());
        for (Map.Entry<com.googlecode.objectify.Key<TestCaseRunEntity>, TestCaseRunEntity> entry : testCaseRunEntityKeyMap.entrySet()) {
            details.addTestCase(entry.getValue());
        }
    }
    return details;
}
#method_after
private TestRunDetails getTestRunDetails(TestRunEntity testRunEntity) {
    TestRunDetails details = new TestRunDetails();
    List<com.googlecode.objectify.Key<TestCaseRunEntity>> testCaseKeyList = new ArrayList<>();
    if (Objects.isNull(testRunEntity.getTestCaseIds())) {
        return details;
    } else {
        for (long testCaseId : testRunEntity.getTestCaseIds()) {
            testCaseKeyList.add(com.googlecode.objectify.Key.create(TestCaseRunEntity.class, testCaseId));
        }
        Map<com.googlecode.objectify.Key<TestCaseRunEntity>, TestCaseRunEntity> testCaseRunEntityKeyMap = ofy().load().keys(() -> testCaseKeyList.iterator());
        for (Map.Entry<com.googlecode.objectify.Key<TestCaseRunEntity>, TestCaseRunEntity> entry : testCaseRunEntityKeyMap.entrySet()) {
            details.addTestCase(entry.getValue());
        }
    }
    return details;
}
#end_block

#method_before
private byte getHopLimit(String upstreamIface) {
    try {
        int upstreamHopLimit = Integer.parseUnsignedInt(mNetd.getProcSysNet(INetd.IPV6, INetd.CONF, upstreamIface, "hop_limit"));
        // Add one hop to account for this forwarding device
        upstreamHopLimit++;
        // Cap the hop limit to 254 (255 generally means on-link only)
        return (byte) Integer.max(upstreamHopLimit, 254);
    } catch (Exception e) {
    }
    return RaParams.DEFAULT_HOPLIMIT;
}
#method_after
private byte getHopLimit(String upstreamIface) {
    try {
        int upstreamHopLimit = Integer.parseUnsignedInt(mNetd.getProcSysNet(INetd.IPV6, INetd.CONF, upstreamIface, "hop_limit"));
        // Add one hop to account for this forwarding device
        upstreamHopLimit++;
        // Cap the hop limit to 255.
        return (byte) Integer.min(upstreamHopLimit, 255);
    } catch (Exception e) {
        mLog.e("Failed to find upstream interface hop limit", e);
    }
    return RaParams.DEFAULT_HOPLIMIT;
}
#end_block

#method_before
boolean shouldNotHideBars() {
    return (mMediaType == MEDIA_TYPE_MUSIC && mSizeType == SIZE_TYPE_FULL) || mAccessibilityManager.isTouchExplorationEnabled();
}
#method_after
boolean shouldNotHideBars() {
    return (mMediaType == MEDIA_TYPE_MUSIC && mSizeType == SIZE_TYPE_FULL) || mAccessibilityManager.isTouchExplorationEnabled() || mController.getPlaybackState() == MediaPlayerConnector.PLAYER_STATE_ERROR || mController.getPlaybackState() == MediaPlayerConnector.PLAYER_STATE_IDLE;
}
#end_block

#method_before
@Override
public void onPlayerStateChanged(@NonNull MediaController2 controller, @MediaPlayerConnector.PlayerState int state) {
    if (DEBUG) {
        Log.d(TAG, "onPlayerStateChanged(state: " + state + ")");
    }
    mPlaybackState = state;
    // 2) Need to handle case where the media file reaches end of duration.
    if (mPlaybackState != mPrevState) {
        switch(mPlaybackState) {
            case MediaPlayerConnector.PLAYER_STATE_PLAYING:
                removeCallbacks(mUpdateProgress);
                post(mUpdateProgress);
                resetHideCallbacks();
                updateForStoppedState(false);
                break;
            case MediaPlayerConnector.PLAYER_STATE_PAUSED:
                mPlayPauseButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_play_circle_filled, null));
                mPlayPauseButton.setContentDescription(mResources.getString(R.string.mcv2_play_button_desc));
                removeCallbacks(mUpdateProgress);
                break;
            default:
                break;
        }
        mPrevState = mPlaybackState;
    }
}
#method_after
@Override
public void onPlayerStateChanged(@NonNull MediaController2 controller, @MediaPlayerConnector.PlayerState int state) {
    if (DEBUG) {
        Log.d(TAG, "onPlayerStateChanged(state: " + state + ")");
    }
    mPlaybackState = state;
    // 2) Need to handle case where the media file reaches end of duration.
    if (mPlaybackState != mPrevState) {
        switch(mPlaybackState) {
            case MediaPlayerConnector.PLAYER_STATE_PLAYING:
                removeCallbacks(mUpdateProgress);
                post(mUpdateProgress);
                resetHideCallbacks();
                updateForStoppedState(false);
                break;
            case MediaPlayerConnector.PLAYER_STATE_PAUSED:
                mPlayPauseButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_play_circle_filled, null));
                mPlayPauseButton.setContentDescription(mResources.getString(R.string.mcv2_play_button_desc));
                removeCallbacks(mUpdateProgress);
                break;
            case MediaPlayerConnector.PLAYER_STATE_ERROR:
                MediaControlView2.this.setEnabled(false);
                mPlayPauseButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_play_circle_filled, null));
                mPlayPauseButton.setContentDescription(mResources.getString(R.string.mcv2_play_button_desc));
                removeCallbacks(mUpdateProgress);
                if (getWindowToken() != null) {
                    new AlertDialog.Builder(getContext()).setMessage(R.string.mcv2_playback_error_text).setPositiveButton(R.string.mcv2_error_dialog_button, new DialogInterface.OnClickListener() {

                        @Override
                        public void onClick(DialogInterface dialogInterface, int i) {
                            dialogInterface.dismiss();
                        }
                    }).setCancelable(true).show();
                }
            default:
                break;
        }
        mPrevState = mPlaybackState;
    }
}
#end_block

#method_before
@Override
public void skipToNext() {
// No-op. This skipToNext() means 'skip to next item in the setNextDataSources()'
}
#method_after
@Override
public void skipToNext() {
// No-op. This skipToNext() means 'skip to next item in the setNextMediaItems()'
}
#end_block

#method_before
public void notifyCurrentDataSourceChanged(final MediaItem2 item) {
    for (int i = 0; i < mCallbacks.size(); i++) {
        final PlayerEventCallback callback = mCallbacks.keyAt(i);
        final Executor executor = mCallbacks.valueAt(i);
        executor.execute(new Runnable() {

            @Override
            public void run() {
                callback.onCurrentDataSourceChanged(MockPlayerConnector.this, item);
            }
        });
    }
}
#method_after
public void notifyCurrentDataSourceChanged(final MediaItem2 item) {
    for (int i = 0; i < mCallbacks.size(); i++) {
        final PlayerEventCallback callback = mCallbacks.keyAt(i);
        final Executor executor = mCallbacks.valueAt(i);
        executor.execute(new Runnable() {

            @Override
            public void run() {
                callback.onCurrentMediaItemChanged(MockPlayerConnector.this, item);
            }
        });
    }
}
#end_block

#method_before
static MediaItem2 fromBundle(@NonNull Bundle bundle, @Nullable ParcelUuid parcelUuid) {
    if (bundle == null) {
        return null;
    }
    final String id = bundle.getString(KEY_ID);
    final Bundle metadataBundle = bundle.getBundle(KEY_METADATA);
    final MediaMetadata2 metadata = metadataBundle != null ? MediaMetadata2.fromBundle(metadataBundle) : null;
    final int flags = bundle.getInt(KEY_FLAGS);
    return new MediaItem2(parcelUuid.getUuid(), id, flags, metadata, 0, 0, 0);
}
#method_after
static MediaItem2 fromBundle(@NonNull Bundle bundle, @Nullable ParcelUuid parcelUuid) {
    if (bundle == null) {
        return null;
    }
    final UUID uuid = (parcelUuid != null) ? parcelUuid.getUuid() : null;
    final String id = bundle.getString(KEY_ID);
    final Bundle metadataBundle = bundle.getBundle(KEY_METADATA);
    final MediaMetadata2 metadata = metadataBundle != null ? MediaMetadata2.fromBundle(metadataBundle) : null;
    final int flags = bundle.getInt(KEY_FLAGS);
    return new MediaItem2(uuid, id, flags, metadata, 0, 0, 0);
}
#end_block

#method_before
@Test
@LargeTest
public void testPreservePlaybackProperties() throws Exception {
/* TODO: enable this test once XMediaPlayer has playlist implementation.
        final int resid1 = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
        final long start1 = 6000;
        final long end1 = 7000;
        AssetFileDescriptor afd1 = mResources.openRawResourceFd(resid1);
        MediaItem2 dsd1 = new FileMediaItem2.Builder(
                afd1.getFileDescriptor(), afd1.getStartOffset(), afd1.getLength())
                .setStartPosition(start1)
                .setEndPosition(end1)
                .build();

        final int resid2 = R.raw.testvideo;
        final long start2 = 3000;
        final long end2 = 4000;
        AssetFileDescriptor afd2 = mResources.openRawResourceFd(resid2);
        MediaItem2 dsd2 = new FileMediaItem2.Builder(
                afd2.getFileDescriptor(), afd2.getStartOffset(), afd2.getLength())
                .setStartPosition(start2)
                .setEndPosition(end2)
                .build();

        mPlayer.setDataSource();
        mPlayer.setNextDataSource(dsd2);
        mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());

        XMediaPlayer.PlayerCallback callback = new XMediaPlayer.PlayerCallback() {
            @Override
            public void onInfo(MediaPlayer2 mp, MediaItem2 dsd, int what, int extra) {
                if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                    mOnPrepareCalled.signal();
                } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_END) {
                    mOnCompletionCalled.signal();
                }
            }

            @Override
            public void onCallCompleted(
                    MediaPlayer2 mp, MediaItem2 dsd, int what, int status) {
                if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                    assertTrue(status == MediaPlayer2.CALL_STATUS_NO_ERROR);
                    mOnPlayCalled.signal();
                }
            }
        };
        mPlayer.registerPlayerCallback(mExecutor, callback);

        mOnPrepareCalled.reset();
        mPlayer.prepare();
        mOnPrepareCalled.waitForSignal();

        mOnPlayCalled.reset();
        mOnCompletionCalled.reset();
        mPlayer.setPlaybackParams(new PlaybackParams2.Builder().setSpeed(2.0f).build());
        mPlayer.play();

        mOnPlayCalled.waitForSignal();
        mOnCompletionCalled.waitForSignal();

        assertEquals(dsd2, mPlayer.getCurrentDataSource());
        assertEquals(2.0f, mPlayer.getPlaybackParams().getSpeed(), 0.001f);

        afd1.close();
        afd2.close();
        */
}
#method_after
@Test
@LargeTest
public void testPreservePlaybackProperties() throws Exception {
/* TODO: enable this test once XMediaPlayer has playlist implementation.
        final int resid1 = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
        final long start1 = 6000;
        final long end1 = 7000;
        AssetFileDescriptor afd1 = mResources.openRawResourceFd(resid1);
        MediaItem2 dsd1 = new FileMediaItem2.Builder(
                afd1.getFileDescriptor(), afd1.getStartOffset(), afd1.getLength())
                .setStartPosition(start1)
                .setEndPosition(end1)
                .build();

        final int resid2 = R.raw.testvideo;
        final long start2 = 3000;
        final long end2 = 4000;
        AssetFileDescriptor afd2 = mResources.openRawResourceFd(resid2);
        MediaItem2 dsd2 = new FileMediaItem2.Builder(
                afd2.getFileDescriptor(), afd2.getStartOffset(), afd2.getLength())
                .setStartPosition(start2)
                .setEndPosition(end2)
                .build();

        mPlayer.setMediaItem();
        mPlayer.setNextMediaItem(dsd2);
        mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());

        XMediaPlayer.PlayerCallback callback = new XMediaPlayer.PlayerCallback() {
            @Override
            public void onInfo(MediaPlayer2 mp, MediaItem2 dsd, int what, int extra) {
                if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                    mOnPrepareCalled.signal();
                } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_END) {
                    mOnCompletionCalled.signal();
                }
            }

            @Override
            public void onCallCompleted(
                    MediaPlayer2 mp, MediaItem2 dsd, int what, int status) {
                if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                    assertTrue(status == MediaPlayer2.CALL_STATUS_NO_ERROR);
                    mOnPlayCalled.signal();
                }
            }
        };
        mPlayer.registerPlayerCallback(mExecutor, callback);

        mOnPrepareCalled.reset();
        mPlayer.prepare();
        mOnPrepareCalled.waitForSignal();

        mOnPlayCalled.reset();
        mOnCompletionCalled.reset();
        mPlayer.setPlaybackParams(new PlaybackParams2.Builder().setSpeed(2.0f).build());
        mPlayer.play();

        mOnPlayCalled.waitForSignal();
        mOnCompletionCalled.waitForSignal();

        assertEquals(dsd2, mPlayer.getCurrentMediaItem());
        assertEquals(2.0f, mPlayer.getPlaybackParams().getSpeed(), 0.001f);

        afd1.close();
        afd2.close();
        */
}
#end_block

#method_before
@Test
@LargeTest
public void testPlayerCallback() throws Throwable {
    final int mp4Duration = 8484;
    if (!loadResource(R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz)) {
        // skip;
        return;
    }
    ListenableFuture<CommandResult2> future;
    final TestUtils.Monitor onSeekCompleteCalled = new TestUtils.Monitor();
    final TestUtils.Monitor onPlayerStateChangedCalled = new TestUtils.Monitor();
    final AtomicInteger playerState = new AtomicInteger();
    final TestUtils.Monitor onBufferingStateChangedCalled = new TestUtils.Monitor();
    final AtomicInteger bufferingState = new AtomicInteger();
    final TestUtils.Monitor onPlaybackSpeedChanged = new TestUtils.Monitor();
    final AtomicReference<Float> playbackSpeed = new AtomicReference<>();
    XMediaPlayer.PlayerCallback callback = new XMediaPlayer.PlayerCallback() {

        @Override
        public void onPlayerStateChanged(SessionPlayer2 player, int state) {
            playerState.set(state);
            onPlayerStateChangedCalled.signal();
        }

        @Override
        public void onBufferingStateChanged(SessionPlayer2 player, MediaItem2 desc, int buffState) {
            bufferingState.set(buffState);
            onBufferingStateChangedCalled.signal();
        }

        @Override
        public void onPlaybackSpeedChanged(SessionPlayer2 player, float speed) {
            playbackSpeed.set(speed);
            onPlaybackSpeedChanged.signal();
        }

        @Override
        public void onSeekCompleted(SessionPlayer2 player, long position) {
            onSeekCompleteCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    onPlayerStateChangedCalled.reset();
    onBufferingStateChangedCalled.reset();
    future = mPlayer.prepare();
    do {
        assertTrue(onBufferingStateChangedCalled.waitForSignal(1000));
    } while (bufferingState.get() != XMediaPlayer.BUFFERING_STATE_BUFFERING_AND_STARVED);
    assertEquals(MediaPlayer2.CALL_STATUS_NO_ERROR, future.get().getResultCode());
    do {
        assertTrue(onPlayerStateChangedCalled.waitForSignal(1000));
    } while (playerState.get() != XMediaPlayer.PLAYER_STATE_PAUSED);
    do {
        assertTrue(onBufferingStateChangedCalled.waitForSignal(1000));
    } while (bufferingState.get() != XMediaPlayer.BUFFERING_STATE_BUFFERING_AND_PLAYABLE);
    onSeekCompleteCalled.reset();
    mPlayer.seekTo(mp4Duration >> 1);
    onSeekCompleteCalled.waitForSignal();
    onPlaybackSpeedChanged.reset();
    mPlayer.setPlaybackSpeed(0.5f);
    do {
        assertTrue(onPlaybackSpeedChanged.waitForSignal(1000));
    } while (Math.abs(playbackSpeed.get() - 0.5f) > FLOAT_TOLERANCE);
    mPlayer.reset();
    assertEquals(XMediaPlayer.PLAYER_STATE_IDLE, mPlayer.getPlayerState());
    mPlayer.unregisterPlayerCallback(callback);
}
#method_after
@Test
@LargeTest
public void testPlayerCallback() throws Throwable {
    final int mp4Duration = 8484;
    if (!loadResource(R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz)) {
        // skip;
        return;
    }
    ListenableFuture<CommandResult2> future;
    final TestUtils.Monitor onSeekCompleteCalled = new TestUtils.Monitor();
    final TestUtils.Monitor onPlayerStateChangedCalled = new TestUtils.Monitor();
    final AtomicInteger playerState = new AtomicInteger();
    final TestUtils.Monitor onBufferingStateChangedCalled = new TestUtils.Monitor();
    final AtomicInteger bufferingState = new AtomicInteger();
    final TestUtils.Monitor onPlaybackSpeedChanged = new TestUtils.Monitor();
    final AtomicReference<Float> playbackSpeed = new AtomicReference<>();
    XMediaPlayer.PlayerCallback callback = new XMediaPlayer.PlayerCallback() {

        @Override
        public void onPlayerStateChanged(SessionPlayer2 player, int state) {
            playerState.set(state);
            onPlayerStateChangedCalled.signal();
        }

        @Override
        public void onBufferingStateChanged(SessionPlayer2 player, MediaItem2 item, int buffState) {
            bufferingState.set(buffState);
            onBufferingStateChangedCalled.signal();
        }

        @Override
        public void onPlaybackSpeedChanged(SessionPlayer2 player, float speed) {
            playbackSpeed.set(speed);
            onPlaybackSpeedChanged.signal();
        }

        @Override
        public void onSeekCompleted(SessionPlayer2 player, long position) {
            onSeekCompleteCalled.signal();
        }
    };
    mPlayer.registerPlayerCallback(mExecutor, callback);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    onPlayerStateChangedCalled.reset();
    onBufferingStateChangedCalled.reset();
    future = mPlayer.prepare();
    do {
        assertTrue(onBufferingStateChangedCalled.waitForSignal(1000));
    } while (bufferingState.get() != XMediaPlayer.BUFFERING_STATE_BUFFERING_AND_STARVED);
    assertEquals(MediaPlayer2.CALL_STATUS_NO_ERROR, future.get().getResultCode());
    do {
        assertTrue(onPlayerStateChangedCalled.waitForSignal(1000));
    } while (playerState.get() != XMediaPlayer.PLAYER_STATE_PAUSED);
    do {
        assertTrue(onBufferingStateChangedCalled.waitForSignal(1000));
    } while (bufferingState.get() != XMediaPlayer.BUFFERING_STATE_BUFFERING_AND_PLAYABLE);
    onSeekCompleteCalled.reset();
    mPlayer.seekTo(mp4Duration >> 1);
    onSeekCompleteCalled.waitForSignal();
    onPlaybackSpeedChanged.reset();
    mPlayer.setPlaybackSpeed(0.5f);
    do {
        assertTrue(onPlaybackSpeedChanged.waitForSignal(1000));
    } while (Math.abs(playbackSpeed.get() - 0.5f) > FLOAT_TOLERANCE);
    mPlayer.reset();
    assertEquals(XMediaPlayer.PLAYER_STATE_IDLE, mPlayer.getPlayerState());
    mPlayer.unregisterPlayerCallback(callback);
}
#end_block

#method_before
@SuppressWarnings("GuardedBy")
private void updatePlayerDataSourceLocked() {
    if (mCurrent == null || mCurrent == mEopPlayItem) {
        return;
    }
    if (mPlayer.getPlayerState() == MediaPlayerConnector.PLAYER_STATE_IDLE) {
        mPlayer.setDataSource(mCurrent.item);
    } else {
        mPlayer.setNextDataSource(mCurrent.item);
        mPlayer.skipToNext();
    }
    mPlayer.loopCurrent(mRepeatMode == MediaPlaylistAgent.REPEAT_MODE_ONE);
// TODO: Call setNextDataSource (b/74090741)
}
#method_after
@SuppressWarnings("GuardedBy")
private void updatePlayerDataSourceLocked() {
    if (mCurrent == null || mCurrent == mEopPlayItem) {
        return;
    }
    if (mPlayer.getPlayerState() == MediaPlayerConnector.PLAYER_STATE_IDLE) {
        mPlayer.setMediaItem(mCurrent.item);
    } else {
        mPlayer.setNextMediaItem(mCurrent.item);
        mPlayer.skipToNext();
    }
    mPlayer.loopCurrent(mRepeatMode == MediaPlaylistAgent.REPEAT_MODE_ONE);
// TODO: Call setNextMediaItem (b/74090741)
}
#end_block

#method_before
protected MediaPlayer2 createMediaPlayer2(Context context, Uri uri, SurfaceHolder holder, AudioAttributesCompat audioAttributes, int audioSessionId) {
    try {
        MediaPlayer2 mp = createMediaPlayer2OnUiThread();
        final AudioAttributesCompat aa = audioAttributes != null ? audioAttributes : new AudioAttributesCompat.Builder().build();
        mp.setAudioAttributes(aa);
        mp.setAudioSessionId(audioSessionId);
        mp.setDataSource(new UriMediaItem2.Builder(context, uri).build());
        if (holder != null) {
            mp.setSurface(holder.getSurface());
        }
        final Monitor onPrepareCalled = new Monitor();
        ExecutorService executor = Executors.newFixedThreadPool(1);
        MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

            @Override
            public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
                if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                    onPrepareCalled.signal();
                }
            }
        };
        mp.setEventCallback(executor, ecb);
        mp.prepare();
        onPrepareCalled.waitForSignal();
        mp.clearEventCallback();
        executor.shutdown();
        return mp;
    } catch (IllegalArgumentException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    } catch (SecurityException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    } catch (InterruptedException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    }
    return null;
}
#method_after
protected MediaPlayer2 createMediaPlayer2(Context context, Uri uri, SurfaceHolder holder, AudioAttributesCompat audioAttributes, int audioSessionId) {
    try {
        MediaPlayer2 mp = createMediaPlayer2OnUiThread();
        final AudioAttributesCompat aa = audioAttributes != null ? audioAttributes : new AudioAttributesCompat.Builder().build();
        mp.setAudioAttributes(aa);
        mp.setAudioSessionId(audioSessionId);
        mp.setMediaItem(new UriMediaItem2.Builder(context, uri).build());
        if (holder != null) {
            mp.setSurface(holder.getSurface());
        }
        final Monitor onPrepareCalled = new Monitor();
        ExecutorService executor = Executors.newFixedThreadPool(1);
        MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

            @Override
            public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
                if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                    onPrepareCalled.signal();
                }
            }
        };
        mp.setEventCallback(executor, ecb);
        mp.prepare();
        onPrepareCalled.waitForSignal();
        mp.clearEventCallback();
        executor.shutdown();
        return mp;
    } catch (IllegalArgumentException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    } catch (SecurityException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    } catch (InterruptedException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    }
    return null;
}
#end_block

#method_before
protected MediaPlayer2 createMediaPlayer2(Context context, int resid, AudioAttributesCompat audioAttributes, int audioSessionId) {
    try {
        AssetFileDescriptor afd = context.getResources().openRawResourceFd(resid);
        if (afd == null) {
            return null;
        }
        mFdsToClose.add(afd);
        MediaPlayer2 mp = createMediaPlayer2OnUiThread();
        final AudioAttributesCompat aa = audioAttributes != null ? audioAttributes : new AudioAttributesCompat.Builder().build();
        mp.setAudioAttributes(aa);
        mp.setAudioSessionId(audioSessionId);
        mp.setDataSource(new FileMediaItem2.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build());
        final Monitor onPrepareCalled = new Monitor();
        ExecutorService executor = Executors.newFixedThreadPool(1);
        MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

            @Override
            public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
                if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                    onPrepareCalled.signal();
                }
            }
        };
        mp.setEventCallback(executor, ecb);
        mp.prepare();
        onPrepareCalled.waitForSignal();
        mp.clearEventCallback();
        afd.close();
        executor.shutdown();
        return mp;
    } catch (IOException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    } catch (IllegalArgumentException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    } catch (SecurityException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    } catch (InterruptedException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    }
    return null;
}
#method_after
protected MediaPlayer2 createMediaPlayer2(Context context, int resid, AudioAttributesCompat audioAttributes, int audioSessionId) {
    try {
        AssetFileDescriptor afd = context.getResources().openRawResourceFd(resid);
        if (afd == null) {
            return null;
        }
        mFdsToClose.add(afd);
        MediaPlayer2 mp = createMediaPlayer2OnUiThread();
        final AudioAttributesCompat aa = audioAttributes != null ? audioAttributes : new AudioAttributesCompat.Builder().build();
        mp.setAudioAttributes(aa);
        mp.setAudioSessionId(audioSessionId);
        mp.setMediaItem(new FileMediaItem2.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build());
        final Monitor onPrepareCalled = new Monitor();
        ExecutorService executor = Executors.newFixedThreadPool(1);
        MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

            @Override
            public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
                if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                    onPrepareCalled.signal();
                }
            }
        };
        mp.setEventCallback(executor, ecb);
        mp.prepare();
        onPrepareCalled.waitForSignal();
        mp.clearEventCallback();
        afd.close();
        executor.shutdown();
        return mp;
    } catch (IOException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    } catch (IllegalArgumentException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    } catch (SecurityException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    } catch (InterruptedException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    }
    return null;
}
#end_block

#method_before
protected boolean loadResource(int resid) throws Exception {
    /* FIXME: ensure device has capability.
        if (!MediaUtils.hasCodecsForResource(mContext, resid)) {
            return false;
        }
        */
    AssetFileDescriptor afd = mResources.openRawResourceFd(resid);
    try {
        mPlayer.setDataSource(new FileMediaItem2.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build());
    } finally {
        // Close descriptor later when test finishes since setDataSource is async operation.
        mFdsToClose.add(afd);
    }
    return true;
}
#method_after
protected boolean loadResource(int resid) throws Exception {
    /* FIXME: ensure device has capability.
        if (!MediaUtils.hasCodecsForResource(mContext, resid)) {
            return false;
        }
        */
    AssetFileDescriptor afd = mResources.openRawResourceFd(resid);
    try {
        mPlayer.setMediaItem(new FileMediaItem2.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build());
    } finally {
        // Close descriptor later when test finishes since setMediaItem is async operation.
        mFdsToClose.add(afd);
    }
    return true;
}
#end_block

#method_before
protected void playVideoWithRetries(String path, Integer width, Integer height, int playTime) throws Exception {
    boolean playedSuccessfully = false;
    final Uri uri = Uri.parse(path);
    for (int i = 0; i < STREAM_RETRIES; i++) {
        try {
            mPlayer.setDataSource(new UriMediaItem2.Builder(mContext, uri).build());
            playLoadedVideo(width, height, playTime);
            playedSuccessfully = true;
            break;
        } catch (PrepareFailedException e) {
            // prepare() can fail because of network issues, so try again
            LOG.warning("prepare() failed on try " + i + ", trying playback again");
        }
    }
    assertTrue("Stream did not play successfully after all attempts", playedSuccessfully);
}
#method_after
protected void playVideoWithRetries(String path, Integer width, Integer height, int playTime) throws Exception {
    boolean playedSuccessfully = false;
    final Uri uri = Uri.parse(path);
    for (int i = 0; i < STREAM_RETRIES; i++) {
        try {
            mPlayer.setMediaItem(new UriMediaItem2.Builder(mContext, uri).build());
            playLoadedVideo(width, height, playTime);
            playedSuccessfully = true;
            break;
        } catch (PrepareFailedException e) {
            // prepare() can fail because of network issues, so try again
            LOG.warning("prepare() failed on try " + i + ", trying playback again");
        }
    }
    assertTrue("Stream did not play successfully after all attempts", playedSuccessfully);
}
#end_block

#method_before
protected void playVideoWithRetries(Uri uri, Map<String, String> headers, List<HttpCookie> cookies, Integer width, Integer height, int playTime) throws Exception {
    boolean playedSuccessfully = false;
    for (int i = 0; i < STREAM_RETRIES; i++) {
        try {
            mPlayer.setDataSource(new UriMediaItem2.Builder(mContext, uri, headers, cookies).build());
            playLoadedVideo(width, height, playTime);
            playedSuccessfully = true;
            break;
        } catch (PrepareFailedException e) {
            // prepare() can fail because of network issues, so try again
            // playLoadedVideo already has reset the player so we can try again safely.
            LOG.warning("prepare() failed on try " + i + ", trying playback again");
        }
    }
    assertTrue("Stream did not play successfully after all attempts", playedSuccessfully);
}
#method_after
protected void playVideoWithRetries(Uri uri, Map<String, String> headers, List<HttpCookie> cookies, Integer width, Integer height, int playTime) throws Exception {
    boolean playedSuccessfully = false;
    for (int i = 0; i < STREAM_RETRIES; i++) {
        try {
            mPlayer.setMediaItem(new UriMediaItem2.Builder(mContext, uri, headers, cookies).build());
            playLoadedVideo(width, height, playTime);
            playedSuccessfully = true;
            break;
        } catch (PrepareFailedException e) {
            // prepare() can fail because of network issues, so try again
            // playLoadedVideo already has reset the player so we can try again safely.
            LOG.warning("prepare() failed on try " + i + ", trying playback again");
        }
    }
    assertTrue("Stream did not play successfully after all attempts", playedSuccessfully);
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
static /* synthetic access */
void handleDataSource(MediaPlayerSource src) throws IOException {
    final MediaItem2 item = src.getDSD();
    Preconditions.checkArgument(item != null, "the MediaItem2 cannot be null");
    MediaPlayer player = src.getPlayer();
    if (item instanceof CallbackMediaItem2) {
        player.setDataSource(new MediaDataSource() {

            DataSourceCallback2 mDataSource = ((CallbackMediaItem2) item).getDataSourceCallback2();

            @Override
            public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
                return mDataSource.readAt(position, buffer, offset, size);
            }

            @Override
            public long getSize() throws IOException {
                return mDataSource.getSize();
            }

            @Override
            public void close() throws IOException {
                mDataSource.close();
            }
        });
    } else if (item instanceof FileMediaItem2) {
        FileMediaItem2 fitem = (FileMediaItem2) item;
        player.setDataSource(fitem.getFileDescriptor(), fitem.getFileDescriptorOffset(), fitem.getFileDescriptorLength());
    } else if (item instanceof UriMediaItem2) {
        UriMediaItem2 uitem = (UriMediaItem2) item;
        player.setDataSource(uitem.getUriContext(), uitem.getUri(), uitem.getUriHeaders(), uitem.getUriCookies());
    } else {
        throw new IllegalArgumentException("Unsupported data source description. " + item.toString());
    }
}
#method_after
@SuppressWarnings("WeakerAccess")
static /* synthetic access */
void handleDataSource(MediaPlayerSource src) throws IOException {
    final MediaItem2 item = src.getDSD();
    Preconditions.checkArgument(item != null, "the MediaItem2 cannot be null");
    MediaPlayer player = src.getPlayer();
    if (item instanceof CallbackMediaItem2) {
        player.setDataSource(new MediaDataSource() {

            DataSourceCallback2 mDataSource = ((CallbackMediaItem2) item).getDataSourceCallback2();

            @Override
            public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
                return mDataSource.readAt(position, buffer, offset, size);
            }

            @Override
            public long getSize() throws IOException {
                return mDataSource.getSize();
            }

            @Override
            public void close() throws IOException {
                mDataSource.close();
            }
        });
    } else if (item instanceof FileMediaItem2) {
        FileMediaItem2 fitem = (FileMediaItem2) item;
        player.setDataSource(fitem.getFileDescriptor(), fitem.getFileDescriptorOffset(), fitem.getFileDescriptorLength());
    } else if (item instanceof UriMediaItem2) {
        UriMediaItem2 uitem = (UriMediaItem2) item;
        player.setDataSource(uitem.getUriContext(), uitem.getUri(), uitem.getUriHeaders(), uitem.getUriCookies());
    } else {
        throw new IllegalArgumentException("Unsupported media item description. " + item.toString());
    }
}
#end_block

#method_before
@Override
public void run() {
    int status = CALL_STATUS_NO_ERROR;
    boolean skip;
    synchronized (mTaskLock) {
        skip = mSkip;
    }
    if (!skip) {
        try {
            if (mMediaCallType != CALL_COMPLETED_NOTIFY_WHEN_COMMAND_LABEL_REACHED && getState() == PLAYER_STATE_ERROR) {
                status = CALL_STATUS_INVALID_OPERATION;
            } else {
                process();
            }
        } catch (IllegalStateException e) {
            status = CALL_STATUS_INVALID_OPERATION;
        } catch (IllegalArgumentException e) {
            status = CALL_STATUS_BAD_VALUE;
        } catch (SecurityException e) {
            status = CALL_STATUS_PERMISSION_DENIED;
        } catch (IOException e) {
            status = CALL_STATUS_ERROR_IO;
        } catch (Exception e) {
            status = CALL_STATUS_ERROR_UNKNOWN;
        }
    } else {
        status = CALL_STATUS_SKIPPED;
    }
    mDSD = getCurrentDataSource();
    if (!mNeedToWaitForEventToComplete || status != CALL_STATUS_NO_ERROR || skip) {
        sendCompleteNotification(status);
        synchronized (mTaskLock) {
            mCurrentTask = null;
            processPendingTask_l();
        }
    }
}
#method_after
@Override
public void run() {
    int status = CALL_STATUS_NO_ERROR;
    boolean skip;
    synchronized (mTaskLock) {
        skip = mSkip;
    }
    if (!skip) {
        try {
            if (mMediaCallType != CALL_COMPLETED_NOTIFY_WHEN_COMMAND_LABEL_REACHED && getState() == PLAYER_STATE_ERROR) {
                status = CALL_STATUS_INVALID_OPERATION;
            } else {
                process();
            }
        } catch (IllegalStateException e) {
            status = CALL_STATUS_INVALID_OPERATION;
        } catch (IllegalArgumentException e) {
            status = CALL_STATUS_BAD_VALUE;
        } catch (SecurityException e) {
            status = CALL_STATUS_PERMISSION_DENIED;
        } catch (IOException e) {
            status = CALL_STATUS_ERROR_IO;
        } catch (Exception e) {
            status = CALL_STATUS_ERROR_UNKNOWN;
        }
    } else {
        status = CALL_STATUS_SKIPPED;
    }
    mDSD = getCurrentMediaItem();
    if (!mNeedToWaitForEventToComplete || status != CALL_STATUS_NO_ERROR || skip) {
        sendCompleteNotification(status);
        synchronized (mTaskLock) {
            mCurrentTask = null;
            processPendingTask_l();
        }
    }
}
#end_block

#method_before
synchronized void setFirst(MediaItem2 item) throws IOException {
    if (mQueue.isEmpty()) {
        mQueue.add(0, new MediaPlayerSource(item));
    } else {
        mQueue.get(0).mDSD = item;
        setUpListeners(mQueue.get(0));
    }
    handleDataSource(mQueue.get(0));
    notifyPlayerEvent(new PlayerEventNotifier() {

        @Override
        public void notify(PlayerEventCallback cb) {
            cb.onCurrentDataSourceChanged(mMediaPlayerConnectorImpl, mQueue.get(0).mDSD);
        }
    });
}
#method_after
synchronized void setFirst(MediaItem2 item) throws IOException {
    if (mQueue.isEmpty()) {
        mQueue.add(0, new MediaPlayerSource(item));
    } else {
        mQueue.get(0).mDSD = item;
        setUpListeners(mQueue.get(0));
    }
    handleDataSource(mQueue.get(0));
    notifyPlayerEvent(new PlayerEventNotifier() {

        @Override
        public void notify(PlayerEventCallback cb) {
            cb.onCurrentMediaItemChanged(mMediaPlayerConnectorImpl, mQueue.get(0).mDSD);
        }
    });
}
#end_block

#method_before
synchronized DataSourceError setNext(MediaItem2 item) {
    if (mQueue.isEmpty() || getFirst().getDSD() == null) {
        throw new IllegalStateException();
    }
    // Clear next data sources if any.
    while (mQueue.size() >= 2) {
        MediaPlayerSource src = mQueue.remove(1);
        src.mPlayer.release();
    }
    MediaPlayerSource src = new MediaPlayerSource(item);
    mQueue.add(1, src);
    return prepareAt(1);
}
#method_after
synchronized DataSourceError setNext(MediaItem2 item) {
    if (mQueue.isEmpty() || getFirst().getDSD() == null) {
        throw new IllegalStateException();
    }
    // Clear next media items if any.
    while (mQueue.size() >= 2) {
        MediaPlayerSource src = mQueue.remove(1);
        src.mPlayer.release();
    }
    MediaPlayerSource src = new MediaPlayerSource(item);
    mQueue.add(1, src);
    return prepareAt(1);
}
#end_block

#method_before
synchronized DataSourceError setNextMultiple(List<MediaItem2> descs) {
    if (mQueue.isEmpty() || getFirst().getDSD() == null) {
        throw new IllegalStateException();
    }
    // Clear next data sources if any.
    while (mQueue.size() >= 2) {
        MediaPlayerSource src = mQueue.remove(1);
        src.mPlayer.release();
    }
    List<MediaPlayerSource> sources = new ArrayList<>();
    for (MediaItem2 item : descs) {
        sources.add(new MediaPlayerSource(item));
    }
    mQueue.addAll(1, sources);
    return prepareAt(1);
}
#method_after
synchronized DataSourceError setNextMultiple(List<MediaItem2> descs) {
    if (mQueue.isEmpty() || getFirst().getDSD() == null) {
        throw new IllegalStateException();
    }
    // Clear next media items if any.
    while (mQueue.size() >= 2) {
        MediaPlayerSource src = mQueue.remove(1);
        src.mPlayer.release();
    }
    List<MediaPlayerSource> sources = new ArrayList<>();
    for (MediaItem2 item : descs) {
        sources.add(new MediaPlayerSource(item));
    }
    mQueue.addAll(1, sources);
    return prepareAt(1);
}
#end_block

#method_before
synchronized DataSourceError onPrepared(MediaPlayer mp) {
    for (int i = 0; i < mQueue.size(); i++) {
        MediaPlayerSource src = mQueue.get(i);
        if (mp == src.getPlayer()) {
            if (i == 0) {
                if (src.mPlayPending) {
                    src.mPlayPending = false;
                    src.getPlayer().start();
                    setMp2State(src.getPlayer(), PLAYER_STATE_PLAYING);
                } else {
                    setMp2State(src.getPlayer(), PLAYER_STATE_PREPARED);
                }
            }
            src.mSourceState = SOURCE_STATE_PREPARED;
            setBufferingState(src.getPlayer(), MediaPlayerConnector.BUFFERING_STATE_BUFFERING_AND_PLAYABLE);
            if (i == 1) {
                boolean hasVideo = false;
                for (MediaPlayer.TrackInfo info : mp.getTrackInfo()) {
                    if (info.getTrackType() == MediaPlayer.TrackInfo.MEDIA_TRACK_TYPE_VIDEO) {
                        hasVideo = true;
                        break;
                    }
                }
                // for the audio-only data source.
                if (!hasVideo) {
                    getCurrentPlayer().setNextMediaPlayer(src.mPlayer);
                    src.mSetAsNextPlayer = true;
                }
            }
            return prepareAt(i + 1);
        }
    }
    return null;
}
#method_after
synchronized DataSourceError onPrepared(MediaPlayer mp) {
    for (int i = 0; i < mQueue.size(); i++) {
        MediaPlayerSource src = mQueue.get(i);
        if (mp == src.getPlayer()) {
            if (i == 0) {
                if (src.mPlayPending) {
                    src.mPlayPending = false;
                    src.getPlayer().start();
                    setMp2State(src.getPlayer(), PLAYER_STATE_PLAYING);
                } else {
                    setMp2State(src.getPlayer(), PLAYER_STATE_PREPARED);
                }
            }
            src.mSourceState = SOURCE_STATE_PREPARED;
            setBufferingState(src.getPlayer(), MediaPlayerConnector.BUFFERING_STATE_BUFFERING_AND_PLAYABLE);
            if (i == 1) {
                boolean hasVideo = false;
                for (MediaPlayer.TrackInfo info : mp.getTrackInfo()) {
                    if (info.getTrackType() == MediaPlayer.TrackInfo.MEDIA_TRACK_TYPE_VIDEO) {
                        hasVideo = true;
                        break;
                    }
                }
                // for the audio-only media item.
                if (!hasVideo) {
                    getCurrentPlayer().setNextMediaPlayer(src.mPlayer);
                    src.mSetAsNextPlayer = true;
                }
            }
            return prepareAt(i + 1);
        }
    }
    return null;
}
#end_block

#method_before
synchronized DataSourceError onCompletion(MediaPlayer mp) {
    final MediaPlayerSource src = getFirst();
    if (mLooping && mp == src.mPlayer) {
        notifyMediaPlayer2Event(new Mp2EventNotifier() {

            @Override
            public void notify(EventCallback cb) {
                MediaPlayer2Impl mp2 = MediaPlayer2Impl.this;
                MediaItem2 item = src.getDSD();
                cb.onInfo(mp2, item, MEDIA_INFO_DATA_SOURCE_REPEAT, 0);
            }
        });
        src.mPlayer.seekTo((int) src.getDSD().getStartPosition());
        src.mPlayer.start();
        setMp2State(mp, PLAYER_STATE_PLAYING);
        return null;
    }
    if (mp == src.mPlayer) {
        notifyMediaPlayer2Event(new Mp2EventNotifier() {

            @Override
            public void notify(EventCallback cb) {
                MediaPlayer2Impl mp2 = MediaPlayer2Impl.this;
                MediaItem2 item = src.getDSD();
                cb.onInfo(mp2, item, MEDIA_INFO_DATA_SOURCE_END, 0);
            }
        });
    } else {
        Log.w(TAG, "Playback complete event from next player. Ignoring.");
    }
    if (!mQueue.isEmpty() && mp == src.mPlayer) {
        if (mQueue.size() == 1) {
            setMp2State(mp, PLAYER_STATE_PAUSED);
            final MediaItem2 item = mQueue.get(0).getDSD();
            notifyPlayerEvent(new PlayerEventNotifier() {

                @Override
                public void notify(PlayerEventCallback cb) {
                    cb.onCurrentDataSourceChanged(mMediaPlayerConnectorImpl, null);
                }
            });
            notifyMediaPlayer2Event(new Mp2EventNotifier() {

                @Override
                public void notify(EventCallback callback) {
                    callback.onInfo(MediaPlayer2Impl.this, item, MEDIA_INFO_DATA_SOURCE_LIST_END, 0);
                }
            });
            return null;
        } else {
            if (mQueue.get(1).mSetAsNextPlayer) {
                // event later.
                return null;
            }
            moveToNext();
            return playCurrent();
        }
    } else {
        Log.w(TAG, "Invalid playback complete callback from " + mp.toString());
        return null;
    }
}
#method_after
synchronized DataSourceError onCompletion(MediaPlayer mp) {
    final MediaPlayerSource src = getFirst();
    if (mLooping && mp == src.mPlayer) {
        notifyMediaPlayer2Event(new Mp2EventNotifier() {

            @Override
            public void notify(EventCallback cb) {
                MediaPlayer2Impl mp2 = MediaPlayer2Impl.this;
                MediaItem2 item = src.getDSD();
                cb.onInfo(mp2, item, MEDIA_INFO_DATA_SOURCE_REPEAT, 0);
            }
        });
        src.mPlayer.seekTo((int) src.getDSD().getStartPosition());
        src.mPlayer.start();
        setMp2State(mp, PLAYER_STATE_PLAYING);
        return null;
    }
    if (mp == src.mPlayer) {
        notifyMediaPlayer2Event(new Mp2EventNotifier() {

            @Override
            public void notify(EventCallback cb) {
                MediaPlayer2Impl mp2 = MediaPlayer2Impl.this;
                MediaItem2 item = src.getDSD();
                cb.onInfo(mp2, item, MEDIA_INFO_DATA_SOURCE_END, 0);
            }
        });
    } else {
        Log.w(TAG, "Playback complete event from next player. Ignoring.");
    }
    if (!mQueue.isEmpty() && mp == src.mPlayer) {
        if (mQueue.size() == 1) {
            setMp2State(mp, PLAYER_STATE_PAUSED);
            final MediaItem2 item = mQueue.get(0).getDSD();
            notifyPlayerEvent(new PlayerEventNotifier() {

                @Override
                public void notify(PlayerEventCallback cb) {
                    cb.onCurrentMediaItemChanged(mMediaPlayerConnectorImpl, null);
                }
            });
            notifyMediaPlayer2Event(new Mp2EventNotifier() {

                @Override
                public void notify(EventCallback callback) {
                    callback.onInfo(MediaPlayer2Impl.this, item, MEDIA_INFO_DATA_SOURCE_LIST_END, 0);
                }
            });
            return null;
        } else {
            if (mQueue.get(1).mSetAsNextPlayer) {
                // event later.
                return null;
            }
            moveToNext();
            return playCurrent();
        }
    } else {
        Log.w(TAG, "Invalid playback complete callback from " + mp.toString());
        return null;
    }
}
#end_block

#method_before
synchronized void moveToNext() {
    final MediaPlayerSource src1 = mQueue.remove(0);
    src1.getPlayer().release();
    if (mQueue.isEmpty()) {
        throw new IllegalStateException("player/source queue emptied");
    }
    final MediaPlayerSource src2 = mQueue.get(0);
    if (src1.mPlayerState != src2.mPlayerState) {
        notifyPlayerEvent(new PlayerEventNotifier() {

            @Override
            public void notify(PlayerEventCallback cb) {
                cb.onPlayerStateChanged(mMediaPlayerConnectorImpl, src2.mPlayerState);
            }
        });
    }
    notifyPlayerEvent(new PlayerEventNotifier() {

        @Override
        public void notify(PlayerEventCallback cb) {
            cb.onCurrentDataSourceChanged(mMediaPlayerConnectorImpl, src2.mDSD);
        }
    });
}
#method_after
synchronized void moveToNext() {
    final MediaPlayerSource src1 = mQueue.remove(0);
    src1.getPlayer().release();
    if (mQueue.isEmpty()) {
        throw new IllegalStateException("player/source queue emptied");
    }
    final MediaPlayerSource src2 = mQueue.get(0);
    if (src1.mPlayerState != src2.mPlayerState) {
        notifyPlayerEvent(new PlayerEventNotifier() {

            @Override
            public void notify(PlayerEventCallback cb) {
                cb.onPlayerStateChanged(mMediaPlayerConnectorImpl, src2.mPlayerState);
            }
        });
    }
    notifyPlayerEvent(new PlayerEventNotifier() {

        @Override
        public void notify(PlayerEventCallback cb) {
            cb.onCurrentMediaItemChanged(mMediaPlayerConnectorImpl, src2.mDSD);
        }
    });
}
#end_block

#method_before
synchronized DataSourceError prepareAt(int n) {
    if (n >= Math.min(2, mQueue.size()) || mQueue.get(n).mSourceState != SOURCE_STATE_INIT || (n != 0 && getPlayerState() == MediaPlayerConnector.PLAYER_STATE_IDLE)) {
        // There is no next source or it's in preparing or prepared state.
        return null;
    }
    MediaPlayerSource src = mQueue.get(n);
    try {
        // Apply audio session ID before calling setDataSource().
        if (mAudioSessionId != null) {
            src.getPlayer().setAudioSessionId(mAudioSessionId);
        }
        src.mSourceState = SOURCE_STATE_PREPARING;
        handleDataSource(src);
        src.getPlayer().prepareAsync();
        return null;
    } catch (Exception e) {
        MediaItem2 item = src.getDSD();
        setMp2State(src.getPlayer(), PLAYER_STATE_ERROR);
        return new DataSourceError(item, MEDIA_ERROR_UNKNOWN, MEDIA_ERROR_UNSUPPORTED);
    }
}
#method_after
synchronized DataSourceError prepareAt(int n) {
    if (n >= Math.min(2, mQueue.size()) || mQueue.get(n).mSourceState != SOURCE_STATE_INIT || (n != 0 && getPlayerState() == MediaPlayerConnector.PLAYER_STATE_IDLE)) {
        // There is no next source or it's in preparing or prepared state.
        return null;
    }
    MediaPlayerSource src = mQueue.get(n);
    try {
        // Apply audio session ID before calling setMediaItem().
        if (mAudioSessionId != null) {
            src.getPlayer().setAudioSessionId(mAudioSessionId);
        }
        src.mSourceState = SOURCE_STATE_PREPARING;
        handleDataSource(src);
        src.getPlayer().prepareAsync();
        return null;
    } catch (Exception e) {
        MediaItem2 item = src.getDSD();
        setMp2State(src.getPlayer(), PLAYER_STATE_ERROR);
        return new DataSourceError(item, MEDIA_ERROR_UNKNOWN, MEDIA_ERROR_UNSUPPORTED);
    }
}
#end_block

#method_before
@Test
public void testCurrentMediaItemChange() throws Exception {
    prepareLooper();
    String displayTitle = "displayTitle";
    MediaMetadata2 metadata = new MediaMetadata2.Builder().putText(MediaMetadata2.METADATA_KEY_DISPLAY_TITLE, displayTitle).build();
    MediaItem2 currentMediaItem = new FileMediaItem2.Builder(new FileDescriptor(), metadata).setFlags(FLAG_PLAYABLE).build();
    List<MediaItem2> playlist = MediaTestUtils.createPlaylist(5);
    final int testItemIndex = 3;
    playlist.set(testItemIndex, currentMediaItem);
    mSession.getMockPlaylistAgent().setPlaylistWithDummyItem(playlist);
    final MediaControllerCallback controllerCallback = new MediaControllerCallback();
    controllerCallback.reset(1);
    mControllerCompat.registerCallback(controllerCallback, sHandler);
    mSession.getMockPlaylistAgent().setCurrentMediaItem(testItemIndex);
    mSession.getMockPlayer().notifyCurrentDataSourceChanged(testItemIndex);
    assertTrue(controllerCallback.await(TIMEOUT_MS));
    assertTrue(controllerCallback.mOnMetadataChangedCalled);
    assertEquals(displayTitle, controllerCallback.mMediaMetadata.getString(MediaMetadata2.METADATA_KEY_DISPLAY_TITLE));
}
#method_after
@Test
public void testCurrentMediaItemChange() throws Exception {
    prepareLooper();
    String displayTitle = "displayTitle";
    MediaMetadata2 metadata = new MediaMetadata2.Builder().putText(MediaMetadata2.METADATA_KEY_DISPLAY_TITLE, displayTitle).build();
    MediaItem2 currentMediaItem = new FileMediaItem2.Builder(new FileDescriptor()).setMetadata(metadata).build();
    List<MediaItem2> playlist = MediaTestUtils.createPlaylist(5);
    final int testItemIndex = 3;
    playlist.set(testItemIndex, currentMediaItem);
    mSession.getMockPlaylistAgent().setPlaylistWithDummyItem(playlist);
    final MediaControllerCallback controllerCallback = new MediaControllerCallback();
    controllerCallback.reset(1);
    mControllerCompat.registerCallback(controllerCallback, sHandler);
    mSession.getMockPlaylistAgent().setCurrentMediaItem(testItemIndex);
    mSession.getMockPlayer().notifyCurrentDataSourceChanged(testItemIndex);
    assertTrue(controllerCallback.await(TIMEOUT_MS));
    assertTrue(controllerCallback.mOnMetadataChangedCalled);
    assertEquals(displayTitle, controllerCallback.mMediaMetadata.getString(MediaMetadata2.METADATA_KEY_DISPLAY_TITLE));
}
#end_block

#method_before
@Override
public void skipToNext() {
// No-op. This skipToNext() means 'skip to next item in the setNextDataSources()'
}
#method_after
@Override
public void skipToNext() {
// No-op. This skipToNext() means 'skip to next item in the setNextMediaItems()'
}
#end_block

#method_before
public void notifyCurrentDataSourceChanged(final MediaItem2 item) {
    for (int i = 0; i < mCallbacks.size(); i++) {
        final PlayerEventCallback callback = mCallbacks.keyAt(i);
        final Executor executor = mCallbacks.valueAt(i);
        executor.execute(new Runnable() {

            @Override
            public void run() {
                callback.onCurrentDataSourceChanged(MockPlayer.this, item);
            }
        });
    }
}
#method_after
public void notifyCurrentDataSourceChanged(final MediaItem2 item) {
    for (int i = 0; i < mCallbacks.size(); i++) {
        final PlayerEventCallback callback = mCallbacks.keyAt(i);
        final Executor executor = mCallbacks.valueAt(i);
        executor.execute(new Runnable() {

            @Override
            public void run() {
                callback.onCurrentMediaItemChanged(MockPlayer.this, item);
            }
        });
    }
}
#end_block

#method_before
public void notifyRoutesInfoChanged(@NonNull ControllerInfo controller, @Nullable List<Bundle> routes) {
    mImpl.notifyRoutesInfoChanged(controller, routes);
}
#method_after
@RestrictTo(LIBRARY_GROUP)
public void notifyRoutesInfoChanged(@NonNull ControllerInfo controller, @Nullable List<Bundle> routes) {
    mImpl.notifyRoutesInfoChanged(controller, routes);
}
#end_block

#method_before
public void onSubscribeRoutesInfo(@NonNull MediaSession2 session, @NonNull ControllerInfo controller) {
}
#method_after
@RestrictTo(LIBRARY_GROUP)
public void onSubscribeRoutesInfo(@NonNull MediaSession2 session, @NonNull ControllerInfo controller) {
}
#end_block

#method_before
public void onUnsubscribeRoutesInfo(@NonNull MediaSession2 session, @NonNull ControllerInfo controller) {
}
#method_after
@RestrictTo(LIBRARY_GROUP)
public void onUnsubscribeRoutesInfo(@NonNull MediaSession2 session, @NonNull ControllerInfo controller) {
}
#end_block

#method_before
public void onSelectRoute(@NonNull MediaSession2 session, @NonNull ControllerInfo controller, @NonNull Bundle route) {
}
#method_after
@RestrictTo(LIBRARY_GROUP)
public void onSelectRoute(@NonNull MediaSession2 session, @NonNull ControllerInfo controller, @NonNull Bundle route) {
}
#end_block

#method_before
@NonNull
public CommandButton build() {
    return new CommandButton(mCommand, mIconResId, mDisplayName, mExtras, mEnabled);
}
#method_after
@Override
@NonNull
public MediaSession2 build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new SessionCallback() {
        };
    }
    return new MediaSession2(mContext, mId, mPlayer, mPlaylistAgent, mSessionActivity, mCallbackExecutor, mCallback);
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> prepare() {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_PREPARE, future));
        mPlayer.prepare();
    }
    // TODO: Changing buffering state is not correct. Think about changing MP2 event APIs for
    // the initial buffering for prepare case.
    setBufferingState(mPlayer.getCurrentDataSource(), BUFFERING_STATE_BUFFERING_AND_STARVED);
    return future;
}
#method_after
@Override
public ListenableFuture<CommandResult2> prepare() {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_PREPARE, future));
        mPlayer.prepare();
    }
    // TODO: Changing buffering state is not correct. Think about changing MP2 event APIs for
    // the initial buffering for prepare case.
    setBufferingState(mPlayer.getCurrentMediaItem(), BUFFERING_STATE_BUFFERING_AND_STARVED);
    return future;
}
#end_block

#method_before
@Override
public int getBufferingState() {
    Integer buffState;
    synchronized (mStateLock) {
        buffState = mDSDToBuffStateMap.get(mPlayer.getCurrentDataSource());
    }
    return buffState == null ? BUFFERING_STATE_UNKNOWN : buffState;
}
#method_after
@Override
public int getBufferingState() {
    Integer buffState;
    synchronized (mStateLock) {
        buffState = mMediaItemToBuffState.get(mPlayer.getCurrentMediaItem());
    }
    return buffState == null ? BUFFERING_STATE_UNKNOWN : buffState;
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> setMediaItem(MediaItem2 item) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE, future));
        mPlayer.setDataSource(item);
    }
    return future;
}
#method_after
@Override
public ListenableFuture<CommandResult2> setMediaItem(MediaItem2 item) {
    SettableFuture<CommandResult2> future = SettableFuture.create();
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.add(new Pair<>(MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE, future));
        mPlayer.setMediaItem(item);
    }
    return future;
}
#end_block

#method_before
@Override
public ListenableFuture<CommandResult2> skipToPlaylistItem(MediaItem2 desc) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public ListenableFuture<CommandResult2> skipToPlaylistItem(MediaItem2 item) {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
public void reset() {
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.clear();
        mPlayer.reset();
    }
    synchronized (mStateLock) {
        mState = PLAYER_STATE_IDLE;
        mDSDToBuffStateMap.clear();
    }
}
#method_after
public void reset() {
    synchronized (mCallTypeAndFutures) {
        mCallTypeAndFutures.clear();
        mPlayer.reset();
    }
    synchronized (mStateLock) {
        mState = PLAYER_STATE_IDLE;
        mMediaItemToBuffState.clear();
    }
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void setBufferingState(final MediaItem2 item, @BuffState final int state) {
    Integer previousState;
    synchronized (mStateLock) {
        previousState = mDSDToBuffStateMap.put(item, state);
    }
    if (previousState == null || previousState.intValue() != state) {
        notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

            @Override
            public void callCallback(SessionPlayer2.PlayerCallback callback) {
                callback.onBufferingStateChanged(XMediaPlayer.this, item, state);
            }
        });
    }
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void setBufferingState(final MediaItem2 item, @BuffState final int state) {
    Integer previousState;
    synchronized (mStateLock) {
        previousState = mMediaItemToBuffState.put(item, state);
    }
    if (previousState == null || previousState.intValue() != state) {
        notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

            @Override
            public void callCallback(SessionPlayer2.PlayerCallback callback) {
                callback.onBufferingStateChanged(XMediaPlayer.this, item, state);
            }
        });
    }
}
#end_block

#method_before
@Override
public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
    Pair<Integer, SettableFuture<CommandResult2>> pair;
    synchronized (mCallTypeAndFutures) {
        pair = mCallTypeAndFutures.pollFirst();
    }
    if (what != pair.first) {
        Log.w(TAG, "Call type does not match. expeced:" + pair.first + " actual:" + what);
        status = MediaPlayer2.CALL_STATUS_ERROR_UNKNOWN;
    }
    if (status == MediaPlayer2.CALL_STATUS_NO_ERROR) {
        switch(what) {
            case MediaPlayer2.CALL_COMPLETED_PREPARE:
            case MediaPlayer2.CALL_COMPLETED_PAUSE:
                setState(PLAYER_STATE_PAUSED);
                break;
            case MediaPlayer2.CALL_COMPLETED_PLAY:
                setState(PLAYER_STATE_PLAYING);
                break;
            case MediaPlayer2.CALL_COMPLETED_SEEK_TO:
                final long pos = mPlayer.getCurrentPosition();
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer2.PlayerCallback callback) {
                        callback.onSeekCompleted(XMediaPlayer.this, pos);
                    }
                });
                break;
            case MediaPlayer2.CALL_COMPLETED_SET_PLAYBACK_PARAMS:
                // TODO: Need to check if the speed value is really changed.
                final float speed = mPlayer.getPlaybackParams().getSpeed();
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer2.PlayerCallback callback) {
                        callback.onPlaybackSpeedChanged(XMediaPlayer.this, speed);
                    }
                });
                break;
        }
    }
    // TODO: more handling on listenable future. e.g. Canceling.
    Integer resultCode = sResultCodeMap.get(status);
    pair.second.set(new CommandResult2(resultCode == null ? RESULT_CODE_ERROR_UNKNOWN : resultCode, System.currentTimeMillis(), item));
}
#method_after
@Override
public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
    Pair<Integer, SettableFuture<CommandResult2>> pair;
    synchronized (mCallTypeAndFutures) {
        pair = mCallTypeAndFutures.pollFirst();
    }
    if (what != pair.first) {
        Log.w(TAG, "Call type does not match. expeced:" + pair.first + " actual:" + what);
        status = MediaPlayer2.CALL_STATUS_ERROR_UNKNOWN;
    }
    if (status == MediaPlayer2.CALL_STATUS_NO_ERROR) {
        switch(what) {
            case MediaPlayer2.CALL_COMPLETED_PREPARE:
            case MediaPlayer2.CALL_COMPLETED_PAUSE:
                setState(PLAYER_STATE_PAUSED);
                break;
            case MediaPlayer2.CALL_COMPLETED_PLAY:
                setState(PLAYER_STATE_PLAYING);
                break;
            case MediaPlayer2.CALL_COMPLETED_SEEK_TO:
                final long pos = mPlayer.getCurrentPosition();
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer2.PlayerCallback callback) {
                        callback.onSeekCompleted(XMediaPlayer.this, pos);
                    }
                });
                break;
            case MediaPlayer2.CALL_COMPLETED_SET_PLAYBACK_PARAMS:
                // TODO: Need to check if the speed value is really changed.
                final float speed = mPlayer.getPlaybackParams().getSpeed();
                notifySessionPlayerCallback(new SessionPlayerCallbackNotifier() {

                    @Override
                    public void callCallback(SessionPlayer2.PlayerCallback callback) {
                        callback.onPlaybackSpeedChanged(XMediaPlayer.this, speed);
                    }
                });
                break;
        }
    }
    // TODO: more handling on listenable future. e.g. Canceling.
    Integer resultCode = sResultCodeMap.get(status);
    pair.second.set(new CommandResult2(resultCode == null ? RESULT_CODE_ERROR_UNKNOWN : resultCode, item));
}
#end_block

#method_before
@Test
public void testNotification() throws InterruptedException {
    prepareLooper();
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaLibrarySessionCallback sessionCallback = new MediaLibrarySessionCallback() {

        @Override
        public SessionCommandGroup2 onConnect(@NonNull MediaSession2 session, @NonNull ControllerInfo controller) {
            if (CLIENT_PACKAGE_NAME.equals(controller.getPackageName())) {
                mSession = session;
                // Change the player and playlist agent with ours.
                session.updatePlayerConnector(mPlayer, mPlaylistAgent);
                latch.countDown();
            }
            return super.onConnect(session, controller);
        }
    };
    TestServiceRegistry.getInstance().setSessionCallback(sessionCallback);
    // Create a controller to start the service.
    RemoteMediaController2 controller = new RemoteMediaController2(mContext, new SessionToken2(mContext, MOCK_MEDIA_SESSION_SERVICE), true);
    // Set current media item.
    final String mediaId = "testMediaId";
    Bitmap albumArt = BitmapFactory.decodeResource(mContext.getResources(), android.support.mediacompat.service.R.drawable.big_buck_bunny);
    MediaMetadata2 metadata = new MediaMetadata2.Builder().putText(MediaMetadata2.METADATA_KEY_MEDIA_ID, mediaId).putText(MediaMetadata2.METADATA_KEY_DISPLAY_TITLE, "Test Song Name").putText(MediaMetadata2.METADATA_KEY_ARTIST, "Test Artist Name").putBitmap(MediaMetadata2.METADATA_KEY_ALBUM_ART, albumArt).build();
    mPlaylistAgent.mCurrentMediaItem = new MediaItem2.Builder(metadata).setMediaId(mediaId).build();
    // Notification should be shown. Clicking play/pause button will change the player state.
    // When playing, the notification will not be removed by swiping horizontally.
    // When paused, the notification can be swiped away.
    mPlayer.notifyPlayerStateChanged(MediaPlayerConnector.PLAYER_STATE_PLAYING);
    Thread.sleep(NOTIFICATION_SHOW_TIME_MS);
}
#method_after
@Test
public void testNotification() throws InterruptedException {
    prepareLooper();
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaLibrarySessionCallback sessionCallback = new MediaLibrarySessionCallback() {

        @Override
        public SessionCommandGroup2 onConnect(@NonNull MediaSession2 session, @NonNull ControllerInfo controller) {
            if (CLIENT_PACKAGE_NAME.equals(controller.getPackageName())) {
                mSession = session;
                // Change the player and playlist agent with ours.
                session.updatePlayerConnector(mPlayer, mPlaylistAgent);
                latch.countDown();
            }
            return super.onConnect(session, controller);
        }
    };
    TestServiceRegistry.getInstance().setSessionCallback(sessionCallback);
    // Create a controller to start the service.
    RemoteMediaController2 controller = new RemoteMediaController2(mContext, new SessionToken2(mContext, MOCK_MEDIA_SESSION_SERVICE), true);
    // Set current media item.
    final String mediaId = "testMediaId";
    Bitmap albumArt = BitmapFactory.decodeResource(mContext.getResources(), android.support.mediacompat.service.R.drawable.big_buck_bunny);
    MediaMetadata2 metadata = new MediaMetadata2.Builder().putText(MediaMetadata2.METADATA_KEY_MEDIA_ID, mediaId).putText(MediaMetadata2.METADATA_KEY_DISPLAY_TITLE, "Test Song Name").putText(MediaMetadata2.METADATA_KEY_ARTIST, "Test Artist Name").putBitmap(MediaMetadata2.METADATA_KEY_ALBUM_ART, albumArt).build();
    mPlaylistAgent.mCurrentMediaItem = new MediaItem2.Builder(MediaItem2.FLAG_PLAYABLE).setMetadata(metadata).setMediaId(mediaId).build();
    // Notification should be shown. Clicking play/pause button will change the player state.
    // When playing, the notification will not be removed by swiping horizontally.
    // When paused, the notification can be swiped away.
    mPlayer.notifyPlayerStateChanged(MediaPlayerConnector.PLAYER_STATE_PLAYING);
    Thread.sleep(NOTIFICATION_SHOW_TIME_MS);
}
#end_block

#method_before
@Test
@MediumTest
public void testPlayNullSourcePath() throws Exception {
    final Monitor onSetDataSourceCalled = new Monitor();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE) {
                assertTrue(status != MediaPlayer2.CALL_STATUS_NO_ERROR);
                onSetDataSourceCalled.signal();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    onSetDataSourceCalled.reset();
    mPlayer.setDataSource((MediaItem2) null);
    onSetDataSourceCalled.waitForSignal();
}
#method_after
@Test
@MediumTest
public void testPlayNullSourcePath() throws Exception {
    final Monitor onSetDataSourceCalled = new Monitor();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE) {
                assertTrue(status != MediaPlayer2.CALL_STATUS_NO_ERROR);
                onSetDataSourceCalled.signal();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    onSetDataSourceCalled.reset();
    mPlayer.setMediaItem((MediaItem2) null);
    onSetDataSourceCalled.waitForSignal();
}
#end_block

#method_before
@Test
@LargeTest
public void testPlayAudioFromDataURI() throws Exception {
    final int mp3Duration = 34909;
    final int tolerance = 70;
    final int seekDuration = 100;
    // This is "R.raw.testmp3_2", base64-encoded.
    final int resid = R.raw.testmp3_3;
    InputStream is = mContext.getResources().openRawResource(resid);
    BufferedReader reader = new BufferedReader(new InputStreamReader(is));
    StringBuilder builder = new StringBuilder();
    builder.append("data:;base64,");
    builder.append(reader.readLine());
    Uri uri = Uri.parse(builder.toString());
    MediaPlayer2 mp = createMediaPlayer2(mContext, uri);
    final Monitor onPrepareCalled = new Monitor();
    final Monitor onPlayCalled = new Monitor();
    final Monitor onSeekToCalled = new Monitor();
    final Monitor onLoopCurrentCalled = new Monitor();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                onPrepareCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                onPlayCalled.signal();
            } else if (what == MediaPlayer2.CALL_COMPLETED_LOOP_CURRENT) {
                onLoopCurrentCalled.signal();
            } else if (what == MediaPlayer2.CALL_COMPLETED_SEEK_TO) {
                onSeekToCalled.signal();
            }
        }
    };
    mp.setEventCallback(mExecutor, ecb);
    try {
        AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
        mp.setAudioAttributes(attributes);
        assertFalse(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        onPlayCalled.reset();
        mp.play();
        onPlayCalled.waitForSignal();
        assertTrue(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        /* FIXME: what's API for checking loop state?
            assertFalse(mp.isLooping());
            */
        onLoopCurrentCalled.reset();
        mp.loopCurrent(true);
        onLoopCurrentCalled.waitForSignal();
        /* FIXME: what's API for checking loop state?
            assertTrue(mp.isLooping());
            */
        assertEquals(mp3Duration, mp.getDuration(), tolerance);
        long pos = mp.getCurrentPosition();
        assertTrue(pos >= 0);
        assertTrue(pos < mp3Duration - seekDuration);
        onSeekToCalled.reset();
        mp.seekTo(pos + seekDuration, MediaPlayer2.SEEK_PREVIOUS_SYNC);
        onSeekToCalled.waitForSignal();
        assertEquals(pos + seekDuration, mp.getCurrentPosition(), tolerance);
        // test pause and restart
        mp.pause();
        Thread.sleep(SLEEP_TIME);
        assertFalse(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        onPlayCalled.reset();
        mp.play();
        onPlayCalled.waitForSignal();
        assertTrue(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        // test stop and restart
        mp.reset();
        mp.setEventCallback(mExecutor, ecb);
        mp.setDataSource(new UriMediaItem2.Builder(mContext, uri).build());
        onPrepareCalled.reset();
        mp.prepare();
        onPrepareCalled.waitForSignal();
        assertFalse(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        onPlayCalled.reset();
        mp.play();
        onPlayCalled.waitForSignal();
        assertTrue(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        // waiting to complete
        while (mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING) {
            Thread.sleep(SLEEP_TIME);
        }
    } finally {
        mp.close();
    }
}
#method_after
@Test
@LargeTest
public void testPlayAudioFromDataURI() throws Exception {
    final int mp3Duration = 34909;
    final int tolerance = 70;
    final int seekDuration = 100;
    // This is "R.raw.testmp3_2", base64-encoded.
    final int resid = R.raw.testmp3_3;
    InputStream is = mContext.getResources().openRawResource(resid);
    BufferedReader reader = new BufferedReader(new InputStreamReader(is));
    StringBuilder builder = new StringBuilder();
    builder.append("data:;base64,");
    builder.append(reader.readLine());
    Uri uri = Uri.parse(builder.toString());
    MediaPlayer2 mp = createMediaPlayer2(mContext, uri);
    final Monitor onPrepareCalled = new Monitor();
    final Monitor onPlayCalled = new Monitor();
    final Monitor onSeekToCalled = new Monitor();
    final Monitor onLoopCurrentCalled = new Monitor();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                onPrepareCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                onPlayCalled.signal();
            } else if (what == MediaPlayer2.CALL_COMPLETED_LOOP_CURRENT) {
                onLoopCurrentCalled.signal();
            } else if (what == MediaPlayer2.CALL_COMPLETED_SEEK_TO) {
                onSeekToCalled.signal();
            }
        }
    };
    mp.setEventCallback(mExecutor, ecb);
    try {
        AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
        mp.setAudioAttributes(attributes);
        assertFalse(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        onPlayCalled.reset();
        mp.play();
        onPlayCalled.waitForSignal();
        assertTrue(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        /* FIXME: what's API for checking loop state?
            assertFalse(mp.isLooping());
            */
        onLoopCurrentCalled.reset();
        mp.loopCurrent(true);
        onLoopCurrentCalled.waitForSignal();
        /* FIXME: what's API for checking loop state?
            assertTrue(mp.isLooping());
            */
        assertEquals(mp3Duration, mp.getDuration(), tolerance);
        long pos = mp.getCurrentPosition();
        assertTrue(pos >= 0);
        assertTrue(pos < mp3Duration - seekDuration);
        onSeekToCalled.reset();
        mp.seekTo(pos + seekDuration, MediaPlayer2.SEEK_PREVIOUS_SYNC);
        onSeekToCalled.waitForSignal();
        assertEquals(pos + seekDuration, mp.getCurrentPosition(), tolerance);
        // test pause and restart
        mp.pause();
        Thread.sleep(SLEEP_TIME);
        assertFalse(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        onPlayCalled.reset();
        mp.play();
        onPlayCalled.waitForSignal();
        assertTrue(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        // test stop and restart
        mp.reset();
        mp.setEventCallback(mExecutor, ecb);
        mp.setMediaItem(new UriMediaItem2.Builder(mContext, uri).build());
        onPrepareCalled.reset();
        mp.prepare();
        onPrepareCalled.waitForSignal();
        assertFalse(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        onPlayCalled.reset();
        mp.play();
        onPlayCalled.waitForSignal();
        assertTrue(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        // waiting to complete
        while (mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING) {
            Thread.sleep(SLEEP_TIME);
        }
    } finally {
        mp.close();
    }
}
#end_block

#method_before
@Test
@LargeTest
public void testPlayAudio() throws Exception {
    final int resid = R.raw.testmp3_2;
    final int mp3Duration = 34909;
    final int tolerance = 70;
    final int seekDuration = 100;
    MediaPlayer2 mp = createMediaPlayer2(mContext, resid);
    AssetFileDescriptor afd = null;
    final Monitor onPrepareCalled = new Monitor();
    final Monitor onPlayCalled = new Monitor();
    final Monitor onSeekToCalled = new Monitor();
    final Monitor onLoopCurrentCalled = new Monitor();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                onPrepareCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                onPlayCalled.signal();
            } else if (what == MediaPlayer2.CALL_COMPLETED_LOOP_CURRENT) {
                onLoopCurrentCalled.signal();
            } else if (what == MediaPlayer2.CALL_COMPLETED_SEEK_TO) {
                onSeekToCalled.signal();
            }
        }
    };
    mp.setEventCallback(mExecutor, ecb);
    try {
        AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
        mp.setAudioAttributes(attributes);
        assertFalse(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        onPlayCalled.reset();
        mp.play();
        onPlayCalled.waitForSignal();
        assertTrue(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        // assertFalse(mp.isLooping());
        onLoopCurrentCalled.reset();
        mp.loopCurrent(true);
        onLoopCurrentCalled.waitForSignal();
        // assertTrue(mp.isLooping());
        assertEquals(mp3Duration, mp.getDuration(), tolerance);
        long pos = mp.getCurrentPosition();
        assertTrue(pos >= 0);
        assertTrue(pos < mp3Duration - seekDuration);
        onSeekToCalled.reset();
        mp.seekTo(pos + seekDuration, MediaPlayer2.SEEK_PREVIOUS_SYNC);
        onSeekToCalled.waitForSignal();
        assertEquals(pos + seekDuration, mp.getCurrentPosition(), tolerance);
        // test pause and restart
        mp.pause();
        Thread.sleep(SLEEP_TIME);
        assertFalse(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        onPlayCalled.reset();
        mp.play();
        onPlayCalled.waitForSignal();
        assertTrue(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        // test stop and restart
        mp.reset();
        afd = mResources.openRawResourceFd(resid);
        mp.setDataSource(new FileMediaItem2.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build());
        mp.setEventCallback(mExecutor, ecb);
        onPrepareCalled.reset();
        mp.prepare();
        onPrepareCalled.waitForSignal();
        afd.close();
        assertFalse(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        onPlayCalled.reset();
        mp.play();
        onPlayCalled.waitForSignal();
        assertTrue(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        // waiting to complete
        while (mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING) {
            Thread.sleep(SLEEP_TIME);
        }
    } catch (Exception e) {
        throw e;
    } finally {
        mp.close();
        afd.close();
    }
}
#method_after
@Test
@LargeTest
public void testPlayAudio() throws Exception {
    final int resid = R.raw.testmp3_2;
    final int mp3Duration = 34909;
    final int tolerance = 70;
    final int seekDuration = 100;
    MediaPlayer2 mp = createMediaPlayer2(mContext, resid);
    AssetFileDescriptor afd = null;
    final Monitor onPrepareCalled = new Monitor();
    final Monitor onPlayCalled = new Monitor();
    final Monitor onSeekToCalled = new Monitor();
    final Monitor onLoopCurrentCalled = new Monitor();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                onPrepareCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                onPlayCalled.signal();
            } else if (what == MediaPlayer2.CALL_COMPLETED_LOOP_CURRENT) {
                onLoopCurrentCalled.signal();
            } else if (what == MediaPlayer2.CALL_COMPLETED_SEEK_TO) {
                onSeekToCalled.signal();
            }
        }
    };
    mp.setEventCallback(mExecutor, ecb);
    try {
        AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
        mp.setAudioAttributes(attributes);
        assertFalse(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        onPlayCalled.reset();
        mp.play();
        onPlayCalled.waitForSignal();
        assertTrue(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        // assertFalse(mp.isLooping());
        onLoopCurrentCalled.reset();
        mp.loopCurrent(true);
        onLoopCurrentCalled.waitForSignal();
        // assertTrue(mp.isLooping());
        assertEquals(mp3Duration, mp.getDuration(), tolerance);
        long pos = mp.getCurrentPosition();
        assertTrue(pos >= 0);
        assertTrue(pos < mp3Duration - seekDuration);
        onSeekToCalled.reset();
        mp.seekTo(pos + seekDuration, MediaPlayer2.SEEK_PREVIOUS_SYNC);
        onSeekToCalled.waitForSignal();
        assertEquals(pos + seekDuration, mp.getCurrentPosition(), tolerance);
        // test pause and restart
        mp.pause();
        Thread.sleep(SLEEP_TIME);
        assertFalse(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        onPlayCalled.reset();
        mp.play();
        onPlayCalled.waitForSignal();
        assertTrue(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        // test stop and restart
        mp.reset();
        afd = mResources.openRawResourceFd(resid);
        mp.setMediaItem(new FileMediaItem2.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build());
        mp.setEventCallback(mExecutor, ecb);
        onPrepareCalled.reset();
        mp.prepare();
        onPrepareCalled.waitForSignal();
        afd.close();
        assertFalse(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        onPlayCalled.reset();
        mp.play();
        onPlayCalled.waitForSignal();
        assertTrue(mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        // waiting to complete
        while (mp.getState() == MediaPlayer2.PLAYER_STATE_PLAYING) {
            Thread.sleep(SLEEP_TIME);
        }
    } catch (Exception e) {
        throw e;
    } finally {
        mp.close();
        afd.close();
    }
}
#end_block

#method_before
@Test
@LargeTest
public void testPlayMidi() throws Exception {
    final int resid = R.raw.midi8sec;
    final int midiDuration = 8000;
    final int tolerance = 70;
    final int seekDuration = 1000;
    MediaPlayer2 mp = createMediaPlayer2(mContext, resid);
    AssetFileDescriptor afd = null;
    final Monitor onPrepareCalled = new Monitor();
    final Monitor onSeekToCalled = new Monitor();
    final Monitor onLoopCurrentCalled = new Monitor();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                onPrepareCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_LOOP_CURRENT) {
                onLoopCurrentCalled.signal();
            } else if (what == MediaPlayer2.CALL_COMPLETED_SEEK_TO) {
                onSeekToCalled.signal();
            }
        }
    };
    mp.setEventCallback(mExecutor, ecb);
    try {
        AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
        mp.setAudioAttributes(attributes);
        mp.play();
        /* FIXME: what's API for checking loop state?
            assertFalse(mp.isLooping());
            */
        onLoopCurrentCalled.reset();
        mp.loopCurrent(true);
        onLoopCurrentCalled.waitForSignal();
        /* FIXME: what's API for checking loop state?
            assertTrue(mp.isLooping());
            */
        assertEquals(midiDuration, mp.getDuration(), tolerance);
        long pos = mp.getCurrentPosition();
        assertTrue(pos >= 0);
        assertTrue(pos < midiDuration - seekDuration);
        onSeekToCalled.reset();
        mp.seekTo(pos + seekDuration, MediaPlayer2.SEEK_PREVIOUS_SYNC);
        onSeekToCalled.waitForSignal();
        assertEquals(pos + seekDuration, mp.getCurrentPosition(), tolerance);
        // test stop and restart
        mp.reset();
        afd = mResources.openRawResourceFd(resid);
        mp.setDataSource(new FileMediaItem2.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build());
        mp.setEventCallback(mExecutor, ecb);
        onPrepareCalled.reset();
        mp.prepare();
        onPrepareCalled.waitForSignal();
        mp.play();
        Thread.sleep(SLEEP_TIME);
    } finally {
        mp.close();
        afd.close();
    }
}
#method_after
@Test
@LargeTest
public void testPlayMidi() throws Exception {
    final int resid = R.raw.midi8sec;
    final int midiDuration = 8000;
    final int tolerance = 70;
    final int seekDuration = 1000;
    MediaPlayer2 mp = createMediaPlayer2(mContext, resid);
    AssetFileDescriptor afd = null;
    final Monitor onPrepareCalled = new Monitor();
    final Monitor onSeekToCalled = new Monitor();
    final Monitor onLoopCurrentCalled = new Monitor();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                onPrepareCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_LOOP_CURRENT) {
                onLoopCurrentCalled.signal();
            } else if (what == MediaPlayer2.CALL_COMPLETED_SEEK_TO) {
                onSeekToCalled.signal();
            }
        }
    };
    mp.setEventCallback(mExecutor, ecb);
    try {
        AudioAttributesCompat attributes = new AudioAttributesCompat.Builder().setLegacyStreamType(AudioManager.STREAM_MUSIC).build();
        mp.setAudioAttributes(attributes);
        mp.play();
        /* FIXME: what's API for checking loop state?
            assertFalse(mp.isLooping());
            */
        onLoopCurrentCalled.reset();
        mp.loopCurrent(true);
        onLoopCurrentCalled.waitForSignal();
        /* FIXME: what's API for checking loop state?
            assertTrue(mp.isLooping());
            */
        assertEquals(midiDuration, mp.getDuration(), tolerance);
        long pos = mp.getCurrentPosition();
        assertTrue(pos >= 0);
        assertTrue(pos < midiDuration - seekDuration);
        onSeekToCalled.reset();
        mp.seekTo(pos + seekDuration, MediaPlayer2.SEEK_PREVIOUS_SYNC);
        onSeekToCalled.waitForSignal();
        assertEquals(pos + seekDuration, mp.getCurrentPosition(), tolerance);
        // test stop and restart
        mp.reset();
        afd = mResources.openRawResourceFd(resid);
        mp.setMediaItem(new FileMediaItem2.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build());
        mp.setEventCallback(mExecutor, ecb);
        onPrepareCalled.reset();
        mp.prepare();
        onPrepareCalled.waitForSignal();
        mp.play();
        Thread.sleep(SLEEP_TIME);
    } finally {
        mp.close();
        afd.close();
    }
}
#end_block

#method_before
private void testSetNextDataSources(boolean video, boolean skip) throws Exception {
    int res1 = video ? R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz : R.raw.loudsoftmp3;
    int res2 = video ? R.raw.testvideo : R.raw.testmp3;
    if (!checkLoadResource(res1)) {
        // skip
        return;
    }
    final MediaItem2 item1 = createDataSourceDesc(res1);
    final MediaItem2 item2 = createDataSourceDesc(res2);
    ArrayList<MediaItem2> nextDSDs = new ArrayList<MediaItem2>(2);
    nextDSDs.add(item2);
    nextDSDs.add(item1);
    mPlayer.setNextDataSources(nextDSDs);
    final Monitor onCompletion1Called = new Monitor();
    final Monitor onCompletion2Called = new Monitor();
    final Monitor onPlaylistEndCalled = new Monitor();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                Log.i(LOG_TAG, "testSetNextDataSources: prepared item MediaId=" + item.getMediaId());
                mOnPrepareCalled.signal();
            } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_END) {
                if (item == item1) {
                    onCompletion1Called.signal();
                } else if (item == item2) {
                    onCompletion2Called.signal();
                } else {
                    mOnCompletionCalled.signal();
                }
            } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_LIST_END) {
                onPlaylistEndCalled.signal();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mOnCompletionCalled.reset();
    onCompletion1Called.reset();
    onCompletion2Called.reset();
    onPlaylistEndCalled.reset();
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.prepare();
    mPlayer.play();
    if (skip) {
        mPlayer.skipToNext();
        mPlayer.skipToNext();
    } else {
        mOnCompletionCalled.waitForSignal();
        onCompletion2Called.waitForSignal();
    }
    onCompletion1Called.waitForSignal();
    if (skip) {
        assertFalse("first item completed", mOnCompletionCalled.isSignalled());
        assertFalse("second item completed", onCompletion2Called.isSignalled());
    }
    onPlaylistEndCalled.waitForSignal();
    mPlayer.reset();
}
#method_after
private void testSetNextDataSources(boolean video, boolean skip) throws Exception {
    int res1 = video ? R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz : R.raw.loudsoftmp3;
    int res2 = video ? R.raw.testvideo : R.raw.testmp3;
    if (!checkLoadResource(res1)) {
        // skip
        return;
    }
    final MediaItem2 item1 = createDataSourceDesc(res1);
    final MediaItem2 item2 = createDataSourceDesc(res2);
    ArrayList<MediaItem2> nextDSDs = new ArrayList<MediaItem2>(2);
    nextDSDs.add(item2);
    nextDSDs.add(item1);
    mPlayer.getNextMediaItems(nextDSDs);
    final Monitor onCompletion1Called = new Monitor();
    final Monitor onCompletion2Called = new Monitor();
    final Monitor onPlaylistEndCalled = new Monitor();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                Log.i(LOG_TAG, "testSetNextDataSources: prepared item MediaId=" + item.getMediaId());
                mOnPrepareCalled.signal();
            } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_END) {
                if (item == item1) {
                    onCompletion1Called.signal();
                } else if (item == item2) {
                    onCompletion2Called.signal();
                } else {
                    mOnCompletionCalled.signal();
                }
            } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_LIST_END) {
                onPlaylistEndCalled.signal();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mOnCompletionCalled.reset();
    onCompletion1Called.reset();
    onCompletion2Called.reset();
    onPlaylistEndCalled.reset();
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.prepare();
    mPlayer.play();
    if (skip) {
        mPlayer.skipToNext();
        mPlayer.skipToNext();
    } else {
        mOnCompletionCalled.waitForSignal();
        onCompletion2Called.waitForSignal();
    }
    onCompletion1Called.waitForSignal();
    if (skip) {
        assertFalse("first item completed", mOnCompletionCalled.isSignalled());
        assertFalse("second item completed", onCompletion2Called.isSignalled());
    }
    onPlaylistEndCalled.waitForSignal();
    mPlayer.reset();
}
#end_block

#method_before
@Test
@LargeTest
public void testSetNextDataSource() throws Exception {
    final MediaItem2 item1 = createDataSourceDesc(R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz);
    final MediaItem2 item2 = createDataSourceDesc(R.raw.testvideo);
    final Monitor onPlaybackCompletedCalled = new Monitor();
    final List<MediaItem2> playedDSDs = new ArrayList<>();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_SET_NEXT_DATA_SOURCE || what == MediaPlayer2.CALL_COMPLETED_SET_NEXT_DATA_SOURCES) {
                if (status != MediaPlayer2.CALL_STATUS_NO_ERROR) {
                    fail("Unexpected status code: " + status);
                }
            }
        }

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_END) {
                playedDSDs.add(item);
                onPlaybackCompletedCalled.signal();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    onPlaybackCompletedCalled.reset();
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.setDataSource(item1);
    mPlayer.setNextDataSource(item1);
    mPlayer.setNextDataSources(Arrays.asList(item2, item1));
    mPlayer.prepare();
    mPlayer.play();
    onPlaybackCompletedCalled.waitForCountedSignals(3);
    assertEquals(3, playedDSDs.size());
    assertEquals(item1, playedDSDs.get(0));
    assertEquals(item2, playedDSDs.get(1));
    assertEquals(item1, playedDSDs.get(2));
    mPlayer.reset();
}
#method_after
@Test
@LargeTest
public void testSetNextDataSource() throws Exception {
    final MediaItem2 item1 = createDataSourceDesc(R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz);
    final MediaItem2 item2 = createDataSourceDesc(R.raw.testvideo);
    final Monitor onPlaybackCompletedCalled = new Monitor();
    final List<MediaItem2> playedDSDs = new ArrayList<>();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_SET_NEXT_DATA_SOURCE || what == MediaPlayer2.CALL_COMPLETED_SET_NEXT_DATA_SOURCES) {
                if (status != MediaPlayer2.CALL_STATUS_NO_ERROR) {
                    fail("Unexpected status code: " + status);
                }
            }
        }

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_END) {
                playedDSDs.add(item);
                onPlaybackCompletedCalled.signal();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    onPlaybackCompletedCalled.reset();
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mPlayer.setMediaItem(item1);
    mPlayer.setNextMediaItem(item1);
    mPlayer.getNextMediaItems(Arrays.asList(item2, item1));
    mPlayer.prepare();
    mPlayer.play();
    onPlaybackCompletedCalled.waitForCountedSignals(3);
    assertEquals(3, playedDSDs.size());
    assertEquals(item1, playedDSDs.get(0));
    assertEquals(item2, playedDSDs.get(1));
    assertEquals(item1, playedDSDs.get(2));
    mPlayer.reset();
}
#end_block

#method_before
@Test
@LargeTest
public void testSetNextDataSourceBeforeSetDataSource() throws Exception {
    final MediaItem2 item1 = createDataSourceDesc(R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz);
    final MediaItem2 item2 = createDataSourceDesc(R.raw.testvideo);
    final Monitor onCallCompletedCalled = new Monitor();
    final List<MediaItem2> playedDSDs = new ArrayList<>();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_SET_NEXT_DATA_SOURCE || what == MediaPlayer2.CALL_COMPLETED_SET_NEXT_DATA_SOURCES) {
                if (status == MediaPlayer2.CALL_STATUS_INVALID_OPERATION) {
                    // expected
                    onCallCompletedCalled.signal();
                } else {
                    fail("Unexpected status code: " + status);
                }
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    onCallCompletedCalled.reset();
    mPlayer.setNextDataSource(item1);
    assertTrue(onCallCompletedCalled.waitForSignal());
    onCallCompletedCalled.reset();
    mPlayer.setNextDataSources(Arrays.asList(item2, item1));
    assertTrue(onCallCompletedCalled.waitForSignal());
    mPlayer.reset();
}
#method_after
@Test
@LargeTest
public void testSetNextDataSourceBeforeSetDataSource() throws Exception {
    final MediaItem2 item1 = createDataSourceDesc(R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz);
    final MediaItem2 item2 = createDataSourceDesc(R.raw.testvideo);
    final Monitor onCallCompletedCalled = new Monitor();
    final List<MediaItem2> playedDSDs = new ArrayList<>();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_SET_NEXT_DATA_SOURCE || what == MediaPlayer2.CALL_COMPLETED_SET_NEXT_DATA_SOURCES) {
                if (status == MediaPlayer2.CALL_STATUS_INVALID_OPERATION) {
                    // expected
                    onCallCompletedCalled.signal();
                } else {
                    fail("Unexpected status code: " + status);
                }
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    onCallCompletedCalled.reset();
    mPlayer.setNextMediaItem(item1);
    assertTrue(onCallCompletedCalled.waitForSignal());
    onCallCompletedCalled.reset();
    mPlayer.getNextMediaItems(Arrays.asList(item2, item1));
    assertTrue(onCallCompletedCalled.waitForSignal());
    mPlayer.reset();
}
#end_block

#method_before
@Test
@LargeTest
public void testPlayerEventCallback() throws Throwable {
    final int mp4Duration = 8484;
    final MediaItem2 item2 = createDataSourceDesc(R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz);
    final Monitor onDsdChangedCalled = new Monitor();
    final Monitor onPrepareCalled = new Monitor();
    final Monitor onSeekCompleteCalled = new Monitor();
    final Monitor onPlayerStateChangedCalled = new Monitor();
    final AtomicInteger playerState = new AtomicInteger();
    final Monitor onBufferingStateChangedCalled = new Monitor();
    final AtomicInteger bufferingState = new AtomicInteger();
    final Monitor onPlaybackSpeedChanged = new Monitor();
    final AtomicReference<Float> playbackSpeed = new AtomicReference<>();
    PlayerEventCallback callback = new PlayerEventCallback() {

        @Override
        public void onCurrentDataSourceChanged(MediaPlayerConnector mpb, MediaItem2 item) {
            switch(onDsdChangedCalled.getNumSignal()) {
                case 1:
                    assertEquals(item2, item);
                    break;
                case 2:
                    assertNull(item);
                    break;
            }
            onDsdChangedCalled.signal();
        }

        @Override
        public void onMediaPrepared(MediaPlayerConnector mpb, MediaItem2 item) {
            onPrepareCalled.signal();
        }

        @Override
        public void onPlayerStateChanged(MediaPlayerConnector mpb, int state) {
            playerState.set(state);
            onPlayerStateChangedCalled.signal();
        }

        @Override
        public void onBufferingStateChanged(MediaPlayerConnector mpb, MediaItem2 item, int state) {
            bufferingState.set(state);
            onBufferingStateChangedCalled.signal();
        }

        @Override
        public void onPlaybackSpeedChanged(MediaPlayerConnector mpb, float speed) {
            playbackSpeed.set(speed);
            onPlaybackSpeedChanged.signal();
        }

        @Override
        public void onSeekCompleted(MediaPlayerConnector mpb, long position) {
            onSeekCompleteCalled.signal();
        }
    };
    MediaPlayerConnector basePlayer = mPlayer.getMediaPlayerConnector();
    ExecutorService executor = Executors.newFixedThreadPool(1);
    basePlayer.registerPlayerEventCallback(executor, callback);
    if (!checkLoadResource(R.raw.testvideo)) {
        // skip;
        return;
    }
    assertEquals(1, onDsdChangedCalled.waitForCountedSignals(1));
    mPlayer.setNextDataSource(item2);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    onPrepareCalled.reset();
    onPlayerStateChangedCalled.reset();
    onBufferingStateChangedCalled.reset();
    basePlayer.prepare();
    do {
        assertTrue(onBufferingStateChangedCalled.waitForSignal(1000));
    } while (bufferingState.get() != MediaPlayerConnector.BUFFERING_STATE_BUFFERING_AND_STARVED);
    assertTrue(onPrepareCalled.waitForSignal(1000));
    do {
        assertTrue(onPlayerStateChangedCalled.waitForSignal(1000));
    } while (playerState.get() != MediaPlayerConnector.PLAYER_STATE_PAUSED);
    do {
        assertTrue(onBufferingStateChangedCalled.waitForSignal(1000));
    } while (bufferingState.get() != MediaPlayerConnector.BUFFERING_STATE_BUFFERING_AND_PLAYABLE);
    onSeekCompleteCalled.reset();
    basePlayer.seekTo(mp4Duration >> 1);
    onSeekCompleteCalled.waitForSignal();
    onPlaybackSpeedChanged.reset();
    basePlayer.setPlaybackSpeed(0.5f);
    do {
        assertTrue(onPlaybackSpeedChanged.waitForSignal(1000));
    } while (Math.abs(playbackSpeed.get() - 0.5f) > FLOAT_TOLERANCE);
    basePlayer.skipToNext();
    basePlayer.play();
    assertEquals(3, onDsdChangedCalled.waitForCountedSignals(3));
    basePlayer.reset();
    assertEquals(MediaPlayerConnector.PLAYER_STATE_IDLE, basePlayer.getPlayerState());
    basePlayer.unregisterPlayerEventCallback(callback);
    executor.shutdown();
}
#method_after
@Test
@LargeTest
public void testPlayerEventCallback() throws Throwable {
    final int mp4Duration = 8484;
    final MediaItem2 item2 = createDataSourceDesc(R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz);
    final Monitor onDsdChangedCalled = new Monitor();
    final Monitor onPrepareCalled = new Monitor();
    final Monitor onSeekCompleteCalled = new Monitor();
    final Monitor onPlayerStateChangedCalled = new Monitor();
    final AtomicInteger playerState = new AtomicInteger();
    final Monitor onBufferingStateChangedCalled = new Monitor();
    final AtomicInteger bufferingState = new AtomicInteger();
    final Monitor onPlaybackSpeedChanged = new Monitor();
    final AtomicReference<Float> playbackSpeed = new AtomicReference<>();
    PlayerEventCallback callback = new PlayerEventCallback() {

        @Override
        public void onCurrentMediaItemChanged(MediaPlayerConnector mpb, MediaItem2 item) {
            switch(onDsdChangedCalled.getNumSignal()) {
                case 1:
                    assertEquals(item2, item);
                    break;
                case 2:
                    assertNull(item);
                    break;
            }
            onDsdChangedCalled.signal();
        }

        @Override
        public void onMediaPrepared(MediaPlayerConnector mpb, MediaItem2 item) {
            onPrepareCalled.signal();
        }

        @Override
        public void onPlayerStateChanged(MediaPlayerConnector mpb, int state) {
            playerState.set(state);
            onPlayerStateChangedCalled.signal();
        }

        @Override
        public void onBufferingStateChanged(MediaPlayerConnector mpb, MediaItem2 item, int state) {
            bufferingState.set(state);
            onBufferingStateChangedCalled.signal();
        }

        @Override
        public void onPlaybackSpeedChanged(MediaPlayerConnector mpb, float speed) {
            playbackSpeed.set(speed);
            onPlaybackSpeedChanged.signal();
        }

        @Override
        public void onSeekCompleted(MediaPlayerConnector mpb, long position) {
            onSeekCompleteCalled.signal();
        }
    };
    MediaPlayerConnector basePlayer = mPlayer.getMediaPlayerConnector();
    ExecutorService executor = Executors.newFixedThreadPool(1);
    basePlayer.registerPlayerEventCallback(executor, callback);
    if (!checkLoadResource(R.raw.testvideo)) {
        // skip;
        return;
    }
    assertEquals(1, onDsdChangedCalled.waitForCountedSignals(1));
    mPlayer.setNextMediaItem(item2);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    onPrepareCalled.reset();
    onPlayerStateChangedCalled.reset();
    onBufferingStateChangedCalled.reset();
    basePlayer.prepare();
    do {
        assertTrue(onBufferingStateChangedCalled.waitForSignal(1000));
    } while (bufferingState.get() != MediaPlayerConnector.BUFFERING_STATE_BUFFERING_AND_STARVED);
    assertTrue(onPrepareCalled.waitForSignal(1000));
    do {
        assertTrue(onPlayerStateChangedCalled.waitForSignal(1000));
    } while (playerState.get() != MediaPlayerConnector.PLAYER_STATE_PAUSED);
    do {
        assertTrue(onBufferingStateChangedCalled.waitForSignal(1000));
    } while (bufferingState.get() != MediaPlayerConnector.BUFFERING_STATE_BUFFERING_AND_PLAYABLE);
    onSeekCompleteCalled.reset();
    basePlayer.seekTo(mp4Duration >> 1);
    onSeekCompleteCalled.waitForSignal();
    onPlaybackSpeedChanged.reset();
    basePlayer.setPlaybackSpeed(0.5f);
    do {
        assertTrue(onPlaybackSpeedChanged.waitForSignal(1000));
    } while (Math.abs(playbackSpeed.get() - 0.5f) > FLOAT_TOLERANCE);
    basePlayer.skipToNext();
    basePlayer.play();
    assertEquals(3, onDsdChangedCalled.waitForCountedSignals(3));
    basePlayer.reset();
    assertEquals(MediaPlayerConnector.PLAYER_STATE_IDLE, basePlayer.getPlayerState());
    basePlayer.unregisterPlayerEventCallback(callback);
    executor.shutdown();
}
#end_block

#method_before
public void testRecordAndPlay() throws Exception {
    if (!hasMicrophone()) {
        return;
    }
    /* FIXME: check the codec exists.
        if (!MediaUtils.checkDecoder(MediaFormat.MIMETYPE_AUDIO_AMR_NB)
                || !MediaUtils.checkEncoder(MediaFormat.MIMETYPE_AUDIO_AMR_NB)) {
            return; // skip
        }
        */
    File outputFile = new File(Environment.getExternalStorageDirectory(), "record_and_play.3gp");
    String outputFileLocation = outputFile.getAbsolutePath();
    try {
        recordMedia(outputFileLocation);
        Uri uri = Uri.parse(outputFileLocation);
        MediaPlayer2 mp = MediaPlayer2.create(mActivity);
        try {
            mp.setDataSource(new UriMediaItem2.Builder(mContext, uri).build());
            mp.prepare();
            Thread.sleep(SLEEP_TIME);
            playAndStop(mp);
        } finally {
            mp.close();
        }
        try {
            mp = createMediaPlayer2(mContext, uri);
            playAndStop(mp);
        } finally {
            if (mp != null) {
                mp.close();
            }
        }
        try {
            mp = createMediaPlayer2(mContext, uri, mActivity.getSurfaceHolder());
            playAndStop(mp);
        } finally {
            if (mp != null) {
                mp.close();
            }
        }
    } finally {
        outputFile.delete();
    }
}
#method_after
public void testRecordAndPlay() throws Exception {
    if (!hasMicrophone()) {
        return;
    }
    /* FIXME: check the codec exists.
        if (!MediaUtils.checkDecoder(MediaFormat.MIMETYPE_AUDIO_AMR_NB)
                || !MediaUtils.checkEncoder(MediaFormat.MIMETYPE_AUDIO_AMR_NB)) {
            return; // skip
        }
        */
    File outputFile = new File(Environment.getExternalStorageDirectory(), "record_and_play.3gp");
    String outputFileLocation = outputFile.getAbsolutePath();
    try {
        recordMedia(outputFileLocation);
        Uri uri = Uri.parse(outputFileLocation);
        MediaPlayer2 mp = MediaPlayer2.create(mActivity);
        try {
            mp.setMediaItem(new UriMediaItem2.Builder(mContext, uri).build());
            mp.prepare();
            Thread.sleep(SLEEP_TIME);
            playAndStop(mp);
        } finally {
            mp.close();
        }
        try {
            mp = createMediaPlayer2(mContext, uri);
            playAndStop(mp);
        } finally {
            if (mp != null) {
                mp.close();
            }
        }
        try {
            mp = createMediaPlayer2(mContext, uri, mActivity.getSurfaceHolder());
            playAndStop(mp);
        } finally {
            if (mp != null) {
                mp.close();
            }
        }
    } finally {
        outputFile.delete();
    }
}
#end_block

#method_before
@Test
@LargeTest
public void testPlaybackFromAMedia2DataSource() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final int duration = 10000;
    /* FIXME: check the codec exists.
        if (!MediaUtils.hasCodecsForResource(mContext, resid)) {
            return;
        }
        */
    TestDataSourceCallback2 dataSource = TestDataSourceCallback2.fromAssetFd(mResources.openRawResourceFd(resid));
    // Test returning -1 from getSize() to indicate unknown size.
    dataSource.returnFromGetSize(-1);
    mPlayer.setDataSource(new CallbackMediaItem2.Builder(dataSource).build());
    playLoadedVideo(null, null, -1);
    assertTrue(mPlayer.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
    // Test pause and restart.
    mPlayer.pause();
    Thread.sleep(SLEEP_TIME);
    assertFalse(mPlayer.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                mOnPlayCalled.signal();
            }
        }
    };
    mPlayer.setEventCallback(mExecutor, ecb);
    mOnPlayCalled.reset();
    mPlayer.play();
    mOnPlayCalled.waitForSignal();
    assertTrue(mPlayer.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
    // Test reset.
    mPlayer.reset();
    mPlayer.setDataSource(new CallbackMediaItem2.Builder(dataSource).build());
    mPlayer.setEventCallback(mExecutor, ecb);
    mOnPrepareCalled.reset();
    mPlayer.prepare();
    mOnPrepareCalled.waitForSignal();
    mOnPlayCalled.reset();
    mPlayer.play();
    mOnPlayCalled.waitForSignal();
    assertTrue(mPlayer.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
    // Test seek. Note: the seek position is cached and returned as the
    // current position so there's no point in comparing them.
    mPlayer.seekTo(duration - SLEEP_TIME, MediaPlayer2.SEEK_PREVIOUS_SYNC);
    while (mPlayer.getState() == MediaPlayer2.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
}
#method_after
@Test
@LargeTest
public void testPlaybackFromAMedia2DataSource() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final int duration = 10000;
    /* FIXME: check the codec exists.
        if (!MediaUtils.hasCodecsForResource(mContext, resid)) {
            return;
        }
        */
    TestDataSourceCallback2 dataSource = TestDataSourceCallback2.fromAssetFd(mResources.openRawResourceFd(resid));
    // Test returning -1 from getSize() to indicate unknown size.
    dataSource.returnFromGetSize(-1);
    mPlayer.setMediaItem(new CallbackMediaItem2.Builder(dataSource).build());
    playLoadedVideo(null, null, -1);
    assertTrue(mPlayer.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
    // Test pause and restart.
    mPlayer.pause();
    Thread.sleep(SLEEP_TIME);
    assertFalse(mPlayer.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                mOnPlayCalled.signal();
            }
        }
    };
    mPlayer.setEventCallback(mExecutor, ecb);
    mOnPlayCalled.reset();
    mPlayer.play();
    mOnPlayCalled.waitForSignal();
    assertTrue(mPlayer.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
    // Test reset.
    mPlayer.reset();
    mPlayer.setMediaItem(new CallbackMediaItem2.Builder(dataSource).build());
    mPlayer.setEventCallback(mExecutor, ecb);
    mOnPrepareCalled.reset();
    mPlayer.prepare();
    mOnPrepareCalled.waitForSignal();
    mOnPlayCalled.reset();
    mPlayer.play();
    mOnPlayCalled.waitForSignal();
    assertTrue(mPlayer.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
    // Test seek. Note: the seek position is cached and returned as the
    // current position so there's no point in comparing them.
    mPlayer.seekTo(duration - SLEEP_TIME, MediaPlayer2.SEEK_PREVIOUS_SYNC);
    while (mPlayer.getState() == MediaPlayer2.PLAYER_STATE_PLAYING) {
        Thread.sleep(SLEEP_TIME);
    }
}
#end_block

#method_before
@Test
@LargeTest
public void testNullMedia2DataSourceIsRejected() throws Exception {
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE) {
                mCallStatus = status;
                mOnPlayCalled.signal();
            }
        }
    };
    mPlayer.setEventCallback(mExecutor, ecb);
    mCallStatus = MediaPlayer2.CALL_STATUS_NO_ERROR;
    mPlayer.setDataSource((MediaItem2) null);
    mOnPlayCalled.waitForSignal();
    assertTrue(mCallStatus != MediaPlayer2.CALL_STATUS_NO_ERROR);
}
#method_after
@Test
@LargeTest
public void testNullMedia2DataSourceIsRejected() throws Exception {
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE) {
                mCallStatus = status;
                mOnPlayCalled.signal();
            }
        }
    };
    mPlayer.setEventCallback(mExecutor, ecb);
    mCallStatus = MediaPlayer2.CALL_STATUS_NO_ERROR;
    mPlayer.setMediaItem((MediaItem2) null);
    mOnPlayCalled.waitForSignal();
    assertTrue(mCallStatus != MediaPlayer2.CALL_STATUS_NO_ERROR);
}
#end_block

#method_before
@Test
@LargeTest
public void testMedia2DataSourceIsClosedOnReset() throws Exception {
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE) {
                mCallStatus = status;
                mOnPlayCalled.signal();
            }
        }
    };
    mPlayer.setEventCallback(mExecutor, ecb);
    TestDataSourceCallback2 dataSource = new TestDataSourceCallback2(new byte[0]);
    mPlayer.setDataSource(new CallbackMediaItem2.Builder(dataSource).build());
    mOnPlayCalled.waitForSignal();
    mPlayer.reset();
    assertTrue(dataSource.isClosed());
}
#method_after
@Test
@LargeTest
public void testMedia2DataSourceIsClosedOnReset() throws Exception {
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE) {
                mCallStatus = status;
                mOnPlayCalled.signal();
            }
        }
    };
    mPlayer.setEventCallback(mExecutor, ecb);
    TestDataSourceCallback2 dataSource = new TestDataSourceCallback2(new byte[0]);
    mPlayer.setMediaItem(new CallbackMediaItem2.Builder(dataSource).build());
    mOnPlayCalled.waitForSignal();
    mPlayer.reset();
    assertTrue(dataSource.isClosed());
}
#end_block

#method_before
@Test
@LargeTest
public void testPlaybackFailsIfMedia2DataSourceThrows() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    /* FIXME: check the codec exists.
        if (!MediaUtils.hasCodecsForResource(mContext, resid)) {
            return;
        }
        */
    setOnErrorListener();
    TestDataSourceCallback2 dataSource = TestDataSourceCallback2.fromAssetFd(mResources.openRawResourceFd(resid));
    mPlayer.setDataSource(new CallbackMediaItem2.Builder(dataSource).build());
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mOnPrepareCalled.reset();
    mPlayer.prepare();
    mOnPrepareCalled.waitForSignal();
    dataSource.throwFromReadAt();
    mPlayer.play();
    assertTrue(mOnErrorCalled.waitForSignal());
}
#method_after
@Test
@LargeTest
public void testPlaybackFailsIfMedia2DataSourceThrows() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    /* FIXME: check the codec exists.
        if (!MediaUtils.hasCodecsForResource(mContext, resid)) {
            return;
        }
        */
    setOnErrorListener();
    TestDataSourceCallback2 dataSource = TestDataSourceCallback2.fromAssetFd(mResources.openRawResourceFd(resid));
    mPlayer.setMediaItem(new CallbackMediaItem2.Builder(dataSource).build());
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mOnPrepareCalled.reset();
    mPlayer.prepare();
    mOnPrepareCalled.waitForSignal();
    dataSource.throwFromReadAt();
    mPlayer.play();
    assertTrue(mOnErrorCalled.waitForSignal());
}
#end_block

#method_before
@Test
@LargeTest
public void testPlaybackFailsIfMedia2DataSourceReturnsAnError() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    /* FIXME: check the codec exists.
        if (!MediaUtils.hasCodecsForResource(mContext, resid)) {
            return;
        }
        */
    TestDataSourceCallback2 dataSource = TestDataSourceCallback2.fromAssetFd(mResources.openRawResourceFd(resid));
    mPlayer.setDataSource(new CallbackMediaItem2.Builder(dataSource).build());
    setOnErrorListener();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mOnPrepareCalled.reset();
    mPlayer.prepare();
    mOnPrepareCalled.waitForSignal();
    dataSource.returnFromReadAt(-2);
    mPlayer.play();
    assertTrue(mOnErrorCalled.waitForSignal());
}
#method_after
@Test
@LargeTest
public void testPlaybackFailsIfMedia2DataSourceReturnsAnError() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    /* FIXME: check the codec exists.
        if (!MediaUtils.hasCodecsForResource(mContext, resid)) {
            return;
        }
        */
    TestDataSourceCallback2 dataSource = TestDataSourceCallback2.fromAssetFd(mResources.openRawResourceFd(resid));
    mPlayer.setMediaItem(new CallbackMediaItem2.Builder(dataSource).build());
    setOnErrorListener();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mOnPrepareCalled.reset();
    mPlayer.prepare();
    mOnPrepareCalled.waitForSignal();
    dataSource.returnFromReadAt(-2);
    mPlayer.play();
    assertTrue(mOnErrorCalled.waitForSignal());
}
#end_block

#method_before
@Test
@SmallTest
public void testClearPendingCommands() throws Exception {
    final Monitor readRequested = new Monitor();
    final Monitor readAllowed = new Monitor();
    DataSourceCallback2 dataSource = new DataSourceCallback2() {

        @Override
        public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
            try {
                readRequested.signal();
                readAllowed.waitForSignal();
            } catch (InterruptedException e) {
                fail();
            }
            return -1;
        }

        @Override
        public long getSize() throws IOException {
            // Unknown size
            return -1;
        }

        @Override
        public void close() throws IOException {
        }
    };
    final ArrayDeque<Integer> commandsCompleted = new ArrayDeque<>();
    setOnErrorListener();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            commandsCompleted.add(what);
        }

        @Override
        public void onError(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mOnPrepareCalled.reset();
    mOnErrorCalled.reset();
    mPlayer.setDataSource(new CallbackMediaItem2.Builder(dataSource).build());
    // prepare() will be pending until readAllowed is signaled.
    mPlayer.prepare();
    mPlayer.play();
    mPlayer.pause();
    mPlayer.play();
    mPlayer.pause();
    mPlayer.play();
    mPlayer.seekTo(1000);
    // Clear the pending commands once the prepare operation starts.
    readRequested.waitForSignal();
    mPlayer.clearPendingCommands();
    // Make the on-going prepare operation fail and check the results.
    readAllowed.signal();
    mOnErrorCalled.waitForSignal();
    assertEquals(0, mOnPrepareCalled.getNumSignal());
    assertEquals(2, commandsCompleted.size());
    assertEquals(MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE, (int) commandsCompleted.peekFirst());
    assertEquals(MediaPlayer2.CALL_COMPLETED_PREPARE, (int) commandsCompleted.getLast());
}
#method_after
@Test
@SmallTest
public void testClearPendingCommands() throws Exception {
    final Monitor readRequested = new Monitor();
    final Monitor readAllowed = new Monitor();
    DataSourceCallback2 dataSource = new DataSourceCallback2() {

        @Override
        public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
            try {
                readRequested.signal();
                readAllowed.waitForSignal();
            } catch (InterruptedException e) {
                fail();
            }
            return -1;
        }

        @Override
        public long getSize() throws IOException {
            // Unknown size
            return -1;
        }

        @Override
        public void close() throws IOException {
        }
    };
    final ArrayDeque<Integer> commandsCompleted = new ArrayDeque<>();
    setOnErrorListener();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            commandsCompleted.add(what);
        }

        @Override
        public void onError(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mOnPrepareCalled.reset();
    mOnErrorCalled.reset();
    mPlayer.setMediaItem(new CallbackMediaItem2.Builder(dataSource).build());
    // prepare() will be pending until readAllowed is signaled.
    mPlayer.prepare();
    mPlayer.play();
    mPlayer.pause();
    mPlayer.play();
    mPlayer.pause();
    mPlayer.play();
    mPlayer.seekTo(1000);
    // Clear the pending commands once the prepare operation starts.
    readRequested.waitForSignal();
    mPlayer.clearPendingCommands();
    // Make the on-going prepare operation fail and check the results.
    readAllowed.signal();
    mOnErrorCalled.waitForSignal();
    assertEquals(0, mOnPrepareCalled.getNumSignal());
    assertEquals(2, commandsCompleted.size());
    assertEquals(MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE, (int) commandsCompleted.peekFirst());
    assertEquals(MediaPlayer2.CALL_COMPLETED_PREPARE, (int) commandsCompleted.getLast());
}
#end_block

#method_before
@Test
@LargeTest
public void testDataSourceStartEnd() throws Exception {
    final int resid1 = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final long start1 = 6000;
    final long end1 = 8000;
    AssetFileDescriptor afd1 = mResources.openRawResourceFd(resid1);
    MediaItem2 item1 = new FileMediaItem2.Builder(afd1.getFileDescriptor(), afd1.getStartOffset(), afd1.getLength()).setStartPosition(start1).setEndPosition(end1).build();
    final int resid2 = R.raw.testvideo;
    final long start2 = 3000;
    final long end2 = 5000;
    AssetFileDescriptor afd2 = mResources.openRawResourceFd(resid2);
    MediaItem2 item2 = new FileMediaItem2.Builder(afd2.getFileDescriptor(), afd2.getStartOffset(), afd2.getLength()).setStartPosition(start2).setEndPosition(end2).build();
    mPlayer.setDataSource(item1);
    mPlayer.setNextDataSource(item2);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_END) {
                mOnCompletionCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                assertTrue(status == MediaPlayer2.CALL_STATUS_NO_ERROR);
                mOnPlayCalled.signal();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mOnPrepareCalled.reset();
    mPlayer.prepare();
    mOnPrepareCalled.waitForSignal();
    mOnPlayCalled.reset();
    mOnCompletionCalled.reset();
    mPlayer.play();
    mOnPlayCalled.waitForSignal();
    assertTrue(mPlayer.getCurrentPosition() >= start1);
    mOnCompletionCalled.waitForSignal();
    assertTrue(mPlayer.getCurrentPosition() >= start2);
    mPlayer.setPlaybackParams(new PlaybackParams2.Builder().setSpeed(0.5f).build());
    mOnCompletionCalled.reset();
    mOnCompletionCalled.waitForSignal();
    assertTrue(Math.abs(mPlayer.getCurrentPosition() - end2) < PLAYBACK_COMPLETE_TOLERANCE_MS);
    afd1.close();
    afd2.close();
}
#method_after
@Test
@LargeTest
public void testDataSourceStartEnd() throws Exception {
    final int resid1 = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final long start1 = 6000;
    final long end1 = 8000;
    AssetFileDescriptor afd1 = mResources.openRawResourceFd(resid1);
    MediaItem2 item1 = new FileMediaItem2.Builder(afd1.getFileDescriptor(), afd1.getStartOffset(), afd1.getLength()).setStartPosition(start1).setEndPosition(end1).build();
    final int resid2 = R.raw.testvideo;
    final long start2 = 3000;
    final long end2 = 5000;
    AssetFileDescriptor afd2 = mResources.openRawResourceFd(resid2);
    MediaItem2 item2 = new FileMediaItem2.Builder(afd2.getFileDescriptor(), afd2.getStartOffset(), afd2.getLength()).setStartPosition(start2).setEndPosition(end2).build();
    mPlayer.setMediaItem(item1);
    mPlayer.setNextMediaItem(item2);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_END) {
                mOnCompletionCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                assertTrue(status == MediaPlayer2.CALL_STATUS_NO_ERROR);
                mOnPlayCalled.signal();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mOnPrepareCalled.reset();
    mPlayer.prepare();
    mOnPrepareCalled.waitForSignal();
    mOnPlayCalled.reset();
    mOnCompletionCalled.reset();
    mPlayer.play();
    mOnPlayCalled.waitForSignal();
    assertTrue(mPlayer.getCurrentPosition() >= start1);
    mOnCompletionCalled.waitForSignal();
    assertTrue(mPlayer.getCurrentPosition() >= start2);
    mPlayer.setPlaybackParams(new PlaybackParams2.Builder().setSpeed(0.5f).build());
    mOnCompletionCalled.reset();
    mOnCompletionCalled.waitForSignal();
    assertTrue(Math.abs(mPlayer.getCurrentPosition() - end2) < PLAYBACK_COMPLETE_TOLERANCE_MS);
    afd1.close();
    afd2.close();
}
#end_block

#method_before
@Test
@LargeTest
public void testDataSourceStartEndWithLooping() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final long start = 6000;
    final long end = 8000;
    AssetFileDescriptor afd = mResources.openRawResourceFd(resid);
    MediaItem2 item = new FileMediaItem2.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).setStartPosition(start).setEndPosition(end).build();
    mPlayer.setDataSource(item);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    final Monitor onDataSourceRepeatCalled = new Monitor();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_REPEAT) {
                onDataSourceRepeatCalled.signal();
            } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_END) {
                mOnCompletionCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                assertTrue(status == MediaPlayer2.CALL_STATUS_NO_ERROR);
                mOnPlayCalled.signal();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mOnPrepareCalled.reset();
    mPlayer.loopCurrent(true);
    mPlayer.prepare();
    mOnPrepareCalled.waitForSignal();
    mOnPlayCalled.reset();
    onDataSourceRepeatCalled.reset();
    mPlayer.play();
    mOnPlayCalled.waitForSignal();
    assertEquals(MediaPlayer2.PLAYER_STATE_PLAYING, mPlayer.getState());
    assertTrue(mPlayer.getCurrentPosition() >= start);
    onDataSourceRepeatCalled.waitForSignal();
    assertEquals(MediaPlayer2.PLAYER_STATE_PLAYING, mPlayer.getState());
    assertTrue(mPlayer.getCurrentPosition() >= start);
    onDataSourceRepeatCalled.waitForCountedSignals(2);
    assertEquals(MediaPlayer2.PLAYER_STATE_PLAYING, mPlayer.getState());
    assertTrue(mPlayer.getCurrentPosition() >= start);
    mOnCompletionCalled.reset();
    mPlayer.loopCurrent(false);
    mOnCompletionCalled.waitForSignal();
    assertEquals(MediaPlayer2.PLAYER_STATE_PAUSED, mPlayer.getState());
    long pos = mPlayer.getCurrentPosition();
    assertTrue("current pos (" + pos + "us) does not match requested pos (" + end + "us).", Math.abs(pos - end) < PLAYBACK_COMPLETE_TOLERANCE_MS);
    afd.close();
}
#method_after
@Test
@LargeTest
public void testDataSourceStartEndWithLooping() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final long start = 6000;
    final long end = 8000;
    AssetFileDescriptor afd = mResources.openRawResourceFd(resid);
    MediaItem2 item = new FileMediaItem2.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).setStartPosition(start).setEndPosition(end).build();
    mPlayer.setMediaItem(item);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    final Monitor onDataSourceRepeatCalled = new Monitor();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_REPEAT) {
                onDataSourceRepeatCalled.signal();
            } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_END) {
                mOnCompletionCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                assertTrue(status == MediaPlayer2.CALL_STATUS_NO_ERROR);
                mOnPlayCalled.signal();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mOnPrepareCalled.reset();
    mPlayer.loopCurrent(true);
    mPlayer.prepare();
    mOnPrepareCalled.waitForSignal();
    mOnPlayCalled.reset();
    onDataSourceRepeatCalled.reset();
    mPlayer.play();
    mOnPlayCalled.waitForSignal();
    assertEquals(MediaPlayer2.PLAYER_STATE_PLAYING, mPlayer.getState());
    assertTrue(mPlayer.getCurrentPosition() >= start);
    onDataSourceRepeatCalled.waitForSignal();
    assertEquals(MediaPlayer2.PLAYER_STATE_PLAYING, mPlayer.getState());
    assertTrue(mPlayer.getCurrentPosition() >= start);
    onDataSourceRepeatCalled.waitForCountedSignals(2);
    assertEquals(MediaPlayer2.PLAYER_STATE_PLAYING, mPlayer.getState());
    assertTrue(mPlayer.getCurrentPosition() >= start);
    mOnCompletionCalled.reset();
    mPlayer.loopCurrent(false);
    mOnCompletionCalled.waitForSignal();
    assertEquals(MediaPlayer2.PLAYER_STATE_PAUSED, mPlayer.getState());
    long pos = mPlayer.getCurrentPosition();
    assertTrue("current pos (" + pos + "us) does not match requested pos (" + end + "us).", Math.abs(pos - end) < PLAYBACK_COMPLETE_TOLERANCE_MS);
    afd.close();
}
#end_block

#method_before
@Test
@LargeTest
public void testPreservePlaybackProperties() throws Exception {
    final int resid1 = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final long start1 = 6000;
    final long end1 = 7000;
    AssetFileDescriptor afd1 = mResources.openRawResourceFd(resid1);
    MediaItem2 item1 = new FileMediaItem2.Builder(afd1.getFileDescriptor(), afd1.getStartOffset(), afd1.getLength()).setStartPosition(start1).setEndPosition(end1).build();
    final int resid2 = R.raw.testvideo;
    final long start2 = 3000;
    final long end2 = 4000;
    AssetFileDescriptor afd2 = mResources.openRawResourceFd(resid2);
    MediaItem2 item2 = new FileMediaItem2.Builder(afd2.getFileDescriptor(), afd2.getStartOffset(), afd2.getLength()).setStartPosition(start2).setEndPosition(end2).build();
    mPlayer.setDataSource(item1);
    mPlayer.setNextDataSource(item2);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_END) {
                mOnCompletionCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                assertTrue(status == MediaPlayer2.CALL_STATUS_NO_ERROR);
                mOnPlayCalled.signal();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mOnPrepareCalled.reset();
    mPlayer.prepare();
    mOnPrepareCalled.waitForSignal();
    mOnPlayCalled.reset();
    mOnCompletionCalled.reset();
    mPlayer.setPlaybackParams(new PlaybackParams2.Builder().setSpeed(2.0f).build());
    mPlayer.play();
    mOnPlayCalled.waitForSignal();
    mOnCompletionCalled.waitForSignal();
    assertEquals(item2, mPlayer.getCurrentDataSource());
    assertEquals(2.0f, mPlayer.getPlaybackParams().getSpeed(), 0.001f);
    afd1.close();
    afd2.close();
}
#method_after
@Test
@LargeTest
public void testPreservePlaybackProperties() throws Exception {
    final int resid1 = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final long start1 = 6000;
    final long end1 = 7000;
    AssetFileDescriptor afd1 = mResources.openRawResourceFd(resid1);
    MediaItem2 item1 = new FileMediaItem2.Builder(afd1.getFileDescriptor(), afd1.getStartOffset(), afd1.getLength()).setStartPosition(start1).setEndPosition(end1).build();
    final int resid2 = R.raw.testvideo;
    final long start2 = 3000;
    final long end2 = 4000;
    AssetFileDescriptor afd2 = mResources.openRawResourceFd(resid2);
    MediaItem2 item2 = new FileMediaItem2.Builder(afd2.getFileDescriptor(), afd2.getStartOffset(), afd2.getLength()).setStartPosition(start2).setEndPosition(end2).build();
    mPlayer.setMediaItem(item1);
    mPlayer.setNextMediaItem(item2);
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_END) {
                mOnCompletionCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                assertTrue(status == MediaPlayer2.CALL_STATUS_NO_ERROR);
                mOnPlayCalled.signal();
            }
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mOnPrepareCalled.reset();
    mPlayer.prepare();
    mOnPrepareCalled.waitForSignal();
    mOnPlayCalled.reset();
    mOnCompletionCalled.reset();
    mPlayer.setPlaybackParams(new PlaybackParams2.Builder().setSpeed(2.0f).build());
    mPlayer.play();
    mOnPlayCalled.waitForSignal();
    mOnCompletionCalled.waitForSignal();
    assertEquals(item2, mPlayer.getCurrentMediaItem());
    assertEquals(2.0f, mPlayer.getPlaybackParams().getSpeed(), 0.001f);
    afd1.close();
    afd2.close();
}
#end_block

#method_before
@Test
@SmallTest
public void testSkipUnnecessarySeek() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final TestDataSourceCallback2 source = TestDataSourceCallback2.fromAssetFd(mResources.openRawResourceFd(resid));
    final Monitor readAllowed = new Monitor();
    DataSourceCallback2 dataSource = new DataSourceCallback2() {

        @Override
        public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
            if (!readAllowed.isSignalled()) {
                try {
                    readAllowed.waitForSignal();
                } catch (InterruptedException e) {
                    fail();
                }
            }
            return source.readAt(position, buffer, offset, size);
        }

        @Override
        public long getSize() throws IOException {
            return source.getSize();
        }

        @Override
        public void close() throws IOException {
            source.close();
        }
    };
    final Monitor labelReached = new Monitor();
    final ArrayList<Pair<Integer, Integer>> commandsCompleted = new ArrayList<>();
    setOnErrorListener();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            commandsCompleted.add(new Pair<>(what, status));
        }

        @Override
        public void onError(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            mOnErrorCalled.signal();
        }

        @Override
        public void onCommandLabelReached(MediaPlayer2 mp, @NonNull Object label) {
            labelReached.signal();
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mOnPrepareCalled.reset();
    mOnErrorCalled.reset();
    mPlayer.setDataSource(new CallbackMediaItem2.Builder(dataSource).build());
    // prepare() will be pending until readAllowed is signaled.
    mPlayer.prepare();
    mPlayer.seekTo(3000);
    mPlayer.seekTo(2000);
    mPlayer.seekTo(1000);
    mPlayer.notifyWhenCommandLabelReached(new Object());
    readAllowed.signal();
    labelReached.waitForSignal();
    assertFalse(mOnErrorCalled.isSignalled());
    assertTrue(mOnPrepareCalled.isSignalled());
    assertEquals(5, commandsCompleted.size());
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE, MediaPlayer2.CALL_STATUS_NO_ERROR), commandsCompleted.get(0));
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_PREPARE, MediaPlayer2.CALL_STATUS_NO_ERROR), commandsCompleted.get(1));
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_SEEK_TO, MediaPlayer2.CALL_STATUS_SKIPPED), commandsCompleted.get(2));
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_SEEK_TO, MediaPlayer2.CALL_STATUS_SKIPPED), commandsCompleted.get(3));
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_SEEK_TO, MediaPlayer2.CALL_STATUS_NO_ERROR), commandsCompleted.get(4));
}
#method_after
@Test
@SmallTest
public void testSkipUnnecessarySeek() throws Exception {
    final int resid = R.raw.video_480x360_mp4_h264_1350kbps_30fps_aac_stereo_192kbps_44100hz;
    final TestDataSourceCallback2 source = TestDataSourceCallback2.fromAssetFd(mResources.openRawResourceFd(resid));
    final Monitor readAllowed = new Monitor();
    DataSourceCallback2 dataSource = new DataSourceCallback2() {

        @Override
        public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
            if (!readAllowed.isSignalled()) {
                try {
                    readAllowed.waitForSignal();
                } catch (InterruptedException e) {
                    fail();
                }
            }
            return source.readAt(position, buffer, offset, size);
        }

        @Override
        public long getSize() throws IOException {
            return source.getSize();
        }

        @Override
        public void close() throws IOException {
            source.close();
        }
    };
    final Monitor labelReached = new Monitor();
    final ArrayList<Pair<Integer, Integer>> commandsCompleted = new ArrayList<>();
    setOnErrorListener();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            commandsCompleted.add(new Pair<>(what, status));
        }

        @Override
        public void onError(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            mOnErrorCalled.signal();
        }

        @Override
        public void onCommandLabelReached(MediaPlayer2 mp, @NonNull Object label) {
            labelReached.signal();
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mOnPrepareCalled.reset();
    mOnErrorCalled.reset();
    mPlayer.setMediaItem(new CallbackMediaItem2.Builder(dataSource).build());
    // prepare() will be pending until readAllowed is signaled.
    mPlayer.prepare();
    mPlayer.seekTo(3000);
    mPlayer.seekTo(2000);
    mPlayer.seekTo(1000);
    mPlayer.notifyWhenCommandLabelReached(new Object());
    readAllowed.signal();
    labelReached.waitForSignal();
    assertFalse(mOnErrorCalled.isSignalled());
    assertTrue(mOnPrepareCalled.isSignalled());
    assertEquals(5, commandsCompleted.size());
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE, MediaPlayer2.CALL_STATUS_NO_ERROR), commandsCompleted.get(0));
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_PREPARE, MediaPlayer2.CALL_STATUS_NO_ERROR), commandsCompleted.get(1));
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_SEEK_TO, MediaPlayer2.CALL_STATUS_SKIPPED), commandsCompleted.get(2));
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_SEEK_TO, MediaPlayer2.CALL_STATUS_SKIPPED), commandsCompleted.get(3));
    assertEquals(new Pair<>(MediaPlayer2.CALL_COMPLETED_SEEK_TO, MediaPlayer2.CALL_STATUS_NO_ERROR), commandsCompleted.get(4));
}
#end_block

#method_before
public static MediaItem2 createMediaItemWithMetadata() {
    return new FileMediaItem2.Builder(new FileDescriptor(), createMetadata()).build();
}
#method_after
public static MediaItem2 createMediaItemWithMetadata() {
    return new FileMediaItem2.Builder(new FileDescriptor()).setMetadata(createMetadata()).build();
}
#end_block

#method_before
@Override
public void prepare() {
    addTask(new Task(CALL_COMPLETED_PREPARE, true) {

        @Override
        void process() {
            MediaItem2 dataSourceDescription = getCurrentDataSource();
            MediaSource mediaSource = ExoPlayerUtils.createMediaSource(mDataSourceFactory, dataSourceDescription);
            synchronized (mPlayerLock) {
                mPlayer.prepare(mediaSource);
            }
        }
    });
}
#method_after
@Override
public void prepare() {
    addTask(new Task(CALL_COMPLETED_PREPARE, true) {

        @Override
        void process() {
            MediaItem2 item = getCurrentMediaItem();
            MediaSource mediaSource = ExoPlayerUtils.createMediaSource(mDataSourceFactory, item);
            synchronized (mPlayerLock) {
                mPlayer.prepare(mediaSource);
            }
        }
    });
}
#end_block

#method_before
@Override
public void onVideoSizeChanged(final int width, final int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {
    final MediaItem2 dataSourceDesc2;
    synchronized (mLock) {
        // TODO(b/80232248): get the active data source from a data source queue.
        dataSourceDesc2 = mDataSourceDescription;
        mVideoWidth = width;
        mVideoHeight = height;
    }
    notifyMediaPlayer2Event(new Mp2EventNotifier() {

        @Override
        public void notify(EventCallback callback) {
            callback.onVideoSizeChanged(ExoPlayerMediaPlayer2Impl.this, dataSourceDesc2, width, height);
        }
    });
}
#method_after
@Override
public void onVideoSizeChanged(final int width, final int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {
    final MediaItem2 item;
    synchronized (mLock) {
        // TODO(b/80232248): get the active media item from a media item queue.
        item = mMediaItem;
        mVideoWidth = width;
        mVideoHeight = height;
    }
    notifyMediaPlayer2Event(new Mp2EventNotifier() {

        @Override
        public void notify(EventCallback callback) {
            callback.onVideoSizeChanged(ExoPlayerMediaPlayer2Impl.this, item, width, height);
        }
    });
}
#end_block

#method_before
@Override
public void onTimelineChanged(Timeline timeline, Object manifest, int reason) {
    // preparation.
    if (reason != Player.TIMELINE_CHANGE_REASON_PREPARED) {
        return;
    }
    final MediaItem2 dataSourceDescription;
    synchronized (mLock) {
        dataSourceDescription = mDataSourceDescription;
    }
    notifyMediaPlayer2Event(new Mp2EventNotifier() {

        @Override
        public void notify(EventCallback callback) {
            MediaPlayer2 mediaPlayer2 = ExoPlayerMediaPlayer2Impl.this;
            callback.onInfo(mediaPlayer2, dataSourceDescription, MEDIA_INFO_PREPARED, 0);
        }
    });
    notifyPlayerEvent(new PlayerEventNotifier() {

        @Override
        public void notify(MediaPlayerConnector.PlayerEventCallback cb) {
            cb.onMediaPrepared(getMediaPlayerConnector(), dataSourceDescription);
        }
    });
    synchronized (mTaskLock) {
        if (mCurrentTask != null && mCurrentTask.mMediaCallType == CALL_COMPLETED_PREPARE && ObjectsCompat.equals(mCurrentTask.mDSD, dataSourceDescription) && mCurrentTask.mNeedToWaitForEventToComplete) {
            mCurrentTask.sendCompleteNotification(CALL_STATUS_NO_ERROR);
            mCurrentTask = null;
            processPendingTask();
        }
    }
}
#method_after
@Override
public void onTimelineChanged(Timeline timeline, Object manifest, int reason) {
    // preparation.
    if (reason != Player.TIMELINE_CHANGE_REASON_PREPARED) {
        return;
    }
    final MediaItem2 item;
    synchronized (mLock) {
        item = mMediaItem;
    }
    notifyMediaPlayer2Event(new Mp2EventNotifier() {

        @Override
        public void notify(EventCallback callback) {
            MediaPlayer2 mediaPlayer2 = ExoPlayerMediaPlayer2Impl.this;
            callback.onInfo(mediaPlayer2, item, MEDIA_INFO_PREPARED, /* extra= */
            0);
        }
    });
    notifyPlayerEvent(new PlayerEventNotifier() {

        @Override
        public void notify(MediaPlayerConnector.PlayerEventCallback cb) {
            cb.onMediaPrepared(getMediaPlayerConnector(), item);
        }
    });
    synchronized (mTaskLock) {
        if (mCurrentTask != null && mCurrentTask.mMediaCallType == CALL_COMPLETED_PREPARE && ObjectsCompat.equals(mCurrentTask.mDSD, item) && mCurrentTask.mNeedToWaitForEventToComplete) {
            mCurrentTask.sendCompleteNotification(CALL_STATUS_NO_ERROR);
            mCurrentTask = null;
            processPendingTask();
        }
    }
}
#end_block

#method_before
@Override
public void onRenderedFirstFrame() {
}
#method_after
@Override
public void onRenderedFirstFrame() {
    final MediaItem2 item;
    synchronized (mLock) {
        // TODO(b/80232248): get the active data source from a data source queue.
        item = mMediaItem;
    }
    notifyMediaPlayer2Event(new Mp2EventNotifier() {

        @Override
        public void notify(EventCallback callback) {
            MediaPlayer2 mediaPlayer2 = ExoPlayerMediaPlayer2Impl.this;
            callback.onInfo(mediaPlayer2, item, MEDIA_INFO_VIDEO_RENDERING_START, /* extra= */
            0);
        }
    });
}
#end_block

#method_before
@Override
public void run() {
    int status = CALL_STATUS_NO_ERROR;
    boolean skip;
    synchronized (mTaskLock) {
        skip = mSkip;
    }
    if (!skip) {
        try {
            if (mMediaCallType != CALL_COMPLETED_NOTIFY_WHEN_COMMAND_LABEL_REACHED && getState() == PLAYER_STATE_ERROR) {
                status = CALL_STATUS_INVALID_OPERATION;
            } else {
                process();
            }
        } catch (IllegalStateException e) {
            status = CALL_STATUS_INVALID_OPERATION;
        } catch (IllegalArgumentException e) {
            status = CALL_STATUS_BAD_VALUE;
        } catch (SecurityException e) {
            status = CALL_STATUS_PERMISSION_DENIED;
        } catch (IOException e) {
            status = CALL_STATUS_ERROR_IO;
        } catch (Exception e) {
            status = CALL_STATUS_ERROR_UNKNOWN;
        }
    } else {
        status = CALL_STATUS_SKIPPED;
    }
    mDSD = getCurrentDataSource();
    if (!mNeedToWaitForEventToComplete || status != CALL_STATUS_NO_ERROR || skip) {
        sendCompleteNotification(status);
        synchronized (mTaskLock) {
            mCurrentTask = null;
            processPendingTask();
        }
    }
}
#method_after
@Override
public void run() {
    int status = CALL_STATUS_NO_ERROR;
    boolean skip;
    synchronized (mTaskLock) {
        skip = mSkip;
    }
    if (!skip) {
        try {
            if (mMediaCallType != CALL_COMPLETED_NOTIFY_WHEN_COMMAND_LABEL_REACHED && getState() == PLAYER_STATE_ERROR) {
                status = CALL_STATUS_INVALID_OPERATION;
            } else {
                process();
            }
        } catch (IllegalStateException e) {
            status = CALL_STATUS_INVALID_OPERATION;
        } catch (IllegalArgumentException e) {
            status = CALL_STATUS_BAD_VALUE;
        } catch (SecurityException e) {
            status = CALL_STATUS_PERMISSION_DENIED;
        } catch (IOException e) {
            status = CALL_STATUS_ERROR_IO;
        } catch (Exception e) {
            status = CALL_STATUS_ERROR_UNKNOWN;
        }
    } else {
        status = CALL_STATUS_SKIPPED;
    }
    mDSD = getCurrentMediaItem();
    if (!mNeedToWaitForEventToComplete || status != CALL_STATUS_NO_ERROR || skip) {
        sendCompleteNotification(status);
        synchronized (mTaskLock) {
            mCurrentTask = null;
            processPendingTask();
        }
    }
}
#end_block

#method_before
private MediaItem2 createMediaItem(String mediaId) {
    MediaMetadata2 metadata = new MediaMetadata2.Builder().putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, mediaId).build();
    return new MediaItem2.Builder(metadata).setMediaId(mediaId).build();
}
#method_after
private MediaItem2 createMediaItem(String mediaId) {
    MediaMetadata2 metadata = new MediaMetadata2.Builder().putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, mediaId).build();
    return new MediaItem2.Builder(MediaItem2.FLAG_PLAYABLE).setMediaId(mediaId).setMetadata(metadata).build();
}
#end_block

#method_before
@Test
public void testOnCommandRequest() throws InterruptedException {
    prepareLooper();
    mPlayer = new MockPlayerConnector(1);
    final MockOnCommandCallback callback = new MockOnCommandCallback();
    MediaSession2 session = new MediaSession2.Builder(mContext).setPlayer(mPlayer).setSessionCallback(sHandlerExecutor, callback).setId("testOnCommandRequest").build();
    mController2 = createRemoteController2(session.getToken());
    mController2.pause();
    assertFalse(mPlayer.mCountDownLatch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    assertFalse(mPlayer.mPauseCalled);
    assertEquals(1, callback.commands.size());
    assertEquals(SessionCommand2.COMMAND_CODE_PLAYBACK_PAUSE, (long) callback.commands.get(0).getCommandCode());
    mController2.play();
    assertTrue(mPlayer.mCountDownLatch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    assertTrue(mPlayer.mPlayCalled);
    assertFalse(mPlayer.mPauseCalled);
    assertEquals(2, callback.commands.size());
    assertEquals(SessionCommand2.COMMAND_CODE_PLAYBACK_PLAY, (long) callback.commands.get(1).getCommandCode());
}
#method_after
@Test
public void testOnCommandRequest() throws InterruptedException {
    prepareLooper();
    mPlayer = new MockPlayerConnector(1);
    final MockOnCommandCallback callback = new MockOnCommandCallback();
    try (MediaSession2 session = new MediaSession2.Builder(mContext).setPlayer(mPlayer).setSessionCallback(sHandlerExecutor, callback).setId("testOnCommandRequest").build()) {
        mController2 = createRemoteController2(session.getToken());
        mController2.pause();
        assertFalse(mPlayer.mCountDownLatch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
        assertFalse(mPlayer.mPauseCalled);
        assertEquals(1, callback.commands.size());
        assertEquals(SessionCommand2.COMMAND_CODE_PLAYBACK_PAUSE, (long) callback.commands.get(0).getCommandCode());
        mController2.play();
        assertTrue(mPlayer.mCountDownLatch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
        assertTrue(mPlayer.mPlayCalled);
        assertFalse(mPlayer.mPauseCalled);
        assertEquals(2, callback.commands.size());
        assertEquals(SessionCommand2.COMMAND_CODE_PLAYBACK_PLAY, (long) callback.commands.get(1).getCommandCode());
    }
}
#end_block

#method_before
@Test
public void testOnCustomCommand() throws InterruptedException {
    prepareLooper();
    // TODO(jaewan): Need to revisit with the permission.
    final SessionCommand2 testCommand = new SessionCommand2("testCustomCommand", null);
    final Bundle testArgs = new Bundle();
    testArgs.putString("args", "testOnCustomCommand");
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaSession2.SessionCallback callback = new MediaSession2.SessionCallback() {

        @Override
        public SessionCommandGroup2 onConnect(@NonNull MediaSession2 session, @NonNull ControllerInfo controller) {
            SessionCommandGroup2 commands = new SessionCommandGroup2.Builder().addAllPredefinedCommands(SessionCommand2.COMMAND_VERSION_1).addCommand(testCommand).build();
            return commands;
        }

        @Override
        public void onCustomCommand(MediaSession2 session, MediaSession2.ControllerInfo controller, SessionCommand2 customCommand, Bundle args, ResultReceiver cb) {
            assertEquals(CLIENT_PACKAGE_NAME, controller.getPackageName());
            assertEquals(testCommand, customCommand);
            assertTrue(TestUtils.equals(testArgs, args));
            assertNull(cb);
            latch.countDown();
        }
    };
    MediaSession2 session = new MediaSession2.Builder(mContext).setPlayer(mPlayer).setSessionCallback(sHandlerExecutor, callback).setId("testOnCustomCommand").build();
    mController2 = createRemoteController2(session.getToken());
    mController2.sendCustomCommand(testCommand, testArgs, null);
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnCustomCommand() throws InterruptedException {
    prepareLooper();
    // TODO(jaewan): Need to revisit with the permission.
    final SessionCommand2 testCommand = new SessionCommand2("testCustomCommand", null);
    final Bundle testArgs = new Bundle();
    testArgs.putString("args", "testOnCustomCommand");
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaSession2.SessionCallback callback = new MediaSession2.SessionCallback() {

        @Override
        public SessionCommandGroup2 onConnect(@NonNull MediaSession2 session, @NonNull ControllerInfo controller) {
            SessionCommandGroup2 commands = new SessionCommandGroup2.Builder().addAllPredefinedCommands(SessionCommand2.COMMAND_VERSION_1).addCommand(testCommand).build();
            return commands;
        }

        @Override
        public void onCustomCommand(MediaSession2 session, MediaSession2.ControllerInfo controller, SessionCommand2 customCommand, Bundle args, ResultReceiver cb) {
            assertEquals(CLIENT_PACKAGE_NAME, controller.getPackageName());
            assertEquals(testCommand, customCommand);
            assertTrue(TestUtils.equals(testArgs, args));
            assertNull(cb);
            latch.countDown();
        }
    };
    try (MediaSession2 session = new MediaSession2.Builder(mContext).setPlayer(mPlayer).setSessionCallback(sHandlerExecutor, callback).setId("testOnCustomCommand").build()) {
        mController2 = createRemoteController2(session.getToken());
        mController2.sendCustomCommand(testCommand, testArgs, null);
        assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    }
}
#end_block

#method_before
@Test
public void testOnSubscribeRoutesInfo() throws InterruptedException {
    prepareLooper();
    final TestSessionCallback callback = new TestSessionCallback() {

        @Override
        public void onSubscribeRoutesInfo(@NonNull MediaSession2 session, @NonNull ControllerInfo controller) {
            assertEquals(CLIENT_PACKAGE_NAME, controller.getPackageName());
            mLatch.countDown();
        }
    };
    MediaSession2 session = new MediaSession2.Builder(mContext).setPlayer(mPlayer).setSessionCallback(sHandlerExecutor, callback).setId("testOnSubscribeRoutesInfo").build();
    mController2 = createRemoteController2(session.getToken());
    callback.resetLatchCount(1);
    mController2.subscribeRoutesInfo();
    assertTrue(callback.mLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnSubscribeRoutesInfo() throws InterruptedException {
    prepareLooper();
    final TestSessionCallback callback = new TestSessionCallback() {

        @Override
        public void onSubscribeRoutesInfo(@NonNull MediaSession2 session, @NonNull ControllerInfo controller) {
            assertEquals(CLIENT_PACKAGE_NAME, controller.getPackageName());
            mLatch.countDown();
        }
    };
    try (MediaSession2 session = new MediaSession2.Builder(mContext).setPlayer(mPlayer).setSessionCallback(sHandlerExecutor, callback).setId("testOnSubscribeRoutesInfo").build()) {
        mController2 = createRemoteController2(session.getToken());
        callback.resetLatchCount(1);
        mController2.subscribeRoutesInfo();
        assertTrue(callback.mLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#end_block

#method_before
@Test
public void testOnUnsubscribeRoutesInfo() throws InterruptedException {
    prepareLooper();
    final TestSessionCallback callback = new TestSessionCallback() {

        @Override
        public void onUnsubscribeRoutesInfo(@NonNull MediaSession2 session, @NonNull ControllerInfo controller) {
            assertEquals(CLIENT_PACKAGE_NAME, controller.getPackageName());
            mLatch.countDown();
        }
    };
    MediaSession2 session = new MediaSession2.Builder(mContext).setPlayer(mPlayer).setSessionCallback(sHandlerExecutor, callback).setId("testOnUnsubscribeRoutesInfo").build();
    mController2 = createRemoteController2(session.getToken());
    callback.resetLatchCount(1);
    mController2.unsubscribeRoutesInfo();
    assertTrue(callback.mLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnUnsubscribeRoutesInfo() throws InterruptedException {
    prepareLooper();
    final TestSessionCallback callback = new TestSessionCallback() {

        @Override
        public void onUnsubscribeRoutesInfo(@NonNull MediaSession2 session, @NonNull ControllerInfo controller) {
            assertEquals(CLIENT_PACKAGE_NAME, controller.getPackageName());
            mLatch.countDown();
        }
    };
    try (MediaSession2 session = new MediaSession2.Builder(mContext).setPlayer(mPlayer).setSessionCallback(sHandlerExecutor, callback).setId("testOnUnsubscribeRoutesInfo").build()) {
        mController2 = createRemoteController2(session.getToken());
        callback.resetLatchCount(1);
        mController2.unsubscribeRoutesInfo();
        assertTrue(callback.mLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#end_block

#method_before
@Test
public void testOnSelectRoute() throws InterruptedException {
    prepareLooper();
    final Bundle testRoute = TestUtils.createTestBundle();
    final TestSessionCallback callback = new TestSessionCallback() {

        @Override
        public void onSelectRoute(@NonNull MediaSession2 session, @NonNull ControllerInfo controller, @NonNull Bundle route) {
            assertEquals(CLIENT_PACKAGE_NAME, controller.getPackageName());
            assertTrue(TestUtils.equals(testRoute, route));
            mLatch.countDown();
        }
    };
    MediaSession2 session = new MediaSession2.Builder(mContext).setPlayer(mPlayer).setSessionCallback(sHandlerExecutor, callback).setId("testOnSelectRoute").build();
    mController2 = createRemoteController2(session.getToken());
    callback.resetLatchCount(1);
    mController2.selectRoute(testRoute);
    assertTrue(callback.mLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnSelectRoute() throws InterruptedException {
    prepareLooper();
    final Bundle testRoute = TestUtils.createTestBundle();
    final TestSessionCallback callback = new TestSessionCallback() {

        @Override
        public void onSelectRoute(@NonNull MediaSession2 session, @NonNull ControllerInfo controller, @NonNull Bundle route) {
            assertEquals(CLIENT_PACKAGE_NAME, controller.getPackageName());
            assertTrue(TestUtils.equals(testRoute, route));
            mLatch.countDown();
        }
    };
    try (MediaSession2 session = new MediaSession2.Builder(mContext).setPlayer(mPlayer).setSessionCallback(sHandlerExecutor, callback).setId("testOnSelectRoute").build()) {
        mController2 = createRemoteController2(session.getToken());
        callback.resetLatchCount(1);
        mController2.selectRoute(testRoute);
        assertTrue(callback.mLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
    }
}
#end_block

#method_before
@Test
public void testOnPlayerStateChanged() throws Exception {
    prepareLooper();
    final int targetState = MediaPlayerConnector.PLAYER_STATE_PLAYING;
    final CountDownLatch latchForSessionCallback = new CountDownLatch(1);
    sHandler.postAndSync(new Runnable() {

        @Override
        public void run() {
            MediaSession2 session = new MediaSession2.Builder(mContext).setPlayer(mPlayer).setSessionCallback(sHandlerExecutor, new MediaSession2.SessionCallback() {

                @Override
                public void onPlayerStateChanged(MediaSession2 session, MediaPlayerConnector player, int state) {
                    assertEquals(targetState, state);
                    latchForSessionCallback.countDown();
                }
            }).build();
        }
    });
    mPlayer.notifyPlayerStateChanged(targetState);
    assertTrue(latchForSessionCallback.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testOnPlayerStateChanged() throws Exception {
    prepareLooper();
    final int targetState = MediaPlayerConnector.PLAYER_STATE_PLAYING;
    final CountDownLatch latchForSessionCallback = new CountDownLatch(1);
    try (MediaSession2 session = new MediaSession2.Builder(mContext).setPlayer(mPlayer).setSessionCallback(sHandlerExecutor, new MediaSession2.SessionCallback() {

        @Override
        public void onPlayerStateChanged(MediaSession2 session, MediaPlayerConnector player, int state) {
            assertEquals(targetState, state);
            latchForSessionCallback.countDown();
        }
    }).setId("testOnPlayerStateChanged").build()) {
        mPlayer.notifyPlayerStateChanged(targetState);
        assertTrue(latchForSessionCallback.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    }
}
#end_block

#method_before
private void playLoadedModularDrmVideo_Generic(final Uri file, final Integer width, final Integer height, int playTime, ModularDrmTestType testType) throws Exception {
    final float volume = 0.5f;
    mAudioOnly = (width == 0);
    mCallStatus = MediaPlayer2.CALL_STATUS_NO_ERROR;
    mECb = new MediaPlayer2.EventCallback() {

        @Override
        public void onVideoSizeChanged(MediaPlayer2 mp, MediaItem2 item, int w, int h) {
            Log.v(TAG, "VideoSizeChanged" + " w:" + w + " h:" + h);
            mOnVideoSizeChangedCalled.signal();
        }

        @Override
        public void onError(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            fail("Media player had error " + what + " playing video");
        }

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPreparedCalled.signal();
            } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_END) {
                Log.v(TAG, "playLoadedVideo: onInfo_PlaybackComplete");
                mOnPlaybackCompleted.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE) {
                mCallStatus = status;
                mSetDataSourceCallCompleted.signal();
            }
        }
    };
    mPlayer.setEventCallback(mExecutor, mECb);
    Log.v(TAG, "playLoadedVideo: setDataSource()");
    mPlayer.setDataSource(new UriMediaItem2.Builder(mContext, file).build());
    mSetDataSourceCallCompleted.waitForSignal();
    if (mCallStatus != MediaPlayer2.CALL_STATUS_NO_ERROR) {
        throw new PrepareFailedException();
    }
    SurfaceHolder surfaceHolder = mActivity.getSurfaceHolder();
    surfaceHolder.setKeepScreenOn(true);
    mPlayer.setSurface(surfaceHolder.getSurface());
    try {
        switch(testType) {
            case V0_SYNC_TEST:
                preparePlayerAndDrm_V0_syncDrmSetup();
                break;
            case V1_ASYNC_TEST:
                preparePlayerAndDrm_V1_asyncDrmSetup();
                break;
            case V2_SYNC_CONFIG_TEST:
                preparePlayerAndDrm_V2_syncDrmSetupPlusConfig();
                break;
            case V3_ASYNC_DRMPREPARED_TEST:
                preparePlayerAndDrm_V3_asyncDrmSetupPlusDrmPreparedListener();
                break;
        }
    } catch (IOException e) {
        e.printStackTrace();
        throw new PrepareFailedException();
    }
    Log.v(TAG, "playLoadedVideo: play()");
    mPlayer.play();
    if (!mAudioOnly) {
        mOnVideoSizeChangedCalled.waitForSignal();
    }
    mPlayer.setPlayerVolume(volume);
    // waiting to complete
    if (playTime == 0) {
        Log.v(TAG, "playLoadedVideo: waiting for playback completion");
        mOnPlaybackCompleted.waitForSignal();
    } else {
        Log.v(TAG, "playLoadedVideo: waiting while playing for " + playTime);
        mOnPlaybackCompleted.waitForSignal(playTime);
    }
    try {
        Log.v(TAG, "playLoadedVideo: releaseDrm");
        mPlayer.releaseDrm();
    } catch (Exception e) {
        e.printStackTrace();
        throw new PrepareFailedException();
    }
}
#method_after
private void playLoadedModularDrmVideo_Generic(final Uri file, final Integer width, final Integer height, int playTime, ModularDrmTestType testType) throws Exception {
    final float volume = 0.5f;
    mAudioOnly = (width == 0);
    mCallStatus = MediaPlayer2.CALL_STATUS_NO_ERROR;
    mECb = new MediaPlayer2.EventCallback() {

        @Override
        public void onVideoSizeChanged(MediaPlayer2 mp, MediaItem2 item, int w, int h) {
            Log.v(TAG, "VideoSizeChanged" + " w:" + w + " h:" + h);
            mOnVideoSizeChangedCalled.signal();
        }

        @Override
        public void onError(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            fail("Media player had error " + what + " playing video");
        }

        @Override
        public void onInfo(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPreparedCalled.signal();
            } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_END) {
                Log.v(TAG, "playLoadedVideo: onInfo_PlaybackComplete");
                mOnPlaybackCompleted.signal();
            }
        }

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_SET_DATA_SOURCE) {
                mCallStatus = status;
                mSetDataSourceCallCompleted.signal();
            }
        }
    };
    mPlayer.setEventCallback(mExecutor, mECb);
    Log.v(TAG, "playLoadedVideo: setMediaItem()");
    mPlayer.setMediaItem(new UriMediaItem2.Builder(mContext, file).build());
    mSetDataSourceCallCompleted.waitForSignal();
    if (mCallStatus != MediaPlayer2.CALL_STATUS_NO_ERROR) {
        throw new PrepareFailedException();
    }
    SurfaceHolder surfaceHolder = mActivity.getSurfaceHolder();
    surfaceHolder.setKeepScreenOn(true);
    mPlayer.setSurface(surfaceHolder.getSurface());
    try {
        switch(testType) {
            case V0_SYNC_TEST:
                preparePlayerAndDrm_V0_syncDrmSetup();
                break;
            case V1_ASYNC_TEST:
                preparePlayerAndDrm_V1_asyncDrmSetup();
                break;
            case V2_SYNC_CONFIG_TEST:
                preparePlayerAndDrm_V2_syncDrmSetupPlusConfig();
                break;
            case V3_ASYNC_DRMPREPARED_TEST:
                preparePlayerAndDrm_V3_asyncDrmSetupPlusDrmPreparedListener();
                break;
        }
    } catch (IOException e) {
        e.printStackTrace();
        throw new PrepareFailedException();
    }
    Log.v(TAG, "playLoadedVideo: play()");
    mPlayer.play();
    if (!mAudioOnly) {
        mOnVideoSizeChangedCalled.waitForSignal();
    }
    mPlayer.setPlayerVolume(volume);
    // waiting to complete
    if (playTime == 0) {
        Log.v(TAG, "playLoadedVideo: waiting for playback completion");
        mOnPlaybackCompleted.waitForSignal();
    } else {
        Log.v(TAG, "playLoadedVideo: waiting while playing for " + playTime);
        mOnPlaybackCompleted.waitForSignal(playTime);
    }
    try {
        Log.v(TAG, "playLoadedVideo: releaseDrm");
        mPlayer.releaseDrm();
    } catch (Exception e) {
        e.printStackTrace();
        throw new PrepareFailedException();
    }
}
#end_block

#method_before
private void playLoadedModularDrmVideo_V4_offlineKey(final Uri file, final Integer width, final Integer height, int playTime) throws Exception {
    final float volume = 0.5f;
    mAudioOnly = (width == 0);
    SurfaceHolder surfaceHolder = mActivity.getSurfaceHolder();
    Log.v(TAG, "playLoadedModularDrmVideo_V4_offlineKey: setSurface " + surfaceHolder);
    mPlayer.setSurface(surfaceHolder.getSurface());
    surfaceHolder.setKeepScreenOn(true);
    mCallStatus = MediaPlayer2.CALL_STATUS_NO_ERROR;
    DrmInfo drmInfo = null;
    for (int round = 0; round < 2; round++) {
        boolean keyRequestRound = (round == 0);
        boolean restoreRound = (round == 1);
        Log.v(TAG, "playLoadedVideo: round " + round);
        try {
            mPlayer.setEventCallback(mExecutor, mECb);
            Log.v(TAG, "playLoadedVideo: setDataSource()");
            mPlayer.setDataSource(new UriMediaItem2.Builder(mContext, file).build());
            Log.v(TAG, "playLoadedVideo: prepare()");
            mPlayer.prepare();
            mOnPreparedCalled.waitForSignal();
            // but preparing the DRM every time with proper key request type
            drmInfo = mPlayer.getDrmInfo();
            if (drmInfo != null) {
                if (keyRequestRound) {
                    // asking for offline keys
                    setupDrm(drmInfo, true, /* prepareDrm */
                    true, /* synchronousNetworking */
                    MediaDrm.KEY_TYPE_OFFLINE);
                } else if (restoreRound) {
                    setupDrmRestore(drmInfo, true);
                } else {
                    fail("preparePlayer: unexpected round " + round);
                }
                Log.v(TAG, "preparePlayer: setupDrm done!");
            }
        } catch (IOException e) {
            e.printStackTrace();
            throw new PrepareFailedException();
        }
        Log.v(TAG, "playLoadedVideo: play()");
        mPlayer.play();
        if (!mAudioOnly) {
            mOnVideoSizeChangedCalled.waitForSignal();
        }
        mPlayer.setPlayerVolume(volume);
        // waiting to complete
        if (playTime == 0) {
            Log.v(TAG, "playLoadedVideo: waiting for playback completion");
            mOnPlaybackCompleted.waitForSignal();
        } else {
            Log.v(TAG, "playLoadedVideo: waiting while playing for " + playTime);
            mOnPlaybackCompleted.waitForSignal(playTime);
        }
        try {
            if (drmInfo != null) {
                if (restoreRound) {
                    // releasing the offline key
                    setupDrm(null, /* drmInfo */
                    false, /* prepareDrm */
                    true, /* synchronousNetworking */
                    MediaDrm.KEY_TYPE_RELEASE);
                    Log.v(TAG, "playLoadedVideo: released offline keys");
                }
                Log.v(TAG, "playLoadedVideo: releaseDrm");
                mPlayer.releaseDrm();
            }
        } catch (Exception e) {
            e.printStackTrace();
            throw new PrepareFailedException();
        }
        if (keyRequestRound) {
            mOnPreparedCalled.reset();
            mOnVideoSizeChangedCalled.reset();
            mOnPlaybackCompleted.reset();
            final int sleepBetweenRounds = 1000;
            Thread.sleep(sleepBetweenRounds);
            Log.v(TAG, "playLoadedVideo: reset");
            mPlayer.reset();
        }
    }
// for
}
#method_after
private void playLoadedModularDrmVideo_V4_offlineKey(final Uri file, final Integer width, final Integer height, int playTime) throws Exception {
    final float volume = 0.5f;
    mAudioOnly = (width == 0);
    SurfaceHolder surfaceHolder = mActivity.getSurfaceHolder();
    Log.v(TAG, "playLoadedModularDrmVideo_V4_offlineKey: setSurface " + surfaceHolder);
    mPlayer.setSurface(surfaceHolder.getSurface());
    surfaceHolder.setKeepScreenOn(true);
    mCallStatus = MediaPlayer2.CALL_STATUS_NO_ERROR;
    DrmInfo drmInfo = null;
    for (int round = 0; round < 2; round++) {
        boolean keyRequestRound = (round == 0);
        boolean restoreRound = (round == 1);
        Log.v(TAG, "playLoadedVideo: round " + round);
        try {
            mPlayer.setEventCallback(mExecutor, mECb);
            Log.v(TAG, "playLoadedVideo: setMediaItem()");
            mPlayer.setMediaItem(new UriMediaItem2.Builder(mContext, file).build());
            Log.v(TAG, "playLoadedVideo: prepare()");
            mPlayer.prepare();
            mOnPreparedCalled.waitForSignal();
            // but preparing the DRM every time with proper key request type
            drmInfo = mPlayer.getDrmInfo();
            if (drmInfo != null) {
                if (keyRequestRound) {
                    // asking for offline keys
                    setupDrm(drmInfo, true, /* prepareDrm */
                    true, /* synchronousNetworking */
                    MediaDrm.KEY_TYPE_OFFLINE);
                } else if (restoreRound) {
                    setupDrmRestore(drmInfo, true);
                } else {
                    fail("preparePlayer: unexpected round " + round);
                }
                Log.v(TAG, "preparePlayer: setupDrm done!");
            }
        } catch (IOException e) {
            e.printStackTrace();
            throw new PrepareFailedException();
        }
        Log.v(TAG, "playLoadedVideo: play()");
        mPlayer.play();
        if (!mAudioOnly) {
            mOnVideoSizeChangedCalled.waitForSignal();
        }
        mPlayer.setPlayerVolume(volume);
        // waiting to complete
        if (playTime == 0) {
            Log.v(TAG, "playLoadedVideo: waiting for playback completion");
            mOnPlaybackCompleted.waitForSignal();
        } else {
            Log.v(TAG, "playLoadedVideo: waiting while playing for " + playTime);
            mOnPlaybackCompleted.waitForSignal(playTime);
        }
        try {
            if (drmInfo != null) {
                if (restoreRound) {
                    // releasing the offline key
                    setupDrm(null, /* drmInfo */
                    false, /* prepareDrm */
                    true, /* synchronousNetworking */
                    MediaDrm.KEY_TYPE_RELEASE);
                    Log.v(TAG, "playLoadedVideo: released offline keys");
                }
                Log.v(TAG, "playLoadedVideo: releaseDrm");
                mPlayer.releaseDrm();
            }
        } catch (Exception e) {
            e.printStackTrace();
            throw new PrepareFailedException();
        }
        if (keyRequestRound) {
            mOnPreparedCalled.reset();
            mOnVideoSizeChangedCalled.reset();
            mOnPlaybackCompleted.reset();
            final int sleepBetweenRounds = 1000;
            Thread.sleep(sleepBetweenRounds);
            Log.v(TAG, "playLoadedVideo: reset");
            mPlayer.reset();
        }
    }
// for
}
#end_block

#method_before
@Override
public void initialize(VideoView2 instance, Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
    mInstance = instance;
    mVideoWidth = 0;
    mVideoHeight = 0;
    mSelectedSubtitleTrackIndex = INVALID_TRACK_INDEX;
    mAudioAttributes = new AudioAttributesCompat.Builder().setUsage(AudioAttributesCompat.USAGE_MEDIA).setContentType(AudioAttributesCompat.CONTENT_TYPE_MOVIE).build();
    mCallbackExecutor = MainHandlerExecutor.getExecutor(context);
    mInstance.setFocusable(true);
    mInstance.setFocusableInTouchMode(true);
    mInstance.requestFocus();
    mTextureView = new VideoTextureView(context);
    mSurfaceView = new VideoSurfaceView(context);
    LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
    mTextureView.setLayoutParams(params);
    mSurfaceView.setLayoutParams(params);
    mTextureView.setSurfaceListener(this);
    mSurfaceView.setSurfaceListener(this);
    mInstance.addView(mTextureView);
    mInstance.addView(mSurfaceView);
    mSubtitleAnchorView = new SubtitleAnchorView(context);
    mSubtitleAnchorView.setLayoutParams(params);
    mSubtitleAnchorView.setBackgroundColor(0);
    mInstance.addView(mSubtitleAnchorView);
    LayoutInflater inflater = (LayoutInflater) mInstance.getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    mMusicFullLandscapeView = inflater.inflate(R.layout.full_landscape_music, null);
    mMusicFullPortraitView = inflater.inflate(R.layout.full_portrait_music, null);
    mMusicEmbeddedView = inflater.inflate(R.layout.embedded_music, null);
    boolean enableControlView = (attrs == null) || attrs.getAttributeBooleanValue("http://schemas.android.com/apk/res-auto", "enableControlView", true);
    if (enableControlView) {
        mMediaControlView = new MediaControlView2(context);
    }
    // Choose surface view by default
    int viewType = (attrs == null) ? VideoView2.VIEW_TYPE_SURFACEVIEW : attrs.getAttributeIntValue("http://schemas.android.com/apk/res-auto", "viewType", VideoView2.VIEW_TYPE_SURFACEVIEW);
    if (viewType == VideoView2.VIEW_TYPE_SURFACEVIEW) {
        if (DEBUG) {
            Log.d(TAG, "viewType attribute is surfaceView.");
        }
        mTextureView.setVisibility(View.GONE);
        mSurfaceView.setVisibility(View.VISIBLE);
        mCurrentView = mSurfaceView;
    } else if (viewType == VideoView2.VIEW_TYPE_TEXTUREVIEW) {
        if (DEBUG) {
            Log.d(TAG, "viewType attribute is textureView.");
        }
        mTextureView.setVisibility(View.VISIBLE);
        mSurfaceView.setVisibility(View.GONE);
        mCurrentView = mTextureView;
    }
    MediaRouteSelector.Builder builder = new MediaRouteSelector.Builder();
    builder.addControlCategory(MediaControlIntent.CATEGORY_REMOTE_PLAYBACK);
    builder.addControlCategory(MediaControlIntent.CATEGORY_LIVE_AUDIO);
    builder.addControlCategory(MediaControlIntent.CATEGORY_LIVE_VIDEO);
    mRouteSelector = builder.build();
}
#method_after
@Override
public void initialize(VideoView2 instance, Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
    mInstance = instance;
    mVideoWidth = 0;
    mVideoHeight = 0;
    mSelectedSubtitleTrackIndex = INVALID_TRACK_INDEX;
    mAudioAttributes = new AudioAttributesCompat.Builder().setUsage(AudioAttributesCompat.USAGE_MEDIA).setContentType(AudioAttributesCompat.CONTENT_TYPE_MOVIE).build();
    mCallbackExecutor = ContextCompat.getMainExecutor(context);
    mInstance.setFocusable(true);
    mInstance.setFocusableInTouchMode(true);
    mInstance.requestFocus();
    mTextureView = new VideoTextureView(context);
    mSurfaceView = new VideoSurfaceView(context);
    LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
    mTextureView.setLayoutParams(params);
    mSurfaceView.setLayoutParams(params);
    mTextureView.setSurfaceListener(this);
    mSurfaceView.setSurfaceListener(this);
    mInstance.addView(mTextureView);
    mInstance.addView(mSurfaceView);
    mSubtitleAnchorView = new SubtitleAnchorView(context);
    mSubtitleAnchorView.setLayoutParams(params);
    mSubtitleAnchorView.setBackgroundColor(0);
    mInstance.addView(mSubtitleAnchorView);
    LayoutInflater inflater = (LayoutInflater) mInstance.getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    mMusicFullLandscapeView = inflater.inflate(R.layout.full_landscape_music, null);
    mMusicFullPortraitView = inflater.inflate(R.layout.full_portrait_music, null);
    mMusicEmbeddedView = inflater.inflate(R.layout.embedded_music, null);
    boolean enableControlView = (attrs == null) || attrs.getAttributeBooleanValue("http://schemas.android.com/apk/res-auto", "enableControlView", true);
    if (enableControlView) {
        mMediaControlView = new MediaControlView2(context);
    }
    // Choose surface view by default
    int viewType = (attrs == null) ? VideoView2.VIEW_TYPE_SURFACEVIEW : attrs.getAttributeIntValue("http://schemas.android.com/apk/res-auto", "viewType", VideoView2.VIEW_TYPE_SURFACEVIEW);
    if (viewType == VideoView2.VIEW_TYPE_SURFACEVIEW) {
        if (DEBUG) {
            Log.d(TAG, "viewType attribute is surfaceView.");
        }
        mTextureView.setVisibility(View.GONE);
        mSurfaceView.setVisibility(View.VISIBLE);
        mCurrentView = mSurfaceView;
    } else if (viewType == VideoView2.VIEW_TYPE_TEXTUREVIEW) {
        if (DEBUG) {
            Log.d(TAG, "viewType attribute is textureView.");
        }
        mTextureView.setVisibility(View.VISIBLE);
        mSurfaceView.setVisibility(View.GONE);
        mCurrentView = mTextureView;
    }
    MediaRouteSelector.Builder builder = new MediaRouteSelector.Builder();
    builder.addControlCategory(MediaControlIntent.CATEGORY_REMOTE_PLAYBACK);
    builder.addControlCategory(MediaControlIntent.CATEGORY_LIVE_AUDIO);
    builder.addControlCategory(MediaControlIntent.CATEGORY_LIVE_VIDEO);
    mRouteSelector = builder.build();
}
#end_block

#method_before
@Override
public void onSurfaceTakeOverDone(VideoViewInterface view) {
    if (DEBUG) {
        Log.d(TAG, "onSurfaceTakeOverDone(). Now current view is: " + view);
    }
    mCurrentView = view;
    if (mViewTypeChangedListener != null) {
        mViewTypeChangedListener.onViewTypeChanged(mInstance, view.getViewType());
    }
    if (needToStart()) {
        mMediaSession.play();
    }
}
#method_after
@Override
public void onSurfaceTakeOverDone(VideoViewInterface view) {
    if (DEBUG) {
        Log.d(TAG, "onSurfaceTakeOverDone(). Now current view is: " + view);
    }
    if (mCurrentState != STATE_PLAYING) {
        mMediaSession.seekTo(mMediaSession.getCurrentPosition());
    }
    mCurrentView = view;
    if (mViewTypeChangedListener != null) {
        mViewTypeChangedListener.onViewTypeChanged(mInstance, view.getViewType());
    }
    if (needToStart()) {
        mMediaSession.play();
    }
}
#end_block

#method_before
void openVideo() {
    if (DEBUG) {
        Log.d(TAG, "openVideo()");
    }
    if (mMediaItem != null) {
        resetPlayer();
        if (isRemotePlayback()) {
            mRoutePlayer.setDataSource(mMediaItem);
            return;
        } else {
            if (mMediaPlayer != null) {
                // TODO: Remove once b/110811730 is fixed.
                mMediaPlayer.setDataSource(mMediaItem);
            }
        }
    }
    try {
        if (mMediaPlayer == null) {
            mMediaPlayer = MediaPlayer2.create(mInstance.getContext());
            mVideoView2Player = new VideoView2Player(mMediaPlayer);
        }
        mSurfaceView.setMediaPlayer(mMediaPlayer);
        mTextureView.setMediaPlayer(mMediaPlayer);
        if (!mCurrentView.assignSurfaceToMediaPlayer(mMediaPlayer)) {
            Log.w(TAG, "failed to assign surface");
        }
        mMediaPlayer.setEventCallback(mCallbackExecutor, mMediaPlayer2Callback);
        mMediaPlayer.setAudioAttributes(mAudioAttributes);
        if (mMediaSession == null) {
            final Context context = mInstance.getContext();
            mMediaSession = new MediaSession2.Builder(context).setPlayer(mVideoView2Player).setId("VideoView2_" + mInstance.toString()).setSessionCallback(mCallbackExecutor, new MediaSessionCallback()).build();
        } else {
            mMediaSession.updatePlayerConnector(mVideoView2Player, mMediaSession.getPlaylistAgent());
        }
        mMediaSession.setPlaylist(mPlayList, null);
        final Context context = mInstance.getContext();
        mSubtitleController = new SubtitleController(context);
        mSubtitleController.registerRenderer(new ClosedCaptionRenderer(context));
        mSubtitleController.registerRenderer(new Cea708CaptionRenderer(context));
        mSubtitleController.setAnchor((SubtitleController.Anchor) mSubtitleAnchorView);
        // we don't set the target state here either, but preserve the
        // target state that was there before.
        mCurrentState = STATE_PREPARING;
        mMediaSession.prepare();
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, "Unable to open content: " + mMediaItem, ex);
        mCurrentState = STATE_ERROR;
        mTargetState = STATE_ERROR;
        mMediaPlayer2Callback.onError(mMediaPlayer, mMediaItem, MediaPlayer2.MEDIA_ERROR_UNKNOWN, MediaPlayer2.MEDIA_ERROR_IO);
    }
}
#method_after
void openVideo() {
    if (DEBUG) {
        Log.d(TAG, "openVideo()");
    }
    if (mMediaItem != null) {
        resetPlayer();
        if (isRemotePlayback()) {
            mRoutePlayer.setMediaItem(mMediaItem);
            return;
        } else {
            if (mMediaPlayer != null) {
                // TODO: Remove once b/110811730 is fixed.
                mMediaPlayer.setMediaItem(mMediaItem);
            }
        }
    }
    try {
        if (mMediaPlayer == null) {
            mMediaPlayer = MediaPlayer2.create(mInstance.getContext());
            mVideoView2Player = new VideoView2Player(mMediaPlayer);
        }
        mSurfaceView.setMediaPlayer(mMediaPlayer);
        mTextureView.setMediaPlayer(mMediaPlayer);
        if (!mCurrentView.assignSurfaceToMediaPlayer(mMediaPlayer)) {
            Log.w(TAG, "failed to assign surface");
        }
        mMediaPlayer.setEventCallback(mCallbackExecutor, mMediaPlayer2Callback);
        mMediaPlayer.setAudioAttributes(mAudioAttributes);
        if (mMediaSession == null) {
            final Context context = mInstance.getContext();
            mMediaSession = new MediaSession2.Builder(context).setPlayer(mVideoView2Player).setId("VideoView2_" + mInstance.toString()).setSessionCallback(mCallbackExecutor, new MediaSessionCallback()).build();
        } else {
            mMediaSession.updatePlayerConnector(mVideoView2Player, mMediaSession.getPlaylistAgent());
        }
        mMediaSession.setPlaylist(mPlayList, null);
        final Context context = mInstance.getContext();
        mSubtitleController = new SubtitleController(context);
        mSubtitleController.registerRenderer(new ClosedCaptionRenderer(context));
        mSubtitleController.registerRenderer(new Cea708CaptionRenderer(context));
        mSubtitleController.setAnchor((SubtitleController.Anchor) mSubtitleAnchorView);
        // we don't set the target state here either, but preserve the
        // target state that was there before.
        mCurrentState = STATE_PREPARING;
        mMediaSession.prepare();
    } catch (IllegalArgumentException ex) {
        Log.w(TAG, "Unable to open content: " + mMediaItem, ex);
        mCurrentState = STATE_ERROR;
        mTargetState = STATE_ERROR;
        mMediaPlayer2Callback.onError(mMediaPlayer, mMediaItem, MediaPlayer2.MEDIA_ERROR_UNKNOWN, MediaPlayer2.MEDIA_ERROR_IO);
    }
}
#end_block

#method_before
public static MediaItem2 createMediaItemWithMetadata() {
    return new FileMediaItem2.Builder(new FileDescriptor(), createMetadata()).setFlags(MediaItem2.FLAG_PLAYABLE).build();
}
#method_after
public static MediaItem2 createMediaItemWithMetadata() {
    return new FileMediaItem2.Builder(new FileDescriptor()).setMetadata(createMetadata()).build();
}
#end_block

#method_before
public static List<MediaItem2> playlistFromParcelableList(List<Parcelable> parcelables, boolean createItem) {
    if (parcelables == null) {
        return null;
    }
    List<MediaItem2> result = new ArrayList<>();
    if (createItem) {
        for (Parcelable itemBundle : parcelables) {
            MediaItem2 item = MediaItem2.fromBundle((Bundle) itemBundle);
            result.add(new FileMediaItem2.Builder(new FileDescriptor(), item.getMetadata()).setFlags(item.getFlags()).setMediaId(item.getMediaId()).build());
        }
    } else {
        for (Parcelable itemBundle : parcelables) {
            result.add(MediaItem2.fromBundle((Bundle) itemBundle));
        }
    }
    return result;
}
#method_after
public static List<MediaItem2> playlistFromParcelableList(List<Parcelable> parcelables, boolean createItem) {
    if (parcelables == null) {
        return null;
    }
    List<MediaItem2> result = new ArrayList<>();
    if (createItem) {
        for (Parcelable itemBundle : parcelables) {
            MediaItem2 item = MediaItem2.fromBundle((Bundle) itemBundle);
            result.add(new FileMediaItem2.Builder(new FileDescriptor()).setMetadata(item.getMetadata()).setMediaId(item.getMediaId()).build());
        }
    } else {
        for (Parcelable itemBundle : parcelables) {
            result.add(MediaItem2.fromBundle((Bundle) itemBundle));
        }
    }
    return result;
}
#end_block

#method_before
public static List<MediaItem2> createPlaylist(int size) {
    final List<MediaItem2> list = new ArrayList<>();
    String caller = Thread.currentThread().getStackTrace()[3].getMethodName();
    for (int i = 0; i < size; i++) {
        MediaItem2 item = new FileMediaItem2.Builder(new FileDescriptor()).setFlags(MediaItem2.FLAG_PLAYABLE).setMediaId(caller + "_item_" + (size + 1)).build();
        list.add(item);
    }
    return list;
}
#method_after
public static List<MediaItem2> createPlaylist(int size) {
    final List<MediaItem2> list = new ArrayList<>();
    String caller = Thread.currentThread().getStackTrace()[3].getMethodName();
    for (int i = 0; i < size; i++) {
        MediaItem2 item = new FileMediaItem2.Builder(new FileDescriptor()).setMediaId(caller + "_item_" + (size + 1)).build();
        list.add(item);
    }
    return list;
}
#end_block

#method_before
public static MediaItem2 createMediaItemWithMetadata() {
    return new FileMediaItem2.Builder(new FileDescriptor(), createMetadata()).setFlags(MediaItem2.FLAG_PLAYABLE).build();
}
#method_after
public static MediaItem2 createMediaItemWithMetadata() {
    return new FileMediaItem2.Builder(new FileDescriptor()).setMetadata(createMetadata()).build();
}
#end_block

#method_before
public void onBufferingStateChanged(@NonNull SessionPlayer2 player, @Nullable MediaItem2 desc, @BuffState int buffState) {
}
#method_after
public void onBufferingStateChanged(@NonNull SessionPlayer2 player, @Nullable MediaItem2 item, @BuffState int buffState) {
}
#end_block

#method_before
@Before
@Override
public void setUp() throws Exception {
    super.setUp();
    mPlayer = new MockPlayer(0);
    mMockAgent = new MockPlaylistAgent();
    mSession = new MediaSession2.Builder(mContext).setPlayer(mPlayer).setPlaylistAgent(mMockAgent).setSessionCallback(sHandlerExecutor, new SessionCallback() {

        @Override
        public SessionCommandGroup2 onConnect(MediaSession2 session, ControllerInfo controller) {
            if (Process.myUid() == controller.getUid()) {
                return super.onConnect(session, controller);
            }
            return null;
        }
    }).build();
}
#method_after
@Before
@Override
public void setUp() throws Exception {
    super.setUp();
    mPlayer = new MockPlayer(0);
    mMockAgent = new MockPlaylistAgent();
    mSession = new MediaSession2.Builder(mContext).setId(TAG).setPlayer(mPlayer).setPlaylistAgent(mMockAgent).setSessionCallback(sHandlerExecutor, new SessionCallback() {

        @Override
        public SessionCommandGroup2 onConnect(MediaSession2 session, ControllerInfo controller) {
            if (Process.myUid() == controller.getUid()) {
                return super.onConnect(session, controller);
            }
            return null;
        }
    }).build();
}
#end_block

#method_before
@Test
public void testConnection_sessionRejects() throws InterruptedException {
    prepareLooper();
    RemoteMediaSession2 session2 = new RemoteMediaSession2(TEST_CONTROLLER_CALLBACK_SESSION_REJECTS, mContext);
    MediaController2 controller = createController(session2.getToken(), false, /* waitForConnect */
    null);
    assertNotNull(controller);
    waitForConnect(controller, false);
    waitForDisconnect(controller, true);
}
#method_after
@Test
public void testConnection_sessionRejects() throws InterruptedException {
    prepareLooper();
    RemoteMediaSession2 session2 = new RemoteMediaSession2(TEST_CONTROLLER_CALLBACK_SESSION_REJECTS, mContext);
    MediaController2 controller = createController(session2.getToken(), false, /* waitForConnect */
    null);
    assertNotNull(controller);
    waitForConnect(controller, false);
    waitForDisconnect(controller, true);
    session2.cleanUp();
}
#end_block

#method_before
@Override
public void setPlaylistWithDummyItem(String sessionId, List<Bundle> playlist) throws RemoteException {
    MediaSession2 session2 = mSession2Map.get(sessionId);
    MockPlaylistAgent agent = (MockPlaylistAgent) session2.getPlaylistAgent();
    List<MediaItem2> list = new ArrayList<>();
    for (Bundle bundle : playlist) {
        MediaItem2 item = MediaItem2.fromBundle(bundle);
        list.add(new FileMediaItem2.Builder(new FileDescriptor(), item.getMetadata()).setMediaId(item.getMediaId()).build());
    }
    agent.mPlaylist = list;
}
#method_after
@Override
public void setPlaylistWithDummyItem(String sessionId, List<Bundle> playlist) throws RemoteException {
    MediaSession2 session2 = mSession2Map.get(sessionId);
    MockPlaylistAgent agent = (MockPlaylistAgent) session2.getPlaylistAgent();
    List<MediaItem2> list = new ArrayList<>();
    for (Bundle bundle : playlist) {
        MediaItem2 item = MediaItem2.fromBundle(bundle);
        list.add(new FileMediaItem2.Builder(new FileDescriptor()).setMetadata(item.getMetadata()).setMediaId(item.getMediaId()).build());
    }
    agent.mPlaylist = list;
}
#end_block

#method_before
@Before
@Override
public void setUp() throws Exception {
    super.setUp();
    final Intent sessionActivity = new Intent(mContext, MockActivity.class);
    // Create this test specific MediaSession2 to use our own Handler.
    mIntent = PendingIntent.getActivity(mContext, 0, sessionActivity, 0);
    mPlayer = new MockPlayerConnector(1);
    mMockAgent = new MockPlaylistAgent();
    mSession = new MediaSession2.Builder(mContext).setPlayer(mPlayer).setPlaylistAgent(mMockAgent).setSessionCallback(sHandlerExecutor, new SessionCallback() {

        @Override
        public SessionCommandGroup2 onConnect(MediaSession2 session, ControllerInfo controller) {
            if (EXPECTED_CONTROLLER_PACKAGE_NAME.equals(controller.getPackageName())) {
                return super.onConnect(session, controller);
            }
            return null;
        }
    }).setSessionActivity(mIntent).setId(TAG).build();
    mController = new RemoteMediaControllerCompat(mContext, mSession.getSessionCompat().getSessionToken(), true);
    mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
}
#method_after
@Before
@Override
public void setUp() throws Exception {
    super.setUp();
    final Intent sessionActivity = new Intent(mContext, MockActivity.class);
    // Create this test specific MediaSession2 to use our own Handler.
    mIntent = PendingIntent.getActivity(mContext, 0, sessionActivity, 0);
    mPlayer = new MockPlayerConnector(1);
    mMockAgent = new MockPlaylistAgent();
    mSession = new MediaSession2.Builder(mContext).setId(TAG).setPlayer(mPlayer).setPlaylistAgent(mMockAgent).setSessionCallback(sHandlerExecutor, new SessionCallback() {

        @Override
        public SessionCommandGroup2 onConnect(MediaSession2 session, ControllerInfo controller) {
            if (EXPECTED_CONTROLLER_PACKAGE_NAME.equals(controller.getPackageName())) {
                return super.onConnect(session, controller);
            }
            return null;
        }
    }).setSessionActivity(mIntent).setId(TAG).build();
    mController = new RemoteMediaControllerCompat(mContext, mSession.getSessionCompat().getSessionToken(), true);
    mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
}
#end_block

#method_before
@Override
public void close() {
    synchronized (mLock) {
        if (mPlayer == null) {
            return;
        }
        mAudioFocusHandler.close();
        mPlayer.unregisterPlayerEventCallback(mPlayerEventCallback);
        mPlayer = null;
        mSessionCompat.release();
        mCallback.onSessionClosed(mInstance);
        notifyToAllControllers(new NotifyRunnable() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onDisconnected();
            }
        });
        mHandler.removeCallbacksAndMessages(null);
        if (mHandlerThread.isAlive()) {
            if (Build.VERSION.SDK_INT >= 18) {
                mHandlerThread.quitSafely();
            } else {
                mHandlerThread.quit();
            }
        }
    }
}
#method_after
@Override
public void close() {
    synchronized (mLock) {
        if (mPlayer == null) {
            return;
        }
        synchronized (MediaSession2ImplBase.class) {
            SESSION_ID_LIST.remove(mSessionId);
        }
        mAudioFocusHandler.close();
        mPlayer.unregisterPlayerEventCallback(mPlayerEventCallback);
        mPlayer = null;
        mSessionCompat.release();
        mCallback.onSessionClosed(mInstance);
        notifyToAllControllers(new NotifyRunnable() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onDisconnected();
            }
        });
        mHandler.removeCallbacksAndMessages(null);
        if (mHandlerThread.isAlive()) {
            if (Build.VERSION.SDK_INT >= 18) {
                mHandlerThread.quitSafely();
            } else {
                mHandlerThread.quit();
            }
        }
    }
}
#end_block

#method_before
@Before
public void setup() throws Throwable {
    mContext = InstrumentationRegistry.getTargetContext();
    mMainHandlerExecutor = MainHandlerExecutor.getExecutor(mContext);
    mInstrumentation = InstrumentationRegistry.getInstrumentation();
    mActivity = mActivityRule.getActivity();
    mVideoView = mActivity.findViewById(R.id.videoview);
    mFileSchemeUri = Uri.parse("android.resource://" + mContext.getPackageName() + "/" + R.raw.test_file_scheme_video);
    mHttpsSchemeUri = Uri.parse(mContext.getResources().getString(R.string.test_https_scheme_video));
    mHttpSchemeUri = Uri.parse(mContext.getResources().getString(R.string.test_http_scheme_video));
    mFileSchemeMediaItem = createTestMediaItem2(mFileSchemeUri);
    mHttpsSchemeMediaItem = createTestMediaItem2(mHttpsSchemeUri);
    mHttpSchemeMediaItem = createTestMediaItem2(mHttpSchemeUri);
    setKeepScreenOn();
    checkAttachedToWindow();
}
#method_after
@Before
public void setup() throws Throwable {
    mContext = InstrumentationRegistry.getTargetContext();
    mMainHandlerExecutor = ContextCompat.getMainExecutor(mContext);
    mInstrumentation = InstrumentationRegistry.getInstrumentation();
    mActivity = mActivityRule.getActivity();
    mVideoView = mActivity.findViewById(R.id.videoview);
    mFileSchemeUri = Uri.parse("android.resource://" + mContext.getPackageName() + "/" + R.raw.test_file_scheme_video);
    mHttpsSchemeUri = Uri.parse(mContext.getResources().getString(R.string.test_https_scheme_video));
    mHttpSchemeUri = Uri.parse(mContext.getResources().getString(R.string.test_http_scheme_video));
    mFileSchemeMediaItem = createTestMediaItem2(mFileSchemeUri);
    mHttpsSchemeMediaItem = createTestMediaItem2(mHttpsSchemeUri);
    mHttpSchemeMediaItem = createTestMediaItem2(mHttpSchemeUri);
    setKeepScreenOn();
    checkAttachedToWindow();
}
#end_block

#method_before
private MediaItem2 createTestMediaItem2(Uri uri) {
    return new UriMediaItem2.Builder(mVideoView.getContext(), uri).setFlags(MediaItem2.FLAG_PLAYABLE).build();
}
#method_after
private MediaItem2 createTestMediaItem2(Uri uri) {
    return new UriMediaItem2.Builder(mVideoView.getContext(), uri).build();
}
#end_block

#method_before
private void setupPlayer() throws Exception {
    final Monitor onPauseCalled = new Monitor();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_PAUSE) {
                onPauseCalled.signal();
            } else if (what == MediaPlayer2.CALL_COMPLETED_PREPARE) {
                mOnPrepareCalled.signal();
            } else if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                mOnPlayCalled.signal();
            }
        }

        @Override
        public void onError(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    if (mTestState == PLAYER_STATE_ERROR) {
        DataSourceCallback2 invalidDataSource = new DataSourceCallback2() {

            @Override
            public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
                return -1;
            }

            @Override
            public long getSize() throws IOException {
                // Unknown size
                return -1;
            }

            @Override
            public void close() throws IOException {
            }
        };
        mOnErrorCalled.reset();
        mPlayer.setDataSource(new CallbackMediaItem2.Builder(invalidDataSource).build());
        mPlayer.prepare();
        mOnErrorCalled.waitForSignal(1000);
        assertEquals(PLAYER_STATE_ERROR, mPlayer.getState());
        return;
    }
    if (mTestState == MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE) {
        mTestState = PLAYER_STATE_IDLE;
        return;
    }
    if (!checkLoadResource(R.raw.testvideo_with_2_subtitle_tracks)) {
        fail();
    }
    if (mTestOpertation == sSkipToNextOperation) {
        MediaItem2 item = createDataSourceDesc(R.raw.testvideo);
        mPlayer.setNextDataSource(item);
    }
    assertEquals(PLAYER_STATE_IDLE, mPlayer.getState());
    if (mTestState == PLAYER_STATE_IDLE) {
        return;
    }
    mPlayer.prepare();
    mOnPrepareCalled.waitForSignal(1000);
    assertEquals(PLAYER_STATE_PREPARED, mPlayer.getState());
    if (mTestOpertation == sDeselectTrackOperation) {
        mPlayer.selectTrack(1);
    }
    if (mTestState == PLAYER_STATE_PREPARED) {
        return;
    }
    mPlayer.play();
    mOnPlayCalled.waitForSignal(1000);
    assertEquals(PLAYER_STATE_PLAYING, mPlayer.getState());
    if (mTestState == PLAYER_STATE_PLAYING) {
        return;
    }
    mPlayer.pause();
    onPauseCalled.waitForSignal(1000);
    assertEquals(PLAYER_STATE_PAUSED, mPlayer.getState());
    if (mTestState == PLAYER_STATE_PAUSED) {
        return;
    }
    fail();
}
#method_after
private void setupPlayer() throws Exception {
    final Monitor onPauseCalled = new Monitor();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onCallCompleted(MediaPlayer2 mp, MediaItem2 item, int what, int status) {
            if (what == MediaPlayer2.CALL_COMPLETED_PAUSE) {
                onPauseCalled.signal();
            } else if (what == MediaPlayer2.CALL_COMPLETED_PREPARE) {
                mOnPrepareCalled.signal();
            } else if (what == MediaPlayer2.CALL_COMPLETED_PLAY) {
                mOnPlayCalled.signal();
            }
        }

        @Override
        public void onError(MediaPlayer2 mp, MediaItem2 item, int what, int extra) {
            mOnErrorCalled.signal();
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    if (mTestState == PLAYER_STATE_ERROR) {
        DataSourceCallback2 invalidDataSource = new DataSourceCallback2() {

            @Override
            public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
                return -1;
            }

            @Override
            public long getSize() throws IOException {
                // Unknown size
                return -1;
            }

            @Override
            public void close() throws IOException {
            }
        };
        mOnErrorCalled.reset();
        mPlayer.setMediaItem(new CallbackMediaItem2.Builder(invalidDataSource).build());
        mPlayer.prepare();
        mOnErrorCalled.waitForSignal(1000);
        assertEquals(PLAYER_STATE_ERROR, mPlayer.getState());
        return;
    }
    if (mTestState == MEDIAPLAYER2_STATE_IDLE_NO_DATA_SOURCE) {
        mTestState = PLAYER_STATE_IDLE;
        return;
    }
    if (!checkLoadResource(R.raw.testvideo_with_2_subtitle_tracks)) {
        fail();
    }
    if (mTestOpertation == sSkipToNextOperation) {
        MediaItem2 item = createDataSourceDesc(R.raw.testvideo);
        mPlayer.setNextMediaItem(item);
    }
    assertEquals(PLAYER_STATE_IDLE, mPlayer.getState());
    if (mTestState == PLAYER_STATE_IDLE) {
        return;
    }
    mPlayer.prepare();
    mOnPrepareCalled.waitForSignal(1000);
    assertEquals(PLAYER_STATE_PREPARED, mPlayer.getState());
    if (mTestOpertation == sDeselectTrackOperation) {
        mPlayer.selectTrack(1);
    }
    if (mTestState == PLAYER_STATE_PREPARED) {
        return;
    }
    mPlayer.play();
    mOnPlayCalled.waitForSignal(1000);
    assertEquals(PLAYER_STATE_PLAYING, mPlayer.getState());
    if (mTestState == PLAYER_STATE_PLAYING) {
        return;
    }
    mPlayer.pause();
    onPauseCalled.waitForSignal(1000);
    assertEquals(PLAYER_STATE_PAUSED, mPlayer.getState());
    if (mTestState == PLAYER_STATE_PAUSED) {
        return;
    }
    fail();
}
#end_block

#method_before
private MediaItem2 createMediaItem(String mediaId) {
    Context context = MockMediaLibraryService2.this;
    return new MediaItem2.Builder().setFlags(0).setMediaId(mediaId).setMetadata(new MediaMetadata2.Builder().putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, mediaId).build()).build();
}
#method_after
private MediaItem2 createMediaItem(String mediaId) {
    Context context = MockMediaLibraryService2.this;
    return new MediaItem2.Builder(MediaItem2.FLAG_PLAYABLE).setMediaId(mediaId).setMetadata(new MediaMetadata2.Builder().putString(MediaMetadata2.METADATA_KEY_MEDIA_ID, mediaId).build()).build();
}
#end_block

#method_before
private MediaItem2 createMediaItem(int key) {
    return new MediaItem2.Builder().setMediaId("TEST_MEDIA_" + key).build();
}
#method_after
private MediaItem2 createMediaItem(int key) {
    return new MediaItem2.Builder(MediaItem2.FLAG_PLAYABLE).setMediaId("TEST_MEDIA_" + key).build();
}
#end_block

#method_before
@Before
public void setup() throws Throwable {
    mContext = InstrumentationRegistry.getTargetContext();
    mMainHandlerExecutor = MainHandlerExecutor.getExecutor(mContext);
    mInstrumentation = InstrumentationRegistry.getInstrumentation();
    mActivity = mActivityRule.getActivity();
    mVideoView = mActivity.findViewById(R.id.videoview);
    mMediaItem = createTestMediaItem2();
    setKeepScreenOn();
    checkAttachedToWindow();
    mControllerCallback = mock(MediaController2.ControllerCallback.class);
    mController = new MediaController2(mVideoView.getContext(), mVideoView.getMediaSessionToken2(), mMainHandlerExecutor, mControllerCallback);
}
#method_after
@Before
public void setup() throws Throwable {
    mContext = InstrumentationRegistry.getTargetContext();
    mMainHandlerExecutor = ContextCompat.getMainExecutor(mContext);
    mInstrumentation = InstrumentationRegistry.getInstrumentation();
    mActivity = mActivityRule.getActivity();
    mVideoView = mActivity.findViewById(R.id.videoview);
    mMediaItem = createTestMediaItem2();
    setKeepScreenOn();
    checkAttachedToWindow();
    mControllerCallback = mock(MediaController2.ControllerCallback.class);
    mController = new MediaController2(mVideoView.getContext(), mVideoView.getMediaSessionToken2(), mMainHandlerExecutor, mControllerCallback);
}
#end_block

#method_before
@Test
public void testPlayVideoWithMediaItemFromFileDescriptor() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testPlayVideoWithMediaItemFromFileDescriptor(): " + "codec is not supported");
        return;
    }
    AssetFileDescriptor afd = mContext.getResources().openRawResourceFd(R.raw.testvideo_with_2_subtitle_tracks);
    final MediaItem2 item = new FileMediaItem2.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).setFlags(MediaItem2.FLAG_PLAYABLE).build();
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(item);
        }
    });
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onConnected(any(MediaController2.class), any(SessionCommandGroup2.class));
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onPlayerStateChanged(any(MediaController2.class), eq(MediaPlayerConnector.PLAYER_STATE_PAUSED));
    mController.play();
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onPlayerStateChanged(any(MediaController2.class), eq(MediaPlayerConnector.PLAYER_STATE_PLAYING));
}
#method_after
@Test
public void testPlayVideoWithMediaItemFromFileDescriptor() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testPlayVideoWithMediaItemFromFileDescriptor(): " + "codec is not supported");
        return;
    }
    AssetFileDescriptor afd = mContext.getResources().openRawResourceFd(R.raw.testvideo_with_2_subtitle_tracks);
    final MediaItem2 item = new FileMediaItem2.Builder(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength()).build();
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(item);
        }
    });
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onConnected(any(MediaController2.class), any(SessionCommandGroup2.class));
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onPlayerStateChanged(any(MediaController2.class), eq(MediaPlayerConnector.PLAYER_STATE_PAUSED));
    mController.play();
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onPlayerStateChanged(any(MediaController2.class), eq(MediaPlayerConnector.PLAYER_STATE_PLAYING));
}
#end_block

#method_before
private MediaItem2 createTestMediaItem2() {
    Uri testVideoUri = Uri.parse("android.resource://" + mContext.getPackageName() + "/" + R.raw.testvideo_with_2_subtitle_tracks);
    return new UriMediaItem2.Builder(mVideoView.getContext(), testVideoUri).setFlags(MediaItem2.FLAG_PLAYABLE).build();
}
#method_after
private MediaItem2 createTestMediaItem2() {
    Uri testVideoUri = Uri.parse("android.resource://" + mContext.getPackageName() + "/" + R.raw.testvideo_with_2_subtitle_tracks);
    return new UriMediaItem2.Builder(mVideoView.getContext(), testVideoUri).build();
}
#end_block

#method_before
public static MediaItem2 convertToMediaItem2(MediaItem item) {
    if (item == null || item.getMediaId() == null) {
        return null;
    }
    MediaMetadata2 metadata2 = convertToMediaMetadata2(item.getDescription());
    return new MediaItem2.Builder().setMediaId(item.getMediaId()).setMetadata(metadata2).setFlags(item.getFlags()).build();
}
#method_after
public static MediaItem2 convertToMediaItem2(MediaItem item) {
    if (item == null || item.getMediaId() == null) {
        return null;
    }
    MediaMetadata2 metadata2 = convertToMediaMetadata2(item.getDescription());
    return new MediaItem2.Builder(item.getFlags()).setMediaId(item.getMediaId()).setMetadata(metadata2).build();
}
#end_block

#method_before
public static MediaItem2 convertToMediaItem2(@NonNull QueueItem item) {
    if (item == null) {
        throw new IllegalArgumentException("item shouldn't be null");
    }
    // descriptionCompat cannot be null
    MediaDescriptionCompat descriptionCompat = item.getDescription();
    MediaMetadata2 metadata2 = convertToMediaMetadata2(descriptionCompat);
    return new MediaItem2.Builder().setMetadata(metadata2).setFlags(FLAG_PLAYABLE).setUuid(createUuidByQueueIdAndMediaId(item.getQueueId(), descriptionCompat.getMediaId())).build();
}
#method_after
public static MediaItem2 convertToMediaItem2(@NonNull QueueItem item) {
    if (item == null) {
        throw new IllegalArgumentException("item shouldn't be null");
    }
    // descriptionCompat cannot be null
    MediaDescriptionCompat descriptionCompat = item.getDescription();
    MediaMetadata2 metadata2 = convertToMediaMetadata2(descriptionCompat);
    return new MediaItem2.Builder(FLAG_PLAYABLE).setMetadata(metadata2).setUuid(createUuidByQueueIdAndMediaId(item.getQueueId(), descriptionCompat.getMediaId())).build();
}
#end_block

#method_before
public static MediaItem2 convertToMediaItem2(MediaMetadataCompat metadataCompat) {
    MediaMetadata2 metadata2 = convertToMediaMetadata2(metadataCompat);
    if (metadata2 == null || metadata2.getMediaId() == null) {
        return null;
    }
    return new MediaItem2.Builder().setFlags(FLAG_PLAYABLE).setMetadata(metadata2).build();
}
#method_after
public static MediaItem2 convertToMediaItem2(MediaMetadataCompat metadataCompat) {
    MediaMetadata2 metadata2 = convertToMediaMetadata2(metadataCompat);
    if (metadata2 == null || metadata2.getMediaId() == null) {
        return null;
    }
    return new MediaItem2.Builder(FLAG_PLAYABLE).setMetadata(metadata2).build();
}
#end_block

#method_before
public static MediaItem2 convertToMediaItem2(MediaDescriptionCompat descriptionCompat) {
    MediaMetadata2 metadata2 = convertToMediaMetadata2(descriptionCompat);
    if (metadata2 == null || metadata2.getMediaId() == null) {
        return null;
    }
    return new MediaItem2.Builder().setFlags(FLAG_PLAYABLE).setMetadata(metadata2).build();
}
#method_after
public static MediaItem2 convertToMediaItem2(MediaDescriptionCompat descriptionCompat) {
    MediaMetadata2 metadata2 = convertToMediaMetadata2(descriptionCompat);
    if (metadata2 == null || metadata2.getMediaId() == null) {
        return null;
    }
    return new MediaItem2.Builder(FLAG_PLAYABLE).setMetadata(metadata2).build();
}
#end_block

#method_before
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
@SuppressWarnings("ClassNewInstance")
public static Worker workerFromClassName(@NonNull String workerClassName, @NonNull Context context, @NonNull WorkerParameters params) {
    try {
        Class<?> clazz = Class.forName(workerClassName);
        Worker worker;
        try {
            Constructor<?> constructor = clazz.getDeclaredConstructor(Context.class, WorkerParameters.class);
            worker = (Worker) constructor.newInstance(context, params);
        } catch (NoSuchMethodException e) {
            worker = (Worker) clazz.newInstance();
            Method internalInitMethod = NonBlockingWorker.class.getDeclaredMethod("internalInit", Context.class, WorkerParameters.class);
            internalInitMethod.setAccessible(true);
            internalInitMethod.invoke(worker, context.getApplicationContext(), params);
        }
        return worker;
    } catch (Exception e) {
        Logger.error(TAG, "Trouble instantiating " + workerClassName, e);
    }
    return null;
}
#method_after
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
@SuppressWarnings("ClassNewInstance")
public static Worker workerFromClassName(@NonNull String workerClassName, @NonNull Context context, @NonNull WorkerParameters params) {
    try {
        Class<?> clazz = Class.forName(workerClassName);
        Worker worker;
        try {
            Constructor<?> constructor = clazz.getDeclaredConstructor(Context.class, WorkerParameters.class);
            worker = (Worker) constructor.newInstance(context.getApplicationContext(), params);
        } catch (NoSuchMethodException e) {
            worker = (Worker) clazz.newInstance();
            Method internalInitMethod = NonBlockingWorker.class.getDeclaredMethod("internalInit", Context.class, WorkerParameters.class);
            internalInitMethod.setAccessible(true);
            internalInitMethod.invoke(worker, context.getApplicationContext(), params);
        }
        return worker;
    } catch (Exception e) {
        Logger.error(TAG, "Trouble instantiating " + workerClassName, e);
    }
    return null;
}
#end_block

#method_before
@Override
final public boolean equals(Object o) {
    return super.equals(o);
}
#method_after
@Override
public final boolean equals(@Nullable Object o) {
    return super.equals(o);
}
#end_block

#method_before
@Override
final public int hashCode() {
    return super.hashCode();
}
#method_after
@Override
public final int hashCode() {
    return super.hashCode();
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder(128);
    DebugUtils.buildShortClassTag(this, sb);
    if (mIndex >= 0) {
        sb.append(" #");
        sb.append(mIndex);
    }
    if (mFragmentId != 0) {
        sb.append(" id=0x");
        sb.append(Integer.toHexString(mFragmentId));
    }
    if (mTag != null) {
        sb.append(" ");
        sb.append(mTag);
    }
    sb.append('}');
    return sb.toString();
}
#method_after
@Override
@SuppressLint("UnknownNullness")
public String toString() {
    StringBuilder sb = new StringBuilder(128);
    DebugUtils.buildShortClassTag(this, sb);
    if (mIndex >= 0) {
        sb.append(" #");
        sb.append(mIndex);
    }
    if (mFragmentId != 0) {
        sb.append(" id=0x");
        sb.append(Integer.toHexString(mFragmentId));
    }
    if (mTag != null) {
        sb.append(" ");
        sb.append(mTag);
    }
    sb.append('}');
    return sb.toString();
}
#end_block

#method_before
@Override
protected void onNewIntent(@Nullable Intent intent) {
    super.onNewIntent(intent);
    mFragments.noteStateNotSaved();
}
#method_after
@Override
protected void onNewIntent(@SuppressLint("UnknownNullness") Intent intent) {
    super.onNewIntent(intent);
    mFragments.noteStateNotSaved();
}
#end_block

#method_before
@Test
public void testDefaultButton_isAnimated() {
    // Given an ACCB with the theme's mButton drawable
    final AppCompatCheckBoxSpy checkBox = mContainer.findViewById(R.id.checkbox_button_compat);
    boolean isAnimated = false;
    // Then this drawable should be an animated-selector
    final Drawable button = checkBox.mButton;
    if (Build.VERSION.SDK_INT >= 21) {
        isAnimated = button instanceof AnimatedStateListDrawableCompat || button instanceof AnimatedStateListDrawable;
    } else {
        isAnimated = button instanceof AnimatedStateListDrawableCompat;
    }
    assertTrue(isAnimated);
}
#method_after
@Test
public void testDefaultButton_isAnimated() {
    // Given an ACCB with the theme's button drawable
    final AppCompatCheckBoxSpy checkBox = mContainer.findViewById(R.id.checkbox_button_compat);
    final Drawable button = checkBox.mButton;
    // Then this drawable should be an animated-selector
    assertTrue(button instanceof AnimatedStateListDrawableCompat || button instanceof AnimatedStateListDrawable);
}
#end_block

#method_before
@Test
public void testDefaultButton_isAnimated() {
    // Given an ACRB with the theme's mButton drawable
    final AppCompatRadioButtonSpy radio = mContainer.findViewById(R.id.radiobutton_button_compat);
    boolean isAnimated = false;
    // Then this drawable should be an animated-selector
    final Drawable button = radio.mButton;
    if (Build.VERSION.SDK_INT >= 21) {
        isAnimated = button instanceof AnimatedStateListDrawableCompat || button instanceof AnimatedStateListDrawable;
    } else {
        isAnimated = button instanceof AnimatedStateListDrawableCompat;
    }
    assertTrue(isAnimated);
}
#method_after
@Test
public void testDefaultButton_isAnimated() {
    // Given an ACRB with the theme's button drawable
    final AppCompatRadioButtonSpy radio = mContainer.findViewById(R.id.radiobutton_button_compat);
    final Drawable button = radio.mButton;
    // Then this drawable should be an animated-selector
    assertTrue(button instanceof AnimatedStateListDrawableCompat || button instanceof AnimatedStateListDrawable);
}
#end_block

#method_before
@NonNull
public Request build() {
    return new Request(mText, mStartIndex, mEndIndex, mDefaultLocales, mReferenceTime);
}
#method_after
@NonNull
public TextClassification build() {
    return new TextClassification(mText, mActions, new EntityConfidence(mEntityConfidence), mId);
}
#end_block

#method_before
@NonNull
public TextLinks build() {
    return new TextLinks(mFullText, mLinks);
}
#method_after
@NonNull
public Request build() {
    return new Request(mText, mDefaultLocales, mEntityConfig, mReferenceTime);
}
#end_block

#method_before
@Override
public void onAddMemberRoute(String routeId) {
    DynamicRouteDescriptor dynamicDescriptor = mDynamicRouteDescriptors.get(routeId);
    if (dynamicDescriptor == null) {
        Log.d(TAG, "onAddMemberRoute: Ignored for routeId: " + routeId);
        return;
    }
    MediaRouteDescriptor routeDescriptor = dynamicDescriptor.getRouteDescriptor();
    DynamicRouteDescriptor.Builder builder = new DynamicRouteDescriptor.Builder(dynamicDescriptor).setSelectionState(DynamicRouteDescriptor.SELECTED);
    // Make fixed volume route not unselectable.
    if (routeDescriptor.getVolumeHandling() == MediaRouter.RouteInfo.PLAYBACK_VOLUME_FIXED) {
        builder.setIsUnselectable(false);
    } else {
        builder.setIsUnselectable(true);
    }
    mDynamicRouteDescriptors.put(routeId, builder.build());
    mMemberRouteIds.add(routeId);
    MediaRouteDescriptor groupDescriptor = new MediaRouteDescriptor.Builder(mRouteDescriptors.get(mRouteId)).addGroupMemberId(routeId).build();
    mRouteDescriptors.put(mRouteId, groupDescriptor);
    if (routeDescriptor.getDeviceType() == MediaRouter.RouteInfo.DEVICE_TYPE_TV) {
        // Make other TVs ungroupable, since only one TV can exist in dynamic group.
        updateGroupableRoutes(routeId, false);
    }
    publishRoutes();
    if (mListenerExecutor != null) {
        mListenerExecutor.execute(() -> mDynamicRoutesChangedListener.onRoutesChanged(SampleDynamicGroupRouteController.this, mDynamicRouteDescriptors.values()));
    }
}
#method_after
@Override
public void onAddMemberRoute(String routeId) {
    DynamicRouteDescriptor dynamicDescriptor = mDynamicRouteDescriptors.get(routeId);
    if (dynamicDescriptor == null) {
        Log.d(TAG, "onAddMemberRoute: Ignored for routeId: " + routeId);
        return;
    }
    MediaRouteDescriptor routeDescriptor = dynamicDescriptor.getRouteDescriptor();
    DynamicRouteDescriptor.Builder builder = new DynamicRouteDescriptor.Builder(dynamicDescriptor).setSelectionState(DynamicRouteDescriptor.SELECTED);
    // Make fixed volume route not unselectable.
    if (routeDescriptor.getVolumeHandling() == MediaRouter.RouteInfo.PLAYBACK_VOLUME_FIXED) {
        builder.setIsUnselectable(false);
    } else {
        builder.setIsUnselectable(true);
    }
    mDynamicRouteDescriptors.put(routeId, builder.build());
    mMemberRouteIds.add(routeId);
    MediaRouteDescriptor groupDescriptor = new MediaRouteDescriptor.Builder(mRouteDescriptors.get(mRouteId)).addGroupMemberId(routeId).build();
    mRouteDescriptors.put(mRouteId, groupDescriptor);
    if (routeDescriptor.getDeviceType() == MediaRouter.RouteInfo.DEVICE_TYPE_TV) {
        // Make other TVs ungroupable, since only one TV can exist in dynamic group.
        setOtherTvDevicesGroupable(false);
    }
    publishRoutes();
    if (mListenerExecutor != null) {
        mListenerExecutor.execute(() -> mDynamicRoutesChangedListener.onRoutesChanged(SampleDynamicGroupRouteController.this, mDynamicRouteDescriptors.values()));
    }
}
#end_block

#method_before
@Override
public void onRemoveMemberRoute(String routeId) {
    DynamicRouteDescriptor dynamicDescriptor = mDynamicRouteDescriptors.get(routeId);
    if (dynamicDescriptor == null || !dynamicDescriptor.isUnselectable() || !mMemberRouteIds.remove(routeId)) {
        Log.d(TAG, "onRemoveMemberRoute: Ignored for routeId: " + routeId);
        return;
    }
    MediaRouteDescriptor routeDescriptor = dynamicDescriptor.getRouteDescriptor();
    DynamicRouteDescriptor.Builder builder = new DynamicRouteDescriptor.Builder(dynamicDescriptor);
    builder.setSelectionState(DynamicRouteDescriptor.UNSELECTED);
    mDynamicRouteDescriptors.put(routeId, builder.build());
    MediaRouteDescriptor groupDescriptor = new MediaRouteDescriptor.Builder(mRouteDescriptors.get(mRouteId)).removeGroupMemberId(routeId).build();
    mRouteDescriptors.put(mRouteId, groupDescriptor);
    if (routeDescriptor.getDeviceType() == MediaRouter.RouteInfo.DEVICE_TYPE_TV) {
        // Revert other TV devices to groupable routes.
        updateGroupableRoutes(routeId, true);
    }
    publishRoutes();
    if (mListenerExecutor != null) {
        mListenerExecutor.execute(() -> mDynamicRoutesChangedListener.onRoutesChanged(SampleDynamicGroupRouteController.this, mDynamicRouteDescriptors.values()));
    }
}
#method_after
@Override
public void onRemoveMemberRoute(String routeId) {
    DynamicRouteDescriptor dynamicDescriptor = mDynamicRouteDescriptors.get(routeId);
    if (dynamicDescriptor == null || !dynamicDescriptor.isUnselectable() || !mMemberRouteIds.remove(routeId)) {
        Log.d(TAG, "onRemoveMemberRoute: Ignored for routeId: " + routeId);
        return;
    }
    MediaRouteDescriptor routeDescriptor = dynamicDescriptor.getRouteDescriptor();
    DynamicRouteDescriptor.Builder builder = new DynamicRouteDescriptor.Builder(dynamicDescriptor);
    builder.setSelectionState(DynamicRouteDescriptor.UNSELECTED);
    mDynamicRouteDescriptors.put(routeId, builder.build());
    MediaRouteDescriptor groupDescriptor = new MediaRouteDescriptor.Builder(mRouteDescriptors.get(mRouteId)).removeGroupMemberId(routeId).build();
    mRouteDescriptors.put(mRouteId, groupDescriptor);
    if (routeDescriptor.getDeviceType() == MediaRouter.RouteInfo.DEVICE_TYPE_TV) {
        // Revert other TV devices to groupable routes.
        setOtherTvDevicesGroupable(true);
    }
    publishRoutes();
    if (mListenerExecutor != null) {
        mListenerExecutor.execute(() -> mDynamicRoutesChangedListener.onRoutesChanged(SampleDynamicGroupRouteController.this, mDynamicRouteDescriptors.values()));
    }
}
#end_block

#method_before
@Test
public void setShowAsActionNever() throws Exception {
    final Context context = InstrumentationRegistry.getTargetContext();
    final ActionMenuItem item = new ActionMenuItem(context, Menu.NONE, Menu.NONE, 0, 0, "item");
    assertThat(item.requiresActionButton()).isTrue();
    assertThat(item.requiresOverflow()).isFalse();
    item.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
    assertThat(item.requiresActionButton()).isTrue();
    assertThat(item.requiresOverflow()).isFalse();
}
#method_after
@Test
public void setShowAsActionNever() throws Exception {
    final Context context = InstrumentationRegistry.getTargetContext();
    final ActionMenuItem item = new ActionMenuItem(context, Menu.NONE, Menu.NONE, 0, 0, "item");
    // ActionMenuItem always require action button and never require overflow irrespective of
    // the set showAsAction flag.
    assertThat(item.requiresActionButton()).isTrue();
    assertThat(item.requiresOverflow()).isFalse();
    item.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
    assertThat(item.requiresActionButton()).isTrue();
    assertThat(item.requiresOverflow()).isFalse();
}
#end_block

#method_before
@NonNull
public CommandButton build() {
    return new CommandButton(mCommand, mIconResId, mDisplayName, mExtras, mEnabled);
}
#method_after
@Override
@NonNull
public MediaSession2 build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = ContextCompat.getMainExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new SessionCallback() {
        };
    }
    return new MediaSession2(mContext, mId, mPlayer, mPlaylistAgent, mSessionActivity, mCallbackExecutor, mCallback);
}
#end_block

#method_before
@Test
public void testLightStatusBarIcons() throws Throwable {
    mNm = (NotificationManager) getInstrumentation().getContext().getSystemService(Context.NOTIFICATION_SERVICE);
    NotificationChannel channel1 = new NotificationChannel(NOTIFICATION_CHANNEL_ID, NOTIFICATION_CHANNEL_ID, NotificationManager.IMPORTANCE_LOW);
    mNm.createNotificationChannel(channel1);
    PackageManager pm = getInstrumentation().getContext().getPackageManager();
    if (pm.hasSystemFeature(PackageManager.FEATURE_WATCH) || pm.hasSystemFeature(PackageManager.FEATURE_TELEVISION) || pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK) || isRunningInVR()) {
        // No status bar on TVs, watches and when running in VR.
        return;
    }
    if (!ActivityManager.isHighEndGfx()) {
        // non-highEndGfx devices don't do colored system bars.
        return;
    }
    // post 10 notifications to ensure enough icons in the status bar
    for (int i = 0; i < 10; i++) {
        Notification.Builder noti1 = new Notification.Builder(getInstrumentation().getContext(), NOTIFICATION_CHANNEL_ID).setSmallIcon(R.drawable.ic_save).setChannelId(NOTIFICATION_CHANNEL_ID).setPriority(Notification.PRIORITY_LOW).setGroup(NOTIFICATION_GROUP_KEY);
        mNm.notify(NOTIFICATION_TAG, i, noti1.build());
    }
    requestLightBars(Color.RED);
    Thread.sleep(WAIT_TIME);
    Bitmap bitmap = takeStatusBarScreenshot(mActivityRule.getActivity());
    Stats s = evaluateLightBarBitmap(bitmap, Color.RED);
    assertLightStats(bitmap, s);
    mNm.cancelAll();
    mNm.deleteNotificationChannel(NOTIFICATION_CHANNEL_ID);
}
#method_after
@Test
public void testLightStatusBarIcons() throws Throwable {
    assumeHasColoredStatusBar();
    mNm = (NotificationManager) getInstrumentation().getContext().getSystemService(Context.NOTIFICATION_SERVICE);
    NotificationChannel channel1 = new NotificationChannel(NOTIFICATION_CHANNEL_ID, NOTIFICATION_CHANNEL_ID, NotificationManager.IMPORTANCE_LOW);
    mNm.createNotificationChannel(channel1);
    // post 10 notifications to ensure enough icons in the status bar
    for (int i = 0; i < 10; i++) {
        Notification.Builder noti1 = new Notification.Builder(getInstrumentation().getContext(), NOTIFICATION_CHANNEL_ID).setSmallIcon(R.drawable.ic_save).setChannelId(NOTIFICATION_CHANNEL_ID).setPriority(Notification.PRIORITY_LOW).setGroup(NOTIFICATION_GROUP_KEY);
        mNm.notify(NOTIFICATION_TAG, i, noti1.build());
    }
    Thread.sleep(WAIT_TIME);
    Bitmap beforeBitmap = takeStatusBarScreenshot(mActivityRule.getActivity());
    requestLightBars(Color.RED);
    Thread.sleep(WAIT_TIME);
    Bitmap bitmap = takeStatusBarScreenshot(mActivityRule.getActivity());
    Bitmap result = treatCutoutAsBackground(beforeBitmap, bitmap);
    if (beforeBitmap != null) {
        beforeBitmap.recycle();
    }
    if (bitmap != null && bitmap != result) {
        bitmap.recycle();
    }
    Stats s = evaluateLightBarBitmap(result, Color.RED);
    assertLightStats(result, s);
    mNm.cancelAll();
    mNm.deleteNotificationChannel(NOTIFICATION_CHANNEL_ID);
}
#end_block

#method_before
@Test
public void testLightNavigationBar() throws Throwable {
    PackageManager pm = getInstrumentation().getContext().getPackageManager();
    if (pm.hasSystemFeature(PackageManager.FEATURE_WATCH) || pm.hasSystemFeature(PackageManager.FEATURE_TELEVISION) || pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK) || pm.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
        // Car navigation is not transparent.
        return;
    }
    if (!ActivityManager.isHighEndGfx()) {
        // non-highEndGfx devices don't do colored system bars.
        return;
    }
    if (!hasVirtualNavigationBar()) {
        // No virtual navigation bar, so no effect.
        return;
    }
    requestLightBars(Color.RED);
    Thread.sleep(WAIT_TIME);
    // Inject a cancelled interaction with the nav bar to ensure it is at full opacity.
    int x = mActivityRule.getActivity().getWidth() / 2;
    int y = mActivityRule.getActivity().getBottom() + 10;
    injectCanceledTap(x, y);
    Thread.sleep(WAIT_TIME);
    Bitmap bitmap = takeNavigationBarScreenshot(mActivityRule.getActivity());
    Stats s = evaluateLightBarBitmap(bitmap, Color.RED);
    assertLightStats(bitmap, s);
}
#method_after
@Test
public void testLightNavigationBar() throws Throwable {
    assumeHasColorNavigationBar();
    requestLightBars(Color.RED);
    Thread.sleep(WAIT_TIME);
    // Inject a cancelled interaction with the nav bar to ensure it is at full opacity.
    int x = mActivityRule.getActivity().getWidth() / 2;
    int y = mActivityRule.getActivity().getBottom() + 10;
    injectCanceledTap(x, y);
    Thread.sleep(WAIT_TIME);
    Bitmap bitmap = takeNavigationBarScreenshot(mActivityRule.getActivity());
    Stats s = evaluateLightBarBitmap(bitmap, Color.RED);
    assertLightStats(bitmap, s);
}
#end_block

#method_before
private Stats evaluateLightBarBitmap(Bitmap bitmap, int background) {
    int iconColor = 0x99000000;
    int iconPartialColor = 0x3d000000;
    int mixedIconColor = mixSrcOver(background, iconColor);
    int mixedIconPartialColor = mixSrcOver(background, iconPartialColor);
    float[] hsvMixedIconColor = new float[3];
    float[] hsvMixedPartialColor = new float[3];
    Color.RGBToHSV(Color.red(mixedIconColor), Color.green(mixedIconColor), Color.blue(mixedIconColor), hsvMixedIconColor);
    Color.RGBToHSV(Color.red(mixedIconPartialColor), Color.green(mixedIconPartialColor), Color.blue(mixedIconPartialColor), hsvMixedPartialColor);
    float maxHsvValue = Math.max(hsvMixedIconColor[2], hsvMixedPartialColor[2]);
    float minHsvValue = Math.min(hsvMixedIconColor[2], hsvMixedPartialColor[2]);
    float[] hsvBackground = new float[3];
    Color.RGBToHSV(Color.red(background), Color.green(background), Color.blue(background), hsvBackground);
    int[] pixels = new int[bitmap.getHeight() * bitmap.getWidth()];
    bitmap.getPixels(pixels, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());
    Stats s = new Stats();
    float eps = 0.005f;
    float[] hsvPixel = new float[3];
    for (int c : pixels) {
        if (isColorSame(c, background)) {
            s.backgroundPixels++;
            continue;
        }
        // What we expect the icons to be colored according to the spec.
        Color.RGBToHSV(Color.red(c), Color.green(c), Color.blue(c), hsvPixel);
        if (isColorSame(c, mixedIconColor) || isColorSame(c, mixedIconPartialColor) || (hsvPixel[2] >= minHsvValue && hsvPixel[2] <= maxHsvValue)) {
            s.iconPixels++;
            continue;
        }
        // Due to anti-aliasing, there will be deviations from the ideal icon color, but it
        // should still be mostly the same hue.
        float hueDiff = Math.abs(ColorUtils.hue(background) - ColorUtils.hue(c));
        if (hueDiff < eps || hueDiff > 1 - eps) {
            // .. it shouldn't be lighter than the original background though.
            if (ColorUtils.brightness(c) > ColorUtils.brightness(background)) {
                s.sameHueLightPixels++;
            } else {
                s.sameHueDarkPixels++;
            }
            continue;
        }
        s.unexpectedHuePixels++;
    }
    return s;
}
#method_after
private Stats evaluateLightBarBitmap(Bitmap bitmap, int background) {
    int iconColor = 0x99000000;
    int iconPartialColor = 0x3d000000;
    int mixedIconColor = mixSrcOver(background, iconColor);
    int mixedIconPartialColor = mixSrcOver(background, iconPartialColor);
    float[] hsvMixedIconColor = new float[3];
    float[] hsvMixedPartialColor = new float[3];
    Color.RGBToHSV(Color.red(mixedIconColor), Color.green(mixedIconColor), Color.blue(mixedIconColor), hsvMixedIconColor);
    Color.RGBToHSV(Color.red(mixedIconPartialColor), Color.green(mixedIconPartialColor), Color.blue(mixedIconPartialColor), hsvMixedPartialColor);
    float maxHsvValue = Math.max(hsvMixedIconColor[2], hsvMixedPartialColor[2]);
    float minHsvValue = Math.min(hsvMixedIconColor[2], hsvMixedPartialColor[2]);
    int[] pixels = new int[bitmap.getHeight() * bitmap.getWidth()];
    bitmap.getPixels(pixels, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());
    Stats s = new Stats();
    float eps = 0.005f;
    float[] hsvPixel = new float[3];
    for (int c : pixels) {
        if (isColorSame(c, background)) {
            s.backgroundPixels++;
            continue;
        }
        // What we expect the icons to be colored according to the spec.
        Color.RGBToHSV(Color.red(c), Color.green(c), Color.blue(c), hsvPixel);
        if (isColorSame(c, mixedIconColor) || isColorSame(c, mixedIconPartialColor) || (hsvPixel[2] >= minHsvValue && hsvPixel[2] <= maxHsvValue)) {
            s.iconPixels++;
            continue;
        }
        // Due to anti-aliasing, there will be deviations from the ideal icon color, but it
        // should still be mostly the same hue.
        float hueDiff = Math.abs(ColorUtils.hue(background) - ColorUtils.hue(c));
        if (hueDiff < eps || hueDiff > 1 - eps) {
            // .. it shouldn't be lighter than the original background though.
            if (ColorUtils.brightness(c) > ColorUtils.brightness(background)) {
                s.sameHueLightPixels++;
            } else {
                s.sameHueDarkPixels++;
            }
            continue;
        }
        s.unexpectedHuePixels++;
    }
    return s;
}
#end_block

#method_before
@Before
@Override
public void setUp() throws Exception {
    super.setUp();
    final Intent sessionActivity = new Intent(mContext, MockActivity.class);
    // Create this test specific MediaSession2 to use our own Handler.
    mIntent = PendingIntent.getActivity(mContext, 0, sessionActivity, 0);
    mPlayer = new MockPlayerConnector(1);
    mMockAgent = new MockPlaylistAgent();
    mSession = new MediaSession2.Builder(mContext).setPlayer(mPlayer).setPlaylistAgent(mMockAgent).setSessionCallback(sHandlerExecutor, new SessionCallback() {

        @Override
        public SessionCommandGroup2 onConnect(MediaSession2 session, ControllerInfo controller) {
            if (EXPECTED_CONTROLLER_PACKAGE_NAME.equals(controller.getPackageName())) {
                return super.onConnect(session, controller);
            }
            return null;
        }
    }).setSessionActivity(mIntent).setId(TAG).build();
    mController = new RemoteMediaControllerCompat(mContext, mSession.getSessionCompat().getSessionToken(), true);
    mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
}
#method_after
@Before
@Override
public void setUp() throws Exception {
    super.setUp();
    final Intent sessionActivity = new Intent(mContext, MockActivity.class);
    // Create this test specific MediaSession2 to use our own Handler.
    mIntent = PendingIntent.getActivity(mContext, 0, sessionActivity, 0);
    mPlayer = new MockPlayerConnector(1);
    mMockAgent = new MockPlaylistAgent();
    mSession = new MediaSession2.Builder(mContext).setId(TAG).setPlayer(mPlayer).setPlaylistAgent(mMockAgent).setSessionCallback(sHandlerExecutor, new SessionCallback() {

        @Override
        public SessionCommandGroup2 onConnect(MediaSession2 session, ControllerInfo controller) {
            if (EXPECTED_CONTROLLER_PACKAGE_NAME.equals(controller.getPackageName())) {
                return super.onConnect(session, controller);
            }
            return null;
        }
    }).setSessionActivity(mIntent).setId(TAG).build();
    mController = new RemoteMediaControllerCompat(mContext, mSession.getSessionCompat().getSessionToken(), true);
    mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    if (msg.what == MSG_MEDIA_PLAY_PAUSE_KEY_DOUBLE_TAP_TIMEOUT) {
        handleMediaPlayPauseKeySingleTapIfPending((RemoteUserInfo) msg.obj);
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    if (msg.what == MSG_MEDIA_PLAY_PAUSE_KEY_DOUBLE_TAP_TIMEOUT) {
        // Here we manually set the caller info, since this is not directly called from
        // the session callback. This is triggered by timeout.
        MediaSessionImpl impl = mSessionImpl.get();
        if (impl == null) {
            return;
        }
        RemoteUserInfo info = (RemoteUserInfo) msg.obj;
        impl.setCurrentControllerInfo(info);
        handleMediaPlayPauseKeySingleTapIfPending();
        impl.setCurrentControllerInfo(null);
    }
}
#end_block

#method_before
@Override
public void onPlayerStateChanged(@NonNull MediaController2 controller, @MediaPlayerConnector.PlayerState int state) {
    if (DEBUG) {
        Log.d(TAG, "onPlayerStateChanged(state: " + state + ")");
    }
    mPlaybackState = state;
    // 2) Need to handle case where the media file reaches end of duration.
    if (mPlaybackState != mPrevState) {
        switch(mPlaybackState) {
            case MediaPlayerConnector.PLAYER_STATE_PLAYING:
                removeCallbacks(mUpdateProgress);
                post(mUpdateProgress);
                resetHideCallbacks();
                updateForStoppedState(false);
                break;
            case MediaPlayerConnector.PLAYER_STATE_PAUSED:
                mPlayPauseButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_play_circle_filled, null));
                mPlayPauseButton.setContentDescription(mResources.getString(R.string.mcv2_play_button_desc));
                removeCallbacks(mUpdateProgress);
                break;
            case MediaPlayerConnector.PLAYER_STATE_ERROR:
                mPlayPauseButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_play_circle_filled, null));
                mPlayPauseButton.setContentDescription(mResources.getString(R.string.mcv2_play_button_desc));
                removeCallbacks(mUpdateProgress);
                if (getWindowToken() != null) {
                    new AlertDialog.Builder(getContext()).setMessage(R.string.mcv2_playback_error_text).setPositiveButton(R.string.mcv2_error_dialog_button, new DialogInterface.OnClickListener() {

                        @Override
                        public void onClick(DialogInterface dialogInterface, int i) {
                            MediaControlView2.this.setEnabled(false);
                            dialogInterface.dismiss();
                        }
                    }).setCancelable(true).show();
                }
            default:
                break;
        }
        mPrevState = mPlaybackState;
    }
}
#method_after
@Override
public void onPlayerStateChanged(@NonNull MediaController2 controller, @MediaPlayerConnector.PlayerState int state) {
    if (DEBUG) {
        Log.d(TAG, "onPlayerStateChanged(state: " + state + ")");
    }
    mPlaybackState = state;
    // 2) Need to handle case where the media file reaches end of duration.
    if (mPlaybackState != mPrevState) {
        switch(mPlaybackState) {
            case MediaPlayerConnector.PLAYER_STATE_PLAYING:
                removeCallbacks(mUpdateProgress);
                post(mUpdateProgress);
                resetHideCallbacks();
                updateForStoppedState(false);
                break;
            case MediaPlayerConnector.PLAYER_STATE_PAUSED:
                mPlayPauseButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_play_circle_filled, null));
                mPlayPauseButton.setContentDescription(mResources.getString(R.string.mcv2_play_button_desc));
                removeCallbacks(mUpdateProgress);
                break;
            case MediaPlayerConnector.PLAYER_STATE_ERROR:
                MediaControlView2.this.setEnabled(false);
                mPlayPauseButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_play_circle_filled, null));
                mPlayPauseButton.setContentDescription(mResources.getString(R.string.mcv2_play_button_desc));
                removeCallbacks(mUpdateProgress);
                if (getWindowToken() != null) {
                    new AlertDialog.Builder(getContext()).setMessage(R.string.mcv2_playback_error_text).setPositiveButton(R.string.mcv2_error_dialog_button, new DialogInterface.OnClickListener() {

                        @Override
                        public void onClick(DialogInterface dialogInterface, int i) {
                            dialogInterface.dismiss();
                        }
                    }).setCancelable(true).show();
                }
            default:
                break;
        }
        mPrevState = mPlaybackState;
    }
}
#end_block

#method_before
public void addOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener) {
    String pkgName = mContext != null ? mContext.getOpPackageName() : "<unknown>";
    if (DBG) {
        logd("register OnSubscriptionsChangedListener pkgName=" + pkgName + " listener=" + listener);
    }
    try {
        // We use the TelephonyRegistry as it runs in the system and thus is always
        // available. Where as SubscriptionController could crash and not be available
        ITelephonyRegistry tr = ITelephonyRegistry.Stub.asInterface(ServiceManager.getService("telephony.registry"));
        if (tr != null) {
            tr.addOnSubscriptionsChangedListener(pkgName, listener.callback);
        }
    } catch (RemoteException ex) {
    // Should not happen
    }
}
#method_after
public void addOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener) {
    String pkgName = mContext != null ? mContext.getOpPackageName() : "<unknown>";
    if (DBG) {
        logd("register OnSubscriptionsChangedListener pkgName=" + pkgName + " listener=" + listener);
    }
    try {
        // We use the TelephonyRegistry as it runs in the system and thus is always
        // available. Where as SubscriptionController could crash and not be available
        ITelephonyRegistry tr = ITelephonyRegistry.Stub.asInterface(ServiceManager.getService("telephony.registry"));
        if (tr != null) {
            tr.addOnSubscriptionsChangedListener(pkgName, listener.callback);
        }
    } catch (RemoteException ex) {
        Log.e(LOG_TAG, "Remote exception ITelephonyRegistry " + ex);
    }
}
#end_block

#method_before
public void removeOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener) {
    String pkgForDebug = mContext != null ? mContext.getOpPackageName() : "<unknown>";
    if (DBG) {
        logd("unregister OnSubscriptionsChangedListener pkgForDebug=" + pkgForDebug + " listener=" + listener);
    }
    try {
        // We use the TelephonyRegistry as its runs in the system and thus is always
        // available where as SubscriptionController could crash and not be available
        ITelephonyRegistry tr = ITelephonyRegistry.Stub.asInterface(ServiceManager.getService("telephony.registry"));
        if (tr != null) {
            tr.removeOnSubscriptionsChangedListener(pkgForDebug, listener.callback);
        }
    } catch (RemoteException ex) {
    // Should not happen
    }
}
#method_after
public void removeOnSubscriptionsChangedListener(OnSubscriptionsChangedListener listener) {
    String pkgForDebug = mContext != null ? mContext.getOpPackageName() : "<unknown>";
    if (DBG) {
        logd("unregister OnSubscriptionsChangedListener pkgForDebug=" + pkgForDebug + " listener=" + listener);
    }
    try {
        // We use the TelephonyRegistry as it runs in the system and thus is always
        // available where as SubscriptionController could crash and not be available
        ITelephonyRegistry tr = ITelephonyRegistry.Stub.asInterface(ServiceManager.getService("telephony.registry"));
        if (tr != null) {
            tr.removeOnSubscriptionsChangedListener(pkgForDebug, listener.callback);
        }
    } catch (RemoteException ex) {
        Log.e(LOG_TAG, "Remote exception ITelephonyRegistry " + ex);
    }
}
#end_block

#method_before
public DataUsageInfo getDataUsageInfo(NetworkTemplate template) {
    final INetworkStatsSession session = getSession();
    if (session == null) {
        return warn("no stats session");
    }
    final NetworkPolicy policy = findNetworkPolicy(template);
    try {
        final NetworkStatsHistory history = session.getHistoryForNetwork(template, FIELDS);
        final long now = System.currentTimeMillis();
        final long start, end;
        if ((policy != null) && (policy.getCycle())) {
            final Pair<ZonedDateTime, ZonedDateTime> cycle = NetworkPolicyManager.cycleIterator(policy).next();
            start = cycle.first.toInstant().toEpochMilli();
            end = cycle.second.toInstant().toEpochMilli();
        } else {
            // period = last 4 wks
            end = now;
            start = now - DateUtils.WEEK_IN_MILLIS * 4;
        }
        final long callStart = System.currentTimeMillis();
        final NetworkStatsHistory.Entry entry = history.getValues(start, end, now, null);
        final long callEnd = System.currentTimeMillis();
        if (DEBUG)
            Log.d(TAG, String.format("history call from %s to %s now=%s took %sms: %s", new Date(start), new Date(end), new Date(now), callEnd - callStart, historyEntryToString(entry)));
        if (entry == null) {
            return warn("no entry data");
        }
        final long totalBytes = entry.rxBytes + entry.txBytes;
        final DataUsageInfo usage = new DataUsageInfo();
        usage.startDate = start;
        usage.usageLevel = totalBytes;
        usage.period = formatDateRange(start, end);
        usage.cycleStart = start;
        usage.cycleEnd = end;
        if (policy != null) {
            usage.limitLevel = policy.limitBytes > 0 ? policy.limitBytes : 0;
            usage.warningLevel = policy.warningBytes > 0 ? policy.warningBytes : 0;
        } else {
            usage.warningLevel = getDefaultWarningLevel();
        }
        if (usage != null && mNetworkController != null) {
            usage.carrier = mNetworkController.getMobileDataNetworkName();
        }
        return usage;
    } catch (RemoteException e) {
        return warn("remote call failed");
    }
}
#method_after
public DataUsageInfo getDataUsageInfo(NetworkTemplate template) {
    final INetworkStatsSession session = getSession();
    if (session == null) {
        return warn("no stats session");
    }
    final NetworkPolicy policy = findNetworkPolicy(template);
    try {
        final NetworkStatsHistory history = session.getHistoryForNetwork(template, FIELDS);
        final long now = System.currentTimeMillis();
        final long start, end;
        if (policy != null && policy.hasCycle()) {
            final Pair<ZonedDateTime, ZonedDateTime> cycle = NetworkPolicyManager.cycleIterator(policy).next();
            start = cycle.first.toInstant().toEpochMilli();
            end = cycle.second.toInstant().toEpochMilli();
        } else {
            // period = last 4 wks
            end = now;
            start = now - DateUtils.WEEK_IN_MILLIS * 4;
        }
        final long callStart = System.currentTimeMillis();
        final NetworkStatsHistory.Entry entry = history.getValues(start, end, now, null);
        final long callEnd = System.currentTimeMillis();
        if (DEBUG)
            Log.d(TAG, String.format("history call from %s to %s now=%s took %sms: %s", new Date(start), new Date(end), new Date(now), callEnd - callStart, historyEntryToString(entry)));
        if (entry == null) {
            return warn("no entry data");
        }
        final long totalBytes = entry.rxBytes + entry.txBytes;
        final DataUsageInfo usage = new DataUsageInfo();
        usage.startDate = start;
        usage.usageLevel = totalBytes;
        usage.period = formatDateRange(start, end);
        usage.cycleStart = start;
        usage.cycleEnd = end;
        if (policy != null) {
            usage.limitLevel = policy.limitBytes > 0 ? policy.limitBytes : 0;
            usage.warningLevel = policy.warningBytes > 0 ? policy.warningBytes : 0;
        } else {
            usage.warningLevel = getDefaultWarningLevel();
        }
        if (usage != null && mNetworkController != null) {
            usage.carrier = mNetworkController.getMobileDataNetworkName();
        }
        return usage;
    } catch (RemoteException e) {
        return warn("remote call failed");
    }
}
#end_block

#method_before
public void pageDown() {
    if (mRecyclerView.getLayoutManager() == null || mRecyclerView.getChildCount() == 0) {
        return;
    }
    OrientationHelper orientationHelper = getOrientationHelper(mRecyclerView.getLayoutManager());
    int screenSize = mRecyclerView.getHeight();
    int scrollDistance = screenSize;
    // If the last item is partially visible, page down should bring it to the top.
    View lastChild = mRecyclerView.getChildAt(mRecyclerView.getChildCount() - 1);
    if (mRecyclerView.getLayoutManager().isViewPartiallyVisible(lastChild, /* completelyVisible= */
    false, /* acceptEndPointInclusion= */
    false)) {
        scrollDistance = orientationHelper.getDecoratedStart(lastChild);
        if (scrollDistance <= 0) {
            // Scroll value can be negative if the child is longer than the screen size and the
            // visible area of the screen does not show the start of the child.
            // Scroll to the next screen if the start value is negative
            scrollDistance = screenSize;
        }
    }
    // want to focus on upcoming view (the one at the bottom of screen).
    for (int i = mRecyclerView.getChildCount() - 1; i >= 0; i--) {
        /* We treat child View longer than screen size differently:
             * 1) When it enters screen, next pageDown will align its top with parent top;
             * 2) When it leaves screen, next pageDown will align its bottom with parent bottom.
             */
        View child = mRecyclerView.getChildAt(i);
        if (child.getHeight() > screenSize) {
            if (orientationHelper.getDecoratedStart(child) > 0) {
                // Child view top is entering screen. Align its top with parent top.
                scrollDistance = orientationHelper.getDecoratedStart(child);
            } else if (screenSize < orientationHelper.getDecoratedEnd(child) && orientationHelper.getDecoratedEnd(child) < 2 * screenSize) {
                // Child view bottom is about to enter screen - its distance to parent bottom
                // is less than a full scroll. Align child bottom with parent bottom.
                scrollDistance = orientationHelper.getDecoratedEnd(child) - screenSize;
            }
            // This is affected by the iteration order.
            break;
        }
    }
    mRecyclerView.smoothScrollBy(0, scrollDistance);
}
#method_after
public void pageDown() {
    if (mRecyclerView.getLayoutManager() == null || mRecyclerView.getChildCount() == 0) {
        return;
    }
    OrientationHelper orientationHelper = getOrientationHelper(mRecyclerView.getLayoutManager());
    int screenSize = mRecyclerView.getHeight();
    int scrollDistance = screenSize;
    // If the last item is partially visible, page down should bring it to the top.
    View lastChild = mRecyclerView.getChildAt(mRecyclerView.getChildCount() - 1);
    if (mRecyclerView.getLayoutManager().isViewPartiallyVisible(lastChild, /* completelyVisible= */
    false, /* acceptEndPointInclusion= */
    false)) {
        scrollDistance = orientationHelper.getDecoratedStart(lastChild);
        if (scrollDistance <= 0) {
            // - Scroll value is zero if the top of last item is aligned with top of the screen;
            // - Scroll value can be negative if the child is longer than the screen size and
            // the visible area of the screen does not show the start of the child.
            // Scroll to the next screen in both cases.
            scrollDistance = screenSize;
        }
    }
    // want to focus on upcoming view (the one at the bottom of screen).
    for (int i = mRecyclerView.getChildCount() - 1; i >= 0; i--) {
        /* We treat child View longer than screen size differently:
             * 1) When it enters screen, next pageDown will align its top with parent top;
             * 2) When it leaves screen, next pageDown will align its bottom with parent bottom.
             */
        View child = mRecyclerView.getChildAt(i);
        if (child.getHeight() > screenSize) {
            if (orientationHelper.getDecoratedStart(child) > 0) {
                // Child view top is entering screen. Align its top with parent top.
                scrollDistance = orientationHelper.getDecoratedStart(child);
            } else if (screenSize < orientationHelper.getDecoratedEnd(child) && orientationHelper.getDecoratedEnd(child) < 2 * screenSize) {
                // Child view bottom is about to enter screen - its distance to parent bottom
                // is less than a full scroll. Align child bottom with parent bottom.
                scrollDistance = orientationHelper.getDecoratedEnd(child) - screenSize;
            }
            // This is affected by the iteration order.
            break;
        }
    }
    mRecyclerView.smoothScrollBy(0, scrollDistance);
}
#end_block

#method_before
@Test
@SdkSuppress(minSdkVersion = 23, maxSdkVersion = 25)
public void testConstraintTrackingWorker_onConstraintsMet() throws InterruptedException {
    when(mBatteryNotLowTracker.getInitialState()).thenReturn(true);
    setupDelegateForExecution(EchoingWorker.class.getName(), new SynchronousExecutor());
    WorkerWrapper.Builder builder = createWorkerWrapperBuilder();
    builder.withWorker(mWorker).withSchedulers(Collections.singletonList(mScheduler));
    mWorkerWrapper = builder.build();
    mWorkTaskExecutor.getBackgroundExecutor().execute(mWorkerWrapper);
    Thread.sleep(TEST_TIMEOUT_IN_MS);
    WorkSpec workSpec = mDatabase.workSpecDao().getWorkSpec(mWork.getStringId());
    assertThat(workSpec.state, is(State.SUCCEEDED));
    Data output = workSpec.output;
    assertThat(output.getBoolean(TEST_ARGUMENT_NAME, false), is(true));
}
#method_after
@Test
@SdkSuppress(minSdkVersion = 23, maxSdkVersion = 25)
public void testConstraintTrackingWorker_onConstraintsMet() {
    when(mBatteryNotLowTracker.getInitialState()).thenReturn(true);
    setupDelegateForExecution(EchoingWorker.class.getName(), new SynchronousExecutor());
    WorkerWrapper.Builder builder = createWorkerWrapperBuilder();
    builder.withWorker(mWorker).withSchedulers(Collections.singletonList(mScheduler));
    mWorkerWrapper = builder.build();
    mWorkTaskExecutor.getBackgroundExecutor().execute(mWorkerWrapper);
    WorkSpec workSpec = mDatabase.workSpecDao().getWorkSpec(mWork.getStringId());
    assertThat(workSpec.state, is(State.SUCCEEDED));
    Data output = workSpec.output;
    assertThat(output.getBoolean(TEST_ARGUMENT_NAME, false), is(true));
}
#end_block

#method_before
@Test
@SdkSuppress(minSdkVersion = 23, maxSdkVersion = 25)
public void testConstraintTrackingWorker_onConstraintsNotMet() throws InterruptedException {
    when(mBatteryNotLowTracker.getInitialState()).thenReturn(false);
    setupDelegateForExecution(TestWorker.class.getName(), new SynchronousExecutor());
    WorkerWrapper.Builder builder = createWorkerWrapperBuilder();
    builder.withWorker(mWorker).withSchedulers(Collections.singletonList(mScheduler));
    mWorkerWrapper = builder.build();
    mWorkTaskExecutor.getBackgroundExecutor().execute(mWorkerWrapper);
    Thread.sleep(TEST_TIMEOUT_IN_MS);
    WorkSpec workSpec = mDatabase.workSpecDao().getWorkSpec(mWork.getStringId());
    assertThat(workSpec.state, is(State.ENQUEUED));
}
#method_after
@Test
@SdkSuppress(minSdkVersion = 23, maxSdkVersion = 25)
public void testConstraintTrackingWorker_onConstraintsNotMet() {
    when(mBatteryNotLowTracker.getInitialState()).thenReturn(false);
    setupDelegateForExecution(TestWorker.class.getName(), new SynchronousExecutor());
    WorkerWrapper.Builder builder = createWorkerWrapperBuilder();
    builder.withWorker(mWorker).withSchedulers(Collections.singletonList(mScheduler));
    mWorkerWrapper = builder.build();
    mWorkTaskExecutor.getBackgroundExecutor().execute(mWorkerWrapper);
    WorkSpec workSpec = mDatabase.workSpecDao().getWorkSpec(mWork.getStringId());
    assertThat(workSpec.state, is(State.ENQUEUED));
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    MediaRouterThemeHelper.setDialogBackgroundColor(mContext, this);
    setContentView(R.layout.mr_cast_dialog);
    mCloseButton = findViewById(R.id.mr_cast_close_button);
    mCloseButton.setColorFilter(COLOR_WHITE_ON_DARK_BACKGROUND);
    mCloseButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    mStopCastingButton = findViewById(R.id.mr_cast_stop_button);
    mStopCastingButton.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mStopCastingButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mSelectedRoute.isSelected()) {
                mRouter.unselect(MediaRouter.UNSELECT_REASON_STOPPED);
            }
            dismiss();
        }
    });
    mAdapter = new RecyclerAdapter();
    mRecyclerView = findViewById(R.id.mr_cast_list);
    mRecyclerView.setAdapter(mAdapter);
    mRecyclerView.setLayoutManager(new LinearLayoutManager(mContext));
    mVolumeChangeListener = new VolumeChangeListener();
    mVolumeSliderColor = MediaRouterThemeHelper.getControllerColor(mContext, 0);
    mVolumeSliderHolderMap = new HashMap<>();
    mBeforeMuteVolumeMap = new HashMap<>();
    mMetadataBackground = findViewById(R.id.mr_cast_meta_background);
    mMetadataBlackScrim = findViewById(R.id.mr_cast_meta_black_scrim);
    mArtView = findViewById(R.id.mr_cast_meta_art);
    mTitleView = findViewById(R.id.mr_cast_meta_title);
    mTitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mSubtitleView = findViewById(R.id.mr_cast_meta_subtitle);
    mSubtitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    Resources res = mContext.getResources();
    mTitlePlaceholder = res.getString(R.string.mr_cast_dialog_title_view_placeholder);
    mCreated = true;
    updateLayout();
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.mr_cast_dialog);
    MediaRouterThemeHelper.setDialogBackgroundColor(mContext, this);
    mCloseButton = findViewById(R.id.mr_cast_close_button);
    mCloseButton.setColorFilter(COLOR_WHITE_ON_DARK_BACKGROUND);
    mCloseButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    mStopCastingButton = findViewById(R.id.mr_cast_stop_button);
    mStopCastingButton.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mStopCastingButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mSelectedRoute.isSelected()) {
                mRouter.unselect(MediaRouter.UNSELECT_REASON_STOPPED);
            }
            dismiss();
        }
    });
    mAdapter = new RecyclerAdapter();
    mRecyclerView = findViewById(R.id.mr_cast_list);
    mRecyclerView.setAdapter(mAdapter);
    mRecyclerView.setLayoutManager(new LinearLayoutManager(mContext));
    mVolumeChangeListener = new VolumeChangeListener();
    mVolumeSliderColor = MediaRouterThemeHelper.getControllerColor(mContext, 0);
    mVolumeSliderHolderMap = new HashMap<>();
    mBeforeMuteVolumeMap = new HashMap<>();
    mMetadataBackground = findViewById(R.id.mr_cast_meta_background);
    mMetadataBlackScrim = findViewById(R.id.mr_cast_meta_black_scrim);
    mArtView = findViewById(R.id.mr_cast_meta_art);
    mTitleView = findViewById(R.id.mr_cast_meta_title);
    mTitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mSubtitleView = findViewById(R.id.mr_cast_meta_subtitle);
    mSubtitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    Resources res = mContext.getResources();
    mTitlePlaceholder = res.getString(R.string.mr_cast_dialog_title_view_placeholder);
    mCreated = true;
    updateLayout();
}
#end_block

#method_before
boolean isSelectedRoute(MediaRouter.RouteInfo route) {
    if (route.isSelected()) {
        return true;
    }
    // If currently casting on a group and route is a member of the group
    if (mSelectedRoute instanceof MediaRouter.RouteGroup) {
        List<MediaRouter.RouteInfo> memberRoutes = ((MediaRouter.RouteGroup) mSelectedRoute).getRoutes();
        for (MediaRouter.RouteInfo memberRoute : memberRoutes) {
            if (memberRoute.getId().equals(route.getId())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
boolean isSelectedRoute(MediaRouter.RouteInfo route) {
    if (route.isSelected()) {
        return true;
    }
    // If currently casting on a group and route is a member of the group
    if (mSelectedRoute instanceof MediaRouter.RouteGroup) {
        List<MediaRouter.RouteInfo> memberRoutes = ((MediaRouter.RouteGroup) mSelectedRoute).getMemberRoutes();
        for (MediaRouter.RouteInfo memberRoute : memberRoutes) {
            if (memberRoute.getId().equals(route.getId())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
void setItems() {
    mItems.clear();
    // Add Group Volume item only when currently casting on a group
    if (mSelectedRoute instanceof MediaRouter.RouteGroup) {
        mItems.add(new Item(mSelectedRoute, ITEM_TYPE_GROUP_VOLUME));
        List<MediaRouter.RouteInfo> routes = ((MediaRouter.RouteGroup) mSelectedRoute).getRoutes();
        for (MediaRouter.RouteInfo route : routes) {
            mItems.add(new Item(route, ITEM_TYPE_ROUTE));
        }
    } else {
        mItems.add(new Item(mSelectedRoute, ITEM_TYPE_ROUTE));
    }
    mAvailableRoutes.clear();
    mAvailableGroups.clear();
    for (MediaRouter.RouteInfo route : mRoutes) {
        // If route is current selected route, skip
        if (isSelectedRoute(route)) {
            continue;
        }
        if (route instanceof MediaRouter.RouteGroup) {
            mAvailableGroups.add(route);
        } else {
            mAvailableRoutes.add(route);
        }
    }
    // Add list items of available routes section to mItems
    if (mAvailableRoutes.size() > 0) {
        mItems.add(new Item(mContext.getString(R.string.mr_dialog_groupable_header), ITEM_TYPE_HEADER));
        for (MediaRouter.RouteInfo route : mAvailableRoutes) {
            mItems.add(new Item(route, ITEM_TYPE_ROUTE));
        }
    }
    // Add list items of available groups section to mItems
    if (mAvailableGroups.size() > 0) {
        mItems.add(new Item(mContext.getString(R.string.mr_dialog_transferable_header), ITEM_TYPE_HEADER));
        for (MediaRouter.RouteInfo route : mAvailableGroups) {
            mItems.add(new Item(route, ITEM_TYPE_GROUP));
        }
    }
    notifyDataSetChanged();
}
#method_after
void setItems() {
    mItems.clear();
    // Add Group Volume item only when currently casting on a group
    if (mSelectedRoute instanceof MediaRouter.RouteGroup) {
        mItems.add(new Item(mSelectedRoute, ITEM_TYPE_GROUP_VOLUME));
        List<MediaRouter.RouteInfo> routes = ((MediaRouter.RouteGroup) mSelectedRoute).getMemberRoutes();
        for (MediaRouter.RouteInfo route : routes) {
            mItems.add(new Item(route, ITEM_TYPE_ROUTE));
        }
    } else {
        mItems.add(new Item(mSelectedRoute, ITEM_TYPE_ROUTE));
    }
    mAvailableRoutes.clear();
    mAvailableGroups.clear();
    for (MediaRouter.RouteInfo route : mRoutes) {
        // If route is current selected route, skip
        if (isSelectedRoute(route)) {
            continue;
        }
        if (route instanceof MediaRouter.RouteGroup) {
            mAvailableGroups.add(route);
        } else {
            mAvailableRoutes.add(route);
        }
    }
    // Add list items of available routes section to mItems
    if (mAvailableRoutes.size() > 0) {
        mItems.add(new Item(mContext.getString(R.string.mr_dialog_groupable_header), ITEM_TYPE_HEADER));
        for (MediaRouter.RouteInfo route : mAvailableRoutes) {
            mItems.add(new Item(route, ITEM_TYPE_ROUTE));
        }
    }
    // Add list items of available groups section to mItems
    if (mAvailableGroups.size() > 0) {
        mItems.add(new Item(mContext.getString(R.string.mr_dialog_transferable_header), ITEM_TYPE_HEADER));
        for (MediaRouter.RouteInfo route : mAvailableGroups) {
            mItems.add(new Item(route, ITEM_TYPE_GROUP));
        }
    }
    notifyDataSetChanged();
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    MediaRouterThemeHelper.setDialogBackgroundColor(mContext, this);
    setContentView(R.layout.mr_picker_dialog);
    mRoutes = new ArrayList<>();
    mCloseButton = findViewById(R.id.mr_picker_close_button);
    mCloseButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    mAdapter = new RecyclerAdapter();
    mRecyclerView = findViewById(R.id.mr_picker_list);
    mRecyclerView.setAdapter(mAdapter);
    mRecyclerView.setLayoutManager(new LinearLayoutManager(mContext));
    updateLayout();
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.mr_picker_dialog);
    MediaRouterThemeHelper.setDialogBackgroundColor(mContext, this);
    mRoutes = new ArrayList<>();
    mCloseButton = findViewById(R.id.mr_picker_close_button);
    mCloseButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    mAdapter = new RecyclerAdapter();
    mRecyclerView = findViewById(R.id.mr_picker_list);
    mRecyclerView.setAdapter(mAdapter);
    mRecyclerView.setLayoutManager(new LinearLayoutManager(mContext));
    updateLayout();
}
#end_block

#method_before
static void setDialogBackgroundColor(Context context, Dialog dialog) {
    int resId = isLightTheme(context) ? R.color.mr_dynamic_dialog_background_light : R.color.mr_dynamic_dialog_background_dark;
    dialog.getWindow().setBackgroundDrawableResource(resId);
}
#method_after
static void setDialogBackgroundColor(Context context, Dialog dialog) {
    View dialogView = dialog.getWindow().getDecorView();
    int backgroundColor = ContextCompat.getColor(context, isLightTheme(context) ? R.color.mr_dynamic_dialog_background_light : R.color.mr_dynamic_dialog_background_dark);
    dialogView.setBackgroundColor(backgroundColor);
}
#end_block

#method_before
private void initPath(Path path) {
    mData = PathUtils.createKeyFrameData(path, PRECISION);
    int numPoints = mData.length / 3;
    // Sanity check
    if (Math.abs(mData[1]) > EPSILON || Math.abs(mData[2]) > EPSILON || Math.abs(mData[mData.length - 2] - 1) > EPSILON || Math.abs(mData[mData.length - 1] - 1) > EPSILON) {
        throw new IllegalArgumentException("The Path must start at (0,0) and end at (1,1)");
    }
    float prevX = 0;
    float prevFraction = 0;
    for (int i = 0; i < numPoints; i++) {
        float fraction = mData[i * 3];
        float x = mData[i * 3 + 1];
        if (fraction == prevFraction && x != prevX) {
            throw new IllegalArgumentException("The Path cannot have discontinuity in the X axis.");
        }
        if (x < prevX) {
            throw new IllegalArgumentException("The Path cannot loop back on itself.");
        }
        prevFraction = fraction;
        prevX = x;
    }
}
#method_after
private void initPath(Path path) {
    mData = PathUtils.createKeyFrameData(path, PRECISION);
    int numPoints = getNumOfPoints();
    // Sanity check
    if (!floatEquals(getXAtIndex(0), 0f) || !floatEquals(getYAtIndex(0), 0f) || !floatEquals(getXAtIndex(numPoints - 1), 1f) || !floatEquals(getYAtIndex(numPoints - 1), 1f)) {
        throw new IllegalArgumentException("The Path must start at (0,0) and end at (1,1)");
    }
    float prevX = 0;
    float prevFraction = 0;
    for (int i = 0; i < numPoints; i++) {
        float fraction = getFractionAtIndex(i);
        float x = getXAtIndex(i);
        if (fraction == prevFraction && x != prevX) {
            throw new IllegalArgumentException("The Path cannot have discontinuity in the X axis.");
        }
        if (x < prevX) {
            throw new IllegalArgumentException("The Path cannot loop back on itself.");
        }
        prevFraction = fraction;
        prevX = x;
    }
}
#end_block

#method_before
@Override
public float getInterpolation(float t) {
    if (t <= 0) {
        return 0;
    } else if (t >= 1) {
        return 1;
    }
    // Do a binary search for the correct x to interpolate between.
    int startIndex = 0;
    int endIndex = mData.length / 3 - 1;
    while (endIndex - startIndex > 1) {
        int midIndex = (startIndex + endIndex) / 2;
        if (t < getXAtIndex(midIndex)) {
            endIndex = midIndex;
        } else {
            startIndex = midIndex;
        }
    }
    float xRange = getXAtIndex(endIndex) - getXAtIndex(startIndex);
    if (xRange == 0) {
        return getYAtIndex(startIndex);
    }
    float tInRange = t - getXAtIndex(startIndex);
    float fraction = tInRange / xRange;
    float startY = getYAtIndex(startIndex);
    float endY = getYAtIndex(endIndex);
    return startY + (fraction * (endY - startY));
}
#method_after
@Override
public float getInterpolation(float t) {
    if (t <= 0) {
        return 0;
    } else if (t >= 1) {
        return 1;
    }
    // Do a binary search for the correct x to interpolate between.
    int startIndex = 0;
    int endIndex = getNumOfPoints() - 1;
    while (endIndex - startIndex > 1) {
        int midIndex = (startIndex + endIndex) / 2;
        if (t < getXAtIndex(midIndex)) {
            endIndex = midIndex;
        } else {
            startIndex = midIndex;
        }
    }
    float xRange = getXAtIndex(endIndex) - getXAtIndex(startIndex);
    if (xRange == 0) {
        return getYAtIndex(startIndex);
    }
    float tInRange = t - getXAtIndex(startIndex);
    float fraction = tInRange / xRange;
    float startY = getYAtIndex(startIndex);
    float endY = getYAtIndex(endIndex);
    return startY + (fraction * (endY - startY));
}
#end_block

#method_before
public String getScreenInfraLogPath() {
    return infraLogPath.replace("gs://vts-report/", "");
}
#method_after
public String getScreenInfraLogPath() {
    String gcsInfraLogBucketName = systemConfigProp.getProperty("gcs.infraLogBucketName");
    return infraLogPath.replace("gs://" + gcsInfraLogBucketName + "/", "");
}
#end_block

#method_before
private void prepareNativeDaemon() {
    mBandwidthControlEnabled = false;
    // only enable bandwidth control when support exists
    final boolean hasKernelSupport;
    if (System.getProperty("os.name").startsWith("Linux")) {
        String[] kernelVersion = System.getProperty("os.version").split("\\.");
        if (kernelVersion.length < 2) {
            Slog.e(TAG, "get kernel version failed");
        }
        int VersionMajor = Integer.parseInt(kernelVersion[0]);
        int VersionMinor = Integer.parseInt(kernelVersion[1]);
        if ((VersionMajor > 4) || (VersionMajor == 4 && VersionMinor >= 9)) {
            hasKernelSupport = new File("/sys/fs/bpf/traffic_cookie_uid_map").exists();
        } else {
            hasKernelSupport = new File("/proc/net/xt_qtaguid/ctrl").exists();
        }
    } else {
        hasKernelSupport = new File("/proc/net/xt_qtaguid/ctrl").exists();
    }
    // push any existing quota or UID rules
    synchronized (mQuotaLock) {
        if (hasKernelSupport) {
            Slog.d(TAG, "enabling bandwidth control");
            try {
                mConnector.execute("bandwidth", "enable");
                mBandwidthControlEnabled = true;
            } catch (NativeDaemonConnectorException e) {
                Log.wtf(TAG, "problem enabling bandwidth controls", e);
            }
        } else {
            Slog.i(TAG, "not enabling bandwidth control");
        }
        SystemProperties.set(PROP_QTAGUID_ENABLED, mBandwidthControlEnabled ? "1" : "0");
        try {
            mConnector.execute("strict", "enable");
            mStrictEnabled = true;
        } catch (NativeDaemonConnectorException e) {
            Log.wtf(TAG, "Failed strict enable", e);
        }
        setDataSaverModeEnabled(mDataSaverMode);
        int size = mActiveQuotas.size();
        if (size > 0) {
            if (DBG)
                Slog.d(TAG, "Pushing " + size + " active quota rules");
            final HashMap<String, Long> activeQuotas = mActiveQuotas;
            mActiveQuotas = Maps.newHashMap();
            for (Map.Entry<String, Long> entry : activeQuotas.entrySet()) {
                setInterfaceQuota(entry.getKey(), entry.getValue());
            }
        }
        size = mActiveAlerts.size();
        if (size > 0) {
            if (DBG)
                Slog.d(TAG, "Pushing " + size + " active alert rules");
            final HashMap<String, Long> activeAlerts = mActiveAlerts;
            mActiveAlerts = Maps.newHashMap();
            for (Map.Entry<String, Long> entry : activeAlerts.entrySet()) {
                setInterfaceAlert(entry.getKey(), entry.getValue());
            }
        }
        SparseBooleanArray uidRejectOnQuota = null;
        SparseBooleanArray uidAcceptOnQuota = null;
        synchronized (mRulesLock) {
            size = mUidRejectOnMetered.size();
            if (size > 0) {
                if (DBG)
                    Slog.d(TAG, "Pushing " + size + " UIDs to metered blacklist rules");
                uidRejectOnQuota = mUidRejectOnMetered;
                mUidRejectOnMetered = new SparseBooleanArray();
            }
            size = mUidAllowOnMetered.size();
            if (size > 0) {
                if (DBG)
                    Slog.d(TAG, "Pushing " + size + " UIDs to metered whitelist rules");
                uidAcceptOnQuota = mUidAllowOnMetered;
                mUidAllowOnMetered = new SparseBooleanArray();
            }
        }
        if (uidRejectOnQuota != null) {
            for (int i = 0; i < uidRejectOnQuota.size(); i++) {
                setUidMeteredNetworkBlacklist(uidRejectOnQuota.keyAt(i), uidRejectOnQuota.valueAt(i));
            }
        }
        if (uidAcceptOnQuota != null) {
            for (int i = 0; i < uidAcceptOnQuota.size(); i++) {
                setUidMeteredNetworkWhitelist(uidAcceptOnQuota.keyAt(i), uidAcceptOnQuota.valueAt(i));
            }
        }
        size = mUidCleartextPolicy.size();
        if (size > 0) {
            if (DBG)
                Slog.d(TAG, "Pushing " + size + " active UID cleartext policies");
            final SparseIntArray local = mUidCleartextPolicy;
            mUidCleartextPolicy = new SparseIntArray();
            for (int i = 0; i < local.size(); i++) {
                setUidCleartextNetworkPolicy(local.keyAt(i), local.valueAt(i));
            }
        }
        setFirewallEnabled(mFirewallEnabled);
        syncFirewallChainLocked(FIREWALL_CHAIN_NONE, "");
        syncFirewallChainLocked(FIREWALL_CHAIN_STANDBY, "standby ");
        syncFirewallChainLocked(FIREWALL_CHAIN_DOZABLE, "dozable ");
        syncFirewallChainLocked(FIREWALL_CHAIN_POWERSAVE, "powersave ");
        final int[] chains = { FIREWALL_CHAIN_STANDBY, FIREWALL_CHAIN_DOZABLE, FIREWALL_CHAIN_POWERSAVE };
        for (int chain : chains) {
            if (getFirewallChainState(chain)) {
                setFirewallChainEnabled(chain, true);
            }
        }
    }
    if (mBandwidthControlEnabled) {
        try {
            getBatteryStats().noteNetworkStatsEnabled();
        } catch (RemoteException e) {
        }
    }
}
#method_after
private void prepareNativeDaemon() {
    mBandwidthControlEnabled = false;
    // push any existing quota or UID rules
    synchronized (mQuotaLock) {
        // TODO: Delete this code and have netd unconditionally enable bandwidth control at
        // startup time
        Slog.d(TAG, "enabling bandwidth control");
        try {
            mConnector.execute("bandwidth", "enable");
            mBandwidthControlEnabled = true;
        } catch (NativeDaemonConnectorException e) {
            Log.wtf(TAG, "problem enabling bandwidth controls", e);
        }
        SystemProperties.set(PROP_QTAGUID_ENABLED, mBandwidthControlEnabled ? "1" : "0");
        mStrictEnabled = true;
        setDataSaverModeEnabled(mDataSaverMode);
        int size = mActiveQuotas.size();
        if (size > 0) {
            if (DBG)
                Slog.d(TAG, "Pushing " + size + " active quota rules");
            final HashMap<String, Long> activeQuotas = mActiveQuotas;
            mActiveQuotas = Maps.newHashMap();
            for (Map.Entry<String, Long> entry : activeQuotas.entrySet()) {
                setInterfaceQuota(entry.getKey(), entry.getValue());
            }
        }
        size = mActiveAlerts.size();
        if (size > 0) {
            if (DBG)
                Slog.d(TAG, "Pushing " + size + " active alert rules");
            final HashMap<String, Long> activeAlerts = mActiveAlerts;
            mActiveAlerts = Maps.newHashMap();
            for (Map.Entry<String, Long> entry : activeAlerts.entrySet()) {
                setInterfaceAlert(entry.getKey(), entry.getValue());
            }
        }
        SparseBooleanArray uidRejectOnQuota = null;
        SparseBooleanArray uidAcceptOnQuota = null;
        synchronized (mRulesLock) {
            size = mUidRejectOnMetered.size();
            if (size > 0) {
                if (DBG)
                    Slog.d(TAG, "Pushing " + size + " UIDs to metered blacklist rules");
                uidRejectOnQuota = mUidRejectOnMetered;
                mUidRejectOnMetered = new SparseBooleanArray();
            }
            size = mUidAllowOnMetered.size();
            if (size > 0) {
                if (DBG)
                    Slog.d(TAG, "Pushing " + size + " UIDs to metered whitelist rules");
                uidAcceptOnQuota = mUidAllowOnMetered;
                mUidAllowOnMetered = new SparseBooleanArray();
            }
        }
        if (uidRejectOnQuota != null) {
            for (int i = 0; i < uidRejectOnQuota.size(); i++) {
                setUidMeteredNetworkBlacklist(uidRejectOnQuota.keyAt(i), uidRejectOnQuota.valueAt(i));
            }
        }
        if (uidAcceptOnQuota != null) {
            for (int i = 0; i < uidAcceptOnQuota.size(); i++) {
                setUidMeteredNetworkWhitelist(uidAcceptOnQuota.keyAt(i), uidAcceptOnQuota.valueAt(i));
            }
        }
        size = mUidCleartextPolicy.size();
        if (size > 0) {
            if (DBG)
                Slog.d(TAG, "Pushing " + size + " active UID cleartext policies");
            final SparseIntArray local = mUidCleartextPolicy;
            mUidCleartextPolicy = new SparseIntArray();
            for (int i = 0; i < local.size(); i++) {
                setUidCleartextNetworkPolicy(local.keyAt(i), local.valueAt(i));
            }
        }
        setFirewallEnabled(mFirewallEnabled);
        syncFirewallChainLocked(FIREWALL_CHAIN_NONE, "");
        syncFirewallChainLocked(FIREWALL_CHAIN_STANDBY, "standby ");
        syncFirewallChainLocked(FIREWALL_CHAIN_DOZABLE, "dozable ");
        syncFirewallChainLocked(FIREWALL_CHAIN_POWERSAVE, "powersave ");
        final int[] chains = { FIREWALL_CHAIN_STANDBY, FIREWALL_CHAIN_DOZABLE, FIREWALL_CHAIN_POWERSAVE };
        for (int chain : chains) {
            if (getFirewallChainState(chain)) {
                setFirewallChainEnabled(chain, true);
            }
        }
    }
    if (mBandwidthControlEnabled) {
        try {
            getBatteryStats().noteNetworkStatsEnabled();
        } catch (RemoteException e) {
        }
    }
}
#end_block

#method_before
@Override
public boolean getIpForwardingEnabled() throws IllegalStateException {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    final NativeDaemonEvent event;
    try {
        event = mConnector.execute("ipfwd", "status");
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
    // 211 Forwarding enabled
    event.checkCode(IpFwdStatusResult);
    return event.getMessage().endsWith("enabled");
}
#method_after
@Override
public boolean getIpForwardingEnabled() throws IllegalStateException {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        final boolean isEnabled = mNetdService.ipfwdEnabled();
        return isEnabled;
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void setIpForwardingEnabled(boolean enable) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mConnector.execute("ipfwd", enable ? "enable" : "disable", "tethering");
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void setIpForwardingEnabled(boolean enable) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        if (enable) {
            mNetdService.ipfwdEnableForwarding("tethering");
        } else {
            mNetdService.ipfwdDisableForwarding("tethering");
        }
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
private void modifyInterfaceForward(boolean add, String fromIface, String toIface) {
    final Command cmd = new Command("ipfwd", add ? "add" : "remove", fromIface, toIface);
    try {
        mConnector.execute(cmd);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
private void modifyInterfaceForward(boolean add, String fromIface, String toIface) {
    try {
        if (add) {
            mNetdService.ipfwdAddInterfaceForward(fromIface, toIface);
        } else {
            mNetdService.ipfwdRemoveInterfaceForward(fromIface, toIface);
        }
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void addIdleTimer(String iface, int timeout, final int type) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    if (DBG)
        Slog.d(TAG, "Adding idletimer");
    synchronized (mIdleTimerLock) {
        IdleTimerParams params = mActiveIdleTimers.get(iface);
        if (params != null) {
            // the interface already has idletimer, update network count
            params.networkCount++;
            return;
        }
        try {
            mConnector.execute("idletimer", "add", iface, Integer.toString(timeout), Integer.toString(type));
        } catch (NativeDaemonConnectorException e) {
            throw e.rethrowAsParcelableException();
        }
        mActiveIdleTimers.put(iface, new IdleTimerParams(timeout, type));
        // Networks start up.
        if (ConnectivityManager.isNetworkTypeMobile(type)) {
            mNetworkActive = false;
        }
        mDaemonHandler.post(new Runnable() {

            @Override
            public void run() {
                notifyInterfaceClassActivity(type, DataConnectionRealTimeInfo.DC_POWER_STATE_HIGH, SystemClock.elapsedRealtimeNanos(), -1, false);
            }
        });
    }
}
#method_after
@Override
public void addIdleTimer(String iface, int timeout, final int type) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    if (DBG)
        Slog.d(TAG, "Adding idletimer");
    synchronized (mIdleTimerLock) {
        IdleTimerParams params = mActiveIdleTimers.get(iface);
        if (params != null) {
            // the interface already has idletimer, update network count
            params.networkCount++;
            return;
        }
        try {
            mNetdService.idletimerAddInterface(iface, timeout, Integer.toString(type));
        } catch (RemoteException | ServiceSpecificException e) {
            throw new IllegalStateException(e);
        }
        mActiveIdleTimers.put(iface, new IdleTimerParams(timeout, type));
        // Networks start up.
        if (ConnectivityManager.isNetworkTypeMobile(type)) {
            mNetworkActive = false;
        }
        mDaemonHandler.post(new Runnable() {

            @Override
            public void run() {
                notifyInterfaceClassActivity(type, DataConnectionRealTimeInfo.DC_POWER_STATE_HIGH, SystemClock.elapsedRealtimeNanos(), -1, false);
            }
        });
    }
}
#end_block

#method_before
@Override
public void removeIdleTimer(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    if (DBG)
        Slog.d(TAG, "Removing idletimer");
    synchronized (mIdleTimerLock) {
        final IdleTimerParams params = mActiveIdleTimers.get(iface);
        if (params == null || --(params.networkCount) > 0) {
            return;
        }
        try {
            mConnector.execute("idletimer", "remove", iface, Integer.toString(params.timeout), Integer.toString(params.type));
        } catch (NativeDaemonConnectorException e) {
            throw e.rethrowAsParcelableException();
        }
        mActiveIdleTimers.remove(iface);
        mDaemonHandler.post(new Runnable() {

            @Override
            public void run() {
                notifyInterfaceClassActivity(params.type, DataConnectionRealTimeInfo.DC_POWER_STATE_LOW, SystemClock.elapsedRealtimeNanos(), -1, false);
            }
        });
    }
}
#method_after
@Override
public void removeIdleTimer(String iface) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    if (DBG)
        Slog.d(TAG, "Removing idletimer");
    synchronized (mIdleTimerLock) {
        final IdleTimerParams params = mActiveIdleTimers.get(iface);
        if (params == null || --(params.networkCount) > 0) {
            return;
        }
        try {
            mNetdService.idletimerRemoveInterface(iface, params.timeout, Integer.toString(params.type));
        } catch (RemoteException | ServiceSpecificException e) {
            throw new IllegalStateException(e);
        }
        mActiveIdleTimers.remove(iface);
        mDaemonHandler.post(new Runnable() {

            @Override
            public void run() {
                notifyInterfaceClassActivity(params.type, DataConnectionRealTimeInfo.DC_POWER_STATE_LOW, SystemClock.elapsedRealtimeNanos(), -1, false);
            }
        });
    }
}
#end_block

#method_before
@Override
public boolean setDataSaverModeEnabled(boolean enable) {
    if (DBG)
        Log.d(TAG, "setDataSaverMode: " + enable);
    synchronized (mQuotaLock) {
        if (mDataSaverMode == enable) {
            Log.w(TAG, "setDataSaverMode(): already " + mDataSaverMode);
            return true;
        }
        Trace.traceBegin(Trace.TRACE_TAG_NETWORK, "bandwidthEnableDataSaver");
        try {
            final boolean changed = mNetdService.bandwidthEnableDataSaver(enable);
            if (changed) {
                mDataSaverMode = enable;
            } else {
                Log.w(TAG, "setDataSaverMode(" + enable + "): netd command silently failed");
            }
            return changed;
        } catch (RemoteException e) {
            Log.w(TAG, "setDataSaverMode(" + enable + "): netd command failed", e);
            return false;
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_NETWORK);
        }
    }
}
#method_after
@Override
public boolean setDataSaverModeEnabled(boolean enable) {
    mContext.enforceCallingOrSelfPermission(NETWORK_SETTINGS, TAG);
    if (DBG)
        Log.d(TAG, "setDataSaverMode: " + enable);
    synchronized (mQuotaLock) {
        if (mDataSaverMode == enable) {
            Log.w(TAG, "setDataSaverMode(): already " + mDataSaverMode);
            return true;
        }
        Trace.traceBegin(Trace.TRACE_TAG_NETWORK, "bandwidthEnableDataSaver");
        try {
            final boolean changed = mNetdService.bandwidthEnableDataSaver(enable);
            if (changed) {
                mDataSaverMode = enable;
            } else {
                Log.w(TAG, "setDataSaverMode(" + enable + "): netd command silently failed");
            }
            return changed;
        } catch (RemoteException e) {
            Log.w(TAG, "setDataSaverMode(" + enable + "): netd command failed", e);
            return false;
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_NETWORK);
        }
    }
}
#end_block

#method_before
@Override
public void setAllowOnlyVpnForUids(boolean add, UidRange[] uidRanges) throws ServiceSpecificException {
    try {
        mNetdService.networkRejectNonSecureVpn(add, uidRanges);
    } catch (ServiceSpecificException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e;
    } catch (RemoteException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e.rethrowAsRuntimeException();
    }
}
#method_after
@Override
public void setAllowOnlyVpnForUids(boolean add, UidRange[] uidRanges) throws ServiceSpecificException {
    mContext.enforceCallingOrSelfPermission(NETWORK_STACK, TAG);
    try {
        mNetdService.networkRejectNonSecureVpn(add, uidRanges);
    } catch (ServiceSpecificException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e;
    } catch (RemoteException e) {
        Log.w(TAG, "setAllowOnlyVpnForUids(" + add + ", " + Arrays.toString(uidRanges) + ")" + ": netd command failed", e);
        throw e.rethrowAsRuntimeException();
    }
}
#end_block

#method_before
private void applyUidCleartextNetworkPolicy(int uid, int policy) {
    final String policyString;
    switch(policy) {
        case StrictMode.NETWORK_POLICY_ACCEPT:
            policyString = "accept";
            break;
        case StrictMode.NETWORK_POLICY_LOG:
            policyString = "log";
            break;
        case StrictMode.NETWORK_POLICY_REJECT:
            policyString = "reject";
            break;
        default:
            throw new IllegalArgumentException("Unknown policy " + policy);
    }
    try {
        mConnector.execute("strict", "set_uid_cleartext_policy", uid, policyString);
        mUidCleartextPolicy.put(uid, policy);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
private void applyUidCleartextNetworkPolicy(int uid, int policy) {
    final int policyValue;
    switch(policy) {
        case StrictMode.NETWORK_POLICY_ACCEPT:
            policyValue = INetd.PENALTY_POLICY_ACCEPT;
            break;
        case StrictMode.NETWORK_POLICY_LOG:
            policyValue = INetd.PENALTY_POLICY_LOG;
            break;
        case StrictMode.NETWORK_POLICY_REJECT:
            policyValue = INetd.PENALTY_POLICY_REJECT;
            break;
        default:
            throw new IllegalArgumentException("Unknown policy " + policy);
    }
    try {
        mNetdService.strictUidCleartextPenalty(uid, policyValue);
        mUidCleartextPolicy.put(uid, policy);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void setUidCleartextNetworkPolicy(int uid, int policy) {
    if (Binder.getCallingUid() != uid) {
        mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    }
    synchronized (mQuotaLock) {
        final int oldPolicy = mUidCleartextPolicy.get(uid, StrictMode.NETWORK_POLICY_ACCEPT);
        if (oldPolicy == policy) {
            // enabled strict and the underlying iptables rules are empty.
            return;
        }
        if (!mStrictEnabled) {
            // Module isn't enabled yet; stash the requested policy away to
            // apply later once the daemon is connected.
            mUidCleartextPolicy.put(uid, policy);
            return;
        }
        // TODO: consider keeping state in netd so we can simplify this code.
        if (oldPolicy != StrictMode.NETWORK_POLICY_ACCEPT && policy != StrictMode.NETWORK_POLICY_ACCEPT) {
            applyUidCleartextNetworkPolicy(uid, StrictMode.NETWORK_POLICY_ACCEPT);
        }
        applyUidCleartextNetworkPolicy(uid, policy);
    }
}
#method_after
@Override
public void setUidCleartextNetworkPolicy(int uid, int policy) {
    if (Binder.getCallingUid() != uid) {
        mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    }
    synchronized (mQuotaLock) {
        final int oldPolicy = mUidCleartextPolicy.get(uid, StrictMode.NETWORK_POLICY_ACCEPT);
        if (oldPolicy == policy) {
            // enabled strict and the underlying iptables rules are empty.
            return;
        }
        // TODO: remove this code after removing prepareNativeDaemon()
        if (!mStrictEnabled) {
            // Module isn't enabled yet; stash the requested policy away to
            // apply later once the daemon is connected.
            mUidCleartextPolicy.put(uid, policy);
            return;
        }
        // TODO: consider keeping state in netd so we can simplify this code.
        if (oldPolicy != StrictMode.NETWORK_POLICY_ACCEPT && policy != StrictMode.NETWORK_POLICY_ACCEPT) {
            applyUidCleartextNetworkPolicy(uid, StrictMode.NETWORK_POLICY_ACCEPT);
        }
        applyUidCleartextNetworkPolicy(uid, policy);
    }
}
#end_block

#method_before
@Override
public NetworkStats getNetworkStatsUidDetail(int uid) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        return mStatsFactory.readNetworkStatsDetail(uid, null, TAG_ALL, null);
    } catch (IOException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
@Override
public NetworkStats getNetworkStatsUidDetail(int uid, String[] ifaces) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        return mStatsFactory.readNetworkStatsDetail(uid, ifaces, TAG_ALL, null);
    } catch (IOException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void setDnsConfigurationForNetwork(int netId, String[] servers, String domains) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    final ContentResolver cr = mContext.getContentResolver();
    int sampleValidity = Settings.Global.getInt(cr, Settings.Global.DNS_RESOLVER_SAMPLE_VALIDITY_SECONDS, DNS_RESOLVER_DEFAULT_SAMPLE_VALIDITY_SECONDS);
    if (sampleValidity < 0 || sampleValidity > 65535) {
        Slog.w(TAG, "Invalid sampleValidity=" + sampleValidity + ", using default=" + DNS_RESOLVER_DEFAULT_SAMPLE_VALIDITY_SECONDS);
        sampleValidity = DNS_RESOLVER_DEFAULT_SAMPLE_VALIDITY_SECONDS;
    }
    int successThreshold = Settings.Global.getInt(cr, Settings.Global.DNS_RESOLVER_SUCCESS_THRESHOLD_PERCENT, DNS_RESOLVER_DEFAULT_SUCCESS_THRESHOLD_PERCENT);
    if (successThreshold < 0 || successThreshold > 100) {
        Slog.w(TAG, "Invalid successThreshold=" + successThreshold + ", using default=" + DNS_RESOLVER_DEFAULT_SUCCESS_THRESHOLD_PERCENT);
        successThreshold = DNS_RESOLVER_DEFAULT_SUCCESS_THRESHOLD_PERCENT;
    }
    int minSamples = Settings.Global.getInt(cr, Settings.Global.DNS_RESOLVER_MIN_SAMPLES, DNS_RESOLVER_DEFAULT_MIN_SAMPLES);
    int maxSamples = Settings.Global.getInt(cr, Settings.Global.DNS_RESOLVER_MAX_SAMPLES, DNS_RESOLVER_DEFAULT_MAX_SAMPLES);
    if (minSamples < 0 || minSamples > maxSamples || maxSamples > 64) {
        Slog.w(TAG, "Invalid sample count (min, max)=(" + minSamples + ", " + maxSamples + "), using default=(" + DNS_RESOLVER_DEFAULT_MIN_SAMPLES + ", " + DNS_RESOLVER_DEFAULT_MAX_SAMPLES + ")");
        minSamples = DNS_RESOLVER_DEFAULT_MIN_SAMPLES;
        maxSamples = DNS_RESOLVER_DEFAULT_MAX_SAMPLES;
    }
    final String[] domainStrs = domains == null ? new String[0] : domains.split(" ");
    final int[] params = { sampleValidity, successThreshold, minSamples, maxSamples };
    final boolean useTls = shouldUseTls(cr);
    // TODO: Populate tlsHostname once it's decided how the hostname's IP
    // addresses will be resolved:
    // 
    // [1] network-provided DNS servers are included here with the
    // hostname and netd will use the network-provided servers to
    // resolve the hostname and fix up its internal structures, or
    // 
    // [2] network-provided DNS servers are included here without the
    // hostname, the ConnectivityService layer resolves the given
    // hostname, and then reconfigures netd with this information.
    // 
    // In practice, there will always be a need for ConnectivityService or
    // the captive portal app to use the network-provided services to make
    // some queries. This argues in favor of [1], in concert with another
    // mechanism, perhaps setting a high bit in the netid, to indicate
    // via existing DNS APIs which set of servers (network-provided or
    // non-network-provided private DNS) should be queried.
    final String tlsHostname = "";
    final String[] tlsFingerprints = new String[0];
    try {
        mNetdService.setResolverConfiguration(netId, servers, domainStrs, params, useTls, tlsHostname, tlsFingerprints);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
#method_after
@Override
public void setDnsConfigurationForNetwork(int netId, String[] servers, String[] domains, int[] params, String tlsHostname, String[] tlsServers) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    final String[] tlsFingerprints = new String[0];
    try {
        mNetdService.setResolverConfiguration(netId, servers, domains, params, tlsHostname, tlsServers, tlsFingerprints);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
@Override
public void startClatd(String interfaceName) throws IllegalStateException {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mConnector.execute("clatd", "start", interfaceName);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void startClatd(String interfaceName) throws IllegalStateException {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.clatdStart(interfaceName);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void stopClatd(String interfaceName) throws IllegalStateException {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mConnector.execute("clatd", "stop", interfaceName);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void stopClatd(String interfaceName) throws IllegalStateException {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.clatdStop(interfaceName);
    } catch (RemoteException | ServiceSpecificException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void removeNetwork(int netId) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mConnector.execute("network", "destroy", netId);
    } catch (NativeDaemonConnectorException e) {
        throw e.rethrowAsParcelableException();
    }
}
#method_after
@Override
public void removeNetwork(int netId) {
    mContext.enforceCallingOrSelfPermission(NETWORK_STACK, TAG);
    try {
        mNetdService.networkDestroy(netId);
    } catch (ServiceSpecificException e) {
        Log.w(TAG, "removeNetwork(" + netId + "): ", e);
        throw e;
    } catch (RemoteException e) {
        Log.w(TAG, "removeNetwork(" + netId + "): ", e);
        throw e.rethrowAsRuntimeException();
    }
}
#end_block

#method_before
public static ImsManager getInstance(Context context, int phoneId) {
    synchronized (sImsManagerInstances) {
        if (sImsManagerInstances.containsKey(phoneId))
            return sImsManagerInstances.get(phoneId);
        ImsManager mgr = new ImsManager(context, phoneId);
        sImsManagerInstances.put(phoneId, mgr);
        return mgr;
    }
}
#method_after
public static ImsManager getInstance(Context context, int phoneId) {
    synchronized (sImsManagerInstances) {
        if (sImsManagerInstances.containsKey(phoneId)) {
            return sImsManagerInstances.get(phoneId);
        }
        ImsManager mgr = new ImsManager(context, phoneId);
        sImsManagerInstances.put(phoneId, mgr);
        return mgr;
    }
}
#end_block

#method_before
public boolean isServiceAvailable() {
    if (mImsServiceProxy != null) {
        return true;
    }
    IBinder binder = ServiceManager.checkService(getImsServiceName(mPhoneId));
    if (binder != null) {
        return true;
    }
    return false;
}
#method_after
public boolean isServiceAvailable() {
    if (mImsServiceProxy == null) {
        createImsService();
    }
    // mImsServiceProxy will always create an ImsServiceProxy.
    return mImsServiceProxy.isBinderAlive();
}
#end_block

#method_before
public void addRegistrationListener(int sessionId, int serviceClass, ImsConnectionStateListener listener) throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    if (listener == null) {
        throw new NullPointerException("listener can't be null");
    }
    try {
        mImsServiceProxy.addRegistrationListener(sessionId, createRegistrationListenerProxy(serviceClass, listener));
    } catch (RemoteException e) {
        throw new ImsException("addRegistrationListener()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#method_after
public void addRegistrationListener(int sessionId, int serviceClass, ImsConnectionStateListener listener) throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    if (listener == null) {
        throw new NullPointerException("listener can't be null");
    }
    try {
        ImsRegistrationListenerProxy p = createRegistrationListenerProxy(serviceClass, listener);
        mRegistrationListeners.add(p);
        mImsServiceProxy.addRegistrationListener(sessionId, p);
    } catch (RemoteException e) {
        throw new ImsException("addRegistrationListener()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#end_block

#method_before
public void addRegistrationListener(int serviceClass, ImsConnectionStateListener listener) throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    if (listener == null) {
        throw new NullPointerException("listener can't be null");
    }
    try {
        mImsServiceProxy.addRegistrationListener(0, /*sessionId*/
        createRegistrationListenerProxy(serviceClass, listener));
    } catch (RemoteException e) {
        throw new ImsException("addRegistrationListener()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#method_after
public void addRegistrationListener(int serviceClass, ImsConnectionStateListener listener) throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    if (listener == null) {
        throw new NullPointerException("listener can't be null");
    }
    try {
        ImsRegistrationListenerProxy p = createRegistrationListenerProxy(serviceClass, listener);
        // Only add the listener if it doesn't already exist in the set.
        mRegistrationListeners.add(p);
        mImsServiceProxy.addRegistrationListener(ImsFeature.MMTEL, p);
    } catch (RemoteException e) {
        throw new ImsException("addRegistrationListener()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#end_block

#method_before
public void removeRegistrationListener(int serviceClass, ImsConnectionStateListener listener) throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    if (listener == null) {
        throw new NullPointerException("listener can't be null");
    }
    try {
        mImsServiceProxy.removeRegistrationListener(0, /*sessionId*/
        createRegistrationListenerProxy(serviceClass, listener));
    } catch (RemoteException e) {
        throw new ImsException("removeRegistrationListener()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#method_after
public void removeRegistrationListener(int sessionId, ImsConnectionStateListener listener) throws ImsException {
    checkAndThrowExceptionIfServiceUnavailable();
    if (listener == null) {
        throw new NullPointerException("listener can't be null");
    }
    try {
        Optional<ImsRegistrationListenerProxy> optionalProxy = mRegistrationListeners.stream().filter(l -> listener.equals(l.mListener)).findFirst();
        if (optionalProxy.isPresent()) {
            ImsRegistrationListenerProxy p = optionalProxy.get();
            mRegistrationListeners.remove(p);
            mImsServiceProxy.removeRegistrationListener(sessionId, p);
        }
    } catch (RemoteException e) {
        throw new ImsException("removeRegistrationListener()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
    }
}
#end_block

#method_before
public ImsUtInterface getSupplementaryServiceConfiguration(int sessionId) throws ImsException {
    // FIXME: manage the multiple Ut interfaces based on the service id
    if (mUt == null) {
        checkAndThrowExceptionIfServiceUnavailable();
        try {
            IImsUt iUt = mImsServiceProxy.getUtInterface(sessionId);
            if (iUt == null) {
                throw new ImsException("getSupplementaryServiceConfiguration()", ImsReasonInfo.CODE_UT_NOT_SUPPORTED);
            }
            mUt = new ImsUt(iUt);
        } catch (RemoteException e) {
            throw new ImsException("getSupplementaryServiceConfiguration()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
        }
    }
    return mUt;
}
#method_after
public ImsUtInterface getSupplementaryServiceConfiguration(int sessionId) throws ImsException {
    // FIXME: manage the multiple Ut interfaces based on the session id
    if (mUt == null || !mImsServiceProxy.isBinderAlive()) {
        checkAndThrowExceptionIfServiceUnavailable();
        try {
            IImsUt iUt = mImsServiceProxy.getUtInterface(sessionId);
            if (iUt == null) {
                throw new ImsException("getSupplementaryServiceConfiguration()", ImsReasonInfo.CODE_UT_NOT_SUPPORTED);
            }
            mUt = new ImsUt(iUt);
        } catch (RemoteException e) {
            throw new ImsException("getSupplementaryServiceConfiguration()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
        }
    }
    return mUt;
}
#end_block

#method_before
public ImsConfig getConfigInterface() throws ImsException {
    if (mConfig == null) {
        checkAndThrowExceptionIfServiceUnavailable();
        try {
            IImsConfig config = mImsServiceProxy.getConfigInterface(mPhoneId);
            if (config == null) {
                throw new ImsException("getConfigInterface()", ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
            }
            mConfig = new ImsConfig(config, mContext);
        } catch (RemoteException e) {
            throw new ImsException("getConfigInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
        }
    }
    if (DBG)
        log("getConfigInterface(), mConfig= " + mConfig);
    return mConfig;
}
#method_after
public ImsConfig getConfigInterface() throws ImsException {
    if (mConfig == null || !mImsServiceProxy.isBinderAlive()) {
        checkAndThrowExceptionIfServiceUnavailable();
        try {
            IImsConfig config = mImsServiceProxy.getConfigInterface(mPhoneId);
            if (config == null) {
                throw new ImsException("getConfigInterface()", ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE);
            }
            mConfig = new ImsConfig(config, mContext);
        } catch (RemoteException e) {
            throw new ImsException("getConfigInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
        }
    }
    if (DBG)
        log("getConfigInterface(), mConfig= " + mConfig);
    return mConfig;
}
#end_block

#method_before
private void createImsService() {
    boolean dynamicBind = mContext.getResources().getBoolean(com.android.internal.R.bool.config_dynamic_bind_ims);
    if (!dynamicBind) {
        // Old method of binding
        Rlog.i(TAG, "Creating ImsService using ServiceManager");
        mImsServiceProxy = getServiceProxyCompat();
    } else {
        Rlog.i(TAG, "Creating ImsService using ImsResolver");
        mImsServiceProxy = getServiceProxy();
    }
}
#method_after
private void createImsService() {
    if (!mConfigDynamicBind) {
        // Old method of binding
        Rlog.i(TAG, "Creating ImsService using ServiceManager");
        mImsServiceProxy = getServiceProxyCompat();
    } else {
        Rlog.i(TAG, "Creating ImsService using ImsResolver");
        mImsServiceProxy = getServiceProxy();
    }
}
#end_block

#method_before
private ImsServiceProxyCompat getServiceProxyCompat() {
    IBinder binder = ServiceManager.checkService(getImsServiceName(mPhoneId));
    if (binder != null) {
        try {
            binder.linkToDeath(mDeathRecipient, 0);
        } catch (RemoteException e) {
        }
    }
    return new ImsServiceProxyCompat(mPhoneId, binder);
}
#method_after
private ImsServiceProxyCompat getServiceProxyCompat() {
    IBinder binder = ServiceManager.checkService(IMS_SERVICE);
    if (binder != null) {
        try {
            binder.linkToDeath(mDeathRecipient, 0);
        } catch (RemoteException e) {
        }
    }
    return new ImsServiceProxyCompat(mPhoneId, binder);
}
#end_block

#method_before
private ImsServiceProxy getServiceProxy() {
    TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
    ImsServiceProxy serviceProxy = new ImsServiceProxy(mPhoneId, ImsFeature.MMTEL);
    // Returns null if the service is not available.
    IImsServiceController b = tm.getImsServiceControllerAndListen(mPhoneId, ImsFeature.MMTEL, serviceProxy.getListener());
    if (b != null) {
        serviceProxy.setBinder(b.asBinder());
    }
    return serviceProxy;
}
#method_after
private ImsServiceProxy getServiceProxy() {
    TelephonyManager tm = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);
    ImsServiceProxy serviceProxy = new ImsServiceProxy(mPhoneId, ImsFeature.MMTEL);
    // Returns null if the service is not available.
    IImsServiceController b = tm.getImsServiceControllerAndListen(mPhoneId, ImsFeature.MMTEL, serviceProxy.getListener());
    if (b != null) {
        serviceProxy.setBinder(b.asBinder());
        serviceProxy.setStatusCallback(() -> mStatusCallbacks.forEach(ImsServiceProxy.INotifyStatusChanged::notifyStatusChanged));
        // Trigger the cache to be updated for feature status.
        serviceProxy.getFeatureStatus();
        // in the old ImsService implementation.
        if (serviceProxy.isBinderAlive()) {
            Intent intent = new Intent(ACTION_IMS_SERVICE_UP);
            intent.putExtra(EXTRA_PHONE_ID, mPhoneId);
            mContext.sendBroadcast(new Intent(intent));
        }
    } else {
        Rlog.w(TAG, "getServiceProxy: b is null! Phone Id: " + mPhoneId);
    }
    return serviceProxy;
}
#end_block

#method_before
@Override
public void binderDied() {
    mImsServiceProxy = null;
    mUt = null;
    mConfig = null;
    mEcbm = null;
    mMultiEndpoint = null;
    if (mContext != null) {
        Intent intent = new Intent(ACTION_IMS_SERVICE_DOWN);
        intent.putExtra(EXTRA_PHONE_ID, mPhoneId);
        mContext.sendBroadcast(new Intent(intent));
    }
}
#method_after
@Override
public void binderDied() {
    mImsServiceProxy = null;
    mUt = null;
    mConfig = null;
    mEcbm = null;
    mMultiEndpoint = null;
    if (mContext != null && !isDynamicBinding()) {
        Intent intent = new Intent(ACTION_IMS_SERVICE_DOWN);
        intent.putExtra(EXTRA_PHONE_ID, mPhoneId);
        mContext.sendBroadcast(new Intent(intent));
    }
}
#end_block

#method_before
@Override
public void registrationDisconnected(ImsReasonInfo imsReasonInfo) {
    if (DBG) {
        log("registrationDisconnected :: imsReasonInfo" + imsReasonInfo);
    }
    if (mListener != null) {
        mListener.onImsDisconnected(imsReasonInfo);
    }
}
#method_after
@Override
public void registrationDisconnected(ImsReasonInfo imsReasonInfo) {
    if (DBG) {
        log("registrationDisconnected :: imsReasonInfo" + imsReasonInfo);
    }
    addToRecentDisconnectReasons(imsReasonInfo);
    if (mListener != null) {
        mListener.onImsDisconnected(imsReasonInfo);
    }
}
#end_block

#method_before
public ImsEcbm getEcbmInterface(int serviceId) throws ImsException {
    if (mEcbm == null) {
        checkAndThrowExceptionIfServiceUnavailable();
        try {
            IImsEcbm iEcbm = mImsServiceProxy.getEcbmInterface(serviceId);
            if (iEcbm == null) {
                throw new ImsException("getEcbmInterface()", ImsReasonInfo.CODE_ECBM_NOT_SUPPORTED);
            }
            mEcbm = new ImsEcbm(iEcbm);
        } catch (RemoteException e) {
            throw new ImsException("getEcbmInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
        }
    }
    return mEcbm;
}
#method_after
public ImsEcbm getEcbmInterface(int serviceId) throws ImsException {
    if (mEcbm == null || !mImsServiceProxy.isBinderAlive()) {
        checkAndThrowExceptionIfServiceUnavailable();
        try {
            IImsEcbm iEcbm = mImsServiceProxy.getEcbmInterface(serviceId);
            if (iEcbm == null) {
                throw new ImsException("getEcbmInterface()", ImsReasonInfo.CODE_ECBM_NOT_SUPPORTED);
            }
            mEcbm = new ImsEcbm(iEcbm);
        } catch (RemoteException e) {
            throw new ImsException("getEcbmInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
        }
    }
    return mEcbm;
}
#end_block

#method_before
public ImsMultiEndpoint getMultiEndpointInterface(int serviceId) throws ImsException {
    if (mMultiEndpoint == null) {
        checkAndThrowExceptionIfServiceUnavailable();
        try {
            IImsMultiEndpoint iImsMultiEndpoint = mImsServiceProxy.getMultiEndpointInterface(serviceId);
            if (iImsMultiEndpoint == null) {
                throw new ImsException("getMultiEndpointInterface()", ImsReasonInfo.CODE_MULTIENDPOINT_NOT_SUPPORTED);
            }
            mMultiEndpoint = new ImsMultiEndpoint(iImsMultiEndpoint);
        } catch (RemoteException e) {
            throw new ImsException("getMultiEndpointInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
        }
    }
    return mMultiEndpoint;
}
#method_after
public ImsMultiEndpoint getMultiEndpointInterface(int serviceId) throws ImsException {
    if (mMultiEndpoint == null || !mImsServiceProxy.isBinderAlive()) {
        checkAndThrowExceptionIfServiceUnavailable();
        try {
            IImsMultiEndpoint iImsMultiEndpoint = mImsServiceProxy.getMultiEndpointInterface(serviceId);
            if (iImsMultiEndpoint == null) {
                throw new ImsException("getMultiEndpointInterface()", ImsReasonInfo.CODE_MULTIENDPOINT_NOT_SUPPORTED);
            }
            mMultiEndpoint = new ImsMultiEndpoint(iImsMultiEndpoint);
        } catch (RemoteException e) {
            throw new ImsException("getMultiEndpointInterface()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
        }
    }
    return mMultiEndpoint;
}
#end_block

#method_before
@Test
public void invalidMigration_missingFtsOption() throws Exception {
    SupportSQLiteDatabase supportSQLiteDatabase = helper.createDatabase(TEST_DB, 1);
    supportSQLiteDatabase.close();
    try {
        Context targetContext = InstrumentationRegistry.getTargetContext();
        FtsMigrationDb db = Room.databaseBuilder(targetContext, FtsMigrationDb.class, TEST_DB).addMigrations(BAD_MIGRATION_1_2, MIGRATION_2_3).build();
        helper.closeWhenFinished(db);
        db.getBookDao().getAllBooks();
        fail("Should have failed migration.");
    } catch (IllegalStateException ex) {
        assertThat(ex.getMessage(), containsString("Migration didn't properly handle"));
    }
}
#method_after
@Test
public void invalidMigration_missingFtsOption() throws Exception {
    SupportSQLiteDatabase supportSQLiteDatabase = helper.createDatabase(TEST_DB, 1);
    supportSQLiteDatabase.close();
    try {
        Context targetContext = InstrumentationRegistry.getTargetContext();
        FtsMigrationDb db = Room.databaseBuilder(targetContext, FtsMigrationDb.class, TEST_DB).addMigrations(BAD_MIGRATION_1_2, MIGRATION_2_3, MIGRATION_3_4).build();
        helper.closeWhenFinished(db);
        db.getBookDao().getAllBooks();
        fail("Should have failed migration.");
    } catch (IllegalStateException ex) {
        assertThat(ex.getMessage(), containsString("Migration didn't properly handle"));
    }
}
#end_block

#method_before
public Collection<String> buildCreateQueries() {
    List<String> result = new ArrayList<>();
    result.add(createTable());
    result.addAll(mContentSyncSqlTriggers);
    return result;
}
#method_after
@Override
public Collection<String> buildCreateQueries() {
    List<String> result = new ArrayList<>();
    result.add(createTable());
    result.addAll(mContentSyncSqlTriggers);
    return result;
}
#end_block

#method_before
@Test
public void testLightStatusBarIcons() throws Throwable {
    assumeHasColoredStatusBar();
    mNm = (NotificationManager) getInstrumentation().getContext().getSystemService(Context.NOTIFICATION_SERVICE);
    NotificationChannel channel1 = new NotificationChannel(NOTIFICATION_CHANNEL_ID, NOTIFICATION_CHANNEL_ID, NotificationManager.IMPORTANCE_LOW);
    mNm.createNotificationChannel(channel1);
    // post 10 notifications to ensure enough icons in the status bar
    for (int i = 0; i < 10; i++) {
        Notification.Builder noti1 = new Notification.Builder(getInstrumentation().getContext(), NOTIFICATION_CHANNEL_ID).setSmallIcon(R.drawable.ic_save).setChannelId(NOTIFICATION_CHANNEL_ID).setPriority(Notification.PRIORITY_LOW).setGroup(NOTIFICATION_GROUP_KEY);
        mNm.notify(NOTIFICATION_TAG, i, noti1.build());
    }
    requestLightBars(Color.RED);
    Thread.sleep(WAIT_TIME);
    Bitmap bitmap = takeStatusBarScreenshot(mActivityRule.getActivity());
    Stats s = evaluateLightBarBitmap(bitmap, Color.RED);
    assertLightStats(bitmap, s);
    mNm.cancelAll();
    mNm.deleteNotificationChannel(NOTIFICATION_CHANNEL_ID);
}
#method_after
@Test
public void testLightStatusBarIcons() throws Throwable {
    assumeHasColoredStatusBar();
    mNm = (NotificationManager) getInstrumentation().getContext().getSystemService(Context.NOTIFICATION_SERVICE);
    NotificationChannel channel1 = new NotificationChannel(NOTIFICATION_CHANNEL_ID, NOTIFICATION_CHANNEL_ID, NotificationManager.IMPORTANCE_LOW);
    mNm.createNotificationChannel(channel1);
    // post 10 notifications to ensure enough icons in the status bar
    for (int i = 0; i < 10; i++) {
        Notification.Builder noti1 = new Notification.Builder(getInstrumentation().getContext(), NOTIFICATION_CHANNEL_ID).setSmallIcon(R.drawable.ic_save).setChannelId(NOTIFICATION_CHANNEL_ID).setPriority(Notification.PRIORITY_LOW).setGroup(NOTIFICATION_GROUP_KEY);
        mNm.notify(NOTIFICATION_TAG, i, noti1.build());
    }
    Thread.sleep(WAIT_TIME);
    Bitmap beforeBitmap = takeStatusBarScreenshot(mActivityRule.getActivity());
    requestLightBars(Color.RED);
    Thread.sleep(WAIT_TIME);
    Bitmap bitmap = takeStatusBarScreenshot(mActivityRule.getActivity());
    Bitmap result = treatCutoutAsBackground(beforeBitmap, bitmap);
    if (beforeBitmap != null) {
        beforeBitmap.recycle();
    }
    if (bitmap != null && bitmap != result) {
        bitmap.recycle();
    }
    Stats s = evaluateLightBarBitmap(result, Color.RED);
    assertLightStats(result, s);
    mNm.cancelAll();
    mNm.deleteNotificationChannel(NOTIFICATION_CHANNEL_ID);
}
#end_block

#method_before
private void writeToFile(String name, String headerLine, Stream<?> contents) throws IOException {
    PrintStream out = new PrintStream(processingEnv.getFiler().createResource(// TODO better location?
    CLASS_OUTPUT, PACKAGE, name).openOutputStream());
    out.println(headerLine);
    contents.forEach(o -> out.println(o));
    if (out.checkError()) {
        throw new IOException("Error when writing to " + name);
    }
    out.close();
}
#method_after
private void writeToFile(String name, String headerLine, Stream<?> contents) throws IOException {
    PrintStream out = new PrintStream(processingEnv.getFiler().createResource(CLASS_OUTPUT, PACKAGE, name).openOutputStream());
    out.println(headerLine);
    contents.forEach(o -> out.println(o));
    if (out.checkError()) {
        throw new IOException("Error when writing to " + name);
    }
    out.close();
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private void updateLayoutForSizeChange(int sizeType) {
    mSizeType = sizeType;
    RelativeLayout.LayoutParams timeViewParams = (RelativeLayout.LayoutParams) mTimeView.getLayoutParams();
    SeekBar seeker = (SeekBar) mProgress;
    switch(mSizeType) {
        case SIZE_TYPE_EMBEDDED:
            // Relating to Title Bar
            mTitleBar.setVisibility(View.VISIBLE);
            mBackButton.setVisibility(View.GONE);
            mTitleView.setPadding(mResources.getDimensionPixelSize(R.dimen.mcv2_embedded_icon_padding), mTitleView.getPaddingTop(), mTitleView.getPaddingRight(), mTitleView.getPaddingBottom());
            // Relating to Full Screen Button
            if (mOnFullScreenListener != null) {
                mMinimalSizeFullScreenView.setVisibility(View.GONE);
                mFullScreenButton = mBasicControls.findViewById(R.id.fullscreen);
                mFullScreenButton.setOnClickListener(mFullScreenListener);
            }
            // Relating to Center View
            mCenterView.removeAllViews();
            mBottomBarLeftView.removeView(mTransportControls);
            mBottomBarLeftView.setVisibility(View.GONE);
            mTransportControls = inflateTransportControls(R.layout.embedded_transport_controls);
            mCenterView.addView(mTransportControls);
            // Relating to Progress Bar
            seeker.setThumb(mResources.getDrawable(R.drawable.custom_progress_thumb));
            seeker.setThumbOffset(0);
            seeker.invalidate();
            mProgressBuffer.setVisibility(View.VISIBLE);
            // Relating to Bottom Bar
            mBottomBar.setVisibility(View.VISIBLE);
            if (timeViewParams.getRules()[RelativeLayout.LEFT_OF] != 0) {
                timeViewParams.removeRule(RelativeLayout.LEFT_OF);
                timeViewParams.addRule(RelativeLayout.RIGHT_OF, R.id.bottom_bar_left);
            }
            break;
        case SIZE_TYPE_FULL:
            // Relating to Title Bar
            mTitleBar.setVisibility(View.VISIBLE);
            mBackButton.setVisibility(View.VISIBLE);
            mTitleView.setPadding(0, mTitleView.getPaddingTop(), mTitleView.getPaddingRight(), mTitleView.getPaddingBottom());
            // Relating to Full Screen Button
            if (mOnFullScreenListener != null) {
                mMinimalSizeFullScreenView.setVisibility(View.GONE);
                mFullScreenButton = mBasicControls.findViewById(R.id.fullscreen);
                mFullScreenButton.setOnClickListener(mFullScreenListener);
            }
            // Relating to Center View
            mCenterView.removeAllViews();
            mBottomBarLeftView.removeView(mTransportControls);
            mTransportControls = inflateTransportControls(R.layout.full_transport_controls);
            mBottomBarLeftView.addView(mTransportControls, 0);
            mBottomBarLeftView.setVisibility(View.VISIBLE);
            // Relating to Progress Bar
            seeker.setThumb(mResources.getDrawable(R.drawable.custom_progress_thumb));
            seeker.setThumbOffset(0);
            seeker.invalidate();
            mProgressBuffer.setVisibility(View.VISIBLE);
            // Relating to Bottom Bar
            mBottomBar.setVisibility(View.VISIBLE);
            if (timeViewParams.getRules()[RelativeLayout.RIGHT_OF] != 0) {
                timeViewParams.removeRule(RelativeLayout.RIGHT_OF);
                timeViewParams.addRule(RelativeLayout.LEFT_OF, R.id.basic_controls);
            }
            break;
        case SIZE_TYPE_MINIMAL:
            // Relating to Title Bar
            mTitleBar.setVisibility(View.GONE);
            mBackButton.setVisibility(View.GONE);
            // Relating to Full Screen Button
            if (mOnFullScreenListener != null) {
                mMinimalSizeFullScreenView.setVisibility(View.VISIBLE);
                mFullScreenButton = mMinimalSizeFullScreenView.findViewById(R.id.minimal_fullscreen);
                mFullScreenButton.setOnClickListener(mFullScreenListener);
            }
            // Relating to Center View
            mCenterView.removeAllViews();
            mBottomBarLeftView.removeView(mTransportControls);
            mTransportControls = inflateTransportControls(R.layout.minimal_transport_controls);
            mCenterView.addView(mTransportControls);
            // Relating to Progress Bar
            seeker.setThumb(null);
            mProgressBuffer.setVisibility(View.GONE);
            // Relating to Bottom Bar
            mBottomBar.setVisibility(View.GONE);
            break;
    }
    mTimeView.setLayoutParams(timeViewParams);
    if (mIsStopped) {
        updateForStoppedState();
    } else {
        updateForNonStoppedState();
    }
    if (mIsFullScreen) {
        mFullScreenButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_fullscreen_exit, null));
    } else {
        mFullScreenButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_fullscreen, null));
    }
}
#method_after
@SuppressWarnings("deprecation")
private void updateLayoutForSizeChange(int sizeType) {
    mSizeType = sizeType;
    RelativeLayout.LayoutParams timeViewParams = (RelativeLayout.LayoutParams) mTimeView.getLayoutParams();
    SeekBar seeker = (SeekBar) mProgress;
    switch(mSizeType) {
        case SIZE_TYPE_EMBEDDED:
            // Relating to Title Bar
            mTitleBar.setVisibility(View.VISIBLE);
            mBackButton.setVisibility(View.GONE);
            mTitleView.setPadding(mResources.getDimensionPixelSize(R.dimen.mcv2_embedded_icon_padding), mTitleView.getPaddingTop(), mTitleView.getPaddingRight(), mTitleView.getPaddingBottom());
            // Relating to Full Screen Button
            if (mOnFullScreenListener != null) {
                mMinimalSizeFullScreenView.setVisibility(View.GONE);
                mFullScreenButton = mBasicControls.findViewById(R.id.fullscreen);
                mFullScreenButton.setOnClickListener(mFullScreenListener);
            }
            // Relating to Center View
            mCenterView.removeAllViews();
            mBottomBarLeftView.removeView(mTransportControls);
            mBottomBarLeftView.setVisibility(View.GONE);
            mTransportControls = inflateTransportControls(R.layout.embedded_transport_controls);
            mCenterView.addView(mTransportControls);
            // Relating to Progress Bar
            seeker.setThumb(mResources.getDrawable(R.drawable.custom_progress_thumb));
            seeker.setThumbOffset(0);
            seeker.invalidate();
            mProgressBuffer.setVisibility(View.VISIBLE);
            // Relating to Bottom Bar
            mBottomBar.setVisibility(View.VISIBLE);
            if (timeViewParams.getRules()[RelativeLayout.LEFT_OF] != 0) {
                timeViewParams.removeRule(RelativeLayout.LEFT_OF);
                timeViewParams.addRule(RelativeLayout.RIGHT_OF, R.id.bottom_bar_left);
            }
            break;
        case SIZE_TYPE_FULL:
            // Relating to Title Bar
            mTitleBar.setVisibility(View.VISIBLE);
            mBackButton.setVisibility(View.VISIBLE);
            mTitleView.setPadding(0, mTitleView.getPaddingTop(), mTitleView.getPaddingRight(), mTitleView.getPaddingBottom());
            // Relating to Full Screen Button
            if (mOnFullScreenListener != null) {
                mMinimalSizeFullScreenView.setVisibility(View.GONE);
                mFullScreenButton = mBasicControls.findViewById(R.id.fullscreen);
                mFullScreenButton.setOnClickListener(mFullScreenListener);
            }
            // Relating to Center View
            mCenterView.removeAllViews();
            mBottomBarLeftView.removeView(mTransportControls);
            mTransportControls = inflateTransportControls(R.layout.full_transport_controls);
            mBottomBarLeftView.addView(mTransportControls, 0);
            mBottomBarLeftView.setVisibility(View.VISIBLE);
            // Relating to Progress Bar
            seeker.setThumb(mResources.getDrawable(R.drawable.custom_progress_thumb));
            seeker.setThumbOffset(0);
            seeker.invalidate();
            mProgressBuffer.setVisibility(View.VISIBLE);
            // Relating to Bottom Bar
            mBottomBar.setVisibility(View.VISIBLE);
            if (timeViewParams.getRules()[RelativeLayout.RIGHT_OF] != 0) {
                timeViewParams.removeRule(RelativeLayout.RIGHT_OF);
                timeViewParams.addRule(RelativeLayout.LEFT_OF, R.id.basic_controls);
            }
            break;
        case SIZE_TYPE_MINIMAL:
            // Relating to Title Bar
            mTitleBar.setVisibility(View.GONE);
            mBackButton.setVisibility(View.GONE);
            // Relating to Full Screen Button
            if (mOnFullScreenListener != null) {
                mMinimalSizeFullScreenView.setVisibility(View.VISIBLE);
                mFullScreenButton = mMinimalSizeFullScreenView.findViewById(R.id.minimal_fullscreen);
                mFullScreenButton.setOnClickListener(mFullScreenListener);
            }
            // Relating to Center View
            mCenterView.removeAllViews();
            mBottomBarLeftView.removeView(mTransportControls);
            mTransportControls = inflateTransportControls(R.layout.minimal_transport_controls);
            mCenterView.addView(mTransportControls);
            // Relating to Progress Bar
            seeker.setThumb(null);
            mProgressBuffer.setVisibility(View.GONE);
            // Relating to Bottom Bar
            mBottomBar.setVisibility(View.GONE);
            break;
    }
    mTimeView.setLayoutParams(timeViewParams);
    // Update play/pause and ffwd buttons based on whether the media is currently stopped or
    // not.
    updateForStoppedState(mIsStopped);
    if (mIsFullScreen) {
        mFullScreenButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_fullscreen_exit, null));
    } else {
        mFullScreenButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_fullscreen, null));
    }
}
#end_block

#method_before
void updateForStoppedState() {
    mIsStopped = true;
    if (mPlayPauseButton != null) {
        mPlayPauseButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_replay_circle_filled, null));
        mPlayPauseButton.setContentDescription(mResources.getString(R.string.mcv2_replay_button_desc));
    }
    if (mFfwdButton != null) {
        mFfwdButton.setAlpha(0.5f);
        mFfwdButton.setEnabled(false);
    }
}
#method_after
void updateForStoppedState(boolean isStopped) {
    if (isStopped) {
        mIsStopped = true;
        if (mPlayPauseButton != null) {
            mPlayPauseButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_replay_circle_filled, null));
            mPlayPauseButton.setContentDescription(mResources.getString(R.string.mcv2_replay_button_desc));
        }
        if (mFfwdButton != null) {
            mFfwdButton.setAlpha(0.5f);
            mFfwdButton.setEnabled(false);
        }
    } else {
        mIsStopped = false;
        if (mPlayPauseButton != null) {
            if (mController.isPlaying()) {
                mPlayPauseButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_pause_circle_filled, null));
                mPlayPauseButton.setContentDescription(mResources.getString(R.string.mcv2_pause_button_desc));
            } else {
                mPlayPauseButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_play_circle_filled, null));
                mPlayPauseButton.setContentDescription(mResources.getString(R.string.mcv2_play_button_desc));
            }
        }
        if (mFfwdButton != null) {
            mFfwdButton.setAlpha(1.0f);
            mFfwdButton.setEnabled(true);
        }
    }
}
#end_block

#method_before
@Override
public void onPlayerStateChanged(@NonNull MediaController2 controller, @MediaPlayerConnector.PlayerState int state) {
    if (DEBUG) {
        Log.d(TAG, "onPlayerStateChanged(state: " + state + ")");
    }
    mPlaybackState = state;
    // 2) Need to handle case where the media file reaches end of duration.
    if (mPlaybackState != mPrevState) {
        switch(mPlaybackState) {
            case MediaPlayerConnector.PLAYER_STATE_PLAYING:
                removeCallbacks(mUpdateProgress);
                post(mUpdateProgress);
                resetHideCallbacks();
                updateForNonStoppedState();
                break;
            case MediaPlayerConnector.PLAYER_STATE_PAUSED:
                mPlayPauseButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_play_circle_filled, null));
                mPlayPauseButton.setContentDescription(mResources.getString(R.string.mcv2_play_button_desc));
                removeCallbacks(mUpdateProgress);
                break;
            default:
                break;
        }
        mPrevState = mPlaybackState;
    }
}
#method_after
@Override
public void onPlayerStateChanged(@NonNull MediaController2 controller, @MediaPlayerConnector.PlayerState int state) {
    if (DEBUG) {
        Log.d(TAG, "onPlayerStateChanged(state: " + state + ")");
    }
    mPlaybackState = state;
    // 2) Need to handle case where the media file reaches end of duration.
    if (mPlaybackState != mPrevState) {
        switch(mPlaybackState) {
            case MediaPlayerConnector.PLAYER_STATE_PLAYING:
                removeCallbacks(mUpdateProgress);
                post(mUpdateProgress);
                resetHideCallbacks();
                updateForStoppedState(false);
                break;
            case MediaPlayerConnector.PLAYER_STATE_PAUSED:
                mPlayPauseButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_play_circle_filled, null));
                mPlayPauseButton.setContentDescription(mResources.getString(R.string.mcv2_play_button_desc));
                removeCallbacks(mUpdateProgress);
                break;
            default:
                break;
        }
        mPrevState = mPlaybackState;
    }
}
#end_block

#method_before
@Override
public void onCurrentMediaItemChanged(@NonNull MediaController2 controller, @Nullable MediaItem2 mediaItem) {
    if (DEBUG) {
        Log.d(TAG, "onCurrentMediaItemChanged(): " + mediaItem);
    }
    if (mediaItem == null) {
        updateForStoppedState();
        // The progress bar and current time text may not have been updated.
        mProgress.setProgress(MAX_PROGRESS);
        mCurrentTime.setText(stringForTime(mDuration));
    }
}
#method_after
@Override
public void onCurrentMediaItemChanged(@NonNull MediaController2 controller, @Nullable MediaItem2 mediaItem) {
    if (DEBUG) {
        Log.d(TAG, "onCurrentMediaItemChanged(): " + mediaItem);
    }
    if (mediaItem == null) {
        updateForStoppedState(true);
        // The progress bar and current time text may not have been updated.
        mProgress.setProgress(MAX_PROGRESS);
        mCurrentTime.setText(stringForTime(mDuration));
    }
}
#end_block

#method_before
@Override
public void onPlaybackStateChanged(PlaybackStateCompat state) {
    mPlaybackState = state;
    // 2) Need to handle case where the media file reaches end of duration.
    if (mPlaybackState.getState() != mPrevState) {
        switch(mPlaybackState.getState()) {
            case PlaybackStateCompat.STATE_PLAYING:
                removeCallbacks(mUpdateProgress);
                post(mUpdateProgress);
                resetHideCallbacks();
                updateForNonStoppedState();
                break;
            case PlaybackStateCompat.STATE_PAUSED:
                mPlayPauseButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_play_circle_filled, null));
                mPlayPauseButton.setContentDescription(mResources.getString(R.string.mcv2_play_button_desc));
                break;
            case PlaybackStateCompat.STATE_STOPPED:
                updateForStoppedState();
                // The progress bar and current time text may not have been updated.
                mProgress.setProgress(MAX_PROGRESS);
                mCurrentTime.setText(stringForTime(mDuration));
                break;
            default:
                break;
        }
        mPrevState = mPlaybackState.getState();
    }
    if (mPlaybackActions != mPlaybackState.getActions()) {
        long newActions = mPlaybackState.getActions();
        if ((newActions & PlaybackStateCompat.ACTION_PAUSE) != 0) {
            mPlayPauseButton.setVisibility(View.VISIBLE);
        }
        if ((newActions & PlaybackStateCompat.ACTION_REWIND) != 0 && mMediaType != MEDIA_TYPE_MUSIC) {
            if (mRewButton != null) {
                mRewButton.setVisibility(View.VISIBLE);
            }
        }
        if ((newActions & PlaybackStateCompat.ACTION_FAST_FORWARD) != 0 && mMediaType != MEDIA_TYPE_MUSIC) {
            if (mFfwdButton != null) {
                mFfwdButton.setVisibility(View.VISIBLE);
            }
        }
        if ((newActions & PlaybackStateCompat.ACTION_SEEK_TO) != 0) {
            mSeekAvailable = true;
        } else {
            mSeekAvailable = false;
        }
        mPlaybackActions = newActions;
    }
    // Add buttons if custom actions are present.
    List<PlaybackStateCompat.CustomAction> customActions = mPlaybackState.getCustomActions();
    mCustomButtons.removeAllViews();
    if (customActions.size() > 0) {
        for (final PlaybackStateCompat.CustomAction action : customActions) {
            ImageButton button = new ImageButton(getContext(), null, /* AttributeSet */
            0);
            // Refer Constructor with argument (int defStyleRes) of View.java
            button.setImageResource(action.getIcon());
            final String actionString = action.getAction().toString();
            button.setOnClickListener(new OnClickListener() {

                @Override
                public void onClick(View v) {
                    mControls.sendCustomAction(actionString, action.getExtras());
                    setVisibility(View.VISIBLE);
                }
            });
            mCustomButtons.addView(button);
        }
    }
}
#method_after
@Override
public void onPlaybackStateChanged(PlaybackStateCompat state) {
    mPlaybackState = state;
    // 2) Need to handle case where the media file reaches end of duration.
    if (mPlaybackState.getState() != mPrevState) {
        switch(mPlaybackState.getState()) {
            case PlaybackStateCompat.STATE_PLAYING:
                removeCallbacks(mUpdateProgress);
                post(mUpdateProgress);
                resetHideCallbacks();
                updateForStoppedState(false);
                break;
            case PlaybackStateCompat.STATE_PAUSED:
                mPlayPauseButton.setImageDrawable(mResources.getDrawable(R.drawable.ic_play_circle_filled, null));
                mPlayPauseButton.setContentDescription(mResources.getString(R.string.mcv2_play_button_desc));
                break;
            case PlaybackStateCompat.STATE_STOPPED:
                updateForStoppedState(true);
                // The progress bar and current time text may not have been updated.
                mProgress.setProgress(MAX_PROGRESS);
                mCurrentTime.setText(stringForTime(mDuration));
                break;
            default:
                break;
        }
        mPrevState = mPlaybackState.getState();
    }
    if (mPlaybackActions != mPlaybackState.getActions()) {
        long newActions = mPlaybackState.getActions();
        if ((newActions & PlaybackStateCompat.ACTION_PAUSE) != 0) {
            mPlayPauseButton.setVisibility(View.VISIBLE);
        }
        if ((newActions & PlaybackStateCompat.ACTION_REWIND) != 0 && mMediaType != MEDIA_TYPE_MUSIC) {
            if (mRewButton != null) {
                mRewButton.setVisibility(View.VISIBLE);
            }
        }
        if ((newActions & PlaybackStateCompat.ACTION_FAST_FORWARD) != 0 && mMediaType != MEDIA_TYPE_MUSIC) {
            if (mFfwdButton != null) {
                mFfwdButton.setVisibility(View.VISIBLE);
            }
        }
        if ((newActions & PlaybackStateCompat.ACTION_SEEK_TO) != 0) {
            mSeekAvailable = true;
        } else {
            mSeekAvailable = false;
        }
        mPlaybackActions = newActions;
    }
    // Add buttons if custom actions are present.
    List<PlaybackStateCompat.CustomAction> customActions = mPlaybackState.getCustomActions();
    mCustomButtons.removeAllViews();
    if (customActions.size() > 0) {
        for (final PlaybackStateCompat.CustomAction action : customActions) {
            ImageButton button = new ImageButton(getContext(), null, /* AttributeSet */
            0);
            // Refer Constructor with argument (int defStyleRes) of View.java
            button.setImageResource(action.getIcon());
            final String actionString = action.getAction().toString();
            button.setOnClickListener(new OnClickListener() {

                @Override
                public void onClick(View v) {
                    mControls.sendCustomAction(actionString, action.getExtras());
                    setVisibility(View.VISIBLE);
                }
            });
            mCustomButtons.addView(button);
        }
    }
}
#end_block

#method_before
@Test
public void invalidMigration_missingFtsOption() throws Exception {
    SupportSQLiteDatabase supportSQLiteDatabase = helper.createDatabase(TEST_DB, 1);
    supportSQLiteDatabase.close();
    try {
        Context targetContext = InstrumentationRegistry.getTargetContext();
        FtsMigrationDb db = Room.databaseBuilder(targetContext, FtsMigrationDb.class, TEST_DB).addMigrations(BAD_MIGRATION_1_2, MIGRATION_2_3).build();
        helper.closeWhenFinished(db);
        db.getBookDao().getAllBooks();
        fail("Should have failed migration.");
    } catch (IllegalStateException ex) {
        assertThat(ex.getMessage(), containsString("Migration didn't properly handle"));
    }
}
#method_after
@Test
public void invalidMigration_missingFtsOption() throws Exception {
    SupportSQLiteDatabase supportSQLiteDatabase = helper.createDatabase(TEST_DB, 1);
    supportSQLiteDatabase.close();
    try {
        Context targetContext = InstrumentationRegistry.getTargetContext();
        FtsMigrationDb db = Room.databaseBuilder(targetContext, FtsMigrationDb.class, TEST_DB).addMigrations(BAD_MIGRATION_1_2, MIGRATION_2_3, MIGRATION_3_4).build();
        helper.closeWhenFinished(db);
        db.getBookDao().getAllBooks();
        fail("Should have failed migration.");
    } catch (IllegalStateException ex) {
        assertThat(ex.getMessage(), containsString("Migration didn't properly handle"));
    }
}
#end_block

#method_before
@Override
protected SupportSQLiteOpenHelper createOpenHelper(DatabaseConfiguration configuration) {
    final SupportSQLiteOpenHelper.Callback _openCallback = new RoomOpenHelper(configuration, new RoomOpenHelper.Delegate(1923) {

        @Override
        public void createAllTables(SupportSQLiteDatabase _db) {
            _db.execSQL("CREATE TABLE IF NOT EXISTS `User` (`uid` INTEGER NOT NULL, `name` TEXT, `lastName` TEXT, `ageColumn` INTEGER NOT NULL, PRIMARY KEY(`uid`))");
            _db.execSQL("CREATE TABLE IF NOT EXISTS room_master_table (id INTEGER PRIMARY KEY,identity_hash TEXT)");
            _db.execSQL("INSERT OR REPLACE INTO room_master_table (id,identity_hash) VALUES(42, \"cd8098a1e968898879c194cef2dff8f7\")");
        }

        @Override
        public void dropAllTables(SupportSQLiteDatabase _db) {
            _db.execSQL("DROP TABLE IF EXISTS `User`");
        }

        @Override
        protected void onCreate(SupportSQLiteDatabase _db) {
            if (mCallbacks != null) {
                for (int _i = 0, _size = mCallbacks.size(); _i < _size; _i++) {
                    mCallbacks.get(_i).onCreate(_db);
                }
            }
        }

        @Override
        public void onOpen(SupportSQLiteDatabase _db) {
            mDatabase = _db;
            internalInitInvalidationTracker(_db);
            if (mCallbacks != null) {
                for (int _i = 0, _size = mCallbacks.size(); _i < _size; _i++) {
                    mCallbacks.get(_i).onOpen(_db);
                }
            }
        }

        @Override
        public void onPreMigrate(SupportSQLiteDatabase _db) {
        }

        @Override
        public void onPostMigrate(SupportSQLiteDatabase _db) {
        }

        @Override
        protected void validateMigration(SupportSQLiteDatabase _db) {
            final HashMap<String, TableInfo.Column> _columnsUser = new HashMap<String, TableInfo.Column>(4);
            _columnsUser.put("uid", new TableInfo.Column("uid", "INTEGER", true, 1));
            _columnsUser.put("name", new TableInfo.Column("name", "TEXT", false, 0));
            _columnsUser.put("lastName", new TableInfo.Column("lastName", "TEXT", false, 0));
            _columnsUser.put("ageColumn", new TableInfo.Column("ageColumn", "INTEGER", true, 0));
            final HashSet<TableInfo.ForeignKey> _foreignKeysUser = new HashSet<TableInfo.ForeignKey>(0);
            final HashSet<TableInfo.Index> _indicesUser = new HashSet<TableInfo.Index>(0);
            final TableInfo _infoUser = new TableInfo("User", _columnsUser, _foreignKeysUser, _indicesUser);
            final TableInfo _existingUser = TableInfo.read(_db, "User");
            if (!_infoUser.equals(_existingUser)) {
                throw new IllegalStateException("Migration didn't properly handle User(foo.bar.User).\n" + " Expected:\n" + _infoUser + "\n" + " Found:\n" + _existingUser);
            }
        }
    }, "cd8098a1e968898879c194cef2dff8f7", "6773601c5bcf94c71ee4eb0de04f21a4");
    final SupportSQLiteOpenHelper.Configuration _sqliteConfig = SupportSQLiteOpenHelper.Configuration.builder(configuration.context).name(configuration.name).callback(_openCallback).build();
    final SupportSQLiteOpenHelper _helper = configuration.sqliteOpenHelperFactory.create(_sqliteConfig);
    return _helper;
}
#method_after
@Override
protected SupportSQLiteOpenHelper createOpenHelper(DatabaseConfiguration configuration) {
    final SupportSQLiteOpenHelper.Callback _openCallback = new RoomOpenHelper(configuration, new RoomOpenHelper.Delegate(1923) {

        @Override
        public void createAllTables(SupportSQLiteDatabase _db) {
            _db.execSQL("CREATE TABLE IF NOT EXISTS `User` (`uid` INTEGER NOT NULL, `name` TEXT, `lastName` TEXT, `ageColumn` INTEGER NOT NULL, PRIMARY KEY(`uid`))");
            _db.execSQL("CREATE TABLE IF NOT EXISTS room_master_table (id INTEGER PRIMARY KEY,identity_hash TEXT)");
            _db.execSQL("INSERT OR REPLACE INTO room_master_table (id,identity_hash) VALUES(42, \"cd8098a1e968898879c194cef2dff8f7\")");
        }

        @Override
        public void dropAllTables(SupportSQLiteDatabase _db) {
            _db.execSQL("DROP TABLE IF EXISTS `User`");
        }

        @Override
        protected void onCreate(SupportSQLiteDatabase _db) {
            if (mCallbacks != null) {
                for (int _i = 0, _size = mCallbacks.size(); _i < _size; _i++) {
                    mCallbacks.get(_i).onCreate(_db);
                }
            }
        }

        @Override
        public void onOpen(SupportSQLiteDatabase _db) {
            mDatabase = _db;
            internalInitInvalidationTracker(_db);
            if (mCallbacks != null) {
                for (int _i = 0, _size = mCallbacks.size(); _i < _size; _i++) {
                    mCallbacks.get(_i).onOpen(_db);
                }
            }
        }

        @Override
        public void onPreMigrate(SupportSQLiteDatabase _db) {
            DBUtil.dropFtsSyncTriggers(_db);
        }

        @Override
        public void onPostMigrate(SupportSQLiteDatabase _db) {
        }

        @Override
        protected void validateMigration(SupportSQLiteDatabase _db) {
            final HashMap<String, TableInfo.Column> _columnsUser = new HashMap<String, TableInfo.Column>(4);
            _columnsUser.put("uid", new TableInfo.Column("uid", "INTEGER", true, 1));
            _columnsUser.put("name", new TableInfo.Column("name", "TEXT", false, 0));
            _columnsUser.put("lastName", new TableInfo.Column("lastName", "TEXT", false, 0));
            _columnsUser.put("ageColumn", new TableInfo.Column("ageColumn", "INTEGER", true, 0));
            final HashSet<TableInfo.ForeignKey> _foreignKeysUser = new HashSet<TableInfo.ForeignKey>(0);
            final HashSet<TableInfo.Index> _indicesUser = new HashSet<TableInfo.Index>(0);
            final TableInfo _infoUser = new TableInfo("User", _columnsUser, _foreignKeysUser, _indicesUser);
            final TableInfo _existingUser = TableInfo.read(_db, "User");
            if (!_infoUser.equals(_existingUser)) {
                throw new IllegalStateException("Migration didn't properly handle User(foo.bar.User).\n" + " Expected:\n" + _infoUser + "\n" + " Found:\n" + _existingUser);
            }
        }
    }, "cd8098a1e968898879c194cef2dff8f7", "6773601c5bcf94c71ee4eb0de04f21a4");
    final SupportSQLiteOpenHelper.Configuration _sqliteConfig = SupportSQLiteOpenHelper.Configuration.builder(configuration.context).name(configuration.name).callback(_openCallback).build();
    final SupportSQLiteOpenHelper _helper = configuration.sqliteOpenHelperFactory.create(_sqliteConfig);
    return _helper;
}
#end_block

#method_before
public Collection<String> buildCreateQueries() {
    List<String> result = new ArrayList<>();
    result.add(createTable());
    result.addAll(mContentSyncSqlTriggers);
    return result;
}
#method_after
@Override
public Collection<String> buildCreateQueries() {
    List<String> result = new ArrayList<>();
    result.add(createTable());
    result.addAll(mContentSyncSqlTriggers);
    return result;
}
#end_block

#method_before
private JavaSimpleType parseSimpleTypeValue(XsdSimpleType simpleType, boolean traverse) throws JavaCodeGeneratorException {
    if (simpleType instanceof XsdList) {
        XsdList list = (XsdList) simpleType;
        return parseSimpleType(list.getItemType(), traverse).newListType();
    } else if (simpleType instanceof XsdRestriction) {
        // we don't consider any restrictions.
        XsdRestriction restriction = (XsdRestriction) simpleType;
        return parseSimpleType(restriction.getBase(), traverse);
    } else if (simpleType instanceof XsdUnion) {
        // unions are almost always interpreted as java.lang.String
        // Exceptionally, if any of member types of union are 'list', then we interpret it as
        // List<String>
        XsdUnion union = (XsdUnion) simpleType;
        for (XsdType memberType : union.getMemberTypes()) {
            if (parseSimpleType(memberType, traverse).isList()) {
                return new JavaSimpleType("java.lang.String", "java.lang.String", "%s", true);
            }
        }
        return new JavaSimpleType("java.lang.String", "java.lang.String", "%s", false);
    } else {
        // unreachable
        throw new IllegalStateException("unknown simple type");
    }
}
#method_after
private JavaSimpleType parseSimpleTypeValue(XsdSimpleType simpleType, boolean traverse) throws JavaCodeGeneratorException {
    if (simpleType instanceof XsdList) {
        XsdList list = (XsdList) simpleType;
        return parseSimpleType(list.getItemType(), traverse).newListType();
    } else if (simpleType instanceof XsdRestriction) {
        // we don't consider any restrictions.
        XsdRestriction restriction = (XsdRestriction) simpleType;
        return parseSimpleType(restriction.getBase(), traverse);
    } else if (simpleType instanceof XsdUnion) {
        // unions are almost always interpreted as java.lang.String
        // Exceptionally, if any of member types of union are 'list', then we interpret it as
        // List<String>
        XsdUnion union = (XsdUnion) simpleType;
        for (XsdType memberType : union.getMemberTypes()) {
            if (parseSimpleType(memberType, traverse).isList()) {
                return new JavaSimpleType("java.lang.String", "%s", true);
            }
        }
        return new JavaSimpleType("java.lang.String", "%s", false);
    } else {
        // unreachable
        throw new IllegalStateException("unknown simple type");
    }
}
#end_block

#method_before
private static JavaSimpleType predefinedType(String name) throws JavaCodeGeneratorException {
    switch(name) {
        case "string":
        case "token":
        case "normalizedString":
        case "language":
        case "ENTITY":
        case "ID":
        case "Name":
        case "NCName":
        case "NMTOKEN":
        case "anyURI":
        case "anyType":
        case "QName":
        case "NOTATION":
        case "IDREF":
            return new JavaSimpleType("java.lang.String", "java.lang.String", "%s", false);
        case "ENTITIES":
        case "NMTOKENS":
        case "IDREFS":
            return new JavaSimpleType("java.lang.String", "java.lang.String", "%s", true);
        case "date":
        case "dateTime":
        case "time":
        case "gDay":
        case "gMonth":
        case "gYear":
        case "gMonthDay":
        case "gYearMonth":
            return new JavaSimpleType("javax.xml.datatype.XMLGregorianCalendar", "javax.xml.datatype.XMLGregorianCalendar", "javax.xml.datatype.DatatypeFactory.newInstance()" + ".newXMLGregorianCalendar(%s)", false);
        case "duration":
            return new JavaSimpleType("javax.xml.datatype.Duration", "javax.xml.datatype.Duration", "javax.xml.datatype.DatatypeFactory.newInstance().newDuration(%s)", false);
        case "decimal":
            return new JavaSimpleType("java.math.BigDecimal", "java.math.BigDecimal", "new java.math.BigDecimal(%s)", false);
        case "integer":
        case "negativeInteger":
        case "nonNegativeInteger":
        case "positiveInteger":
        case "nonPositiveInteger":
        case "unsignedLong":
            return new JavaSimpleType("java.math.BigInteger", "java.math.BigInteger", "new java.math.BigInteger(%s)", false);
        case "long":
        case "unsignedInt":
            return new JavaSimpleType("long", "java.lang.Long", "Long.parseLong(%s)", false);
        case "int":
        case "unsignedShort":
            return new JavaSimpleType("int", "java.lang.Integer", "Integer.parseInt(%s)", false);
        case "short":
        case "unsignedByte":
            return new JavaSimpleType("short", "java.lang.Short", "Short.parseShort(%s)", false);
        case "byte":
            return new JavaSimpleType("byte", "java.lang.Byte", "Byte.parseByte(%s)", false);
        case "boolean":
            return new JavaSimpleType("boolean", "java.lang.Boolean", "Boolean.parseBoolean(%s)", false);
        case "double":
            return new JavaSimpleType("double", "java.lang.Double", "Double.parseDouble(%s)", false);
        case "float":
            return new JavaSimpleType("float", "java.lang.Float", "Float.parseFloat(%s)", false);
        case "base64Binary":
            return new JavaSimpleType("byte[]", "byte[]", "java.util.Base64.getDecoder().decode(%s)", false);
        case "hexBinary":
            return new JavaSimpleType("java.math.BigInteger", "java.math.BigInteger", "new java.math.BigInteger(%s, 16)", false);
    }
    throw new JavaCodeGeneratorException("unknown xsd predefined type : " + name);
}
#method_after
private static JavaSimpleType predefinedType(String name) throws JavaCodeGeneratorException {
    switch(name) {
        case "string":
        case "token":
        case "normalizedString":
        case "language":
        case "ENTITY":
        case "ID":
        case "Name":
        case "NCName":
        case "NMTOKEN":
        case "anyURI":
        case "anyType":
        case "QName":
        case "NOTATION":
        case "IDREF":
            return new JavaSimpleType("java.lang.String", "%s", false);
        case "ENTITIES":
        case "NMTOKENS":
        case "IDREFS":
            return new JavaSimpleType("java.lang.String", "%s", true);
        case "date":
        case "dateTime":
        case "time":
        case "gDay":
        case "gMonth":
        case "gYear":
        case "gMonthDay":
        case "gYearMonth":
            return new JavaSimpleType("javax.xml.datatype.XMLGregorianCalendar", "javax.xml.datatype.DatatypeFactory.newInstance()" + ".newXMLGregorianCalendar(%s)", false);
        case "duration":
            return new JavaSimpleType("javax.xml.datatype.Duration", "javax.xml.datatype.DatatypeFactory.newInstance().newDuration(%s)", false);
        case "decimal":
            return new JavaSimpleType("java.math.BigDecimal", "new java.math.BigDecimal(%s)", false);
        case "integer":
        case "negativeInteger":
        case "nonNegativeInteger":
        case "positiveInteger":
        case "nonPositiveInteger":
        case "unsignedLong":
            return new JavaSimpleType("java.math.BigInteger", "new java.math.BigInteger(%s)", false);
        case "long":
        case "unsignedInt":
            return new JavaSimpleType("long", "java.lang.Long", "Long.parseLong(%s)", false);
        case "int":
        case "unsignedShort":
            return new JavaSimpleType("int", "java.lang.Integer", "Integer.parseInt(%s)", false);
        case "short":
        case "unsignedByte":
            return new JavaSimpleType("short", "java.lang.Short", "Short.parseShort(%s)", false);
        case "byte":
            return new JavaSimpleType("byte", "java.lang.Byte", "Byte.parseByte(%s)", false);
        case "boolean":
            return new JavaSimpleType("boolean", "java.lang.Boolean", "Boolean.parseBoolean(%s)", false);
        case "double":
            return new JavaSimpleType("double", "java.lang.Double", "Double.parseDouble(%s)", false);
        case "float":
            return new JavaSimpleType("float", "java.lang.Float", "Float.parseFloat(%s)", false);
        case "base64Binary":
            return new JavaSimpleType("byte[]", "java.util.Base64.getDecoder().decode(%s)", false);
        case "hexBinary":
            return new JavaSimpleType("java.math.BigInteger", "new java.math.BigInteger(%s, 16)", false);
    }
    throw new JavaCodeGeneratorException("unknown xsd predefined type : " + name);
}
#end_block

#method_before
@Override
public String getName() {
    return list ? String.format("java.util.List<%s>", nullableName) : name;
}
#method_after
@Override
public String getName() {
    return fullName;
}
#end_block

#method_before
@Override
public String getNullableName() {
    return list ? String.format("java.util.List<%s>", nullableName) : nullableName;
}
#method_after
@Override
public String getNullableName() {
    return nullableFullName;
}
#end_block

#method_before
private void runWorker() {
    if (tryCheckForInterruptionAndNotify()) {
        return;
    }
    mWorkDatabase.beginTransaction();
    try {
        mWorkSpec = mWorkSpecDao.getWorkSpec(mWorkSpecId);
        if (mWorkSpec == null) {
            Logger.error(TAG, String.format("Didn't find WorkSpec for id %s", mWorkSpecId));
            notifyListener(false, false);
            return;
        }
        // running, finished, or is blocked.
        if (mWorkSpec.state != ENQUEUED) {
            notifyIncorrectStatus();
            mWorkDatabase.setTransactionSuccessful();
            return;
        }
        // Needed for nested transactions, such as when we're in a dependent work request when
        // using a SynchronousExecutor.
        mWorkDatabase.setTransactionSuccessful();
    } finally {
        mWorkDatabase.endTransaction();
    }
    // Merge inputs.  This can be potentially expensive code, so this should not be done inside
    // a database transaction.
    Data input;
    if (mWorkSpec.isPeriodic()) {
        input = mWorkSpec.input;
    } else {
        InputMerger inputMerger = InputMerger.fromClassName(mWorkSpec.inputMergerClassName);
        if (inputMerger == null) {
            Logger.error(TAG, String.format("Could not create Input Merger %s", mWorkSpec.inputMergerClassName));
            setFailedAndNotify();
            return;
        }
        List<Data> inputs = new ArrayList<>();
        inputs.add(mWorkSpec.input);
        inputs.addAll(mWorkSpecDao.getInputsFromPrerequisites(mWorkSpecId));
        input = inputMerger.merge(inputs);
    }
    Extras extras = new Extras(input, mTags, mRuntimeExtras, mWorkSpec.runAttemptCount);
    // in test mode.
    if (mWorker == null) {
        mWorker = workerFromWorkSpec(mAppContext, mWorkSpec, extras);
    }
    if (mWorker == null) {
        Logger.error(TAG, String.format("Could for create Worker %s", mWorkSpec.workerClassName));
        setFailedAndNotify();
        return;
    }
    // may have modified the DB since we checked last at the top of this function.
    if (trySetRunning()) {
        if (tryCheckForInterruptionAndNotify()) {
            return;
        }
        final SettableFuture<Pair<Result, Data>> future = SettableFuture.create();
        try {
            final ListenableFuture<Pair<Result, Data>> innerFuture = mWorker.onStartWork();
            future.setFuture(innerFuture);
        } catch (Throwable e) {
            future.setException(e);
        }
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    onWorkFinished(future.get().first);
                } catch (InterruptedException | ExecutionException exception) {
                    Logger.error(TAG, String.format("%s failed because it threw an exception/error", mWorkDescription), exception);
                    onWorkFinished(Result.FAILURE);
                }
            }
        }, mWorkTaskExecutor.getBackgroundExecutor());
    } else {
        notifyIncorrectStatus();
    }
}
#method_after
private void runWorker() {
    if (tryCheckForInterruptionAndNotify()) {
        return;
    }
    mWorkDatabase.beginTransaction();
    try {
        mWorkSpec = mWorkSpecDao.getWorkSpec(mWorkSpecId);
        if (mWorkSpec == null) {
            Logger.error(TAG, String.format("Didn't find WorkSpec for id %s", mWorkSpecId));
            notifyListener(false, false);
            return;
        }
        // running, finished, or is blocked.
        if (mWorkSpec.state != ENQUEUED) {
            notifyIncorrectStatus();
            mWorkDatabase.setTransactionSuccessful();
            return;
        }
        // Needed for nested transactions, such as when we're in a dependent work request when
        // using a SynchronousExecutor.
        mWorkDatabase.setTransactionSuccessful();
    } finally {
        mWorkDatabase.endTransaction();
    }
    // Merge inputs.  This can be potentially expensive code, so this should not be done inside
    // a database transaction.
    Data input;
    if (mWorkSpec.isPeriodic()) {
        input = mWorkSpec.input;
    } else {
        InputMerger inputMerger = InputMerger.fromClassName(mWorkSpec.inputMergerClassName);
        if (inputMerger == null) {
            Logger.error(TAG, String.format("Could not create Input Merger %s", mWorkSpec.inputMergerClassName));
            setFailedAndNotify();
            return;
        }
        List<Data> inputs = new ArrayList<>();
        inputs.add(mWorkSpec.input);
        inputs.addAll(mWorkSpecDao.getInputsFromPrerequisites(mWorkSpecId));
        input = inputMerger.merge(inputs);
    }
    Extras extras = new Extras(input, mTags, mRuntimeExtras, mWorkSpec.runAttemptCount);
    // in test mode.
    if (mWorker == null) {
        mWorker = workerFromWorkSpec(mAppContext, mWorkSpec, extras);
    }
    if (mWorker == null) {
        Logger.error(TAG, String.format("Could for create Worker %s", mWorkSpec.workerClassName));
        setFailedAndNotify();
        return;
    }
    // may have modified the DB since we checked last at the top of this function.
    if (trySetRunning()) {
        if (tryCheckForInterruptionAndNotify()) {
            return;
        }
        final SettableFuture<Pair<Result, Data>> future = SettableFuture.create();
        try {
            final ListenableFuture<Pair<Result, Data>> innerFuture = mWorker.onStartWork();
            future.setFuture(innerFuture);
        } catch (Throwable e) {
            future.setException(e);
        }
        // Avoid synthetic accessors.
        final String workDescription = mWorkDescription;
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    onWorkFinished(future.get().first);
                } catch (InterruptedException | ExecutionException exception) {
                    Logger.error(TAG, String.format("%s failed because it threw an exception/error", workDescription), exception);
                    onWorkFinished(Result.FAILURE);
                }
            }
        }, mWorkTaskExecutor.getBackgroundExecutor());
    } else {
        notifyIncorrectStatus();
    }
}
#end_block

#method_before
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
public void onWorkFinished(@NonNull Result result) {
    if (!tryCheckForInterruptionAndNotify()) {
        try {
            mWorkDatabase.beginTransaction();
            State state = mWorkSpecDao.getState(mWorkSpecId);
            if (state == null) {
                // state can be null here with a REPLACE on beginUniqueWork().
                // Treat it as a failure, and rescheduleAndNotify() will
                // turn into a no-op. We still need to notify potential observers
                // holding on to wake locks on our behalf.
                notifyListener(false, false);
            } else if (state == RUNNING) {
                handleResult(result);
            } else if (!state.isFinished()) {
                rescheduleAndNotify();
            }
            mWorkDatabase.setTransactionSuccessful();
        } finally {
            mWorkDatabase.endTransaction();
        }
    }
    // Try to schedule any newly-unblocked workers, and workers requiring rescheduling (such as
    // periodic work using AlarmManager).  This code runs after runWorker() because it should
    // happen in its own transaction.
    boolean isFinished = mWorkSpec.state.isFinished();
    // that it should remove this job and AlarmManager should remove all related alarms.
    if (isFinished) {
        for (Scheduler scheduler : mSchedulers) {
            scheduler.cancel(mWorkSpecId);
        }
    }
    Schedulers.schedule(mConfiguration, mWorkDatabase, mSchedulers);
}
#method_after
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
public void onWorkFinished(@NonNull Result result) {
    assertBackgroundExecutorThread();
    if (!tryCheckForInterruptionAndNotify()) {
        try {
            mWorkDatabase.beginTransaction();
            State state = mWorkSpecDao.getState(mWorkSpecId);
            if (state == null) {
                // state can be null here with a REPLACE on beginUniqueWork().
                // Treat it as a failure, and rescheduleAndNotify() will
                // turn into a no-op. We still need to notify potential observers
                // holding on to wake locks on our behalf.
                notifyListener(false, false);
            } else if (state == RUNNING) {
                handleResult(result);
            } else if (!state.isFinished()) {
                rescheduleAndNotify();
            }
            mWorkDatabase.setTransactionSuccessful();
        } finally {
            mWorkDatabase.endTransaction();
        }
    }
    // Try to schedule any newly-unblocked workers, and workers requiring rescheduling (such as
    // periodic work using AlarmManager).  This code runs after runWorker() because it should
    // happen in its own transaction.
    boolean isFinished = mWorkSpec.state.isFinished();
    // that it should remove this job and AlarmManager should remove all related alarms.
    if (isFinished) {
        for (Scheduler scheduler : mSchedulers) {
            scheduler.cancel(mWorkSpecId);
        }
    }
    Schedulers.schedule(mConfiguration, mWorkDatabase, mSchedulers);
}
#end_block

#method_before
@CddTest(requirement = "7.1.1.1/H-0-1,W-0-1,7.1.2/C-1-1")
@Presubmit
public void testScreenConfiguration() {
    WindowManager windowManager = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
    Display display = windowManager.getDefaultDisplay();
    DisplayMetrics metrics = new DisplayMetrics();
    display.getMetrics(metrics);
    double xInches = (double) metrics.widthPixels / metrics.xdpi;
    double yInches = (double) metrics.heightPixels / metrics.ydpi;
    double diagonalInches = Math.sqrt(Math.pow(xInches, 2) + Math.pow(yInches, 2));
    double minSize = 2.5d;
    if (getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
        // Watches have a different minimum diagonal.
        minSize = 1.0d;
    }
    assertTrue("Screen diagonal must be at least " + minSize + " inches: " + diagonalInches, diagonalInches >= minSize);
    double density = 160.0d * metrics.density;
    assertTrue("Screen density must be at least 100 dpi: " + density, density >= 100.0d);
    Set<Integer> allowedDensities = new HashSet<Integer>();
    allowedDensities.add(DisplayMetrics.DENSITY_LOW);
    allowedDensities.add(DisplayMetrics.DENSITY_MEDIUM);
    allowedDensities.add(DisplayMetrics.DENSITY_TV);
    allowedDensities.add(DisplayMetrics.DENSITY_HIGH);
    allowedDensities.add(DisplayMetrics.DENSITY_260);
    allowedDensities.add(DisplayMetrics.DENSITY_280);
    allowedDensities.add(DisplayMetrics.DENSITY_300);
    allowedDensities.add(DisplayMetrics.DENSITY_XHIGH);
    allowedDensities.add(DisplayMetrics.DENSITY_340);
    allowedDensities.add(DisplayMetrics.DENSITY_360);
    allowedDensities.add(DisplayMetrics.DENSITY_400);
    allowedDensities.add(DisplayMetrics.DENSITY_420);
    allowedDensities.add(DisplayMetrics.DENSITY_XXHIGH);
    allowedDensities.add(DisplayMetrics.DENSITY_560);
    allowedDensities.add(DisplayMetrics.DENSITY_XXXHIGH);
    assertTrue("DisplayMetrics#densityDpi must be one of the DisplayMetrics.DENSITY_* values: " + allowedDensities, allowedDensities.contains(metrics.densityDpi));
    assertEquals(metrics.density, (float) metrics.densityDpi / DisplayMetrics.DENSITY_DEFAULT, 0.5f / DisplayMetrics.DENSITY_DEFAULT);
}
#method_after
@CddTest(requirement = "7.1.1.1/H-0-1,W-0-1,7.1.1.3/C-0-1,7.1.2/C-1-1")
@Presubmit
public void testScreenConfiguration() {
    WindowManager windowManager = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
    Display display = windowManager.getDefaultDisplay();
    DisplayMetrics metrics = new DisplayMetrics();
    display.getMetrics(metrics);
    double xInches = (double) metrics.widthPixels / metrics.xdpi;
    double yInches = (double) metrics.heightPixels / metrics.ydpi;
    double diagonalInches = Math.sqrt(Math.pow(xInches, 2) + Math.pow(yInches, 2));
    double minSize = 2.5d;
    if (getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
        // Watches have a different minimum diagonal.
        minSize = 1.0d;
    }
    assertTrue("Screen diagonal must be at least " + minSize + " inches: " + diagonalInches, diagonalInches >= minSize);
    double density = 160.0d * metrics.density;
    assertTrue("Screen density must be at least 100 dpi: " + density, density >= 100.0d);
    Set<Integer> allowedDensities = new HashSet<Integer>();
    allowedDensities.add(DisplayMetrics.DENSITY_LOW);
    allowedDensities.add(DisplayMetrics.DENSITY_MEDIUM);
    allowedDensities.add(DisplayMetrics.DENSITY_TV);
    allowedDensities.add(DisplayMetrics.DENSITY_HIGH);
    allowedDensities.add(DisplayMetrics.DENSITY_260);
    allowedDensities.add(DisplayMetrics.DENSITY_280);
    allowedDensities.add(DisplayMetrics.DENSITY_300);
    allowedDensities.add(DisplayMetrics.DENSITY_XHIGH);
    allowedDensities.add(DisplayMetrics.DENSITY_340);
    allowedDensities.add(DisplayMetrics.DENSITY_360);
    allowedDensities.add(DisplayMetrics.DENSITY_400);
    allowedDensities.add(DisplayMetrics.DENSITY_420);
    allowedDensities.add(DisplayMetrics.DENSITY_XXHIGH);
    allowedDensities.add(DisplayMetrics.DENSITY_560);
    allowedDensities.add(DisplayMetrics.DENSITY_XXXHIGH);
    assertTrue("DisplayMetrics#densityDpi must be one of the DisplayMetrics.DENSITY_* values: " + allowedDensities, allowedDensities.contains(metrics.densityDpi));
    assertEquals(metrics.density, (float) metrics.densityDpi / DisplayMetrics.DENSITY_DEFAULT, 0.5f / DisplayMetrics.DENSITY_DEFAULT);
}
#end_block

#method_before
public void setToken(IBinder token) {
    switch(mWindowState) {
        case SoftInputWindowState.WAITING_TOKEN:
            // This is the only expected scenario.
            WindowManager.LayoutParams lp = getWindow().getAttributes();
            lp.token = token;
            getWindow().setAttributes(lp);
            mWindowState = SoftInputWindowState.TOKEN_SET;
            break;
        case SoftInputWindowState.TOKEN_SET:
        case SoftInputWindowState.SHOWN_AT_LEAST_ONCE:
        case SoftInputWindowState.REJECTED_AT_LEAST_ONCE:
            throw new IllegalStateException("setToken can be called only once");
        default:
            throw new IllegalStateException("Unexpected state=" + mWindowState);
    }
}
#method_after
public void setToken(IBinder token) {
    switch(mWindowState) {
        case SoftInputWindowState.TOKEN_PENDING:
            // Normal scenario.  Nothing to worry about.
            WindowManager.LayoutParams lp = getWindow().getAttributes();
            lp.token = token;
            getWindow().setAttributes(lp);
            updateWindowState(SoftInputWindowState.TOKEN_SET);
            return;
        case SoftInputWindowState.TOKEN_SET:
        case SoftInputWindowState.SHOWN_AT_LEAST_ONCE:
        case SoftInputWindowState.REJECTED_AT_LEAST_ONCE:
            throw new IllegalStateException("setToken can be called only once");
        case SoftInputWindowState.DESTROYED:
            // Just ignore.  Since there are multiple event queues from the token is issued
            // in the system server to the timing when it arrives here, it can be delivered
            // after the is already destroyed.  No one should be blamed because of such an
            // unfortunate but possible scenario.
            Log.i(TAG, "Ignoring setToken() because window is already destroyed.");
            return;
        default:
            throw new IllegalStateException("Unexpected state=" + mWindowState);
    }
}
#end_block

#method_before
@Override
public final void show() {
    switch(mWindowState) {
        case SoftInputWindowState.WAITING_TOKEN:
            throw new IllegalStateException("Window token is not set yet.");
        case SoftInputWindowState.TOKEN_SET:
        case SoftInputWindowState.SHOWN_AT_LEAST_ONCE:
            try {
                super.show();
            } catch (WindowManager.BadTokenException e) {
                mWindowState = SoftInputWindowState.REJECTED_AT_LEAST_ONCE;
            }
            break;
        case SoftInputWindowState.REJECTED_AT_LEAST_ONCE:
            // nothing we can safely do anymore because WMS has already denied show().
            break;
        default:
            throw new IllegalStateException("Unexpected state=" + mWindowState);
    }
}
#method_after
@Override
public final void show() {
    switch(mWindowState) {
        case SoftInputWindowState.TOKEN_PENDING:
            throw new IllegalStateException("Window token is not set yet.");
        case SoftInputWindowState.TOKEN_SET:
        case SoftInputWindowState.SHOWN_AT_LEAST_ONCE:
            // Normal scenario.  Nothing to worry about.
            try {
                super.show();
                updateWindowState(SoftInputWindowState.SHOWN_AT_LEAST_ONCE);
            } catch (WindowManager.BadTokenException e) {
                // Just ignore this exception.  Since show() can be requested from other
                // components such as the system and there could be multiple event queues before
                // the request finally arrives here, the system may have already invalidated the
                // window token attached to our window.  In such a scenario, receiving
                // BadTokenException here is an expected behavior.  We just ignore it and update
                // the state so that we do not touch this window later.
                Log.i(TAG, "Probably the IME window token is already invalidated." + " show() does nothing.");
                updateWindowState(SoftInputWindowState.REJECTED_AT_LEAST_ONCE);
            }
            return;
        case SoftInputWindowState.REJECTED_AT_LEAST_ONCE:
            // Just ignore.  In general we cannot completely avoid this kind of race condition.
            Log.i(TAG, "Not trying to call show() because it was already rejected once.");
            return;
        case SoftInputWindowState.DESTROYED:
            // Just ignore.  In general we cannot completely avoid this kind of race condition.
            Log.i(TAG, "Ignoring show() because the window is already destroyed.");
            return;
        default:
            throw new IllegalStateException("Unexpected state=" + mWindowState);
    }
}
#end_block

#method_before
final void dismissForDestroyIfNecessary() {
    switch(mWindowState) {
        case SoftInputWindowState.WAITING_TOKEN:
        case SoftInputWindowState.TOKEN_SET:
            // nothing to do because the window has never been shown.
            break;
        case SoftInputWindowState.SHOWN_AT_LEAST_ONCE:
            // when the current IME is being switched to another one.
            try {
                getWindow().setWindowAnimations(0);
                dismiss();
            } catch (WindowManager.BadTokenException e) {
                mWindowState = SoftInputWindowState.REJECTED_AT_LEAST_ONCE;
            }
            break;
        case SoftInputWindowState.REJECTED_AT_LEAST_ONCE:
            // nothing we can safely do anymore because WMS has already denied show().
            break;
        default:
            throw new IllegalStateException("Unexpected state=" + mWindowState);
    }
}
#method_after
final void dismissForDestroyIfNecessary() {
    switch(mWindowState) {
        case SoftInputWindowState.TOKEN_PENDING:
        case SoftInputWindowState.TOKEN_SET:
            // nothing to do because the window has never been shown.
            updateWindowState(SoftInputWindowState.DESTROYED);
            return;
        case SoftInputWindowState.SHOWN_AT_LEAST_ONCE:
            // when the current IME is being switched to another one.
            try {
                getWindow().setWindowAnimations(0);
                dismiss();
            } catch (WindowManager.BadTokenException e) {
                // Just ignore this exception.  Since show() can be requested from other
                // components such as the system and there could be multiple event queues before
                // the request finally arrives here, the system may have already invalidated the
                // window token attached to our window.  In such a scenario, receiving
                // BadTokenException here is an expected behavior.  We just ignore it and update
                // the state so that we do not touch this window later.
                Log.i(TAG, "Probably the IME window token is already invalidated. " + "No need to dismiss it.");
            }
            // Either way, consider that the window is destroyed.
            updateWindowState(SoftInputWindowState.DESTROYED);
            return;
        case SoftInputWindowState.REJECTED_AT_LEAST_ONCE:
            // Just ignore.  In general we cannot completely avoid this kind of race condition.
            Log.i(TAG, "Not trying to dismiss the window because it is most likely unnecessary.");
            // Anyway, consider that the window is destroyed.
            updateWindowState(SoftInputWindowState.DESTROYED);
            return;
        case SoftInputWindowState.DESTROYED:
            throw new IllegalStateException("dismissForDestroyIfNecessary can be called only once");
        default:
            throw new IllegalStateException("Unexpected state=" + mWindowState);
    }
}
#end_block

#method_before
private static SupportMenu createMenu(final TextView textView, final BackgroundSpan highlight, List<RemoteActionCompat> actions) {
    final MenuBuilder menu = new MenuBuilder(textView.getContext());
    final Map<MenuItem, PendingIntent> menuActions = new ArrayMap<>();
    final int size = actions.size();
    for (int i = 0; i < size; i++) {
        final RemoteActionCompat action = actions.get(i);
        final MenuItem item = menu.add(FloatingToolbar.MENU_ID_SMART_ACTION, /* groupId */
        i == 0 ? FloatingToolbar.MENU_ID_SMART_ACTION : i, /* itemId */
        i == 0 ? 0 : ORDER_START + i, /* order */
        action.getTitle());
        if (action.shouldShowIcon()) {
            item.setIcon(action.getIcon().loadDrawable(textView.getContext()));
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            item.setContentDescription(action.getContentDescription());
        }
        item.setShowAsAction(i == 0 ? MenuItem.SHOW_AS_ACTION_ALWAYS : MenuItem.SHOW_AS_ACTION_NEVER);
        menuActions.put(item, action.getActionIntent());
    }
    menu.add(Menu.NONE, android.R.id.copy, 1, android.R.string.copy).setAlphabeticShortcut('c').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
    menu.add(Menu.NONE, android.R.id.shareText, 2, R.string.abc_share).setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
    menu.setCallback(new MenuBuilder.Callback() {

        @Override
        public boolean onMenuItemSelected(MenuBuilder menu, MenuItem item) {
            final PendingIntent intent = menuActions.get(item);
            if (intent != null) {
                try {
                    intent.send();
                } catch (PendingIntent.CanceledException e) {
                    Log.e(LOG_TAG, "Error performing smart action", e);
                }
            } else {
                switch(item.getItemId()) {
                    case android.R.id.copy:
                        copyText();
                        break;
                    case android.R.id.shareText:
                        shareText();
                        break;
                }
            }
            return true;
        }

        @Override
        public void onMenuModeChange(MenuBuilder menu) {
        }

        private void copyText() {
            final ClipboardManager clipboard = textView.getContext().getSystemService(ClipboardManager.class);
            final String text = getHighlightedText(textView, highlight);
            if (clipboard != null && text != null) {
                try {
                    clipboard.setPrimaryClip(ClipData.newPlainText(null, text));
                } catch (Throwable t) {
                    Log.d(LOG_TAG, "Error copying text: " + t.getMessage());
                }
            }
        }

        private void shareText() {
            final String text = getHighlightedText(textView, highlight);
            if (text != null) {
                final Intent sharingIntent = new Intent(android.content.Intent.ACTION_SEND);
                sharingIntent.setType("text/plain");
                sharingIntent.removeExtra(android.content.Intent.EXTRA_TEXT);
                sharingIntent.putExtra(android.content.Intent.EXTRA_TEXT, text);
                textView.getContext().startActivity(Intent.createChooser(sharingIntent, null));
            }
        }
    });
    return menu;
}
#method_after
private static SupportMenu createMenu(final TextView textView, final BackgroundSpan highlight, List<RemoteActionCompat> actions) {
    final MenuBuilder menu = new MenuBuilder(textView.getContext());
    final Map<MenuItem, PendingIntent> menuActions = new ArrayMap<>();
    final int size = actions.size();
    for (int i = 0; i < size; i++) {
        final RemoteActionCompat action = actions.get(i);
        final MenuItem item = menu.add(FloatingToolbar.MENU_ID_SMART_ACTION, /* groupId */
        i == 0 ? FloatingToolbar.MENU_ID_SMART_ACTION : i, /* itemId */
        i == 0 ? 0 : ORDER_START + i, /* order */
        action.getTitle());
        if (action.shouldShowIcon()) {
            item.setIcon(action.getIcon().loadDrawable(textView.getContext()));
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            item.setContentDescription(action.getContentDescription());
        }
        item.setShowAsAction(i == 0 ? MenuItem.SHOW_AS_ACTION_ALWAYS : MenuItem.SHOW_AS_ACTION_NEVER);
        menuActions.put(item, action.getActionIntent());
    }
    menu.add(Menu.NONE, android.R.id.copy, 1, android.R.string.copy).setAlphabeticShortcut('c').setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
    menu.add(Menu.NONE, android.R.id.shareText, 2, R.string.abc_share).setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
    menu.setCallback(new MenuBuilder.Callback() {

        @Override
        public boolean onMenuItemSelected(MenuBuilder menu, MenuItem item) {
            final PendingIntent intent = menuActions.get(item);
            if (intent != null) {
                try {
                    intent.send();
                } catch (PendingIntent.CanceledException e) {
                    Log.e(LOG_TAG, "Error performing smart action", e);
                }
            } else {
                switch(item.getItemId()) {
                    case android.R.id.copy:
                        copyText();
                        break;
                    case android.R.id.shareText:
                        shareText();
                        break;
                }
            }
            return true;
        }

        @Override
        public void onMenuModeChange(MenuBuilder menu) {
        }

        private void copyText() {
            final ClipboardManager clipboard = textView.getContext().getSystemService(ClipboardManager.class);
            final String text = getHighlightedText(textView, highlight);
            if (clipboard != null && !TextUtils.isEmpty(text)) {
                try {
                    clipboard.setPrimaryClip(ClipData.newPlainText(null, text));
                } catch (Throwable t) {
                    Log.d(LOG_TAG, "Error copying text: " + t.getMessage());
                }
            }
        }

        private void shareText() {
            final String text = getHighlightedText(textView, highlight);
            if (!TextUtils.isEmpty(text)) {
                final Intent sharingIntent = new Intent(android.content.Intent.ACTION_SEND);
                sharingIntent.setType("text/plain");
                sharingIntent.putExtra(android.content.Intent.EXTRA_TEXT, text);
                textView.getContext().startActivity(Intent.createChooser(sharingIntent, null));
            }
        }
    });
    return menu;
}
#end_block

#method_before
@NonNull
public TextLinks build() {
    return new TextLinks(mFullText, mLinks);
}
#method_after
@NonNull
public Request build() {
    return new Request(mText, mDefaultLocales, mEntityConfig);
}
#end_block

#method_before
@Override
public void onClick(View widget) {
    if (!(widget instanceof TextView)) {
        return;
    }
    final TextView textView = (TextView) widget;
    final CharSequence text = textView.getText();
    if (!(text instanceof Spanned)) {
        return;
    }
    final Spanned spanned = (Spanned) text;
    final int start = spanned.getSpanStart(this);
    final int end = spanned.getSpanEnd(this);
    if (start >= 0 && start < end && end <= text.length()) {
        final TextClassification.Request request = new TextClassification.Request.Builder(text, start, end).setReferenceTime(mTextLinkSpanData.getReferenceTime()).setDefaultLocales(getLocales(textView)).build();
        final TextClassifier classifier = mTextLinkSpanData.getTextClassifier();
        // TODO: Truncate the text.
        sWorkerExecutor.execute(new Runnable() {

            @Override
            public void run() {
                final List<RemoteActionCompat> actions = classifier.classifyText(request).getActions();
                sMainThreadExecutor.execute(new Runnable() {

                    @Override
                    public void run() {
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                            ToolbarController.getInstance(textView).show(actions, start, end);
                        } else if (!actions.isEmpty()) {
                            try {
                                actions.get(0).getActionIntent().send();
                            } catch (PendingIntent.CanceledException e) {
                                Log.e(LOG_TAG, "Error handling TextLinkSpan click", e);
                            }
                        } else {
                            Log.d(LOG_TAG, "Cannot trigger link. No actions found.");
                        }
                    }
                });
            }
        });
    } else {
        Log.d(LOG_TAG, "Cannot show link toolbar. Invalid text indices");
    }
}
#method_after
@Override
public void onClick(View widget) {
    if (!(widget instanceof TextView)) {
        return;
    }
    final TextView textView = (TextView) widget;
    final CharSequence text = textView.getText();
    if (!(text instanceof Spanned)) {
        return;
    }
    final Spanned spanned = (Spanned) text;
    final int start = spanned.getSpanStart(this);
    final int end = spanned.getSpanEnd(this);
    if (start < 0 || start >= end || end > text.length()) {
        Log.d(LOG_TAG, "Cannot show link toolbar. Invalid text indices");
        return;
    }
    final TextClassification.Request request = new TextClassification.Request.Builder(text, start, end).setReferenceTime(mTextLinkSpanData.getReferenceTime()).setDefaultLocales(getLocales(textView)).build();
    final TextClassifier classifier = mTextLinkSpanData.getTextClassifier();
    // TODO: Truncate the text.
    sWorkerExecutor.execute(new Runnable() {

        @Override
        public void run() {
            final List<RemoteActionCompat> actions = classifier.classifyText(request).getActions();
            sMainThreadExecutor.execute(new Runnable() {

                @Override
                public void run() {
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                        ToolbarController.getInstance(textView).show(actions, start, end);
                        return;
                    }
                    if (!actions.isEmpty()) {
                        try {
                            actions.get(0).getActionIntent().send();
                        } catch (PendingIntent.CanceledException e) {
                            Log.e(LOG_TAG, "Error handling TextLinkSpan click", e);
                        }
                        return;
                    }
                    Log.d(LOG_TAG, "Cannot trigger link. No actions found.");
                }
            });
        }
    });
}
#end_block

#method_before
@Test
public void proguardMap() throws IOException, ParseException {
    ProguardMap map = new ProguardMap();
    // An empty proguard map should not deobfuscate anything.
    assertEquals("foo.bar.Sludge", map.getClassName("foo.bar.Sludge"));
    assertEquals("fooBarSludge", map.getClassName("fooBarSludge"));
    assertEquals("myfield", map.getFieldName("foo.bar.Sludge", "myfield"));
    assertEquals("myfield", map.getFieldName("fooBarSludge", "myfield"));
    ProguardMap.Frame frame = map.getFrame("foo.bar.Sludge", "mymethod", "(Lfoo/bar/Sludge;)V", "SourceFile.java", 123);
    assertEquals("mymethod", frame.method);
    assertEquals("(Lfoo/bar/Sludge;)V", frame.signature);
    assertEquals("SourceFile.java", frame.filename);
    assertEquals(123, frame.line);
    // Read in the proguard map.
    map.readFromReader(new StringReader(TEST_MAP));
    // It should still not deobfuscate things that aren't in the map
    assertEquals("foo.bar.Sludge", map.getClassName("foo.bar.Sludge"));
    assertEquals("fooBarSludge", map.getClassName("fooBarSludge"));
    assertEquals("myfield", map.getFieldName("foo.bar.Sludge", "myfield"));
    assertEquals("myfield", map.getFieldName("fooBarSludge", "myfield"));
    frame = map.getFrame("foo.bar.Sludge", "mymethod", "(Lfoo/bar/Sludge;)V", "SourceFile.java", 123);
    assertEquals("mymethod", frame.method);
    assertEquals("(Lfoo/bar/Sludge;)V", frame.signature);
    assertEquals("SourceFile.java", frame.filename);
    assertEquals(123, frame.line);
    // Test deobfuscation of class names
    assertEquals("class.that.is.Empty", map.getClassName("a"));
    assertEquals("class.that.is.Empty$subclass", map.getClassName("b"));
    assertEquals("class.with.only.Fields", map.getClassName("c"));
    assertEquals("class.with.Methods", map.getClassName("d"));
    // Test deobfuscation of array classes.
    assertEquals("class.with.Methods[]", map.getClassName("d[]"));
    assertEquals("class.with.Methods[][]", map.getClassName("d[][]"));
    // Test deobfuscation of methods
    assertEquals("prim_type_field", map.getFieldName("class.with.only.Fields", "a"));
    assertEquals("prim_array_type_field", map.getFieldName("class.with.only.Fields", "b"));
    assertEquals("class_type_field", map.getFieldName("class.with.only.Fields", "c"));
    assertEquals("array_type_field", map.getFieldName("class.with.only.Fields", "d"));
    assertEquals("longObfuscatedNameField", map.getFieldName("class.with.only.Fields", "abc"));
    assertEquals("some_field", map.getFieldName("class.with.Methods", "a"));
    // Test deobfuscation of frames
    frame = map.getFrame("class.with.Methods", "<clinit>", "()V", "SourceFile.java", 13);
    assertEquals("<clinit>", frame.method);
    assertEquals("()V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(13, frame.line);
    frame = map.getFrame("class.with.Methods", "m", "()V", "SourceFile.java", 42);
    assertEquals("boringMethod", frame.method);
    assertEquals("()V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(42, frame.line);
    frame = map.getFrame("class.with.Methods", "m", "(IF)V", "SourceFile.java", 45);
    assertEquals("methodWithPrimArgs", frame.method);
    assertEquals("(IF)V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(45, frame.line);
    frame = map.getFrame("class.with.Methods", "m", "([IF)V", "SourceFile.java", 49);
    assertEquals("methodWithPrimArrArgs", frame.method);
    assertEquals("([IF)V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(49, frame.line);
    frame = map.getFrame("class.with.Methods", "m", "(Lclass/not/in/Map;)V", "SourceFile.java", 52);
    assertEquals("methodWithClearObjArg", frame.method);
    assertEquals("(Lclass/not/in/Map;)V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(52, frame.line);
    frame = map.getFrame("class.with.Methods", "m", "([Lclass/not/in/Map;)V", "SourceFile.java", 57);
    assertEquals("methodWithClearObjArrArg", frame.method);
    assertEquals("([Lclass/not/in/Map;)V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(57, frame.line);
    frame = map.getFrame("class.with.Methods", "m", "(Lc;)V", "SourceFile.java", 59);
    assertEquals("methodWithObfObjArg", frame.method);
    assertEquals("(Lclass/with/only/Fields;)V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(59, frame.line);
    frame = map.getFrame("class.with.Methods", "n", "()Lc;", "SourceFile.java", 64);
    assertEquals("methodWithObfRes", frame.method);
    assertEquals("()Lclass/with/only/Fields;", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(64, frame.line);
    frame = map.getFrame("class.with.Methods", "o", "()V", "SourceFile.java", 80);
    assertEquals("lineObfuscatedMethod", frame.method);
    assertEquals("()V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(8, frame.line);
    frame = map.getFrame("class.with.Methods", "p", "()V", "SourceFile.java", 94);
    assertEquals("lineObfuscatedMethod2", frame.method);
    assertEquals("()V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(13, frame.line);
    // Some methods may not have been obfuscated. We should still be able
    // to compute the filename properly.
    frame = map.getFrame("class.with.Methods", "unObfuscatedMethodName", "()V", "SourceFile.java", 0);
    assertEquals("Methods.java", frame.filename);
}
#method_after
@Test
public void proguardMap() throws IOException, ParseException {
    ProguardMap map = new ProguardMap();
    // An empty proguard map should not deobfuscate anything.
    assertEquals("foo.bar.Sludge", map.getClassName("foo.bar.Sludge"));
    assertEquals("fooBarSludge", map.getClassName("fooBarSludge"));
    assertEquals("myfield", map.getFieldName("foo.bar.Sludge", "myfield"));
    assertEquals("myfield", map.getFieldName("fooBarSludge", "myfield"));
    ProguardMap.Frame frame = map.getFrame("foo.bar.Sludge", "mymethod", "(Lfoo/bar/Sludge;)V", "SourceFile.java", 123);
    assertEquals("mymethod", frame.method);
    assertEquals("(Lfoo/bar/Sludge;)V", frame.signature);
    assertEquals("SourceFile.java", frame.filename);
    assertEquals(123, frame.line);
    // Read in the proguard map.
    map.readFromReader(new StringReader(TEST_MAP));
    // It should still not deobfuscate things that aren't in the map
    assertEquals("foo.bar.Sludge", map.getClassName("foo.bar.Sludge"));
    assertEquals("fooBarSludge", map.getClassName("fooBarSludge"));
    assertEquals("myfield", map.getFieldName("foo.bar.Sludge", "myfield"));
    assertEquals("myfield", map.getFieldName("fooBarSludge", "myfield"));
    frame = map.getFrame("foo.bar.Sludge", "mymethod", "(Lfoo/bar/Sludge;)V", "SourceFile.java", 123);
    assertEquals("mymethod", frame.method);
    assertEquals("(Lfoo/bar/Sludge;)V", frame.signature);
    assertEquals("SourceFile.java", frame.filename);
    assertEquals(123, frame.line);
    // Test deobfuscation of class names
    assertEquals("class.that.is.Empty", map.getClassName("a"));
    assertEquals("class.that.is.Empty$subclass", map.getClassName("b"));
    assertEquals("class.with.only.Fields", map.getClassName("c"));
    assertEquals("class.with.Methods", map.getClassName("d"));
    // Test deobfuscation of array classes.
    assertEquals("class.with.Methods[]", map.getClassName("d[]"));
    assertEquals("class.with.Methods[][]", map.getClassName("d[][]"));
    // Test deobfuscation of methods
    assertEquals("prim_type_field", map.getFieldName("class.with.only.Fields", "a"));
    assertEquals("prim_array_type_field", map.getFieldName("class.with.only.Fields", "b"));
    assertEquals("class_type_field", map.getFieldName("class.with.only.Fields", "c"));
    assertEquals("array_type_field", map.getFieldName("class.with.only.Fields", "d"));
    assertEquals("longObfuscatedNameField", map.getFieldName("class.with.only.Fields", "abc"));
    assertEquals("some_field", map.getFieldName("class.with.Methods", "a"));
    // Test deobfuscation of frames
    frame = map.getFrame("class.with.Methods", "<clinit>", "()V", "SourceFile.java", 13);
    assertEquals("<clinit>", frame.method);
    assertEquals("()V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(13, frame.line);
    frame = map.getFrame("class.with.Methods", "m", "()V", "SourceFile.java", 42);
    assertEquals("boringMethod", frame.method);
    assertEquals("()V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(42, frame.line);
    frame = map.getFrame("class.with.Methods", "m", "(IF)V", "SourceFile.java", 45);
    assertEquals("methodWithPrimArgs", frame.method);
    assertEquals("(IF)V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(45, frame.line);
    frame = map.getFrame("class.with.Methods", "m", "([IF)V", "SourceFile.java", 49);
    assertEquals("methodWithPrimArrArgs", frame.method);
    assertEquals("([IF)V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(49, frame.line);
    frame = map.getFrame("class.with.Methods", "m", "(Lclass/not/in/Map;)V", "SourceFile.java", 52);
    assertEquals("methodWithClearObjArg", frame.method);
    assertEquals("(Lclass/not/in/Map;)V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(52, frame.line);
    frame = map.getFrame("class.with.Methods", "m", "([Lclass/not/in/Map;)V", "SourceFile.java", 57);
    assertEquals("methodWithClearObjArrArg", frame.method);
    assertEquals("([Lclass/not/in/Map;)V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(57, frame.line);
    frame = map.getFrame("class.with.Methods", "m", "(Lc;)V", "SourceFile.java", 59);
    assertEquals("methodWithObfObjArg", frame.method);
    assertEquals("(Lclass/with/only/Fields;)V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(59, frame.line);
    frame = map.getFrame("class.with.Methods", "n", "()Lc;", "SourceFile.java", 64);
    assertEquals("methodWithObfRes", frame.method);
    assertEquals("()Lclass/with/only/Fields;", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(64, frame.line);
    frame = map.getFrame("class.with.Methods", "o", "()V", "SourceFile.java", 80);
    assertEquals("lineObfuscatedMethod", frame.method);
    assertEquals("()V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(8, frame.line);
    frame = map.getFrame("class.with.Methods", "o", "()V", "SourceFile.java", 103);
    assertEquals("lineObfuscatedMethod", frame.method);
    assertEquals("()V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(53, frame.line);
    frame = map.getFrame("class.with.Methods", "p", "()V", "SourceFile.java", 94);
    assertEquals("lineObfuscatedMethod2", frame.method);
    assertEquals("()V", frame.signature);
    assertEquals("Methods.java", frame.filename);
    assertEquals(13, frame.line);
    // Some methods may not have been obfuscated. We should still be able
    // to compute the filename properly.
    frame = map.getFrame("class.with.Methods", "unObfuscatedMethodName", "()V", "SourceFile.java", 0);
    assertEquals("Methods.java", frame.filename);
}
#end_block

#method_before
public void addFrame(String obfuscatedMethodName, String clearMethodName, String clearSignature, int obfuscatedLine, int obfuscatedLineEnd, int clearLine) {
    for (int i = obfuscatedLine; i <= obfuscatedLineEnd; i++) {
        String key = obfuscatedMethodName + clearSignature + i;
        mFrames.put(key, new FrameData(clearMethodName, obfuscatedLine - clearLine));
    }
}
#method_after
public void addFrame(String obfuscatedMethodName, String clearMethodName, String clearSignature, int obfuscatedLine, int obfuscatedLineEnd, int clearLine) {
    String key = obfuscatedMethodName + clearSignature;
    FrameData data = mFrames.get(key);
    if (data == null) {
        data = new FrameData(clearMethodName);
    }
    data.lineNumbers.put(obfuscatedLine, new LineNumber(obfuscatedLine, obfuscatedLineEnd, clearLine));
    mFrames.put(key, data);
}
#end_block

#method_before
public Frame getFrame(String clearClassName, String obfuscatedMethodName, String clearSignature, String obfuscatedFilename, int obfuscatedLine) {
    String key = obfuscatedMethodName + clearSignature + obfuscatedLine;
    FrameData frame = mFrames.get(key);
    if (frame == null) {
        frame = new FrameData(obfuscatedMethodName, 0);
    }
    return new Frame(frame.clearMethodName, clearSignature, getFileName(clearClassName), obfuscatedLine - frame.lineDelta);
}
#method_after
public Frame getFrame(String clearClassName, String obfuscatedMethodName, String clearSignature, String obfuscatedFilename, int obfuscatedLine) {
    String key = obfuscatedMethodName + clearSignature;
    FrameData frame = mFrames.get(key);
    if (frame == null) {
        frame = new FrameData(obfuscatedMethodName);
    }
    return new Frame(frame.clearMethodName, clearSignature, getFileName(clearClassName), frame.getClearLine(obfuscatedLine));
}
#end_block

#method_before
public void readFromReader(Reader mapReader) throws IOException, ParseException {
    BufferedReader reader = new BufferedReader(mapReader);
    String line = reader.readLine();
    while (line != null) {
        // Comment lines start with '#'. Skip over them.
        if (line.startsWith("#")) {
            line = reader.readLine();
            continue;
        }
        // Class lines are of the form:
        // 'clear.class.name -> obfuscated_class_name:'
        int sep = line.indexOf(" -> ");
        if (sep == -1 || sep + 5 >= line.length()) {
            parseException("Error parsing class line: '" + line + "'");
        }
        String clearClassName = line.substring(0, sep);
        String obfuscatedClassName = line.substring(sep + 4, line.length() - 1);
        ClassData classData = new ClassData(clearClassName);
        mClassesFromClearName.put(clearClassName, classData);
        mClassesFromObfuscatedName.put(obfuscatedClassName, classData);
        // After the class line comes zero or more field/method lines of the form:
        // '    type clearName -> obfuscatedName'
        line = reader.readLine();
        while (line != null && line.startsWith("    ")) {
            String trimmed = line.trim();
            int ws = trimmed.indexOf(' ');
            sep = trimmed.indexOf(" -> ");
            if (ws == -1 || sep == -1) {
                parseException("Error parse field/method line: '" + line + "'");
            }
            String type = trimmed.substring(0, ws);
            String clearName = trimmed.substring(ws + 1, sep);
            String obfuscatedName = trimmed.substring(sep + 4, trimmed.length());
            // field.
            if (clearName.indexOf('(') == -1) {
                classData.addField(obfuscatedName, clearName);
            } else {
                // For methods, the type is of the form: [#:[#:]]<returnType>
                int obfuscatedLine = 0;
                int obfuscatedLineEnd = 0;
                int colon = type.indexOf(':');
                if (colon != -1) {
                    obfuscatedLine = Integer.parseInt(type.substring(0, colon));
                    type = type.substring(colon + 1);
                }
                colon = type.indexOf(':');
                if (colon != -1) {
                    obfuscatedLineEnd = Integer.parseInt(type.substring(0, colon));
                    type = type.substring(colon + 1);
                }
                // For methods, the clearName is of the form: <clearName><sig>[:#[:#]]
                int op = clearName.indexOf('(');
                int cp = clearName.indexOf(')');
                if (op == -1 || cp == -1) {
                    parseException("Error parse method line: '" + line + "'");
                }
                String sig = clearName.substring(op, cp + 1);
                int clearLine = obfuscatedLine;
                colon = clearName.lastIndexOf(':');
                if (colon != -1) {
                    clearLine = Integer.parseInt(clearName.substring(colon + 1));
                    clearName = clearName.substring(0, colon);
                }
                colon = clearName.lastIndexOf(':');
                if (colon != -1) {
                    clearLine = Integer.parseInt(clearName.substring(colon + 1));
                    clearName = clearName.substring(0, colon);
                }
                clearName = clearName.substring(0, op);
                String clearSig = fromProguardSignature(sig + type);
                classData.addFrame(obfuscatedName, clearName, clearSig, obfuscatedLine, obfuscatedLineEnd, clearLine);
            }
            line = reader.readLine();
        }
    }
    reader.close();
}
#method_after
public void readFromReader(Reader mapReader) throws IOException, ParseException {
    BufferedReader reader = new BufferedReader(mapReader);
    String line = reader.readLine();
    while (line != null) {
        // Comment lines start with '#'. Skip over them.
        if (line.startsWith("#")) {
            line = reader.readLine();
            continue;
        }
        // Class lines are of the form:
        // 'clear.class.name -> obfuscated_class_name:'
        int sep = line.indexOf(" -> ");
        if (sep == -1 || sep + 5 >= line.length()) {
            parseException("Error parsing class line: '" + line + "'");
        }
        String clearClassName = line.substring(0, sep);
        String obfuscatedClassName = line.substring(sep + 4, line.length() - 1);
        ClassData classData = new ClassData(clearClassName);
        mClassesFromClearName.put(clearClassName, classData);
        mClassesFromObfuscatedName.put(obfuscatedClassName, classData);
        // After the class line comes zero or more field/method lines of the form:
        // '    type clearName -> obfuscatedName'
        line = reader.readLine();
        while (line != null && line.startsWith("    ")) {
            String trimmed = line.trim();
            int ws = trimmed.indexOf(' ');
            sep = trimmed.indexOf(" -> ");
            if (ws == -1 || sep == -1) {
                parseException("Error parse field/method line: '" + line + "'");
            }
            String type = trimmed.substring(0, ws);
            String clearName = trimmed.substring(ws + 1, sep);
            String obfuscatedName = trimmed.substring(sep + 4, trimmed.length());
            // field.
            if (clearName.indexOf('(') == -1) {
                classData.addField(obfuscatedName, clearName);
            } else {
                // For methods, the type is of the form: [#:[#:]]<returnType>
                int obfuscatedLine = 0;
                // The end of the obfuscated line range.
                // If line does not contain explicit end range, e.g #:, it is equivalent to #:#:
                int obfuscatedLineEnd = 0;
                int colon = type.indexOf(':');
                if (colon != -1) {
                    obfuscatedLine = Integer.parseInt(type.substring(0, colon));
                    obfuscatedLineEnd = obfuscatedLine;
                    type = type.substring(colon + 1);
                }
                colon = type.indexOf(':');
                if (colon != -1) {
                    obfuscatedLineEnd = Integer.parseInt(type.substring(0, colon));
                    type = type.substring(colon + 1);
                }
                // For methods, the clearName is of the form: <clearName><sig>[:#[:#]]
                int op = clearName.indexOf('(');
                int cp = clearName.indexOf(')');
                if (op == -1 || cp == -1) {
                    parseException("Error parse method line: '" + line + "'");
                }
                String sig = clearName.substring(op, cp + 1);
                int clearLine = obfuscatedLine;
                colon = clearName.lastIndexOf(':');
                if (colon != -1) {
                    clearLine = Integer.parseInt(clearName.substring(colon + 1));
                    clearName = clearName.substring(0, colon);
                }
                colon = clearName.lastIndexOf(':');
                if (colon != -1) {
                    clearLine = Integer.parseInt(clearName.substring(colon + 1));
                    clearName = clearName.substring(0, colon);
                }
                clearName = clearName.substring(0, op);
                String clearSig = fromProguardSignature(sig + type);
                classData.addFrame(obfuscatedName, clearName, clearSig, obfuscatedLine, obfuscatedLineEnd, clearLine);
            }
            line = reader.readLine();
        }
    }
    reader.close();
}
#end_block

#method_before
private boolean shouldBind() {
    if (mStarted) {
        // Bind whenever there is a discovery request.
        if (getDiscoveryRequest() != null) {
            return true;
        }
        // This means that one of this provider's routes is selected.
        if (!mControllers.isEmpty()) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean shouldBind() {
    if (mStarted) {
        // Bind whenever there is a discovery request.
        if (getDiscoveryRequest() != null) {
            return true;
        }
        // This means that one of this provider's routes is selected.
        if (!mControllerConnections.isEmpty()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private RouteController createRouteController(String routeId, String routeGroupId) {
    MediaRouteProviderDescriptor descriptor = getDescriptor();
    if (descriptor != null) {
        List<MediaRouteDescriptor> routes = descriptor.getRoutes();
        final int count = routes.size();
        for (int i = 0; i < count; i++) {
            final MediaRouteDescriptor route = routes.get(i);
            if (route.getId().equals(routeId)) {
                RouteController controller = new RegisteredRouteController(routeId, routeGroupId);
                mControllers.add((Controller) controller);
                if (mConnectionReady) {
                    ((Controller) controller).attachConnection(mActiveConnection);
                }
                updateBinding();
                return controller;
            }
        }
    }
    return null;
}
#method_after
private RouteController createRouteController(String routeId, String routeGroupId) {
    MediaRouteProviderDescriptor descriptor = getDescriptor();
    if (descriptor != null) {
        List<MediaRouteDescriptor> routes = descriptor.getRoutes();
        final int count = routes.size();
        for (int i = 0; i < count; i++) {
            final MediaRouteDescriptor route = routes.get(i);
            if (route.getId().equals(routeId)) {
                RouteController controller = new RegisteredRouteController(routeId, routeGroupId);
                mControllerConnections.add((ControllerConnection) controller);
                if (mConnectionReady) {
                    ((ControllerConnection) controller).attachConnection(mActiveConnection);
                }
                updateBinding();
                return controller;
            }
        }
    }
    return null;
}
#end_block

#method_before
private DynamicGroupRouteController createDynamicGroupRouteController(String initialMemberRouteId) {
    MediaRouteProviderDescriptor descriptor = getDescriptor();
    if (descriptor != null) {
        List<MediaRouteDescriptor> routes = descriptor.getRoutes();
        final int count = routes.size();
        for (int i = 0; i < count; i++) {
            final MediaRouteDescriptor route = routes.get(i);
            if (route.getId().equals(initialMemberRouteId)) {
                Controller controller = new RegisteredDynamicController(initialMemberRouteId);
                mControllers.add(controller);
                if (mConnectionReady) {
                    controller.attachConnection(mActiveConnection);
                }
                updateBinding();
                return (DynamicGroupRouteController) controller;
            }
        }
    }
    return null;
}
#method_after
private DynamicGroupRouteController createDynamicGroupRouteController(String initialMemberRouteId) {
    MediaRouteProviderDescriptor descriptor = getDescriptor();
    if (descriptor != null) {
        List<MediaRouteDescriptor> routes = descriptor.getRoutes();
        final int count = routes.size();
        for (int i = 0; i < count; i++) {
            final MediaRouteDescriptor route = routes.get(i);
            if (route.getId().equals(initialMemberRouteId)) {
                DynamicGroupRouteController controller = new RegisteredDynamicController(initialMemberRouteId);
                mControllerConnections.add((ControllerConnection) controller);
                if (mConnectionReady) {
                    ((ControllerConnection) controller).attachConnection(mActiveConnection);
                }
                updateBinding();
                return controller;
            }
        }
    }
    return null;
}
#end_block

#method_before
void onControllerReleased(Controller controller) {
    mControllers.remove(controller);
    controller.detachConnection();
    updateBinding();
}
#method_after
void onControllerReleased(ControllerConnection controllerConnection) {
    mControllerConnections.remove(controllerConnection);
    controllerConnection.detachConnection();
    updateBinding();
}
#end_block

#method_before
private void attachControllersToConnection() {
    int count = mControllers.size();
    for (int i = 0; i < count; i++) {
        mControllers.get(i).attachConnection(mActiveConnection);
    }
}
#method_after
private void attachControllersToConnection() {
    int count = mControllerConnections.size();
    for (int i = 0; i < count; i++) {
        mControllerConnections.get(i).attachConnection(mActiveConnection);
    }
}
#end_block

#method_before
private void detachControllersFromConnection() {
    int count = mControllers.size();
    for (int i = 0; i < count; i++) {
        mControllers.get(i).detachConnection();
    }
}
#method_after
private void detachControllersFromConnection() {
    int count = mControllerConnections.size();
    for (int i = 0; i < count; i++) {
        mControllerConnections.get(i).detachConnection();
    }
}
#end_block

#method_before
// ///////////////////////////////////
public void attachConnection(Connection connection) {
    ControlRequestCallback callback = new ControlRequestCallback() {

        @Override
        public void onResult(Bundle data) {
            mRouteId = data.getString(CLIENT_DATA_ROUTE_ID);
            mGroupableSectionTitle = data.getString(DATA_KEY_GROUPABLE_SECION_TITLE);
            mTransferableSectionTitle = data.getString(DATA_KEY_TRANSFERABLE_SECTION_TITLE);
        }

        @Override
        public void onError(String error, Bundle data) {
            Log.d(TAG, "Error: " + error + ", data: " + data);
        }
    };
    mConnection = connection;
    mControllerId = connection.createDynamicGroupRouteController(mInitialMemberRouteId, callback);
    if (mSelected) {
        connection.selectRoute(mControllerId);
        if (mPendingSetVolume >= 0) {
            connection.setVolume(mControllerId, mPendingSetVolume);
            mPendingSetVolume = -1;
        }
        if (mPendingUpdateVolumeDelta != 0) {
            connection.updateVolume(mControllerId, mPendingUpdateVolumeDelta);
            mPendingUpdateVolumeDelta = 0;
        }
    }
}
#method_after
// ///////////////////////////////////
@Override
public void attachConnection(Connection connection) {
    ControlRequestCallback callback = new ControlRequestCallback() {

        @Override
        public void onResult(Bundle data) {
            mRouteId = data.getString(CLIENT_DATA_ROUTE_ID);
            mGroupableSectionTitle = data.getString(DATA_KEY_GROUPABLE_SECION_TITLE);
            mTransferableSectionTitle = data.getString(DATA_KEY_TRANSFERABLE_SECTION_TITLE);
        }

        @Override
        public void onError(String error, Bundle data) {
            Log.d(TAG, "Error: " + error + ", data: " + data);
        }
    };
    mConnection = connection;
    mControllerId = connection.createDynamicGroupRouteController(mInitialMemberRouteId, callback);
    if (mSelected) {
        connection.selectRoute(mControllerId);
        if (mPendingSetVolume >= 0) {
            connection.setVolume(mControllerId, mPendingSetVolume);
            mPendingSetVolume = -1;
        }
        if (mPendingUpdateVolumeDelta != 0) {
            connection.updateVolume(mControllerId, mPendingUpdateVolumeDelta);
            mPendingUpdateVolumeDelta = 0;
        }
    }
}
#end_block

#method_before
public void detachConnection() {
    if (mConnection != null) {
        mConnection.releaseRouteController(mControllerId);
        mConnection = null;
        mControllerId = 0;
    }
}
#method_after
@Override
public void detachConnection() {
    if (mConnection != null) {
        mConnection.releaseRouteController(mControllerId);
        mConnection = null;
        mControllerId = 0;
    }
}
#end_block

#method_before
public void attachConnection(Connection connection) {
    mConnection = connection;
    mControllerId = connection.createRouteController(mRouteId, mRouteGroupId);
    if (mSelected) {
        connection.selectRoute(mControllerId);
        if (mPendingSetVolume >= 0) {
            connection.setVolume(mControllerId, mPendingSetVolume);
            mPendingSetVolume = -1;
        }
        if (mPendingUpdateVolumeDelta != 0) {
            connection.updateVolume(mControllerId, mPendingUpdateVolumeDelta);
            mPendingUpdateVolumeDelta = 0;
        }
    }
}
#method_after
@Override
public void attachConnection(Connection connection) {
    mConnection = connection;
    mControllerId = connection.createRouteController(mRouteId, mRouteGroupId);
    if (mSelected) {
        connection.selectRoute(mControllerId);
        if (mPendingSetVolume >= 0) {
            connection.setVolume(mControllerId, mPendingSetVolume);
            mPendingSetVolume = -1;
        }
        if (mPendingUpdateVolumeDelta != 0) {
            connection.updateVolume(mControllerId, mPendingUpdateVolumeDelta);
            mPendingUpdateVolumeDelta = 0;
        }
    }
}
#end_block

#method_before
public void detachConnection() {
    if (mConnection != null) {
        mConnection.releaseRouteController(mControllerId);
        mConnection = null;
        mControllerId = 0;
    }
}
#method_after
@Override
public void detachConnection() {
    if (mConnection != null) {
        mConnection.releaseRouteController(mControllerId);
        mConnection = null;
        mControllerId = 0;
    }
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder(super.toString());
    sb.append('[');
    final int count = mRoutes.size();
    for (int i = 0; i < count; i++) {
        if (i > 0)
            sb.append(", ");
        sb.append(mRoutes.get(i));
    }
    sb.append(']');
    return sb.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder sb = new StringBuilder(super.toString());
    sb.append('[');
    final int count = mMemberRoutes.size();
    for (int i = 0; i < count; i++) {
        if (i > 0)
            sb.append(", ");
        sb.append(mMemberRoutes.get(i));
    }
    sb.append(']');
    return sb.toString();
}
#end_block

#method_before
@Override
int maybeUpdateDescriptor(MediaRouteDescriptor descriptor) {
    boolean changed = false;
    if (mDescriptor != descriptor) {
        mDescriptor = descriptor;
        if (descriptor != null) {
            List<String> groupMemberIds = descriptor.getGroupMemberIds();
            List<RouteInfo> routes = new ArrayList<>();
            if (groupMemberIds == null) {
                Log.w(TAG, "groupMemberIds shouldn't be null.");
                changed = true;
            } else {
                changed = groupMemberIds.size() != mRoutes.size();
                for (String groupMemberId : groupMemberIds) {
                    String uniqueId = sGlobal.getUniqueId(getProvider(), groupMemberId);
                    RouteInfo groupMember = sGlobal.getRoute(uniqueId);
                    if (groupMember != null) {
                        routes.add(groupMember);
                        if (!changed && !mRoutes.contains(groupMember)) {
                            changed = true;
                        }
                    }
                }
            }
            if (changed) {
                mRoutes = routes;
            }
        }
    }
    return (changed ? CHANGE_GENERAL : 0) | super.updateDescriptor(descriptor);
}
#method_after
@Override
int maybeUpdateDescriptor(MediaRouteDescriptor descriptor) {
    boolean changed = false;
    if (mDescriptor != descriptor) {
        mDescriptor = descriptor;
        if (descriptor != null) {
            List<String> groupMemberIds = descriptor.getGroupMemberIds();
            List<RouteInfo> routes = new ArrayList<>();
            if (groupMemberIds == null) {
                Log.w(TAG, "groupMemberIds shouldn't be null.");
                changed = true;
            } else {
                changed = groupMemberIds.size() != mMemberRoutes.size();
                for (String groupMemberId : groupMemberIds) {
                    String uniqueId = sGlobal.getUniqueId(getProvider(), groupMemberId);
                    RouteInfo groupMember = sGlobal.getRoute(uniqueId);
                    if (groupMember != null) {
                        routes.add(groupMember);
                        if (!changed && !mMemberRoutes.contains(groupMember)) {
                            changed = true;
                        }
                    }
                }
            }
            if (changed) {
                mMemberRoutes = routes;
            }
        }
    }
    return (changed ? CHANGE_GENERAL : 0) | super.updateDescriptor(descriptor);
}
#end_block

#method_before
void updateDescriptors(Collection<DynamicRouteDescriptor> dynamicDescriptors) {
    mRoutes.clear();
    mMemberRoutes.clear();
    mUnselectableRoutes.clear();
    mGroupableRoutes.clear();
    mTransferableRoutes.clear();
    for (DynamicRouteDescriptor dynamicDescriptor : dynamicDescriptors) {
        if (dynamicDescriptor.isGroupable()) {
            RouteInfo route = findRouteByDynamicRouteDescriptor(dynamicDescriptor);
            if (route != null) {
                mGroupableRoutes.add(route.getId());
            }
        }
        if (dynamicDescriptor.isTransferable()) {
            RouteInfo route = findRouteByDynamicRouteDescriptor(dynamicDescriptor);
            if (route != null) {
                mTransferableRoutes.add(route.getId());
            }
        }
        if ((dynamicDescriptor.getSelectionState() == DynamicRouteDescriptor.SELECTING) || (dynamicDescriptor.getSelectionState() == DynamicRouteDescriptor.SELECTED)) {
            RouteInfo route = findRouteByDynamicRouteDescriptor(dynamicDescriptor);
            if (route != null) {
                mRoutes.add(route);
                mMemberRoutes.add(route.getId());
                if (dynamicDescriptor.isUnselectable()) {
                    mUnselectableRoutes.add(route.getId());
                }
            }
        }
    }
}
#method_after
void updateDescriptors(Collection<DynamicRouteDescriptor> dynamicDescriptors) {
    mMemberRoutes.clear();
    mUnselectableRoutes.clear();
    mGroupableRoutes.clear();
    mTransferableRoutes.clear();
    for (DynamicRouteDescriptor dynamicDescriptor : dynamicDescriptors) {
        if (dynamicDescriptor.isGroupable()) {
            RouteInfo route = findRouteByDynamicRouteDescriptor(dynamicDescriptor);
            if (route != null) {
                mGroupableRoutes.add(route);
            }
        }
        if (dynamicDescriptor.isTransferable()) {
            RouteInfo route = findRouteByDynamicRouteDescriptor(dynamicDescriptor);
            if (route != null) {
                mTransferableRoutes.add(route);
            }
        }
        if ((dynamicDescriptor.getSelectionState() == DynamicRouteDescriptor.SELECTING) || (dynamicDescriptor.getSelectionState() == DynamicRouteDescriptor.SELECTED)) {
            RouteInfo route = findRouteByDynamicRouteDescriptor(dynamicDescriptor);
            if (route != null) {
                mMemberRoutes.add(route);
                if (dynamicDescriptor.isUnselectable()) {
                    mUnselectableRoutes.add(route);
                }
            }
        }
    }
}
#end_block

#method_before
public List<String> getUnselectableRoutes() {
    return mUnselectableRoutes;
}
#method_after
public List<RouteInfo> getUnselectableRoutes() {
    return mUnselectableRoutes;
}
#end_block

#method_before
public List<String> getGroupableRoutes() {
    return mGroupableRoutes;
}
#method_after
public List<RouteInfo> getGroupableRoutes() {
    return mGroupableRoutes;
}
#end_block

#method_before
public List<String> getTransferableRoutes() {
    return mTransferableRoutes;
}
#method_after
public List<RouteInfo> getTransferableRoutes() {
    return mTransferableRoutes;
}
#end_block

#method_before
void selectRouteIntoGroup(@NonNull RouteInfo route) {
    if (!(mSelectedRoute instanceof DynamicGroupInfo) || (!(mSelectedRouteController instanceof DynamicGroupRouteController))) {
        throw new IllegalStateException("There is no currently selected " + "dynamic group route.");
    }
    DynamicGroupInfo groupInfo = (DynamicGroupInfo) mSelectedRoute;
    if (groupInfo.getMemberRoutes().contains(route.getId()) || !groupInfo.getGroupableRoutes().contains(route.getId())) {
        // route is already a member or not groupable to the current dynamic group.
        return;
    }
    ((DynamicGroupRouteController) mSelectedRouteController).onAddMemberRoute(route.getId());
}
#method_after
void selectRouteIntoGroup(@NonNull RouteInfo route) {
    if (!(mSelectedRoute instanceof DynamicGroupInfo) || (!(mSelectedRouteController instanceof DynamicGroupRouteController))) {
        throw new IllegalStateException("There is no currently selected " + "dynamic group route.");
    }
    DynamicGroupInfo groupInfo = (DynamicGroupInfo) mSelectedRoute;
    if (groupInfo.getMemberRoutes().contains(route) || !groupInfo.getGroupableRoutes().contains(route)) {
        // route is already a member or not groupable to the current dynamic group.
        return;
    }
    ((DynamicGroupRouteController) mSelectedRouteController).onAddMemberRoute(route.getDescriptorId());
}
#end_block

#method_before
void unselectRouteFromGroup(@NonNull RouteInfo route) {
    if (!(mSelectedRoute instanceof DynamicGroupInfo) || (!(mSelectedRouteController instanceof DynamicGroupRouteController))) {
        throw new IllegalStateException("There is no currently selected " + "dynamic group route.");
    }
    DynamicGroupInfo groupInfo = (DynamicGroupInfo) mSelectedRoute;
    if (!groupInfo.getMemberRoutes().contains(route.getId()) || groupInfo.getUnselectableRoutes().contains(route.getId())) {
        return;
    }
    ((DynamicGroupRouteController) mSelectedRouteController).onRemoveMemberRoute(route.getId());
}
#method_after
void unselectRouteFromGroup(@NonNull RouteInfo route) {
    if (!(mSelectedRoute instanceof DynamicGroupInfo) || (!(mSelectedRouteController instanceof DynamicGroupRouteController))) {
        throw new IllegalStateException("There is no currently selected " + "dynamic group route.");
    }
    DynamicGroupInfo groupInfo = (DynamicGroupInfo) mSelectedRoute;
    if (!groupInfo.getMemberRoutes().contains(route) || groupInfo.getUnselectableRoutes().contains(route)) {
        return;
    }
    ((DynamicGroupRouteController) mSelectedRouteController).onRemoveMemberRoute(route.getDescriptorId());
}
#end_block

#method_before
void updateSelectedRouteIfNeeded(boolean selectedRouteDescriptorChanged) {
    // Update default route.
    if (mDefaultRoute != null && !mDefaultRoute.isSelectable()) {
        Log.i(TAG, "Clearing the default route because it " + "is no longer selectable: " + mDefaultRoute);
        mDefaultRoute = null;
    }
    if (mDefaultRoute == null && !mRoutes.isEmpty()) {
        for (RouteInfo route : mRoutes) {
            if (isSystemDefaultRoute(route) && route.isSelectable()) {
                mDefaultRoute = route;
                Log.i(TAG, "Found default route: " + mDefaultRoute);
                break;
            }
        }
    }
    // Update bluetooth route.
    if (mBluetoothRoute != null && !mBluetoothRoute.isSelectable()) {
        Log.i(TAG, "Clearing the bluetooth route because it " + "is no longer selectable: " + mBluetoothRoute);
        mBluetoothRoute = null;
    }
    if (mBluetoothRoute == null && !mRoutes.isEmpty()) {
        for (RouteInfo route : mRoutes) {
            if (isSystemLiveAudioOnlyRoute(route) && route.isSelectable()) {
                mBluetoothRoute = route;
                Log.i(TAG, "Found bluetooth route: " + mBluetoothRoute);
                break;
            }
        }
    }
    // Update selected route.
    if (mSelectedRoute == null || !mSelectedRoute.isSelectable()) {
        Log.i(TAG, "Unselecting the current route because it " + "is no longer selectable: " + mSelectedRoute);
        setSelectedRouteInternal(chooseFallbackRoute(), MediaRouter.UNSELECT_REASON_UNKNOWN);
    } else if (selectedRouteDescriptorChanged) {
        // for the added/removed route members.
        if (mSelectedRoute instanceof RouteGroup) {
            List<RouteInfo> routes = ((RouteGroup) mSelectedRoute).getRoutes();
            // Build a set of descriptor IDs for the new route group.
            Set<String> idSet = new HashSet<>();
            for (RouteInfo route : routes) {
                idSet.add(route.mDescriptorId);
            }
            // Unselect route controllers for the removed routes.
            Iterator<Map.Entry<String, RouteController>> iter = mRouteControllerMap.entrySet().iterator();
            while (iter.hasNext()) {
                Map.Entry<String, RouteController> entry = iter.next();
                if (!idSet.contains(entry.getKey())) {
                    RouteController controller = entry.getValue();
                    controller.onUnselect();
                    controller.onRelease();
                    iter.remove();
                }
            }
            // Select route controllers for the added routes.
            for (RouteInfo route : routes) {
                if (!mRouteControllerMap.containsKey(route.mUniqueId)) {
                    RouteController controller = route.getProviderInstance().onCreateRouteController(route.mDescriptorId, mSelectedRoute.mDescriptorId);
                    controller.onSelect();
                    mRouteControllerMap.put(route.mUniqueId, controller);
                }
            }
        }
        // Update the playback info because the properties of the route have changed.
        updatePlaybackInfoFromSelectedRoute();
    }
}
#method_after
void updateSelectedRouteIfNeeded(boolean selectedRouteDescriptorChanged) {
    // Update default route.
    if (mDefaultRoute != null && !mDefaultRoute.isSelectable()) {
        Log.i(TAG, "Clearing the default route because it " + "is no longer selectable: " + mDefaultRoute);
        mDefaultRoute = null;
    }
    if (mDefaultRoute == null && !mRoutes.isEmpty()) {
        for (RouteInfo route : mRoutes) {
            if (isSystemDefaultRoute(route) && route.isSelectable()) {
                mDefaultRoute = route;
                Log.i(TAG, "Found default route: " + mDefaultRoute);
                break;
            }
        }
    }
    // Update bluetooth route.
    if (mBluetoothRoute != null && !mBluetoothRoute.isSelectable()) {
        Log.i(TAG, "Clearing the bluetooth route because it " + "is no longer selectable: " + mBluetoothRoute);
        mBluetoothRoute = null;
    }
    if (mBluetoothRoute == null && !mRoutes.isEmpty()) {
        for (RouteInfo route : mRoutes) {
            if (isSystemLiveAudioOnlyRoute(route) && route.isSelectable()) {
                mBluetoothRoute = route;
                Log.i(TAG, "Found bluetooth route: " + mBluetoothRoute);
                break;
            }
        }
    }
    // Update selected route.
    if (mSelectedRoute == null || !mSelectedRoute.isSelectable()) {
        Log.i(TAG, "Unselecting the current route because it " + "is no longer selectable: " + mSelectedRoute);
        setSelectedRouteInternal(chooseFallbackRoute(), MediaRouter.UNSELECT_REASON_UNKNOWN);
    } else if (selectedRouteDescriptorChanged) {
        // for the added/removed route members.
        if (mSelectedRoute instanceof RouteGroup) {
            List<RouteInfo> routes = ((RouteGroup) mSelectedRoute).getMemberRoutes();
            // Build a set of descriptor IDs for the new route group.
            Set<String> idSet = new HashSet<>();
            for (RouteInfo route : routes) {
                idSet.add(route.mDescriptorId);
            }
            // Unselect route controllers for the removed routes.
            Iterator<Map.Entry<String, RouteController>> iter = mRouteControllerMap.entrySet().iterator();
            while (iter.hasNext()) {
                Map.Entry<String, RouteController> entry = iter.next();
                if (!idSet.contains(entry.getKey())) {
                    RouteController controller = entry.getValue();
                    controller.onUnselect();
                    controller.onRelease();
                    iter.remove();
                }
            }
            // Select route controllers for the added routes.
            for (RouteInfo route : routes) {
                if (!mRouteControllerMap.containsKey(route.mUniqueId)) {
                    RouteController controller = route.getProviderInstance().onCreateRouteController(route.mDescriptorId, mSelectedRoute.mDescriptorId);
                    controller.onSelect();
                    mRouteControllerMap.put(route.mUniqueId, controller);
                }
            }
        }
        // Update the playback info because the properties of the route have changed.
        updatePlaybackInfoFromSelectedRoute();
    }
}
#end_block

#method_before
private void setSelectedRouteInternal(@NonNull RouteInfo route, int unselectReason) {
    // TODO: Remove the following logging when no longer needed.
    if (sGlobal == null || (mBluetoothRoute != null && route.isDefault())) {
        final StackTraceElement[] callStack = Thread.currentThread().getStackTrace();
        StringBuilder sb = new StringBuilder();
        // callStack[3] is the caller of this method.
        for (int i = 3; i < callStack.length; i++) {
            StackTraceElement caller = callStack[i];
            sb.append(caller.getClassName()).append(".").append(caller.getMethodName()).append(":").append(caller.getLineNumber()).append("  ");
        }
        if (sGlobal == null) {
            Log.w(TAG, "setSelectedRouteInternal is called while sGlobal is null: pkgName=" + mApplicationContext.getPackageName() + ", callers=" + sb.toString());
        } else {
            Log.w(TAG, "Default route is selected while a BT route is available: pkgName=" + mApplicationContext.getPackageName() + ", callers=" + sb.toString());
        }
    }
    if (mSelectedRoute != route) {
        if (mSelectedRoute != null) {
            if (DEBUG) {
                Log.d(TAG, "Route unselected: " + mSelectedRoute + " reason: " + unselectReason);
            }
            mCallbackHandler.post(CallbackHandler.MSG_ROUTE_UNSELECTED, mSelectedRoute, unselectReason);
            if (mSelectedRouteController != null) {
                mSelectedRouteController.onUnselect(unselectReason);
                mSelectedRouteController.onRelease();
                mSelectedRouteController = null;
            }
            if (!mRouteControllerMap.isEmpty()) {
                for (RouteController controller : mRouteControllerMap.values()) {
                    controller.onUnselect(unselectReason);
                    controller.onRelease();
                }
                mRouteControllerMap.clear();
            }
        }
        if (route.getProvider().supportsDynamicGroup()) {
            // MRP will create a new dynamic group route with initially selected route.
            MediaRouteProvider.DynamicGroupRouteController controller = route.getProviderInstance().onCreateDynamicGroupRouteController(route.mDescriptorId);
            // Controller has the new route's id which MediaRouteDescriptor might not be
            // published yet.
            String uniqueId = assignRouteUniqueId(route.getProvider(), controller.getDynamicGroupRouteId());
            controller.setOnDynamicRoutesChangedListener(MainHandlerExecutor.getExecutor(mApplicationContext), mDynamicRoutesListener);
            mSelectedRouteController = controller;
            mSelectedRoute = new DynamicGroupInfo(route.getProvider(), controller.getDynamicGroupRouteId(), uniqueId);
        } else {
            mSelectedRouteController = route.getProviderInstance().onCreateRouteController(route.mDescriptorId);
            mSelectedRoute = route;
        }
        if (mSelectedRouteController != null) {
            mSelectedRouteController.onSelect();
        }
        if (DEBUG) {
            Log.d(TAG, "Route selected: " + mSelectedRoute);
        }
        mCallbackHandler.post(CallbackHandler.MSG_ROUTE_SELECTED, mSelectedRoute);
        if (mSelectedRoute instanceof RouteGroup) {
            List<RouteInfo> routes = ((RouteGroup) mSelectedRoute).getRoutes();
            mRouteControllerMap.clear();
            for (RouteInfo r : routes) {
                RouteController controller = r.getProviderInstance().onCreateRouteController(r.mDescriptorId, mSelectedRoute.mDescriptorId);
                controller.onSelect();
                mRouteControllerMap.put(r.mUniqueId, controller);
            }
        }
        updatePlaybackInfoFromSelectedRoute();
    }
}
#method_after
private void setSelectedRouteInternal(@NonNull RouteInfo route, int unselectReason) {
    // TODO: Remove the following logging when no longer needed.
    if (sGlobal == null || (mBluetoothRoute != null && route.isDefault())) {
        final StackTraceElement[] callStack = Thread.currentThread().getStackTrace();
        StringBuilder sb = new StringBuilder();
        // callStack[3] is the caller of this method.
        for (int i = 3; i < callStack.length; i++) {
            StackTraceElement caller = callStack[i];
            sb.append(caller.getClassName()).append(".").append(caller.getMethodName()).append(":").append(caller.getLineNumber()).append("  ");
        }
        if (sGlobal == null) {
            Log.w(TAG, "setSelectedRouteInternal is called while sGlobal is null: pkgName=" + mApplicationContext.getPackageName() + ", callers=" + sb.toString());
        } else {
            Log.w(TAG, "Default route is selected while a BT route is available: pkgName=" + mApplicationContext.getPackageName() + ", callers=" + sb.toString());
        }
    }
    if (mSelectedRoute != route) {
        if (mSelectedRoute != null) {
            if (DEBUG) {
                Log.d(TAG, "Route unselected: " + mSelectedRoute + " reason: " + unselectReason);
            }
            mCallbackHandler.post(CallbackHandler.MSG_ROUTE_UNSELECTED, mSelectedRoute, unselectReason);
            if (mSelectedRouteController != null) {
                mSelectedRouteController.onUnselect(unselectReason);
                mSelectedRouteController.onRelease();
                mSelectedRouteController = null;
            }
            if (!mRouteControllerMap.isEmpty()) {
                for (RouteController controller : mRouteControllerMap.values()) {
                    controller.onUnselect(unselectReason);
                    controller.onRelease();
                }
                mRouteControllerMap.clear();
            }
        }
        if (route.getProvider().supportsDynamicGroup()) {
            // MRP will create a new dynamic group route with initially selected route.
            MediaRouteProvider.DynamicGroupRouteController controller = route.getProviderInstance().onCreateDynamicGroupRouteController(route.mDescriptorId);
            // Controller has the new route's id which MediaRouteDescriptor might not be
            // published yet.
            String uniqueId = assignRouteUniqueId(route.getProvider(), controller.getDynamicGroupRouteId());
            controller.setOnDynamicRoutesChangedListener(MainHandlerExecutor.getExecutor(mApplicationContext), mDynamicRoutesListener);
            mSelectedRouteController = controller;
            mSelectedRoute = new DynamicGroupInfo(route.getProvider(), controller.getDynamicGroupRouteId(), uniqueId, controller);
        } else {
            mSelectedRouteController = route.getProviderInstance().onCreateRouteController(route.mDescriptorId);
            mSelectedRoute = route;
        }
        if (mSelectedRouteController != null) {
            mSelectedRouteController.onSelect();
        }
        if (DEBUG) {
            Log.d(TAG, "Route selected: " + mSelectedRoute);
        }
        mCallbackHandler.post(CallbackHandler.MSG_ROUTE_SELECTED, mSelectedRoute);
        if (mSelectedRoute instanceof RouteGroup) {
            List<RouteInfo> routes = ((RouteGroup) mSelectedRoute).getMemberRoutes();
            mRouteControllerMap.clear();
            for (RouteInfo r : routes) {
                RouteController controller = r.getProviderInstance().onCreateRouteController(r.mDescriptorId, mSelectedRoute.mDescriptorId);
                controller.onSelect();
                mRouteControllerMap.put(r.mUniqueId, controller);
            }
        }
        updatePlaybackInfoFromSelectedRoute();
    }
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.mr_cast_dialog);
    mCloseButton = findViewById(R.id.mr_cast_close_button);
    mCloseButton.setColorFilter(COLOR_WHITE_ON_DARK_BACKGROUND);
    mCloseButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    mStopCastingButton = findViewById(R.id.mr_cast_stop_button);
    mStopCastingButton.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mStopCastingButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mSelectedRoute.isSelected()) {
                mRouter.unselect(MediaRouter.UNSELECT_REASON_STOPPED);
            }
            dismiss();
        }
    });
    mAdapter = new RecyclerAdapter();
    mRecyclerView = findViewById(R.id.mr_cast_list);
    mRecyclerView.setAdapter(mAdapter);
    mRecyclerView.setLayoutManager(new LinearLayoutManager(mContext));
    mVolumeChangeListener = new VolumeChangeListener();
    mVolumeSliderColor = MediaRouterThemeHelper.getControllerColor(mContext, 0);
    mVolumeSliderHolderMap = new HashMap<>();
    mBeforeMuteVolumeMap = new HashMap<>();
    mMetadataLayout = findViewById(R.id.mr_cast_meta);
    mArtView = findViewById(R.id.mr_cast_meta_art);
    mTitleView = findViewById(R.id.mr_cast_meta_title);
    mTitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mSubtitleView = findViewById(R.id.mr_cast_meta_subtitle);
    mSubtitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    Resources res = mContext.getResources();
    mTitlePlaceholder = res.getString(R.string.mr_cast_dialog_title_view_placeholder);
    mCreated = true;
    updateLayout();
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.mr_cast_dialog);
    mCloseButton = findViewById(R.id.mr_cast_close_button);
    mCloseButton.setColorFilter(COLOR_WHITE_ON_DARK_BACKGROUND);
    mCloseButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    mStopCastingButton = findViewById(R.id.mr_cast_stop_button);
    mStopCastingButton.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mStopCastingButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mSelectedRoute.isSelected()) {
                mRouter.unselect(MediaRouter.UNSELECT_REASON_STOPPED);
            }
            dismiss();
        }
    });
    mAdapter = new RecyclerAdapter();
    mRecyclerView = findViewById(R.id.mr_cast_list);
    mRecyclerView.setAdapter(mAdapter);
    mRecyclerView.setLayoutManager(new LinearLayoutManager(mContext));
    mVolumeChangeListener = new VolumeChangeListener();
    mVolumeSliderColor = MediaRouterThemeHelper.getControllerColor(mContext, 0);
    mVolumeSliderHolderMap = new HashMap<>();
    mBeforeMuteVolumeMap = new HashMap<>();
    mMetadataBackground = findViewById(R.id.mr_cast_meta_background);
    mMetadataBlackScrim = findViewById(R.id.mr_cast_meta_black_scrim);
    mArtView = findViewById(R.id.mr_cast_meta_art);
    mTitleView = findViewById(R.id.mr_cast_meta_title);
    mTitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mSubtitleView = findViewById(R.id.mr_cast_meta_subtitle);
    mSubtitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    Resources res = mContext.getResources();
    mTitlePlaceholder = res.getString(R.string.mr_cast_dialog_title_view_placeholder);
    mCreated = true;
    updateLayout();
}
#end_block

#method_before
void update() {
    // in the process of selecting route.
    if (mRouteForVolumeUpdatingByUser != null || mIsSelectingRoute) {
        mHasPendingUpdate = true;
        return;
    }
    mHasPendingUpdate = false;
    if (!mSelectedRoute.isSelected() || mSelectedRoute.isDefaultOrBluetooth()) {
        dismiss();
        return;
    }
    if (!mCreated) {
        return;
    }
    if (mArtIconIsLoaded) {
        if (isBitmapRecycled(mArtIconLoadedBitmap)) {
            mArtView.setVisibility(View.GONE);
            Log.w(TAG, "Can't set artwork image with recycled bitmap: " + mArtIconLoadedBitmap);
        } else {
            mArtView.setVisibility(View.VISIBLE);
            mArtView.setImageBitmap(mArtIconLoadedBitmap);
            mArtView.setBackgroundColor(mArtIconBackgroundColor);
            mMetadataLayout.setBackgroundDrawable(new BitmapDrawable(mArtIconLoadedBitmap));
        }
        clearLoadedBitmap();
    } else {
        // Update metadata layout
        mArtView.setVisibility(View.GONE);
    }
    updateMetadataLayout();
}
#method_after
void update() {
    // in the process of selecting route.
    if (mRouteForVolumeUpdatingByUser != null || mIsSelectingRoute) {
        mHasPendingUpdate = true;
        return;
    }
    mHasPendingUpdate = false;
    if (!mSelectedRoute.isSelected() || mSelectedRoute.isDefaultOrBluetooth()) {
        dismiss();
        return;
    }
    if (!mCreated) {
        return;
    }
    if (mArtIconIsLoaded && !isBitmapRecycled(mArtIconLoadedBitmap) && mArtIconLoadedBitmap != null) {
        mArtView.setVisibility(View.VISIBLE);
        mArtView.setImageBitmap(mArtIconLoadedBitmap);
        mArtView.setBackgroundColor(mArtIconBackgroundColor);
        // Blur will not be supported for SDK < 17 devices to avoid unnecessarily bloating
        // the size of this package (approximately two-fold). Instead, only the black scrim
        // will be placed on top of the metadata background.
        mMetadataBlackScrim.setVisibility(View.VISIBLE);
        if (Build.VERSION.SDK_INT >= 17) {
            Bitmap blurredBitmap = blurBitmap(mArtIconLoadedBitmap, BLUR_RADIUS, mContext);
            mMetadataBackground.setImageBitmap(blurredBitmap);
        } else {
            mMetadataBackground.setImageBitmap(Bitmap.createBitmap(mArtIconLoadedBitmap));
        }
    } else {
        if (isBitmapRecycled(mArtIconLoadedBitmap)) {
            Log.w(TAG, "Can't set artwork image with recycled bitmap: " + mArtIconLoadedBitmap);
        }
        mArtView.setVisibility(View.GONE);
        mMetadataBlackScrim.setVisibility(View.GONE);
        mMetadataBackground.setImageBitmap(null);
    }
    clearLoadedBitmap();
    updateMetadataLayout();
}
#end_block

#method_before
protected void copyFrom(ServiceState s) {
    mVoiceRegState = s.mVoiceRegState;
    mDataRegState = s.mDataRegState;
    mVoiceRoamingType = s.mVoiceRoamingType;
    mDataRoamingType = s.mDataRoamingType;
    mVoiceOperatorAlphaLong = s.mVoiceOperatorAlphaLong;
    mVoiceOperatorAlphaShort = s.mVoiceOperatorAlphaShort;
    mVoiceOperatorNumeric = s.mVoiceOperatorNumeric;
    mDataOperatorAlphaLong = s.mDataOperatorAlphaLong;
    mDataOperatorAlphaShort = s.mDataOperatorAlphaShort;
    mDataOperatorNumeric = s.mDataOperatorNumeric;
    mIsManualNetworkSelection = s.mIsManualNetworkSelection;
    mRilVoiceRadioTechnology = s.mRilVoiceRadioTechnology;
    mRilDataRadioTechnology = s.mRilDataRadioTechnology;
    mCssIndicator = s.mCssIndicator;
    mNetworkId = s.mNetworkId;
    mSystemId = s.mSystemId;
    mCdmaRoamingIndicator = s.mCdmaRoamingIndicator;
    mCdmaDefaultRoamingIndicator = s.mCdmaDefaultRoamingIndicator;
    mCdmaEriIconIndex = s.mCdmaEriIconIndex;
    mCdmaEriIconMode = s.mCdmaEriIconMode;
    mIsEmergencyOnly = s.mIsEmergencyOnly;
    mIsDataRoamingFromRegistration = s.mIsDataRoamingFromRegistration;
    mIsUsingCarrierAggregation = s.mIsUsingCarrierAggregation;
    mChannelNumber = s.mChannelNumber;
    mCellBandwidths = s.mCellBandwidths == null ? new int[0] : Arrays.copyOf(s.mCellBandwidths, s.mCellBandwidths.length);
    mLteEarfcnRsrpBoost = s.mLteEarfcnRsrpBoost;
    mNetworkRegistrationStates = new ArrayList<>(s.mNetworkRegistrationStates);
}
#method_after
protected void copyFrom(ServiceState s) {
    mVoiceRegState = s.mVoiceRegState;
    mDataRegState = s.mDataRegState;
    mVoiceRoamingType = s.mVoiceRoamingType;
    mDataRoamingType = s.mDataRoamingType;
    mVoiceOperatorAlphaLong = s.mVoiceOperatorAlphaLong;
    mVoiceOperatorAlphaShort = s.mVoiceOperatorAlphaShort;
    mVoiceOperatorNumeric = s.mVoiceOperatorNumeric;
    mDataOperatorAlphaLong = s.mDataOperatorAlphaLong;
    mDataOperatorAlphaShort = s.mDataOperatorAlphaShort;
    mDataOperatorNumeric = s.mDataOperatorNumeric;
    mIsManualNetworkSelection = s.mIsManualNetworkSelection;
    mRilVoiceRadioTechnology = s.mRilVoiceRadioTechnology;
    mRilDataRadioTechnology = s.mRilDataRadioTechnology;
    mCssIndicator = s.mCssIndicator;
    mNetworkId = s.mNetworkId;
    mSystemId = s.mSystemId;
    mCdmaRoamingIndicator = s.mCdmaRoamingIndicator;
    mCdmaDefaultRoamingIndicator = s.mCdmaDefaultRoamingIndicator;
    mCdmaEriIconIndex = s.mCdmaEriIconIndex;
    mCdmaEriIconMode = s.mCdmaEriIconMode;
    mIsEmergencyOnly = s.mIsEmergencyOnly;
    mIsDataRoamingFromRegistration = s.mIsDataRoamingFromRegistration;
    mIsUsingCarrierAggregation = s.mIsUsingCarrierAggregation;
    mChannelNumber = s.mChannelNumber;
    mCellBandwidths = s.mCellBandwidths == null ? null : Arrays.copyOf(s.mCellBandwidths, s.mCellBandwidths.length);
    mLteEarfcnRsrpBoost = s.mLteEarfcnRsrpBoost;
    mNetworkRegistrationStates = s.mNetworkRegistrationStates == null ? null : new ArrayList<>(s.mNetworkRegistrationStates);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (!(o instanceof ServiceState))
        return false;
    ServiceState s = (ServiceState) o;
    return (mVoiceRegState == s.mVoiceRegState && mDataRegState == s.mDataRegState && mIsManualNetworkSelection == s.mIsManualNetworkSelection && mVoiceRoamingType == s.mVoiceRoamingType && mDataRoamingType == s.mDataRoamingType && mChannelNumber == s.mChannelNumber && Arrays.equals(mCellBandwidths, s.mCellBandwidths) && equalsHandlesNulls(mVoiceOperatorAlphaLong, s.mVoiceOperatorAlphaLong) && equalsHandlesNulls(mVoiceOperatorAlphaShort, s.mVoiceOperatorAlphaShort) && equalsHandlesNulls(mVoiceOperatorNumeric, s.mVoiceOperatorNumeric) && equalsHandlesNulls(mDataOperatorAlphaLong, s.mDataOperatorAlphaLong) && equalsHandlesNulls(mDataOperatorAlphaShort, s.mDataOperatorAlphaShort) && equalsHandlesNulls(mDataOperatorNumeric, s.mDataOperatorNumeric) && equalsHandlesNulls(mRilVoiceRadioTechnology, s.mRilVoiceRadioTechnology) && equalsHandlesNulls(mRilDataRadioTechnology, s.mRilDataRadioTechnology) && equalsHandlesNulls(mCssIndicator, s.mCssIndicator) && equalsHandlesNulls(mNetworkId, s.mNetworkId) && equalsHandlesNulls(mSystemId, s.mSystemId) && equalsHandlesNulls(mCdmaRoamingIndicator, s.mCdmaRoamingIndicator) && equalsHandlesNulls(mCdmaDefaultRoamingIndicator, s.mCdmaDefaultRoamingIndicator) && mIsEmergencyOnly == s.mIsEmergencyOnly && mIsDataRoamingFromRegistration == s.mIsDataRoamingFromRegistration && mIsUsingCarrierAggregation == s.mIsUsingCarrierAggregation) && mNetworkRegistrationStates.containsAll(s.mNetworkRegistrationStates);
}
#method_after
@Override
public boolean equals(Object o) {
    if (!(o instanceof ServiceState))
        return false;
    ServiceState s = (ServiceState) o;
    return (mVoiceRegState == s.mVoiceRegState && mDataRegState == s.mDataRegState && mIsManualNetworkSelection == s.mIsManualNetworkSelection && mVoiceRoamingType == s.mVoiceRoamingType && mDataRoamingType == s.mDataRoamingType && mChannelNumber == s.mChannelNumber && Arrays.equals(mCellBandwidths, s.mCellBandwidths) && equalsHandlesNulls(mVoiceOperatorAlphaLong, s.mVoiceOperatorAlphaLong) && equalsHandlesNulls(mVoiceOperatorAlphaShort, s.mVoiceOperatorAlphaShort) && equalsHandlesNulls(mVoiceOperatorNumeric, s.mVoiceOperatorNumeric) && equalsHandlesNulls(mDataOperatorAlphaLong, s.mDataOperatorAlphaLong) && equalsHandlesNulls(mDataOperatorAlphaShort, s.mDataOperatorAlphaShort) && equalsHandlesNulls(mDataOperatorNumeric, s.mDataOperatorNumeric) && equalsHandlesNulls(mRilVoiceRadioTechnology, s.mRilVoiceRadioTechnology) && equalsHandlesNulls(mRilDataRadioTechnology, s.mRilDataRadioTechnology) && equalsHandlesNulls(mCssIndicator, s.mCssIndicator) && equalsHandlesNulls(mNetworkId, s.mNetworkId) && equalsHandlesNulls(mSystemId, s.mSystemId) && equalsHandlesNulls(mCdmaRoamingIndicator, s.mCdmaRoamingIndicator) && equalsHandlesNulls(mCdmaDefaultRoamingIndicator, s.mCdmaDefaultRoamingIndicator) && mIsEmergencyOnly == s.mIsEmergencyOnly && mIsDataRoamingFromRegistration == s.mIsDataRoamingFromRegistration && mIsUsingCarrierAggregation == s.mIsUsingCarrierAggregation) && (mNetworkRegistrationStates == null ? s.mNetworkRegistrationStates == null : s.mNetworkRegistrationStates != null && mNetworkRegistrationStates.containsAll(s.mNetworkRegistrationStates));
}
#end_block

#method_before
// This method is called
// 1. When the data roaming status changes from non-roaming to roaming.
private void onDataRoamingOnOrSettingsChanged(int messageType) {
    if (DBG)
        log("onDataRoamingOnOrSettingsChanged");
    // Used to differentiate data roaming turned on vs settings changed.
    boolean settingChanged = (messageType == DctConstants.EVENT_ROAMING_SETTING_CHANGE);
    // Check if the device is actually data roaming
    if (!mPhone.getServiceState().getDataRoaming()) {
        if (DBG)
            log("device is not roaming. ignored the request.");
        return;
    }
    if (getDataRoamingEnabled()) {
        if (DBG)
            log("onDataRoamingOnOrSettingsChanged: setup data on roaming");
        setupDataOnConnectableApns(Phone.REASON_ROAMING_ON);
        notifyDataConnection(Phone.REASON_ROAMING_ON);
    } else {
        // charged for data roaming usage.
        if (DBG)
            log("onDataRoamingOnOrSettingsChanged: Tear down data connection on roaming.");
        cleanUpAllConnections(true, Phone.REASON_ROAMING_ON);
        notifyOffApnsOfAvailability(Phone.REASON_ROAMING_ON);
    }
}
#method_after
// This method is called
// 1. When the data roaming status changes from non-roaming to roaming.
private void onDataRoamingOnOrSettingsChanged(int messageType) {
    if (DBG)
        log("onDataRoamingOnOrSettingsChanged");
    // Used to differentiate data roaming turned on vs settings changed.
    boolean settingChanged = (messageType == DctConstants.EVENT_ROAMING_SETTING_CHANGE);
    // Check if the device is actually data roaming
    if (!mPhone.getServiceState().getDataRoaming()) {
        if (DBG)
            log("device is not roaming. ignored the request.");
        return;
    }
    checkDataRoamingStatus(settingChanged);
    if (getDataRoamingEnabled()) {
        if (DBG)
            log("onDataRoamingOnOrSettingsChanged: setup data on roaming");
        setupDataOnConnectableApns(Phone.REASON_ROAMING_ON);
        notifyDataConnection(Phone.REASON_ROAMING_ON);
    } else {
        // charged for data roaming usage.
        if (DBG)
            log("onDataRoamingOnOrSettingsChanged: Tear down data connection on roaming.");
        cleanUpAllConnections(true, Phone.REASON_ROAMING_ON);
        notifyOffApnsOfAvailability(Phone.REASON_ROAMING_ON);
    }
}
#end_block

#method_before
private void onDataSetupComplete(AsyncResult ar) {
    DcFailCause cause = DcFailCause.UNKNOWN;
    boolean handleError = false;
    ApnContext apnContext = getValidApnContext(ar, "onDataSetupComplete");
    if (apnContext == null)
        return;
    if (ar.exception == null) {
        DataConnection dataConnection = apnContext.getDataConnection();
        if (RADIO_TESTS) {
            // Note: To change radio.test.onDSC.null.dcac from command line you need to
            // adb root and adb remount and from the command line you can only change the
            // value to 1 once. To change it a second time you can reboot or execute
            // adb shell stop and then adb shell start. The command line to set the value is:
            // adb shell sqlite3 /data/data/com.android.providers.settings/databases/settings.db "insert into system (name,value) values ('radio.test.onDSC.null.dcac', '1');"
            ContentResolver cr = mPhone.getContext().getContentResolver();
            String radioTestProperty = "radio.test.onDSC.null.dcac";
            if (Settings.System.getInt(cr, radioTestProperty, 0) == 1) {
                log("onDataSetupComplete: " + radioTestProperty + " is true, set dcac to null and reset property to false");
                dataConnection = null;
                Settings.System.putInt(cr, radioTestProperty, 0);
                log("onDataSetupComplete: " + radioTestProperty + "=" + Settings.System.getInt(mPhone.getContext().getContentResolver(), radioTestProperty, -1));
            }
        }
        if (dataConnection == null) {
            log("onDataSetupComplete: no connection to DC, handle as error");
            cause = DcFailCause.CONNECTION_TO_DATACONNECTIONAC_BROKEN;
            handleError = true;
        } else {
            ApnSetting apn = apnContext.getApnSetting();
            if (DBG) {
                log("onDataSetupComplete: success apn=" + (apn == null ? "unknown" : apn.getApnName()));
            }
            if (apn != null && !TextUtils.isEmpty(apn.getProxyAddressAsString())) {
                try {
                    int port = apn.getProxyPort();
                    if (port == -1) {
                        port = 8080;
                    }
                    ProxyInfo proxy = new ProxyInfo(apn.getProxyAddressAsString(), port, null);
                    dataConnection.setLinkPropertiesHttpProxy(proxy);
                } catch (NumberFormatException e) {
                    loge("onDataSetupComplete: NumberFormatException making ProxyProperties (" + apn.getProxyPort() + "): " + e);
                }
            }
            // everything is setup
            if (TextUtils.equals(apnContext.getApnType(), PhoneConstants.APN_TYPE_DEFAULT)) {
                try {
                    SystemProperties.set(PUPPET_MASTER_RADIO_STRESS_TEST, "true");
                } catch (RuntimeException ex) {
                    log("Failed to set PUPPET_MASTER_RADIO_STRESS_TEST to true");
                }
                if (mCanSetPreferApn && mPreferredApn == null) {
                    if (DBG)
                        log("onDataSetupComplete: PREFERRED APN is null");
                    mPreferredApn = apn;
                    if (mPreferredApn != null) {
                        setPreferredApn(mPreferredApn.getId());
                    }
                }
            } else {
                try {
                    SystemProperties.set(PUPPET_MASTER_RADIO_STRESS_TEST, "false");
                } catch (RuntimeException ex) {
                    log("Failed to set PUPPET_MASTER_RADIO_STRESS_TEST to false");
                }
            }
            // A connection is setup
            apnContext.setState(DctConstants.State.CONNECTED);
            boolean isProvApn = apnContext.isProvisioningApn();
            final ConnectivityManager cm = ConnectivityManager.from(mPhone.getContext());
            if (mProvisionBroadcastReceiver != null) {
                mPhone.getContext().unregisterReceiver(mProvisionBroadcastReceiver);
                mProvisionBroadcastReceiver = null;
            }
            if ((!isProvApn) || mIsProvisioning) {
                // Hide any provisioning notification.
                cm.setProvisioningNotificationVisible(false, ConnectivityManager.TYPE_MOBILE, mProvisionActionName);
                // Complete the connection normally notifying the world we're connected.
                // We do this if this isn't a special provisioning apn or if we've been
                // told its time to provision.
                completeConnection(apnContext);
            } else {
                // is sent to the DCT.
                if (DBG) {
                    log("onDataSetupComplete: successful, BUT send connected to prov apn as" + " mIsProvisioning:" + mIsProvisioning + " == false" + " && (isProvisioningApn:" + isProvApn + " == true");
                }
                // While radio is up, grab provisioning URL.  The URL contains ICCID which
                // disappears when radio is off.
                mProvisionBroadcastReceiver = new ProvisionNotificationBroadcastReceiver(cm.getMobileProvisioningUrl(), TelephonyManager.getDefault().getNetworkOperatorName());
                mPhone.getContext().registerReceiver(mProvisionBroadcastReceiver, new IntentFilter(mProvisionActionName));
                // Put up user notification that sign-in is required.
                cm.setProvisioningNotificationVisible(true, ConnectivityManager.TYPE_MOBILE, mProvisionActionName);
                // Turn off radio to save battery and avoid wasting carrier resources.
                // The network isn't usable and network validation will just fail anyhow.
                setRadio(false);
            }
            if (DBG) {
                log("onDataSetupComplete: SETUP complete type=" + apnContext.getApnType() + ", reason:" + apnContext.getReason());
            }
            if (Build.IS_DEBUGGABLE) {
                // adb shell setprop persist.radio.test.pco [pco_val]
                String radioTestProperty = "persist.radio.test.pco";
                int pcoVal = SystemProperties.getInt(radioTestProperty, -1);
                if (pcoVal != -1) {
                    log("PCO testing: read pco value from persist.radio.test.pco " + pcoVal);
                    final byte[] value = new byte[1];
                    value[0] = (byte) pcoVal;
                    final Intent intent = new Intent(TelephonyIntents.ACTION_CARRIER_SIGNAL_PCO_VALUE);
                    intent.putExtra(TelephonyIntents.EXTRA_APN_TYPE_KEY, "default");
                    intent.putExtra(TelephonyIntents.EXTRA_APN_PROTO_KEY, "IPV4V6");
                    intent.putExtra(TelephonyIntents.EXTRA_PCO_ID_KEY, 0xFF00);
                    intent.putExtra(TelephonyIntents.EXTRA_PCO_VALUE_KEY, value);
                    mPhone.getCarrierSignalAgent().notifyCarrierSignalReceivers(intent);
                }
            }
        }
    } else {
        cause = (DcFailCause) (ar.result);
        if (DBG) {
            ApnSetting apn = apnContext.getApnSetting();
            log(String.format("onDataSetupComplete: error apn=%s cause=%s", (apn == null ? "unknown" : apn.getApnName()), cause));
        }
        if (cause.isEventLoggable()) {
            // Log this failure to the Event Logs.
            int cid = getCellLocationId();
            EventLog.writeEvent(EventLogTags.PDP_SETUP_FAIL, cause.ordinal(), cid, TelephonyManager.getDefault().getNetworkType());
        }
        ApnSetting apn = apnContext.getApnSetting();
        mPhone.notifyPreciseDataConnectionFailed(apnContext.getReason(), apnContext.getApnType(), apn != null ? apn.getApnName() : "unknown", cause.toString());
        // Compose broadcast intent send to the specific carrier signaling receivers
        Intent intent = new Intent(TelephonyIntents.ACTION_CARRIER_SIGNAL_REQUEST_NETWORK_FAILED);
        intent.putExtra(TelephonyIntents.EXTRA_ERROR_CODE_KEY, cause.getErrorCode());
        intent.putExtra(TelephonyIntents.EXTRA_APN_TYPE_KEY, apnContext.getApnType());
        mPhone.getCarrierSignalAgent().notifyCarrierSignalReceivers(intent);
        if (cause.isRadioRestartFailure(mPhone.getContext(), mPhone.getSubId()) || apnContext.restartOnError(cause.getErrorCode())) {
            if (DBG)
                log("Modem restarted.");
            sendRestartRadio();
        }
        // failed.
        if (isPermanentFailure(cause)) {
            log("cause = " + cause + ", mark apn as permanent failed. apn = " + apn);
            apnContext.markApnPermanentFailed(apn);
        }
        handleError = true;
    }
    if (handleError) {
        onDataSetupCompleteError(ar);
    }
    /* If flag is set to false after SETUP_DATA_CALL is invoked, we need
         * to clean data connections.
         */
    if (!mDataEnabledSettings.isInternalDataEnabled()) {
        cleanUpAllConnections(Phone.REASON_DATA_DISABLED);
    }
}
#method_after
private void onDataSetupComplete(AsyncResult ar) {
    DcFailCause cause = DcFailCause.UNKNOWN;
    boolean handleError = false;
    ApnContext apnContext = getValidApnContext(ar, "onDataSetupComplete");
    if (apnContext == null)
        return;
    if (ar.exception == null) {
        DataConnection dataConnection = apnContext.getDataConnection();
        if (RADIO_TESTS) {
            // Note: To change radio.test.onDSC.null.dcac from command line you need to
            // adb root and adb remount and from the command line you can only change the
            // value to 1 once. To change it a second time you can reboot or execute
            // adb shell stop and then adb shell start. The command line to set the value is:
            // adb shell sqlite3 /data/data/com.android.providers.settings/databases/settings.db "insert into system (name,value) values ('radio.test.onDSC.null.dcac', '1');"
            ContentResolver cr = mPhone.getContext().getContentResolver();
            String radioTestProperty = "radio.test.onDSC.null.dcac";
            if (Settings.System.getInt(cr, radioTestProperty, 0) == 1) {
                log("onDataSetupComplete: " + radioTestProperty + " is true, set dcac to null and reset property to false");
                dataConnection = null;
                Settings.System.putInt(cr, radioTestProperty, 0);
                log("onDataSetupComplete: " + radioTestProperty + "=" + Settings.System.getInt(mPhone.getContext().getContentResolver(), radioTestProperty, -1));
            }
        }
        if (dataConnection == null) {
            log("onDataSetupComplete: no connection to DC, handle as error");
            cause = DcFailCause.CONNECTION_TO_DATACONNECTIONAC_BROKEN;
            handleError = true;
        } else {
            ApnSetting apn = apnContext.getApnSetting();
            if (DBG) {
                log("onDataSetupComplete: success apn=" + (apn == null ? "unknown" : apn.getApnName()));
            }
            if (apn != null && !TextUtils.isEmpty(apn.getProxyAddressAsString())) {
                try {
                    int port = apn.getProxyPort();
                    if (port == -1) {
                        port = 8080;
                    }
                    ProxyInfo proxy = new ProxyInfo(apn.getProxyAddressAsString(), port, null);
                    dataConnection.setLinkPropertiesHttpProxy(proxy);
                } catch (NumberFormatException e) {
                    loge("onDataSetupComplete: NumberFormatException making ProxyProperties (" + apn.getProxyPort() + "): " + e);
                }
            }
            // everything is setup
            if (TextUtils.equals(apnContext.getApnType(), PhoneConstants.APN_TYPE_DEFAULT)) {
                try {
                    SystemProperties.set(PUPPET_MASTER_RADIO_STRESS_TEST, "true");
                } catch (RuntimeException ex) {
                    log("Failed to set PUPPET_MASTER_RADIO_STRESS_TEST to true");
                }
                if (mCanSetPreferApn && mPreferredApn == null) {
                    if (DBG)
                        log("onDataSetupComplete: PREFERRED APN is null");
                    mPreferredApn = apn;
                    if (mPreferredApn != null) {
                        setPreferredApn(mPreferredApn.getId());
                    }
                }
            } else {
                try {
                    SystemProperties.set(PUPPET_MASTER_RADIO_STRESS_TEST, "false");
                } catch (RuntimeException ex) {
                    log("Failed to set PUPPET_MASTER_RADIO_STRESS_TEST to false");
                }
            }
            // A connection is setup
            apnContext.setState(DctConstants.State.CONNECTED);
            checkDataRoamingStatus(false);
            boolean isProvApn = apnContext.isProvisioningApn();
            final ConnectivityManager cm = ConnectivityManager.from(mPhone.getContext());
            if (mProvisionBroadcastReceiver != null) {
                mPhone.getContext().unregisterReceiver(mProvisionBroadcastReceiver);
                mProvisionBroadcastReceiver = null;
            }
            if ((!isProvApn) || mIsProvisioning) {
                // Hide any provisioning notification.
                cm.setProvisioningNotificationVisible(false, ConnectivityManager.TYPE_MOBILE, mProvisionActionName);
                // Complete the connection normally notifying the world we're connected.
                // We do this if this isn't a special provisioning apn or if we've been
                // told its time to provision.
                completeConnection(apnContext);
            } else {
                // is sent to the DCT.
                if (DBG) {
                    log("onDataSetupComplete: successful, BUT send connected to prov apn as" + " mIsProvisioning:" + mIsProvisioning + " == false" + " && (isProvisioningApn:" + isProvApn + " == true");
                }
                // While radio is up, grab provisioning URL.  The URL contains ICCID which
                // disappears when radio is off.
                mProvisionBroadcastReceiver = new ProvisionNotificationBroadcastReceiver(cm.getMobileProvisioningUrl(), TelephonyManager.getDefault().getNetworkOperatorName());
                mPhone.getContext().registerReceiver(mProvisionBroadcastReceiver, new IntentFilter(mProvisionActionName));
                // Put up user notification that sign-in is required.
                cm.setProvisioningNotificationVisible(true, ConnectivityManager.TYPE_MOBILE, mProvisionActionName);
                // Turn off radio to save battery and avoid wasting carrier resources.
                // The network isn't usable and network validation will just fail anyhow.
                setRadio(false);
            }
            if (DBG) {
                log("onDataSetupComplete: SETUP complete type=" + apnContext.getApnType() + ", reason:" + apnContext.getReason());
            }
            if (Build.IS_DEBUGGABLE) {
                // adb shell setprop persist.radio.test.pco [pco_val]
                String radioTestProperty = "persist.radio.test.pco";
                int pcoVal = SystemProperties.getInt(radioTestProperty, -1);
                if (pcoVal != -1) {
                    log("PCO testing: read pco value from persist.radio.test.pco " + pcoVal);
                    final byte[] value = new byte[1];
                    value[0] = (byte) pcoVal;
                    final Intent intent = new Intent(TelephonyIntents.ACTION_CARRIER_SIGNAL_PCO_VALUE);
                    intent.putExtra(TelephonyIntents.EXTRA_APN_TYPE_KEY, "default");
                    intent.putExtra(TelephonyIntents.EXTRA_APN_PROTO_KEY, "IPV4V6");
                    intent.putExtra(TelephonyIntents.EXTRA_PCO_ID_KEY, 0xFF00);
                    intent.putExtra(TelephonyIntents.EXTRA_PCO_VALUE_KEY, value);
                    mPhone.getCarrierSignalAgent().notifyCarrierSignalReceivers(intent);
                }
            }
        }
    } else {
        cause = (DcFailCause) (ar.result);
        if (DBG) {
            ApnSetting apn = apnContext.getApnSetting();
            log(String.format("onDataSetupComplete: error apn=%s cause=%s", (apn == null ? "unknown" : apn.getApnName()), cause));
        }
        if (cause.isEventLoggable()) {
            // Log this failure to the Event Logs.
            int cid = getCellLocationId();
            EventLog.writeEvent(EventLogTags.PDP_SETUP_FAIL, cause.ordinal(), cid, TelephonyManager.getDefault().getNetworkType());
        }
        ApnSetting apn = apnContext.getApnSetting();
        mPhone.notifyPreciseDataConnectionFailed(apnContext.getReason(), apnContext.getApnType(), apn != null ? apn.getApnName() : "unknown", cause.toString());
        // Compose broadcast intent send to the specific carrier signaling receivers
        Intent intent = new Intent(TelephonyIntents.ACTION_CARRIER_SIGNAL_REQUEST_NETWORK_FAILED);
        intent.putExtra(TelephonyIntents.EXTRA_ERROR_CODE_KEY, cause.getErrorCode());
        intent.putExtra(TelephonyIntents.EXTRA_APN_TYPE_KEY, apnContext.getApnType());
        mPhone.getCarrierSignalAgent().notifyCarrierSignalReceivers(intent);
        if (cause.isRadioRestartFailure(mPhone.getContext(), mPhone.getSubId()) || apnContext.restartOnError(cause.getErrorCode())) {
            if (DBG)
                log("Modem restarted.");
            sendRestartRadio();
        }
        // failed.
        if (isPermanentFailure(cause)) {
            log("cause = " + cause + ", mark apn as permanent failed. apn = " + apn);
            apnContext.markApnPermanentFailed(apn);
        }
        handleError = true;
    }
    if (handleError) {
        onDataSetupCompleteError(ar);
    }
    /* If flag is set to false after SETUP_DATA_CALL is invoked, we need
         * to clean data connections.
         */
    if (!mDataEnabledSettings.isInternalDataEnabled()) {
        cleanUpAllConnections(Phone.REASON_DATA_DISABLED);
    }
}
#end_block

#method_before
public void onBufferingStateChanged(@NonNull SessionPlayer2 player, @Nullable MediaItemDesc2 desc, @BuffState int buffState) {
}
#method_after
public void onBufferingStateChanged(@NonNull SessionPlayer2 player, @Nullable MediaItem2 desc, @BuffState int buffState) {
}
#end_block

#method_before
public void onPlaylistChanged(@NonNull SessionPlayer2 player, List<MediaItemDesc2> list, @Nullable MediaMetadata2 metadata) {
}
#method_after
public void onPlaylistChanged(@NonNull SessionPlayer2 player, List<MediaItem2> list, @Nullable MediaMetadata2 metadata) {
}
#end_block

#method_before
@Status
public int apply(@NonNull Context context, @NonNull Spannable text, @NonNull TextLinksParams textLinksParams) {
    Preconditions.checkNotNull(text);
    TextClassifier textClassifier = TextClassificationManager.of(context).getTextClassifier();
    // TODO: If text is longer than the supported length, break it down and process them.
    SpannableString truncatedText = SpannableString.valueOf(text.subSequence(0, Math.min(text.length(), textClassifier.getMaxGenerateLinksTextLength())));
    return textLinksParams.apply(truncatedText, this, textClassifier);
}
#method_after
@UiThread
@Status
public int apply(@NonNull TextView textView, TextLinksParams textLinksParams) {
    Preconditions.checkNotNull(textView);
    addLinkMovementMethod(textView);
    SpannableString spannableString = SpannableString.valueOf(textView.getText());
    int status = apply(textView.getContext(), spannableString, textLinksParams);
    if (status == TextLinks.STATUS_LINKS_APPLIED) {
        textView.setText(spannableString);
    }
    return status;
}
#end_block

#method_before
@Status
public int apply(@NonNull Context context, @NonNull Spannable text, @NonNull TextLinksParams textLinksParams) {
    Preconditions.checkNotNull(text);
    TextClassifier textClassifier = TextClassificationManager.of(context).getTextClassifier();
    // TODO: If text is longer than the supported length, break it down and process them.
    SpannableString truncatedText = SpannableString.valueOf(text.subSequence(0, Math.min(text.length(), textClassifier.getMaxGenerateLinksTextLength())));
    return textLinksParams.apply(truncatedText, this, textClassifier);
}
#method_after
@Status
public int apply(@NonNull Context context, @NonNull Spannable text, @NonNull TextLinksParams textLinksParams) {
    Preconditions.checkNotNull(context);
    Preconditions.checkNotNull(text);
    Preconditions.checkNotNull(textLinksParams);
    TextClassifier textClassifier = TextClassificationManager.of(context).getTextClassifier();
    return textLinksParams.apply(text, this, textClassifier);
}
#end_block

#method_before
@NonNull
public TextLinks build() {
    return new TextLinks(mFullText, mLinks);
}
#method_after
@NonNull
public Request build() {
    return new Request(mText, mDefaultLocales, mEntityConfig);
}
#end_block

#method_before
@Test
public void testResolveWithValue() {
    final int value = 10;
    final ListenableFuture<Integer> future = FutureExtras.resolve(value);
    assertValue(future, value);
}
#method_after
@Test
public void testResolveWithValue() {
    final int value = 10;
    final ListenableFuture<Integer> future = resolve(value);
    assertValue(future, value);
}
#end_block

#method_before
@Test
public void testResolveWithException() {
    final Throwable throwable = new RuntimeException("An exception occurred.");
    final ListenableFuture<Integer> future = FutureExtras.resolveWithException(throwable);
    assertExceptionWithMessage(future, throwable.getMessage());
}
#method_after
@Test
public void testResolveWithException() {
    final Throwable throwable = new RuntimeException("An exception occurred.");
    final ListenableFuture<Integer> future = resolveWithException(throwable);
    assertExceptionWithMessage(future, throwable.getMessage());
}
#end_block

#method_before
@Test
public void testMap() {
    int value = 10;
    ListenableFuture<Integer> input = FutureExtras.resolve(value);
    Function<Integer, String> mapper = new Function<Integer, String>() {

        @Override
        public String apply(Integer input) {
            return String.valueOf(input);
        }
    };
    ListenableFuture<String> result = FutureExtras.map(input, mExecutor, mapper);
    assertValue(result, String.valueOf(value));
}
#method_after
@Test
public void testMap() {
    int value = 10;
    ListenableFuture<Integer> input = resolve(value);
    Function<Integer, String> mapper = new Function<Integer, String>() {

        @Override
        public String apply(Integer input) {
            return String.valueOf(input);
        }
    };
    ListenableFuture<String> result = FutureExtras.map(input, mExecutor, mapper);
    assertValue(result, String.valueOf(value));
}
#end_block

#method_before
@Test
public void testMapWithException() {
    final String message = "Something bad happened";
    ListenableFuture<Integer> input = FutureExtras.resolve(10);
    Function<Integer, String> mapper = new Function<Integer, String>() {

        @Override
        public String apply(Integer input) {
            throw new RuntimeException(message);
        }
    };
    ListenableFuture<String> result = FutureExtras.map(input, mExecutor, mapper);
    assertExceptionWithMessage(result, message);
}
#method_after
@Test
public void testMapWithException() {
    final String message = "Something bad happened";
    ListenableFuture<Integer> input = resolve(10);
    Function<Integer, String> mapper = new Function<Integer, String>() {

        @Override
        public String apply(Integer input) {
            throw new RuntimeException(message);
        }
    };
    ListenableFuture<String> result = FutureExtras.map(input, mExecutor, mapper);
    assertExceptionWithMessage(result, message);
}
#end_block

#method_before
@Test
public void testFlatMap() {
    int value = 10;
    ListenableFuture<Integer> input = FutureExtras.resolve(value);
    Function<Integer, ListenableFuture<String>> flatMapper = new Function<Integer, ListenableFuture<String>>() {

        @Override
        public ListenableFuture<String> apply(Integer integer) {
            return FutureExtras.resolve(String.valueOf(integer));
        }
    };
    ListenableFuture<String> result = FutureExtras.flatMap(input, mExecutor, flatMapper);
    assertValue(result, String.valueOf(value));
}
#method_after
@Test
public void testFlatMap() {
    int value = 10;
    ListenableFuture<Integer> input = resolve(value);
    Function<Integer, ListenableFuture<String>> flatMapper = new Function<Integer, ListenableFuture<String>>() {

        @Override
        public ListenableFuture<String> apply(Integer integer) {
            return resolve(String.valueOf(integer));
        }
    };
    ListenableFuture<String> result = FutureExtras.flatMap(input, mExecutor, flatMapper);
    assertValue(result, String.valueOf(value));
}
#end_block

#method_before
@Test
public void testFlatMapWithException() {
    final String message = "Something bad happened";
    ListenableFuture<Integer> input = FutureExtras.resolve(10);
    Function<Integer, ListenableFuture<String>> flatMapper = new Function<Integer, ListenableFuture<String>>() {

        @Override
        public ListenableFuture<String> apply(Integer integer) {
            throw new RuntimeException(message);
        }
    };
    ListenableFuture<String> result = FutureExtras.flatMap(input, mExecutor, flatMapper);
    assertExceptionWithMessage(result, message);
}
#method_after
@Test
public void testFlatMapWithException() {
    final String message = "Something bad happened";
    ListenableFuture<Integer> input = resolve(10);
    Function<Integer, ListenableFuture<String>> flatMapper = new Function<Integer, ListenableFuture<String>>() {

        @Override
        public ListenableFuture<String> apply(Integer integer) {
            throw new RuntimeException(message);
        }
    };
    ListenableFuture<String> result = FutureExtras.flatMap(input, mExecutor, flatMapper);
    assertExceptionWithMessage(result, message);
}
#end_block

#method_before
public void sendDialerSpecialCode(String code) {
    if (!TextUtils.isEmpty(code)) {
        Intent intent = new Intent(TelephonyIntents.SECRET_CODE_ACTION, Uri.parse("android_secret_code://" + code));
        intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
        mContext.sendBroadcast(intent);
        // {@link TelephonyManager.SECRET_CODE_ACTION} will replace {@link
        // TelephonyIntents#SECRET_CODE_ACTION} in the next Android version. Before
        // that both of these two actions will be broadcast.
        Intent secrectCodeIntent = new Intent(TelephonyManager.SECRET_CODE_ACTION, Uri.parse("android_secret_code://" + code));
        intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
        mContext.sendBroadcast(secrectCodeIntent);
    }
}
#method_after
public void sendDialerSpecialCode(String code) {
    if (!TextUtils.isEmpty(code)) {
        Intent intent = new Intent(TelephonyIntents.SECRET_CODE_ACTION, Uri.parse("android_secret_code://" + code));
        intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
        mContext.sendBroadcast(intent);
        // {@link TelephonyManager.ACTION_SECRET_CODE} will replace {@link
        // TelephonyIntents#SECRET_CODE_ACTION} in the next Android version. Before
        // that both of these two actions will be broadcast.
        Intent secrectCodeIntent = new Intent(TelephonyManager.ACTION_SECRET_CODE, Uri.parse("android_secret_code://" + code));
        intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
        mContext.sendBroadcast(secrectCodeIntent);
    }
}
#end_block

#method_before
@Override
protected void validateMigration(SupportSQLiteDatabase db) {
    final Map<String, EntityBundle> tables = mDatabaseBundle.getEntitiesByTableName();
    for (EntityBundle entity : tables.values()) {
        if (entity instanceof FtsEntityBundle) {
            final TableCreateInfo expected = toTableCreateInfo((FtsEntityBundle) entity);
            final TableCreateInfo found = TableCreateInfo.read(db, entity.getTableName());
            if (!expected.equals(found)) {
                throw new IllegalStateException("Migration failed.\nExpected:" + expected + "\nFound:" + found);
            }
        } else {
            final TableInfo expected = toTableInfo(entity);
            final TableInfo found = TableInfo.read(db, entity.getTableName());
            if (!expected.equals(found)) {
                throw new IllegalStateException("Migration failed.\nExpected:" + expected + " \nfound:" + found);
            }
        }
    }
    if (mVerifyDroppedTables) {
        List<String> excludeList = new ArrayList<>();
        excludeList.add(Room.MASTER_TABLE_NAME);
        excludeList.add("android_metadata");
        excludeList.add("sqlite_sequence");
        for (EntityBundle entity : mDatabaseBundle.getEntities()) {
            // add fts shadow table names to the excluded list
            if (entity instanceof FtsEntityBundle) {
                excludeList.addAll(((FtsEntityBundle) entity).getShadowTableNames());
            }
        }
        // now ensure tables that should be removed are removed, expect for those in the
        // excluded list.
        StringBuilder query = new StringBuilder("SELECT name FROM sqlite_master " + "WHERE type='table' AND name NOT IN (");
        for (int i = 0; i < excludeList.size(); i++) {
            if (i == 0) {
                query.append("?");
            } else {
                query.append(",?");
            }
        }
        query.append(")");
        Cursor cursor = db.query(query.toString(), excludeList.toArray(new String[0]));
        // noinspection TryFinallyCanBeTryWithResources
        try {
            while (cursor.moveToNext()) {
                final String tableName = cursor.getString(0);
                if (!tables.containsKey(tableName)) {
                    throw new IllegalStateException("Migration failed. Unexpected table " + tableName);
                }
            }
        } finally {
            cursor.close();
        }
    }
}
#method_after
@Override
protected void validateMigration(SupportSQLiteDatabase db) {
    final Map<String, EntityBundle> tables = mDatabaseBundle.getEntitiesByTableName();
    for (EntityBundle entity : tables.values()) {
        if (entity instanceof FtsEntityBundle) {
            final FtsTableInfo expected = toFtsTableInfo((FtsEntityBundle) entity);
            final FtsTableInfo found = FtsTableInfo.read(db, entity.getTableName());
            if (!expected.equals(found)) {
                throw new IllegalStateException("Migration failed.\nExpected:" + expected + "\nFound:" + found);
            }
        } else {
            final TableInfo expected = toTableInfo(entity);
            final TableInfo found = TableInfo.read(db, entity.getTableName());
            if (!expected.equals(found)) {
                throw new IllegalStateException("Migration failed.\nExpected:" + expected + " \nfound:" + found);
            }
        }
    }
    if (mVerifyDroppedTables) {
        // now ensure tables that should be removed are removed.
        Set<String> expectedTables = new HashSet<>();
        for (EntityBundle entity : tables.values()) {
            expectedTables.add(entity.getTableName());
            if (entity instanceof FtsEntityBundle) {
                expectedTables.addAll(((FtsEntityBundle) entity).getShadowTableNames());
            }
        }
        Cursor cursor = db.query("SELECT name FROM sqlite_master WHERE type='table'" + " AND name NOT IN(?, ?, ?)", new String[] { Room.MASTER_TABLE_NAME, "android_metadata", "sqlite_sequence" });
        // noinspection TryFinallyCanBeTryWithResources
        try {
            while (cursor.moveToNext()) {
                final String tableName = cursor.getString(0);
                if (!expectedTables.contains(tableName)) {
                    throw new IllegalStateException("Migration failed. Unexpected table " + tableName);
                }
            }
        } finally {
            cursor.close();
        }
    }
}
#end_block

#method_before
@Test
public void invalidMigration_missingFtsOption() throws Exception {
    SupportSQLiteDatabase supportSQLiteDatabase = helper.createDatabase(TEST_DB, 1);
    supportSQLiteDatabase.close();
    try {
        Context targetContext = InstrumentationRegistry.getTargetContext();
        FtsMigrationDb db = Room.databaseBuilder(targetContext, FtsMigrationDb.class, TEST_DB).addMigrations(BAD_MIGRATION_1_2).build();
        helper.closeWhenFinished(db);
        db.getBookDao().getAllBooks();
        fail("Should have failed migration.");
    } catch (IllegalStateException ignored) {
    }
}
#method_after
@Test
public void invalidMigration_missingFtsOption() throws Exception {
    SupportSQLiteDatabase supportSQLiteDatabase = helper.createDatabase(TEST_DB, 1);
    supportSQLiteDatabase.close();
    try {
        Context targetContext = InstrumentationRegistry.getTargetContext();
        FtsMigrationDb db = Room.databaseBuilder(targetContext, FtsMigrationDb.class, TEST_DB).addMigrations(BAD_MIGRATION_1_2).build();
        helper.closeWhenFinished(db);
        db.getBookDao().getAllBooks();
        fail("Should have failed migration.");
    } catch (IllegalStateException ex) {
        assertThat(ex.getMessage(), containsString("Migration didn't properly handle"));
    }
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    Step step = (Step) o;
    return Objects.equals(mManeuver, step.mManeuver) && Objects.equals(mDistance, step.mDistance) && Objects.equals(mEta, step.mEta);
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    Step step = (Step) o;
    return Objects.equals(getManeuver(), step.getManeuver()) && Objects.equals(getDistance(), step.getDistance());
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(mManeuver, mDistance, mEta);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(mManeuver, mDistance);
}
#end_block

#method_before
@NonNull
public Instant getTime() {
    return Instant.ofEpochSecond(mSecondsSinceEpoch);
}
#method_after
@NonNull
ZonedDateTime getTime() {
    return ZonedDateTime.ofInstant(Instant.ofEpochSecond(mSecondsSinceEpoch), getZonedId());
}
#end_block

#method_before
@Nullable
public Unit getDisplayUnit() {
    return mDisplayUnit.getValue(Unit.class);
}
#method_after
@NonNull
public Unit getDisplayUnit() {
    return EnumWrapper.getValue(mDisplayUnit, Unit.UNKNOWN);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    Distance distance = (Distance) o;
    return mMeters == distance.mMeters && mDisplayE3 == distance.mDisplayE3 && Objects.equals(mDisplayUnit, distance.mDisplayUnit);
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    Distance distance = (Distance) o;
    return getMeters() == distance.getMeters() && Objects.equals(getDisplayValue(), distance.getDisplayValue()) && Objects.equals(getDisplayUnit(), distance.getDisplayUnit());
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(mMeters, mDisplayUnit, mDisplayE3);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(getMeters(), getDisplayUnit(), getDisplayValue());
}
#end_block

#method_before
@NonNull
public List<Step> getSteps() {
    return mSteps;
}
#method_after
@NonNull
public List<Step> getSteps() {
    return Common.nonNullOrEmpty(mSteps);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    NavigationState that = (NavigationState) o;
    return Objects.equals(mStatus, that.mStatus) && Objects.equals(mMode, that.mMode) && Objects.equals(mSteps, that.mSteps);
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    NavigationState that = (NavigationState) o;
    return Objects.equals(getSteps(), that.getSteps()) && Objects.equals(getDestinations(), that.getDestinations());
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(mStatus, mMode, mSteps);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(getSteps(), getDestinations());
}
#end_block

#method_before
@Test
public void schemaIsSerializableAndDeserializable() {
    String bundleKey = "DATA";
    NavigationState state = createSampleState();
    // Set the state into a {@link Bundle}
    Bundle in = new Bundle();
    in.putParcelable(bundleKey, ParcelUtils.toParcelable(state));
    // Serialize it into a {@link Parcel}
    Parcel parcel = Parcel.obtain();
    in.writeToParcel(parcel, 0);
    parcel.setDataPosition(0);
    // Deserialize it back to {@link Bundle}
    Bundle out = new Bundle();
    out.readFromParcel(parcel);
    // Recover the state and assert
    NavigationState result = ParcelUtils.fromParcelable(out.getParcelable(bundleKey));
    assertEquals(state, result);
}
#method_after
@Test
public void schemaIsSerializableAndDeserializable() {
    NavigationState state = createSampleState();
    // Serialize and deserialize
    Parcelable out = deserialize(serialize(state.toParcelable()));
    // Recover the state and assert
    NavigationState result = NavigationState.fromParcelable(out);
    assertEquals(state, result);
}
#end_block

#method_before
private NavigationState createSampleState() {
    return new NavigationState();
}
#method_after
private NavigationState createSampleState() {
    return new NavigationState.Builder().addStep(new Step.Builder().setManeuver(new Maneuver.Builder().setType(Maneuver.Type.DEPART).build()).setDistance(new Distance(10, "10", Distance.Unit.METERS)).build()).addStep(new Step.Builder().setManeuver(new Maneuver.Builder().setType(Maneuver.Type.ROUNDABOUT_EXIT).setRoundaboutExitNumber(2).build()).setDistance(new Distance(15, "15", Distance.Unit.METERS)).build()).addDestination(new Destination.Builder().setTitle("Home").setDistance(new Distance(1230, "1.2", Distance.Unit.KILOMETERS)).build()).build();
}
#end_block

#method_before
@Nullable
public Type getType() {
    return mType.getValue(Type.class);
}
#method_after
@NonNull
public Type getType() {
    return EnumWrapper.getValue(mType, Type.UNKNOWN);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    Maneuver maneuver = (Maneuver) o;
    return mRoundaboutExitNumber == maneuver.mRoundaboutExitNumber && Objects.equals(mType, maneuver.mType);
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    Maneuver maneuver = (Maneuver) o;
    return getRoundaboutExitNumber() == maneuver.getRoundaboutExitNumber() && Objects.equals(getType(), maneuver.getType());
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(mType, mRoundaboutExitNumber);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(getType(), getRoundaboutExitNumber());
}
#end_block

#method_before
@CddTest(requirement = "7.4.2.4/C-1-1,C-2-1")
public void testAddPasspointConfigWithUserCredential() throws Exception {
    if (!WifiFeature.isWifiSupported(getContext())) {
        // skip the test if WiFi is not supported
        return;
    }
    testAddPasspointConfig(generatePasspointConfig(generateUserCredential()));
}
#method_after
@CddTest(requirement = "7.4.2.4/C-1-1,C-1-2,C-2-1")
public void testAddPasspointConfigWithUserCredential() throws Exception {
    if (!WifiFeature.isWifiSupported(getContext())) {
        // skip the test if WiFi is not supported
        return;
    }
    testAddPasspointConfig(generatePasspointConfig(generateUserCredential()));
}
#end_block

#method_before
@CddTest(requirement = "7.4.2.4/C-1-1,C-2-1")
public void testAddPasspointConfigWithCertCredential() throws Exception {
    if (!WifiFeature.isWifiSupported(getContext())) {
        // skip the test if WiFi is not supported
        return;
    }
    testAddPasspointConfig(generatePasspointConfig(generateCertCredential()));
}
#method_after
@CddTest(requirement = "7.4.2.4/C-1-1,C-1-2,C-2-1")
public void testAddPasspointConfigWithCertCredential() throws Exception {
    if (!WifiFeature.isWifiSupported(getContext())) {
        // skip the test if WiFi is not supported
        return;
    }
    testAddPasspointConfig(generatePasspointConfig(generateCertCredential()));
}
#end_block

#method_before
@CddTest(requirement = "7.4.2.4/C-1-1,C-2-1")
public void testAddPasspointConfigWithSimCredential() throws Exception {
    if (!WifiFeature.isWifiSupported(getContext())) {
        // skip the test if WiFi is not supported
        return;
    }
    testAddPasspointConfig(generatePasspointConfig(generateSimCredential()));
}
#method_after
@CddTest(requirement = "7.4.2.4/C-1-1,C-1-2,C-2-1")
public void testAddPasspointConfigWithSimCredential() throws Exception {
    if (!WifiFeature.isWifiSupported(getContext())) {
        // skip the test if WiFi is not supported
        return;
    }
    testAddPasspointConfig(generatePasspointConfig(generateSimCredential()));
}
#end_block

