296
#method_before
private JLabel getLabel() {
    if (imageRender == null) {
        imageRender = new JLabel();
        imageRender.setOpaque(true);
    }
    return imageRender;
}
#method_after
private JLabel getLabel() {
    if (imageRender == null) {
        imageRender = new JLabel();
        directory = "";
        imageRender.setOpaque(true);
        imi = new ImageIcon();
        img = imi.getImage();
        imageRender.setIcon(imi);
    }
    return imageRender;
}
#end_block

#method_before
public void setRotate(double[] indices) {
    int h = img.getHeight(this);
    int w = img.getWidth(this);
    BufferedImage bim = new BufferedImage(h, w, BufferedImage.TYPE_INT_RGB);
    Graphics2D g2 = bim.createGraphics();
    g2.rotate(Math.toRadians(indices[0]), w / 2, h / 2);
    g2.drawImage(img, 0, 0, this);
    imageRender.setIcon(new ImageIcon(bim));
}
#method_after
public void setRotate(double[] indices) {
    if (img != null) {
        int h = img.getHeight(this);
        int w = img.getWidth(this);
        BufferedImage bim = new BufferedImage(h, w, BufferedImage.TYPE_INT_RGB);
        Graphics2D g2 = bim.createGraphics();
        g2.rotate(Math.toRadians(indices[0]), w / 2, h / 2);
        g2.drawImage(img, 0, 0, this);
        imageRender.setIcon(new ImageIcon(bim));
    }
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("Line")) {
        return ContouredObjectPropertyType.LINE;
    } else if (propertyName.equals("LineMode")) {
        return LinePropertyType.MODE;
    } else if (propertyName.equals("LineStyle")) {
        return LinePropertyType.LINESTYLE;
    } else if (propertyName.equals("LineThickness")) {
        return LinePropertyType.THICKNESS;
    } else if (propertyName.equals("LineColor")) {
        return LinePropertyType.COLOR;
    } else if (propertyName.equals("FillMode")) {
        return ContouredObjectPropertyType.FILLMODE;
    } else if (propertyName.equals("Background")) {
        return ContouredObjectPropertyType.BACKGROUND;
    } else if (propertyName.equals("Mark")) {
        return ContouredObjectPropertyType.MARK;
    } else if (propertyName.equals("MarkMode")) {
        return MarkPropertyType.MODE;
    } else if (propertyName.equals("MarkStyle")) {
        return MarkPropertyType.STYLE;
    } else if (propertyName.equals("MarkSizeUnit")) {
        return MarkPropertyType.MARKSIZEUNIT;
    } else if (propertyName.equals("MarkSize")) {
        return MarkPropertyType.SIZE;
    } else if (propertyName.equals("MarkForeground")) {
        return MarkPropertyType.FOREGROUND;
    } else if (propertyName.equals("MarkBackground")) {
        return MarkPropertyType.BACKGROUND;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("Line")) {
        return ContouredObjectPropertyType.LINE;
    } else if (propertyName.equals("LineMode")) {
        return LinePropertyType.MODE;
    } else if (propertyName.equals("LineStyle")) {
        return LinePropertyType.LINESTYLE;
    } else if (propertyName.equals("LineThickness")) {
        return LinePropertyType.THICKNESS;
    } else if (propertyName.equals("LineColor")) {
        return LinePropertyType.COLOR;
    } else if (propertyName.equals("FillMode")) {
        return ContouredObjectPropertyType.FILLMODE;
    } else if (propertyName.equals("Background")) {
        return ContouredObjectPropertyType.BACKGROUND;
    } else if (propertyName.equals("Mark")) {
        return ContouredObjectPropertyType.MARK;
    } else if (propertyName.equals("MarkMode")) {
        return MarkPropertyType.MODE;
    } else if (propertyName.equals("MarkStyle")) {
        return MarkPropertyType.STYLE;
    } else if (propertyName.equals("MarkSizeUnit")) {
        return MarkPropertyType.SIZEUNIT;
    } else if (propertyName.equals("MarkSize")) {
        return MarkPropertyType.SIZE;
    } else if (propertyName.equals("MarkForeground")) {
        return MarkPropertyType.FOREGROUND;
    } else if (propertyName.equals("MarkBackground")) {
        return MarkPropertyType.BACKGROUND;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    if (property == ContouredObjectPropertyType.LINE) {
        return getLine();
    } else if (property == LinePropertyType.MODE) {
        return getLineMode();
    } else if (property == LinePropertyType.LINESTYLE) {
        return getLineStyle();
    } else if (property == LinePropertyType.THICKNESS) {
        return getLineThickness();
    } else if (property == LinePropertyType.COLOR) {
        return getLineColor();
    } else if (property == ContouredObjectPropertyType.FILLMODE) {
        return getFillMode();
    } else if (property == ContouredObjectPropertyType.BACKGROUND) {
        return getBackground();
    } else if (property == ContouredObjectPropertyType.MARK) {
        return getMark();
    } else if (property == MarkPropertyType.MODE) {
        return getMarkMode();
    } else if (property == MarkPropertyType.STYLE) {
        return getMarkStyle();
    } else if (property == MarkPropertyType.MARKSIZEUNIT) {
        return getMarkSizeUnit();
    } else if (property == MarkPropertyType.SIZE) {
        return getMarkSize();
    } else if (property == MarkPropertyType.FOREGROUND) {
        return getMarkForeground();
    } else if (property == MarkPropertyType.BACKGROUND) {
        return getMarkBackground();
    } else {
        return super.getPropertyFast(property);
    }
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == ContouredObjectPropertyType.LINE) {
        return getLine();
    } else if (property == LinePropertyType.MODE) {
        return getLineMode();
    } else if (property == LinePropertyType.LINESTYLE) {
        return getLineStyle();
    } else if (property == LinePropertyType.THICKNESS) {
        return getLineThickness();
    } else if (property == LinePropertyType.COLOR) {
        return getLineColor();
    } else if (property == ContouredObjectPropertyType.FILLMODE) {
        return getFillMode();
    } else if (property == ContouredObjectPropertyType.BACKGROUND) {
        return getBackground();
    } else if (property == ContouredObjectPropertyType.MARK) {
        return getMark();
    } else if (property == MarkPropertyType.MODE) {
        return getMarkMode();
    } else if (property == MarkPropertyType.STYLE) {
        return getMarkStyle();
    } else if (property == MarkPropertyType.SIZEUNIT) {
        return getMarkSizeUnit();
    } else if (property == MarkPropertyType.SIZE) {
        return getMarkSize();
    } else if (property == MarkPropertyType.FOREGROUND) {
        return getMarkForeground();
    } else if (property == MarkPropertyType.BACKGROUND) {
        return getMarkBackground();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public boolean setPropertyFast(Object property, Object value) {
    if (property == ContouredObjectPropertyType.LINE) {
        setLine((Line) value);
    } else if (property == LinePropertyType.MODE) {
        setLineMode((Boolean) value);
    } else if (property == LinePropertyType.LINESTYLE) {
        setLineStyle((Integer) value);
    } else if (property == LinePropertyType.THICKNESS) {
        setLineThickness((Double) value);
    } else if (property == LinePropertyType.COLOR) {
        setLineColor((Integer) value);
    } else if (property == ContouredObjectPropertyType.FILLMODE) {
        setFillMode((Boolean) value);
    } else if (property == ContouredObjectPropertyType.BACKGROUND) {
        setBackground((Integer) value);
    } else if (property == ContouredObjectPropertyType.MARK) {
        setMark((Mark) value);
    } else if (property == MarkPropertyType.MODE) {
        setMarkMode((Boolean) value);
    } else if (property == MarkPropertyType.STYLE) {
        setMarkStyle((Integer) value);
    } else if (property == MarkPropertyType.MARKSIZEUNIT) {
        setMarkSizeUnit((Integer) value);
    } else if (property == MarkPropertyType.SIZE) {
        setMarkSize((Integer) value);
    } else if (property == MarkPropertyType.FOREGROUND) {
        this.setMarkForeground((Integer) value);
    } else if (property == MarkPropertyType.BACKGROUND) {
        this.setMarkBackground((Integer) value);
    } else {
        return super.setPropertyFast(property, value);
    }
    return true;
}
#method_after
public boolean setPropertyFast(Object property, Object value) {
    if (property == ContouredObjectPropertyType.LINE) {
        setLine((Line) value);
    } else if (property == LinePropertyType.MODE) {
        setLineMode((Boolean) value);
    } else if (property == LinePropertyType.LINESTYLE) {
        setLineStyle((Integer) value);
    } else if (property == LinePropertyType.THICKNESS) {
        setLineThickness((Double) value);
    } else if (property == LinePropertyType.COLOR) {
        setLineColor((Integer) value);
    } else if (property == ContouredObjectPropertyType.FILLMODE) {
        setFillMode((Boolean) value);
    } else if (property == ContouredObjectPropertyType.BACKGROUND) {
        setBackground((Integer) value);
    } else if (property == ContouredObjectPropertyType.MARK) {
        setMark((Mark) value);
    } else if (property == MarkPropertyType.MODE) {
        setMarkMode((Boolean) value);
    } else if (property == MarkPropertyType.STYLE) {
        setMarkStyle((Integer) value);
    } else if (property == MarkPropertyType.SIZEUNIT) {
        setMarkSizeUnit((Integer) value);
    } else if (property == MarkPropertyType.SIZE) {
        setMarkSize((Integer) value);
    } else if (property == MarkPropertyType.FOREGROUND) {
        this.setMarkForeground((Integer) value);
    } else if (property == MarkPropertyType.BACKGROUND) {
        this.setMarkBackground((Integer) value);
    } else {
        return super.setPropertyFast(property, value);
    }
    return true;
}
#end_block

#method_before
private static void setGraphicObjectProperty(String id, String propertyName, Object value) {
    GraphicController.getController().setProperty(id, propertyName, value);
}
#method_after
private static void setGraphicObjectProperty(String id, String propertyName, Object value) {
    GraphicController.getController().setPropertyFast(id, propertyName, value);
}
#end_block

#method_before
private static Object getGraphicObjectProperty(String id, String propertyName) {
    return GraphicController.getController().getProperty(id, propertyName);
}
#method_after
private static Object getGraphicObjectProperty(String id, String propertyName) {
    return GraphicController.getController().getPropertyFast(id, propertyName);
}
#end_block

#method_before
public static void createPopupMenu(final JEditorPane c) {
    final JPopupMenu popup = new JPopupMenu();
    final JMenuItem evalMenuItem = new JMenuItem(XpadMessages.EVALUATE_SELECTION);
    JMenuItem menuItem = null;
    /* Execute into Scilab */
    ActionListener actionListenerExecuteIntoScilab = new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            String selection = ((ScilabEditorPane) c).getCodeToExecute();
            if (selection == null) {
                infoBar.setText(Messages.gettext("No text to execute"));
            } else {
                ScilabConsole.getConsole().getAsSimpleConsole().sendCommandsToScilab(selection, true, true);
            }
        }
    };
    evalMenuItem.addActionListener(actionListenerExecuteIntoScilab);
    if (!ScilabConsole.isExistingConsole()) {
        /* Only available in STD mode */
        evalMenuItem.setEnabled(false);
    }
    PropertyChangeListener listenerEvalItem = new PropertyChangeListener() {

        public void propertyChange(PropertyChangeEvent arg0) {
            String select = c.getSelectedText();
            if (select == null) {
                evalMenuItem.setText(Messages.gettext(XpadMessages.EVALUATE_FROM_BEGINNING));
            } else {
                evalMenuItem.setText(Messages.gettext(XpadMessages.EVALUATE_SELECTION));
            }
        }
    };
    evalMenuItem.addPropertyChangeListener(listenerEvalItem);
    popup.add(evalMenuItem);
    /* Edit in the Scilab Text Editor */
    ActionListener actionListenerLoadIntoTextEditor = new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            String selection = c.getSelectedText();
            if (selection == null) {
                infoBar.setText(Messages.gettext("No text selected"));
            } else {
                Xpad.xpadWithText(selection);
            }
        }
    };
    menuItem = new JMenuItem(Messages.gettext("Edit selection in a new tab"));
    menuItem.addActionListener(actionListenerLoadIntoTextEditor);
    popup.add(menuItem);
    popup.addSeparator();
    /* Copy */
    menuItem = new JMenuItem(new DefaultEditorKit.CopyAction());
    menuItem.setText(Messages.gettext("Copy"));
    popup.add(menuItem);
    popup.addSeparator();
    /* Cut */
    menuItem = new JMenuItem(new DefaultEditorKit.CutAction());
    menuItem.setText(Messages.gettext("Cut"));
    popup.add(menuItem);
    popup.addSeparator();
    /* Paste */
    menuItem = new JMenuItem(new DefaultEditorKit.PasteAction());
    menuItem.setText(Messages.gettext("Paste"));
    popup.add(menuItem);
    popup.addSeparator();
    /* Select all */
    ActionListener actionListenerSelectAll = new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            c.selectAll();
        }
    };
    menuItem = new JMenuItem(Messages.gettext("Select All"));
    menuItem.addActionListener(actionListenerSelectAll);
    popup.add(menuItem);
    /* Edit in the Scilab Text Editor */
    final JMenuItem helpMenuItem = new JMenuItem("Help on the selected text");
    ActionListener actionListenerHelpOnKeyword = new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            String selection = c.getSelectedText();
            if (selection == null) {
                KeywordEvent kwe = ((ScilabEditorPane) c).getKeywordEvent();
                if (ScilabLexerConstants.isHelpable(kwe.getType())) {
                    try {
                        selection = c.getDocument().getText(kwe.getStart(), kwe.getLength());
                    } catch (BadLocationException e) {
                    }
                } else {
                    infoBar.setText(Messages.gettext("No text selected"));
                    return;
                }
            }
            /* Double the quote/double quote in order to avoid
                     * and error with the call of help()
                     */
            selection = selection.replaceAll("'", "''");
            selection = selection.replaceAll("\"", "\"\"");
            InterpreterManagement.requestScilabExec("help('" + selection + "')");
        }
    };
    /* Not sure it is the best listener */
    PropertyChangeListener listenerTextItem = new PropertyChangeListener() {

        public void propertyChange(PropertyChangeEvent arg0) {
            String keyword = c.getSelectedText();
            if (keyword == null) {
                KeywordEvent kwe = ((ScilabEditorPane) c).getKeywordEvent();
                if (ScilabLexerConstants.isHelpable(kwe.getType())) {
                    try {
                        keyword = c.getDocument().getText(kwe.getStart(), kwe.getLength());
                    } catch (BadLocationException e) {
                    }
                } else {
                    helpMenuItem.setText(Messages.gettext("Help on selected text or keyword"));
                    helpMenuItem.setEnabled(false);
                    return;
                }
            }
            int nbOfDisplayedOnlyXChar = 10;
            if (keyword.length() > nbOfDisplayedOnlyXChar) {
                keyword = keyword.substring(0, nbOfDisplayedOnlyXChar) + "...";
            }
            helpMenuItem.setText(Messages.gettext("Help about '") + keyword + "'");
            helpMenuItem.setEnabled(true);
        }
    };
    helpMenuItem.addPropertyChangeListener(listenerTextItem);
    helpMenuItem.addActionListener(actionListenerHelpOnKeyword);
    popup.add(helpMenuItem);
    /* Open source file in the Scilab Text Editor */
    final JMenuItem sourceMenuItem = new JMenuItem(XpadMessages.OPEN_SOURCE_FILE_ON_KEYWORD);
    ActionListener actionListenerOpenSource = new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            String selection = c.getSelectedText();
            if (selection == null) {
                KeywordEvent kwe = ((ScilabEditorPane) c).getKeywordEvent();
                if (ScilabLexerConstants.isOpenable(kwe.getType())) {
                    try {
                        ScilabDocument doc = (ScilabDocument) ((ScilabEditorPane) c).getDocument();
                        String kw = doc.getText(kwe.getStart(), kwe.getLength());
                        int pos = doc.searchFunctionByName(kw);
                        if (pos != -1) {
                            ((ScilabEditorPane) c).scrollTextToPos(pos);
                        } else {
                            InterpreterManagement.requestScilabExec("a46d43fa4w5z8512dc7dc2c3=get_function_path('" + kw + "');if a46d43fa4w5z8512dc7dc2c3~=[] then editor(a46d43fa4w5z8512dc7dc2c3);clear a46d43fa4w5z8512dc7dc2c3;end");
                        }
                    } catch (BadLocationException e) {
                    }
                }
            }
        }
    };
    /* Not sure it is the best listener */
    PropertyChangeListener listenerSourceItem = new PropertyChangeListener() {

        public void propertyChange(PropertyChangeEvent arg0) {
            String keyword = c.getSelectedText();
            if (keyword == null) {
                KeywordEvent kwe = ((ScilabEditorPane) c).getKeywordEvent();
                if (ScilabLexerConstants.isOpenable(kwe.getType())) {
                    try {
                        keyword = c.getDocument().getText(kwe.getStart(), kwe.getLength());
                    } catch (BadLocationException e) {
                    }
                } else {
                    sourceMenuItem.setText(XpadMessages.OPEN_SOURCE_FILE_ON_KEYWORD);
                    sourceMenuItem.setEnabled(false);
                    return;
                }
            }
            int nbOfDisplayedOnlyXChar = 10;
            if (keyword.length() > nbOfDisplayedOnlyXChar) {
                keyword = keyword.substring(0, nbOfDisplayedOnlyXChar) + "...";
            }
            sourceMenuItem.setText(Messages.gettext("Source of '") + keyword + "'");
            sourceMenuItem.setEnabled(true);
        }
    };
    sourceMenuItem.addPropertyChangeListener(listenerSourceItem);
    sourceMenuItem.addActionListener(actionListenerOpenSource);
    popup.add(sourceMenuItem);
    /* Creates the Popupmenu on the component */
    c.setComponentPopupMenu(popup);
}
#method_after
public static void createPopupMenu(final JEditorPane c) {
    final JPopupMenu popup = new JPopupMenu();
    final JMenuItem evalMenuItem = new JMenuItem(XpadMessages.EVALUATE_SELECTION);
    JMenuItem menuItem = null;
    /* Execute into Scilab */
    ActionListener actionListenerExecuteIntoScilab = new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            String selection = ((ScilabEditorPane) c).getCodeToExecute();
            if (selection == null) {
                infoBar.setText(Messages.gettext("No text to execute"));
            } else {
                ScilabConsole.getConsole().getAsSimpleConsole().sendCommandsToScilab(selection, true, true);
            }
        }
    };
    evalMenuItem.addActionListener(actionListenerExecuteIntoScilab);
    if (!ScilabConsole.isExistingConsole()) {
        /* Only available in STD mode */
        evalMenuItem.setEnabled(false);
    }
    PropertyChangeListener listenerEvalItem = new PropertyChangeListener() {

        public void propertyChange(PropertyChangeEvent arg0) {
            String select = c.getSelectedText();
            if (select == null) {
                evalMenuItem.setText(Messages.gettext(XpadMessages.EVALUATE_FROM_BEGINNING));
            } else {
                evalMenuItem.setText(Messages.gettext(XpadMessages.EVALUATE_SELECTION));
            }
        }
    };
    evalMenuItem.addPropertyChangeListener(listenerEvalItem);
    popup.add(evalMenuItem);
    /* Edit in the Scilab Text Editor */
    ActionListener actionListenerLoadIntoTextEditor = new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            String selection = c.getSelectedText();
            if (selection == null) {
                infoBar.setText(Messages.gettext("No text selected"));
            } else {
                Xpad.xpadWithText(selection);
            }
        }
    };
    menuItem = new JMenuItem(Messages.gettext("Edit selection in a new tab"));
    menuItem.addActionListener(actionListenerLoadIntoTextEditor);
    popup.add(menuItem);
    popup.addSeparator();
    /* Copy */
    menuItem = new JMenuItem(new DefaultEditorKit.CopyAction());
    menuItem.setText(Messages.gettext("Copy"));
    popup.add(menuItem);
    popup.addSeparator();
    /* Cut */
    menuItem = new JMenuItem(new DefaultEditorKit.CutAction());
    menuItem.setText(Messages.gettext("Cut"));
    popup.add(menuItem);
    popup.addSeparator();
    /* Paste */
    menuItem = new JMenuItem(new DefaultEditorKit.PasteAction());
    menuItem.setText(Messages.gettext("Paste"));
    popup.add(menuItem);
    popup.addSeparator();
    /* Select all */
    ActionListener actionListenerSelectAll = new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            c.selectAll();
        }
    };
    menuItem = new JMenuItem(Messages.gettext("Select All"));
    menuItem.addActionListener(actionListenerSelectAll);
    popup.add(menuItem);
    /* Edit in the Scilab Text Editor */
    final JMenuItem helpMenuItem = new JMenuItem("Help on the selected text");
    ActionListener actionListenerHelpOnKeyword = new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            String selection = c.getSelectedText();
            if (selection == null) {
                KeywordEvent kwe = ((ScilabEditorPane) c).getKeywordEvent();
                if (ScilabLexerConstants.isHelpable(kwe.getType())) {
                    try {
                        selection = c.getDocument().getText(kwe.getStart(), kwe.getLength());
                    } catch (BadLocationException e) {
                    }
                } else {
                    infoBar.setText(Messages.gettext("No text selected"));
                    return;
                }
            }
            /* Double the quote/double quote in order to avoid
                     * and error with the call of help()
                     */
            selection = selection.replaceAll("'", "''");
            selection = selection.replaceAll("\"", "\"\"");
            InterpreterManagement.requestScilabExec("help('" + selection + "')");
        }
    };
    /* Not sure it is the best listener */
    PropertyChangeListener listenerTextItem = new PropertyChangeListener() {

        public void propertyChange(PropertyChangeEvent arg0) {
            String keyword = c.getSelectedText();
            if (keyword == null) {
                KeywordEvent kwe = ((ScilabEditorPane) c).getKeywordEvent();
                if (ScilabLexerConstants.isHelpable(kwe.getType())) {
                    try {
                        keyword = c.getDocument().getText(kwe.getStart(), kwe.getLength());
                    } catch (BadLocationException e) {
                    }
                } else {
                    helpMenuItem.setText(Messages.gettext("Help on selected text or keyword"));
                    helpMenuItem.setEnabled(false);
                    return;
                }
            }
            int nbOfDisplayedOnlyXChar = 10;
            if (keyword.length() > nbOfDisplayedOnlyXChar) {
                keyword = keyword.substring(0, nbOfDisplayedOnlyXChar) + "...";
            }
            helpMenuItem.setText(Messages.gettext("Help about '") + keyword + "'");
            helpMenuItem.setEnabled(true);
        }
    };
    helpMenuItem.addPropertyChangeListener(listenerTextItem);
    helpMenuItem.addActionListener(actionListenerHelpOnKeyword);
    popup.add(helpMenuItem);
    /* Open source file in the Scilab Text Editor */
    final JMenuItem sourceMenuItem = new JMenuItem(XpadMessages.OPEN_SOURCE_FILE_ON_KEYWORD);
    ActionListener actionListenerOpenSource = new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            String selection = c.getSelectedText();
            if (selection == null) {
                KeywordEvent kwe = ((ScilabEditorPane) c).getKeywordEvent();
                if (ScilabLexerConstants.isOpenable(kwe.getType())) {
                    try {
                        ScilabDocument doc = (ScilabDocument) ((ScilabEditorPane) c).getDocument();
                        String kw = doc.getText(kwe.getStart(), kwe.getLength());
                        int pos = doc.searchFunctionByName(kw);
                        if (pos != -1) {
                            ((ScilabEditorPane) c).scrollTextToPos(pos);
                        } else {
                            String path = "get_function_path('" + kw + "')";
                            InterpreterManagement.requestScilabExec("if " + path + " ~=[] then editor(" + path + ");end");
                        }
                    } catch (BadLocationException e) {
                    }
                }
            }
        }
    };
    /* Not sure it is the best listener */
    PropertyChangeListener listenerSourceItem = new PropertyChangeListener() {

        public void propertyChange(PropertyChangeEvent arg0) {
            String keyword = c.getSelectedText();
            if (keyword == null) {
                KeywordEvent kwe = ((ScilabEditorPane) c).getKeywordEvent();
                if (ScilabLexerConstants.isOpenable(kwe.getType())) {
                    try {
                        keyword = c.getDocument().getText(kwe.getStart(), kwe.getLength());
                    } catch (BadLocationException e) {
                    }
                } else {
                    sourceMenuItem.setText(XpadMessages.OPEN_SOURCE_FILE_ON_KEYWORD);
                    sourceMenuItem.setEnabled(false);
                    return;
                }
            }
            int nbOfDisplayedOnlyXChar = 10;
            if (keyword.length() > nbOfDisplayedOnlyXChar) {
                keyword = keyword.substring(0, nbOfDisplayedOnlyXChar) + "...";
            }
            sourceMenuItem.setText(Messages.gettext("Source of '") + keyword + "'");
            sourceMenuItem.setEnabled(true);
        }
    };
    sourceMenuItem.addPropertyChangeListener(listenerSourceItem);
    sourceMenuItem.addActionListener(actionListenerOpenSource);
    popup.add(sourceMenuItem);
    /* Creates the Popupmenu on the component */
    c.setComponentPopupMenu(popup);
}
#end_block

#method_before
private Object getDefaultValue(Object value) {
    System.err.println("Calling getDefaultValue");
    System.err.println(value.getClass().getCanonicalName());
    if (value instanceof String) {
        return "";
    }
    if (value instanceof Double) {
        return 0.0;
    }
    if (value instanceof Boolean) {
        return false;
    }
    return null;
}
#method_after
private Object getDefaultValue(Object value) {
    if (value instanceof String) {
        return "";
    }
    if (value instanceof Double) {
        return 0.0;
    }
    if (value instanceof Boolean) {
        return false;
    }
    return null;
}
#end_block

#method_before
public void printPattern() {
    if (LOG.isTraceEnabled()) {
        try {
            Iterator<Block> blockIter = blocks.getBlock().iterator();
            while (blockIter.hasNext()) {
                Block block = blockIter.next();
                if (LOG.isTraceEnabled()) {
                    LOG.trace("From: " + block.getSim() + " to: " + block.getXCos());
                }
            }
        } catch (Exception e1) {
            LogFactory.getLog(PatternElement.class).error(e1);
        }
    }
}
#method_after
public void printPattern() {
    if (LOG.isTraceEnabled()) {
        try {
            Iterator<Block> blockIter = blocks.getBlock().iterator();
            while (blockIter.hasNext()) {
                Block block = blockIter.next();
                if (LOG.isTraceEnabled()) {
                    LOG.trace("From: " + block.getSim() + " to: " + block.getXcos());
                }
            }
        } catch (Exception e1) {
            LogFactory.getLog(PatternElement.class).error(e1);
        }
    }
}
#end_block

#method_before
@XmlElementDecl(namespace = "", name = "blocks")
public JAXBElement<BlockPallete> createBlocks(BlockPallete value) {
    return new JAXBElement<BlockPallete>(_Blocks_QNAME, BlockPallete.class, null, value);
}
#method_after
@XmlElementDecl(namespace = "", name = "blocks")
public JAXBElement<BlockPalette> createBlocks(BlockPalette value) {
    return new JAXBElement<BlockPalette>(_Blocks_QNAME, BlockPalette.class, null, value);
}
#end_block

#method_before
public List<StringParameter> getString() {
    if (string == null) {
        string = new ArrayList<StringParameter>();
    }
    return this.string;
}
#method_after
public List<StringParameters> getString() {
    if (string == null) {
        string = new ArrayList<StringParameters>();
    }
    return this.string;
}
#end_block

#method_before
public List<IntegerParameter> getInteger() {
    if (integer == null) {
        integer = new ArrayList<IntegerParameter>();
    }
    return this.integer;
}
#method_after
public List<IntegerParameters> getInteger() {
    if (integer == null) {
        integer = new ArrayList<IntegerParameters>();
    }
    return this.integer;
}
#end_block

#method_before
private double computeLabelCenter(double textWidth, double textHeight, double alignedTextHeight, Vector3D tickPosPix, Vector3D ticksDirPix, Vector3D centerPosition, TicksPositionCase ticksSide) {
    Vector3D textCenter = tickPosPix.add(ticksDirPix);
    double res;
    // the aim is to put ticks segment and text center aligned
    switch(ticksSide) {
        case RIGHT:
            res = textWidth;
            textCenter.setY(textCenter.getY() - textHeight / 2.0);
            break;
        case LEFT:
            res = textWidth;
            textCenter.setX(textCenter.getX() - textWidth);
            textCenter.setY(textCenter.getY() - textHeight / 2.0);
            break;
        case TOP:
            res = textHeight;
            textCenter.setX(textCenter.getX() - textWidth / 2.0);
            break;
        case BOTTOM:
            // in this case, a precomputed height value is used to align
            // the label
            res = textHeight;
            textCenter.setX(textCenter.getX() - textWidth / 2.0);
            textCenter.setY(textCenter.getY() - alignedTextHeight);
            break;
        default:
            res = 0.0;
            break;
    }
    /* We need to use rounded values to avoid grabbaled text */
    centerPosition.setValues(Math.round(textCenter.getX()), Math.round(textCenter.getY()), textCenter.getZ());
    return res;
}
#method_after
private double computeLabelCenter(double textWidth, double textHeight, double alignedTextHeight, Vector3D tickPosPix, Vector3D ticksDirPix, Vector3D centerPosition, TicksPositionCase ticksSide) {
    Vector3D textCenter = tickPosPix.add(ticksDirPix);
    double res;
    // the aim is to put ticks segment and text center aligned
    switch(ticksSide) {
        case RIGHT:
            res = textWidth;
            textCenter.setY(textCenter.getY() - textHeight / 2.0);
            break;
        case LEFT:
            res = textWidth;
            textCenter.setX(textCenter.getX() - textWidth);
            textCenter.setY(textCenter.getY() - textHeight / 2.0);
            break;
        case TOP:
            res = textHeight;
            textCenter.setX(textCenter.getX() - textWidth / 2.0);
            break;
        case BOTTOM:
            /*
			 * In this case, a precomputed height value is used to align
			 * the label
			 */
            res = textHeight;
            textCenter.setX(textCenter.getX() - textWidth / 2.0);
            textCenter.setY(textCenter.getY() - alignedTextHeight);
            break;
        default:
            res = 0.0;
            break;
    }
    /* We need to use rounded values to avoid grabbaled text */
    centerPosition.setValues(Math.round(textCenter.getX()), Math.round(textCenter.getY()), textCenter.getZ());
    return res;
}
#end_block

#method_before
protected double drawLabels(SciTextRenderer renderer, SciTextRenderer exponentRenderer, Vector3D[] ticksPosPix, Vector3D ticksDirPix, double[] bboxWidth, double[] bboxHeight) {
    int nbLabels = ticksPosPix.length;
    Vector3D textCenter = new Vector3D();
    double maxDist = 0.0;
    double maxBboxHeight = 0.0;
    labelsPositions = new Vector3D[nbLabels];
    if (isDisplayingExponents()) {
        labelsExpPositions = new Vector3D[nbLabels];
    } else {
        labelsExpPositions = null;
    }
    if (isDisplayingExponents()) {
        ticksDirPix.scalarMultSelf(LABEL_EXPONENT_TO_AXIS_DISTANCE);
    } else {
        ticksDirPix.scalarMultSelf(LABEL_TO_AXIS_DISTANCE);
    }
    // only taking into account non-Latex/MathML labels
    if (nbLabels > 0) {
        if (!(getTickLabel(0).charAt(0) == '<' || getTickLabel(0).charAt(0) == '$')) {
            maxBboxHeight = bboxHeight[0];
        }
    }
    for (int i = 1; i < nbLabels; i++) {
        if (!(getTickLabel(i).charAt(0) == '<' || getTickLabel(i).charAt(0) == '$')) {
            if (bboxHeight[i] > maxBboxHeight) {
                maxBboxHeight = bboxHeight[i];
            }
        }
    }
    // compute orientation of ticks
    TicksPositionCase ticksOrientation = computeGlobalOrientation(ticksDirPix);
    GL gl = getGL();
    // does not work well with text rendering
    gl.glDisable(GL.GL_COLOR_LOGIC_OP);
    renderer.begin3DRendering(gl);
    for (int i = 0; i < nbLabels; i++) {
        double curDist;
        double alignedBboxHeight;
        if (ticksPosPix[i] == null) {
            continue;
        }
        if (getTickLabel(i).charAt(0) == '<' || getTickLabel(i).charAt(0) == '$') {
            alignedBboxHeight = bboxHeight[i];
        } else {
            alignedBboxHeight = maxBboxHeight;
        }
        curDist = computeLabelCenter(bboxWidth[i], bboxHeight[i], alignedBboxHeight, ticksPosPix[i], ticksDirPix, textCenter, ticksOrientation);
        // find the maximum distance
        if (curDist > maxDist) {
            maxDist = curDist;
        }
        labelsPositions[i] = new Vector3D(textCenter);
        renderer.draw3D(gl, getTickLabel(i), labelsPositions[i].getX(), labelsPositions[i].getY(), labelsPositions[i].getZ(), 0.0);
    }
    renderer.end3DRendering(gl);
    if (isDisplayingExponents()) {
        exponentRenderer.begin3DRendering(gl);
        for (int i = 0; i < nbLabels; i++) {
            if (ticksPosPix[i] == null) {
                continue;
            }
            double baseWidth = bboxWidth[i + nbLabels];
            double baseHeight = bboxHeight[i + nbLabels];
            labelsExpPositions[i] = computeExponentPosition(labelsPositions[i], baseWidth, baseHeight);
            if (labelsExpPositions[i] == null) {
                continue;
            }
            exponentRenderer.draw3D(gl, getLabelExponent(i), labelsExpPositions[i].getX(), labelsExpPositions[i].getY(), labelsExpPositions[i].getZ(), 0.0);
        }
        exponentRenderer.end3DRendering(gl);
    }
    // does not work well with text rendering
    gl.glEnable(GL.GL_COLOR_LOGIC_OP);
    // labelToAxisDist =  maxDist + ticksDirPix.getNorm();
    double ticksDirPixNorm = ticksDirPix.getNorm();
    Vector3D labelDisplacament = ticksDirPix.scalarMult((ticksDirPixNorm + maxDist) / ticksDirPixNorm);
    // convert labelDisplacement length into user coordinates
    labelDisplacament = transform.retrieveSceneCoordinates(gl, labelDisplacament);
    labelDisplacament = labelDisplacament.substract(transform.retrieveSceneCoordinates(gl, Vector3D.ORIGIN));
    // showLabels(renderer);
    labelToAxisDist = labelDisplacament.getNorm();
    return labelToAxisDist;
}
#method_after
protected double drawLabels(SciTextRenderer renderer, SciTextRenderer exponentRenderer, Vector3D[] ticksPosPix, Vector3D ticksDirPix, double[] bboxWidth, double[] bboxHeight) {
    int nbLabels = ticksPosPix.length;
    Vector3D textCenter = new Vector3D();
    double maxDist = 0.0;
    double maxBboxHeight = 0.0;
    labelsPositions = new Vector3D[nbLabels];
    if (isDisplayingExponents()) {
        labelsExpPositions = new Vector3D[nbLabels];
    } else {
        labelsExpPositions = null;
    }
    if (isDisplayingExponents()) {
        ticksDirPix.scalarMultSelf(LABEL_EXPONENT_TO_AXIS_DISTANCE);
    } else {
        ticksDirPix.scalarMultSelf(LABEL_TO_AXIS_DISTANCE);
    }
    /*
		 * Determine the largest bounding box height value,
		 * only taking into account non-Latex/MathML labels
		 */
    if (nbLabels > 0) {
        if (getTickLabel(0).length() > 0 && !isMathLabel(getTickLabel(0))) {
            maxBboxHeight = bboxHeight[0];
        }
    }
    for (int i = 1; i < nbLabels; i++) {
        if (getTickLabel(i).length() > 0 && !isMathLabel(getTickLabel(i))) {
            if (bboxHeight[i] > maxBboxHeight) {
                maxBboxHeight = bboxHeight[i];
            }
        }
    }
    // compute orientation of ticks
    TicksPositionCase ticksOrientation = computeGlobalOrientation(ticksDirPix);
    GL gl = getGL();
    // does not work well with text rendering
    gl.glDisable(GL.GL_COLOR_LOGIC_OP);
    renderer.begin3DRendering(gl);
    for (int i = 0; i < nbLabels; i++) {
        double curDist;
        double alignedBboxHeight;
        if (ticksPosPix[i] == null) {
            continue;
        }
        /*
			 * The following test determines the height value to use in order to align
			 * user-defined labels to a bottom-positioned x-axis.
			 * The current label's bounding box height is used if it is a Latex/MathML label
			 * otherwise, the previously computed maximum height is used. This allows to correctly
			 * align standard text labels with different heights and yields the most satisfying
			 * result when mixed ticks are used (standard text + Latex/MathML)
			 */
        if (getTickLabel(i).length() > 0 && isMathLabel(getTickLabel(i))) {
            alignedBboxHeight = bboxHeight[i];
        } else {
            alignedBboxHeight = maxBboxHeight;
        }
        curDist = computeLabelCenter(bboxWidth[i], bboxHeight[i], alignedBboxHeight, ticksPosPix[i], ticksDirPix, textCenter, ticksOrientation);
        // find the maximum distance
        if (curDist > maxDist) {
            maxDist = curDist;
        }
        labelsPositions[i] = new Vector3D(textCenter);
        renderer.draw3D(gl, getTickLabel(i), labelsPositions[i].getX(), labelsPositions[i].getY(), labelsPositions[i].getZ(), 0.0);
    }
    renderer.end3DRendering(gl);
    if (isDisplayingExponents()) {
        exponentRenderer.begin3DRendering(gl);
        for (int i = 0; i < nbLabels; i++) {
            if (ticksPosPix[i] == null) {
                continue;
            }
            double baseWidth = bboxWidth[i + nbLabels];
            double baseHeight = bboxHeight[i + nbLabels];
            labelsExpPositions[i] = computeExponentPosition(labelsPositions[i], baseWidth, baseHeight);
            if (labelsExpPositions[i] == null) {
                continue;
            }
            exponentRenderer.draw3D(gl, getLabelExponent(i), labelsExpPositions[i].getX(), labelsExpPositions[i].getY(), labelsExpPositions[i].getZ(), 0.0);
        }
        exponentRenderer.end3DRendering(gl);
    }
    // does not work well with text rendering
    gl.glEnable(GL.GL_COLOR_LOGIC_OP);
    // labelToAxisDist =  maxDist + ticksDirPix.getNorm();
    double ticksDirPixNorm = ticksDirPix.getNorm();
    Vector3D labelDisplacament = ticksDirPix.scalarMult((ticksDirPixNorm + maxDist) / ticksDirPixNorm);
    // convert labelDisplacement length into user coordinates
    labelDisplacament = transform.retrieveSceneCoordinates(gl, labelDisplacament);
    labelDisplacament = labelDisplacament.substract(transform.retrieveSceneCoordinates(gl, Vector3D.ORIGIN));
    // showLabels(renderer);
    labelToAxisDist = labelDisplacament.getNorm();
    return labelToAxisDist;
}
#end_block

#method_before
public MenuBar buildMenuBar() {
    menuBar = ScilabMenuBar.createMenuBar();
    fileMenu = ScilabMenu.createMenu();
    fileMenu.setText(UiDataMessages.FILE);
    fileMenu.setMnemonic('F');
    fileMenu.add(CloseAction.createMenu());
    menuBar.add(fileMenu);
    filterMenu = ScilabMenu.createMenu();
    filterMenu.setText(UiDataMessages.FILTER);
    filterBooleanCheckBox = BooleanFilteringAction.createCheckBoxMenu();
    filterMenu.add(filterBooleanCheckBox);
    filterDoubleCheckBox = DoubleFilteringAction.createCheckBoxMenu();
    filterMenu.add(filterDoubleCheckBox);
    filterPolynomialCheckBox = PolynomialFilteringAction.createCheckBoxMenu();
    filterMenu.add(filterPolynomialCheckBox);
    filterFunctionLibCheckBox = FunctionLibFilteringAction.createCheckBoxMenu();
    filterMenu.add(filterFunctionLibCheckBox);
    filterStringCheckBox = StringFilteringAction.createCheckBoxMenu();
    filterMenu.add(filterStringCheckBox);
    filterSparceCheckBox = SparceFilteringAction.createCheckBoxMenu();
    filterMenu.add(filterSparceCheckBox);
    filterSparceBoolCheckBox = SparceBoolFilteringAction.createCheckBoxMenu();
    filterMenu.add(filterSparceBoolCheckBox);
    filterIntegerCheckBox = IntegerFilteringAction.createCheckBoxMenu();
    filterMenu.add(filterIntegerCheckBox);
    filterGraphicHandlesCheckBox = GraphicHandlesFilteringAction.createCheckBoxMenu();
    filterMenu.add(filterGraphicHandlesCheckBox);
    filterUncompiledFuncCheckBox = UncompiledFunctionFilteringAction.createCheckBoxMenu();
    filterMenu.add(filterUncompiledFuncCheckBox);
    filtercompiledFuncCheckBox = CompiledFunctionFilteringAction.createCheckBoxMenu();
    filterMenu.add(filtercompiledFuncCheckBox);
    filterListCheckBox = ListFilteringAction.createCheckBoxMenu();
    filterMenu.add(filterListCheckBox);
    filterTListCheckBox = TListFilteringAction.createCheckBoxMenu();
    filterMenu.add(filterTListCheckBox);
    filterMListCheckBox = MListFilteringAction.createCheckBoxMenu();
    filterMenu.add(filterMListCheckBox);
    filterPointerCheckBox = PointerFilteringAction.createCheckBoxMenu();
    filterMenu.add(filterPointerCheckBox);
    menuBar.add(filterMenu);
    return menuBar;
}
#method_after
public MenuBar buildMenuBar() {
    menuBar = ScilabMenuBar.createMenuBar();
    fileMenu = ScilabMenu.createMenu();
    fileMenu.setText(UiDataMessages.FILE);
    fileMenu.setMnemonic('F');
    fileMenu.add(CloseAction.createMenu());
    menuBar.add(fileMenu);
    filterMenu = ScilabMenu.createMenu();
    filterMenu.setText(UiDataMessages.FILTER);
    filterBooleanCheckBox = BooleanFilteringAction.createCheckBoxMenu();
    filterBooleanCheckBox.setChecked(true);
    filterMenu.add(filterBooleanCheckBox);
    filterDoubleCheckBox = DoubleFilteringAction.createCheckBoxMenu();
    filterDoubleCheckBox.setChecked(true);
    filterMenu.add(filterDoubleCheckBox);
    filterPolynomialCheckBox = PolynomialFilteringAction.createCheckBoxMenu();
    filterBooleanCheckBox.setChecked(true);
    filterMenu.add(filterPolynomialCheckBox);
    filterFunctionLibCheckBox = FunctionLibFilteringAction.createCheckBoxMenu();
    filterMenu.add(filterFunctionLibCheckBox);
    filterStringCheckBox = StringFilteringAction.createCheckBoxMenu();
    filterStringCheckBox.setChecked(true);
    filterMenu.add(filterStringCheckBox);
    filterSparceCheckBox = SparceFilteringAction.createCheckBoxMenu();
    filterSparceCheckBox.setChecked(true);
    filterMenu.add(filterSparceCheckBox);
    filterSparceBoolCheckBox = SparceBoolFilteringAction.createCheckBoxMenu();
    filterSparceBoolCheckBox.setChecked(true);
    filterMenu.add(filterSparceBoolCheckBox);
    filterIntegerCheckBox = IntegerFilteringAction.createCheckBoxMenu();
    filterIntegerCheckBox.setChecked(true);
    filterMenu.add(filterIntegerCheckBox);
    filterGraphicHandlesCheckBox = GraphicHandlesFilteringAction.createCheckBoxMenu();
    filterMenu.add(filterGraphicHandlesCheckBox);
    filterUncompiledFuncCheckBox = UncompiledFunctionFilteringAction.createCheckBoxMenu();
    filterMenu.add(filterUncompiledFuncCheckBox);
    filtercompiledFuncCheckBox = CompiledFunctionFilteringAction.createCheckBoxMenu();
    filterMenu.add(filtercompiledFuncCheckBox);
    filterListCheckBox = ListFilteringAction.createCheckBoxMenu();
    filterListCheckBox.setChecked(true);
    filterMenu.add(filterListCheckBox);
    filterTListCheckBox = TListFilteringAction.createCheckBoxMenu();
    filterTListCheckBox.setChecked(true);
    filterMenu.add(filterTListCheckBox);
    filterMListCheckBox = MListFilteringAction.createCheckBoxMenu();
    filterMListCheckBox.setChecked(true);
    filterMenu.add(filterMListCheckBox);
    filterPointerCheckBox = PointerFilteringAction.createCheckBoxMenu();
    filterMenu.add(filterPointerCheckBox);
    menuBar.add(filterMenu);
    return menuBar;
}
#end_block

#method_before
public HashSet<Integer> getFilteredValues() {
    HashSet<Integer> filteredValues = new HashSet<Integer>();
    // TODO to replace later by something which smells less
    if (filterBooleanCheckBox.isChecked()) {
        filteredValues.add(BOOLEAN_CLASS_NUMBER);
    }
    if (filterDoubleCheckBox.isChecked()) {
        filteredValues.add(DOUBLE_CLASS_NUMBER);
    }
    if (filterFunctionLibCheckBox.isChecked()) {
        filteredValues.add(FUNCTIONLIB_CLASS_NUMBER);
    }
    if (filterStringCheckBox.isChecked()) {
        filteredValues.add(STRING_CLASS_NUMBER);
    }
    if (filterPolynomialCheckBox.isChecked()) {
        filteredValues.add(POLYNOMIAL_CLASS_NUMBER);
    }
    if (filterSparceCheckBox.isChecked()) {
        filteredValues.add(SPARCE_CLASS_NUMBER);
    }
    if (filterSparceBoolCheckBox.isChecked()) {
        filteredValues.add(SPARCE_BOOLEAN_CLASS_NUMBER);
    }
    if (filterIntegerCheckBox.isChecked()) {
        filteredValues.add(INTEGER_CLASS_NUMBER);
    }
    if (filterGraphicHandlesCheckBox.isChecked()) {
        filteredValues.add(GRAPHIC_HANDLES_CLASS_NUMBER);
    }
    if (filterUncompiledFuncCheckBox.isChecked()) {
        filteredValues.add(UNCOMPILED_FUNCTION_CLASS_NUMBER);
    }
    if (filtercompiledFuncCheckBox.isChecked()) {
        filteredValues.add(COMPILED_FUNCTION_CLASS_NUMBER);
    }
    if (filterListCheckBox.isChecked()) {
        filteredValues.add(LIST_CLASS_NUMBER);
    }
    if (filterTListCheckBox.isChecked()) {
        filteredValues.add(TLIST_CLASS_NUMBER);
    }
    if (filterMListCheckBox.isChecked()) {
        filteredValues.add(MLIST_CLASS_NUMBER);
    }
    if (filterPointerCheckBox.isChecked()) {
        filteredValues.add(POINTER_CLASS_NUMBER);
    }
    return filteredValues;
}
#method_after
public HashSet<Integer> getFilteredValues() {
    HashSet<Integer> filteredValues = new HashSet<Integer>();
    // TODO to replace later by something which smells less
    if (filterBooleanCheckBox.isChecked()) {
        filteredValues.add(BOOLEAN_CLASS_NUMBER);
    }
    if (!filterDoubleCheckBox.isChecked()) {
        filteredValues.add(DOUBLE_CLASS_NUMBER);
    }
    if (!filterFunctionLibCheckBox.isChecked()) {
        filteredValues.add(FUNCTIONLIB_CLASS_NUMBER);
    }
    if (!filterStringCheckBox.isChecked()) {
        filteredValues.add(STRING_CLASS_NUMBER);
    }
    if (!filterPolynomialCheckBox.isChecked()) {
        filteredValues.add(POLYNOMIAL_CLASS_NUMBER);
    }
    if (!filterSparceCheckBox.isChecked()) {
        filteredValues.add(SPARCE_CLASS_NUMBER);
    }
    if (!filterSparceBoolCheckBox.isChecked()) {
        filteredValues.add(SPARCE_BOOLEAN_CLASS_NUMBER);
    }
    if (!filterIntegerCheckBox.isChecked()) {
        filteredValues.add(INTEGER_CLASS_NUMBER);
    }
    if (!filterGraphicHandlesCheckBox.isChecked()) {
        filteredValues.add(GRAPHIC_HANDLES_CLASS_NUMBER);
    }
    if (!filterUncompiledFuncCheckBox.isChecked()) {
        filteredValues.add(UNCOMPILED_FUNCTION_CLASS_NUMBER);
    }
    if (!filtercompiledFuncCheckBox.isChecked()) {
        filteredValues.add(COMPILED_FUNCTION_CLASS_NUMBER);
    }
    if (!filterListCheckBox.isChecked()) {
        filteredValues.add(LIST_CLASS_NUMBER);
    }
    if (!filterTListCheckBox.isChecked()) {
        filteredValues.add(TLIST_CLASS_NUMBER);
    }
    if (!filterMListCheckBox.isChecked()) {
        filteredValues.add(MLIST_CLASS_NUMBER);
    }
    if (!filterPointerCheckBox.isChecked()) {
        filteredValues.add(POINTER_CLASS_NUMBER);
    }
    return filteredValues;
}
#end_block

#method_before
public BasicBlock decode(SimulinkBlock from, BasicBlock into) {
    validate();
    /*
		 * fill the data
		 */
    fillDimension(from, into);
    fillOrigin(from, into);
    fillFlipAndRotation(from, into);
    return into;
}
#method_after
public BasicBlock decode(SimulinkBlock from, BasicBlock into) {
    /**
     * mutable field used to share decoded BasicBlock with submethods
     */
    BasicBlock base = into;
    validate();
    /*
		 * fill the data
		 */
    fillDimension(from, base);
    fillOrigin(from, base);
    fillFlipAndRotation(from, base);
    return base;
}
#end_block

#method_before
private void fillOrigin(SimulinkBlock from, BasicBlock into) {
    // TODO: Check if compatibility pattern needed
    String[] position = from.getParameter("Position").replaceAll("\\W", " ").trim().split("\\s+");
    if (LOG.isTraceEnabled()) {
        LOG.trace(Integer.toString(position.length));
        for (int i = 0; i < position.length; i++) {
            LOG.trace(position[i]);
        }
    }
    double x = Double.parseDouble(position[0]);
    double y = Double.parseDouble(position[1]);
    into.getGeometry().setX(x);
    into.getGeometry().setY(y);
}
#method_after
private void fillOrigin(SimulinkBlock from, BasicBlock into) {
    // TODO: Check if compatibility pattern needed
    /**
     * Position parameter read by parser is string and looks like this [55, 43, 54, 42]
     * \\W is used to strip string from non-word characters
     * \\s+ to split string around whitespaces
     */
    String[] position = from.getParameter("Position").replaceAll("\\W", " ").trim().split("\\s+");
    if (LOG.isTraceEnabled()) {
        LOG.trace(Integer.toString(position.length));
        for (int i = 0; i < position.length; i++) {
            LOG.trace(position[i]);
        }
    }
    double x = Double.parseDouble(position[0]);
    double y = Double.parseDouble(position[1]);
    into.getGeometry().setX(x);
    into.getGeometry().setY(y);
}
#end_block

#method_before
private void fillDimension(SimulinkBlock from, BasicBlock into) {
    // TODO: Check if compatibility pattern needed
    String[] position = from.getParameter("Position").replaceAll("\\W", " ").trim().split("\\s+");
    double w = Double.parseDouble(position[2]) - Double.parseDouble(position[0]);
    double h = Double.parseDouble(position[3]) - Double.parseDouble(position[1]);
    into.getGeometry().setWidth(w);
    into.getGeometry().setHeight(h);
}
#method_after
private void fillDimension(SimulinkBlock from, BasicBlock into) {
    // TODO: Check if compatibility pattern needed
    /**
     * Position parameter read by parser is string and looks like this [55, 43, 54, 42]
     * \\W is used to strip string from non-word characters
     * \\s+ to split string around whitespaces
     */
    String[] position = from.getParameter("Position").replaceAll("\\W", " ").trim().split("\\s+");
    double w = Double.parseDouble(position[2]) - Double.parseDouble(position[0]);
    double h = Double.parseDouble(position[3]) - Double.parseDouble(position[1]);
    into.getGeometry().setWidth(w);
    into.getGeometry().setHeight(h);
}
#end_block

#method_before
private void decodeParams(BasicBlock block) {
    // TODO Auto-generated method stub
    OutputPortElement outElement = new OutputPortElement(base);
    UnmodifiableIterator<SimulinkOutPort> portOutIter = base.getOutPorts().iterator();
    while (portOutIter.hasNext()) {
        // block.addPort(
        outElement.decode(portOutIter.next(), null);
    }
    InputPortElement inElement = new InputPortElement(base);
    UnmodifiableIterator<SimulinkInPort> portInIter = base.getInPorts().iterator();
    while (portInIter.hasNext()) {
        // block.addPort(
        inElement.decode(portInIter.next(), null);
    }
    /*
		 * decode graphics elements of BasicBlock
		 */
    graphicElement.decode(base, block);
    /*
		 * recursively decode all of the Block subBlocks
		 */
    decodeSubBlocks(block);
}
#method_after
private void decodeParams(BasicBlock block) {
    // TODO Auto-generated method stub
    OutputPortElement outElement = new OutputPortElement(base);
    UnmodifiableIterator<SimulinkOutPort> portOutIter = base.getOutPorts().iterator();
    while (portOutIter.hasNext()) {
        // TODO: block.addPort(outElement.decode(portOutIter.next(), null);
        outElement.decode(portOutIter.next(), null);
    }
    InputPortElement inElement = new InputPortElement(base);
    UnmodifiableIterator<SimulinkInPort> portInIter = base.getInPorts().iterator();
    while (portInIter.hasNext()) {
        // TODO:block.addPort(inElement.decode(portInIter.next(), null);
        inElement.decode(portInIter.next(), null);
    }
    /*
		 * decode graphics elements of BasicBlock
		 */
    graphicElement.decode(base, block);
    specificElement.decode(base, block);
    /*
		 * recursively decode all of the Block subBlocks
		 */
    decodeSubBlocks(block);
}
#end_block

#method_before
public BasicBlock decode(SimulinkBlock from, BasicBlock into) {
    validate();
    return into;
}
#method_after
public BasicBlock decode(SimulinkBlock from, BasicBlock into) {
    validate();
    patternElement.printPattern();
    return into;
}
#end_block

#method_before
public void closeXpad() {
    if (find != null) {
        find.closeFindReplaceWindow();
    }
    GotoLineAction.closeGotoLineWindow();
    SetColorsAction.closeSetColorsWindow();
    while (getTabPane().getComponentCount() > 0) {
        closeTabAt(0, true);
    }
    xpadList.remove(this);
    editor = null;
}
#method_after
public void closeXpad() {
    if (find != null) {
        find.closeFindReplaceWindow();
    }
    GotoLineAction.closeGotoLineWindow();
    SetColorsAction.closeSetColorsWindow();
    while (getTabPane().getComponentCount() > 0) {
        closeTabAt(0, true);
    }
    xpadList.remove(this);
    editor = null;
    SwingScilabWindow window = (SwingScilabWindow) parentWindow.getAsSimpleWindow();
    Point p = window.getLocation();
    ConfigXpadManager.saveMainWindowPosition(new Position(p.x, p.y));
    Dimension d = window.getSize();
    ConfigXpadManager.saveMainWindowSize(new Size(d.width, d.height));
}
#end_block

#method_before
public void splitTab(boolean vertical) {
    ScilabEditorPane pane = getTextPane();
    ScilabEditorPane leftPane = new ScilabEditorPane(editor);
    ScilabEditorPane rightPane = new ScilabEditorPane(editor);
    initPane(leftPane, true);
    initPane(rightPane, true);
    leftPane.setOtherPaneInSplit(rightPane);
    rightPane.setOtherPaneInSplit(leftPane);
    pane.copyProps(leftPane);
    pane.copyProps(rightPane);
    ScilabDocument doc = (ScilabDocument) pane.getDocument();
    leftPane.setDocument(doc);
    rightPane.setDocument(doc);
    leftPane.setCaretPosition(0);
    rightPane.setCaretPosition(0);
    JSplitPane split;
    if (vertical) {
        split = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
    } else {
        split = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
    }
    tabPane.setComponentAt(tabPane.getSelectedIndex(), split);
    split.setLeftComponent(leftPane.getScrollPane());
    split.setRightComponent(rightPane.getScrollPane());
    split.setResizeWeight(0.5);
    setContentPane(tabPane);
    setHelpOnTyping(leftPane);
    setHelpOnTyping(rightPane);
    initInputMap(leftPane);
    initInputMap(rightPane);
    if (doc.getBinary()) {
        leftPane.disableAll();
        rightPane.disableAll();
        getInfoBar().setText("Binary file : read-only mode");
    } else {
        getInfoBar().setText("");
    }
    updateTabTitle();
}
#method_after
public void splitTab(boolean vertical) {
    ScilabEditorPane pane = getTextPane();
    ScilabEditorPane leftPane = new ScilabEditorPane(editor);
    ScilabEditorPane rightPane = new ScilabEditorPane(editor);
    initPane(leftPane, true);
    initPane(rightPane, true);
    leftPane.setOtherPaneInSplit(rightPane);
    rightPane.setOtherPaneInSplit(leftPane);
    pane.copyProps(leftPane);
    pane.copyProps(rightPane);
    ScilabDocument doc = (ScilabDocument) pane.getDocument();
    leftPane.setDocument(doc);
    rightPane.setDocument(doc);
    leftPane.setCaretPosition(0);
    rightPane.setCaretPosition(0);
    JSplitPane split;
    if (vertical) {
        split = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
    } else {
        split = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);
    }
    tabPane.setComponentAt(tabPane.getSelectedIndex(), split);
    split.setLeftComponent(leftPane.getScrollPane());
    split.setRightComponent(rightPane.getScrollPane());
    split.setResizeWeight(0.5);
    setContentPane(tabPane);
    setHelpOnTyping(leftPane);
    setHelpOnTyping(rightPane);
    initInputMap(leftPane);
    initInputMap(rightPane);
    if (doc.getBinary()) {
        leftPane.disableAll();
        rightPane.disableAll();
        getInfoBar().setText(XpadMessages.BINARY_FILE_MODE);
    } else {
        getInfoBar().setText("");
    }
    updateTabTitle();
}
#end_block

#method_before
public void removeSplit() {
    if (tabPane.getSelectedComponent() instanceof JSplitPane) {
        ScilabEditorPane pane = new ScilabEditorPane(editor);
        ScilabEditorPane textpane = getTextPane();
        initPane(pane);
        textpane.setOtherPaneInSplit(null);
        textpane.copyProps(pane);
        ScilabDocument doc = (ScilabDocument) textpane.getDocument();
        pane.setDocument(doc);
        pane.setCaretPosition(0);
        setHelpOnTyping(pane);
        tabPane.setComponentAt(tabPane.getSelectedIndex(), pane.getScrollPane());
        setContentPane(tabPane);
        initInputMap(pane);
        if (doc.getBinary()) {
            pane.disableAll();
            getInfoBar().setText("Binary file : read-only mode");
        } else {
            getInfoBar().setText("");
        }
        updateTabTitle();
    }
}
#method_after
public void removeSplit() {
    if (tabPane.getSelectedComponent() instanceof JSplitPane) {
        ScilabEditorPane pane = new ScilabEditorPane(editor);
        ScilabEditorPane textpane = getTextPane();
        initPane(pane);
        textpane.setOtherPaneInSplit(null);
        textpane.copyProps(pane);
        ScilabDocument doc = (ScilabDocument) textpane.getDocument();
        pane.setDocument(doc);
        pane.setCaretPosition(0);
        setHelpOnTyping(pane);
        tabPane.setComponentAt(tabPane.getSelectedIndex(), pane.getScrollPane());
        setContentPane(tabPane);
        initInputMap(pane);
        if (doc.getBinary()) {
            pane.disableAll();
            getInfoBar().setText(XpadMessages.BINARY_FILE_MODE);
        } else {
            getInfoBar().setText("");
        }
        updateTabTitle();
    }
}
#end_block

#method_before
public void readFile(File f) {
    getInfoBar().setText(XpadMessages.LOADING);
    // Get current file path for Execute file into Scilab
    fileFullPath = f.getAbsolutePath();
    ScilabDocument styleDocument = null;
    ScilabEditorPane theTextPane;
    // File exist
    if (f.exists()) {
        theTextPane = addTab(f.getName());
        styleDocument = (ScilabDocument) theTextPane.getDocument();
        styleDocument.disableUndoManager();
        theTextPane.setLastModified(f.lastModified());
        try {
            synchronized (styleDocument) {
                styleDocument.setUpdater(false);
                boolean indentMode = styleDocument.getAutoIndent();
                styleDocument.setAutoIndent(false);
                try {
                    try {
                        editorKit.read(new BufferedReader(new InputStreamReader(new FileInputStream(f), styleDocument.getEncoding())), styleDocument, 0);
                    } catch (ChangedCharSetException e) {
                        editorKit.read(new BufferedReader(new InputStreamReader(new FileInputStream(f), e.getCharSetSpec())), styleDocument, 0);
                    }
                } catch (BadLocationException e) {
                    e.printStackTrace();
                }
                styleDocument.setAutoIndent(indentMode);
                styleDocument.setUpdater(true);
            }
        } catch (IOException ioex) {
            ioex.printStackTrace();
        }
        theTextPane.setName(f.getAbsolutePath());
        getTabPane().setTitleAt(getTabPane().getSelectedIndex(), f.getName());
        styleDocument.setContentModified(false);
        styleDocument.enableUndoManager();
        if (styleDocument.getBinary()) {
            theTextPane.setEditable(false);
            theTextPane.disableAll();
            getInfoBar().setText("Binary file : read-only mode");
        } else {
            getInfoBar().setText("");
        }
        xpadGUI.updateEncodingMenu((ScilabDocument) getTextPane().getDocument());
    // File does not exist
    } else {
        theTextPane = addEmptyTab();
        int choice = JOptionPane.showConfirmDialog(Xpad.this, String.format(XpadMessages.FILE_DOESNT_EXIST, f.getName()), XPAD, JOptionPane.YES_NO_OPTION);
        if (choice == 0) {
            // OK
            styleDocument = (ScilabDocument) theTextPane.getDocument();
            styleDocument.disableUndoManager();
            BufferedWriter out = null;
            try {
                out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f), styleDocument.getEncoding()));
                try {
                    editorKit.write(out, styleDocument, 0, styleDocument.getLength());
                    out.flush();
                    out.close();
                } catch (IOException e) {
                    e.printStackTrace();
                } catch (BadLocationException e) {
                    e.printStackTrace();
                }
            } catch (UnsupportedEncodingException e2) {
                e2.printStackTrace();
            } catch (FileNotFoundException e2) {
                e2.printStackTrace();
            }
            ConfigManager.saveLastOpenedDirectory(f.getPath());
            ConfigXpadManager.saveToRecentOpenedFiles(f.getPath());
            theTextPane.setName(f.getPath());
            getTabPane().setTitleAt(getTabPane().getSelectedIndex(), f.getName());
            setTitle(f.getPath() + TIRET + XpadMessages.SCILAB_EDITOR);
            updateRecentOpenedFilesMenu();
            styleDocument.setContentModified(false);
            styleDocument.enableUndoManager();
            getTextPane().setLastModified(f.lastModified());
            // Get current file path for Execute file into Scilab
            fileFullPath = f.getAbsolutePath();
            getInfoBar().setText("");
        } else {
            getInfoBar().setText("");
        }
    }
    // Empty the undo Manager
    UndoManager undo = ((ScilabDocument) getTextPane().getDocument()).getUndoManager();
    undo.discardAllEdits();
    synchronized (synchro) {
        synchro.notify();
    }
}
#method_after
public void readFile(File f) {
    getInfoBar().setText(XpadMessages.LOADING);
    // Get current file path for Execute file into Scilab
    fileFullPath = f.getAbsolutePath();
    ScilabDocument styleDocument = null;
    ScilabEditorPane theTextPane;
    // File exist
    if (f.exists()) {
        theTextPane = addTab(f.getName());
        styleDocument = (ScilabDocument) theTextPane.getDocument();
        styleDocument.disableUndoManager();
        theTextPane.setLastModified(f.lastModified());
        try {
            synchronized (styleDocument) {
                styleDocument.setUpdater(false);
                boolean indentMode = styleDocument.getAutoIndent();
                styleDocument.setAutoIndent(false);
                try {
                    try {
                        editorKit.read(new BufferedReader(new InputStreamReader(new FileInputStream(f), styleDocument.getEncoding())), styleDocument, 0);
                    } catch (ChangedCharSetException e) {
                        editorKit.read(new BufferedReader(new InputStreamReader(new FileInputStream(f), e.getCharSetSpec())), styleDocument, 0);
                    }
                } catch (BadLocationException e) {
                    e.printStackTrace();
                }
                styleDocument.setAutoIndent(indentMode);
                styleDocument.setUpdater(true);
            }
        } catch (IOException ioex) {
            ioex.printStackTrace();
        }
        theTextPane.setName(f.getAbsolutePath());
        getTabPane().setTitleAt(getTabPane().getSelectedIndex(), f.getName());
        styleDocument.setContentModified(false);
        styleDocument.enableUndoManager();
        if (styleDocument.getBinary()) {
            theTextPane.setEditable(false);
            theTextPane.disableAll();
            getInfoBar().setText(XpadMessages.BINARY_FILE_MODE);
        } else {
            getInfoBar().setText("");
        }
        xpadGUI.updateEncodingMenu((ScilabDocument) getTextPane().getDocument());
    // File does not exist
    } else {
        theTextPane = addEmptyTab();
        int choice = JOptionPane.showConfirmDialog(Xpad.this, String.format(XpadMessages.FILE_DOESNT_EXIST, f.getName()), XPAD, JOptionPane.YES_NO_OPTION);
        if (choice == 0) {
            // OK
            styleDocument = (ScilabDocument) theTextPane.getDocument();
            styleDocument.disableUndoManager();
            BufferedWriter out = null;
            try {
                out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f), styleDocument.getEncoding()));
                try {
                    editorKit.write(out, styleDocument, 0, styleDocument.getLength());
                    out.flush();
                    out.close();
                } catch (IOException e) {
                    e.printStackTrace();
                } catch (BadLocationException e) {
                    e.printStackTrace();
                }
            } catch (UnsupportedEncodingException e2) {
                e2.printStackTrace();
            } catch (FileNotFoundException e2) {
                e2.printStackTrace();
            }
            ConfigManager.saveLastOpenedDirectory(f.getPath());
            ConfigXpadManager.saveToRecentOpenedFiles(f.getPath());
            theTextPane.setName(f.getPath());
            getTabPane().setTitleAt(getTabPane().getSelectedIndex(), f.getName());
            setTitle(f.getPath() + TIRET + XpadMessages.SCILAB_EDITOR);
            updateRecentOpenedFilesMenu();
            styleDocument.setContentModified(false);
            styleDocument.enableUndoManager();
            getTextPane().setLastModified(f.lastModified());
            // Get current file path for Execute file into Scilab
            fileFullPath = f.getAbsolutePath();
            getInfoBar().setText("");
        } else {
            getInfoBar().setText("");
        }
    }
    // Empty the undo Manager
    UndoManager undo = ((ScilabDocument) getTextPane().getDocument()).getUndoManager();
    undo.discardAllEdits();
    synchronized (synchro) {
        synchro.notify();
    }
}
#end_block

#method_before
public void closeXpad() {
    if (find != null) {
        find.closeFindReplaceWindow();
    }
    GotoLineAction.closeGotoLineWindow();
    SetColorsAction.closeSetColorsWindow();
    while (getTabPane().getComponentCount() > 0) {
        closeTabAt(0, true);
    }
    editor = null;
}
#method_after
public void closeXpad() {
    if (find != null) {
        find.closeFindReplaceWindow();
    }
    GotoLineAction.closeGotoLineWindow();
    SetColorsAction.closeSetColorsWindow();
    while (getTabPane().getComponentCount() > 0) {
        closeTabAt(0, true);
    }
    editor = null;
    SwingScilabWindow window = (SwingScilabWindow) parentWindow.getAsSimpleWindow();
    Point p = window.getLocation();
    ConfigXpadManager.saveMainWindowPosition(new Position(p.x, p.y));
    Dimension d = window.getSize();
    ConfigXpadManager.saveMainWindowSize(new Size(d.width, d.height));
}
#end_block

#method_before
public void enableHighlightedLine(boolean active) {
    if (active && !highlightEnable) {
        try {
            getHighlighter().addHighlight(0, 0, this);
        } catch (BadLocationException e) {
        }
        highlightEnable = true;
    }
    if (!active && highlightEnable) {
        getHighlighter().removeAllHighlights();
        highlightEnable = false;
    }
    repaint();
}
#method_after
public void enableHighlightedLine(boolean active) {
    if (active && !highlightEnable) {
        try {
            highlightCL = getHighlighter().addHighlight(0, 0, this);
        } catch (BadLocationException e) {
        }
        highlightEnable = true;
    }
    if (!active && highlightEnable) {
        getHighlighter().removeHighlight(highlightCL);
        highlightEnable = false;
    }
    repaint();
}
#end_block

#method_before
public static void createPopupMenu(final JEditorPane c) {
    final JPopupMenu popup = new JPopupMenu();
    JMenuItem menuItem = null;
    /* Execute into Scilab */
    ActionListener actionListenerExecuteIntoScilab = new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            String selection = ((ScilabEditorPane) c).getCodeToExecute();
            if (selection == null) {
                infoBar.setText(Messages.gettext("No text to execute"));
            } else {
                ScilabConsole.getConsole().getAsSimpleConsole().sendCommandsToScilab(selection, true, true);
            }
        }
    };
    menuItem = new JMenuItem(XpadMessages.EVALUATE_SELECTION);
    menuItem.addActionListener(actionListenerExecuteIntoScilab);
    if (!ScilabConsole.isExistingConsole()) {
        /* Only available in STD mode */
        menuItem.setEnabled(false);
    }
    popup.add(menuItem);
    /* Edit in the Scilab Text Editor */
    ActionListener actionListenerLoadIntoTextEditor = new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            String selection = c.getSelectedText();
            if (selection == null) {
                infoBar.setText(Messages.gettext("No text selected"));
            } else {
                Xpad.xpadWithText(selection);
            }
        }
    };
    menuItem = new JMenuItem(Messages.gettext("Edit selection in a new tab"));
    menuItem.addActionListener(actionListenerLoadIntoTextEditor);
    popup.add(menuItem);
    popup.addSeparator();
    /* Copy */
    menuItem = new JMenuItem(new DefaultEditorKit.CopyAction());
    menuItem.setText(Messages.gettext("Copy"));
    popup.add(menuItem);
    popup.addSeparator();
    /* Cut */
    menuItem = new JMenuItem(new DefaultEditorKit.CutAction());
    menuItem.setText(Messages.gettext("Cut"));
    popup.add(menuItem);
    popup.addSeparator();
    /* Paste */
    menuItem = new JMenuItem(new DefaultEditorKit.PasteAction());
    menuItem.setText(Messages.gettext("Paste"));
    popup.add(menuItem);
    popup.addSeparator();
    /* Select all */
    ActionListener actionListenerSelectAll = new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            c.selectAll();
        }
    };
    menuItem = new JMenuItem(Messages.gettext("Select All"));
    menuItem.addActionListener(actionListenerSelectAll);
    popup.add(menuItem);
    /* Edit in the Scilab Text Editor */
    final JMenuItem helpMenuItem = new JMenuItem("Help on the selected text");
    ActionListener actionListenerHelpOnKeyword = new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            String selection = c.getSelectedText();
            if (selection == null) {
                KeywordEvent kwe = ((ScilabEditorPane) c).getKeywordEvent();
                if (ScilabLexerConstants.isHelpable(kwe.getType())) {
                    try {
                        selection = c.getDocument().getText(kwe.getStart(), kwe.getLength());
                    } catch (BadLocationException e) {
                    }
                } else {
                    infoBar.setText(Messages.gettext("No text selected"));
                    return;
                }
            }
            /* Double the quote/double quote in order to avoid
                     * and error with the call of help()
                     */
            selection = selection.replaceAll("'", "''");
            selection = selection.replaceAll("\"", "\"\"");
            InterpreterManagement.requestScilabExec("help('" + selection + "')");
        }
    };
    /* Not sure it is the best listener */
    PropertyChangeListener listenerTextItem = new PropertyChangeListener() {

        public void propertyChange(PropertyChangeEvent arg0) {
            String keyword = c.getSelectedText();
            if (keyword == null) {
                KeywordEvent kwe = ((ScilabEditorPane) c).getKeywordEvent();
                if (ScilabLexerConstants.isHelpable(kwe.getType())) {
                    try {
                        keyword = c.getDocument().getText(kwe.getStart(), kwe.getLength());
                    } catch (BadLocationException e) {
                    }
                } else {
                    helpMenuItem.setText(Messages.gettext("Help on selected text or keyword"));
                    return;
                }
            }
            int nbOfDisplayedOnlyXChar = 10;
            if (keyword.length() > nbOfDisplayedOnlyXChar) {
                keyword = keyword.substring(0, nbOfDisplayedOnlyXChar) + "...";
            }
            helpMenuItem.setText(Messages.gettext("Help about '") + keyword + "'");
        }
    };
    helpMenuItem.addPropertyChangeListener(listenerTextItem);
    helpMenuItem.addActionListener(actionListenerHelpOnKeyword);
    popup.add(helpMenuItem);
    /* Creates the Popupmenu on the component */
    c.setComponentPopupMenu(popup);
}
#method_after
public static void createPopupMenu(final JEditorPane c) {
    final JPopupMenu popup = new JPopupMenu();
    JMenuItem menuItem = null;
    /* Execute into Scilab */
    ActionListener actionListenerExecuteIntoScilab = new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            String selection = ((ScilabEditorPane) c).getCodeToExecute();
            if (selection == null) {
                infoBar.setText(Messages.gettext("No text to execute"));
            } else {
                ScilabConsole.getConsole().getAsSimpleConsole().sendCommandsToScilab(selection, true, true);
            }
        }
    };
    menuItem = new JMenuItem(XpadMessages.EVALUATE_SELECTION);
    menuItem.addActionListener(actionListenerExecuteIntoScilab);
    if (!ScilabConsole.isExistingConsole()) {
        /* Only available in STD mode */
        menuItem.setEnabled(false);
    }
    popup.add(menuItem);
    /* Edit in the Scilab Text Editor */
    ActionListener actionListenerLoadIntoTextEditor = new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            String selection = c.getSelectedText();
            if (selection == null) {
                infoBar.setText(Messages.gettext("No text selected"));
            } else {
                Xpad.xpadWithText(selection);
            }
        }
    };
    menuItem = new JMenuItem(Messages.gettext("Edit selection in a new tab"));
    menuItem.addActionListener(actionListenerLoadIntoTextEditor);
    popup.add(menuItem);
    popup.addSeparator();
    /* Copy */
    menuItem = new JMenuItem(new DefaultEditorKit.CopyAction());
    menuItem.setText(Messages.gettext("Copy"));
    popup.add(menuItem);
    popup.addSeparator();
    /* Cut */
    menuItem = new JMenuItem(new DefaultEditorKit.CutAction());
    menuItem.setText(Messages.gettext("Cut"));
    popup.add(menuItem);
    popup.addSeparator();
    /* Paste */
    menuItem = new JMenuItem(new DefaultEditorKit.PasteAction());
    menuItem.setText(Messages.gettext("Paste"));
    popup.add(menuItem);
    popup.addSeparator();
    /* Select all */
    ActionListener actionListenerSelectAll = new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            c.selectAll();
        }
    };
    menuItem = new JMenuItem(Messages.gettext("Select All"));
    menuItem.addActionListener(actionListenerSelectAll);
    popup.add(menuItem);
    /* Edit in the Scilab Text Editor */
    final JMenuItem helpMenuItem = new JMenuItem("Help on the selected text");
    ActionListener actionListenerHelpOnKeyword = new ActionListener() {

        public void actionPerformed(ActionEvent actionEvent) {
            String selection = c.getSelectedText();
            if (selection == null) {
                KeywordEvent kwe = ((ScilabEditorPane) c).getKeywordEvent();
                if (ScilabLexerConstants.isHelpable(kwe.getType())) {
                    try {
                        selection = c.getDocument().getText(kwe.getStart(), kwe.getLength());
                    } catch (BadLocationException e) {
                    }
                } else {
                    infoBar.setText(Messages.gettext("No text selected"));
                    return;
                }
            }
            /* Double the quote/double quote in order to avoid
                     * and error with the call of help()
                     */
            selection = selection.replaceAll("'", "''");
            selection = selection.replaceAll("\"", "\"\"");
            InterpreterManagement.requestScilabExec("help('" + selection + "')");
        }
    };
    /* Not sure it is the best listener */
    PropertyChangeListener listenerTextItem = new PropertyChangeListener() {

        public void propertyChange(PropertyChangeEvent arg0) {
            String keyword = c.getSelectedText();
            if (keyword == null) {
                KeywordEvent kwe = ((ScilabEditorPane) c).getKeywordEvent();
                if (ScilabLexerConstants.isHelpable(kwe.getType())) {
                    try {
                        keyword = c.getDocument().getText(kwe.getStart(), kwe.getLength());
                    } catch (BadLocationException e) {
                    }
                } else {
                    helpMenuItem.setText(Messages.gettext("Help on selected text or keyword"));
                    helpMenuItem.setEnabled(false);
                    return;
                }
            }
            int nbOfDisplayedOnlyXChar = 10;
            if (keyword.length() > nbOfDisplayedOnlyXChar) {
                keyword = keyword.substring(0, nbOfDisplayedOnlyXChar) + "...";
            }
            helpMenuItem.setText(Messages.gettext("Help about '") + keyword + "'");
            helpMenuItem.setEnabled(true);
        }
    };
    helpMenuItem.addPropertyChangeListener(listenerTextItem);
    helpMenuItem.addActionListener(actionListenerHelpOnKeyword);
    popup.add(helpMenuItem);
    /* Creates the Popupmenu on the component */
    c.setComponentPopupMenu(popup);
}
#end_block

#method_before
private void createToolsMenu(Menu toolsMenu, Xpad editorInstance) {
    toolsMenu.setText(XpadMessages.TOOLS);
    toolsMenu.setMnemonic('o');
    toolsMenu.add(ActivateHelpOnTypingAction.createCheckBoxMenu(editorInstance, map.get("ActivateHelpOnTypingAction")));
    toolsMenu.addSeparator();
    toolsMenu.add(CommentAction.createMenu(editorInstance, map.get("CommentAction")));
    toolsMenu.add(UnCommentAction.createMenu(editorInstance, map.get("UnCommentAction")));
    toolsMenu.addSeparator();
    toolsMenu.add(TabifyAction.createMenu(editorInstance, map.get("TabifyAction")));
    toolsMenu.add(UnTabifyAction.createMenu(editorInstance, map.get("UnTabifyAction")));
    toolsMenu.addSeparator();
    toolsMenu.add(IndentAction.createMenu(editorInstance, map.get("IndentAction")));
    toolsMenu.addSeparator();
    toolsMenu.add(RemoveTrailingWhiteAction.createMenu(editorInstance, map.get("RemoveTrailingWhiteAction")));
}
#method_after
private void createToolsMenu(Menu toolsMenu, Xpad editorInstance) {
    toolsMenu.setText(XpadMessages.TOOLS);
    toolsMenu.setMnemonic('o');
    toolsMenu.add(ActivateHelpOnTypingAction.createCheckBoxMenu(editorInstance, map.get("ActivateHelpOnTypingAction")));
    toolsMenu.addSeparator();
    toolsMenu.add(OpenTabInNewWindowAction.createMenu(editorInstance, map.get("OpenTabInNewWindowAction")));
    toolsMenu.add(CCloseTabInNewWindowAction.createMenu(editorInstance, map.get("CCloseTabInNewWindowAction")));
    toolsMenu.addSeparator();
    toolsMenu.add(CommentAction.createMenu(editorInstance, map.get("CommentAction")));
    toolsMenu.add(UnCommentAction.createMenu(editorInstance, map.get("UnCommentAction")));
    toolsMenu.addSeparator();
    toolsMenu.add(TabifyAction.createMenu(editorInstance, map.get("TabifyAction")));
    toolsMenu.add(UnTabifyAction.createMenu(editorInstance, map.get("UnTabifyAction")));
    toolsMenu.addSeparator();
    toolsMenu.add(IndentAction.createMenu(editorInstance, map.get("IndentAction")));
    toolsMenu.addSeparator();
    toolsMenu.add(GenerateHelpFromFunctionAction.createMenu(editorInstance, map.get("GenerateHelpFromFunctionAction")));
    toolsMenu.add(RemoveTrailingWhiteAction.createMenu(editorInstance, map.get("RemoveTrailingWhiteAction")));
}
#end_block

#method_before
public void setDataVector(Object[][] data) {
    int cols = data[0].length;
    Integer[] identifiers = new Integer[cols];
    for (int i = 0; i < cols; ++i) {
        identifiers[i] = i;
    }
    super.setDataVector(data, identifiers);
}
#method_after
public void setDataVector(Object[][] data) {
    int cols = data[0].length;
    Integer[] identifiers = new Integer[cols];
    for (int i = 0; i < cols; ++i) {
        identifiers[i] = i + 1;
    }
    super.setDataVector(data, identifiers);
}
#end_block

#method_before
public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int col) {
    // +1 because scilab index start at 1
    this.row = row + 1;
    this.col = row + 1;
    return super.getTableCellEditorComponent(table, value, isSelected, row, col);
}
#method_after
public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int col) {
    // +1 because scilab index start at 1
    this.row = row + 1;
    this.col = col + 1;
    return super.getTableCellEditorComponent(table, value, isSelected, row, col);
}
#end_block

#method_before
private void installStylesheet() {
    final mxCodec codec = new mxCodec();
    try {
        /*
			 * Initialize constants
			 */
        final String file = "Xcos-style.xml";
        final String homePath = XcosConstants.SCIHOME.getAbsolutePath();
        final File userStyleSheet = new File(homePath + '/' + file);
        /*
	    	 * Copy the base stylesheet into the user dir when it doesn't exist.
	    	 */
        if (!userStyleSheet.exists()) {
            final String sciPath = XcosConstants.SCI.getAbsolutePath();
            File baseStyleSheet = new File(sciPath + "/modules/xcos/etc/" + file);
            FileUtils.forceCopy(baseStyleSheet, userStyleSheet);
        }
        /*
			 * Load the stylesheet
			 */
        final String sciURL = XcosConstants.SCI.toURI().toURL().toString();
        final String homeURL = XcosConstants.SCIHOME.toURI().toURL().toString();
        String xml = mxUtils.readFile(userStyleSheet.getAbsolutePath());
        xml = xml.replaceAll("\\$SCILAB", sciURL);
        xml = xml.replaceAll("\\$SCIHOME", homeURL);
        Document document = mxUtils.parse(xml);
        codec.decode(document.getDocumentElement(), getStylesheet());
    } catch (IOException e) {
        LOG.warn(e);
        return;
    }
    // Set Canvas background
    URL background = null;
    try {
        Map<String, Object> style = getStylesheet().getCellStyle("Icon", null);
        if (style != null) {
            background = new URL((String) style.get(XcosConstants.STYLE_IMAGE));
        }
    } catch (MalformedURLException e) {
        LOG.warn(e);
    }
    ((ScilabCanvas) getAsComponent().getCanvas()).setSvgBackgroundImage(background);
}
#method_after
private void installStylesheet() {
    final mxCodec codec = new mxCodec();
    try {
        /*
			 * Initialize constants
			 */
        final String file = "Xcos-style.xml";
        final String homePath = ScilabConstants.SCIHOME.getAbsolutePath();
        final File userStyleSheet = new File(homePath + '/' + file);
        /*
	    	 * Copy the base stylesheet into the user dir when it doesn't exist.
	    	 */
        if (!userStyleSheet.exists()) {
            final String sciPath = ScilabConstants.SCI.getAbsolutePath();
            File baseStyleSheet = new File(sciPath + "/modules/xcos/etc/" + file);
            FileUtils.forceCopy(baseStyleSheet, userStyleSheet);
        }
        /*
			 * Load the stylesheet
			 */
        final String sciURL = ScilabConstants.SCI.toURI().toURL().toString();
        final String homeURL = ScilabConstants.SCIHOME.toURI().toURL().toString();
        String xml = mxUtils.readFile(userStyleSheet.getAbsolutePath());
        xml = xml.replaceAll("\\$SCILAB", sciURL);
        xml = xml.replaceAll("\\$SCIHOME", homeURL);
        Document document = mxUtils.parse(xml);
        codec.decode(document.getDocumentElement(), getStylesheet());
    } catch (IOException e) {
        LOG.warn(e);
        return;
    }
    // Set Canvas background
    URL background = null;
    try {
        Map<String, Object> style = getStylesheet().getCellStyle("Icon", null);
        if (style != null) {
            background = new URL((String) style.get(XcosConstants.STYLE_IMAGE));
        }
    } catch (MalformedURLException e) {
        LOG.warn(e);
    }
    ((ScilabCanvas) getAsComponent().getCanvas()).setSvgBackgroundImage(background);
}
#end_block

#method_before
@ScilabExported(module = "xcos", filename = "Xcos.giws.xml")
public static void xcos(String fileName) {
    /* load scicos libraries (macros) */
    ScilabInterpreterManagement.requestScilabExec("loadScicosLibs();");
    final String filename = fileName;
    SwingUtilities.invokeLater(new Runnable() {

        public void run() {
            ConfigurationManager.getInstance().addToRecentFiles(filename);
            if (!XcosTab.focusOnExistingFile(filename)) {
                XcosDiagram diagram = createEmptyDiagram();
                diagram.openDiagramFromFile(filename);
            }
            ConfigurationManager.getInstance().saveConfig();
        }
    });
}
#method_after
@ScilabExported(module = "xcos", filename = "Xcos.giws.xml")
public static void xcos(String fileName) {
    /* load scicos libraries (macros) */
    ScilabInterpreterManagement.requestScilabExec("loadScicosLibs();");
    // FIXME: temporary workaround
    // fix #7015 by instantiate the palette manager once.
    PaletteManager.getInstance();
    final String filename = fileName;
    SwingUtilities.invokeLater(new Runnable() {

        public void run() {
            ConfigurationManager.getInstance().addToRecentFiles(filename);
            if (!XcosTab.focusOnExistingFile(filename)) {
                XcosDiagram diagram = createEmptyDiagram();
                ViewPaletteBrowserAction.setPalettesVisible(false);
                diagram.openDiagramFromFile(filename);
            }
            ConfigurationManager.getInstance().saveConfig();
        }
    });
}
#end_block

#method_before
public static void synchronousScilabExec(String command) throws InterpreterException {
    final String uidDesc = Integer.toString(command.hashCode());
    final String fullCommand = command + NOTIFY + uidDesc + CLOSE;
    if (runningTasks.contains(uidDesc)) {
        throw new InterpreterException(ScilabInterpreterManagementMessages.SCILAB_SAMECOMMAND);
    }
    int ret = InterpreterManagement.requestScilabExec(fullCommand);
    if (ret != 0) {
        throw new InterpreterException(ScilabInterpreterManagementMessages.SCILAB_UNABLE);
    }
    runningTasks.add(uidDesc);
    Signal.wait(uidDesc);
    runningTasks.remove(uidDesc);
}
#method_after
public static void synchronousScilabExec(String command) throws InterpreterException {
    final String uidDesc = Integer.toString(command.hashCode());
    final String fullCommand = command + NOTIFY + uidDesc + CLOSE;
    if (runningTasks.contains(uidDesc)) {
        throw new InterpreterException(ActionBindingMessages.SCILAB_SAMECOMMAND);
    }
    int ret = InterpreterManagement.requestScilabExec(fullCommand);
    if (ret != 0) {
        throw new InterpreterException(ActionBindingMessages.SCILAB_UNABLE);
    }
    runningTasks.add(uidDesc);
    Signal.wait(uidDesc);
    runningTasks.remove(uidDesc);
}
#end_block

#method_before
@Deprecated
public static void asynchronousScilabExec(String command, final ActionListener callback) throws InterpreterException {
    final int uid = command.hashCode();
    final String uidDesc = Integer.toString(uid);
    final String fullCommand = command + NOTIFY + uidDesc + CLOSE;
    final ActionEvent event = new ActionEvent(ScilabInterpreterManagement.class, uid, command);
    if (runningTasks.contains(uidDesc)) {
        throw new InterpreterException(ScilabInterpreterManagementMessages.SCILAB_SAMECOMMAND);
    }
    executor.submit(new Callable<Void>() {

        public Void call() throws Exception {
            int ret = InterpreterManagement.putCommandInScilabQueue(fullCommand);
            if (ret != 0) {
                throw new InterpreterException(ScilabInterpreterManagementMessages.SCILAB_UNABLE);
            }
            runningTasks.add(uidDesc);
            Signal.wait(uidDesc);
            runningTasks.remove(uidDesc);
            SwingUtilities.invokeLater(new Runnable() {

                public void run() {
                    callback.actionPerformed(event);
                }
            });
            return null;
        }
    });
}
#method_after
@Deprecated
public static void asynchronousScilabExec(String command, final ActionListener callback) throws InterpreterException {
    final int uid = command.hashCode();
    final String uidDesc = Integer.toString(uid);
    final String fullCommand = command + NOTIFY + uidDesc + CLOSE;
    final ActionEvent event = new ActionEvent(ScilabInterpreterManagement.class, uid, command);
    if (runningTasks.contains(uidDesc)) {
        throw new InterpreterException(ActionBindingMessages.SCILAB_SAMECOMMAND);
    }
    executor.submit(new Callable<Void>() {

        public Void call() throws Exception {
            int ret = InterpreterManagement.putCommandInScilabQueue(fullCommand);
            if (ret != 0) {
                throw new InterpreterException(ActionBindingMessages.SCILAB_UNABLE);
            }
            runningTasks.add(uidDesc);
            Signal.wait(uidDesc);
            runningTasks.remove(uidDesc);
            SwingUtilities.invokeLater(new Runnable() {

                public void run() {
                    callback.actionPerformed(event);
                }
            });
            return null;
        }
    });
}
#end_block

#method_before
public static void asynchronousScilabExec(final ActionListener callback, String command) throws InterpreterException {
    final int uid = command.hashCode();
    final String uidDesc = Integer.toString(uid);
    final String fullCommand = command + NOTIFY + uidDesc + CLOSE;
    final ActionEvent event = new ActionEvent(ScilabInterpreterManagement.class, uid, command);
    if (runningTasks.contains(uidDesc)) {
        throw new InterpreterException(ScilabInterpreterManagementMessages.SCILAB_SAMECOMMAND);
    }
    executor.submit(new Callable<Void>() {

        public Void call() throws Exception {
            int ret = InterpreterManagement.putCommandInScilabQueue(fullCommand);
            if (ret != 0) {
                throw new InterpreterException(ScilabInterpreterManagementMessages.SCILAB_UNABLE);
            }
            runningTasks.add(uidDesc);
            Signal.wait(uidDesc);
            runningTasks.remove(uidDesc);
            SwingUtilities.invokeLater(new Runnable() {

                public void run() {
                    callback.actionPerformed(event);
                }
            });
            return null;
        }
    });
}
#method_after
public static void asynchronousScilabExec(final ActionListener callback, String command) throws InterpreterException {
    final int uid = command.hashCode();
    final String uidDesc = Integer.toString(uid);
    final String fullCommand = command + NOTIFY + uidDesc + CLOSE;
    final ActionEvent event = new ActionEvent(ScilabInterpreterManagement.class, uid, command);
    if (runningTasks.contains(uidDesc)) {
        throw new InterpreterException(ActionBindingMessages.SCILAB_SAMECOMMAND);
    }
    executor.submit(new Callable<Void>() {

        public Void call() throws Exception {
            int ret = InterpreterManagement.putCommandInScilabQueue(fullCommand);
            if (ret != 0) {
                throw new InterpreterException(ActionBindingMessages.SCILAB_UNABLE);
            }
            runningTasks.add(uidDesc);
            Signal.wait(uidDesc);
            runningTasks.remove(uidDesc);
            SwingUtilities.invokeLater(new Runnable() {

                public void run() {
                    callback.actionPerformed(event);
                }
            });
            return null;
        }
    });
}
#end_block

#method_before
public void keyTyped(KeyEvent e) {
    char c = e.getKeyChar();
    if (c != KeyEvent.CHAR_UNDEFINED) {
        int pos = textPane.getCaretPosition();
        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
            try {
                doc.insertString(pos, Character.toString(c), null);
                e.consume();
                KeywordEvent kwe = textPane.getKeywordEvent(pos + 1);
                switch(kwe.getType()) {
                    case ScilabLexerConstants.OSKEYWORD:
                        doc.insertString(pos + 1, "\nend", null);
                        textPane.getIndentManager().indentDoc(pos + 1, pos + 4);
                        textPane.setCaretPosition(pos + 1);
                        break;
                    case ScilabLexerConstants.FKEYWORD:
                        if ("f".equals(doc.getText(kwe.getStart(), 1))) {
                            doc.insertString(pos + 1, " ()\nendfunction", null);
                            textPane.getIndentManager().indentDoc(pos + 4, pos + 15);
                            textPane.setCaretPosition(pos + 2);
                        }
                        break;
                }
            } catch (BadLocationException exc) {
            }
        } else {
            if (c == '(' || c == '[' || c == '{') {
                String str;
                switch(c) {
                    case '(':
                        str = "()";
                        break;
                    case '[':
                        str = "[]";
                        break;
                    default:
                        str = "{}";
                }
                try {
                    doc.insertString(pos, str, null);
                    e.consume();
                    textPane.setCaretPosition(pos + 1);
                } catch (BadLocationException exc) {
                }
            }
        }
    }
}
#method_after
public void keyTyped(KeyEvent e) {
    char c = e.getKeyChar();
    if (c != KeyEvent.CHAR_UNDEFINED && textPane.getSelectionStart() == textPane.getSelectionEnd() && e.getModifiers() == 0) {
        int pos = textPane.getCaretPosition();
        if (c == ' ') {
            try {
                doc.insertString(pos, " ", null);
                e.consume();
                KeywordEvent kwe = textPane.getKeywordEvent(pos);
                switch(kwe.getType()) {
                    case ScilabLexerConstants.OSKEYWORD:
                        doc.insertString(pos + 1, "\nend", null);
                        textPane.getIndentManager().indentDoc(pos + 1, pos + 4);
                        textPane.setCaretPosition(pos + 1);
                        break;
                    case ScilabLexerConstants.FKEYWORD:
                        /* We have 'function' or 'endfunction' */
                        if ("f".equals(doc.getText(kwe.getStart(), 1))) {
                            doc.insertString(pos + 1, "()\nendfunction", null);
                            textPane.getIndentManager().indentDoc(pos + 3, pos + 14);
                            textPane.setCaretPosition(pos + 1);
                        }
                        break;
                }
            } catch (BadLocationException exc) {
            }
        } else {
            String str = null;
            switch(c) {
                case '(':
                    str = "()";
                    break;
                case '[':
                    str = "[]";
                    break;
                case '{':
                    str = "{}";
                    break;
                case '\"':
                    str = "\"\"";
            }
            if (str != null) {
                try {
                    doc.insertString(pos, str, null);
                    e.consume();
                    textPane.setCaretPosition(pos + 1);
                } catch (BadLocationException exc) {
                }
            }
        }
    }
}
#end_block

#method_before
private File wrapTeX(File inFile) throws IOException {
    String tex = Helpers.loadString(inFile, "ISO-8859-1");
    File latexFile = File.createTempFile("CopyConvert", ".tex", ScilabConstants.TMPDIR);
    StringBuilder buffer = new StringBuilder();
    buffer.append("\\documentclass[12pt]{article}\n");
    buffer.append("\\usepackage[latin1]{inputenc}\n");
    buffer.append("\\pagestyle{empty}\n");
    buffer.append("\\begin{document}\n");
    buffer.append(tex);
    buffer.append('\n');
    buffer.append("\\end{document}\n");
    Helpers.saveString(buffer.toString(), latexFile, "ISO-8859-1");
    return latexFile;
}
#method_after
private File wrapTeX(File inFile) throws IOException {
    String tex = Helpers.loadString(inFile, "ISO-8859-1");
    File latexFile = File.createTempFile("CopyConvert", ".tex", TMPDIR);
    StringBuilder buffer = new StringBuilder();
    buffer.append("\\documentclass[12pt]{article}\n");
    buffer.append("\\usepackage[latin1]{inputenc}\n");
    buffer.append("\\pagestyle{empty}\n");
    buffer.append("\\begin{document}\n");
    buffer.append(tex);
    buffer.append('\n');
    buffer.append("\\end{document}\n");
    Helpers.saveString(buffer.toString(), latexFile, "ISO-8859-1");
    return latexFile;
}
#end_block

#method_before
/**
 * Preprocess the extendedStyle.xsl file
 * Basically, we load the xsl and replace STYLE_DOC by the actual path
 * to the xsl file since docbook cannot replace env variables
 * @return the path to the preprocessed file
 */
private File generateExtendedStyle() {
    String mainStyleDoc = SCI + "/modules/helptools/schema/extendedStyle.xsl";
    try {
        String contentMainStyleDoc = Helpers.loadString(new File(mainStyleDoc), "UTF-8");
        /* STYLE_DOC is a predefined variable */
        File tmpFileForURI = new File(this.styleDoc);
        contentMainStyleDoc = contentMainStyleDoc.replaceAll("STYLE_DOC", tmpFileForURI.toURI().toString());
        File temporaryStyleFile = File.createTempFile("style_", ".xsl", ScilabConstants.TMPDIR);
        Helpers.saveString(contentMainStyleDoc, temporaryStyleFile, "UTF-8");
        return temporaryStyleFile;
    } catch (java.io.IOException e) {
        System.err.println("Could not convert " + mainStyleDoc);
        return null;
    }
}
#method_after
/**
 * Preprocess the extendedStyle.xsl file
 * Basically, we load the xsl and replace STYLE_DOC by the actual path
 * to the xsl file since docbook cannot replace env variables
 * @return the path to the preprocessed file
 */
private File generateExtendedStyle() {
    String mainStyleDoc = SCI + "/modules/helptools/schema/extendedStyle.xsl";
    try {
        String contentMainStyleDoc = Helpers.loadString(new File(mainStyleDoc), "UTF-8");
        /* STYLE_DOC is a predefined variable */
        File tmpFileForURI = new File(this.styleDoc);
        contentMainStyleDoc = contentMainStyleDoc.replaceAll("STYLE_DOC", tmpFileForURI.toURI().toString());
        File temporaryStyleFile = File.createTempFile("style_", ".xsl");
        Helpers.saveString(contentMainStyleDoc, temporaryStyleFile, "UTF-8");
        return temporaryStyleFile;
    } catch (java.io.IOException e) {
        System.err.println("Could not convert " + mainStyleDoc);
        return null;
    }
}
#end_block

#method_before
public void doAction() {
    KeywordEvent kwe = ((ScilabEditorPane) getEditor().getTextPane()).getKeywordEvent();
    if (ScilabLexerConstants.isOpenable(kwe.getType())) {
        try {
            String kw = getEditor().getTextPane().getDocument().getText(kwe.getStart(), kwe.getLength());
            InterpreterManagement.requestScilabExec("a46d43fa4w5z8512dc7dc2c3=get_function_path(" + kw + ");if a46d43fa4w5z8512dc7dc2c3~=[] then editor(a46d43fa4w5z8512dc7dc2c3);clear a46d43fa4w5z8512dc7dc2c3;end");
        } catch (BadLocationException e) {
        }
    }
}
#method_after
public void doAction() {
    KeywordEvent kwe = ((ScilabEditorPane) getEditor().getTextPane()).getKeywordEvent();
    if (ScilabLexerConstants.isOpenable(kwe.getType())) {
        try {
            String kw = getEditor().getTextPane().getDocument().getText(kwe.getStart(), kwe.getLength());
            InterpreterManagement.requestScilabExec("a46d43fa4w5z8512dc7dc2c3=get_function_path('" + kw + "');if a46d43fa4w5z8512dc7dc2c3~=[] then editor(a46d43fa4w5z8512dc7dc2c3);clear a46d43fa4w5z8512dc7dc2c3;end");
        } catch (BadLocationException e) {
        }
    }
}
#end_block

#method_before
protected int drawUnselectedText(Graphics g, int sx, int sy, int p0, int p1) throws BadLocationException {
    /* The lexer returns all tokens between the pos p0 and p1.
	   The value of the returned token determinates the color and the font.
	   The lines can be broken by the Pane so we must look at previous
	   and next chars to know if p0 or p1 is "inside" a token. */
    Element elem = doc.getDefaultRootElement();
    Element line = elem.getElement(elem.getElementIndex(p0));
    int prevTok = -1;
    int tok = -1;
    int mark = p0;
    int start = p0;
    int x = sx;
    int y = sy;
    boolean isBroken = false;
    if (desktopFontHints == null) {
        /* This hint is used to have antialiased fonts in the view in using 
	       the same method (differents way to antialias with LCD screen) as the desktop. */
        desktopFontHints = (Map) Toolkit.getDefaultToolkit().getDesktopProperty(DESKTOPHINTS);
        calculateHeight(((Graphics2D) g).getFontRenderContext(), context.tokenFonts[0]);
    } else {
        ((Graphics2D) g).addRenderingHints(desktopFontHints);
    }
    int startL = line.getStartOffset();
    int endL = line.getEndOffset();
    if (startL != start) {
        // we are drawing a broken line
        try {
            lexer.setRange(startL, endL);
            while (startL < start) {
                tok = lexer.yylex();
                startL = lexer.start + lexer.yychar() + lexer.yylength();
            }
            isBroken = true;
        } catch (IOException e) {
        }
    }
    if (!isBroken) {
        lexer.setRange(start, endL);
    }
    while (start < p1) {
        try {
            if (!isBroken) {
                tok = lexer.yylex();
            } else {
                isBroken = false;
            }
        } catch (IOException e) {
        }
        start = lexer.start + lexer.yychar();
        int end = Math.min(p1, start + lexer.yylength());
        if (end != mark) {
            if (tok != prevTok) {
                g.setColor(context.tokenColors[tok]);
                g.setFont(context.tokenFonts[tok]);
                prevTok = tok;
            }
            doc.getText(mark, end - mark, text);
            int w;
            if ((context.tokenAttrib[tok] & 1) != 0) {
                w = Utilities.getTabbedTextWidth(text, g.getFontMetrics(), x, this, mark);
                g.drawLine(x, y + 1, x + w, y + 1);
            }
            if ((context.tokenAttrib[tok] & 2) != 0) {
                w = Utilities.getTabbedTextWidth(text, g.getFontMetrics(), x, this, mark);
                g.drawLine(x, y - whiteHeight, x + w, y - whiteHeight);
            }
            switch(tok) {
                case ScilabLexerConstants.WHITE:
                    if (isWhiteViewable) {
                        w = Utilities.getTabbedTextWidth(text, g.getFontMetrics(), x, this, mark);
                        g.drawLine(x + (w - 1) / 2, y - whiteHeight, x + (w + 1) / 2, y - whiteHeight);
                    }
                    break;
                case ScilabLexerConstants.TAB:
                    if (isTabViewable) {
                        paintTab(text, x, y, g, mark);
                    }
                    break;
                case ScilabLexerConstants.LATEX:
                    if (isLaTeXViewable) {
                    // LaTeXUtilities.drawText(text, x, y, g, mark);
                    }
                    break;
                default:
                    break;
            }
            x = Utilities.drawTabbedText(text, x, y, g, this, mark);
            mark = end;
        }
        start = end;
    }
    return x;
}
#method_after
protected int drawUnselectedText(Graphics g, int sx, int sy, int p0, int p1) throws BadLocationException {
    /* The lexer returns all tokens between the pos p0 and p1.
           The value of the returned token determinates the color and the font.
           The lines can be broken by the Pane so we must look at previous
           and next chars to know if p0 or p1 is "inside" a token. */
    Element elem = doc.getDefaultRootElement();
    Element line = elem.getElement(elem.getElementIndex(p0));
    int prevTok = -1;
    int tok = -1;
    int mark = p0;
    int start = p0;
    int x = sx;
    int y = sy;
    boolean isBroken = false;
    if (desktopFontHints == null) {
        /* This hint is used to have antialiased fonts in the view in using 
               the same method (differents way to antialias with LCD screen) as the desktop. */
        desktopFontHints = (Map) Toolkit.getDefaultToolkit().getDesktopProperty(DESKTOPHINTS);
        calculateHeight(((Graphics2D) g).getFontRenderContext(), context.tokenFonts[0]);
    } else {
        ((Graphics2D) g).addRenderingHints(desktopFontHints);
    }
    int startL = line.getStartOffset();
    int endL = line.getEndOffset();
    if (startL != start) {
        // we are drawing a broken line
        try {
            lexer.setRange(startL, endL);
            while (startL < start) {
                tok = lexer.yylex();
                startL = lexer.start + lexer.yychar() + lexer.yylength();
            }
            isBroken = true;
        } catch (IOException e) {
        }
    }
    if (!isBroken) {
        lexer.setRange(start, endL);
    }
    while (start < p1) {
        try {
            if (!isBroken) {
                tok = lexer.yylex();
            } else {
                isBroken = false;
            }
        } catch (IOException e) {
        }
        start = lexer.start + lexer.yychar();
        int end = Math.min(p1, start + lexer.yylength());
        if (end != mark) {
            if (tok != prevTok) {
                g.setColor(context.tokenColors[tok]);
                g.setFont(context.tokenFonts[tok]);
                prevTok = tok;
            }
            doc.getText(mark, end - mark, text);
            int w;
            if ((context.tokenAttrib[tok] & 1) != 0) {
                w = Utilities.getTabbedTextWidth(text, g.getFontMetrics(), x, this, mark);
                g.drawLine(x, y + 1, x + w, y + 1);
            }
            if ((context.tokenAttrib[tok] & 2) != 0) {
                w = Utilities.getTabbedTextWidth(text, g.getFontMetrics(), x, this, mark);
                g.drawLine(x, y - whiteHeight, x + w, y - whiteHeight);
            }
            switch(tok) {
                case ScilabLexerConstants.WHITE:
                    if (isWhiteViewable) {
                        w = Utilities.getTabbedTextWidth(text, g.getFontMetrics(), x, this, mark);
                        g.drawLine(x + (w - 1) / 2, y - whiteHeight, x + (w + 1) / 2, y - whiteHeight);
                    }
                    break;
                case ScilabLexerConstants.TAB:
                    if (isTabViewable) {
                        paintTab(text, x, y, g, mark);
                    }
                    break;
                case ScilabLexerConstants.LATEX:
                    if (isLaTeXViewable) {
                    // LaTeXUtilities.drawText(text, x, y, g, mark);
                    }
                    break;
                default:
                    break;
            }
            x = Utilities.drawTabbedText(text, x, y, g, this, mark);
            mark = end;
        }
        start = end;
    }
    return x;
}
#end_block

#method_before
public static void xpad(String filePath, int lineNumber) {
    Xpad editorInstance = launchXpad();
    File f = new File(filePath);
    ConfigXpadManager.saveToRecentOpenedFiles(filePath);
    editorInstance.updateRecentOpenedFilesMenu();
    editorInstance.readFileAndWait(f);
    // editorInstance.getXln().highlightLine(lineNumber);
    editorInstance.lastKnownSavedState = System.currentTimeMillis();
}
#method_after
public static void xpad(String filePath, int lineNumber) {
    Xpad editorInstance = launchXpad();
    File f = new File(filePath);
    ConfigXpadManager.saveToRecentOpenedFiles(filePath);
    editorInstance.updateRecentOpenedFilesMenu();
    editorInstance.readFileAndWait(f);
    editorInstance.lastKnownSavedState = System.currentTimeMillis();
}
#end_block

#method_before
public ScilabEditorPane getTextPane(int index) {
    try {
        return (ScilabEditorPane) ((JScrollPane) tabPane.getComponentAt(index)).getViewport().getComponent(0);
    } catch (NullPointerException e) {
        System.err.println("Could not retrieve the text tab at index " + index + ".\n" + e);
        return null;
    } catch (ArrayIndexOutOfBoundsException e) {
        // System.err.println("no tab (yet?)."+e);
        return null;
    }
}
#method_after
public ScilabEditorPane getTextPane(int index) {
    try {
        return (ScilabEditorPane) ((JScrollPane) tabPane.getComponentAt(index)).getViewport().getComponent(0);
    } catch (NullPointerException e) {
        System.err.println("Could not retrieve the text tab at index " + index + ".\n" + e);
        return null;
    } catch (ArrayIndexOutOfBoundsException e) {
        // can happen between Xpad construction and first call to addTab()
        return null;
    }
}
#end_block

#method_before
/**
 * Open variable Browser with informations given columnsNames
 * @param columnNames titles of the JTable
 */
public static void openVariableBrowser(String[] columnNames) {
    VariableBrowser browsevar = ScilabVariableBrowser.getVariableBrowser(columnNames);
    browsevar.setVisible(true);
}
#method_after
/**
 * Open variable Browser with information given columnsNames
 * @param columnNames titles of the JTable
 */
public static void openVariableBrowser(String[] columnNames) {
    VariableBrowser browsevar = ScilabVariableBrowser.getVariableBrowser(columnNames);
    browsevar.setVisible(true);
}
#end_block

#method_before
public Boolean getAuto() {
    return new Boolean(auto);
}
#method_after
public Boolean getAuto() {
    return auto;
}
#end_block

#method_before
public void setAuto(Boolean auto) {
    this.auto = auto.booleanValue();
}
#method_after
public void setAuto(Boolean auto) {
    this.auto = auto;
}
#end_block

#method_before
public Double[] getLocations() {
    Double[] retLocations = new Double[locations.length];
    for (int i = 0; i < locations.length; i++) {
        retLocations[i] = new Double(locations[i]);
    }
    return retLocations;
}
#method_after
public Double[] getLocations() {
    Double[] retLocations = new Double[locations.length];
    for (int i = 0; i < locations.length; i++) {
        retLocations[i] = locations[i];
    }
    return retLocations;
}
#end_block

#method_before
public void setLocations(Double[] locations) {
    for (int i = 0; i < locations.length; i++) {
        this.locations[i] = locations[i].doubleValue();
    }
}
#method_after
public void setLocations(Double[] locations) {
    for (int i = 0; i < locations.length; i++) {
        this.locations[i] = locations[i];
    }
}
#end_block

#method_before
public Integer getSubticks() {
    return new Integer(subticks);
}
#method_after
public Integer getSubticks() {
    return subticks;
}
#end_block

#method_before
public void setSubticks(Integer subticks) {
    this.subticks = subticks.intValue();
}
#method_after
public void setSubticks(Integer subticks) {
    this.subticks = subticks;
}
#end_block

#method_before
public Object getProperty(UID id, String property) {
    // LOG("getProperty id = " + id + " property = " + property);
    GraphicObject object = allObjects.get(id);
    return object.getProperty(property);
}
#method_after
public Object getProperty(UID id, String property) {
    GraphicObject object = allObjects.get(id);
    return object.getProperty(property);
}
#end_block

#method_before
public void setProperty(UID id, String property, Object value) {
    // LOG("setProperty id = " + id + " property = " + property + " value = " + value);
    GraphicObject object = allObjects.get(id);
    object.setProperty(property, value);
}
#method_after
public void setProperty(UID id, String property, Object value) {
    GraphicObject object = allObjects.get(id);
    object.setProperty(property, value);
}
#end_block

#method_before
public UID createObject(UID id, GraphicObject.Type type) {
    GraphicObject object = createTypedObject(type);
    allObjects.put(id, object);
    return id;
}
#method_after
public UID createObject(UID id, GraphicObject.Type type) {
    GraphicObject object = createTypedObject(type);
    if (object != null) {
        allObjects.put(id, object);
        object.setIdentifier(id);
        return id;
    } else {
        return null;
    }
}
#end_block

#method_before
private GraphicObject createTypedObject(Type type) {
    GraphicObject createdObject;
    switch(type) {
        case ARC:
            System.out.format("ARC created\n");
            createdObject = new Arc();
            break;
        case AXES:
            System.out.format("AXES created\n");
            createdObject = new Axes();
            break;
        case AXIS:
            System.out.format("AXIS created\n");
            createdObject = new Axis();
            break;
        case CHAMP:
            System.out.format("CHAMP created\n");
            createdObject = new Champ();
            break;
        case COMPOUND:
            System.out.format("COMPOUND created\n");
            createdObject = new Compound();
            break;
        case FAC3D:
            System.out.format("FAC3D created\n");
            createdObject = new Fac3d();
            break;
        case FEC:
            System.out.format("FEC created\n");
            createdObject = new Fec();
            break;
        case FIGURE:
            System.out.format("FIGURE created\n");
            createdObject = new Figure();
            break;
        case GRAYPLOT:
            System.out.format("GRAYPLOT created\n");
            createdObject = new Grayplot();
            break;
        case LABEL:
            System.out.format("LABEL created\n");
            createdObject = new Label();
            break;
        case LEGEND:
            System.out.format("LEGEND created\n");
            createdObject = new Legend();
            break;
        case MATPLOT:
            System.out.format("MATPLOT created\n");
            createdObject = new Matplot();
            break;
        case PLOT3D:
            System.out.format("PLOT3D created\n");
            createdObject = new Plot3d();
            break;
        case POLYLINE:
            System.out.format("POLYLINE created\n");
            createdObject = new Polyline();
            break;
        case RECTANGLE:
            System.out.format("RECTANGLE created\n");
            createdObject = new Rectangle();
            break;
        case SEGS:
            System.out.format("SEGS created\n");
            createdObject = new Segs();
            break;
        case TEXT:
            System.out.format("TEXT created\n");
            createdObject = new Text();
            break;
        case UNKNOWNOBJECT:
            System.err.format("No object created\n");
            createdObject = null;
            break;
        default:
            System.err.format("No object created\n");
            createdObject = null;
            break;
    }
    return createdObject;
}
#method_after
private GraphicObject createTypedObject(Type type) {
    switch(type) {
        case ARC:
            return new Arc();
        case AXES:
            return new Axes();
        case AXIS:
            return new Axis();
        case CHAMP:
            return new Champ();
        case COMPOUND:
            return new Compound();
        case FAC3D:
            return new Fac3d();
        case FEC:
            return new Fec();
        case FIGURE:
            return new Figure();
        case GRAYPLOT:
            return new Grayplot();
        case LABEL:
            return new Label();
        case LEGEND:
            return new Legend();
        case MATPLOT:
            return new Matplot();
        case PLOT3D:
            return new Plot3d();
        case POLYLINE:
            return new Polyline();
        case RECTANGLE:
            return new Rectangle();
        case SEGS:
            return new Segs();
        case TEXT:
            return new Text();
        case UNKNOWNOBJECT:
            return null;
        default:
            return null;
    }
}
#end_block

#method_before
public void deleteObject(UID id) {
    allObjects.remove(id);
    System.err.format("# remaining objects: %d\n", allObjects.size());
}
#method_after
public void deleteObject(UID id) {
    allObjects.remove(id);
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("ZBounds")) {
        returnedProp = FecProperty.ZBOUNDS;
    } else if (propertyName.equals("OutsideColor")) {
        returnedProp = FecProperty.OUTSIDECOLOR;
    } else if (propertyName.equals("ColorRange")) {
        returnedProp = FecProperty.COLORRANGE;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("ZBounds")) {
        return FecProperty.ZBOUNDS;
    } else if (propertyName.equals("OutsideColor")) {
        return FecProperty.OUTSIDECOLOR;
    } else if (propertyName.equals("ColorRange")) {
        return FecProperty.COLORRANGE;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp;
    if (property == FecProperty.ZBOUNDS) {
        returnedProp = getZBounds();
    } else if (property == FecProperty.OUTSIDECOLOR) {
        returnedProp = getOutsideColor();
    } else if (property == FecProperty.COLORRANGE) {
        returnedProp = getColorRange();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == FecProperty.ZBOUNDS) {
        return getZBounds();
    } else if (property == FecProperty.OUTSIDECOLOR) {
        return getOutsideColor();
    } else if (property == FecProperty.COLORRANGE) {
        return getColorRange();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Integer[] getColorRange() {
    Integer[] retColorRange = new Integer[2];
    retColorRange[0] = new Integer(colorRange[0]);
    retColorRange[1] = new Integer(colorRange[1]);
    return retColorRange;
}
#method_after
public Integer[] getColorRange() {
    Integer[] retColorRange = new Integer[2];
    retColorRange[0] = colorRange[0];
    retColorRange[1] = colorRange[1];
    return retColorRange;
}
#end_block

#method_before
public void setColorRange(Integer[] colorRange) {
    this.colorRange[0] = colorRange[0].intValue();
    this.colorRange[1] = colorRange[1].intValue();
}
#method_after
public void setColorRange(Integer[] colorRange) {
    this.colorRange[0] = colorRange[0];
    this.colorRange[1] = colorRange[1];
}
#end_block

#method_before
public Integer[] getOutsideColor() {
    Integer[] retOutsideColor = new Integer[2];
    retOutsideColor[0] = new Integer(outsideColor[0]);
    retOutsideColor[1] = new Integer(outsideColor[1]);
    return retOutsideColor;
}
#method_after
public Integer[] getOutsideColor() {
    Integer[] retOutsideColor = new Integer[2];
    retOutsideColor[0] = outsideColor[0];
    retOutsideColor[1] = outsideColor[1];
    return retOutsideColor;
}
#end_block

#method_before
public void setOutsideColor(Integer[] outsideColor) {
    this.outsideColor[0] = outsideColor[0].intValue();
    this.outsideColor[1] = outsideColor[1].intValue();
}
#method_after
public void setOutsideColor(Integer[] outsideColor) {
    this.outsideColor[0] = outsideColor[0];
    this.outsideColor[1] = outsideColor[1];
}
#end_block

#method_before
public Double[] getZBounds() {
    Double[] retZBounds = new Double[2];
    retZBounds[0] = new Double(zBounds[0]);
    retZBounds[1] = new Double(zBounds[1]);
    return retZBounds;
}
#method_after
public Double[] getZBounds() {
    Double[] retZBounds = new Double[2];
    retZBounds[0] = zBounds[0];
    retZBounds[1] = zBounds[1];
    return retZBounds;
}
#end_block

#method_before
public void setZBounds(Double[] zBounds) {
    zBounds[0] = zBounds[0].doubleValue();
    zBounds[1] = zBounds[1].doubleValue();
}
#method_after
public void setZBounds(Double[] zBounds) {
    this.zBounds[0] = zBounds[0];
    this.zBounds[1] = zBounds[1];
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("ClipProperty")) {
        returnedProp = GraphicClippableObjectProperty.CLIPPROPERTY;
    } else if (propertyName.equals("ClipState")) {
        returnedProp = ClippablePropertyType.CLIPSTATE;
    } else if (propertyName.equals("ClipBox")) {
        returnedProp = ClippablePropertyType.CLIPBOX;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("ClipProperty")) {
        return GraphicClippableObjectProperty.CLIPPROPERTY;
    } else if (propertyName.equals("ClipState")) {
        return ClippablePropertyType.CLIPSTATE;
    } else if (propertyName.equals("ClipBox")) {
        return ClippablePropertyType.CLIPBOX;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp;
    if (property == GraphicClippableObjectProperty.CLIPPROPERTY) {
        returnedProp = getClipProperty();
    } else if (property == ClippableProperty.ClippablePropertyType.CLIPSTATE) {
        returnedProp = getClipState();
    } else if (property == ClippableProperty.ClippablePropertyType.CLIPBOX) {
        returnedProp = getClipBox();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == GraphicClippableObjectProperty.CLIPPROPERTY) {
        return getClipProperty();
    } else if (property == ClippableProperty.ClippablePropertyType.CLIPSTATE) {
        return getClipState();
    } else if (property == ClippableProperty.ClippablePropertyType.CLIPBOX) {
        return getClipBox();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Double[] getClipBox() {
    double[] cbox = clipProperty.getClipBox();
    Double[] clipBox = new Double[cbox.length];
    for (int i = 0; i < clipBox.length; i++) {
        clipBox[i] = new Double(cbox[i]);
    }
    return clipBox;
}
#method_after
public Double[] getClipBox() {
    return clipProperty.getClipBox();
}
#end_block

#method_before
public void setClipBox(Double[] clipBox) {
    double[] cBox = new double[clipBox.length];
    for (int i = 0; i < clipBox.length; i++) {
        cBox[i] = clipBox[i].doubleValue();
    }
    clipProperty.setClipBox(cBox);
}
#method_after
public void setClipBox(Double[] clipBox) {
    clipProperty.setClipBox(clipBox);
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("Links")) {
        returnedProp = LegendProperty.LINKS;
    } else if (propertyName.equals("LegendLocation")) {
        returnedProp = LegendProperty.LEGENDLOCATION;
    } else if (propertyName.equals("Position")) {
        returnedProp = LegendProperty.POSITION;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("Links")) {
        return LegendProperty.LINKS;
    } else if (propertyName.equals("LegendLocation")) {
        return LegendProperty.LEGENDLOCATION;
    } else if (propertyName.equals("Position")) {
        return LegendProperty.POSITION;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp;
    if (property == LegendProperty.LINKS) {
        returnedProp = getLinks();
    } else if (property == LegendProperty.LEGENDLOCATION) {
        returnedProp = getLegendLocation();
    } else if (property == LegendProperty.POSITION) {
        returnedProp = getPosition();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == LegendProperty.LINKS) {
        return getLinks();
    } else if (property == LegendProperty.LEGENDLOCATION) {
        return getLegendLocation();
    } else if (property == LegendProperty.POSITION) {
        return getPosition();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Double[] getPosition() {
    Double[] retPosition = new Double[2];
    retPosition[0] = new Double(position[0]);
    retPosition[1] = new Double(position[1]);
    return retPosition;
}
#method_after
public Double[] getPosition() {
    Double[] retPosition = new Double[2];
    retPosition[0] = position[0];
    retPosition[1] = position[1];
    return retPosition;
}
#end_block

#method_before
public void setPosition(Double[] position) {
    this.position[0] = position[0].doubleValue();
    this.position[1] = position[1].doubleValue();
}
#method_after
public void setPosition(Double[] position) {
    this.position[0] = position[0];
    this.position[1] = position[1];
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("ClipProperty")) {
        returnedProp = ClippableTextObjectProperty.CLIPPROPERTY;
    } else if (propertyName.equals("ClipState")) {
        returnedProp = ClippableProperty.ClippablePropertyType.CLIPSTATE;
    } else if (propertyName.equals("ClipBox")) {
        returnedProp = ClippableProperty.ClippablePropertyType.CLIPBOX;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("ClipProperty")) {
        return ClippableTextObjectProperty.CLIPPROPERTY;
    } else if (propertyName.equals("ClipState")) {
        return ClippableProperty.ClippablePropertyType.CLIPSTATE;
    } else if (propertyName.equals("ClipBox")) {
        return ClippableProperty.ClippablePropertyType.CLIPBOX;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp;
    if (property == ClippableTextObjectProperty.CLIPPROPERTY) {
        returnedProp = getClipProperty();
    } else if (property == ClippableProperty.ClippablePropertyType.CLIPSTATE) {
        returnedProp = getClipState();
    } else if (property == ClippableProperty.ClippablePropertyType.CLIPBOX) {
        returnedProp = getClipBox();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == ClippableTextObjectProperty.CLIPPROPERTY) {
        return getClipProperty();
    } else if (property == ClippableProperty.ClippablePropertyType.CLIPSTATE) {
        return getClipState();
    } else if (property == ClippableProperty.ClippablePropertyType.CLIPBOX) {
        return getClipBox();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Double[] getClipBox() {
    double[] cbox = clipProperty.getClipBox();
    Double[] clipBox = new Double[cbox.length];
    for (int i = 0; i < clipBox.length; i++) {
        clipBox[i] = new Double(cbox[i]);
    }
    return clipBox;
}
#method_after
public Double[] getClipBox() {
    return clipProperty.getClipBox();
}
#end_block

#method_before
public void setClipBox(Double[] clipBox) {
    double[] cBox = new double[clipBox.length];
    for (int i = 0; i < clipBox.length; i++) {
        cBox[i] = clipBox[i].doubleValue();
    }
    clipProperty.setClipBox(cBox);
}
#method_after
public void setClipBox(Double[] clipBox) {
    clipProperty.setClipBox(clipBox);
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("Parent")) {
        returnedProp = GraphicObjectPropertyType.PARENT;
    } else if (propertyName.equals("Children")) {
        returnedProp = GraphicObjectPropertyType.CHILDREN;
    } else if (propertyName.equals("Visible")) {
        returnedProp = GraphicObjectPropertyType.VISIBLE;
    } else if (propertyName.equals("UserData")) {
        returnedProp = GraphicObjectPropertyType.USERDATA;
    } else {
        returnedProp = GraphicObjectPropertyType.UNKNOWNPROP;
    }
    return returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("Parent")) {
        return GraphicObjectPropertyType.PARENT;
    } else if (propertyName.equals("Children")) {
        return GraphicObjectPropertyType.CHILDREN;
    } else if (propertyName.equals("Visible")) {
        return GraphicObjectPropertyType.VISIBLE;
    } else if (propertyName.equals("UserData")) {
        return GraphicObjectPropertyType.USERDATA;
    } else {
        return GraphicObjectPropertyType.UNKNOWNPROPERTY;
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp = null;
    if (property == GraphicObjectPropertyType.PARENT) {
        returnedProp = getParent();
    } else if (property == GraphicObjectPropertyType.CHILDREN) {
        returnedProp = getChildren();
    } else if (property == GraphicObjectPropertyType.VISIBLE) {
        returnedProp = getVisible();
    } else if (property == GraphicObjectPropertyType.USERDATA) {
        returnedProp = getUserData();
    } else if (property == GraphicObjectPropertyType.UNKNOWNPROP) {
        returnedProp = null;
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == GraphicObjectPropertyType.PARENT) {
        return getParent();
    } else if (property == GraphicObjectPropertyType.CHILDREN) {
        return getChildren();
    } else if (property == GraphicObjectPropertyType.VISIBLE) {
        return getVisible();
    } else if (property == GraphicObjectPropertyType.USERDATA) {
        return getUserData();
    } else if (property == GraphicObjectPropertyType.UNKNOWNPROPERTY) {
        return null;
    } else {
        return null;
    }
}
#end_block

#method_before
public void setPropertyFast(Object property, Object value) {
    if (property == GraphicObjectPropertyType.PARENT) {
        setParent((GraphicObject) value);
    } else if (property == GraphicObjectPropertyType.CHILDREN) {
        setChildren((ArrayList<GraphicObject>) value);
    } else if (property == GraphicObjectPropertyType.VISIBLE) {
        setVisible((Boolean) value);
    } else if (property == GraphicObjectPropertyType.USERDATA) {
        setUserData((byte[]) value);
    } else {
        System.err.format("GraphicObject setPropertyFast: Unknown property\n");
    }
}
#method_after
public void setPropertyFast(Object property, Object value) {
    if (property == GraphicObjectPropertyType.PARENT) {
        setParent((GraphicObject) value);
    } else if (property == GraphicObjectPropertyType.CHILDREN) {
        setChildren((ArrayList<GraphicObject>) value);
    } else if (property == GraphicObjectPropertyType.VISIBLE) {
        setVisible((Boolean) value);
    } else if (property == GraphicObjectPropertyType.USERDATA) {
        setUserData((byte[]) value);
    }
}
#end_block

#method_before
public void setProperty(String property, Object value) {
    try {
        // System.out.format("before calling getMethod: %s\n", property);
        Method setter = this.getClass().getMethod("set" + property, value.getClass());
        // System.out.format("before setter.invoke: %s\n", setter.toString());
        setter.invoke(this, value);
    } catch (Exception e) {
        System.err.println("Got Exception " + e.getMessage());
        e.printStackTrace();
    }
}
#method_after
public void setProperty(String property, Object value) {
    try {
        Method setter = this.getClass().getMethod("set" + property, value.getClass());
        setter.invoke(this, value);
    } catch (Exception e) {
        System.err.println("Got Exception " + e.getMessage());
        e.printStackTrace();
    }
}
#end_block

#method_before
public Object getProperty(String property) {
    try {
        // System.out.format("before calling getMethod: %s\n", property);
        Method getter = this.getClass().getMethod("get" + property, (Class[]) null);
        // System.out.format("before getter.invoke: %s\n", property);
        return getter.invoke(this, (Object[]) null);
    } catch (Exception e) {
        System.err.println("Got Exception " + e.getMessage());
    }
    // TODO Auto-generated method stub
    return null;
}
#method_after
public Object getProperty(String property) {
    try {
        Method getter = this.getClass().getMethod("get" + property, (Class[]) null);
        return getter.invoke(this, (Object[]) null);
    } catch (Exception e) {
        System.err.println("Got Exception " + e.getMessage());
    }
    // TODO Auto-generated method stub
    return null;
}
#end_block

#method_before
public Boolean getVisible() {
    return new Boolean(visible);
}
#method_after
public Boolean getVisible() {
    return visible;
}
#end_block

#method_before
public void setVisible(Boolean visible) {
    this.visible = visible.booleanValue();
}
#method_after
public void setVisible(Boolean visible) {
    this.visible = visible;
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp = null;
    if (propertyName.equals("Visible")) {
        returnedProp = AxisPropertyProperty.VISIBLE;
    } else if (propertyName.equals("Reverse")) {
        returnedProp = AxisPropertyProperty.REVERSE;
    } else if (propertyName.equals("GridColor")) {
        returnedProp = AxisPropertyProperty.GRIDCOLOR;
    } else if (propertyName.equals("Label")) {
        returnedProp = AxisPropertyProperty.LABEL;
    } else if (propertyName.equals("AxisLocation")) {
        returnedProp = AxisPropertyProperty.AXISLOCATION;
    } else if (propertyName.equals("Ticks")) {
        returnedProp = AxisPropertyProperty.TICKS;
    } else if (propertyName.equals("LogFlag")) {
        returnedProp = AxisPropertyProperty.LOGFLAG;
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("Visible")) {
        return AxisPropertyProperty.VISIBLE;
    } else if (propertyName.equals("Reverse")) {
        return AxisPropertyProperty.REVERSE;
    } else if (propertyName.equals("GridColor")) {
        return AxisPropertyProperty.GRIDCOLOR;
    } else if (propertyName.equals("Label")) {
        return AxisPropertyProperty.LABEL;
    } else if (propertyName.equals("AxisLocation")) {
        return AxisPropertyProperty.AXISLOCATION;
    } else if (propertyName.equals("LogFlag")) {
        return AxisPropertyProperty.LOGFLAG;
    } else if (propertyName.equals("Ticks")) {
        return AxisPropertyProperty.TICKS;
    } else {
        return AxisPropertyProperty.UNKNOWNPROPERTY;
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp = null;
    if (property == AxisPropertyProperty.VISIBLE) {
        returnedProp = getVisible();
    } else if (property == AxisPropertyProperty.REVERSE) {
        returnedProp = getReverse();
    } else if (property == AxisPropertyProperty.GRIDCOLOR) {
        returnedProp = getGridColor();
    } else if (property == AxisPropertyProperty.LABEL) {
        returnedProp = getLabel();
    } else if (property == AxisPropertyProperty.AXISLOCATION) {
        returnedProp = getAxisLocation();
    } else if (property == AxisPropertyProperty.TICKS) {
        returnedProp = getTicks();
    } else if (property == AxisPropertyProperty.LOGFLAG) {
        returnedProp = getLogFlag();
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == AxisPropertyProperty.VISIBLE) {
        return getVisible();
    } else if (property == AxisPropertyProperty.REVERSE) {
        return getReverse();
    } else if (property == AxisPropertyProperty.GRIDCOLOR) {
        return getGridColor();
    } else if (property == AxisPropertyProperty.LABEL) {
        return getLabel();
    } else if (property == AxisPropertyProperty.AXISLOCATION) {
        return getAxisLocation();
    } else if (property == AxisPropertyProperty.LOGFLAG) {
        return getLogFlag();
    } else if (property == AxisPropertyProperty.TICKS) {
        return getTicks();
    } else {
        return null;
    }
}
#end_block

#method_before
public void setPropertyFast(Object property, Object value) {
    if (property == AxisPropertyProperty.VISIBLE) {
        setVisible((Boolean) value);
    } else if (property == AxisPropertyProperty.REVERSE) {
        setReverse((Boolean) reverse);
    } else if (property == AxisPropertyProperty.GRIDCOLOR) {
        setGridColor((Integer) value);
    } else if (property == AxisPropertyProperty.LABEL) {
        setLabel((Label) value);
    } else if (property == AxisPropertyProperty.AXISLOCATION) {
        setAxisLocation((AxisLocation) value);
    } else if (property == AxisPropertyProperty.TICKS) {
        setTicks((TicksProperty) value);
    } else if (property == AxisPropertyProperty.LOGFLAG) {
        setLogFlag((Boolean) value);
    }
}
#method_after
public void setPropertyFast(Object property, Object value) {
    if (property == AxisPropertyProperty.VISIBLE) {
        setVisible((Boolean) value);
    } else if (property == AxisPropertyProperty.REVERSE) {
        setReverse((Boolean) value);
    } else if (property == AxisPropertyProperty.GRIDCOLOR) {
        setGridColor((Integer) value);
    } else if (property == AxisPropertyProperty.LABEL) {
        setLabel((Label) value);
    } else if (property == AxisPropertyProperty.AXISLOCATION) {
        setAxisLocation((AxisLocation) value);
    } else if (property == AxisPropertyProperty.LOGFLAG) {
        setLogFlag((Boolean) value);
    } else if (property == AxisPropertyProperty.TICKS) {
        setTicks((TicksProperty) value);
    }
}
#end_block

#method_before
public int getGridColor() {
    return gridColor;
}
#method_after
public Integer getGridColor() {
    return gridColor;
}
#end_block

#method_before
public void setGridColor(int gridColor) {
    this.gridColor = gridColor;
}
#method_after
public void setGridColor(Integer gridColor) {
    this.gridColor = gridColor;
}
#end_block

#method_before
public Boolean getLogFlag() {
    return new Boolean(logFlag);
}
#method_after
public Boolean getLogFlag() {
    return logFlag;
}
#end_block

#method_before
public void setLogFlag(Boolean logFlag) {
    this.logFlag = logFlag.booleanValue();
}
#method_after
public void setLogFlag(Boolean logFlag) {
    this.logFlag = logFlag;
}
#end_block

#method_before
public Boolean getReverse() {
    return new Boolean(reverse);
}
#method_after
public Boolean getReverse() {
    return reverse;
}
#end_block

#method_before
public void setReverse(Boolean reverse) {
    this.reverse = reverse.booleanValue();
}
#method_after
public void setReverse(Boolean reverse) {
    this.reverse = reverse;
}
#end_block

#method_before
public Boolean getVisible() {
    return new Boolean(visible);
}
#method_after
public Boolean getVisible() {
    return visible;
}
#end_block

#method_before
public void setVisible(Boolean visible) {
    this.visible = visible.booleanValue();
}
#method_after
public void setVisible(Boolean visible) {
    this.visible = visible;
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("Arrows")) {
        returnedProp = VectFieldProperty.ARROWS;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("Arrows")) {
        return VectFieldProperty.ARROWS;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp;
    if (property == VectFieldProperty.ARROWS) {
        returnedProp = this.getArrows();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == VectFieldProperty.ARROWS) {
        return getArrows();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("ClipProperty")) {
        returnedProp = ClippableContouredObjectPropertyType.CLIPPROPERTY;
    } else if (propertyName.equals("ClipState")) {
        returnedProp = ClippablePropertyType.CLIPSTATE;
    } else if (propertyName.equals("ClipBox")) {
        returnedProp = ClippablePropertyType.CLIPBOX;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("ClipProperty")) {
        return ClippableContouredObjectPropertyType.CLIPPROPERTY;
    } else if (propertyName.equals("ClipState")) {
        return ClippablePropertyType.CLIPSTATE;
    } else if (propertyName.equals("ClipBox")) {
        return ClippablePropertyType.CLIPBOX;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp = null;
    if (property == ClippableContouredObjectPropertyType.CLIPPROPERTY) {
        returnedProp = getClipProperty();
    } else if (property == ClippablePropertyType.CLIPSTATE) {
        returnedProp = getClipState();
    } else if (property == ClippablePropertyType.CLIPBOX) {
        returnedProp = getClipBox();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == ClippableContouredObjectPropertyType.CLIPPROPERTY) {
        return getClipProperty();
    } else if (property == ClippablePropertyType.CLIPSTATE) {
        return getClipState();
    } else if (property == ClippablePropertyType.CLIPBOX) {
        return getClipBox();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Double[] getClipBox() {
    double[] cbox = clipProperty.getClipBox();
    Double[] clipBox = new Double[cbox.length];
    for (int i = 0; i < clipBox.length; i++) {
        clipBox[i] = new Double(cbox[i]);
    }
    return clipBox;
}
#method_after
public Double[] getClipBox() {
    return clipProperty.getClipBox();
}
#end_block

#method_before
public void setClipBox(Double[] clipBox) {
    double[] cBox = new double[clipBox.length];
    for (int i = 0; i < clipBox.length; i++) {
        cBox[i] = clipBox[i].doubleValue();
    }
    clipProperty.setClipBox(cBox);
}
#method_after
public void setClipBox(Double[] clipBox) {
    clipProperty.setClipBox(clipBox);
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("SurfaceMode")) {
        returnedProp = SurfaceProperty.SURFACEMODE;
    } else if (propertyName.equals("ColorMode")) {
        returnedProp = SurfaceProperty.COLORMODE;
    } else if (propertyName.equals("ColorFlag")) {
        returnedProp = SurfaceProperty.COLORFLAG;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("SurfaceMode")) {
        return SurfaceProperty.SURFACEMODE;
    } else if (propertyName.equals("ColorMode")) {
        return SurfaceProperty.COLORMODE;
    } else if (propertyName.equals("ColorFlag")) {
        return SurfaceProperty.COLORFLAG;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp;
    if (property == SurfaceProperty.SURFACEMODE) {
        returnedProp = getSurfaceMode();
    } else if (property == SurfaceProperty.COLORMODE) {
        returnedProp = getColorMode();
    } else if (property == SurfaceProperty.COLORFLAG) {
        returnedProp = getColorFlag();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == SurfaceProperty.SURFACEMODE) {
        return getSurfaceMode();
    } else if (property == SurfaceProperty.COLORMODE) {
        return getColorMode();
    } else if (property == SurfaceProperty.COLORFLAG) {
        return getColorFlag();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Integer getColorFlag() {
    return new Integer(colorFlag);
}
#method_after
public Integer getColorFlag() {
    return colorFlag;
}
#end_block

#method_before
public void setColorFlag(Integer colorFlag) {
    this.colorFlag = colorFlag.intValue();
}
#method_after
public void setColorFlag(Integer colorFlag) {
    this.colorFlag = colorFlag;
}
#end_block

#method_before
public Integer getColorMode() {
    return new Integer(colorMode);
}
#method_after
public Integer getColorMode() {
    return colorMode;
}
#end_block

#method_before
public void setColorMode(Integer colorMode) {
    this.colorMode = colorMode.intValue();
}
#method_after
public void setColorMode(Integer colorMode) {
    this.colorMode = colorMode;
}
#end_block

#method_before
public Boolean getSurfaceMode() {
    return new Boolean(surfaceMode);
}
#method_after
public Boolean getSurfaceMode() {
    return surfaceMode;
}
#end_block

#method_before
public void setSurfaceMode(Boolean surfaceMode) {
    this.surfaceMode = surfaceMode.booleanValue();
}
#method_after
public void setSurfaceMode(Boolean surfaceMode) {
    this.surfaceMode = surfaceMode;
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp = null;
    if (propertyName.equals("Style")) {
        returnedProp = FontProperty.STYLE;
    } else if (propertyName.equals("Size")) {
        returnedProp = FontProperty.SIZE;
    } else if (propertyName.equals("Color")) {
        returnedProp = FontProperty.COLOR;
    } else if (propertyName.equals("Fractional")) {
        returnedProp = FontProperty.FRACTIONAL;
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("Style")) {
        return FontProperty.STYLE;
    } else if (propertyName.equals("Size")) {
        return FontProperty.SIZE;
    } else if (propertyName.equals("Color")) {
        return FontProperty.COLOR;
    } else if (propertyName.equals("Fractional")) {
        return FontProperty.FRACTIONAL;
    } else {
        return FontProperty.UNKNOWNPROPERTY;
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp = null;
    if (property == FontProperty.STYLE) {
        returnedProp = getStyle();
    } else if (property == FontProperty.SIZE) {
        returnedProp = getSize();
    } else if (property == FontProperty.COLOR) {
        returnedProp = getColor();
    } else if (property == FontProperty.FRACTIONAL) {
        returnedProp = getFractional();
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == FontProperty.STYLE) {
        return getStyle();
    } else if (property == FontProperty.SIZE) {
        return getSize();
    } else if (property == FontProperty.COLOR) {
        return getColor();
    } else if (property == FontProperty.FRACTIONAL) {
        return getFractional();
    } else {
        return null;
    }
}
#end_block

#method_before
public Integer getColor() {
    return new Integer(color);
}
#method_after
public Integer getColor() {
    return color;
}
#end_block

#method_before
public void setColor(Integer color) {
    this.color = color.intValue();
}
#method_after
public void setColor(Integer color) {
    this.color = color;
}
#end_block

#method_before
public Boolean getFractional() {
    return new Boolean(fractional);
}
#method_after
public Boolean getFractional() {
    return fractional;
}
#end_block

#method_before
public void setFractional(Boolean fractional) {
    this.fractional = fractional.booleanValue();
}
#method_after
public void setFractional(Boolean fractional) {
    this.fractional = fractional;
}
#end_block

#method_before
public Double getSize() {
    return new Double(size);
}
#method_after
public Double getSize() {
    return size;
}
#end_block

#method_before
public void setSize(Double size) {
    this.size = size.doubleValue();
}
#method_after
public void setSize(Double size) {
    this.size = size;
}
#end_block

#method_before
public Integer getStyle() {
    return new Integer(style);
}
#method_after
public Integer getStyle() {
    return style;
}
#end_block

#method_before
public void setStyle(Integer style) {
    this.style = style.intValue();
}
#method_after
public void setStyle(Integer style) {
    this.style = style;
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("UpperLeftPoint")) {
        returnedProp = ArcProperty.UPPERLEFTPOINT;
    } else if (propertyName.equals("Width")) {
        returnedProp = ArcProperty.WIDTH;
    } else if (propertyName.equals("Height")) {
        returnedProp = ArcProperty.HEIGHT;
    } else if (propertyName.equals("StartAngle")) {
        returnedProp = ArcProperty.STARTANGLE;
    } else if (propertyName.equals("EndAngle")) {
        returnedProp = ArcProperty.ENDANGLE;
    } else if (propertyName.equals("ArcDrawingMethod")) {
        returnedProp = ArcProperty.ARCDRAWINGMETHOD;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("UpperLeftPoint")) {
        return ArcProperty.UPPERLEFTPOINT;
    } else if (propertyName.equals("Width")) {
        return ArcProperty.WIDTH;
    } else if (propertyName.equals("Height")) {
        return ArcProperty.HEIGHT;
    } else if (propertyName.equals("StartAngle")) {
        return ArcProperty.STARTANGLE;
    } else if (propertyName.equals("EndAngle")) {
        return ArcProperty.ENDANGLE;
    } else if (propertyName.equals("ArcDrawingMethod")) {
        return ArcProperty.ARCDRAWINGMETHOD;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp = null;
    if (property == ArcProperty.UPPERLEFTPOINT) {
        returnedProp = getUpperLeftPoint();
    } else if (property == ArcProperty.WIDTH) {
        returnedProp = getWidth();
    } else if (property == ArcProperty.HEIGHT) {
        returnedProp = getHeight();
    } else if (property == ArcProperty.STARTANGLE) {
        returnedProp = getStartAngle();
    } else if (property == ArcProperty.ENDANGLE) {
        returnedProp = getEndAngle();
    } else if (property == ArcProperty.ARCDRAWINGMETHOD) {
        returnedProp = getArcDrawingMethod();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == ArcProperty.UPPERLEFTPOINT) {
        return getUpperLeftPoint();
    } else if (property == ArcProperty.WIDTH) {
        return getWidth();
    } else if (property == ArcProperty.HEIGHT) {
        return getHeight();
    } else if (property == ArcProperty.STARTANGLE) {
        return getStartAngle();
    } else if (property == ArcProperty.ENDANGLE) {
        return getEndAngle();
    } else if (property == ArcProperty.ARCDRAWINGMETHOD) {
        return getArcDrawingMethod();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Double getEndAngle() {
    return new Double(endAngle);
}
#method_after
public Double getEndAngle() {
    return endAngle;
}
#end_block

#method_before
public void setEndAngle(Double endAngle) {
    this.endAngle = endAngle.doubleValue();
}
#method_after
public void setEndAngle(Double endAngle) {
    this.endAngle = endAngle;
}
#end_block

#method_before
public Double getHeight() {
    return new Double(height);
}
#method_after
public Double getHeight() {
    return height;
}
#end_block

#method_before
public void setHeight(Double height) {
    this.height = height.doubleValue();
}
#method_after
public void setHeight(Double height) {
    this.height = height;
}
#end_block

#method_before
public Double getStartAngle() {
    return new Double(startAngle);
}
#method_after
public Double getStartAngle() {
    return startAngle;
}
#end_block

#method_before
public void setStartAngle(Double startAngle) {
    this.startAngle = startAngle.doubleValue();
}
#method_after
public void setStartAngle(Double startAngle) {
    this.startAngle = startAngle;
}
#end_block

#method_before
public Double[] getUpperLeftPoint() {
    Double[] returnedPoint = new Double[3];
    returnedPoint[0] = new Double(upperLeftPoint[0]);
    returnedPoint[1] = new Double(upperLeftPoint[1]);
    returnedPoint[2] = new Double(upperLeftPoint[2]);
    return returnedPoint;
}
#method_after
public Double[] getUpperLeftPoint() {
    Double[] returnedPoint = new Double[3];
    returnedPoint[0] = upperLeftPoint[0];
    returnedPoint[1] = upperLeftPoint[1];
    returnedPoint[2] = upperLeftPoint[2];
    return returnedPoint;
}
#end_block

#method_before
public void setUpperLeftPoint(Double[] upperLeftPoint) {
    this.upperLeftPoint[0] = upperLeftPoint[0].doubleValue();
    this.upperLeftPoint[1] = upperLeftPoint[1].doubleValue();
    this.upperLeftPoint[2] = upperLeftPoint[2].doubleValue();
}
#method_after
public void setUpperLeftPoint(Double[] upperLeftPoint) {
    this.upperLeftPoint[0] = upperLeftPoint[0];
    this.upperLeftPoint[1] = upperLeftPoint[1];
    this.upperLeftPoint[2] = upperLeftPoint[2];
}
#end_block

#method_before
public Double getWidth() {
    return new Double(width);
}
#method_after
public Double getWidth() {
    return width;
}
#end_block

#method_before
public void setWidth(Double width) {
    this.width = width.doubleValue();
}
#method_after
public void setWidth(Double width) {
    this.width = width;
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("TicksDirection")) {
        returnedProp = AxisProperty.TICKSDIRECTION;
    } else if (propertyName.equals("XTicksCoords")) {
        returnedProp = AxisProperty.XTICKSCOORDS;
    } else if (propertyName.equals("YTicksCoords")) {
        returnedProp = AxisProperty.YTICKSCOORDS;
    } else if (propertyName.equals("TicksColor")) {
        returnedProp = AxisProperty.TICKSCOLOR;
    } else if (propertyName.equals("TicksSegment")) {
        returnedProp = AxisProperty.TICKSSEGMENT;
    } else if (propertyName.equals("TicksLabels")) {
        returnedProp = AxisProperty.TICKSLABELS;
    } else if (propertyName.equals("Formatn")) {
        returnedProp = AxisProperty.FORMATN;
    } else if (propertyName.equals("Font")) {
        returnedProp = AxisProperty.FONT;
    } else if (propertyName.equals("Style")) {
        returnedProp = Font.FontProperty.STYLE;
    } else if (propertyName.equals("Size")) {
        returnedProp = Font.FontProperty.SIZE;
    } else if (propertyName.equals("Color")) {
        returnedProp = Font.FontProperty.COLOR;
    } else if (propertyName.equals("Fractional")) {
        returnedProp = Font.FontProperty.FRACTIONAL;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("TicksDirection")) {
        return AxisProperty.TICKSDIRECTION;
    } else if (propertyName.equals("XTicksCoords")) {
        return AxisProperty.XTICKSCOORDS;
    } else if (propertyName.equals("YTicksCoords")) {
        return AxisProperty.YTICKSCOORDS;
    } else if (propertyName.equals("TicksColor")) {
        return AxisProperty.TICKSCOLOR;
    } else if (propertyName.equals("TicksSegment")) {
        return AxisProperty.TICKSSEGMENT;
    } else if (propertyName.equals("TicksLabels")) {
        return AxisProperty.TICKSLABELS;
    } else if (propertyName.equals("Formatn")) {
        return AxisProperty.FORMATN;
    } else if (propertyName.equals("Font")) {
        return AxisProperty.FONT;
    } else if (propertyName.equals("Style")) {
        return Font.FontProperty.STYLE;
    } else if (propertyName.equals("Size")) {
        return Font.FontProperty.SIZE;
    } else if (propertyName.equals("Color")) {
        return Font.FontProperty.COLOR;
    } else if (propertyName.equals("Fractional")) {
        return Font.FontProperty.FRACTIONAL;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp;
    if (property == AxisProperty.TICKSDIRECTION) {
        returnedProp = getTicksDirection();
    } else if (property == AxisProperty.XTICKSCOORDS) {
        returnedProp = getXTicksCoords();
    } else if (property == AxisProperty.YTICKSCOORDS) {
        returnedProp = getYTicksCoords();
    } else if (property == AxisProperty.TICKSCOLOR) {
        returnedProp = getTicksColor();
    } else if (property == AxisProperty.TICKSSEGMENT) {
        returnedProp = getTicksSegment();
    } else if (property == AxisProperty.TICKSLABELS) {
        returnedProp = getTicksLabels();
    } else if (property == AxisProperty.FORMATN) {
        returnedProp = getFormatn();
    } else if (property == AxisProperty.FONT) {
        returnedProp = getFont();
    } else if (property == Font.FontProperty.STYLE) {
        returnedProp = getStyle();
    } else if (property == Font.FontProperty.SIZE) {
        returnedProp = getSize();
    } else if (property == Font.FontProperty.COLOR) {
        returnedProp = getColor();
    } else if (property == Font.FontProperty.FRACTIONAL) {
        returnedProp = getFractional();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == AxisProperty.TICKSDIRECTION) {
        return getTicksDirection();
    } else if (property == AxisProperty.XTICKSCOORDS) {
        return getXTicksCoords();
    } else if (property == AxisProperty.YTICKSCOORDS) {
        return getYTicksCoords();
    } else if (property == AxisProperty.TICKSCOLOR) {
        return getTicksColor();
    } else if (property == AxisProperty.TICKSSEGMENT) {
        return getTicksSegment();
    } else if (property == AxisProperty.TICKSLABELS) {
        return getTicksLabels();
    } else if (property == AxisProperty.FORMATN) {
        return getFormatn();
    } else if (property == AxisProperty.FONT) {
        return getFont();
    } else if (property == Font.FontProperty.STYLE) {
        return getStyle();
    } else if (property == Font.FontProperty.SIZE) {
        return getSize();
    } else if (property == Font.FontProperty.COLOR) {
        return getColor();
    } else if (property == Font.FontProperty.FRACTIONAL) {
        return getFractional();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Integer getTicksColor() {
    return new Integer(ticksColor);
}
#method_after
public Integer getTicksColor() {
    return ticksColor;
}
#end_block

#method_before
public void setTicksColor(Integer ticksColor) {
    this.ticksColor = ticksColor.intValue();
}
#method_after
public void setTicksColor(Integer ticksColor) {
    this.ticksColor = ticksColor;
}
#end_block

#method_before
public Boolean getTicksSegment() {
    return new Boolean(ticksSegment);
}
#method_after
public Boolean getTicksSegment() {
    return ticksSegment;
}
#end_block

#method_before
public Double[] getXTicksCoords() {
    Double[] retXTicksCoords = new Double[xTicksCoords.length];
    for (int i = 0; i < xTicksCoords.length; i++) {
        retXTicksCoords[i] = new Double(xTicksCoords[i]);
    }
    return retXTicksCoords;
}
#method_after
public Double[] getXTicksCoords() {
    Double[] retXTicksCoords = new Double[xTicksCoords.length];
    for (int i = 0; i < xTicksCoords.length; i++) {
        retXTicksCoords[i] = xTicksCoords[i];
    }
    return retXTicksCoords;
}
#end_block

#method_before
public void setXTicksCoords(Double[] ticksCoords) {
    for (int i = 0; i < xTicksCoords.length; i++) {
        xTicksCoords[i] = ticksCoords[i].doubleValue();
    }
}
#method_after
public void setXTicksCoords(Double[] ticksCoords) {
    for (int i = 0; i < xTicksCoords.length; i++) {
        xTicksCoords[i] = ticksCoords[i];
    }
}
#end_block

#method_before
public Double[] getYTicksCoords() {
    Double[] retYTicksCoords = new Double[yTicksCoords.length];
    for (int i = 0; i < yTicksCoords.length; i++) {
        retYTicksCoords[i] = new Double(yTicksCoords[i]);
    }
    return retYTicksCoords;
}
#method_after
public Double[] getYTicksCoords() {
    Double[] retYTicksCoords = new Double[yTicksCoords.length];
    for (int i = 0; i < yTicksCoords.length; i++) {
        retYTicksCoords[i] = yTicksCoords[i];
    }
    return retYTicksCoords;
}
#end_block

#method_before
public void setYTicksCoords(Double[] ticksCoords) {
    for (int i = 0; i < yTicksCoords.length; i++) {
        yTicksCoords[i] = ticksCoords[i].doubleValue();
    }
}
#method_after
public void setYTicksCoords(Double[] ticksCoords) {
    for (int i = 0; i < yTicksCoords.length; i++) {
        yTicksCoords[i] = ticksCoords[i];
    }
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("DataMapping")) {
        returnedProp = Fac3dProperty.DATAMAPPING;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("DataMapping")) {
        return Fac3dProperty.DATAMAPPING;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp;
    if (property == Fac3dProperty.DATAMAPPING) {
        returnedProp = getDataMapping();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == Fac3dProperty.DATAMAPPING) {
        return getDataMapping();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Boolean getAutoScale() {
    return new Boolean(autoScale);
}
#method_after
public Boolean getAutoScale() {
    return autoScale;
}
#end_block

#method_before
public void setAutoScale(Boolean autoScale) {
    this.autoScale = autoScale.booleanValue();
}
#method_after
public void setAutoScale(Boolean autoScale) {
    this.autoScale = autoScale;
}
#end_block

#method_before
public Double[] getDataBounds() {
    Double[] retDataBounds = new Double[6];
    for (int i = 0; i < retDataBounds.length; i++) {
        retDataBounds[i] = new Double(dataBounds[i]);
    }
    return retDataBounds;
}
#method_after
public Double[] getDataBounds() {
    Double[] retDataBounds = new Double[6];
    for (int i = 0; i < retDataBounds.length; i++) {
        retDataBounds[i] = dataBounds[i];
    }
    return retDataBounds;
}
#end_block

#method_before
public void setDataBounds(Double[] dataBounds) {
    for (int i = 0; i < this.dataBounds.length; i++) {
        this.dataBounds[i] = dataBounds[i].doubleValue();
    }
}
#method_after
public void setDataBounds(Double[] dataBounds) {
    for (int i = 0; i < this.dataBounds.length; i++) {
        this.dataBounds[i] = dataBounds[i];
    }
}
#end_block

#method_before
public Integer getHiddenAxisColor() {
    return new Integer(hiddenAxisColor);
}
#method_after
public Integer getHiddenAxisColor() {
    return hiddenAxisColor;
}
#end_block

#method_before
public void setHiddenAxisColor(Integer hiddenAxisColor) {
    this.hiddenAxisColor = hiddenAxisColor.intValue();
}
#method_after
public void setHiddenAxisColor(Integer hiddenAxisColor) {
    this.hiddenAxisColor = hiddenAxisColor;
}
#end_block

#method_before
public Double[] getRealDataBounds() {
    Double[] retRealDataBounds = new Double[6];
    for (int i = 0; i < retRealDataBounds.length; i++) {
        retRealDataBounds[i] = new Double(realDataBounds[i]);
    }
    return retRealDataBounds;
}
#method_after
public Double[] getRealDataBounds() {
    Double[] retRealDataBounds = new Double[6];
    for (int i = 0; i < retRealDataBounds.length; i++) {
        retRealDataBounds[i] = realDataBounds[i];
    }
    return retRealDataBounds;
}
#end_block

#method_before
public void setRealDataBounds(Double[] realDataBounds) {
    for (int i = 0; i < this.realDataBounds.length; i++) {
        this.realDataBounds[i] = realDataBounds[i].doubleValue();
    }
}
#method_after
public void setRealDataBounds(Double[] realDataBounds) {
    for (int i = 0; i < this.realDataBounds.length; i++) {
        this.realDataBounds[i] = realDataBounds[i];
    }
}
#end_block

#method_before
public Boolean getTightLimits() {
    return new Boolean(tightLimits);
}
#method_after
public Boolean getTightLimits() {
    return tightLimits;
}
#end_block

#method_before
public void setTightLimits(Boolean tightLimits) {
    this.tightLimits = tightLimits.booleanValue();
}
#method_after
public void setTightLimits(Boolean tightLimits) {
    this.tightLimits = tightLimits;
}
#end_block

#method_before
public Double[] getZoomBox() {
    Double[] retZoomBox = new Double[6];
    for (int i = 0; i < retZoomBox.length; i++) {
        retZoomBox[i] = new Double(zoomBox[i]);
    }
    return retZoomBox;
}
#method_after
public Double[] getZoomBox() {
    Double[] retZoomBox = new Double[6];
    for (int i = 0; i < retZoomBox.length; i++) {
        retZoomBox[i] = zoomBox[i];
    }
    return retZoomBox;
}
#end_block

#method_before
public void setZoomBox(Double[] zoomBox) {
    for (int i = 0; i < this.zoomBox.length; i++) {
        this.zoomBox[i] = zoomBox[i].doubleValue();
    }
}
#method_after
public void setZoomBox(Double[] zoomBox) {
    for (int i = 0; i < this.zoomBox.length; i++) {
        this.zoomBox[i] = zoomBox[i];
    }
}
#end_block

#method_before
public Integer getBackground() {
    return new Integer(background);
}
#method_after
public Integer getBackground() {
    return background;
}
#end_block

#method_before
public void setBackground(Integer background) {
    this.background = background.intValue();
}
#method_after
public void setBackground(Integer background) {
    this.background = background;
}
#end_block

#method_before
public Integer getForeground() {
    return new Integer(foreground);
}
#method_after
public Integer getForeground() {
    return foreground;
}
#end_block

#method_before
public void setForeground(Integer foreground) {
    this.foreground = foreground.intValue();
}
#method_after
public void setForeground(Integer foreground) {
    this.foreground = foreground;
}
#end_block

#method_before
public Boolean getMode() {
    return new Boolean(mode);
}
#method_after
public Boolean getMode() {
    return mode;
}
#end_block

#method_before
public void setMode(Boolean mode) {
    this.mode = mode.booleanValue();
}
#method_after
public void setMode(Boolean mode) {
    this.mode = mode;
}
#end_block

#method_before
public Integer getStyle() {
    return new Integer(style);
}
#method_after
public Integer getStyle() {
    return style;
}
#end_block

#method_before
public void setStyle(Integer style) {
    this.style = style.intValue();
}
#method_after
public void setStyle(Integer style) {
    this.style = style;
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("Colored")) {
        returnedProp = ChampProperty.COLORED;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("Colored")) {
        return ChampProperty.COLORED;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp;
    if (property == ChampProperty.COLORED) {
        returnedProp = this.getColored();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == ChampProperty.COLORED) {
        return getColored();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Boolean getColored() {
    return new Boolean(colored);
}
#method_after
public Boolean getColored() {
    return colored;
}
#end_block

#method_before
public void setColored(Boolean colored) {
    this.colored = colored.booleanValue();
}
#method_after
public void setColored(Boolean colored) {
    this.colored = colored;
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("Line")) {
        returnedProp = ContouredObjectPropertyType.LINE;
    } else if (propertyName.equals("LineMode")) {
        returnedProp = LinePropertyType.MODE;
    } else if (propertyName.equals("LineStyle")) {
        returnedProp = LinePropertyType.LINESTYLE;
    } else if (propertyName.equals("LineThickness")) {
        returnedProp = LinePropertyType.THICKNESS;
    } else if (propertyName.equals("LineColor")) {
        returnedProp = LinePropertyType.COLOR;
    } else if (propertyName.equals("FillMode")) {
        returnedProp = ContouredObjectPropertyType.FILLMODE;
    } else if (propertyName.equals("Background")) {
        returnedProp = ContouredObjectPropertyType.BACKGROUND;
    } else if (propertyName.equals("Mark")) {
        returnedProp = ContouredObjectPropertyType.MARK;
    } else if (propertyName.equals("MarkMode")) {
        returnedProp = MarkPropertyType.MODE;
    } else if (propertyName.equals("MarkStyle")) {
        returnedProp = MarkPropertyType.STYLE;
    } else if (propertyName.equals("MarkSizeUnit")) {
        returnedProp = MarkPropertyType.MARKSIZEUNIT;
    } else if (propertyName.equals("MarkForeground")) {
        returnedProp = MarkPropertyType.FOREGROUND;
    } else if (propertyName.equals("MarkBackground")) {
        returnedProp = MarkPropertyType.BACKGROUND;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("Line")) {
        return ContouredObjectPropertyType.LINE;
    } else if (propertyName.equals("LineMode")) {
        return LinePropertyType.MODE;
    } else if (propertyName.equals("LineStyle")) {
        return LinePropertyType.LINESTYLE;
    } else if (propertyName.equals("LineThickness")) {
        return LinePropertyType.THICKNESS;
    } else if (propertyName.equals("LineColor")) {
        return LinePropertyType.COLOR;
    } else if (propertyName.equals("FillMode")) {
        return ContouredObjectPropertyType.FILLMODE;
    } else if (propertyName.equals("Background")) {
        return ContouredObjectPropertyType.BACKGROUND;
    } else if (propertyName.equals("Mark")) {
        return ContouredObjectPropertyType.MARK;
    } else if (propertyName.equals("MarkMode")) {
        return MarkPropertyType.MODE;
    } else if (propertyName.equals("MarkStyle")) {
        return MarkPropertyType.STYLE;
    } else if (propertyName.equals("MarkSizeUnit")) {
        return MarkPropertyType.MARKSIZEUNIT;
    } else if (propertyName.equals("MarkForeground")) {
        return MarkPropertyType.FOREGROUND;
    } else if (propertyName.equals("MarkBackground")) {
        return MarkPropertyType.BACKGROUND;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp = null;
    if (property == ContouredObjectPropertyType.LINE) {
        returnedProp = getLine();
    } else if (property == LinePropertyType.MODE) {
        returnedProp = getLineMode();
    } else if (property == LinePropertyType.LINESTYLE) {
        returnedProp = getLineStyle();
    } else if (property == LinePropertyType.THICKNESS) {
        returnedProp = getThickness();
    } else if (property == LinePropertyType.COLOR) {
        returnedProp = getColor();
    } else if (property == ContouredObjectPropertyType.FILLMODE) {
        returnedProp = getFillMode();
    } else if (property == ContouredObjectPropertyType.BACKGROUND) {
        returnedProp = getBackground();
    } else if (property == ContouredObjectPropertyType.MARK) {
        returnedProp = getMark();
    } else if (property == MarkPropertyType.MODE) {
        returnedProp = getMarkMode();
    } else if (property == MarkPropertyType.STYLE) {
        returnedProp = getMarkStyle();
    } else if (property == MarkPropertyType.MARKSIZEUNIT) {
        returnedProp = getMarkSizeUnit();
    } else if (property == MarkPropertyType.FOREGROUND) {
        returnedProp = getMarkForeground();
    } else if (property == MarkPropertyType.BACKGROUND) {
        returnedProp = getMarkBackground();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == ContouredObjectPropertyType.LINE) {
        return getLine();
    } else if (property == LinePropertyType.MODE) {
        return getLineMode();
    } else if (property == LinePropertyType.LINESTYLE) {
        return getLineStyle();
    } else if (property == LinePropertyType.THICKNESS) {
        return getThickness();
    } else if (property == LinePropertyType.COLOR) {
        return getColor();
    } else if (property == ContouredObjectPropertyType.FILLMODE) {
        return getFillMode();
    } else if (property == ContouredObjectPropertyType.BACKGROUND) {
        return getBackground();
    } else if (property == ContouredObjectPropertyType.MARK) {
        return getMark();
    } else if (property == MarkPropertyType.MODE) {
        return getMarkMode();
    } else if (property == MarkPropertyType.STYLE) {
        return getMarkStyle();
    } else if (property == MarkPropertyType.MARKSIZEUNIT) {
        return getMarkSizeUnit();
    } else if (property == MarkPropertyType.FOREGROUND) {
        return getMarkForeground();
    } else if (property == MarkPropertyType.BACKGROUND) {
        return getMarkBackground();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Integer getBackground() {
    return new Integer(background);
}
#method_after
public Integer getBackground() {
    return background;
}
#end_block

#method_before
public void setBackground(Integer background) {
    this.background = background.intValue();
}
#method_after
public void setBackground(Integer background) {
    this.background = background;
}
#end_block

#method_before
public Boolean getFillMode() {
    return new Boolean(fillMode);
}
#method_after
public Boolean getFillMode() {
    return fillMode;
}
#end_block

#method_before
public void setFillMode(Boolean fillMode) {
    this.fillMode = fillMode.booleanValue();
}
#method_after
public void setFillMode(Boolean fillMode) {
    this.fillMode = fillMode;
}
#end_block

#method_before
public Integer getMarkBackground() {
    return new Integer(mark.getBackground());
}
#method_after
public Integer getMarkBackground() {
    return mark.getBackground();
}
#end_block

#method_before
public Boolean getMarkMode() {
    return new Boolean(mark.getMode());
}
#method_after
public Boolean getMarkMode() {
    return mark.getMode();
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("FontAngle")) {
        returnedProp = TextProperty.FONTANGLE;
    } else if (propertyName.equals("Position")) {
        returnedProp = TextProperty.POSITION;
    } else if (propertyName.equals("Alignment")) {
        returnedProp = TextProperty.ALIGNMENT;
    } else if (propertyName.equals("Box")) {
        returnedProp = TextProperty.BOX;
    } else if (propertyName.equals("TextBox")) {
        returnedProp = TextProperty.TEXTBOX;
    } else if (propertyName.equals("TextBoxMode")) {
        returnedProp = TextProperty.TEXTBOXMODE;
    } else if (propertyName.equals("AutoDimensioning")) {
        returnedProp = TextProperty.AUTODIMENSIONING;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("FontAngle")) {
        return TextProperty.FONTANGLE;
    } else if (propertyName.equals("Position")) {
        return TextProperty.POSITION;
    } else if (propertyName.equals("Alignment")) {
        return TextProperty.ALIGNMENT;
    } else if (propertyName.equals("Box")) {
        return TextProperty.BOX;
    } else if (propertyName.equals("TextBox")) {
        return TextProperty.TEXTBOX;
    } else if (propertyName.equals("TextBoxMode")) {
        return TextProperty.TEXTBOXMODE;
    } else if (propertyName.equals("AutoDimensioning")) {
        return TextProperty.AUTODIMENSIONING;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp;
    if (property == TextProperty.FONTANGLE) {
        returnedProp = getFontAngle();
    } else if (property == TextProperty.POSITION) {
        returnedProp = getPosition();
    } else if (property == TextProperty.ALIGNMENT) {
        returnedProp = getAlignment();
    } else if (property == TextProperty.BOX) {
        returnedProp = getBox();
    } else if (property == TextProperty.TEXTBOX) {
        returnedProp = getTextBox();
    } else if (property == TextProperty.TEXTBOXMODE) {
        returnedProp = getTextBoxMode();
    } else if (property == TextProperty.AUTODIMENSIONING) {
        returnedProp = getAutoDimensioning();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == TextProperty.FONTANGLE) {
        return getFontAngle();
    } else if (property == TextProperty.POSITION) {
        return getPosition();
    } else if (property == TextProperty.ALIGNMENT) {
        return getAlignment();
    } else if (property == TextProperty.BOX) {
        return getBox();
    } else if (property == TextProperty.TEXTBOX) {
        return getTextBox();
    } else if (property == TextProperty.TEXTBOXMODE) {
        return getTextBoxMode();
    } else if (property == TextProperty.AUTODIMENSIONING) {
        return getAutoDimensioning();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Boolean getAutoDimensioning() {
    return new Boolean(autoDimensioning);
}
#method_after
public Boolean getAutoDimensioning() {
    return autoDimensioning;
}
#end_block

#method_before
public void setAutoDimensioning(Boolean autoDimensioning) {
    this.autoDimensioning = autoDimensioning.booleanValue();
}
#method_after
public void setAutoDimensioning(Boolean autoDimensioning) {
    this.autoDimensioning = autoDimensioning;
}
#end_block

#method_before
public Boolean getBox() {
    return new Boolean(box);
}
#method_after
public Boolean getBox() {
    return box;
}
#end_block

#method_before
public void setBox(Boolean box) {
    this.box = box.booleanValue();
}
#method_after
public void setBox(Boolean box) {
    this.box = box;
}
#end_block

#method_before
public Double getFontAngle() {
    return new Double(fontAngle);
}
#method_after
public Double getFontAngle() {
    return fontAngle;
}
#end_block

#method_before
public void setFontAngle(Double fontAngle) {
    this.fontAngle = fontAngle.doubleValue();
}
#method_after
public void setFontAngle(Double fontAngle) {
    this.fontAngle = fontAngle;
}
#end_block

#method_before
public Double[] getPosition() {
    Double[] retPosition = new Double[3];
    retPosition[0] = new Double(position[0]);
    retPosition[1] = new Double(position[1]);
    retPosition[2] = new Double(position[2]);
    return retPosition;
}
#method_after
public Double[] getPosition() {
    Double[] retPosition = new Double[3];
    retPosition[0] = position[0];
    retPosition[1] = position[1];
    retPosition[2] = position[2];
    return retPosition;
}
#end_block

#method_before
public void setPosition(Double[] position) {
    this.position[0] = position[0].doubleValue();
    this.position[1] = position[1].doubleValue();
    this.position[2] = position[2].doubleValue();
}
#method_after
public void setPosition(Double[] position) {
    this.position[0] = position[0];
    this.position[1] = position[1];
    this.position[2] = position[2];
}
#end_block

#method_before
public Double[] getTextBox() {
    Double[] retTextBox = new Double[2];
    retTextBox[0] = new Double(textBox[0]);
    retTextBox[1] = new Double(textBox[2]);
    return retTextBox;
}
#method_after
public Double[] getTextBox() {
    Double[] retTextBox = new Double[2];
    retTextBox[0] = textBox[0];
    retTextBox[1] = textBox[2];
    return retTextBox;
}
#end_block

#method_before
public void setTextBox(Double[] textBox) {
    this.textBox[0] = textBox[0].doubleValue();
    this.textBox[1] = textBox[1].doubleValue();
}
#method_after
public void setTextBox(Double[] textBox) {
    this.textBox[0] = textBox[0];
    this.textBox[1] = textBox[1];
}
#end_block

#method_before
public void setProperty(UID id, String prop, Object value) {
    // LOG("setProperty id = "+id+" prop = "+prop);
    // System.out.format("setProperty: %s %s\n", prop, value.toString());
    GraphicModel.getModel().setProperty(id, prop, value);
    objectUpdate(id);
}
#method_after
public void setProperty(UID id, String prop, Object value) {
    GraphicModel.getModel().setProperty(id, prop, value);
    objectUpdate(id);
}
#end_block

#method_before
public Object getProperty(UID id, String prop) {
    // LOG("getProperty id = "+id+" prop = "+prop);
    return GraphicModel.getModel().getProperty(id, prop);
}
#method_after
public Object getProperty(UID id, String prop) {
    return GraphicModel.getModel().getProperty(id, prop);
}
#end_block

#method_before
public UID askObject(Type type) {
    // LOG("askObject()");
    UID id = createUID();
    GraphicModel.getModel().createObject(id, type);
    objectCreated(id);
    return id;
}
#method_after
public UID askObject(Type type) {
    UID id = createUID();
    GraphicModel.getModel().createObject(id, type);
    objectCreated(id);
    return id;
}
#end_block

#method_before
public void objectCreated(UID id) {
// LOG("objectCreated id = "+id);
// TBD, deactivated for now
/*
	Iterator<IView> itr = allViews.iterator();
	while (itr.hasNext()) {
		System.out.format("createObject: %s\n", id.toString());
	    IView currentView = itr.next();
	    currentView.createObject(id);
	}
	objectUpdate(id);
	*/
}
#method_after
public void objectCreated(UID id) {
// TBD, deactivated for now
/*
	Iterator<IView> itr = allViews.iterator();
	while (itr.hasNext()) {
		System.out.format("createObject: %s\n", id.toString());
	    IView currentView = itr.next();
	    currentView.createObject(id);
	}
	objectUpdate(id);
	*/
}
#end_block

#method_before
public void objectUpdate(UID id) {
// LOG("objectUpdate id = "+id);
// TBD, deactivated for now
/*
	Iterator<IView> itr = allViews.iterator();
	while (itr.hasNext()) {
	    itr.next().updateObject(id);
	}
	*/
}
#method_after
public void objectUpdate(UID id) {
// TBD, deactivated for now
/*
	Iterator<IView> itr = allViews.iterator();
	while (itr.hasNext()) {
	    itr.next().updateObject(id);
	}
	*/
}
#end_block

#method_before
public void deleteObject(UID id) {
    LOG("deleteObject id = " + id);
    GraphicModel.getModel().deleteObject(id);
// TBD, deactivated for now
/*
	   Iterator<IView> itr = allViews.iterator();
		while (itr.hasNext()) {
		    itr.next().deleteObject(id);
		}
		*/
}
#method_after
public void deleteObject(UID id) {
    GraphicModel.getModel().deleteObject(id);
// TBD, deactivated for now
/*
	   Iterator<IView> itr = allViews.iterator();
		while (itr.hasNext()) {
		    itr.next().deleteObject(id);
		}
		*/
}
#end_block

#method_before
public Integer getColor() {
    return new Integer(color);
}
#method_after
public Integer getColor() {
    return color;
}
#end_block

#method_before
public void setColor(Integer color) {
    this.color = color.intValue();
}
#method_after
public void setColor(Integer color) {
    this.color = color;
}
#end_block

#method_before
public Boolean getMode() {
    return new Boolean(mode);
}
#method_after
public Boolean getMode() {
    return mode;
}
#end_block

#method_before
public void setMode(Boolean mode) {
    this.mode = mode.booleanValue();
}
#method_after
public void setMode(Boolean mode) {
    this.mode = mode;
}
#end_block

#method_before
public Double getThickness() {
    return new Double(thickness);
}
#method_after
public Double getThickness() {
    return thickness;
}
#end_block

#method_before
public void setThickness(Double thickness) {
    this.thickness = thickness.doubleValue();
}
#method_after
public void setThickness(Double thickness) {
    this.thickness = thickness;
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("Dimensions")) {
        returnedProp = FigureProperty.DIMENSIONS;
    } else if (propertyName.equals("Position")) {
        returnedProp = FigureDimensionsProperty.POSITION;
    } else if (propertyName.equals("Size")) {
        returnedProp = FigureDimensionsProperty.SIZE;
    } else if (propertyName.equals("Canvas")) {
        returnedProp = FigureProperty.CANVAS;
    } else if (propertyName.equals("AutoResize")) {
        returnedProp = CanvasProperty.AUTORESIZE;
    } else if (propertyName.equals("Viewport")) {
        returnedProp = CanvasProperty.VIEWPORT;
    } else if (propertyName.equals("AxesSize")) {
        returnedProp = CanvasProperty.AXESSIZE;
    } else if (propertyName.equals("FigureName")) {
        returnedProp = FigureProperty.NAME;
    } else if (propertyName.equals("Name")) {
        returnedProp = FigureNameProperty.NAME;
    } else if (propertyName.equals("Id")) {
        returnedProp = FigureNameProperty.ID;
    } else if (propertyName.equals("InfoMessage")) {
        returnedProp = FigureProperty.INFOMESSAGE;
    } else if (propertyName.equals("ColorMap")) {
        returnedProp = FigureProperty.COLORMAP;
    } else if (propertyName.equals("RenderingMode")) {
        returnedProp = FigureProperty.RENDERINGMODE;
    } else if (propertyName.equals("Pixmap")) {
        returnedProp = RenderingModeProperty.PIXMAP;
    } else if (propertyName.equals("PixelDrawingMode")) {
        returnedProp = RenderingModeProperty.PIXELDRAWINGMODE;
    } else if (propertyName.equals("Antialiasing")) {
        returnedProp = RenderingModeProperty.ANTIALIASING;
    } else if (propertyName.equals("ImmediateDrawing")) {
        returnedProp = RenderingModeProperty.IMMEDIATEDRAWING;
    } else if (propertyName.equals("Background")) {
        returnedProp = FigureProperty.BACKGROUND;
    } else if (propertyName.equals("EventHandler")) {
        returnedProp = FigureProperty.EVENTHANDLER;
    } else if (propertyName.equals("EventHandlerName")) {
        returnedProp = EventHandlerProperty.EVENTHANDLER;
    } else if (propertyName.equals("Tag")) {
        returnedProp = FigureProperty.TAG;
    } else if (propertyName.equals("RotationType")) {
        returnedProp = FigureProperty.ROTATIONTYPE;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("Dimensions")) {
        return FigureProperty.DIMENSIONS;
    } else if (propertyName.equals("Position")) {
        return FigureDimensionsProperty.POSITION;
    } else if (propertyName.equals("Size")) {
        return FigureDimensionsProperty.SIZE;
    } else if (propertyName.equals("Canvas")) {
        return FigureProperty.CANVAS;
    } else if (propertyName.equals("AutoResize")) {
        return CanvasProperty.AUTORESIZE;
    } else if (propertyName.equals("Viewport")) {
        return CanvasProperty.VIEWPORT;
    } else if (propertyName.equals("AxesSize")) {
        return CanvasProperty.AXESSIZE;
    } else if (propertyName.equals("FigureName")) {
        return FigureProperty.NAME;
    } else if (propertyName.equals("Name")) {
        return FigureNameProperty.NAME;
    } else if (propertyName.equals("Id")) {
        return FigureNameProperty.ID;
    } else if (propertyName.equals("InfoMessage")) {
        return FigureProperty.INFOMESSAGE;
    } else if (propertyName.equals("ColorMap")) {
        return FigureProperty.COLORMAP;
    } else if (propertyName.equals("RenderingMode")) {
        return FigureProperty.RENDERINGMODE;
    } else if (propertyName.equals("Pixmap")) {
        return RenderingModeProperty.PIXMAP;
    } else if (propertyName.equals("PixelDrawingMode")) {
        return RenderingModeProperty.PIXELDRAWINGMODE;
    } else if (propertyName.equals("Antialiasing")) {
        return RenderingModeProperty.ANTIALIASING;
    } else if (propertyName.equals("ImmediateDrawing")) {
        return RenderingModeProperty.IMMEDIATEDRAWING;
    } else if (propertyName.equals("Background")) {
        return FigureProperty.BACKGROUND;
    } else if (propertyName.equals("EventHandler")) {
        return FigureProperty.EVENTHANDLER;
    } else if (propertyName.equals("EventHandlerName")) {
        return EventHandlerProperty.EVENTHANDLER;
    } else if (propertyName.equals("Tag")) {
        return FigureProperty.TAG;
    } else if (propertyName.equals("RotationType")) {
        return FigureProperty.ROTATIONTYPE;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp;
    if (property == FigureProperty.DIMENSIONS) {
        returnedProp = getDimensions();
    } else if (property == FigureDimensionsProperty.POSITION) {
        returnedProp = getPosition();
    } else if (property == FigureDimensionsProperty.SIZE) {
        returnedProp = getSize();
    } else if (property == FigureProperty.CANVAS) {
        returnedProp = getCanvas();
    } else if (property == CanvasProperty.AUTORESIZE) {
        returnedProp = getAutoResize();
    } else if (property == CanvasProperty.VIEWPORT) {
        returnedProp = getViewport();
    } else if (property == CanvasProperty.AXESSIZE) {
        returnedProp = getAxesSize();
    } else if (property == FigureProperty.NAME) {
        returnedProp = getFigureName();
    } else if (property == FigureNameProperty.NAME) {
        returnedProp = getName();
    } else if (property == FigureNameProperty.ID) {
        returnedProp = getId();
    } else if (property == FigureProperty.INFOMESSAGE) {
        returnedProp = getInfoMessage();
    } else if (property == FigureProperty.COLORMAP) {
        returnedProp = getColorMap();
    } else if (property == FigureProperty.RENDERINGMODE) {
        returnedProp = getRenderingMode();
    } else if (property == RenderingModeProperty.PIXMAP) {
        returnedProp = getPixmap();
    } else if (property == RenderingModeProperty.PIXELDRAWINGMODE) {
        returnedProp = getPixelDrawingMode();
    } else if (property == RenderingModeProperty.ANTIALIASING) {
        returnedProp = getAntialiasing();
    } else if (property == RenderingModeProperty.IMMEDIATEDRAWING) {
        returnedProp = getImmediateDrawing();
    } else if (property == FigureProperty.BACKGROUND) {
        returnedProp = getBackground();
    } else if (property == FigureProperty.EVENTHANDLER) {
        returnedProp = getEventHandler();
    } else if (property == EventHandlerProperty.EVENTHANDLER) {
        returnedProp = getEventHandlerString();
    } else if (property == FigureProperty.TAG) {
        returnedProp = getTag();
    } else if (property == FigureProperty.ROTATIONTYPE) {
        returnedProp = getRotation();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == FigureProperty.DIMENSIONS) {
        return getDimensions();
    } else if (property == FigureDimensionsProperty.POSITION) {
        return getPosition();
    } else if (property == FigureDimensionsProperty.SIZE) {
        return getSize();
    } else if (property == FigureProperty.CANVAS) {
        return getCanvas();
    } else if (property == CanvasProperty.AUTORESIZE) {
        return getAutoResize();
    } else if (property == CanvasProperty.VIEWPORT) {
        return getViewport();
    } else if (property == CanvasProperty.AXESSIZE) {
        return getAxesSize();
    } else if (property == FigureProperty.NAME) {
        return getFigureName();
    } else if (property == FigureNameProperty.NAME) {
        return getName();
    } else if (property == FigureNameProperty.ID) {
        return getId();
    } else if (property == FigureProperty.INFOMESSAGE) {
        return getInfoMessage();
    } else if (property == FigureProperty.COLORMAP) {
        return getColorMap();
    } else if (property == FigureProperty.RENDERINGMODE) {
        return getRenderingMode();
    } else if (property == RenderingModeProperty.PIXMAP) {
        return getPixmap();
    } else if (property == RenderingModeProperty.PIXELDRAWINGMODE) {
        return getPixelDrawingMode();
    } else if (property == RenderingModeProperty.ANTIALIASING) {
        return getAntialiasing();
    } else if (property == RenderingModeProperty.IMMEDIATEDRAWING) {
        return getImmediateDrawing();
    } else if (property == FigureProperty.BACKGROUND) {
        return getBackground();
    } else if (property == FigureProperty.EVENTHANDLER) {
        return getEventHandler();
    } else if (property == EventHandlerProperty.EVENTHANDLER) {
        return getEventHandlerString();
    } else if (property == FigureProperty.TAG) {
        return getTag();
    } else if (property == FigureProperty.ROTATIONTYPE) {
        return getRotation();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public void setBackground(Integer background) {
    this.background = background.intValue();
}
#method_after
public void setBackground(Integer background) {
    this.background = background;
}
#end_block

#method_before
public Boolean getAutoResize() {
    return new Boolean(canvas.autoResize);
}
#method_after
public Boolean getAutoResize() {
    return canvas.autoResize;
}
#end_block

#method_before
public void setAutoResize(Boolean autoResize) {
    canvas.autoResize = autoResize.booleanValue();
}
#method_after
public void setAutoResize(Boolean autoResize) {
    canvas.autoResize = autoResize;
}
#end_block

#method_before
public Integer[] getViewport() {
    Integer[] retViewport = new Integer[2];
    retViewport[0] = new Integer(canvas.viewport[0]);
    retViewport[1] = new Integer(canvas.viewport[1]);
    return retViewport;
}
#method_after
public Integer[] getViewport() {
    Integer[] retViewport = new Integer[2];
    retViewport[0] = canvas.viewport[0];
    retViewport[1] = canvas.viewport[1];
    return retViewport;
}
#end_block

#method_before
public void setViewport(Integer[] viewport) {
    canvas.viewport[0] = viewport[0].intValue();
    canvas.viewport[1] = viewport[1].intValue();
}
#method_after
public void setViewport(Integer[] viewport) {
    canvas.viewport[0] = viewport[0];
    canvas.viewport[1] = viewport[1];
}
#end_block

#method_before
public Integer[] getAxesSize() {
    Integer[] retAxesSize = new Integer[2];
    retAxesSize[0] = new Integer(canvas.axesSize[0]);
    retAxesSize[1] = new Integer(canvas.axesSize[1]);
    return retAxesSize;
}
#method_after
public Integer[] getAxesSize() {
    Integer[] retAxesSize = new Integer[2];
    retAxesSize[0] = canvas.axesSize[0];
    retAxesSize[1] = canvas.axesSize[1];
    return retAxesSize;
}
#end_block

#method_before
public void setAxesSize(Integer[] axesSize) {
    canvas.axesSize[0] = axesSize[0].intValue();
    canvas.axesSize[1] = axesSize[1].intValue();
}
#method_after
public void setAxesSize(Integer[] axesSize) {
    canvas.axesSize[0] = axesSize[0];
    canvas.axesSize[1] = axesSize[1];
}
#end_block

#method_before
public Integer[] getPosition() {
    Integer[] retPosition = new Integer[2];
    retPosition[0] = new Integer(dimensions.position[0]);
    retPosition[1] = new Integer(dimensions.position[1]);
    return retPosition;
}
#method_after
public Integer[] getPosition() {
    Integer[] retPosition = new Integer[2];
    retPosition[0] = dimensions.position[0];
    retPosition[1] = dimensions.position[1];
    return retPosition;
}
#end_block

#method_before
public void setPosition(Integer[] position) {
    dimensions.position[0] = position[0].intValue();
    dimensions.position[1] = position[1].intValue();
}
#method_after
public void setPosition(Integer[] position) {
    dimensions.position[0] = position[0];
    dimensions.position[1] = position[1];
}
#end_block

#method_before
public Integer[] getSize() {
    Integer[] retSize = new Integer[2];
    retSize[0] = new Integer(dimensions.size[0]);
    retSize[1] = new Integer(dimensions.size[1]);
    return retSize;
}
#method_after
public Integer[] getSize() {
    Integer[] retSize = new Integer[2];
    retSize[0] = dimensions.size[0];
    retSize[1] = dimensions.size[1];
    return retSize;
}
#end_block

#method_before
public void setSize(Integer[] size) {
    dimensions.size[0] = size[0].intValue();
    dimensions.size[1] = size[1].intValue();
}
#method_after
public void setSize(Integer[] size) {
    dimensions.size[0] = size[0];
    dimensions.size[1] = size[1];
}
#end_block

#method_before
public Integer getId() {
    return new Integer(figureName.id);
}
#method_after
public Integer getId() {
    return figureName.id;
}
#end_block

#method_before
public void setId(Integer id) {
    figureName.id = id.intValue();
}
#method_after
public void setId(Integer id) {
    figureName.id = id;
}
#end_block

#method_before
public Boolean getPixmap() {
    return new Boolean(renderingMode.pixmap);
}
#method_after
public Boolean getPixmap() {
    return renderingMode.pixmap;
}
#end_block

#method_before
public void setPixmap(Boolean pixmap) {
    renderingMode.pixmap = pixmap.booleanValue();
}
#method_after
public void setPixmap(Boolean pixmap) {
    renderingMode.pixmap = pixmap;
}
#end_block

#method_before
public Integer getAntialiasing() {
    return new Integer(renderingMode.antialiasing);
}
#method_after
public Integer getAntialiasing() {
    return renderingMode.antialiasing;
}
#end_block

#method_before
public void setAntialiasing(Integer antialiasing) {
    renderingMode.antialiasing = antialiasing.intValue();
}
#method_after
public void setAntialiasing(Integer antialiasing) {
    renderingMode.antialiasing = antialiasing;
}
#end_block

#method_before
public Boolean getImmediateDrawing() {
    return new Boolean(renderingMode.immediateDrawing);
}
#method_after
public Boolean getImmediateDrawing() {
    return renderingMode.immediateDrawing;
}
#end_block

#method_before
public void setImmediateDrawing(Boolean immediateDrawing) {
    renderingMode.immediateDrawing = immediateDrawing.booleanValue();
}
#method_after
public void setImmediateDrawing(Boolean immediateDrawing) {
    renderingMode.immediateDrawing = immediateDrawing;
}
#end_block

#method_before
public Integer getTag() {
    return new Integer(tag);
}
#method_after
public Integer getTag() {
    return tag;
}
#end_block

#method_before
public void setTag(Integer tag) {
    this.tag = tag.intValue();
}
#method_after
public void setTag(Integer tag) {
    this.tag = tag;
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("UpperLeftPoint")) {
        returnedProp = RectangleProperty.UPPERLEFTPOINT;
    } else if (propertyName.equals("Width")) {
        returnedProp = RectangleProperty.WIDTH;
    } else if (propertyName.equals("Height")) {
        returnedProp = RectangleProperty.HEIGHT;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("UpperLeftPoint")) {
        return RectangleProperty.UPPERLEFTPOINT;
    } else if (propertyName.equals("Width")) {
        return RectangleProperty.WIDTH;
    } else if (propertyName.equals("Height")) {
        return RectangleProperty.HEIGHT;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp;
    if (property == RectangleProperty.UPPERLEFTPOINT) {
        returnedProp = getUpperLeftPoint();
    } else if (property == RectangleProperty.WIDTH) {
        returnedProp = getWidth();
    } else if (property == RectangleProperty.HEIGHT) {
        returnedProp = getHeight();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == RectangleProperty.UPPERLEFTPOINT) {
        return getUpperLeftPoint();
    } else if (property == RectangleProperty.WIDTH) {
        return getWidth();
    } else if (property == RectangleProperty.HEIGHT) {
        return getHeight();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Double getHeight() {
    return new Double(height);
}
#method_after
public Double getHeight() {
    return height;
}
#end_block

#method_before
public void setHeight(Double height) {
    this.height = height.doubleValue();
}
#method_after
public void setHeight(Double height) {
    this.height = height;
}
#end_block

#method_before
public Double[] getUpperLeftPoint() {
    Double[] retPoint = new Double[3];
    retPoint[0] = new Double(upperLeftPoint[0]);
    retPoint[1] = new Double(upperLeftPoint[1]);
    retPoint[2] = new Double(upperLeftPoint[2]);
    return retPoint;
}
#method_after
public Double[] getUpperLeftPoint() {
    Double[] retPoint = new Double[3];
    retPoint[0] = upperLeftPoint[0];
    retPoint[1] = upperLeftPoint[1];
    retPoint[2] = upperLeftPoint[2];
    return retPoint;
}
#end_block

#method_before
public void setUpperLeftPoint(Double[] upperLeftPoint) {
    this.upperLeftPoint[0] = upperLeftPoint[0].doubleValue();
    this.upperLeftPoint[1] = upperLeftPoint[1].doubleValue();
    this.upperLeftPoint[2] = upperLeftPoint[2].doubleValue();
}
#method_after
public void setUpperLeftPoint(Double[] upperLeftPoint) {
    this.upperLeftPoint[0] = upperLeftPoint[0];
    this.upperLeftPoint[1] = upperLeftPoint[1];
    this.upperLeftPoint[2] = upperLeftPoint[2];
}
#end_block

#method_before
public Double getWidth() {
    return new Double(width);
}
#method_after
public Double getWidth() {
    return width;
}
#end_block

#method_before
public void setWidth(Double width) {
    this.width = width.doubleValue();
}
#method_after
public void setWidth(Double width) {
    this.width = width;
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("DataMapping")) {
        returnedProp = GrayplotProperty.DATAMAPPING;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("DataMapping")) {
        return GrayplotProperty.DATAMAPPING;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp;
    if (property == GrayplotProperty.DATAMAPPING) {
        returnedProp = getDataMapping();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == GrayplotProperty.DATAMAPPING) {
        return getDataMapping();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("Base")) {
        returnedProp = ArrowProperty.BASE;
    } else if (propertyName.equals("Direction")) {
        returnedProp = ArrowProperty.DIRECTION;
    } else if (propertyName.equals("ArrowSize")) {
        returnedProp = ArrowProperty.ARROWSIZE;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("Base")) {
        return ArrowProperty.BASE;
    } else if (propertyName.equals("Direction")) {
        return ArrowProperty.DIRECTION;
    } else if (propertyName.equals("ArrowSize")) {
        return ArrowProperty.ARROWSIZE;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp;
    if (property == ArrowProperty.BASE) {
        returnedProp = getBase();
    } else if (property == ArrowProperty.DIRECTION) {
        returnedProp = getDirection();
    } else if (property == ArrowProperty.ARROWSIZE) {
        returnedProp = getArrowSize();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == ArrowProperty.BASE) {
        return getBase();
    } else if (property == ArrowProperty.DIRECTION) {
        return getDirection();
    } else if (property == ArrowProperty.ARROWSIZE) {
        return getArrowSize();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Double getArrowSize() {
    return new Double(arrowSize);
}
#method_after
public Double getArrowSize() {
    return arrowSize;
}
#end_block

#method_before
public void setArrowSize(Double arrowSize) {
    this.arrowSize = arrowSize.doubleValue();
}
#method_after
public void setArrowSize(Double arrowSize) {
    this.arrowSize = arrowSize;
}
#end_block

#method_before
public Double[] getBase() {
    Double[] retBase = new Double[3];
    retBase[0] = new Double(base[0]);
    retBase[2] = new Double(base[1]);
    retBase[1] = new Double(base[2]);
    return retBase;
}
#method_after
public Double[] getBase() {
    Double[] retBase = new Double[3];
    retBase[0] = base[0];
    retBase[2] = base[1];
    retBase[1] = base[2];
    return retBase;
}
#end_block

#method_before
public void setBase(Double[] base) {
    this.base[0] = base[0].doubleValue();
    this.base[1] = base[1].doubleValue();
    this.base[2] = base[2].doubleValue();
}
#method_after
public void setBase(Double[] base) {
    this.base[0] = base[0];
    this.base[1] = base[1];
    this.base[2] = base[2];
}
#end_block

#method_before
public Double[] getDirection() {
    Double[] retDirection = new Double[3];
    retDirection[0] = new Double(direction[0]);
    retDirection[1] = new Double(direction[1]);
    retDirection[2] = new Double(direction[2]);
    return retDirection;
}
#method_after
public Double[] getDirection() {
    Double[] retDirection = new Double[3];
    retDirection[0] = direction[0];
    retDirection[1] = direction[1];
    retDirection[2] = direction[2];
    return retDirection;
}
#end_block

#method_before
public void setDirection(Double[] direction) {
    this.direction[0] = direction[0].doubleValue();
    this.direction[1] = direction[1].doubleValue();
    this.direction[2] = direction[2].doubleValue();
}
#method_after
public void setDirection(Double[] direction) {
    this.direction[0] = direction[0];
    this.direction[1] = direction[1];
    this.direction[2] = direction[2];
}
#end_block

#method_before
public Boolean getCubeScaling() {
    return new Boolean(cubeScaling);
}
#method_after
public Boolean getCubeScaling() {
    return cubeScaling;
}
#end_block

#method_before
public void setCubeScaling(Boolean cubeScaling) {
    this.cubeScaling = cubeScaling.booleanValue();
}
#method_after
public void setCubeScaling(Boolean cubeScaling) {
    this.cubeScaling = cubeScaling;
}
#end_block

#method_before
public Boolean getIsoview() {
    return new Boolean(isoview);
}
#method_after
public Boolean getIsoview() {
    return isoview;
}
#end_block

#method_before
public void setIsoview(Boolean isoview) {
    this.isoview = isoview.booleanValue();
}
#method_after
public void setIsoview(Boolean isoview) {
    this.isoview = isoview;
}
#end_block

#method_before
public Double[] getRotationAngles() {
    Double[] retRotationAngles = new Double[2];
    retRotationAngles[0] = new Double(rotationAngles[0]);
    retRotationAngles[1] = new Double(rotationAngles[1]);
    return retRotationAngles;
}
#method_after
public Double[] getRotationAngles() {
    Double[] retRotationAngles = new Double[2];
    retRotationAngles[0] = rotationAngles[0];
    retRotationAngles[1] = rotationAngles[1];
    return retRotationAngles;
}
#end_block

#method_before
public void setRotationAngles(Double[] rotationAngles) {
    this.rotationAngles[0] = rotationAngles[0].doubleValue();
    this.rotationAngles[1] = rotationAngles[0].doubleValue();
}
#method_after
public void setRotationAngles(Double[] rotationAngles) {
    this.rotationAngles[0] = rotationAngles[0];
    this.rotationAngles[1] = rotationAngles[0];
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("FontAngle")) {
        returnedProp = LabelProperty.FONTANGLE;
    } else if (propertyName.equals("AutoPosition")) {
        returnedProp = LabelProperty.AUTOPOSITION;
    } else if (propertyName.equals("Position")) {
        returnedProp = LabelProperty.POSITION;
    } else if (propertyName.equals("AutoRotation")) {
        returnedProp = LabelProperty.AUTOROTATION;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("FontAngle")) {
        return LabelProperty.FONTANGLE;
    } else if (propertyName.equals("AutoPosition")) {
        return LabelProperty.AUTOPOSITION;
    } else if (propertyName.equals("Position")) {
        return LabelProperty.POSITION;
    } else if (propertyName.equals("AutoRotation")) {
        return LabelProperty.AUTOROTATION;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp;
    if (property == LabelProperty.FONTANGLE) {
        returnedProp = getFontAngle();
    } else if (property == LabelProperty.AUTOPOSITION) {
        returnedProp = getAutoPosition();
    } else if (property == LabelProperty.POSITION) {
        returnedProp = getPosition();
    } else if (property == LabelProperty.AUTOROTATION) {
        returnedProp = getAutoRotation();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == LabelProperty.FONTANGLE) {
        return getFontAngle();
    } else if (property == LabelProperty.AUTOPOSITION) {
        return getAutoPosition();
    } else if (property == LabelProperty.POSITION) {
        return getPosition();
    } else if (property == LabelProperty.AUTOROTATION) {
        return getAutoRotation();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Boolean getAutoPosition() {
    return new Boolean(autoPosition);
}
#method_after
public Boolean getAutoPosition() {
    return autoPosition;
}
#end_block

#method_before
public void setAutoPosition(Boolean autoPosition) {
    this.autoPosition = autoPosition.booleanValue();
}
#method_after
public void setAutoPosition(Boolean autoPosition) {
    this.autoPosition = autoPosition;
}
#end_block

#method_before
public Boolean getAutoRotation() {
    return new Boolean(autoRotation);
}
#method_after
public Boolean getAutoRotation() {
    return autoRotation;
}
#end_block

#method_before
public void setAutoRotation(Boolean autoRotation) {
    this.autoRotation = autoRotation.booleanValue();
}
#method_after
public void setAutoRotation(Boolean autoRotation) {
    this.autoRotation = autoRotation;
}
#end_block

#method_before
public Double getFontAngle() {
    return new Double(fontAngle);
}
#method_after
public Double getFontAngle() {
    return fontAngle;
}
#end_block

#method_before
public void setFontAngle(Double fontAngle) {
    this.fontAngle = fontAngle.doubleValue();
}
#method_after
public void setFontAngle(Double fontAngle) {
    this.fontAngle = fontAngle;
}
#end_block

#method_before
public Double[] getPosition() {
    Double[] retPosition = new Double[3];
    retPosition[0] = new Double(position[0]);
    retPosition[1] = new Double(position[1]);
    retPosition[2] = new Double(position[2]);
    return retPosition;
}
#method_after
public Double[] getPosition() {
    Double[] retPosition = new Double[3];
    retPosition[0] = position[0];
    retPosition[1] = position[1];
    retPosition[2] = position[2];
    return retPosition;
}
#end_block

#method_before
public void setPosition(Double[] position) {
    this.position[0] = position[0].doubleValue();
    this.position[1] = position[1].doubleValue();
    this.position[2] = position[2].doubleValue();
}
#method_after
public void setPosition(Double[] position) {
    this.position[0] = position[0];
    this.position[1] = position[1];
    this.position[2] = position[2];
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("Closed")) {
        returnedProp = PolylineProperty.CLOSED;
    } else if (propertyName.equals("ArrowSizeFactor")) {
        returnedProp = PolylineProperty.ARROWSIZEFACTOR;
    } else if (propertyName.equals("PolylineStyle")) {
        returnedProp = PolylineProperty.POLYLINESTYLE;
    } else if (propertyName.equals("InterpColorVector")) {
        returnedProp = PolylineProperty.INTERPCOLORVECTOR;
    } else if (propertyName.equals("InterpColorMode")) {
        returnedProp = PolylineProperty.INTERPCOLORMODE;
    } else if (propertyName.equals("XShift")) {
        returnedProp = PolylineProperty.XSHIFT;
    } else if (propertyName.equals("YShift")) {
        returnedProp = PolylineProperty.YSHIFT;
    } else if (propertyName.equals("ZShift")) {
        returnedProp = PolylineProperty.ZSHIFT;
    } else if (propertyName.equals("BarWidth")) {
        returnedProp = PolylineProperty.BARWIDTH;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("Closed")) {
        return PolylineProperty.CLOSED;
    } else if (propertyName.equals("ArrowSizeFactor")) {
        return PolylineProperty.ARROWSIZEFACTOR;
    } else if (propertyName.equals("PolylineStyle")) {
        return PolylineProperty.POLYLINESTYLE;
    } else if (propertyName.equals("InterpColorVector")) {
        return PolylineProperty.INTERPCOLORVECTOR;
    } else if (propertyName.equals("InterpColorMode")) {
        return PolylineProperty.INTERPCOLORMODE;
    } else if (propertyName.equals("XShift")) {
        return PolylineProperty.XSHIFT;
    } else if (propertyName.equals("YShift")) {
        return PolylineProperty.YSHIFT;
    } else if (propertyName.equals("ZShift")) {
        return PolylineProperty.ZSHIFT;
    } else if (propertyName.equals("BarWidth")) {
        return PolylineProperty.BARWIDTH;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp;
    if (property == PolylineProperty.CLOSED) {
        returnedProp = getClosed();
    } else if (property == PolylineProperty.ARROWSIZEFACTOR) {
        returnedProp = getArrowSizeFactor();
    } else if (property == PolylineProperty.POLYLINESTYLE) {
        returnedProp = getPolylineStyle();
    } else if (property == PolylineProperty.INTERPCOLORVECTOR) {
        returnedProp = getInterpColorVector();
    } else if (property == PolylineProperty.INTERPCOLORMODE) {
        returnedProp = getInterpColorMode();
    } else if (property == PolylineProperty.XSHIFT) {
        returnedProp = getXShift();
    } else if (property == PolylineProperty.YSHIFT) {
        returnedProp = getYShift();
    } else if (property == PolylineProperty.ZSHIFT) {
        returnedProp = getZShift();
    } else if (property == PolylineProperty.BARWIDTH) {
        returnedProp = getBarWidth();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == PolylineProperty.CLOSED) {
        return getClosed();
    } else if (property == PolylineProperty.ARROWSIZEFACTOR) {
        return getArrowSizeFactor();
    } else if (property == PolylineProperty.POLYLINESTYLE) {
        return getPolylineStyle();
    } else if (property == PolylineProperty.INTERPCOLORVECTOR) {
        return getInterpColorVector();
    } else if (property == PolylineProperty.INTERPCOLORMODE) {
        return getInterpColorMode();
    } else if (property == PolylineProperty.XSHIFT) {
        return getXShift();
    } else if (property == PolylineProperty.YSHIFT) {
        return getYShift();
    } else if (property == PolylineProperty.ZSHIFT) {
        return getZShift();
    } else if (property == PolylineProperty.BARWIDTH) {
        return getBarWidth();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Double getArrowSizeFactor() {
    return new Double(arrowSizeFactor);
}
#method_after
public Double getArrowSizeFactor() {
    return arrowSizeFactor;
}
#end_block

#method_before
public void setArrowSizeFactor(Double arrowSizeFactor) {
    this.arrowSizeFactor = arrowSizeFactor.doubleValue();
}
#method_after
public void setArrowSizeFactor(Double arrowSizeFactor) {
    this.arrowSizeFactor = arrowSizeFactor;
}
#end_block

#method_before
public Double getBarWidth() {
    return new Double(barWidth);
}
#method_after
public Double getBarWidth() {
    return barWidth;
}
#end_block

#method_before
public void setBarWidth(Double barWidth) {
    this.barWidth = barWidth.doubleValue();
}
#method_after
public void setBarWidth(Double barWidth) {
    this.barWidth = barWidth;
}
#end_block

#method_before
public Boolean getClosed() {
    return new Boolean(closed);
}
#method_after
public Boolean getClosed() {
    return closed;
}
#end_block

#method_before
public void setClosed(Boolean closed) {
    this.closed = closed.booleanValue();
}
#method_after
public void setClosed(Boolean closed) {
    this.closed = closed;
}
#end_block

#method_before
public Boolean getInterpColorMode() {
    return new Boolean(interpColorMode);
}
#method_after
public Boolean getInterpColorMode() {
    return interpColorMode;
}
#end_block

#method_before
public void setInterpColorMode(Boolean interpColorMode) {
    this.interpColorMode = interpColorMode.booleanValue();
}
#method_after
public void setInterpColorMode(Boolean interpColorMode) {
    this.interpColorMode = interpColorMode;
}
#end_block

#method_before
public Integer[] getInterpColorVector() {
    Integer[] retVector = new Integer[interpColorVector.length];
    for (int i = 0; i < interpColorVector.length; i++) {
        retVector[i] = new Integer(interpColorVector[i]);
    }
    return retVector;
}
#method_after
public Integer[] getInterpColorVector() {
    Integer[] retVector = new Integer[interpColorVector.length];
    for (int i = 0; i < interpColorVector.length; i++) {
        retVector[i] = interpColorVector[i];
    }
    return retVector;
}
#end_block

#method_before
public void setInterpColorVector(Integer[] interpColorVector) {
    for (int i = 0; i < interpColorVector.length; i++) {
        this.interpColorVector[i] = interpColorVector[i].intValue();
    }
}
#method_after
public void setInterpColorVector(Integer[] interpColorVector) {
    for (int i = 0; i < interpColorVector.length; i++) {
        this.interpColorVector[i] = interpColorVector[i];
    }
}
#end_block

#method_before
public Integer getPolylineStyle() {
    return new Integer(polylineStyle);
}
#method_after
public Integer getPolylineStyle() {
    return polylineStyle;
}
#end_block

#method_before
public void setPolylineStyle(Integer polylineStyle) {
    this.polylineStyle = polylineStyle.intValue();
}
#method_after
public void setPolylineStyle(Integer polylineStyle) {
    this.polylineStyle = polylineStyle;
}
#end_block

#method_before
public double[] getClipBox() {
    double[] retClipBox = new double[clipBox.length];
    for (int i = 0; i < clipBox.length; i++) {
        retClipBox[i] = clipBox[i];
    }
    return retClipBox;
}
#method_after
public Double[] getClipBox() {
    Double[] retClipBox = new Double[clipBox.length];
    for (int i = 0; i < clipBox.length; i++) {
        retClipBox[i] = clipBox[i];
    }
    return retClipBox;
}
#end_block

#method_before
public void setClipBox(double[] clipBox) {
    for (int i = 0; i < clipBox.length; i++) {
        this.clipBox[i] = clipBox[i];
    }
}
#method_after
public void setClipBox(Double[] clipBox) {
    for (int i = 0; i < clipBox.length; i++) {
        this.clipBox[i] = clipBox[i];
    }
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("Text")) {
        returnedProp = TextObjectProperty.TEXT;
    } else if (propertyName.equals("TextString")) {
        // To be modified
        returnedProp = FormattedText.FormattedTextProperty.TEXT;
    } else if (propertyName.equals("Font")) {
        returnedProp = FormattedText.FormattedTextProperty.FONT;
    } else if (propertyName.equals("Style")) {
        returnedProp = Font.FontProperty.STYLE;
    } else if (propertyName.equals("Size")) {
        returnedProp = Font.FontProperty.SIZE;
    } else if (propertyName.equals("Color")) {
        returnedProp = Font.FontProperty.COLOR;
    } else if (propertyName.equals("Fractional")) {
        returnedProp = Font.FontProperty.FRACTIONAL;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("Text")) {
        return TextObjectProperty.TEXT;
    } else if (propertyName.equals("TextString")) {
        // To be modified
        return FormattedText.FormattedTextProperty.TEXT;
    } else if (propertyName.equals("Font")) {
        return FormattedText.FormattedTextProperty.FONT;
    } else if (propertyName.equals("Style")) {
        return Font.FontProperty.STYLE;
    } else if (propertyName.equals("Size")) {
        return Font.FontProperty.SIZE;
    } else if (propertyName.equals("Color")) {
        return Font.FontProperty.COLOR;
    } else if (propertyName.equals("Fractional")) {
        return Font.FontProperty.FRACTIONAL;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp;
    if (property == TextObjectProperty.TEXT) {
        returnedProp = getText();
    } else if (property == FormattedText.FormattedTextProperty.TEXT) {
        returnedProp = getTextString();
    } else if (property == FormattedText.FormattedTextProperty.FONT) {
        returnedProp = getFont();
    } else if (property == Font.FontProperty.STYLE) {
        returnedProp = getFontStyle();
    } else if (property == Font.FontProperty.SIZE) {
        returnedProp = getFontSize();
    } else if (property == Font.FontProperty.COLOR) {
        returnedProp = getFontColor();
    } else if (property == Font.FontProperty.FRACTIONAL) {
        returnedProp = getFontFractional();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == TextObjectProperty.TEXT) {
        return getText();
    } else if (property == FormattedText.FormattedTextProperty.TEXT) {
        return getTextString();
    } else if (property == FormattedText.FormattedTextProperty.FONT) {
        return getFont();
    } else if (property == Font.FontProperty.STYLE) {
        return getFontStyle();
    } else if (property == Font.FontProperty.SIZE) {
        return getFontSize();
    } else if (property == Font.FontProperty.COLOR) {
        return getFontColor();
    } else if (property == Font.FontProperty.FRACTIONAL) {
        return getFontFractional();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public Integer getFontStyle() {
    return new Integer(text.getFont().getStyle());
}
#method_after
public Integer getFontStyle() {
    return text.getFont().getStyle();
}
#end_block

#method_before
public Integer getFontColor() {
    return new Integer(text.getFont().getColor());
}
#method_after
public Integer getFontColor() {
    return text.getFont().getColor();
}
#end_block

#method_before
public Double getFontSize() {
    return new Double(text.getFont().getSize());
}
#method_after
public Double getFontSize() {
    return text.getFont().getSize();
}
#end_block

#method_before
public Boolean getFontFractional() {
    return new Boolean(text.getFont().getFractional());
}
#method_after
public Boolean getFontFractional() {
    return text.getFont().getFractional();
}
#end_block

#method_before
public Object getPropertyFromName(String propertyName) {
    Object returnedProp;
    if (propertyName.equals("Axes")) {
        returnedProp = AxesProperty.AXES;
    } else if (propertyName.equals("XAxis")) {
        returnedProp = AxesProperty.XAXIS;
    } else if (propertyName.equals("YAxis")) {
        returnedProp = AxesProperty.YAXIS;
    } else if (propertyName.equals("ZAxis")) {
        returnedProp = AxesProperty.ZAXIS;
    } else if (propertyName.equals("GridPosition")) {
        returnedProp = AxesProperty.GRIDPOSITION;
    } else if (propertyName.equals("Title")) {
        returnedProp = AxesProperty.TITLE;
    } else if (propertyName.equals("AutoClear")) {
        returnedProp = AxesProperty.AUTOCLEAR;
    } else if (propertyName.equals("Filled")) {
        returnedProp = AxesProperty.FILLED;
    } else if (propertyName.equals("Camera")) {
        returnedProp = AxesProperty.CAMERA;
    } else if (propertyName.equals("View")) {
        returnedProp = Camera.CameraProperty.VIEW;
    } else if (propertyName.equals("IsoView")) {
        returnedProp = Camera.CameraProperty.ISOVIEW;
    } else if (propertyName.equals("CubeScaling")) {
        returnedProp = Camera.CameraProperty.CUBESCALING;
    } else if (propertyName.equals("RotationAngles")) {
        returnedProp = Camera.CameraProperty.ROTATIONANGLES;
    } else if (propertyName.equals("Box")) {
        returnedProp = AxesProperty.BOX;
    } else if (propertyName.equals("BoxType")) {
        returnedProp = Box.BoxProperty.BOX;
    } else if (propertyName.equals("HiddenAxisColor")) {
        returnedProp = Box.BoxProperty.HIDDENAXISCOLOR;
    } else if (propertyName.equals("TightLimits")) {
        returnedProp = Box.BoxProperty.TIGHTLIMITS;
    } else if (propertyName.equals("DataBounds")) {
        returnedProp = Box.BoxProperty.DATABOUNDS;
    } else if (propertyName.equals("RealDataBounds")) {
        returnedProp = Box.BoxProperty.REALDATABOUNDS;
    } else if (propertyName.equals("ZoomBox")) {
        returnedProp = Box.BoxProperty.ZOOMBOX;
    } else if (propertyName.equals("AutoScale")) {
        returnedProp = Box.BoxProperty.AUTOSCALE;
    } else if (propertyName.equals("Margins")) {
        returnedProp = AxesProperty.MARGINS;
    } else if (propertyName.equals("AxesBounds")) {
        returnedProp = AxesProperty.AXESBOUNDS;
    } else {
        returnedProp = super.getPropertyFromName(propertyName);
    }
    return (Object) returnedProp;
}
#method_after
public Object getPropertyFromName(String propertyName) {
    if (propertyName.equals("Axes")) {
        return AxesProperty.AXES;
    } else if (propertyName.equals("XAxis")) {
        return AxesProperty.XAXIS;
    } else if (propertyName.equals("XAxisVisible")) {
        return AxesProperty.XAXISVISIBLE;
    } else if (propertyName.equals("XAxisReverse")) {
        return AxesProperty.XAXISREVERSE;
    } else if (propertyName.equals("XAxisGridColor")) {
        return AxesProperty.XAXISGRIDCOLOR;
    } else if (propertyName.equals("XAxisLabel")) {
        return AxesProperty.XAXISLABEL;
    } else if (propertyName.equals("XAxisLocation")) {
        return AxesProperty.XAXISLOCATION;
    } else if (propertyName.equals("XAxisLogFlag")) {
        return AxesProperty.XAXISLOGFLAG;
    } else if (propertyName.equals("XAxisTicks")) {
        return AxesProperty.XAXISTICKS;
    } else if (propertyName.equals("XAxisAutoTicks")) {
        return AxesProperty.XAXISAUTOTICKS;
    } else if (propertyName.equals("XAxisTicksLocations")) {
        return AxesProperty.XAXISTICKSLOCATIONS;
    } else if (propertyName.equals("XAxisTicksLabels")) {
        return AxesProperty.XAXISTICKSLABELS;
    } else if (propertyName.equals("XAxisSubticks")) {
        return AxesProperty.XAXISSUBTICKS;
    } else if (propertyName.equals("YAxis")) {
        return AxesProperty.YAXIS;
    } else if (propertyName.equals("YAxisVisible")) {
        return AxesProperty.YAXISVISIBLE;
    } else if (propertyName.equals("YAxisReverse")) {
        return AxesProperty.YAXISREVERSE;
    } else if (propertyName.equals("YAxisGridColor")) {
        return AxesProperty.YAXISGRIDCOLOR;
    } else if (propertyName.equals("YAxisLabel")) {
        return AxesProperty.YAXISLABEL;
    } else if (propertyName.equals("YAxisLocation")) {
        return AxesProperty.YAXISLOCATION;
    } else if (propertyName.equals("YAxisLogFlag")) {
        return AxesProperty.YAXISLOGFLAG;
    } else if (propertyName.equals("YAxisTicks")) {
        return AxesProperty.YAXISTICKS;
    } else if (propertyName.equals("YAxisAutoTicks")) {
        return AxesProperty.YAXISAUTOTICKS;
    } else if (propertyName.equals("YAxisTicksLocations")) {
        return AxesProperty.YAXISTICKSLOCATIONS;
    } else if (propertyName.equals("YAxisTicksLabels")) {
        return AxesProperty.YAXISTICKSLABELS;
    } else if (propertyName.equals("YAxisSubticks")) {
        return AxesProperty.YAXISSUBTICKS;
    } else if (propertyName.equals("ZAxis")) {
        return AxesProperty.ZAXIS;
    } else if (propertyName.equals("ZAxisVisible")) {
        return AxesProperty.ZAXISVISIBLE;
    } else if (propertyName.equals("ZAxisReverse")) {
        return AxesProperty.ZAXISREVERSE;
    } else if (propertyName.equals("ZAxisGridColor")) {
        return AxesProperty.ZAXISGRIDCOLOR;
    } else if (propertyName.equals("ZAxisLabel")) {
        return AxesProperty.ZAXISLABEL;
    } else if (propertyName.equals("ZAxisLocation")) {
        return AxesProperty.ZAXISLOCATION;
    } else if (propertyName.equals("ZAxisLogFlag")) {
        return AxesProperty.ZAXISLOGFLAG;
    } else if (propertyName.equals("ZAxisTicks")) {
        return AxesProperty.ZAXISTICKS;
    } else if (propertyName.equals("ZAxisAutoTicks")) {
        return AxesProperty.ZAXISAUTOTICKS;
    } else if (propertyName.equals("ZAxisTicksLocations")) {
        return AxesProperty.ZAXISTICKSLOCATIONS;
    } else if (propertyName.equals("ZAxisTicksLabels")) {
        return AxesProperty.ZAXISTICKSLABELS;
    } else if (propertyName.equals("ZAxisSubticks")) {
        return AxesProperty.ZAXISSUBTICKS;
    } else if (propertyName.equals("GridPosition")) {
        return AxesProperty.GRIDPOSITION;
    } else if (propertyName.equals("Title")) {
        return AxesProperty.TITLE;
    } else if (propertyName.equals("AutoClear")) {
        return AxesProperty.AUTOCLEAR;
    } else if (propertyName.equals("Filled")) {
        return AxesProperty.FILLED;
    } else if (propertyName.equals("Camera")) {
        return AxesProperty.CAMERA;
    } else if (propertyName.equals("View")) {
        return Camera.CameraProperty.VIEW;
    } else if (propertyName.equals("IsoView")) {
        return Camera.CameraProperty.ISOVIEW;
    } else if (propertyName.equals("CubeScaling")) {
        return Camera.CameraProperty.CUBESCALING;
    } else if (propertyName.equals("RotationAngles")) {
        return Camera.CameraProperty.ROTATIONANGLES;
    } else if (propertyName.equals("Box")) {
        return AxesProperty.BOX;
    } else if (propertyName.equals("BoxType")) {
        return Box.BoxProperty.BOX;
    } else if (propertyName.equals("HiddenAxisColor")) {
        return Box.BoxProperty.HIDDENAXISCOLOR;
    } else if (propertyName.equals("TightLimits")) {
        return Box.BoxProperty.TIGHTLIMITS;
    } else if (propertyName.equals("DataBounds")) {
        return Box.BoxProperty.DATABOUNDS;
    } else if (propertyName.equals("RealDataBounds")) {
        return Box.BoxProperty.REALDATABOUNDS;
    } else if (propertyName.equals("ZoomBox")) {
        return Box.BoxProperty.ZOOMBOX;
    } else if (propertyName.equals("AutoScale")) {
        return Box.BoxProperty.AUTOSCALE;
    } else if (propertyName.equals("Margins")) {
        return AxesProperty.MARGINS;
    } else if (propertyName.equals("AxesBounds")) {
        return AxesProperty.AXESBOUNDS;
    } else {
        return super.getPropertyFromName(propertyName);
    }
}
#end_block

#method_before
public Object getPropertyFast(Object property) {
    Object returnedProp;
    if (property == AxesProperty.AXES) {
        returnedProp = getAxes();
    } else if (property == AxesProperty.XAXIS) {
        returnedProp = getXAxis();
    } else if (property == AxesProperty.YAXIS) {
        returnedProp = getYAxis();
    } else if (property == AxesProperty.ZAXIS) {
        returnedProp = getZAxis();
    } else if (property == AxesProperty.GRIDPOSITION) {
        returnedProp = getGridPosition();
    } else if (property == AxesProperty.TITLE) {
        returnedProp = getTitle();
    } else if (property == AxesProperty.AUTOCLEAR) {
        returnedProp = getAutoClear();
    } else if (property == AxesProperty.FILLED) {
        returnedProp = getFilled();
    } else if (property == AxesProperty.CAMERA) {
        returnedProp = getCamera();
    } else if (property == Camera.CameraProperty.VIEW) {
        returnedProp = getViewType();
    } else if (property == Camera.CameraProperty.ISOVIEW) {
        returnedProp = getIsoView();
    } else if (property == Camera.CameraProperty.CUBESCALING) {
        returnedProp = getCubeScaling();
    } else if (property == Camera.CameraProperty.ROTATIONANGLES) {
        returnedProp = getRotationAngles();
    } else if (property == AxesProperty.BOX) {
        returnedProp = getBox();
    } else if (property == Box.BoxProperty.BOX) {
        returnedProp = getBoxType();
    } else if (property == Box.BoxProperty.HIDDENAXISCOLOR) {
        returnedProp = getHiddenAxisColor();
    } else if (property == Box.BoxProperty.TIGHTLIMITS) {
        returnedProp = getTightLimits();
    } else if (property == Box.BoxProperty.DATABOUNDS) {
        returnedProp = getDataBounds();
    } else if (property == Box.BoxProperty.REALDATABOUNDS) {
        returnedProp = getRealDataBounds();
    } else if (property == Box.BoxProperty.ZOOMBOX) {
        returnedProp = getZoomBox();
    } else if (property == Box.BoxProperty.AUTOSCALE) {
        returnedProp = getAutoScale();
    } else if (property == AxesProperty.MARGINS) {
        returnedProp = getMargins();
    } else if (property == AxesProperty.AXESBOUNDS) {
        returnedProp = getAxesBounds();
    } else {
        returnedProp = super.getPropertyFast(property);
    }
    return returnedProp;
}
#method_after
public Object getPropertyFast(Object property) {
    if (property == AxesProperty.AXES) {
        return getAxes();
    } else if (property == AxesProperty.XAXIS) {
        return getXAxis();
    } else if (property == AxesProperty.XAXISVISIBLE) {
        return getXAxisVisible();
    } else if (property == AxesProperty.XAXISREVERSE) {
        return getXAxisReverse();
    } else if (property == AxesProperty.XAXISGRIDCOLOR) {
        return getXAxisGridColor();
    } else if (property == AxesProperty.XAXISLABEL) {
        return getXAxisLabel();
    } else if (property == AxesProperty.XAXISLOCATION) {
        return getXAxisLocation();
    } else if (property == AxesProperty.XAXISLOGFLAG) {
        return getXAxisLogFlag();
    } else if (property == AxesProperty.XAXISTICKS) {
        return getXAxisTicks();
    } else if (property == AxesProperty.XAXISAUTOTICKS) {
        return getXAxisAutoTicks();
    } else if (property == AxesProperty.XAXISTICKSLOCATIONS) {
        return getXAxisTicksLocations();
    } else if (property == AxesProperty.XAXISTICKSLABELS) {
        return getXAxisTicksLabels();
    } else if (property == AxesProperty.XAXISSUBTICKS) {
        return getXAxisSubticks();
    } else if (property == AxesProperty.YAXIS) {
        return getYAxis();
    } else if (property == AxesProperty.YAXISVISIBLE) {
        return getYAxisVisible();
    } else if (property == AxesProperty.YAXISREVERSE) {
        return getYAxisReverse();
    } else if (property == AxesProperty.YAXISGRIDCOLOR) {
        return getYAxisGridColor();
    } else if (property == AxesProperty.YAXISLABEL) {
        return getYAxisLabel();
    } else if (property == AxesProperty.YAXISLOCATION) {
        return getYAxisLocation();
    } else if (property == AxesProperty.YAXISLOGFLAG) {
        return getYAxisLogFlag();
    } else if (property == AxesProperty.YAXISTICKS) {
        return getYAxisTicks();
    } else if (property == AxesProperty.YAXISAUTOTICKS) {
        return getYAxisAutoTicks();
    } else if (property == AxesProperty.YAXISTICKSLOCATIONS) {
        return getYAxisTicksLocations();
    } else if (property == AxesProperty.YAXISTICKSLABELS) {
        return getYAxisTicksLabels();
    } else if (property == AxesProperty.YAXISSUBTICKS) {
        return getYAxisSubticks();
    } else if (property == AxesProperty.ZAXIS) {
        return getZAxis();
    } else if (property == AxesProperty.ZAXISVISIBLE) {
        return getZAxisVisible();
    } else if (property == AxesProperty.ZAXISREVERSE) {
        return getZAxisReverse();
    } else if (property == AxesProperty.ZAXISGRIDCOLOR) {
        return getZAxisGridColor();
    } else if (property == AxesProperty.ZAXISLABEL) {
        return getZAxisLabel();
    } else if (property == AxesProperty.ZAXISLOCATION) {
        return getZAxisLocation();
    } else if (property == AxesProperty.ZAXISLOGFLAG) {
        return getZAxisLogFlag();
    } else if (property == AxesProperty.ZAXISTICKS) {
        return getZAxisTicks();
    } else if (property == AxesProperty.ZAXISAUTOTICKS) {
        return getZAxisAutoTicks();
    } else if (property == AxesProperty.ZAXISTICKSLOCATIONS) {
        return getZAxisTicksLocations();
    } else if (property == AxesProperty.ZAXISTICKSLABELS) {
        return getZAxisTicksLabels();
    } else if (property == AxesProperty.ZAXISSUBTICKS) {
        return getZAxisSubticks();
    } else if (property == AxesProperty.GRIDPOSITION) {
        return getGridPosition();
    } else if (property == AxesProperty.TITLE) {
        return getTitle();
    } else if (property == AxesProperty.AUTOCLEAR) {
        return getAutoClear();
    } else if (property == AxesProperty.FILLED) {
        return getFilled();
    } else if (property == AxesProperty.CAMERA) {
        return getCamera();
    } else if (property == Camera.CameraProperty.VIEW) {
        return getViewType();
    } else if (property == Camera.CameraProperty.ISOVIEW) {
        return getIsoView();
    } else if (property == Camera.CameraProperty.CUBESCALING) {
        return getCubeScaling();
    } else if (property == Camera.CameraProperty.ROTATIONANGLES) {
        return getRotationAngles();
    } else if (property == AxesProperty.BOX) {
        return getBox();
    } else if (property == Box.BoxProperty.BOX) {
        return getBoxType();
    } else if (property == Box.BoxProperty.HIDDENAXISCOLOR) {
        return getHiddenAxisColor();
    } else if (property == Box.BoxProperty.TIGHTLIMITS) {
        return getTightLimits();
    } else if (property == Box.BoxProperty.DATABOUNDS) {
        return getDataBounds();
    } else if (property == Box.BoxProperty.REALDATABOUNDS) {
        return getRealDataBounds();
    } else if (property == Box.BoxProperty.ZOOMBOX) {
        return getZoomBox();
    } else if (property == Box.BoxProperty.AUTOSCALE) {
        return getAutoScale();
    } else if (property == AxesProperty.MARGINS) {
        return getMargins();
    } else if (property == AxesProperty.AXESBOUNDS) {
        return getAxesBounds();
    } else {
        return super.getPropertyFast(property);
    }
}
#end_block

#method_before
public void setPropertyFast(Object property, Object value) {
    if (property == AxesProperty.AXES) {
        setAxes((AxisProperty[]) value);
    } else if (property == AxesProperty.XAXIS) {
        setXAxis((AxisProperty) value);
    } else if (property == AxesProperty.YAXIS) {
        setYAxis((AxisProperty) value);
    } else if (property == AxesProperty.ZAXIS) {
        setZAxis((AxisProperty) value);
    } else if (property == AxesProperty.GRIDPOSITION) {
        setGridPosition((GridPosition) value);
    } else if (property == AxesProperty.TITLE) {
        setTitle((Label) value);
    } else if (property == AxesProperty.AUTOCLEAR) {
        setAutoClear((Boolean) value);
    } else if (property == AxesProperty.FILLED) {
        setFilled((Boolean) value);
    } else if (property == AxesProperty.CAMERA) {
        setCamera((Camera) value);
    } else if (property == Camera.CameraProperty.VIEW) {
        setViewType((ViewType) value);
    } else if (property == Camera.CameraProperty.ISOVIEW) {
        setIsoView((Boolean) value);
    } else if (property == Camera.CameraProperty.CUBESCALING) {
        setCubeScaling((Boolean) value);
    } else if (property == Camera.CameraProperty.ROTATIONANGLES) {
        setRotationAngles((Double[]) value);
    } else if (property == AxesProperty.BOX) {
        setBox((Box) value);
    } else if (property == Box.BoxProperty.BOX) {
        setBoxType((BoxType) value);
    } else if (property == Box.BoxProperty.HIDDENAXISCOLOR) {
        setHiddenAxisColor((Integer) value);
    } else if (property == Box.BoxProperty.TIGHTLIMITS) {
        setTightLimits((Boolean) value);
    } else if (property == Box.BoxProperty.DATABOUNDS) {
        setDataBounds((Double[]) value);
    } else if (property == Box.BoxProperty.REALDATABOUNDS) {
        setRealDataBounds((Double[]) value);
    } else if (property == Box.BoxProperty.ZOOMBOX) {
        setZoomBox((Double[]) value);
    } else if (property == Box.BoxProperty.AUTOSCALE) {
        setAutoScale((Boolean) value);
    } else if (property == AxesProperty.MARGINS) {
        setMargins((Double[]) value);
    } else if (property == AxesProperty.AXESBOUNDS) {
        setAxesBounds((Double[]) value);
    } else {
        super.setPropertyFast(property, value);
    }
}
#method_after
public void setPropertyFast(Object property, Object value) {
    if (property == AxesProperty.AXES) {
        setAxes((AxisProperty[]) value);
    } else if (property == AxesProperty.XAXIS) {
        setXAxis((AxisProperty) value);
    } else if (property == AxesProperty.XAXISVISIBLE) {
        setXAxisVisible((Boolean) value);
    } else if (property == AxesProperty.XAXISREVERSE) {
        setXAxisReverse((Boolean) value);
    } else if (property == AxesProperty.XAXISGRIDCOLOR) {
        setXAxisGridColor((Integer) value);
    } else if (property == AxesProperty.XAXISLABEL) {
        setXAxisLabel((Label) value);
    } else if (property == AxesProperty.XAXISLOCATION) {
        setXAxisLocation((AxisLocation) value);
    } else if (property == AxesProperty.XAXISLOGFLAG) {
        setXAxisLogFlag((Boolean) value);
    } else if (property == AxesProperty.XAXISTICKS) {
        setXAxisTicks((TicksProperty) value);
    } else if (property == AxesProperty.XAXISAUTOTICKS) {
        setXAxisAutoTicks((Boolean) value);
    } else if (property == AxesProperty.XAXISTICKSLOCATIONS) {
        setXAxisTicksLocation((Double[]) value);
    } else if (property == AxesProperty.XAXISTICKSLABELS) {
        setXAxisTicksLabels((ArrayList<FormattedText>) value);
    } else if (property == AxesProperty.XAXISSUBTICKS) {
        setXAxisSubticks((Integer) value);
    } else if (property == AxesProperty.YAXIS) {
        setYAxis((AxisProperty) value);
    } else if (property == AxesProperty.YAXISVISIBLE) {
        setYAxisVisible((Boolean) value);
    } else if (property == AxesProperty.YAXISREVERSE) {
        setYAxisReverse((Boolean) value);
    } else if (property == AxesProperty.YAXISGRIDCOLOR) {
        setYAxisGridColor((Integer) value);
    } else if (property == AxesProperty.YAXISLABEL) {
        setYAxisLabel((Label) value);
    } else if (property == AxesProperty.YAXISLOCATION) {
        setYAxisLocation((AxisLocation) value);
    } else if (property == AxesProperty.YAXISLOGFLAG) {
        setYAxisLogFlag((Boolean) value);
    } else if (property == AxesProperty.YAXISTICKS) {
        setYAxisTicks((TicksProperty) value);
    } else if (property == AxesProperty.YAXISAUTOTICKS) {
        setYAxisAutoTicks((Boolean) value);
    } else if (property == AxesProperty.YAXISTICKSLOCATIONS) {
        setYAxisTicksLocation((Double[]) value);
    } else if (property == AxesProperty.YAXISTICKSLABELS) {
        setYAxisTicksLabels((ArrayList<FormattedText>) value);
    } else if (property == AxesProperty.YAXISSUBTICKS) {
        setYAxisSubticks((Integer) value);
    } else if (property == AxesProperty.ZAXIS) {
        setZAxis((AxisProperty) value);
    } else if (property == AxesProperty.ZAXISVISIBLE) {
        setZAxisVisible((Boolean) value);
    } else if (property == AxesProperty.ZAXISREVERSE) {
        setZAxisReverse((Boolean) value);
    } else if (property == AxesProperty.ZAXISGRIDCOLOR) {
        setZAxisGridColor((Integer) value);
    } else if (property == AxesProperty.ZAXISLABEL) {
        setZAxisLabel((Label) value);
    } else if (property == AxesProperty.ZAXISLOCATION) {
        setZAxisLocation((AxisLocation) value);
    } else if (property == AxesProperty.ZAXISLOGFLAG) {
        setZAxisLogFlag((Boolean) value);
    } else if (property == AxesProperty.ZAXISTICKS) {
        setZAxisTicks((TicksProperty) value);
    } else if (property == AxesProperty.ZAXISAUTOTICKS) {
        setZAxisAutoTicks((Boolean) value);
    } else if (property == AxesProperty.ZAXISTICKSLOCATIONS) {
        setZAxisTicksLocation((Double[]) value);
    } else if (property == AxesProperty.ZAXISTICKSLABELS) {
        setZAxisTicksLabels((ArrayList<FormattedText>) value);
    } else if (property == AxesProperty.ZAXISSUBTICKS) {
        setZAxisSubticks((Integer) value);
    } else if (property == AxesProperty.GRIDPOSITION) {
        setGridPosition((GridPosition) value);
    } else if (property == AxesProperty.TITLE) {
        setTitle((Label) value);
    } else if (property == AxesProperty.AUTOCLEAR) {
        setAutoClear((Boolean) value);
    } else if (property == AxesProperty.FILLED) {
        setFilled((Boolean) value);
    } else if (property == AxesProperty.CAMERA) {
        setCamera((Camera) value);
    } else if (property == Camera.CameraProperty.VIEW) {
        setViewType((ViewType) value);
    } else if (property == Camera.CameraProperty.ISOVIEW) {
        setIsoView((Boolean) value);
    } else if (property == Camera.CameraProperty.CUBESCALING) {
        setCubeScaling((Boolean) value);
    } else if (property == Camera.CameraProperty.ROTATIONANGLES) {
        setRotationAngles((Double[]) value);
    } else if (property == AxesProperty.BOX) {
        setBox((Box) value);
    } else if (property == Box.BoxProperty.BOX) {
        setBoxType((BoxType) value);
    } else if (property == Box.BoxProperty.HIDDENAXISCOLOR) {
        setHiddenAxisColor((Integer) value);
    } else if (property == Box.BoxProperty.TIGHTLIMITS) {
        setTightLimits((Boolean) value);
    } else if (property == Box.BoxProperty.DATABOUNDS) {
        setDataBounds((Double[]) value);
    } else if (property == Box.BoxProperty.REALDATABOUNDS) {
        setRealDataBounds((Double[]) value);
    } else if (property == Box.BoxProperty.ZOOMBOX) {
        setZoomBox((Double[]) value);
    } else if (property == Box.BoxProperty.AUTOSCALE) {
        setAutoScale((Boolean) value);
    } else if (property == AxesProperty.MARGINS) {
        setMargins((Double[]) value);
    } else if (property == AxesProperty.AXESBOUNDS) {
        setAxesBounds((Double[]) value);
    } else {
        super.setPropertyFast(property, value);
    }
}
#end_block

#method_before
public Boolean getAutoClear() {
    return new Boolean(autoClear);
}
#method_after
public Boolean getAutoClear() {
    return autoClear;
}
#end_block

#method_before
public void setAutoClear(Boolean autoClear) {
    this.autoClear = autoClear.booleanValue();
}
#method_after
public void setAutoClear(Boolean autoClear) {
    this.autoClear = autoClear;
}
#end_block

#method_before
public Double[] getAxesBounds() {
    Double[] retAxesBounds = new Double[4];
    retAxesBounds[0] = new Double(axesBounds[0]);
    retAxesBounds[1] = new Double(axesBounds[1]);
    retAxesBounds[2] = new Double(axesBounds[2]);
    retAxesBounds[3] = new Double(axesBounds[3]);
    return retAxesBounds;
}
#method_after
public Double[] getAxesBounds() {
    Double[] retAxesBounds = new Double[4];
    retAxesBounds[0] = axesBounds[0];
    retAxesBounds[1] = axesBounds[1];
    retAxesBounds[2] = axesBounds[2];
    retAxesBounds[3] = axesBounds[3];
    return retAxesBounds;
}
#end_block

#method_before
public void setAxesBounds(Double[] axesBounds) {
    this.axesBounds[0] = axesBounds[0].doubleValue();
    this.axesBounds[1] = axesBounds[1].doubleValue();
    this.axesBounds[2] = axesBounds[2].doubleValue();
    this.axesBounds[3] = axesBounds[3].doubleValue();
}
#method_after
public void setAxesBounds(Double[] axesBounds) {
    this.axesBounds[0] = axesBounds[0];
    this.axesBounds[1] = axesBounds[1];
    this.axesBounds[2] = axesBounds[2];
    this.axesBounds[3] = axesBounds[3];
}
#end_block

#method_before
public Integer getHiddenAxisColor() {
    return new Integer(box.getHiddenAxisColor());
}
#method_after
public Integer getHiddenAxisColor() {
    return box.getHiddenAxisColor();
}
#end_block

#method_before
public void setHiddenAxisColor(Integer color) {
    box.setHiddenAxisColor(color.intValue());
}
#method_after
public void setHiddenAxisColor(Integer color) {
    box.setHiddenAxisColor(color);
}
#end_block

#method_before
public Boolean getTightLimits() {
    return new Boolean(box.getTightLimits());
}
#method_after
public Boolean getTightLimits() {
    return box.getTightLimits();
}
#end_block

#method_before
public void setTightLimits(Boolean tightLimits) {
    box.setTightLimits(tightLimits.booleanValue());
}
#method_after
public void setTightLimits(Boolean tightLimits) {
    box.setTightLimits(tightLimits);
}
#end_block

#method_before
public boolean getAutoScale() {
    return box.getAutoScale();
}
#method_after
public Boolean getAutoScale() {
    return box.getAutoScale();
}
#end_block

#method_before
public void setIsoView(Boolean isoView) {
    camera.setIsoview(isoView.booleanValue());
}
#method_after
public void setIsoView(Boolean isoView) {
    camera.setIsoview(isoView);
}
#end_block

#method_before
public void setCubeScaling(Boolean cubeScaling) {
    camera.setCubeScaling(cubeScaling.booleanValue());
}
#method_after
public void setCubeScaling(Boolean cubeScaling) {
    camera.setCubeScaling(cubeScaling);
}
#end_block

#method_before
public Boolean getFilled() {
    return new Boolean(filled);
}
#method_after
public Boolean getFilled() {
    return filled;
}
#end_block

#method_before
public void setFilled(Boolean filled) {
    this.filled = filled.booleanValue();
}
#method_after
public void setFilled(Boolean filled) {
    this.filled = filled;
}
#end_block

#method_before
public Double[] getMargins() {
    Double[] retMargins = new Double[4];
    retMargins[0] = new Double(margins[0]);
    retMargins[1] = new Double(margins[1]);
    retMargins[2] = new Double(margins[2]);
    retMargins[3] = new Double(margins[3]);
    return retMargins;
}
#method_after
public Double[] getMargins() {
    Double[] retMargins = new Double[4];
    retMargins[0] = margins[0];
    retMargins[1] = margins[1];
    retMargins[2] = margins[2];
    retMargins[3] = margins[3];
    return retMargins;
}
#end_block

#method_before
public void setMargins(Double[] margins) {
    this.margins[0] = margins[0].doubleValue();
    this.margins[1] = margins[1].doubleValue();
    this.margins[2] = margins[2].doubleValue();
    this.margins[3] = margins[3].doubleValue();
}
#method_after
public void setMargins(Double[] margins) {
    this.margins[0] = margins[0];
    this.margins[1] = margins[1];
    this.margins[2] = margins[2];
    this.margins[3] = margins[3];
}
#end_block

#method_before
private ScilabType getScilabStringInstance(int size) {
    ScilabType data;
    if (size != 0) {
        data = new ScilabString(new String[size][1]);
    } else {
        data = new ScilabDouble();
    }
    return data;
}
#method_after
private ScilabType getScilabStringInstance(int size) {
    if (size != 0) {
        return new ScilabString(new String[size][1]);
    } else {
        return new ScilabDouble();
    }
}
#end_block

#method_before
private ScilabDouble getScilabDoubleInstance(int size) {
    ScilabDouble data;
    if (size != 0) {
        data = new ScilabDouble(new double[size][1]);
    } else {
        data = new ScilabDouble();
    }
    return data;
}
#method_after
private ScilabDouble getScilabDoubleInstance(int size) {
    if (size != 0) {
        return new ScilabDouble(new double[size][1]);
    } else {
        return new ScilabDouble();
    }
}
#end_block

