496
#method_before
@BeforeClass
public static void startIndexService() throws InterruptedException, ExecutionException {
    if (nodeInfo != null) {
        // do not start Elasticsearch twice
        return;
    }
    nodeInfo = ElasticTestUtils.startElasticsearchNode();
}
#method_after
@BeforeClass
public static void startIndexService() throws InterruptedException, ExecutionException {
    if (nodeInfo != null) {
        // do not start Elasticsearch twice
        return;
    }
    nodeInfo = ElasticTestUtils.startElasticsearchNode();
    createIndexes();
}
#end_block

#method_before
@After
public void cleanupIndex() {
    if (nodeInfo != null) {
        ElasticTestUtils.deleteIndexes(nodeInfo.node);
        ElasticTestUtils.createIndexes(nodeInfo.node);
    }
}
#method_after
@After
public void cleanupIndex() {
    if (nodeInfo != null) {
        ElasticTestUtils.deleteIndexes(nodeInfo.node, INDEX_NAME);
        createIndexes();
    }
}
#end_block

#method_before
@Override
public void replace(AccountState as) throws IOException {
    Bulk bulk = new Bulk.Builder().defaultIndex(indexName).defaultType(ACCOUNTS).addAction(insert(ACCOUNTS, as)).refresh(refresh).build();
    JestResult result = client.execute(bulk);
    if (!result.isSucceeded()) {
        throw new IOException(String.format("Failed to replace change %s in index %s: %s", as.getAccount().getId(), indexName, result.getErrorMessage()));
    }
}
#method_after
@Override
public void replace(AccountState as) throws IOException {
    Bulk bulk = new Bulk.Builder().defaultIndex(indexName).defaultType(ACCOUNTS).addAction(insert(ACCOUNTS, as)).refresh(refresh).build();
    JestResult result = client.execute(bulk);
    if (!result.isSucceeded()) {
        throw new IOException(String.format("Failed to replace account %s in index %s: %s", as.getAccount().getId(), indexName, result.getErrorMessage()));
    }
}
#end_block

#method_before
@Override
protected String getMappings() {
    try {
        return XContentFactory.jsonBuilder().startObject().field("mappings", getMappingProperties(AccountSchemaDefinitions.INSTANCE.getLatest(), ACCOUNTS)).endObject().string();
    } catch (IOException e) {
        throw new RuntimeException("Cannot build mappings for " + ACCOUNTS + " index", e);
    }
}
#method_after
@Override
protected String getMappings() {
    ImmutableMap<String, AccountMapping> mappings = ImmutableMap.of("mappings", mapping);
    return gson.toJson(mappings);
}
#end_block

#method_before
private DataSource open(final Config cfg, final Context context, final DataSourceType dst) {
    ConfigSection dbs = new ConfigSection(cfg, "database");
    String driver = dbs.optional("driver");
    if (Strings.isNullOrEmpty(driver)) {
        driver = dst.getDriver();
    }
    String url = dbs.optional("url");
    if (Strings.isNullOrEmpty(url)) {
        url = dst.getUrl();
    }
    String username = dbs.optional("username");
    String password = dbs.optional("password");
    String interceptor = dbs.optional("dataSourceInterceptorClass");
    boolean usePool;
    if (context == Context.SINGLE_USER) {
        usePool = false;
    } else {
        usePool = cfg.getBoolean("database", "connectionpool", dst.usePool());
    }
    if (usePool) {
        final BasicDataSource ds = new BasicDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        if (username != null && !username.isEmpty()) {
            ds.setUsername(username);
        }
        if (password != null && !password.isEmpty()) {
            ds.setPassword(password);
        }
        ds.setMaxActive(cfg.getInt("database", "poollimit", DEFAULT_POOL_LIMIT));
        ds.setMinIdle(cfg.getInt("database", "poolminidle", 4));
        ds.setMaxIdle(cfg.getInt("database", "poolmaxidle", 4));
        ds.setMaxWait(ConfigUtil.getTimeUnit(cfg, "database", null, "poolmaxwait", MILLISECONDS.convert(30, SECONDS), MILLISECONDS));
        ds.setInitialSize(ds.getMinIdle());
        ds.setValidationQuery(dst.getValidationQuery());
        return intercept(interceptor, ds);
    } else {
        // 
        try {
            final Properties p = new Properties();
            p.setProperty("driver", driver);
            p.setProperty("url", url);
            if (username != null) {
                p.setProperty("user", username);
            }
            if (password != null) {
                p.setProperty("password", password);
            }
            return intercept(interceptor, new SimpleDataSource(p));
        } catch (SQLException se) {
            throw new ProvisionException("Database unavailable", se);
        }
    }
}
#method_after
private DataSource open(final Config cfg, final Context context, final DataSourceType dst) {
    ConfigSection dbs = new ConfigSection(cfg, "database");
    String driver = dbs.optional("driver");
    if (Strings.isNullOrEmpty(driver)) {
        driver = dst.getDriver();
    }
    String url = dbs.optional("url");
    if (Strings.isNullOrEmpty(url)) {
        url = dst.getUrl();
    }
    String username = dbs.optional("username");
    String password = dbs.optional("password");
    String interceptor = dbs.optional("dataSourceInterceptorClass");
    boolean usePool;
    if (context == Context.SINGLE_USER) {
        usePool = false;
    } else {
        usePool = cfg.getBoolean("database", "connectionpool", dst.usePool());
    }
    if (usePool) {
        final BasicDataSource ds = new BasicDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        if (username != null && !username.isEmpty()) {
            ds.setUsername(username);
        }
        if (password != null && !password.isEmpty()) {
            ds.setPassword(password);
        }
        ds.setMaxActive(cfg.getInt("database", "poollimit", DEFAULT_POOL_LIMIT));
        ds.setMinIdle(cfg.getInt("database", "poolminidle", 4));
        ds.setMaxIdle(cfg.getInt("database", "poolmaxidle", 4));
        ds.setMaxWait(ConfigUtil.getTimeUnit(cfg, "database", null, "poolmaxwait", MILLISECONDS.convert(30, SECONDS), MILLISECONDS));
        ds.setInitialSize(ds.getMinIdle());
        ds.setValidationQuery(dst.getValidationQuery());
        ds.setValidationQueryTimeout(5);
        return intercept(interceptor, ds);
    } else {
        // 
        try {
            final Properties p = new Properties();
            p.setProperty("driver", driver);
            p.setProperty("url", url);
            if (username != null) {
                p.setProperty("user", username);
            }
            if (password != null) {
                p.setProperty("password", password);
            }
            return intercept(interceptor, new SimpleDataSource(p));
        } catch (SQLException se) {
            throw new ProvisionException("Database unavailable", se);
        }
    }
}
#end_block

#method_before
@Override
public String getValidationQuery() {
    return "select 1 from dual";
}
#method_after
@Override
public String getValidationQuery() {
    return "SELECT 1 FROM SYSIBM.SYSDUMMY1";
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource rsrc, Input input) throws IOException, AuthException, OrmException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("not allowed index account");
    }
    // evicting the account from the cache, reindexes the account
    accountCache.evict(rsrc.getUser().getAccountId());
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource rsrc, Input input) throws IOException, AuthException, OrmException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("not allowed to index account");
    }
    // evicting the account from the cache, reindexes the account
    accountCache.evict(rsrc.getUser().getAccountId());
    return Response.none();
}
#end_block

#method_before
public void start(WorkQueue workQueue) {
    pool = workQueue.createQueue(config.getPoolThreads(), poolName);
}
#method_after
public void start(WorkQueue workQueue) {
    String poolName = "ReplicateTo-" + config.getRemoteConfig().getName();
    pool = workQueue.createQueue(config.getPoolThreads(), poolName);
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            e.addRef(ref);
            scheduleTask(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        } else if (!e.getRefs().contains(ref)) {
            e.addRef(ref);
            postEvent(e, ref);
        }
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#method_after
void schedule(Project.NameKey project, String ref, URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!shouldReplicate(project, ref, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            addRef(e, ref);
            pool.schedule(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        } else if (!e.getRefs().contains(ref)) {
            addRef(e, ref);
        }
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#end_block

#method_before
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.cancel();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    scheduleTask(pushOp, config.getDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    pushOp.setToRetry();
                    scheduleTask(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    break;
            }
        }
    }
}
#method_after
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.canceledByReplication();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, config.getDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    pushOp.setToRetry();
                    pool.schedule(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    break;
            }
        }
    }
}
#end_block

#method_before
boolean wouldPushProject(final Project.NameKey project) {
    if (!isVisible(project)) {
        return false;
    }
    // by default push all projects
    String[] projects = config.getProjects();
    if (projects.length < 1) {
        return true;
    }
    return (new ReplicationFilter(Arrays.asList(projects))).matches(project);
}
#method_after
boolean wouldPushProject(Project.NameKey project) {
    if (!shouldReplicate(project)) {
        return false;
    }
    // by default push all projects
    List<String> projects = config.getProjects();
    if (projects.isEmpty()) {
        return true;
    }
    return (new ReplicationFilter(projects)).matches(project);
}
#end_block

#method_before
boolean isSingleProjectMatch() {
    String[] projects = config.getProjects();
    boolean ret = (projects.length == 1);
    if (ret) {
        String projectMatch = projects[0];
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#method_after
boolean isSingleProjectMatch() {
    List<String> projects = config.getProjects();
    boolean ret = (projects.size() == 1);
    if (ret) {
        String projectMatch = projects.get(0);
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#end_block

#method_before
boolean wouldPushRef(String ref) {
    if (!config.replicatePermissions() && RefNames.REFS_CONFIG.equals(ref)) {
        return false;
    }
    for (RefSpec s : remote.getPushRefSpecs()) {
        if (s.matchSource(ref)) {
            return true;
        }
    }
    return false;
}
#method_after
boolean wouldPushRef(String ref) {
    if (!config.replicatePermissions() && RefNames.REFS_CONFIG.equals(ref)) {
        return false;
    }
    for (RefSpec s : config.getRemoteConfig().getPushRefSpecs()) {
        if (s.matchSource(ref)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            String remoteNameStyle = config.getRemoteNameStyle();
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (remoteNameStyle.equals("basenameOnly")) {
                name = FilenameUtils.getBaseName(name);
            } else if (!remoteNameStyle.equals("slash")) {
                repLog.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#method_after
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(config.getRemoteConfig().getURIs().size());
    for (URIish uri : config.getRemoteConfig().getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            String remoteNameStyle = config.getRemoteNameStyle();
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (remoteNameStyle.equals("basenameOnly")) {
                name = FilenameUtils.getBaseName(name);
            } else if (!remoteNameStyle.equals("slash")) {
                repLog.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#end_block

#method_before
String[] getAdminUrls() {
    return config.getAdminUrls();
}
#method_after
ImmutableList<String> getAdminUrls() {
    return config.getAdminUrls();
}
#end_block

#method_before
String[] getUrls() {
    return config.getUrls();
}
#method_after
ImmutableList<String> getUrls() {
    return config.getUrls();
}
#end_block

#method_before
String[] getAuthGroupNames() {
    return config.getAuthGroupNames();
}
#method_after
ImmutableList<String> getAuthGroupNames() {
    return config.getAuthGroupNames();
}
#end_block

#method_before
String[] getProjects() {
    return config.getProjects();
}
#method_after
ImmutableList<String> getProjects() {
    return config.getProjects();
}
#end_block

#method_before
private void postEvent(PushOne pushOp, String inputRef) {
    Set<String> refs = inputRef == null ? pushOp.getRefs() : ImmutableSet.of(inputRef);
    Project.NameKey project = pushOp.getProjectNameKey();
    String targetNode = resolveNodeName(pushOp.getURI());
    for (String ref : refs) {
        ReplicationScheduledEvent event = new ReplicationScheduledEvent(project.get(), ref, targetNode);
        eventDispatcher.postEvent(new Branch.NameKey(project, ref), event);
    }
}
#method_after
private void postEvent(PushOne pushOp, String ref) {
    Project.NameKey project = pushOp.getProjectNameKey();
    String targetNode = resolveNodeName(pushOp.getURI());
    ReplicationScheduledEvent event = new ReplicationScheduledEvent(project.get(), ref, targetNode);
    eventDispatcher.get().postEvent(new Branch.NameKey(project, ref), event);
}
#end_block

#method_before
private void postEvent(RefEvent event) {
    try (ReviewDb db = schema.open()) {
        dispatcher.postEvent(event, db);
    } catch (OrmException e) {
        log.error("Cannot post event", e);
    }
}
#method_after
private void postEvent(RefEvent event) {
    try {
        dispatcher.postEvent(event);
    } catch (OrmException e) {
        log.error("Cannot post event", e);
    }
}
#end_block

#method_before
protected ProcessBuilder newBuildProcess(Label label) throws IOException {
    ProcessBuilder proc = new ProcessBuilder("bazel", "build", label.fullName());
    return proc;
}
#method_after
@Override
protected ProcessBuilder newBuildProcess(Label label) throws IOException {
    ProcessBuilder proc = new ProcessBuilder("bazel", "build", label.fullName());
    return proc;
}
#end_block

#method_before
protected ProcessBuilder newBuildProcess(Label label) throws IOException {
    Properties properties = loadBuckProperties(sourceRoot.resolve("buck-out/gen/tools/buck/buck.properties"));
    String buck = firstNonNull(properties.getProperty("buck"), "buck");
    ProcessBuilder proc = new ProcessBuilder(buck, "build", label.fullName());
    if (properties.containsKey("PATH")) {
        proc.environment().put("PATH", properties.getProperty("PATH"));
    }
    return proc;
}
#method_after
@Override
protected ProcessBuilder newBuildProcess(Label label) throws IOException {
    Properties properties = loadBuckProperties(sourceRoot.resolve("buck-out/gen/tools/buck/buck.properties"));
    String buck = firstNonNull(properties.getProperty("buck"), "buck");
    ProcessBuilder proc = new ProcessBuilder(buck, "build", label.fullName());
    if (properties.containsKey("PATH")) {
        proc.environment().put("PATH", properties.getProperty("PATH"));
    }
    return proc;
}
#end_block

#method_before
public void build(Label label) throws IOException, BuildFailureException {
    ProcessBuilder proc = newBuildProcess(label);
    proc.directory(sourceRoot.toFile()).redirectErrorStream(true);
    log.info("building " + label.fullName());
    long start = TimeUtil.nowMs();
    Process rebuild = proc.start();
    byte[] out;
    try (InputStream in = rebuild.getInputStream()) {
        out = ByteStreams.toByteArray(in);
    } finally {
        rebuild.getOutputStream().close();
    }
    int status;
    try {
        status = rebuild.waitFor();
    } catch (InterruptedException e) {
        throw new InterruptedIOException("interrupted waiting for " + proc.toString());
    }
    if (status != 0) {
        log.warn("build failed: " + new String(out));
        throw new BuildFailureException(out);
    }
    long time = TimeUtil.nowMs() - start;
    log.info(String.format("UPDATED    %s in %.3fs", label.fullName(), time / 1000.0));
}
#method_after
public void build(Label label) throws IOException, BuildFailureException {
    ProcessBuilder proc = newBuildProcess(label);
    proc.directory(sourceRoot.toFile()).redirectErrorStream(true);
    log.info("building [" + name() + "] " + label.fullName());
    long start = TimeUtil.nowMs();
    Process rebuild = proc.start();
    byte[] out;
    try (InputStream in = rebuild.getInputStream()) {
        out = ByteStreams.toByteArray(in);
    } finally {
        rebuild.getOutputStream().close();
    }
    int status;
    try {
        status = rebuild.waitFor();
    } catch (InterruptedException e) {
        throw new InterruptedIOException("interrupted waiting for " + proc.toString());
    }
    if (status != 0) {
        log.warn("build failed: " + new String(out));
        throw new BuildFailureException(out);
    }
    long time = TimeUtil.nowMs() - start;
    log.info(String.format("UPDATED    %s in %.3fs", label.fullName(), time / 1000.0));
}
#end_block

#method_before
@Provides
@Singleton
BowerComponentsServlet getBowerComponentsServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    return new BowerComponentsServlet(cache, getPaths().builder);
}
#method_after
@Provides
@Singleton
BowerComponentsDevServlet getBowerComponentsServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    return getPaths().isDev() ? new BowerComponentsDevServlet(cache, getPaths().builder) : null;
}
#end_block

#method_before
@Provides
@Singleton
FontsServlet getFontsServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    return new FontsServlet(cache, getPaths().builder);
}
#method_after
@Provides
@Singleton
FontsDevServlet getFontsServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    return getPaths().isDev() ? new FontsDevServlet(cache, getPaths().builder) : null;
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    String pkg = "gerrit-gwtui";
    String target = "ui_" + rule.select((HttpServletRequest) request);
    if (gwtuiRecompile || !uaInitialized.contains(target)) {
        String rule = "//" + pkg + ":" + target;
        // TODO(davido): instead of assuming specific Buck's internal
        // target directory for gwt_binary() artifacts, ask Buck for
        // the location of user agent permutation GWT zip, e. g.:
        // $ buck targets --show_output //gerrit-gwtui:ui_safari \
        // | awk '{print $2}'
        String child = String.format("%s/__gwt_binary_%s__", pkg, target);
        BuildSystem.Label label = new BuildSystem.Label(pkg, target + ".zip");
        File zip = builder.targetPath(label).toFile();
        synchronized (this) {
            try {
                builder.build(label);
            } catch (BuildSystem.BuildFailureException e) {
                e.display(rule, (HttpServletResponse) res);
                return;
            }
            if (!target.equals(lastTarget) || lastTime != zip.lastModified()) {
                lastTarget = target;
                lastTime = zip.lastModified();
                unpack(zip, unpackedWar.toFile());
            }
        }
        uaInitialized.add(target);
    }
    chain.doFilter(request, res);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    String agent = rule.select((HttpServletRequest) request);
    if (unpackedWar != null && (gwtuiRecompile || !uaInitialized.contains(agent))) {
        Label label = builder.gwtZipLabel(agent);
        File zip = builder.targetPath(label).toFile();
        synchronized (this) {
            try {
                builder.build(label);
            } catch (BuildSystem.BuildFailureException e) {
                e.display(label.toString(), (HttpServletResponse) res);
                return;
            }
            if (!agent.equals(lastAgent) || lastTime != zip.lastModified()) {
                lastAgent = agent;
                lastTime = zip.lastModified();
                unpack(zip, unpackedWar.toFile());
            }
        }
        uaInitialized.add(agent);
    }
    chain.doFilter(request, res);
}
#end_block

#method_before
public static Path resolveInSourceRoot(String name) throws FileNotFoundException {
    // Find ourselves in the classpath, as a loose class file or jar.
    Class<GerritLauncher> self = GerritLauncher.class;
    // If the build system provides us with a source root, use that.
    try (InputStream stream = self.getResourceAsStream(SOURCE_ROOT_RESOURCE)) {
        System.err.println("URL: " + stream);
        if (stream != null) {
            Scanner scan = new java.util.Scanner(stream, "UTF-8").useDelimiter("\n");
            if (scan.hasNext()) {
                Path p = Paths.get(scan.next());
                if (!Files.exists(p)) {
                    throw new FileNotFoundException("source root not found: " + p);
                }
                return p;
            }
        }
    } catch (IOException e) {
    // not Bazel, then.
    }
    URL u = self.getResource(self.getSimpleName() + ".class");
    if (u == null) {
        throw new FileNotFoundException("Cannot find class " + self.getName());
    } else if ("jar".equals(u.getProtocol())) {
        String p = u.getPath();
        try {
            u = new URL(p.substring(0, p.indexOf('!')));
        } catch (MalformedURLException e) {
            FileNotFoundException fnfe = new FileNotFoundException("Not a valid jar file: " + u);
            fnfe.initCause(e);
            throw fnfe;
        }
    }
    if (!"file".equals(u.getProtocol())) {
        throw new FileNotFoundException("Cannot extract path from " + u);
    }
    // Pop up to the top-level source folder by looking for .buckconfig.
    Path dir = Paths.get(u.getPath());
    while (!Files.isRegularFile(dir.resolve(".buckconfig"))) {
        Path parent = dir.getParent();
        if (parent == null) {
            throw new FileNotFoundException("Cannot find source root from " + u);
        }
        dir = parent;
    }
    Path ret = dir.resolve(name);
    if (!Files.exists(ret)) {
        throw new FileNotFoundException(name + " not found in source root " + dir);
    }
    return ret;
}
#method_after
public static Path resolveInSourceRoot(String name) throws FileNotFoundException {
    // Find ourselves in the classpath, as a loose class file or jar.
    Class<GerritLauncher> self = GerritLauncher.class;
    // If the build system provides us with a source root, use that.
    try (InputStream stream = self.getResourceAsStream(SOURCE_ROOT_RESOURCE)) {
        System.err.println("URL: " + stream);
        if (stream != null) {
            try (Scanner scan = new Scanner(stream, UTF_8.name()).useDelimiter("\n")) {
                if (scan.hasNext()) {
                    Path p = Paths.get(scan.next());
                    if (!Files.exists(p)) {
                        throw new FileNotFoundException("source root not found: " + p);
                    }
                    return p;
                }
            }
        }
    } catch (IOException e) {
    // not Bazel, then.
    }
    URL u = self.getResource(self.getSimpleName() + ".class");
    if (u == null) {
        throw new FileNotFoundException("Cannot find class " + self.getName());
    } else if ("jar".equals(u.getProtocol())) {
        String p = u.getPath();
        try {
            u = new URL(p.substring(0, p.indexOf('!')));
        } catch (MalformedURLException e) {
            FileNotFoundException fnfe = new FileNotFoundException("Not a valid jar file: " + u);
            fnfe.initCause(e);
            throw fnfe;
        }
    }
    if (!"file".equals(u.getProtocol())) {
        throw new FileNotFoundException("Cannot extract path from " + u);
    }
    // Pop up to the top-level source folder by looking for .buckconfig.
    Path dir = Paths.get(u.getPath());
    while (!Files.isRegularFile(dir.resolve(".buckconfig"))) {
        Path parent = dir.getParent();
        if (parent == null) {
            throw new FileNotFoundException("Cannot find source root from " + u);
        }
        dir = parent;
    }
    Path ret = dir.resolve(name);
    if (!Files.exists(ret)) {
        throw new FileNotFoundException(name + " not found in source root " + dir);
    }
    return ret;
}
#end_block

#method_before
@Override
public void build(Label label) throws IOException, BuildFailureException {
    log.info("buck build " + label);
    Properties properties = loadBuckProperties(targetPath(label));
    String buck = firstNonNull(properties.getProperty("buck"), "buck");
    ProcessBuilder proc = new ProcessBuilder(buck, "build", label.fullName()).directory(sourceRoot.toFile()).redirectErrorStream(true);
    if (properties.containsKey("PATH")) {
        proc.environment().put("PATH", properties.getProperty("PATH"));
    }
    long start = TimeUtil.nowMs();
    Process rebuild = proc.start();
    byte[] out;
    try (InputStream in = rebuild.getInputStream()) {
        out = ByteStreams.toByteArray(in);
    } finally {
        rebuild.getOutputStream().close();
    }
    int status;
    try {
        status = rebuild.waitFor();
    } catch (InterruptedException e) {
        throw new InterruptedIOException("interrupted waiting for " + buck);
    }
    if (status != 0) {
        throw new BuildFailureException(out);
    }
    long time = TimeUtil.nowMs() - start;
    log.info(String.format("UPDATED    %s in %.3fs", label.fullName(), time / 1000.0));
}
#method_after
@Override
public void build(Label label) throws IOException, BuildFailureException {
    log.info("buck build " + label.fullName());
    Properties properties = loadBuckProperties(sourceRoot.resolve("buck-out/gen/tools/buck/buck.properties"));
    String buck = firstNonNull(properties.getProperty("buck"), "buck");
    ProcessBuilder proc = new ProcessBuilder(buck, "build", label.fullName()).directory(sourceRoot.toFile()).redirectErrorStream(true);
    if (properties.containsKey("PATH")) {
        proc.environment().put("PATH", properties.getProperty("PATH"));
    }
    long start = TimeUtil.nowMs();
    Process rebuild = proc.start();
    byte[] out;
    try (InputStream in = rebuild.getInputStream()) {
        out = ByteStreams.toByteArray(in);
    } finally {
        rebuild.getOutputStream().close();
    }
    int status;
    try {
        status = rebuild.waitFor();
    } catch (InterruptedException e) {
        throw new InterruptedIOException("interrupted waiting for " + buck);
    }
    if (status != 0) {
        throw new BuildFailureException(out);
    }
    long time = TimeUtil.nowMs() - start;
    log.info(String.format("UPDATED    %s in %.3fs", label.fullName(), time / 1000.0));
}
#end_block

#method_before
private static Properties loadBuckProperties(Path gen) throws IOException {
    Properties properties = new Properties();
    Path p = gen.resolve(Paths.get("tools/buck/buck.properties"));
    try (InputStream in = Files.newInputStream(p)) {
        properties.load(in);
    } catch (NoSuchFileException e) {
    // Ignore; will be run from PATH, with a descriptive error if it fails.
    }
    return properties;
}
#method_after
private static Properties loadBuckProperties(Path propPath) throws IOException {
    Properties properties = new Properties();
    try (InputStream in = Files.newInputStream(propPath)) {
        properties.load(in);
    } catch (NoSuchFileException e) {
    // Ignore; will be run from PATH, with a descriptive error if it fails.
    }
    return properties;
}
#end_block

#method_before
@Override
public Path targetPath(Label label) {
    return sourceRoot.resolve("buck-out").resolve("gen").resolve(label.pkg).resolve(label.name).resolve(label.artifact);
}
#method_after
@Override
public Path targetPath(Label label) {
    return sourceRoot.resolve("buck-out").resolve("gen").resolve(label.artifact);
}
#end_block

#method_before
@Override
public void performAction(final String taskIdString, final String actionString) throws IOException {
    int taskId = Integer.parseInt(taskIdString);
    String[] chopped = actionString.split(" ");
    if (chopped.length >= 1) {
        String action = chopped[0];
        switch(action) {
            case "add-project":
                if (chopped.length == 2) {
                    try {
                        String projectName = chopped[1];
                        ProjectInfo projectInfo = conduit.projectQuery(projectName);
                        String projectPhid = projectInfo.getPhid();
                        Set<String> projectPhids = Sets.newHashSet(projectPhid);
                        ManiphestInfo taskInfo = conduit.maniphestInfo(taskId);
                        for (JsonElement jsonElement : taskInfo.getProjectPHIDs().getAsJsonArray()) {
                            projectPhids.add(jsonElement.getAsString());
                        }
                        conduit.maniphestUpdate(taskId, projectPhids);
                    } catch (ConduitException e) {
                        throw new IOException("Error on conduit", e);
                    }
                } else {
                    throw new IOException("Action ' + action + ' expects exactly " + "1 parameter but " + (chopped.length - 1) + " given");
                }
                break;
            default:
                throw new IOException("Unknown action ' + action + '");
        }
    } else {
        throw new IOException("Could not parse action ' + actionString + '");
    }
// No custom actions at this point.
// 
// Note that you can use hashtag names in comments to associate a task
// with a new project.
}
#method_after
@Override
public void performAction(final String taskIdString, final String actionString) throws IOException {
    int taskId = Integer.parseInt(taskIdString);
    String[] chopped = actionString.split(" ");
    if (chopped.length >= 1) {
        String action = chopped[0];
        switch(action) {
            case "add-project":
                if (chopped.length == 2) {
                    try {
                        String projectName = chopped[1];
                        ProjectInfo projectInfo = conduit.projectQuery(projectName);
                        String projectPhid = projectInfo.getPhid();
                        Set<String> projectPhids = Sets.newHashSet(projectPhid);
                        ManiphestInfo taskInfo = conduit.maniphestInfo(taskId);
                        for (JsonElement jsonElement : taskInfo.getProjectPHIDs().getAsJsonArray()) {
                            projectPhids.add(jsonElement.getAsString());
                        }
                        conduit.maniphestUpdate(taskId, projectPhids);
                    } catch (ConduitException e) {
                        throw new IOException("Error on conduit", e);
                    }
                } else {
                    throw new IOException("Action ' + action + ' expects exactly " + "1 parameter but " + (chopped.length - 1) + " given");
                }
                break;
            default:
                throw new IOException("Unknown action ' + action + '");
        }
    } else {
        throw new IOException("Could not parse action ' + actionString + '");
    }
}
#end_block

#method_before
@Test
public void alwaysAddFooters() throws Exception {
    String reviewedBy = "Reviewed-by: Administrator <admin@example.com>";
    PushOneCommit.Result change1 = createChange();
    PushOneCommit.Result change2 = createChange();
    assertThat(getCommitMessage(change1)).doesNotContain(reviewedBy);
    assertThat(getCommitMessage(change2)).doesNotContain(reviewedBy);
    // change1 is a fast-forward, but should be rebased in cherry pick style
    // anyway, making change2 not a fast-forward, requiring a rebase.
    approve(change1);
    submit(change2);
    // ... but both changes should get reviewed-by footers.
    assertThat(getCommitMessage(change1)).contains(reviewedBy);
    // FIXME.
    assertThat(getCommitMessage(change2)).contains(reviewedBy);
}
#method_after
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void alwaysAddFooters() throws Exception {
    PushOneCommit.Result change1 = createChange();
    PushOneCommit.Result change2 = createChange();
    assertThat(getCurrentCommit(change1).getFooterLines(FooterConstants.REVIEWED_BY)).isEmpty();
    assertThat(getCurrentCommit(change2).getFooterLines(FooterConstants.REVIEWED_BY)).isEmpty();
    // change1 is a fast-forward, but should be rebased in cherry pick style
    // anyway, making change2 not a fast-forward, requiring a rebase.
    approve(change1.getChangeId());
    submit(change2.getChangeId());
    // ... but both changes should get reviewed-by footers.
    assertLatestRevisionHasFooters(change1);
    assertLatestRevisionHasFooters(change2);
}
#end_block

#method_before
@Deprecated
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    for (FileCommentGroup group : getGroupedInlineComments()) {
        String link = group.getLink();
        if (link != null) {
            cmts.append(link).append('\n');
        }
        cmts.append(group.getTitle()).append(":\n\n");
        for (Comment c : group.comments) {
            appendComment(cmts, lines, group.fileData, c);
        }
        cmts.append("\n\n");
    }
    return cmts.toString();
}
#method_after
@Deprecated
public String getInlineComments(int lines) {
    try (Repository repo = getRepository()) {
        StringBuilder cmts = new StringBuilder();
        for (FileCommentGroup group : getGroupedInlineComments(repo)) {
            String link = group.getLink();
            if (link != null) {
                cmts.append(link).append('\n');
            }
            cmts.append(group.getTitle()).append(":\n\n");
            for (Comment c : group.comments) {
                appendComment(cmts, lines, group.fileData, c);
            }
            cmts.append("\n\n");
        }
        return cmts.toString();
    }
}
#end_block

#method_before
private List<CommentSender.FileCommentGroup> getGroupedInlineComments() {
    List<CommentSender.FileCommentGroup> groups = new ArrayList<>();
    try (Repository repo = getRepository()) {
        // Get the patch list:
        PatchList patchList = null;
        if (repo != null) {
            try {
                patchList = getPatchList();
            } catch (PatchListNotAvailableException e) {
                log.error("Failed to get patch list", e);
            }
        }
        // Loop over the comments and collect them into groups based on the file
        // location of the comment.
        FileCommentGroup currentGroup = null;
        for (Comment c : inlineComments) {
            // If it's a new group:
            if (currentGroup == null || !c.key.filename.equals(currentGroup.filename) || c.key.patchSetId != currentGroup.patchSetId) {
                currentGroup = new FileCommentGroup();
                currentGroup.filename = c.key.filename;
                currentGroup.patchSetId = c.key.patchSetId;
                groups.add(currentGroup);
                if (patchList != null) {
                    try {
                        currentGroup.fileData = new PatchFile(repo, patchList, c.key.filename);
                    } catch (IOException e) {
                        log.warn(String.format("Cannot load %s from %s in %s", c.key.filename, patchList.getNewId().name(), projectState.getProject().getName()), e);
                        currentGroup.fileData = null;
                    }
                }
            }
            if (currentGroup.fileData != null) {
                currentGroup.comments.add(c);
            }
        }
    }
    Collections.sort(groups, Comparator.comparing(g -> g.filename, FilenameComparator.INSTANCE));
    return groups;
}
#method_after
private List<CommentSender.FileCommentGroup> getGroupedInlineComments(Repository repo) {
    List<CommentSender.FileCommentGroup> groups = new ArrayList<>();
    // Get the patch list:
    PatchList patchList = null;
    if (repo != null) {
        try {
            patchList = getPatchList();
        } catch (PatchListNotAvailableException e) {
            log.error("Failed to get patch list", e);
        }
    }
    // Loop over the comments and collect them into groups based on the file
    // location of the comment.
    FileCommentGroup currentGroup = null;
    for (Comment c : inlineComments) {
        // If it's a new group:
        if (currentGroup == null || !c.key.filename.equals(currentGroup.filename) || c.key.patchSetId != currentGroup.patchSetId) {
            currentGroup = new FileCommentGroup();
            currentGroup.filename = c.key.filename;
            currentGroup.patchSetId = c.key.patchSetId;
            groups.add(currentGroup);
            if (patchList != null) {
                try {
                    currentGroup.fileData = new PatchFile(repo, patchList, c.key.filename);
                } catch (IOException e) {
                    log.warn(String.format("Cannot load %s from %s in %s", c.key.filename, patchList.getNewId().name(), projectState.getProject().getName()), e);
                    currentGroup.fileData = null;
                }
            }
        }
        if (currentGroup.fileData != null) {
            currentGroup.comments.add(c);
        }
    }
    Collections.sort(groups, Comparator.comparing(g -> g.filename, FilenameComparator.INSTANCE));
    return groups;
}
#end_block

#method_before
private List<String> getLinesOfComment(Comment comment, PatchFile fileData) {
    List<String> lines = new ArrayList<>();
    if (comment.range == null) {
        lines.add(getLine(fileData, comment.side, comment.lineNbr));
    } else {
        lines.addAll(getLinesByRange(comment.range, fileData, comment.side));
    }
    return lines;
}
#method_after
private List<String> getLinesOfComment(Comment comment, PatchFile fileData) {
    List<String> lines = new ArrayList<>();
    if (comment.lineNbr == 0) {
        // file level comment has no line
        return lines;
    }
    if (comment.range == null) {
        lines.add(getLine(fileData, comment.side, comment.lineNbr));
    } else {
        lines.addAll(getLinesByRange(comment.range, fileData, comment.side));
    }
    return lines;
}
#end_block

#method_before
private List<Map<String, Object>> getCommentGroupsTemplateData() {
    List<Map<String, Object>> commentGroups = new ArrayList<>();
    for (CommentSender.FileCommentGroup group : getGroupedInlineComments()) {
        Map<String, Object> groupData = new HashMap<>();
        groupData.put("link", group.getLink());
        groupData.put("title", group.getTitle());
        groupData.put("patchSetId", group.patchSetId);
        List<Map<String, Object>> commentsList = new ArrayList<>();
        for (Comment comment : group.comments) {
            Map<String, Object> commentData = new HashMap<>();
            commentData.put("lines", getLinesOfComment(comment, group.fileData));
            commentData.put("message", comment.message.trim());
            // Set the prefix.
            String prefix = getCommentLinePrefix(comment);
            commentData.put("linePrefix", prefix);
            commentData.put("linePrefixEmpty", Strings.padStart(": ", prefix.length(), ' '));
            // Set line numbers.
            int startLine;
            if (comment.range == null) {
                startLine = comment.lineNbr;
            } else {
                startLine = comment.range.startLine;
                commentData.put("endLine", comment.range.endLine);
            }
            commentData.put("startLine", startLine);
            // Set the comment link.
            if (comment.lineNbr == 0) {
                commentData.put("link", group.getLink());
            } else if (comment.side == 0) {
                commentData.put("link", group.getLink() + "@a" + startLine);
            } else {
                commentData.put("link", group.getLink() + '@' + startLine);
            }
            // Set robot comment data.
            if (comment instanceof RobotComment) {
                RobotComment robotComment = (RobotComment) comment;
                commentData.put("isRobotComment", true);
                commentData.put("robotId", robotComment.robotId);
                commentData.put("robotRunId", robotComment.robotRunId);
                commentData.put("robotUrl", robotComment.url);
            } else {
                commentData.put("isRobotComment", false);
            }
            // Set parent comment info.
            Optional<Comment> parent = getParent(comment);
            if (parent.isPresent()) {
                commentData.put("parentMessage", getShortenedCommentMessage(parent.get()));
            }
            commentsList.add(commentData);
        }
        groupData.put("comments", commentsList);
        commentGroups.add(groupData);
    }
    return commentGroups;
}
#method_after
private List<Map<String, Object>> getCommentGroupsTemplateData(Repository repo) {
    List<Map<String, Object>> commentGroups = new ArrayList<>();
    for (CommentSender.FileCommentGroup group : getGroupedInlineComments(repo)) {
        Map<String, Object> groupData = new HashMap<>();
        groupData.put("link", group.getLink());
        groupData.put("title", group.getTitle());
        groupData.put("patchSetId", group.patchSetId);
        List<Map<String, Object>> commentsList = new ArrayList<>();
        for (Comment comment : group.comments) {
            Map<String, Object> commentData = new HashMap<>();
            commentData.put("lines", getLinesOfComment(comment, group.fileData));
            commentData.put("message", comment.message.trim());
            // Set the prefix.
            String prefix = getCommentLinePrefix(comment);
            commentData.put("linePrefix", prefix);
            commentData.put("linePrefixEmpty", Strings.padStart(": ", prefix.length(), ' '));
            // Set line numbers.
            int startLine;
            if (comment.range == null) {
                startLine = comment.lineNbr;
            } else {
                startLine = comment.range.startLine;
                commentData.put("endLine", comment.range.endLine);
            }
            commentData.put("startLine", startLine);
            // Set the comment link.
            if (comment.lineNbr == 0) {
                commentData.put("link", group.getLink());
            } else if (comment.side == 0) {
                commentData.put("link", group.getLink() + "@a" + startLine);
            } else {
                commentData.put("link", group.getLink() + '@' + startLine);
            }
            // Set robot comment data.
            if (comment instanceof RobotComment) {
                RobotComment robotComment = (RobotComment) comment;
                commentData.put("isRobotComment", true);
                commentData.put("robotId", robotComment.robotId);
                commentData.put("robotRunId", robotComment.robotRunId);
                commentData.put("robotUrl", robotComment.url);
            } else {
                commentData.put("isRobotComment", false);
            }
            // Set parent comment info.
            Optional<Comment> parent = getParent(comment);
            if (parent.isPresent()) {
                commentData.put("parentMessage", getShortenedCommentMessage(parent.get()));
            }
            commentsList.add(commentData);
        }
        groupData.put("comments", commentsList);
        commentGroups.add(groupData);
    }
    return commentGroups;
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("commentFiles", getCommentGroupsTemplateData());
    soyContext.put("commentTimestamp", getCommentTimestamp());
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    try (Repository repo = getRepository()) {
        soyContext.put("commentFiles", getCommentGroupsTemplateData(repo));
    }
    soyContext.put("commentTimestamp", getCommentTimestamp());
}
#end_block

#method_before
private String getCommentTimestamp() {
    // Grouping is currently done by timestamp.
    return MailUtil.rfcDateformatter.print(new DateTime(timestamp));
}
#method_after
private String getCommentTimestamp() {
    // Grouping is currently done by timestamp.
    return MailUtil.rfcDateformatter.format(ZonedDateTime.ofInstant(timestamp.toInstant(), ZoneId.of("UTC")));
}
#end_block

#method_before
private static void assertHeaders(Map<String, EmailHeader> have, Map<String, Object> want) throws Exception {
    for (Map.Entry<String, Object> entry : want.entrySet()) {
        if (entry.getValue() instanceof String) {
            assertThat(have).containsEntry("X-" + entry.getKey(), new EmailHeader.String((String) entry.getValue()));
        } else if (entry.getValue() instanceof Date) {
            assertThat(have).containsEntry("X-" + entry.getKey(), new EmailHeader.Date((Date) entry.getValue()));
        } else {
            throw new Exception("Object has unsupported type: " + entry.getValue().getClass().getName() + " must be java.util.Date or java.lang.String");
        }
    }
}
#method_after
private static void assertHeaders(Map<String, EmailHeader> have, Map<String, Object> want) throws Exception {
    for (Map.Entry<String, Object> entry : want.entrySet()) {
        if (entry.getValue() instanceof String) {
            assertThat(have).containsEntry("X-" + entry.getKey(), new EmailHeader.String((String) entry.getValue()));
        } else if (entry.getValue() instanceof Date) {
            assertThat(have).containsEntry("X-" + entry.getKey(), new EmailHeader.Date((Date) entry.getValue()));
        } else {
            throw new Exception("Object has unsupported type: " + entry.getValue().getClass().getName() + " must be java.util.Date or java.lang.String for key " + entry.getKey());
        }
    }
}
#end_block

#method_before
private static void assertTextFooter(String body, Map<String, Object> want) throws Exception {
    for (Map.Entry<String, Object> entry : want.entrySet()) {
        if (entry.getValue() instanceof String) {
            assertThat(body).contains(entry.getKey() + ": " + entry.getValue());
        } else if (entry.getValue() instanceof Date) {
            assertThat(body).contains(entry.getKey() + ": " + MailUtil.rfcDateformatter.print(new DateTime(entry.getValue())));
        } else {
            throw new Exception("Object has unsupported type: " + entry.getValue().getClass().getName() + " must be java.util.Date or java.lang.String");
        }
    }
}
#method_after
private static void assertTextFooter(String body, Map<String, Object> want) throws Exception {
    for (Map.Entry<String, Object> entry : want.entrySet()) {
        if (entry.getValue() instanceof String) {
            assertThat(body).contains(entry.getKey() + ": " + entry.getValue());
        } else if (entry.getValue() instanceof Timestamp) {
            assertThat(body).contains(entry.getKey() + ": " + MailUtil.rfcDateformatter.format(ZonedDateTime.ofInstant(((Timestamp) entry.getValue()).toInstant(), ZoneId.of("UTC"))));
        } else {
            throw new Exception("Object has unsupported type: " + entry.getValue().getClass().getName() + " must be java.util.Date or java.lang.String for key " + entry.getKey());
        }
    }
}
#end_block

#method_before
private Map<String, Collection<String>> permittedLabels(ChangeControl ctl, ChangeData cd) throws OrmException {
    if (ctl == null || !ctl.getUser().isIdentifiedUser()) {
        return null;
    }
    Map<String, Short> labels = currentLabels(ctl);
    boolean isMerged = ctl.getChange().getStatus() == Change.Status.MERGED;
    LabelTypes labelTypes = ctl.getLabelTypes();
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null || (isMerged && !type.allowPostSubmit())) {
                continue;
            }
            PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
            for (LabelValue v : type.getValues()) {
                boolean ok = range.contains(v.getValue());
                if (isMerged) {
                    short prev = labels.getOrDefault(type.getName(), (short) 0);
                    ok &= v.getValue() >= prev;
                }
                if (ok) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#method_after
private Map<String, Collection<String>> permittedLabels(ChangeControl ctl, ChangeData cd) throws OrmException {
    if (ctl == null || !ctl.getUser().isIdentifiedUser()) {
        return null;
    }
    Map<String, Short> labels = null;
    boolean isMerged = ctl.getChange().getStatus() == Change.Status.MERGED;
    LabelTypes labelTypes = ctl.getLabelTypes();
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null || (isMerged && !type.allowPostSubmit())) {
                continue;
            }
            PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
            for (LabelValue v : type.getValues()) {
                boolean ok = range.contains(v.getValue());
                if (isMerged) {
                    if (labels == null) {
                        labels = currentLabels(ctl);
                    }
                    short prev = labels.getOrDefault(type.getName(), (short) 0);
                    ok &= v.getValue() >= prev;
                }
                if (ok) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#end_block

#method_before
private void validatePostSubmitLabels(ChangeContext ctx, LabelTypes labelTypes, Map<String, Short> previous, List<PatchSetApproval> ups, List<PatchSetApproval> del) throws ResourceConflictException {
    if (ctx.getChange().getStatus().isOpen()) {
        // Not closed, nothing to validate.
        return;
    } else if (del.isEmpty() && ups.isEmpty()) {
        // No new votes.
        return;
    } else if (ctx.getChange().getStatus() != Change.Status.MERGED) {
        throw new ResourceConflictException("change is closed");
    }
    // Disallow reducing votes on any labels post-submit. This assumes the
    // high values were broadly necessary to submit, so reducing them would
    // make it possible to take a merged change and make it no longer
    // submittable.
    List<PatchSetApproval> reduced = new ArrayList<>(ups.size() + del.size());
    List<String> disallowed = new ArrayList<>(labelTypes.getLabelTypes().size());
    for (PatchSetApproval psa : del) {
        LabelType lt = checkNotNull(labelTypes.byLabel(psa.getLabel()));
        String normName = lt.getName();
        if (!lt.allowPostSubmit()) {
            disallowed.add(normName);
        }
        Short prev = previous.get(normName);
        if (prev != null) {
            reduced.add(psa);
        }
    }
    for (PatchSetApproval psa : ups) {
        LabelType lt = checkNotNull(labelTypes.byLabel(psa.getLabel()));
        String normName = lt.getName();
        if (!lt.allowPostSubmit()) {
            disallowed.add(normName);
        }
        Short prev = previous.get(normName);
        if (prev == null) {
            continue;
        }
        // Should be filtered out above.
        checkState(prev != psa.getValue());
        if (prev > psa.getValue()) {
            reduced.add(psa);
        } else {
            // Set postSubmit bit in ReviewDb; not required for NoteDb, which sets
            // it automatically.
            psa.setPostSubmit(true);
        }
    }
    if (!disallowed.isEmpty()) {
        throw new ResourceConflictException("Voting on labels disallowed after submit: " + disallowed.stream().distinct().sorted().collect(joining(", ")));
    }
    if (!reduced.isEmpty()) {
        throw new ResourceConflictException("Cannot reduce vote on labels for closed change: " + reduced.stream().map(p -> p.getLabel()).distinct().sorted().collect(joining(", ")));
    }
}
#method_after
private void validatePostSubmitLabels(ChangeContext ctx, LabelTypes labelTypes, Map<String, Short> previous, List<PatchSetApproval> ups, List<PatchSetApproval> del) throws ResourceConflictException {
    if (ctx.getChange().getStatus().isOpen()) {
        // Not closed, nothing to validate.
        return;
    } else if (del.isEmpty() && ups.isEmpty()) {
        // No new votes.
        return;
    } else if (ctx.getChange().getStatus() != Change.Status.MERGED) {
        throw new ResourceConflictException("change is closed");
    }
    // Disallow reducing votes on any labels post-submit. This assumes the
    // high values were broadly necessary to submit, so reducing them would
    // make it possible to take a merged change and make it no longer
    // submittable.
    List<PatchSetApproval> reduced = new ArrayList<>(ups.size() + del.size());
    List<String> disallowed = new ArrayList<>(labelTypes.getLabelTypes().size());
    for (PatchSetApproval psa : del) {
        LabelType lt = checkNotNull(labelTypes.byLabel(psa.getLabel()));
        String normName = lt.getName();
        if (!lt.allowPostSubmit()) {
            disallowed.add(normName);
        }
        Short prev = previous.get(normName);
        if (prev != null && prev != 0) {
            reduced.add(psa);
        }
    }
    for (PatchSetApproval psa : ups) {
        LabelType lt = checkNotNull(labelTypes.byLabel(psa.getLabel()));
        String normName = lt.getName();
        if (!lt.allowPostSubmit()) {
            disallowed.add(normName);
        }
        Short prev = previous.get(normName);
        if (prev == null) {
            continue;
        }
        // Should be filtered out above.
        checkState(prev != psa.getValue());
        if (prev > psa.getValue()) {
            reduced.add(psa);
        } else {
            // Set postSubmit bit in ReviewDb; not required for NoteDb, which sets
            // it automatically.
            psa.setPostSubmit(true);
        }
    }
    if (!disallowed.isEmpty()) {
        throw new ResourceConflictException("Voting on labels disallowed after submit: " + disallowed.stream().distinct().sorted().collect(joining(", ")));
    }
    if (!reduced.isEmpty()) {
        throw new ResourceConflictException("Cannot reduce vote on labels for closed change: " + reduced.stream().map(p -> p.getLabel()).distinct().sorted().collect(joining(", ")));
    }
}
#end_block

#method_before
@Test
public void postSubmitApproval() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    String label = "Code-Review";
    ApprovalInfo approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Submit by direct push.
    git().push().setRefSpecs(new RefSpec(r.getCommit().name() + ":refs/heads/master")).call();
    assertThat(gApi.changes().id(changeId).get().status).isEqualTo(ChangeStatus.MERGED);
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Repeating the current label is allowed. Does not flip the postSubmit bit
    // due to deduplication codepath.
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Reducing vote is not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessage("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Increasing vote is allowed.
    gApi.changes().id(changeId).current().review(ReviewInput.approve());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
    // Decreasing to previous post-submit vote is still not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessage("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
}
#method_after
@Test
public void postSubmitApproval() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    String label = "Code-Review";
    ApprovalInfo approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Submit by direct push.
    git().push().setRefSpecs(new RefSpec(r.getCommit().name() + ":refs/heads/master")).call();
    assertThat(gApi.changes().id(changeId).get().status).isEqualTo(ChangeStatus.MERGED);
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    assertPermitted(gApi.changes().id(changeId).get(EnumSet.of(DETAILED_LABELS)), "Code-Review", 1, 2);
    // Repeating the current label is allowed. Does not flip the postSubmit bit
    // due to deduplication codepath.
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Reducing vote is not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessage("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Increasing vote is allowed.
    gApi.changes().id(changeId).current().review(ReviewInput.approve());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
    assertPermitted(gApi.changes().id(changeId).get(EnumSet.of(DETAILED_LABELS)), "Code-Review", 2);
    // Decreasing to previous post-submit vote is still not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessage("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
}
#end_block

#method_before
private ApprovalInfo getApproval(String changeId, String label) throws Exception {
    ChangeInfo info = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    LabelInfo li = info.labels.get(label);
    assertThat(li).isNotNull();
    int accountId = atrScope.get().getUser().getAccountId().get();
    return li.all.stream().filter(a -> a._accountId == accountId).findFirst().get();
}
#method_after
private ApprovalInfo getApproval(String changeId, String label) throws Exception {
    ChangeInfo info = gApi.changes().id(changeId).get(EnumSet.of(DETAILED_LABELS));
    LabelInfo li = info.labels.get(label);
    assertThat(li).isNotNull();
    int accountId = atrScope.get().getUser().getAccountId().get();
    return li.all.stream().filter(a -> a._accountId == accountId).findFirst().get();
}
#end_block

#method_before
private List<ChangeControl> changeFromNotesFactory(String id, final CurrentUser currentUser) throws OrmException {
    List<ChangeNotes> changes = changeNotesFactory.create(db, parseId(id));
    return FluentIterable.from(changes).transform(new Function<ChangeNotes, ChangeControl>() {

        @Override
        public ChangeControl apply(ChangeNotes changeNote) {
            return controlForChange(changeNote, currentUser);
        }
    }).filter(Predicates.notNull()).toList();
}
#method_after
private List<ChangeControl> changeFromNotesFactory(String id, final CurrentUser currentUser) throws OrmException, UnloggedFailure {
    List<ChangeNotes> changes = changeNotesFactory.create(db, parseId(id));
    return FluentIterable.from(changes).transform(new Function<ChangeNotes, ChangeControl>() {

        @Override
        public ChangeControl apply(ChangeNotes changeNote) {
            return controlForChange(changeNote, currentUser);
        }
    }).filter(Predicates.notNull()).toList();
}
#end_block

#method_before
private List<Change.Id> parseId(String id) {
    try {
        return Arrays.asList(new Change.Id(Integer.parseInt(id)));
    } catch (NumberFormatException e) {
        log.error("Invalid change ID " + id, e);
        return Collections.emptyList();
    }
}
#method_after
private List<Change.Id> parseId(String id) throws UnloggedFailure {
    try {
        return Arrays.asList(new Change.Id(Integer.parseInt(id)));
    } catch (NumberFormatException e) {
        throw new UnloggedFailure(2, "Invalid change ID " + id, e);
    }
}
#end_block

#method_before
public List<CodeReviewCommit> sort(Collection<CodeReviewCommit> incoming) throws IOException {
    final List<CodeReviewCommit> sorted = new ArrayList<>();
    final Set<CodeReviewCommit> sort = new HashSet<>(incoming);
    while (!sort.isEmpty()) {
        final CodeReviewCommit n = removeOne(sort);
        rw.resetRetain(canMergeFlag);
        rw.markStart(n);
        if (initialTip != null) {
            rw.markUninteresting(initialTip);
        }
        CodeReviewCommit c;
        final List<CodeReviewCommit> contents = new ArrayList<>();
        while ((c = rw.next()) != null) {
            if (!c.has(canMergeFlag) || !incoming.contains(c)) {
                if (isAlreadyMerged(c)) {
                    rw.markUninteresting(c);
                    continue;
                }
                // 
                if (n.missing == null) {
                    n.setStatusCode(CommitMergeStatus.MISSING_DEPENDENCY);
                    n.missing = new ArrayList<>();
                }
                n.missing.add(c);
            } else {
                contents.add(c);
            }
        }
        if (n.getStatusCode() == CommitMergeStatus.MISSING_DEPENDENCY) {
            continue;
        }
        sort.removeAll(contents);
        Collections.reverse(contents);
        sorted.removeAll(contents);
        sorted.addAll(contents);
    }
    return sorted;
}
#method_after
public List<CodeReviewCommit> sort(Collection<CodeReviewCommit> incoming) throws IOException {
    final List<CodeReviewCommit> sorted = new ArrayList<>();
    final Set<CodeReviewCommit> sort = new HashSet<>(incoming);
    while (!sort.isEmpty()) {
        final CodeReviewCommit n = removeOne(sort);
        rw.resetRetain(canMergeFlag);
        rw.markStart(n);
        if (initialTip != null) {
            rw.markUninteresting(initialTip);
        }
        CodeReviewCommit c;
        final List<CodeReviewCommit> contents = new ArrayList<>();
        while ((c = rw.next()) != null) {
            if (!c.has(canMergeFlag) || !incoming.contains(c)) {
                if (isAlreadyMerged(c)) {
                    rw.markUninteresting(c);
                    break;
                }
                // 
                if (n.missing == null) {
                    n.setStatusCode(CommitMergeStatus.MISSING_DEPENDENCY);
                    n.missing = new ArrayList<>();
                }
                n.missing.add(c);
            } else {
                contents.add(c);
            }
        }
        if (n.getStatusCode() == CommitMergeStatus.MISSING_DEPENDENCY) {
            continue;
        }
        sort.removeAll(contents);
        Collections.reverse(contents);
        sorted.removeAll(contents);
        sorted.addAll(contents);
    }
    return sorted;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
public static <R extends RestResource> Iterable<UiAction.Description> from(DynamicMap<RestView<R>> views, R resource, Provider<CurrentUser> userProvider, Config cfg) {
    return FluentIterable.from(views).transform((DynamicMap.Entry<RestView<R>> e) -> {
        int d = e.getExportName().indexOf('.');
        if (d < 0) {
            return null;
        }
        RestView<R> view;
        try {
            view = e.getProvider().get();
        } catch (RuntimeException err) {
            log.error(String.format("error creating view %s.%s", e.getPluginName(), e.getExportName()), err);
            return null;
        }
        if (!(view instanceof UiAction)) {
            return null;
        }
        try {
            CapabilityUtils.checkRequiresCapability(userProvider, e.getPluginName(), view.getClass());
        } catch (AuthException exc) {
            return null;
        }
        UiAction.Description dsc = ((UiAction<R>) view).getDescription(resource);
        if (dsc == null || !dsc.isVisible()) {
            return null;
        }
        String name = e.getExportName().substring(d + 1);
        PrivateInternals_UiActionDescription.setMethod(dsc, e.getExportName().substring(0, d));
        String id = "gerrit".equals(e.getPluginName()) ? name : e.getPluginName() + '~' + name;
        PrivateInternals_UiActionDescription.setId(dsc, id);
        dsc.setEnabled(cfg.getBoolean("action", id, "enabled", false));
        return dsc;
    }).filter(Objects::nonNull);
}
#method_after
public static <R extends RestResource> FluentIterable<UiAction.Description> from(RestCollection<?, R> collection, R resource, Provider<CurrentUser> userProvider) {
    return from(collection.views(), resource, userProvider);
}
#end_block

#method_before
public Map<String, ActionInfo> format(RevisionResource rsrc) {
    return toActionMap(rsrc);
}
#method_after
public Map<String, ActionInfo> format(RevisionResource rsrc) throws OrmException {
    ChangeInfo changeInfo = null;
    RevisionInfo revisionInfo = null;
    List<ActionVisitor> visitors = visitors();
    if (!visitors.isEmpty()) {
        changeInfo = changeJson().format(rsrc);
        revisionInfo = checkNotNull(Iterables.getOnlyElement(changeInfo.revisions.values()));
        changeInfo.revisions = null;
    }
    return toActionMap(rsrc, visitors, changeInfo, revisionInfo);
}
#end_block

#method_before
public ChangeInfo addChangeActions(ChangeInfo to, ChangeControl ctl) {
    to.actions = toActionMap(ctl);
    return to;
}
#method_after
public ChangeInfo addChangeActions(ChangeInfo to, ChangeControl ctl) {
    List<ActionVisitor> visitors = visitors();
    to.actions = toActionMap(ctl, visitors, copy(visitors, to));
    return to;
}
#end_block

#method_before
public RevisionInfo addRevisionActions(RevisionInfo to, RevisionResource rsrc) {
    to.actions = toActionMap(rsrc);
    return to;
}
#method_after
public RevisionInfo addRevisionActions(@Nullable ChangeInfo changeInfo, RevisionInfo to, RevisionResource rsrc) throws OrmException {
    List<ActionVisitor> visitors = visitors();
    if (!visitors.isEmpty()) {
        if (changeInfo != null) {
            changeInfo = copy(visitors, changeInfo);
        } else {
            changeInfo = changeJson().format(rsrc);
        }
    }
    to.actions = toActionMap(rsrc, visitors, changeInfo, copy(visitors, to));
    return to;
}
#end_block

#method_before
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc) {
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (rsrc.getControl().getUser().isIdentifiedUser()) {
        Provider<CurrentUser> userProvider = Providers.of(rsrc.getControl().getUser());
        for (UiAction.Description d : UiActions.from(revisions, rsrc, userProvider, cfg)) {
            out.put(d.getId(), new ActionInfo(d));
        }
    }
    return out;
}
#method_after
private Map<String, ActionInfo> toActionMap(ChangeControl ctl, List<ActionVisitor> visitors, ChangeInfo changeInfo) {
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (!ctl.getUser().isIdentifiedUser()) {
        return out;
    }
    Provider<CurrentUser> userProvider = Providers.of(ctl.getUser());
    FluentIterable<UiAction.Description> descs = UiActions.from(changeViews, changeResourceFactory.create(ctl), userProvider);
    // resulting action map.
    if (ctl.getChange().getStatus().isOpen()) {
        UiAction.Description descr = new UiAction.Description();
        PrivateInternals_UiActionDescription.setId(descr, "followup");
        PrivateInternals_UiActionDescription.setMethod(descr, "POST");
        descr.setTitle("Create follow-up change");
        descr.setLabel("Follow-Up");
        descs = descs.append(descr);
    }
    ACTION: for (UiAction.Description d : descs) {
        ActionInfo actionInfo = new ActionInfo(d);
        for (ActionVisitor visitor : visitors) {
            if (!visitor.visit(d.getId(), actionInfo, changeInfo)) {
                continue ACTION;
            }
        }
        out.put(d.getId(), actionInfo);
    }
    return out;
}
#end_block

#method_before
@Test
public void testParseMetadataFromHeader() {
    // This tests if the metadata parser is able to parse metadata from the
    // email headers of the message.
    MailMessage.Builder b = MailMessage.builder();
    b.id("");
    b.dateReceived(new DateTime());
    b.subject("");
    b.addAdditionalHeader(toHeaderWithDel(MetadataName.CHANGE_ID) + "cid");
    b.addAdditionalHeader(toHeaderWithDel(MetadataName.PATCH_SET) + "1");
    b.addAdditionalHeader(toHeaderWithDel(MetadataName.MESSAGE_TYPE) + "comment");
    b.addAdditionalHeader(toHeaderWithDel(MetadataName.TIMESTAMP) + "Tue, 25 Oct 2016 02:11:35 -0700");
    Address author = new Address("Diffy", "test@gerritcodereview.com");
    b.from(author);
    MailMetadata meta = MetadataParser.parse(b.build());
    assertThat(meta.author).isEqualTo(author.getEmail());
    assertThat(meta.changeId).isEqualTo("cid");
    assertThat(meta.patchSet).isEqualTo(1);
    assertThat(meta.messageType).isEqualTo("comment");
    assertThat(meta.timestamp.getTime()).isEqualTo(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC).getMillis());
}
#method_after
@Test
public void testParseMetadataFromHeader() {
    // This tests if the metadata parser is able to parse metadata from the
    // email headers of the message.
    MailMessage.Builder b = MailMessage.builder();
    b.id("");
    b.dateReceived(new DateTime());
    b.subject("");
    b.addAdditionalHeader(toHeaderWithDelimiter(MetadataName.CHANGE_ID) + "cid");
    b.addAdditionalHeader(toHeaderWithDelimiter(MetadataName.PATCH_SET) + "1");
    b.addAdditionalHeader(toHeaderWithDelimiter(MetadataName.MESSAGE_TYPE) + "comment");
    b.addAdditionalHeader(toHeaderWithDelimiter(MetadataName.TIMESTAMP) + "Tue, 25 Oct 2016 02:11:35 -0700");
    Address author = new Address("Diffy", "test@gerritcodereview.com");
    b.from(author);
    MailMetadata meta = MetadataParser.parse(b.build());
    assertThat(meta.author).isEqualTo(author.getEmail());
    assertThat(meta.changeId).isEqualTo("cid");
    assertThat(meta.patchSet).isEqualTo(1);
    assertThat(meta.messageType).isEqualTo("comment");
    assertThat(meta.timestamp.getTime()).isEqualTo(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC).getMillis());
}
#end_block

#method_before
@Test
public void testParseMetadataFromText() {
    // This tests if the metadata parser is able to parse metadata from the
    // the text body of the message.
    MailMessage.Builder b = MailMessage.builder();
    b.id("");
    b.dateReceived(new DateTime());
    b.subject("");
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(toFooterWithDel(MetadataName.CHANGE_ID) + "cid" + "\n");
    stringBuilder.append(toFooterWithDel(MetadataName.PATCH_SET) + "1" + "\n");
    stringBuilder.append(toFooterWithDel(MetadataName.MESSAGE_TYPE) + "comment" + "\n");
    stringBuilder.append(toFooterWithDel(MetadataName.TIMESTAMP) + "Tue, 25 Oct 2016 02:11:35 -0700" + "\n");
    b.textContent(stringBuilder.toString());
    Address author = new Address("Diffy", "test@gerritcodereview.com");
    b.from(author);
    MailMetadata meta = MetadataParser.parse(b.build());
    assertThat(meta.author).isEqualTo(author.getEmail());
    assertThat(meta.changeId).isEqualTo("cid");
    assertThat(meta.patchSet).isEqualTo(1);
    assertThat(meta.messageType).isEqualTo("comment");
    assertThat(meta.timestamp.getTime()).isEqualTo(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC).getMillis());
}
#method_after
@Test
public void testParseMetadataFromText() {
    // This tests if the metadata parser is able to parse metadata from the
    // the text body of the message.
    MailMessage.Builder b = MailMessage.builder();
    b.id("");
    b.dateReceived(new DateTime());
    b.subject("");
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(toFooterWithDelimiter(MetadataName.CHANGE_ID) + "cid" + "\n");
    stringBuilder.append(toFooterWithDelimiter(MetadataName.PATCH_SET) + "1" + "\n");
    stringBuilder.append(toFooterWithDelimiter(MetadataName.MESSAGE_TYPE) + "comment" + "\n");
    stringBuilder.append(toFooterWithDelimiter(MetadataName.TIMESTAMP) + "Tue, 25 Oct 2016 02:11:35 -0700" + "\n");
    b.textContent(stringBuilder.toString());
    Address author = new Address("Diffy", "test@gerritcodereview.com");
    b.from(author);
    MailMetadata meta = MetadataParser.parse(b.build());
    assertThat(meta.author).isEqualTo(author.getEmail());
    assertThat(meta.changeId).isEqualTo("cid");
    assertThat(meta.patchSet).isEqualTo(1);
    assertThat(meta.messageType).isEqualTo("comment");
    assertThat(meta.timestamp.getTime()).isEqualTo(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC).getMillis());
}
#end_block

#method_before
@Test
public void testParseMetadataFromHTML() {
    // This tests if the metadata parser is able to parse metadata from the
    // the HTML body of the message.
    MailMessage.Builder b = MailMessage.builder();
    b.id("");
    b.dateReceived(new DateTime());
    b.subject("");
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("<p>" + toFooterWithDel(MetadataName.CHANGE_ID) + "cid" + "</p>");
    stringBuilder.append("<p>" + toFooterWithDel(MetadataName.PATCH_SET) + "1" + "</p>");
    stringBuilder.append("<p>" + toFooterWithDel(MetadataName.MESSAGE_TYPE) + "comment" + "</p>");
    stringBuilder.append("<p>" + toFooterWithDel(MetadataName.TIMESTAMP) + "Tue, 25 Oct 2016 02:11:35 -0700" + "</p>");
    b.htmlContent(stringBuilder.toString());
    Address author = new Address("Diffy", "test@gerritcodereview.com");
    b.from(author);
    MailMetadata meta = MetadataParser.parse(b.build());
    assertThat(meta.author).isEqualTo(author.getEmail());
    assertThat(meta.changeId).isEqualTo("cid");
    assertThat(meta.patchSet).isEqualTo(1);
    assertThat(meta.messageType).isEqualTo("comment");
    assertThat(meta.timestamp.getTime()).isEqualTo(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC).getMillis());
}
#method_after
@Test
public void testParseMetadataFromHTML() {
    // This tests if the metadata parser is able to parse metadata from the
    // the HTML body of the message.
    MailMessage.Builder b = MailMessage.builder();
    b.id("");
    b.dateReceived(new DateTime());
    b.subject("");
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("<p>" + toFooterWithDelimiter(MetadataName.CHANGE_ID) + "cid" + "</p>");
    stringBuilder.append("<p>" + toFooterWithDelimiter(MetadataName.PATCH_SET) + "1" + "</p>");
    stringBuilder.append("<p>" + toFooterWithDelimiter(MetadataName.MESSAGE_TYPE) + "comment" + "</p>");
    stringBuilder.append("<p>" + toFooterWithDelimiter(MetadataName.TIMESTAMP) + "Tue, 25 Oct 2016 02:11:35 -0700" + "</p>");
    b.htmlContent(stringBuilder.toString());
    Address author = new Address("Diffy", "test@gerritcodereview.com");
    b.from(author);
    MailMetadata meta = MetadataParser.parse(b.build());
    assertThat(meta.author).isEqualTo(author.getEmail());
    assertThat(meta.changeId).isEqualTo("cid");
    assertThat(meta.patchSet).isEqualTo(1);
    assertThat(meta.messageType).isEqualTo("comment");
    assertThat(meta.timestamp.getTime()).isEqualTo(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC).getMillis());
}
#end_block

#method_before
public static MailMetadata parse(MailMessage m) {
    MailMetadata metadata = new MailMetadata();
    // Find author
    metadata.author = m.from().getEmail();
    // Check email headers for X-Gerrit-<Name>
    for (String header : m.additionalHeaders()) {
        if (header.startsWith(toHeaderWithDel(MetadataName.CHANGE_ID))) {
            metadata.changeId = header.substring(toHeaderWithDel(MetadataName.CHANGE_ID).length());
        } else if (header.startsWith(toHeaderWithDel(MetadataName.PATCH_SET))) {
            String ps = header.substring(toHeaderWithDel(MetadataName.PATCH_SET).length());
            metadata.patchSet = Ints.tryParse(ps);
        } else if (header.startsWith(toHeaderWithDel(MetadataName.TIMESTAMP))) {
            String ts = header.substring(toHeaderWithDel(MetadataName.TIMESTAMP).length());
            metadata.timestamp = Timestamp.from(MailUtil.rfcDateformatter.parse(ts, Instant::from));
        } else if (header.startsWith(toHeaderWithDel(MetadataName.MESSAGE_TYPE))) {
            metadata.messageType = header.substring(toHeaderWithDel(MetadataName.MESSAGE_TYPE).length());
        }
    }
    if (metadata.hasRequiredFields()) {
        return metadata;
    }
    // If the required fields were not yet found, continue to parse the text
    if (!Strings.isNullOrEmpty(m.textContent())) {
        String[] lines = m.textContent().split("\n");
        extractFooters(lines, metadata);
        if (metadata.hasRequiredFields()) {
            return metadata;
        }
    }
    // HTML footer are contained inside a <p> tag
    if (!Strings.isNullOrEmpty(m.htmlContent())) {
        String[] lines = m.htmlContent().split("</p>");
        extractFooters(lines, metadata);
        if (metadata.hasRequiredFields()) {
            return metadata;
        }
    }
    return metadata;
}
#method_after
public static MailMetadata parse(MailMessage m) {
    MailMetadata metadata = new MailMetadata();
    // Find author
    metadata.author = m.from().getEmail();
    // Check email headers for X-Gerrit-<Name>
    for (String header : m.additionalHeaders()) {
        if (header.startsWith(toHeaderWithDelimiter(MetadataName.CHANGE_ID))) {
            metadata.changeId = header.substring(toHeaderWithDelimiter(MetadataName.CHANGE_ID).length());
        } else if (header.startsWith(toHeaderWithDelimiter(MetadataName.PATCH_SET))) {
            String ps = header.substring(toHeaderWithDelimiter(MetadataName.PATCH_SET).length());
            metadata.patchSet = Ints.tryParse(ps);
        } else if (header.startsWith(toHeaderWithDelimiter(MetadataName.TIMESTAMP))) {
            String ts = header.substring(toHeaderWithDelimiter(MetadataName.TIMESTAMP).length());
            metadata.timestamp = Timestamp.from(MailUtil.rfcDateformatter.parse(ts, Instant::from));
        } else if (header.startsWith(toHeaderWithDelimiter(MetadataName.MESSAGE_TYPE))) {
            metadata.messageType = header.substring(toHeaderWithDelimiter(MetadataName.MESSAGE_TYPE).length());
        }
    }
    if (metadata.hasRequiredFields()) {
        return metadata;
    }
    // If the required fields were not yet found, continue to parse the text
    if (!Strings.isNullOrEmpty(m.textContent())) {
        String[] lines = m.textContent().split("\n");
        extractFooters(lines, metadata);
        if (metadata.hasRequiredFields()) {
            return metadata;
        }
    }
    // HTML footer are contained inside a <p> tag
    if (!Strings.isNullOrEmpty(m.htmlContent())) {
        String[] lines = m.htmlContent().split("</p>");
        extractFooters(lines, metadata);
        if (metadata.hasRequiredFields()) {
            return metadata;
        }
    }
    return metadata;
}
#end_block

#method_before
private static void extractFooters(String[] lines, MailMetadata metadata) {
    for (String line : lines) {
        if (metadata.changeId == null && line.contains(MetadataName.CHANGE_ID)) {
            metadata.changeId = extractFooter(toFooterWithDel(MetadataName.CHANGE_ID), line);
        } else if (metadata.patchSet == null && line.contains(MetadataName.PATCH_SET)) {
            metadata.patchSet = Ints.tryParse(extractFooter(toFooterWithDel(MetadataName.PATCH_SET), line));
        } else if (metadata.timestamp == null && line.contains(MetadataName.TIMESTAMP)) {
            String ts = extractFooter(toFooterWithDel(MetadataName.TIMESTAMP), line);
            metadata.timestamp = Timestamp.from(MailUtil.rfcDateformatter.parse(ts, Instant::from));
        } else if (metadata.messageType == null && line.contains(MetadataName.MESSAGE_TYPE)) {
            metadata.messageType = extractFooter(toFooterWithDel(MetadataName.MESSAGE_TYPE), line);
        }
    }
}
#method_after
private static void extractFooters(String[] lines, MailMetadata metadata) {
    for (String line : lines) {
        if (metadata.changeId == null && line.contains(MetadataName.CHANGE_ID)) {
            metadata.changeId = extractFooter(toFooterWithDelimiter(MetadataName.CHANGE_ID), line);
        } else if (metadata.patchSet == null && line.contains(MetadataName.PATCH_SET)) {
            metadata.patchSet = Ints.tryParse(extractFooter(toFooterWithDelimiter(MetadataName.PATCH_SET), line));
        } else if (metadata.timestamp == null && line.contains(MetadataName.TIMESTAMP)) {
            String ts = extractFooter(toFooterWithDelimiter(MetadataName.TIMESTAMP), line);
            metadata.timestamp = Timestamp.from(MailUtil.rfcDateformatter.parse(ts, Instant::from));
        } else if (metadata.messageType == null && line.contains(MetadataName.MESSAGE_TYPE)) {
            metadata.messageType = extractFooter(toFooterWithDelimiter(MetadataName.MESSAGE_TYPE), line);
        }
    }
}
#end_block

#method_before
public boolean hasRequiredFields() {
    return changeId != null && patchSet != null && author != null && timestamp != null;
}
#method_after
public boolean hasRequiredFields() {
    return changeId != null && patchSet != null && author != null && timestamp != null && messageType != null;
}
#end_block

#method_before
@Override
public String toString() {
    return changeId + patchSet + author + timestamp + messageType;
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("Change-Id", changeId).add("Patch-Set", patchSet).add("Author", author).add("Timestamp", timestamp).add("Message-Type", messageType).toString();
}
#end_block

#method_before
@Override
protected void configure() {
    listener().to(LocalDiskRepositoryManager.class);
    listener().to(LocalDiskRepositoryManager.Lifecycle.class);
}
#method_after
@Override
protected void configure() {
    listener().to(LocalDiskRepositoryManager.Lifecycle.class);
}
#end_block

#method_before
@Override
public Repository createRepository(Project.NameKey name) throws RepositoryNotFoundException, RepositoryCaseMismatchException {
    Path path = getBasePath(name);
    if (isUnreasonableName(name)) {
        throw new RepositoryNotFoundException("Invalid name: " + name);
    }
    File dir = FileKey.resolve(path.resolve(name.get()).toFile(), FS.DETECTED);
    FileKey loc;
    if (dir != null) {
        // Already exists on disk, use the repository we found.
        // 
        loc = FileKey.exact(dir, FS.DETECTED);
        if (!names.contains(name)) {
            throw new RepositoryCaseMismatchException(name);
        }
    } else {
        // It doesn't exist under any of the standard permutations
        // of the repository name, so prefer the standard bare name.
        // 
        String n = name.get() + Constants.DOT_GIT_EXT;
        loc = FileKey.exact(path.resolve(n).toFile(), FS.DETECTED);
    }
    try {
        Repository db = RepositoryCache.open(loc, false);
        db.create(true);
        StoredConfig config = db.getConfig();
        config.setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_LOGALLREFUPDATES, true);
        config.save();
        // JGit only writes to the reflog for refs/meta/config if the log file
        // already exists.
        // 
        File metaConfigLog = new File(db.getDirectory(), "logs/" + RefNames.REFS_CONFIG);
        if (!metaConfigLog.getParentFile().mkdirs() || !metaConfigLog.createNewFile()) {
            log.error(String.format("Failed to create ref log for %s in repository %s", RefNames.REFS_CONFIG, name));
        }
        onCreateProject(name);
        return db;
    } catch (IOException e1) {
        final RepositoryNotFoundException e2;
        e2 = new RepositoryNotFoundException("Cannot create repository " + name);
        e2.initCause(e1);
        throw e2;
    }
}
#method_after
@Override
public Repository createRepository(Project.NameKey name) throws RepositoryNotFoundException, RepositoryCaseMismatchException, IOException {
    Path path = getBasePath(name);
    if (isUnreasonableName(name)) {
        throw new RepositoryNotFoundException("Invalid name: " + name);
    }
    File dir = FileKey.resolve(path.resolve(name.get()).toFile(), FS.DETECTED);
    FileKey loc;
    if (dir != null) {
        // Already exists on disk, use the repository we found.
        // 
        Project.NameKey onDiskName = getProjectName(path, dir.getCanonicalFile().toPath());
        onCreateProject(onDiskName);
        loc = FileKey.exact(dir, FS.DETECTED);
        if (!names.contains(name)) {
            throw new RepositoryCaseMismatchException(name);
        }
    } else {
        // It doesn't exist under any of the standard permutations
        // of the repository name, so prefer the standard bare name.
        // 
        String n = name.get() + Constants.DOT_GIT_EXT;
        loc = FileKey.exact(path.resolve(n).toFile(), FS.DETECTED);
    }
    try {
        Repository db = RepositoryCache.open(loc, false);
        db.create(true);
        StoredConfig config = db.getConfig();
        config.setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_LOGALLREFUPDATES, true);
        config.save();
        // JGit only writes to the reflog for refs/meta/config if the log file
        // already exists.
        // 
        File metaConfigLog = new File(db.getDirectory(), "logs/" + RefNames.REFS_CONFIG);
        if (!metaConfigLog.getParentFile().mkdirs() || !metaConfigLog.createNewFile()) {
            log.error(String.format("Failed to create ref log for %s in repository %s", RefNames.REFS_CONFIG, name));
        }
        onCreateProject(name);
        return db;
    } catch (IOException e1) {
        final RepositoryNotFoundException e2;
        e2 = new RepositoryNotFoundException("Cannot create repository " + name);
        e2.initCause(e1);
        throw e2;
    }
}
#end_block

#method_before
@Override
public SortedSet<Project.NameKey> list() {
    // The results of this method are cached by ProjectCacheImpl. Control only
    // enters here if the cache was flushed by the administrator to force
    // scanning the filesystem. Don't rely on the cached names collection.
    namesUpdateLock.lock();
    try {
        ProjectVisitor visitor = new ProjectVisitor(basePath);
        scanProjects(visitor);
        return Collections.unmodifiableSortedSet(visitor.found);
    } finally {
        namesUpdateLock.unlock();
    }
}
#method_after
@Override
public SortedSet<Project.NameKey> list() {
    // The results of this method are cached by ProjectCacheImpl. Control only
    // enters here if the cache was flushed by the administrator to force
    // scanning the filesystem.
    // Don't rely on the cached names collection but update it to contain
    // the set of found project names
    ProjectVisitor visitor = new ProjectVisitor(basePath);
    scanProjects(visitor);
    namesUpdateLock.lock();
    try {
        names = Collections.unmodifiableSortedSet(visitor.found);
    } finally {
        namesUpdateLock.unlock();
    }
    return names;
}
#end_block

#method_before
private void addProject(Path p) {
    Project.NameKey nameKey = getProjectName(p);
    if (getBasePath(nameKey).equals(startFolder)) {
        if (isUnreasonableName(nameKey)) {
            log.warn("Ignoring unreasonably named repository " + p.toAbsolutePath());
        } else {
            found.add(nameKey);
        }
    }
}
#method_after
private void addProject(Path p) {
    Project.NameKey nameKey = getProjectName(startFolder, p);
    if (getBasePath(nameKey).equals(startFolder)) {
        if (isUnreasonableName(nameKey)) {
            log.warn("Ignoring unreasonably named repository " + p.toAbsolutePath());
        } else {
            found.add(nameKey);
        }
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    int updatedCount = 0;
    SortedSet<NameKey> repoList = repoManager.list();
    ui.message("\tMigrating " + repoList.size() + " repositories ...");
    for (Project.NameKey projectName : repoList) {
        try (Repository git = repoManager.openRepository(projectName);
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, projectName, git)) {
            ProjectConfigSchemaUpdate cfg = ProjectConfigSchemaUpdate.read(md);
            cfg.removeForceFromPermission("pushTag");
            if (cfg.isUpdated())
                updatedCount++;
            cfg.save(serverUser, COMMIT_MSG);
        } catch (ConfigInvalidException | IOException ex) {
            throw new OrmException("Cannot migrate project " + projectName, ex);
        }
    }
    ui.message("\tMigration completed:  " + updatedCount + " repositories updated.");
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    SortedSet<Project.NameKey> repoList = repoManager.list();
    SortedSet<Project.NameKey> repoUpgraded = new TreeSet<>();
    ui.message("\tMigrating " + repoList.size() + " repositories ...");
    for (Project.NameKey projectName : repoList) {
        try (Repository git = repoManager.openRepository(projectName);
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, projectName, git)) {
            ProjectConfigSchemaUpdate cfg = ProjectConfigSchemaUpdate.read(md);
            cfg.removeForceFromPermission("pushTag");
            if (cfg.isUpdated()) {
                repoUpgraded.add(projectName);
            }
            cfg.save(serverUser, COMMIT_MSG);
        } catch (ConfigInvalidException | IOException ex) {
            throw new OrmException("Cannot migrate project " + projectName, ex);
        }
    }
    ui.message("\tMigration completed:  " + repoUpgraded.size() + " repositories updated:");
    ui.message("\t" + repoUpgraded.stream().map(n -> n.get()).collect(Collectors.joining(" ")));
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    int updatedCount = 0;
    SortedSet<NameKey> repoList = repoManager.list();
    ui.message("\tMigrating " + repoList.size() + " repositories ...");
    for (Project.NameKey projectName : repoList) {
        try (Repository git = repoManager.openRepository(projectName);
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, projectName, git)) {
            ProjectConfig config = ProjectConfig.read(md);
            if (config.hasLegacyPermissions()) {
                md.getCommitBuilder().setAuthor(serverUser);
                md.getCommitBuilder().setCommitter(serverUser);
                md.setMessage(COMMIT_MSG);
                config.commit(md);
                updatedCount++;
            }
        } catch (ConfigInvalidException | IOException ex) {
            throw new OrmException("Cannot migrate project " + projectName, ex);
        }
    }
    ui.message("\tMigration completed:  " + updatedCount + " repositories updated.");
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    SortedSet<Project.NameKey> repoList = repoManager.list();
    SortedSet<Project.NameKey> repoUpgraded = new TreeSet<>();
    ui.message("\tMigrating " + repoList.size() + " repositories ...");
    for (Project.NameKey projectName : repoList) {
        try (Repository git = repoManager.openRepository(projectName);
            MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, projectName, git)) {
            ProjectConfig config = ProjectConfig.read(md);
            if (config.hasLegacyPermissions()) {
                md.getCommitBuilder().setAuthor(serverUser);
                md.getCommitBuilder().setCommitter(serverUser);
                md.setMessage(COMMIT_MSG);
                config.commit(md);
                repoUpgraded.add(projectName);
            }
        } catch (ConfigInvalidException | IOException ex) {
            throw new OrmException("Cannot migrate project " + projectName, ex);
        }
    }
    ui.message("\tMigration completed:  " + repoUpgraded.size() + " repositories updated:");
    ui.message("\t" + repoUpgraded.stream().map(n -> n.get()).collect(Collectors.joining(" ")));
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeList.query("change:" + changeId.get() + " has:draft", Collections.<ListChangesOption>emptySet(), group.add(new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                hasDraftComments = result.length() > 0;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(final ChangeInfo info) {
            info.init();
            addExtensionPoints(info, initCurrentRevision(info));
            final RevisionInfo rev = info.revision(revision);
            CallbackGroup group = new CallbackGroup();
            loadCommit(rev, group);
            group.addListener(new GerritCallback<Void>() {

                @Override
                public void onSuccess(Void result) {
                    if (base == null && rev.commit().parents().length() > 1 && Gerrit.getUserPreferences().defaultBaseForMerges() == DefaultBase.FIRST_PARENT) {
                        base = "-1";
                    }
                    loadConfigInfo(info, base);
                }
            });
            group.done();
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeList.query("change:" + changeId.get() + " has:draft", Collections.<ListChangesOption>emptySet(), group.add(new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                hasDraftComments = result.length() > 0;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(final ChangeInfo info) {
            info.init();
            addExtensionPoints(info, initCurrentRevision(info));
            final RevisionInfo rev = info.revision(revision);
            CallbackGroup group = new CallbackGroup();
            loadCommit(rev, group);
            group.addListener(new GerritCallback<Void>() {

                @Override
                public void onSuccess(Void result) {
                    if (base == null && rev.commit().parents().length() > 1) {
                        base = Gerrit.getUserPreferences().defaultBaseForMerges().getBase();
                    }
                    loadConfigInfo(info, base);
                }
            });
            group.done();
        }
    }));
}
#end_block

#method_before
public final void defaultBaseForMerges(DefaultBase s) {
    defaultBaseForMergesRaw(s != null ? s.toString() : null);
}
#method_after
public final void defaultBaseForMerges(DefaultBase b) {
    defaultBaseForMergesRaw(b != null ? b.toString() : null);
}
#end_block

#method_before
@Override
public Response<List<CommitInfo>> apply(RevisionResource rsrc) throws BadRequestException, IOException {
    List<CommitInfo> result = new ArrayList<>();
    Project.NameKey p = rsrc.getChange().getProject();
    try (Repository repo = repoManager.openRepository(p);
        RevWalk rw = new RevWalk(repo)) {
        String rev = rsrc.getPatchSet().getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        if (uninterestingParent < 0 || uninterestingParent >= commit.getParentCount()) {
            throw new BadRequestException("No such parent: " + uninterestingParent);
        }
        if (commit.getParentCount() < 2) {
            return Response.<List<CommitInfo>>ok(ImmutableList.<CommitInfo>of());
        }
        for (int parent = 0; parent < commit.getParentCount(); parent++) {
            if (parent == uninterestingParent) {
                rw.markUninteresting(commit.getParent(parent));
            } else {
                rw.markStart(commit.getParent(parent));
            }
        }
        RevCommit c;
        while ((c = rw.next()) != null) {
            CommitInfo info = json.create(ChangeJson.NO_OPTIONS).toCommit(rsrc.getControl(), rw, c, addLinks, true);
            result.add(info);
        }
    }
    Response<List<CommitInfo>> r = Response.ok(result);
    if (rsrc.isCacheable()) {
        r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
    }
    return r;
}
#method_after
@Override
public Response<List<CommitInfo>> apply(RevisionResource rsrc) throws BadRequestException, IOException {
    List<CommitInfo> result = new ArrayList<>();
    Project.NameKey p = rsrc.getChange().getProject();
    try (Repository repo = repoManager.openRepository(p);
        RevWalk rw = new RevWalk(repo)) {
        String rev = rsrc.getPatchSet().getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        if (uninterestingParent < 1 || uninterestingParent > commit.getParentCount()) {
            throw new BadRequestException("No such parent: " + uninterestingParent);
        }
        if (commit.getParentCount() < 2) {
            return Response.<List<CommitInfo>>ok(ImmutableList.<CommitInfo>of());
        }
        for (int parent = 0; parent < commit.getParentCount(); parent++) {
            if (parent == uninterestingParent - 1) {
                rw.markUninteresting(commit.getParent(parent));
            } else {
                rw.markStart(commit.getParent(parent));
            }
        }
        ChangeJson changeJson = json.create(ChangeJson.NO_OPTIONS);
        RevCommit c;
        while ((c = rw.next()) != null) {
            CommitInfo info = changeJson.toCommit(rsrc.getControl(), rw, c, addLinks, true);
            result.add(info);
        }
    }
    Response<List<CommitInfo>> r = Response.ok(result);
    if (rsrc.isCacheable()) {
        r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
    }
    return r;
}
#end_block

#method_before
@Test
public void getMergeList() throws Exception {
    ObjectId initial = repo().exactRef(HEAD).getLeaf().getObjectId();
    PushOneCommit.Result gp1 = pushFactory.create(db, admin.getIdent(), testRepo, "grand parent 1", ImmutableMap.of("foo", "foo-1.1", "bar", "bar-1.1")).to("refs/for/master");
    PushOneCommit.Result p1 = pushFactory.create(db, admin.getIdent(), testRepo, "parent 1", ImmutableMap.of("foo", "foo-1.2", "bar", "bar-1.2")).to("refs/for/master");
    // reset HEAD in order to create a sibling of the first change
    testRepo.reset(initial);
    PushOneCommit.Result gp2 = pushFactory.create(db, admin.getIdent(), testRepo, "grand parent 1", ImmutableMap.of("foo", "foo-2.1", "bar", "bar-2.1")).to("refs/for/master");
    PushOneCommit.Result p2 = pushFactory.create(db, admin.getIdent(), testRepo, "parent 2", ImmutableMap.of("foo", "foo-2.2", "bar", "bar-2.2")).to("refs/for/master");
    PushOneCommit m = pushFactory.create(db, admin.getIdent(), testRepo, "merge", ImmutableMap.of("foo", "foo-1", "bar", "bar-2"));
    m.setParents(ImmutableList.of(p1.getCommit(), p2.getCommit()));
    PushOneCommit.Result result = m.to("refs/for/master");
    result.assertOkStatus();
    List<CommitInfo> mergeList = gApi.changes().id(result.getChangeId()).current().getMergeList().get();
    assertThat(mergeList).hasSize(2);
    assertThat(mergeList.get(0).commit).isEqualTo(p2.getCommit().name());
    assertThat(mergeList.get(1).commit).isEqualTo(gp2.getCommit().name());
    mergeList = gApi.changes().id(result.getChangeId()).current().getMergeList().withUninterestingParent(1).get();
    assertThat(mergeList).hasSize(2);
    assertThat(mergeList.get(0).commit).isEqualTo(p1.getCommit().name());
    assertThat(mergeList.get(1).commit).isEqualTo(gp1.getCommit().name());
}
#method_after
@Test
public void getMergeList() throws Exception {
    ObjectId initial = repo().exactRef(HEAD).getLeaf().getObjectId();
    PushOneCommit.Result gp1 = pushFactory.create(db, admin.getIdent(), testRepo, "grand parent 1", ImmutableMap.of("foo", "foo-1.1", "bar", "bar-1.1")).to("refs/for/master");
    PushOneCommit.Result p1 = pushFactory.create(db, admin.getIdent(), testRepo, "parent 1", ImmutableMap.of("foo", "foo-1.2", "bar", "bar-1.2")).to("refs/for/master");
    // reset HEAD in order to create a sibling of the first change
    testRepo.reset(initial);
    PushOneCommit.Result gp2 = pushFactory.create(db, admin.getIdent(), testRepo, "grand parent 1", ImmutableMap.of("foo", "foo-2.1", "bar", "bar-2.1")).to("refs/for/master");
    PushOneCommit.Result p2 = pushFactory.create(db, admin.getIdent(), testRepo, "parent 2", ImmutableMap.of("foo", "foo-2.2", "bar", "bar-2.2")).to("refs/for/master");
    PushOneCommit m = pushFactory.create(db, admin.getIdent(), testRepo, "merge", ImmutableMap.of("foo", "foo-1", "bar", "bar-2"));
    m.setParents(ImmutableList.of(p1.getCommit(), p2.getCommit()));
    PushOneCommit.Result result = m.to("refs/for/master");
    result.assertOkStatus();
    List<CommitInfo> mergeList = gApi.changes().id(result.getChangeId()).current().getMergeList().get();
    assertThat(mergeList).hasSize(2);
    assertThat(mergeList.get(0).commit).isEqualTo(p2.getCommit().name());
    assertThat(mergeList.get(1).commit).isEqualTo(gp2.getCommit().name());
    mergeList = gApi.changes().id(result.getChangeId()).current().getMergeList().withUninterestingParent(2).get();
    assertThat(mergeList).hasSize(2);
    assertThat(mergeList.get(0).commit).isEqualTo(p1.getCommit().name());
    assertThat(mergeList.get(1).commit).isEqualTo(gp1.getCommit().name());
}
#end_block

#method_before
@Override
public String getCommand(DownloadScheme scheme, String project) {
    String username = userProvider.get().getUserName();
    if (username == null) {
        return null;
    }
    String projectName = getBaseName(project);
    if (configCommand != null) {
        return new StringBuilder().append(super.getCommand(scheme, project)).append(" && (cd ").append(projectName).append(" && ").append(configCommand).append(")").toString();
    }
    if (scheme instanceof SshScheme) {
        StringBuilder b = new StringBuilder().append(super.getCommand(scheme, project)).append(" && scp -p");
        if (sshScheme.getSshdPort() != 22) {
            b.append(" -P ").append(sshScheme.getSshdPort());
        }
        b.append(" ").append(username).append("@").append(sshScheme.getSshdHost()).append(":").append(HOOK).append(" ").append(projectName).append("/.git/hooks/");
        return b.toString();
    }
    if (scheme instanceof HttpScheme || scheme instanceof AnonymousHttpScheme) {
        return new StringBuilder().append(super.getCommand(scheme, project)).append(" && (cd ").append(projectName).append(" && curl -kLo").append(TARGET).append(HOOK).append(" ").append(getHttpHost(scheme.getUrl(project), project)).append("tools/").append(HOOK).append("; chmod +x").append(TARGET).append(HOOK).append(")").toString();
    }
    return null;
}
#method_after
@Override
public String getCommand(DownloadScheme scheme, String project) {
    String username = userProvider.get().getUserName();
    if (username == null) {
        return null;
    }
    String projectName = getBaseName(project);
    if (configCommand != null) {
        return new StringBuilder().append(super.getCommand(scheme, project)).append(" && (cd ").append(projectName).append(" && ").append(configCommand).append(")").toString();
    }
    if (scheme instanceof SshScheme) {
        StringBuilder b = new StringBuilder().append(super.getCommand(scheme, project)).append(" && scp -p");
        if (sshScheme.getSshdPort() != 22) {
            b.append(" -P ").append(sshScheme.getSshdPort());
        }
        b.append(" ").append(username).append("@").append(sshScheme.getSshdHost()).append(":").append(HOOK).append(" ").append(projectName).append("/.git/hooks/");
        return b.toString();
    }
    if (scheme instanceof HttpScheme || scheme instanceof AnonymousHttpScheme) {
        return new StringBuilder().append(super.getCommand(scheme, project)).append(" && (cd ").append(projectName).append(" && curl -kLo").append(TARGET).append(HOOK).append(" ").append(getHttpHost(scheme, project)).append("tools/").append(HOOK).append("; chmod +x").append(TARGET).append(HOOK).append(")").toString();
    }
    return null;
}
#end_block

#method_before
private String getHttpHost(String url, String project) {
    int auth = url.lastIndexOf("/a/");
    if (auth > -1) {
        return url.substring(0, auth + 1);
    }
    return url.substring(0, url.lastIndexOf(project));
}
#method_after
private String getHttpHost(DownloadScheme scheme, String project) {
    String host = scheme.getUrl(project);
    host = host.substring(0, host.lastIndexOf(project));
    int auth = host.lastIndexOf("/a/");
    if (auth > -1) {
        host = host.substring(0, auth + 1);
    }
    return host;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.allow(cfg, Permission.OWNER, REGISTERED_USERS, "refs/*");
    Util.allow(cfg, Permission.PUSH, REGISTERED_USERS, "refs/for/refs/meta/config");
    Util.allow(cfg, Permission.SUBMIT, REGISTERED_USERS, "refs/meta/config");
    saveProjectConfig(project, cfg);
    setApiUser(user);
    fetchRefsMetaConfig();
}
#method_after
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.allow(cfg, Permission.OWNER, REGISTERED_USERS, "refs/*");
    Util.allow(cfg, Permission.PUSH, REGISTERED_USERS, "refs/for/refs/meta/config");
    Util.allow(cfg, Permission.SUBMIT, REGISTERED_USERS, RefNames.REFS_CONFIG);
    saveProjectConfig(project, cfg);
    setApiUser(user);
    fetchRefsMetaConfig();
}
#end_block

#method_before
private String testUpdateProjectConfig() throws Exception {
    Config cfg = readProjectConfig();
    assertThat(cfg.getString("project", null, "description")).isNull();
    String desc = "new project description";
    cfg.setString("project", null, "description", desc);
    PushOneCommit.Result r = createConfigChange(cfg);
    String id = r.getChangeId();
    gApi.changes().id(id).current().review(ReviewInput.approve());
    gApi.changes().id(id).current().submit();
    assertThat(gApi.changes().id(id).info().status).isEqualTo(ChangeStatus.MERGED);
    assertThat(gApi.projects().name(project.get()).get().description).isEqualTo(desc);
    fetchRefsMetaConfig();
    assertThat(readProjectConfig().getString("project", null, "description")).isEqualTo(desc);
    String changeRev = gApi.changes().id(id).get().currentRevision;
    String branchRev = gApi.projects().name(project.get()).branch("refs/meta/config").get().revision;
    assertThat(changeRev).isEqualTo(branchRev);
    return id;
}
#method_after
private String testUpdateProjectConfig() throws Exception {
    Config cfg = readProjectConfig();
    assertThat(cfg.getString("project", null, "description")).isNull();
    String desc = "new project description";
    cfg.setString("project", null, "description", desc);
    PushOneCommit.Result r = createConfigChange(cfg);
    String id = r.getChangeId();
    gApi.changes().id(id).current().review(ReviewInput.approve());
    gApi.changes().id(id).current().submit();
    assertThat(gApi.changes().id(id).info().status).isEqualTo(ChangeStatus.MERGED);
    assertThat(gApi.projects().name(project.get()).get().description).isEqualTo(desc);
    fetchRefsMetaConfig();
    assertThat(readProjectConfig().getString("project", null, "description")).isEqualTo(desc);
    String changeRev = gApi.changes().id(id).get().currentRevision;
    String branchRev = gApi.projects().name(project.get()).branch(RefNames.REFS_CONFIG).get().revision;
    assertThat(changeRev).isEqualTo(branchRev);
    return id;
}
#end_block

#method_before
@Test
public void rejectDoubleInheritance() throws Exception {
    // Create separate projects to test the config
    Project.NameKey parent = createProject("projectToInheritFrom");
    Project.NameKey child = createProject("projectWithMalformedConfig");
    String config = gApi.projects().name(child.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    // Append and push malformed project config
    String pattern = "[access]\n" + "\tinheritFrom = " + allProjects.get() + "\n";
    String doubleInherit = pattern + "\tinheritFrom = " + parent.get() + "\n";
    config = config.replace(pattern, doubleInherit);
    TestRepository<InMemoryRepository> childRepo = cloneProject(child, admin);
    // Fetch permission ref
    GitUtil.fetch(childRepo, "refs/meta/config:cfg");
    childRepo.reset("cfg");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), childRepo, "Subject", "project.config", config);
    push.to(RefNames.REFS_CONFIG).assertErrorStatus("invalid project configuration");
}
#method_after
@Test
public void rejectDoubleInheritance() throws Exception {
    setApiUser(admin);
    // Create separate projects to test the config
    Project.NameKey parent = createProject("projectToInheritFrom");
    Project.NameKey child = createProject("projectWithMalformedConfig");
    String config = gApi.projects().name(child.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    // Append and push malformed project config
    String pattern = "[access]\n" + "\tinheritFrom = " + allProjects.get() + "\n";
    String doubleInherit = pattern + "\tinheritFrom = " + parent.get() + "\n";
    config = config.replace(pattern, doubleInherit);
    TestRepository<InMemoryRepository> childRepo = cloneProject(child, admin);
    // Fetch meta ref
    GitUtil.fetch(childRepo, RefNames.REFS_CONFIG + ":cfg");
    childRepo.reset("cfg");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), childRepo, "Subject", "project.config", config);
    PushOneCommit.Result res = push.to(RefNames.REFS_CONFIG);
    res.assertErrorStatus();
    res.assertMessage("cannot inherit from multiple projects");
}
#end_block

#method_before
private void fetchRefsMetaConfig() throws Exception {
    git().fetch().setRefSpecs(new RefSpec("refs/meta/config:refs/meta/config")).call();
    testRepo.reset("refs/meta/config");
}
#method_after
private void fetchRefsMetaConfig() throws Exception {
    git().fetch().setRefSpecs(new RefSpec("refs/meta/config:refs/meta/config")).call();
    testRepo.reset(RefNames.REFS_CONFIG);
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    readGroupList();
    Map<String, GroupReference> groupsByName = mapGroupReferences();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    if (rc.getStringList(ACCESS, null, KEY_INHERIT_FROM).length > 1) {
        throw new ConfigInvalidException("Cannot inherit from multiple projects");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setEnableSignedPush(getEnum(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setRequireSignedPush(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadBranchOrderSection(rc);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadSubscribeSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    readGroupList();
    Map<String, GroupReference> groupsByName = mapGroupReferences();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    if (rc.getStringList(ACCESS, null, KEY_INHERIT_FROM).length > 1) {
        // The config must not contain more than one parent to inherit from
        // as there is no guarantee which of the parents would be used then.
        error(new ValidationError(PROJECT_CONFIG, "Cannot inherit from multiple projects"));
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setEnableSignedPush(getEnum(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setRequireSignedPush(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadBranchOrderSection(rc);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadSubscribeSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#end_block

#method_before
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = bu.getUser().getAccountId();
        boolean ccOrReviewer = input.labels != null;
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (id.get() == reviewerInfo._accountId) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (id.get() == accountInfo._accountId) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(bu.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, reviewerResults));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, input.notify);
    }
    return Response.ok(output);
}
#method_after
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = bu.getUser().getAccountId();
        boolean ccOrReviewer = input.labels != null;
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(bu.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, reviewerResults));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, input.notify);
    }
    return Response.ok(output);
}
#end_block

#method_before
public synchronized void handleEmails() {
    POP3Client pop3;
    if (mailSettings.encryption != Encryption.NONE) {
        pop3 = new POP3SClient(mailSettings.encryption.name());
    } else {
        pop3 = new POP3Client();
    }
    if (mailSettings.port > 0) {
        pop3.setDefaultPort(mailSettings.port);
    }
    try {
        pop3.connect(mailSettings.host);
    } catch (IOException e) {
        log.error("Could not connect to POP3 email server", e);
        return;
    }
    try {
        try {
            if (!pop3.login(mailSettings.username, mailSettings.password)) {
                log.error("Could not login to POP3 email server." + " Check username and password");
                return;
            }
            try {
                // listMessages
                POP3MessageInfo[] messages = pop3.listMessages();
                if (messages == null) {
                    log.error("Could not retrieve message list via POP3");
                    return;
                }
                log.info("Received " + messages.length + " messages via POP3");
                // Fetch messages
                List<MailMessage> mailMessages = new ArrayList<>();
                for (POP3MessageInfo msginfo : messages) {
                    if (msginfo == null) {
                        // Message was deleted
                        continue;
                    }
                    Reader reader = pop3.retrieveMessage(msginfo.number);
                    if (reader == null) {
                        log.error("Could not retrieve POP3 message header for message " + msginfo.identifier);
                        return;
                    }
                    int[] message = fetchMessage(reader);
                    try {
                        MailMessage mailMessage = RawMailParser.parse(message);
                        // 822 and delete the message if deletion is pending.
                        if (pendingDeletion.contains(mailMessage.id())) {
                            if (!pop3.deleteMessage(msginfo.number)) {
                                log.error("Could not delete message " + msginfo.number);
                            }
                        } else {
                            // Process message further
                            mailMessages.add(mailMessage);
                        }
                    } catch (MailParsingException e) {
                        log.error("Could not parse message " + msginfo.number);
                    }
                }
                pendingDeletion.clear();
            // TODO(hiesel) Call processing logic with mailMessages
            } finally {
                pop3.logout();
            }
        } finally {
            pop3.disconnect();
        }
    } catch (IOException e) {
        log.error("Error while issuing POP3 command", e);
    }
}
#method_after
@Override
public synchronized void handleEmails() {
    POP3Client pop3;
    if (mailSettings.encryption != Encryption.NONE) {
        pop3 = new POP3SClient(mailSettings.encryption.name());
    } else {
        pop3 = new POP3Client();
    }
    if (mailSettings.port > 0) {
        pop3.setDefaultPort(mailSettings.port);
    }
    try {
        pop3.connect(mailSettings.host);
    } catch (IOException e) {
        log.error("Could not connect to POP3 email server", e);
        return;
    }
    try {
        try {
            if (!pop3.login(mailSettings.username, mailSettings.password)) {
                log.error("Could not login to POP3 email server." + " Check username and password");
                return;
            }
            try {
                POP3MessageInfo[] messages = pop3.listMessages();
                if (messages == null) {
                    log.error("Could not retrieve message list via POP3");
                    return;
                }
                log.info("Received " + messages.length + " messages via POP3");
                // Fetch messages
                List<MailMessage> mailMessages = new ArrayList<>();
                for (POP3MessageInfo msginfo : messages) {
                    if (msginfo == null) {
                        // Message was deleted
                        continue;
                    }
                    Reader reader = pop3.retrieveMessage(msginfo.number);
                    if (reader == null) {
                        log.error("Could not retrieve POP3 message header for message " + msginfo.identifier);
                        return;
                    }
                    int[] message = fetchMessage(reader);
                    try {
                        MailMessage mailMessage = RawMailParser.parse(message);
                        // 822 and delete the message if deletion is pending.
                        if (pendingDeletion.contains(mailMessage.id())) {
                            if (pop3.deleteMessage(msginfo.number)) {
                                pendingDeletion.remove(mailMessage.id());
                            } else {
                                log.error("Could not delete message " + msginfo.number);
                            }
                        } else {
                            // Process message further
                            mailMessages.add(mailMessage);
                        }
                    } catch (MailParsingException e) {
                        log.error("Could not parse message " + msginfo.number);
                    }
                }
            // TODO(hiesel) Call processing logic with mailMessages
            } finally {
                pop3.logout();
            }
        } finally {
            pop3.disconnect();
        }
    } catch (IOException e) {
        log.error("Error while issuing POP3 command", e);
    }
}
#end_block

#method_before
public final int[] fetchMessage(Reader reader) throws IOException {
    BufferedReader bufferedReader;
    if (reader instanceof BufferedReader) {
        bufferedReader = (BufferedReader) reader;
    } else {
        bufferedReader = new BufferedReader(reader);
    }
    List<Integer> character = new ArrayList<>();
    int ch;
    while ((ch = bufferedReader.read()) != -1) {
        character.add(ch);
    }
    bufferedReader.close();
    if (bufferedReader != reader) {
        reader.close();
    }
    return Ints.toArray(character);
}
#method_after
public final int[] fetchMessage(Reader reader) throws IOException {
    BufferedReader bufferedReader;
    if (reader instanceof BufferedReader) {
        bufferedReader = (BufferedReader) reader;
    } else {
        bufferedReader = new BufferedReader(reader);
    }
    try {
        List<Integer> character = new ArrayList<>();
        int ch;
        while ((ch = bufferedReader.read()) != -1) {
            character.add(ch);
        }
        return Ints.toArray(character);
    } finally {
        bufferedReader.close();
        if (bufferedReader != reader) {
            reader.close();
        }
    }
}
#end_block

#method_before
public synchronized void handleEmails() {
// TODO(hiesel) Implement.
}
#method_after
@Override
public synchronized void handleEmails() {
// TODO(hiesel) Implement.
}
#end_block

#method_before
@Test
public void testDelete() throws Exception {
    GreenMailUser user = mockPop3Server.setUser(USERNAME, USERNAME, PASSWORD);
    user.deliver(createSimpleMessage());
    assertThat(mockPop3Server.getReceivedMessages().length).isEqualTo(1);
    // Let Gerrit handle emails
    mailReceiver.handleEmails();
    // Check that the message is still present
    assertThat(mockPop3Server.getReceivedMessages().length).isEqualTo(1);
    // Mark the message for deletion
    mailReceiver.deleteEmailEventually(mockPop3Server.getReceivedMessages()[0].getMessageID());
    // Let Gerrit handle emails
    mailReceiver.handleEmails();
    // Check that the message was deleted
    assertThat(mockPop3Server.getReceivedMessages().length).isEqualTo(0);
}
#method_after
@Test
public void testDelete() throws Exception {
    GreenMailUser user = mockPop3Server.setUser(USERNAME, USERNAME, PASSWORD);
    user.deliver(createSimpleMessage());
    assertThat(mockPop3Server.getReceivedMessages().length).isEqualTo(1);
    // Let Gerrit handle emails
    mailReceiver.handleEmails();
    // Check that the message is still present
    assertThat(mockPop3Server.getReceivedMessages().length).isEqualTo(1);
    // Mark the message for deletion
    mailReceiver.requestDeletion(mockPop3Server.getReceivedMessages()[0].getMessageID());
    // Let Gerrit handle emails
    mailReceiver.handleEmails();
    // Check that the message was deleted
    assertThat(mockPop3Server.getReceivedMessages().length).isEqualTo(0);
}
#end_block

#method_before
public void start() {
    if (timer == null) {
        timer = new Timer();
    } else {
        timer.cancel();
    }
    timer.scheduleAtFixedRate(new TimerTask() {

        @Override
        public void run() {
            MailReceiver.this.handleEmails();
        }
    }, 0l, mailSettings.fetchInterval * 1000);
}
#method_after
@Override
public void start() {
    if (timer == null) {
        timer = new Timer();
    } else {
        timer.cancel();
    }
    timer.scheduleAtFixedRate(new TimerTask() {

        @Override
        public void run() {
            MailReceiver.this.handleEmails();
        }
    }, 0l, mailSettings.fetchInterval);
}
#end_block

#method_before
public void stop() {
    if (timer != null) {
        timer.cancel();
    }
}
#method_after
@Override
public void stop() {
    if (timer != null) {
        timer.cancel();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    if (mailSettings.protocol != Protocol.NONE) {
        listener().to(MailReceiver.class);
        if (mailSettings.protocol == Protocol.IMAP) {
            bind(MailReceiver.class).to(ImapMailReceiver.class);
        } else if (mailSettings.protocol == Protocol.POP3) {
            bind(MailReceiver.class).to(Pop3MailReceiver.class);
        }
    }
}
#method_after
@Override
protected void configure() {
    if (mailSettings.protocol == Protocol.NONE) {
        return;
    }
    listener().to(MailReceiver.class);
    switch(mailSettings.protocol) {
        case IMAP:
            bind(MailReceiver.class).to(ImapMailReceiver.class);
            break;
        case POP3:
            bind(MailReceiver.class).to(Pop3MailReceiver.class);
            break;
        case NONE:
        default:
    }
}
#end_block

#method_before
public void start() {
    if (timer == null) {
        timer = new Timer();
    } else {
        timer.cancel();
    }
    timer.scheduleAtFixedRate(new TimerTask() {

        @Override
        public void run() {
            MailReceiver.this.handleEmails();
        }
    }, 0l, mailSettings.fetchInterval * 1000);
}
#method_after
@Override
public void start() {
    if (timer == null) {
        timer = new Timer();
    } else {
        timer.cancel();
    }
    timer.scheduleAtFixedRate(new TimerTask() {

        @Override
        public void run() {
            MailReceiver.this.handleEmails();
        }
    }, 0l, mailSettings.fetchInterval);
}
#end_block

#method_before
public void stop() {
    if (timer != null) {
        timer.cancel();
    }
}
#method_after
@Override
public void stop() {
    if (timer != null) {
        timer.cancel();
    }
}
#end_block

#method_before
protected synchronized void handleEmails() {
// TODO(hiesel) Implement.
}
#method_after
@Override
protected synchronized void handleEmails() {
// TODO(hiesel) Implement.
}
#end_block

#method_before
protected synchronized void handleEmails() {
// TODO(hiesel) Implement.
}
#method_after
@Override
protected synchronized void handleEmails() {
// TODO(hiesel) Implement.
}
#end_block

#method_before
@Override
public MailMessage expectedMailMessage() {
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114da7ae26e2eb053fe0c29c@google.com>").from(new Address("Jonathan Nieder (Gerrit)", "noreply-gerritcodereview-CtTy0igsBrnvL7dKoWEIEg@google.com")).addTo(new Address("ekempin", "ekempin@google.com")).textContent(textContent).subject("\uD83D\uDE1B test").dateReceived(new DateTime(2016, 10, 25, 9, 11, 35, 0));
    return expect.build();
}
#method_after
@Override
public MailMessage expectedMailMessage() {
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114da7ae26e2eb053fe0c29c@google.com>").from(new Address("Jonathan Nieder (Gerrit)", "noreply-gerritcodereview-CtTy0igsBrnvL7dKoWEIEg@google.com")).addTo(new Address("ekempin", "ekempin@google.com")).textContent(textContent).subject("\uD83D\uDE1B test").dateReceived(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC));
    return expect.build();
}
#end_block

#method_before
@Override
public MailMessage expectedMailMessage() {
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114da7ae26e2eb053fe0c29c@google.com>").from(new Address("Jonathan Nieder (Gerrit)", "noreply-gerritcodereview-CtTy0igsBrnvL7dKoWEIEg@google.com")).addTo(new Address("ekempin", "ekempin@google.com")).textContent(textContent).subject("\uD83D\uDE1B test").dateReceived(new DateTime(2016, 10, 25, 9, 11, 35, 0));
    return expect.build();
}
#method_after
@Override
public MailMessage expectedMailMessage() {
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114da7ae26e2eb053fe0c29c@google.com>").from(new Address("Jonathan Nieder (Gerrit)", "noreply-gerritcodereview-CtTy0igsBrnvL7dKoWEIEg@google.com")).addTo(new Address("ekempin", "ekempin@google.com")).textContent(textContent).subject("\uD83D\uDE1B test").dateReceived(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC));
    return expect.build();
}
#end_block

#method_before
@Override
public MailMessage expectedMailMessage() {
    System.out.println("\uD83D\uDE1B test");
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114da7ae26e2eb053fe0c29c@google.com>").from(new Address("Jonathan Nieder (Gerrit)", "noreply-gerritcodereview-CtTy0igsBrnvL7dKoWEIEg@google.com")).addTo(new Address("ekempin", "ekempin@google.com")).textContent(textContent).subject("me vulgaire").dateReceived(new DateTime(2016, 10, 25, 9, 11, 35, 0));
    return expect.build();
}
#method_after
@Override
public MailMessage expectedMailMessage() {
    System.out.println("\uD83D\uDE1B test");
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114da7ae26e2eb053fe0c29c@google.com>").from(new Address("Jonathan Nieder (Gerrit)", "noreply-gerritcodereview-CtTy0igsBrnvL7dKoWEIEg@google.com")).addTo(new Address("ekempin", "ekempin@google.com")).textContent(textContent).subject("me vulgaire").dateReceived(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC));
    return expect.build();
}
#end_block

#method_before
private void assertMail(MailMessage have, MailMessage want) {
    assertThat(have.id()).isEqualTo(want.id());
    assertThat(have.to()).isEqualTo(want.to());
    assertThat(have.from()).isEqualTo(want.from());
    assertThat(have.cc()).isEqualTo(want.cc());
    assertThat(have.dateReceived()).isEqualTo(want.dateReceived());
    assertThat(have.additionalHeaders()).isEqualTo(want.additionalHeaders());
    assertThat(have.subject()).isEqualTo(want.subject());
    assertThat(have.textContent()).isEqualTo(want.textContent());
    assertThat(have.htmlContent()).isEqualTo(want.htmlContent());
}
#method_after
private void assertMail(MailMessage have, MailMessage want) {
    assertThat(have.id()).isEqualTo(want.id());
    assertThat(have.to()).isEqualTo(want.to());
    assertThat(have.from()).isEqualTo(want.from());
    assertThat(have.cc()).isEqualTo(want.cc());
    assertThat(have.dateReceived().getMillis()).isEqualTo(want.dateReceived().getMillis());
    assertThat(have.additionalHeaders()).isEqualTo(want.additionalHeaders());
    assertThat(have.subject()).isEqualTo(want.subject());
    assertThat(have.textContent()).isEqualTo(want.textContent());
    assertThat(have.htmlContent()).isEqualTo(want.htmlContent());
}
#end_block

#method_before
@Override
public MailMessage expectedMailMessage() {
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114cd8be55b4ab053face5cd@google.com>").from(new Address("ekempin (Gerrit)", "noreply-gerritcodereview-qUgXfQecoDLHwp0MldAzig@google.com")).addCc(new Address("ekempin", "ekempin@google.com")).addTo(new Address("Patrick Hiesel", "hiesel@google.com")).textContent(textContent).htmlContent(unencodedHtmlContent).subject("Change in gerrit[master]: Implement " + "receiver class structure and bindings").addAdditionalHeader("MIME-Version: 1.0").dateReceived(new DateTime(2016, 10, 25, 9, 11, 35, 0));
    return expect.build();
}
#method_after
@Override
public MailMessage expectedMailMessage() {
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114cd8be55b4ab053face5cd@google.com>").from(new Address("ekempin (Gerrit)", "noreply-gerritcodereview-qUgXfQecoDLHwp0MldAzig@google.com")).addCc(new Address("ekempin", "ekempin@google.com")).addTo(new Address("Patrick Hiesel", "hiesel@google.com")).textContent(textContent).htmlContent(unencodedHtmlContent).subject("Change in gerrit[master]: Implement " + "receiver class structure and bindings").addAdditionalHeader("MIME-Version: 1.0").dateReceived(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC));
    return expect.build();
}
#end_block

#method_before
@Override
public MailMessage expectedMailMessage() {
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114da7ae26e2eb053fe0c29c@google.com>").from(new Address("Jonathan Nieder (Gerrit)", "noreply-gerritcodereview-CtTy0igsBrnvL7dKoWEIEg@google.com")).addTo(new Address("ekempin", "ekempin@google.com")).addCc(new Address("Dave Borowitz", "dborowitz@google.com")).addCc(new Address("Jonathan Nieder", "jrn@google.com")).addCc(new Address("Patrick Hiesel", "hiesel@google.com")).textContent(textContent).subject("Change in gerrit[master]: (Re)enable voting" + " buttons for merged changes").dateReceived(new DateTime(2016, 10, 25, 9, 11, 35, 0)).addAdditionalHeader("Authentication-Results: mx.google.com; " + "dkim=pass header.i=@google.com;").addAdditionalHeader("In-Reply-To: <gerrit.1477487889000.Iba501e00bee" + "77be3bd0ced72f88fd04ba0accaed@gerrit-review.googlesource.com>").addAdditionalHeader("References: <gerrit.1477487889000.Iba501e00bee" + "77be3bd0ced72f88fd04ba0accaed@gerrit-review.googlesource.com>");
    return expect.build();
}
#method_after
@Override
public MailMessage expectedMailMessage() {
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114da7ae26e2eb053fe0c29c@google.com>").from(new Address("Jonathan Nieder (Gerrit)", "noreply-gerritcodereview-CtTy0igsBrnvL7dKoWEIEg@google.com")).addTo(new Address("ekempin", "ekempin@google.com")).addCc(new Address("Dave Borowitz", "dborowitz@google.com")).addCc(new Address("Jonathan Nieder", "jrn@google.com")).addCc(new Address("Patrick Hiesel", "hiesel@google.com")).textContent(textContent).subject("Change in gerrit[master]: (Re)enable voting" + " buttons for merged changes").dateReceived(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC)).addAdditionalHeader("Authentication-Results: mx.google.com; " + "dkim=pass header.i=@google.com;").addAdditionalHeader("In-Reply-To: <gerrit.1477487889000.Iba501e00bee" + "77be3bd0ced72f88fd04ba0accaed@gerrit-review.googlesource.com>").addAdditionalHeader("References: <gerrit.1477487889000.Iba501e00bee" + "77be3bd0ced72f88fd04ba0accaed@gerrit-review.googlesource.com>");
    return expect.build();
}
#end_block

#method_before
@Override
public MailMessage expectedMailMessage() {
    System.out.println("\uD83D\uDE1B test");
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<CAM7sg=3meaAVUxW3KXeJEVs8sv_ADw1BnvpcHHiYVR2TQQi__w" + "@mail.gmail.com>").from(new Address("Patrick Hiesel", "hiesel@google.com")).addTo(new Address("Patrick Hiesel", "hiesel@google.com")).textContent("Contains unwanted attachment").htmlContent("<div dir=\"ltr\">Contains unwanted attachment</div>").subject("Test Subject").addAdditionalHeader("MIME-Version: 1.0").dateReceived(new DateTime(2016, 10, 25, 9, 11, 35, 0));
    return expect.build();
}
#method_after
@Override
public MailMessage expectedMailMessage() {
    System.out.println("\uD83D\uDE1B test");
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<CAM7sg=3meaAVUxW3KXeJEVs8sv_ADw1BnvpcHHiYVR2TQQi__w" + "@mail.gmail.com>").from(new Address("Patrick Hiesel", "hiesel@google.com")).addTo(new Address("Patrick Hiesel", "hiesel@google.com")).textContent("Contains unwanted attachment").htmlContent("<div dir=\"ltr\">Contains unwanted attachment</div>").subject("Test Subject").addAdditionalHeader("MIME-Version: 1.0").dateReceived(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC));
    return expect.build();
}
#end_block

#method_before
public static MailMessage parse(String raw) throws MailParsingException {
    MailMessage.Builder messageBuilder = MailMessage.builder();
    Message mimeMessage;
    try {
        MessageBuilder builder = new DefaultMessageBuilder();
        mimeMessage = builder.parseMessage(new ByteArrayInputStream(raw.getBytes()));
    } catch (IOException | MimeException e) {
        throw new MailParsingException("Can't parse email", e);
    }
    // Add general headers
    messageBuilder.id(mimeMessage.getMessageId());
    messageBuilder.subject(mimeMessage.getSubject());
    messageBuilder.dateReceived(new DateTime(mimeMessage.getDate()));
    // Add From, To and Cc
    if (mimeMessage.getFrom() != null && mimeMessage.getFrom().size() > 0) {
        Mailbox from = mimeMessage.getFrom().get(0);
        messageBuilder.from(new Address(from.getName(), from.getAddress()));
    }
    if (mimeMessage.getTo() != null) {
        for (Mailbox m : mimeMessage.getTo().flatten()) {
            messageBuilder.addTo(new Address(m.getName(), m.getAddress()));
        }
    }
    if (mimeMessage.getCc() != null) {
        for (Mailbox m : mimeMessage.getCc().flatten()) {
            messageBuilder.addCc(new Address(m.getName(), m.getAddress()));
        }
    }
    // Add additional headers
    mimeMessage.getHeader().getFields().stream().filter(f -> !"to from cc date message-id subject content-type".contains(f.getName().toLowerCase())).forEach(f -> messageBuilder.addAdditionalHeader(f.getName() + ": " + f.getBody()));
    // Add text and html body parts
    StringBuilder textBuilder = new StringBuilder();
    StringBuilder htmlBuilder = new StringBuilder();
    try {
        handleMimePart(mimeMessage, textBuilder, htmlBuilder);
    } catch (IOException e) {
        throw new MailParsingException("Can't parse email", e);
    }
    messageBuilder.textContent(textBuilder.length() > 0 ? textBuilder.toString() : null);
    messageBuilder.htmlContent(htmlBuilder.length() > 0 ? htmlBuilder.toString() : null);
    return messageBuilder.build();
}
#method_after
public static MailMessage parse(String raw) throws MailParsingException {
    MailMessage.Builder messageBuilder = MailMessage.builder();
    Message mimeMessage;
    try {
        MessageBuilder builder = new DefaultMessageBuilder();
        mimeMessage = builder.parseMessage(new ByteArrayInputStream(raw.getBytes()));
    } catch (IOException | MimeException e) {
        throw new MailParsingException("Can't parse email", e);
    }
    // Add general headers
    messageBuilder.id(mimeMessage.getMessageId());
    messageBuilder.subject(mimeMessage.getSubject());
    messageBuilder.dateReceived(new DateTime(mimeMessage.getDate()));
    // Add From, To and Cc
    if (mimeMessage.getFrom() != null && mimeMessage.getFrom().size() > 0) {
        Mailbox from = mimeMessage.getFrom().get(0);
        messageBuilder.from(new Address(from.getName(), from.getAddress()));
    }
    if (mimeMessage.getTo() != null) {
        for (Mailbox m : mimeMessage.getTo().flatten()) {
            messageBuilder.addTo(new Address(m.getName(), m.getAddress()));
        }
    }
    if (mimeMessage.getCc() != null) {
        for (Mailbox m : mimeMessage.getCc().flatten()) {
            messageBuilder.addCc(new Address(m.getName(), m.getAddress()));
        }
    }
    // Add additional headers
    mimeMessage.getHeader().getFields().stream().filter(f -> !MAIN_HEADERS.contains(f.getName().toLowerCase())).forEach(f -> messageBuilder.addAdditionalHeader(f.getName() + ": " + f.getBody()));
    // Add text and html body parts
    StringBuilder textBuilder = new StringBuilder();
    StringBuilder htmlBuilder = new StringBuilder();
    try {
        handleMimePart(mimeMessage, textBuilder, htmlBuilder);
    } catch (IOException e) {
        throw new MailParsingException("Can't parse email", e);
    }
    messageBuilder.textContent(Strings.emptyToNull(textBuilder.toString()));
    messageBuilder.htmlContent(Strings.emptyToNull(htmlBuilder.toString()));
    try {
        // required attributes are missing, so that the caller doesn't fall over.
        return messageBuilder.build();
    } catch (IllegalStateException e) {
        throw new MailParsingException("Missing required attributes after email was parsed", e);
    }
}
#end_block

#method_before
private static void handleMimePart(Entity part, StringBuilder textBuilder, StringBuilder htmlBuilder) throws IOException {
    if (part.getMimeType().startsWith("text/") && (part.getDispositionType() == null || !part.getDispositionType().equals("attachment"))) {
        TextBody tb = (TextBody) part.getBody();
        String result = CharStreams.toString(new InputStreamReader(tb.getInputStream(), tb.getMimeCharset()));
        if (part.getMimeType().equals("text/plain")) {
            textBuilder.append(result);
        } else if (part.getMimeType().equals("text/html")) {
            htmlBuilder.append(result);
        }
    } else if (part.getMimeType().equals("multipart/alternative") || part.getMimeType().equals("multipart/mixed")) {
        Multipart multipart = (Multipart) part.getBody();
        for (Entity e : multipart.getBodyParts()) {
            handleMimePart(e, textBuilder, htmlBuilder);
        }
    }
}
#method_after
private static void handleMimePart(Entity part, StringBuilder textBuilder, StringBuilder htmlBuilder) throws IOException {
    if (isPlainOrHtml(part.getMimeType()) && !isAttachment(part.getDispositionType())) {
        TextBody tb = (TextBody) part.getBody();
        String result = CharStreams.toString(new InputStreamReader(tb.getInputStream(), tb.getMimeCharset()));
        if (part.getMimeType().equals("text/plain")) {
            textBuilder.append(result);
        } else if (part.getMimeType().equals("text/html")) {
            htmlBuilder.append(result);
        }
    } else if (isMixedOrAlternative(part.getMimeType())) {
        Multipart multipart = (Multipart) part.getBody();
        for (Entity e : multipart.getBodyParts()) {
            handleMimePart(e, textBuilder, htmlBuilder);
        }
    }
}
#end_block

#method_before
private void migrateData(List<SchemaVersion> pending, UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    for (SchemaVersion v : pending) {
        long startSec = System.currentTimeMillis();
        ui.message(String.format("Migrating data to schema %d ...", v.getVersionNbr()));
        v.migrateData(db, ui);
        v.finish(curr, db);
        ui.message(String.format("                          > Done (%.3f s)", (System.currentTimeMillis() - startSec) / 1000.0));
    }
}
#method_after
private void migrateData(List<SchemaVersion> pending, UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    for (SchemaVersion v : pending) {
        Stopwatch sw = Stopwatch.createStarted();
        ui.message(String.format("Migrating data to schema %d ...", v.getVersionNbr()));
        v.migrateData(db, ui);
        v.finish(curr, db);
        ui.message(String.format("\t> Done (%.3f s)", sw.elapsed(TimeUnit.MILLISECONDS) / 1000d));
    }
}
#end_block

#method_before
@Override
public List<Destination> getDestinations(FilterType filterType) {
    Predicate<Destination> filter;
    switch(filterType) {
        case PROJECT_CREATION:
            filter = new Predicate<Destination>() {

                @Override
                public boolean apply(Destination dest) {
                    if (dest == null || !dest.isCreateMissingRepos()) {
                        return false;
                    }
                    return true;
                }
            };
            break;
        case PROJECT_DELETION:
            filter = new Predicate<Destination>() {

                @Override
                public boolean apply(Destination dest) {
                    if (dest == null || !dest.isReplicateProjectDeletions()) {
                        return false;
                    }
                    return true;
                }
            };
            break;
        case ALL:
            return destinations;
        default:
            return destinations;
    }
    return FluentIterable.from(destinations).filter(filter).toList();
}
#method_after
@Override
public List<Destination> getDestinations(FilterType filterType) {
    Predicate<? super Destination> filter;
    switch(filterType) {
        case PROJECT_CREATION:
            filter = dest -> dest.isCreateMissingRepos();
            break;
        case PROJECT_DELETION:
            filter = dest -> dest.isReplicateProjectDeletions();
            break;
        case ALL:
        default:
            filter = dest -> true;
            break;
    }
    return destinations.stream().filter(Objects::nonNull).filter(filter).collect(toList());
}
#end_block

#method_before
private List<Destination> allDestinations(Destination.Factory destinationFactory) throws ConfigInvalidException, IOException {
    if (!config.getFile().exists()) {
        log.warn("Config file " + config.getFile() + " does not exist; not replicating");
        return Collections.emptyList();
    }
    if (config.getFile().length() == 0) {
        log.info("Config file " + config.getFile() + " is empty; not replicating");
        return Collections.emptyList();
    }
    try {
        config.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", config.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", config.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = config.getBoolean("gerrit", "replicateOnStartup", true);
    defaultForceUpdate = config.getBoolean("gerrit", "defaultForceUpdate", false);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(config)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(defaultForceUpdate));
        }
        Destination destination = destinationFactory.create(c, config);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, config.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#method_after
private List<Destination> allDestinations(DestinationFactory destinationFactory) throws ConfigInvalidException, IOException {
    if (!config.getFile().exists()) {
        log.warn("Config file " + config.getFile() + " does not exist; not replicating");
        return Collections.emptyList();
    }
    if (config.getFile().length() == 0) {
        log.info("Config file " + config.getFile() + " is empty; not replicating");
        return Collections.emptyList();
    }
    try {
        config.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", config.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", config.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = config.getBoolean("gerrit", "replicateOnStartup", true);
    defaultForceUpdate = config.getBoolean("gerrit", "defaultForceUpdate", false);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(config)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(defaultForceUpdate));
        }
        Destination destination = destinationFactory.create(new DestinationConfiguration(c, config));
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, config.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ReplicationQueue.class).in(Scopes.SINGLETON);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), HeadUpdatedListener.class).to(ReplicationQueue.class);
    bind(OnStartStop.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(OnStartStop.class);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(ReplicationLogFile.class);
    bind(CredentialsFactory.class).to(AutoReloadSecureCredentialsFactoryDecorator.class).in(Scopes.SINGLETON);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(START_REPLICATION)).to(StartReplicationCapability.class);
    install(new FactoryModuleBuilder().build(PushAll.Factory.class));
    install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class));
    install(new FactoryModuleBuilder().build(Destination.Factory.class));
    bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class);
    bind(ReplicationStateListener.class).to(ReplicationStateLogger.class);
    EventTypes.register(RefReplicatedEvent.TYPE, RefReplicatedEvent.class);
    EventTypes.register(RefReplicationDoneEvent.TYPE, RefReplicationDoneEvent.class);
    bind(SshSessionFactory.class).toProvider(ReplicationSshSessionFactoryProvider.class);
}
#method_after
@Override
protected void configure() {
    bind(DestinationFactory.class).in(Scopes.SINGLETON);
    bind(ReplicationQueue.class).in(Scopes.SINGLETON);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), HeadUpdatedListener.class).to(ReplicationQueue.class);
    bind(OnStartStop.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(OnStartStop.class);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(ReplicationLogFile.class);
    bind(CredentialsFactory.class).to(AutoReloadSecureCredentialsFactoryDecorator.class).in(Scopes.SINGLETON);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(START_REPLICATION)).to(StartReplicationCapability.class);
    install(new FactoryModuleBuilder().build(PushAll.Factory.class));
    install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class));
    bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class);
    bind(ReplicationStateListener.class).to(ReplicationStateLogger.class);
    EventTypes.register(RefReplicatedEvent.TYPE, RefReplicatedEvent.class);
    EventTypes.register(RefReplicationDoneEvent.TYPE, RefReplicationDoneEvent.class);
    bind(SshSessionFactory.class).toProvider(ReplicationSshSessionFactoryProvider.class);
}
#end_block

#method_before
@Override
public Void call() throws IOException {
    // change ID.
    for (ChangeIndex i : getWriteIndexes()) {
        i.delete(id);
    }
    log.info(String.format("Deleted change %d from index.", id.get()));
    fireChangeDeletedFromIndexEvent(id.get());
    return null;
}
#method_after
@Override
public Void call() throws IOException {
    // change ID.
    for (ChangeIndex i : getWriteIndexes()) {
        i.delete(id);
    }
    log.info("Deleted change {} from index.", id.get());
    fireChangeDeletedFromIndexEvent(id.get());
    return null;
}
#end_block

#method_before
@Override
public void sendRedirect(String location) throws IOException {
    this.status = SC_MOVED_TEMPORARILY;
    super.setHeader("Location", location);
}
#method_after
@Override
public void sendRedirect(String location) throws IOException {
    this.status = SC_MOVED_TEMPORARILY;
    setHeader(LOCATION_HEADER, location);
}
#end_block

#method_before
@Override
public void setHeader(String name, String value) {
    super.setHeader(name, value);
    headers.put(name.toLowerCase(), value);
}
#method_after
@Override
public void setHeader(String name, String value) {
    super.setHeader(name, value);
    headers.put(name, value);
}
#end_block

#method_before
@Override
public int getStatus() {
    return status;
}
#method_after
@SuppressWarnings("all")
public // to servlet-api 3.1
int getStatus() {
    return status;
}
#end_block

#method_before
void play() throws IOException {
    if (status != 0) {
        log.debug("Replaying {} {}", status, statusMsg);
        if (status == SC_MOVED_TEMPORARILY) {
            super.sendRedirect(headers.get("location"));
        } else {
            super.sendError(status, statusMsg);
        }
    }
}
#method_after
void play() throws IOException {
    if (status != 0) {
        log.debug("Replaying {} {}", status, statusMsg);
        if (status == SC_MOVED_TEMPORARILY) {
            super.sendRedirect(headers.get(LOCATION_HEADER));
        } else {
            super.sendError(status, statusMsg);
        }
    }
}
#end_block

#method_before
private List<ChangeControl> changeFromNotesFactory(String id, CurrentUser currentUser) throws OrmException {
    return changeNotesFactory.create(db, Arrays.asList(Change.Id.parse(id))).stream().map(changeNote -> controlForChange(changeNote, currentUser)).filter(changeControl -> changeControl.isPresent()).map(changeControl -> changeControl.get()).collect(Collectors.toList());
}
#method_after
private List<ChangeControl> changeFromNotesFactory(String id, CurrentUser currentUser) throws OrmException {
    return changeNotesFactory.create(db, Arrays.asList(Change.Id.parse(id))).stream().map(changeNote -> controlForChange(changeNote, currentUser)).filter(changeControl -> changeControl.isPresent()).map(changeControl -> changeControl.get()).collect(toList());
}
#end_block

#method_before
public ImmutableSet<Project.NameKey> getProjectsInOrder() throws SubmoduleException {
    LinkedHashSet<Project.NameKey> projects = new LinkedHashSet<>();
    for (Project.NameKey project : branchesByProject.keySet()) {
        if (projects.contains(project)) {
            continue;
        }
        addAllSubmoduleProjects(project, new LinkedHashSet<>(), projects);
    }
    for (Branch.NameKey branch : updatedBranches) {
        projects.add(branch.getParentKey());
    }
    return ImmutableSet.copyOf(projects);
}
#method_after
public ImmutableSet<Project.NameKey> getProjectsInOrder() throws SubmoduleException {
    LinkedHashSet<Project.NameKey> projects = new LinkedHashSet<>();
    for (Project.NameKey project : branchesByProject.keySet()) {
        addAllSubmoduleProjects(project, new LinkedHashSet<>(), projects);
    }
    for (Branch.NameKey branch : updatedBranches) {
        projects.add(branch.getParentKey());
    }
    return ImmutableSet.copyOf(projects);
}
#end_block

#method_before
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    return ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.ABANDON);
}
#method_after
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    return ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_ABANDON);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    newTopicName = Strings.nullToEmpty(input.topic);
    oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (oldTopicName.equals(newTopicName)) {
        return false;
    }
    String summary;
    if (oldTopicName.isEmpty()) {
        summary = "Topic set to " + newTopicName;
    } else if (newTopicName.isEmpty()) {
        summary = "Topic " + oldTopicName + " removed";
    } else {
        summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
    }
    change.setTopic(Strings.emptyToNull(newTopicName));
    update.setTopic(change.getTopic());
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, summary, ChangeMessagesUtil.PUT_TOPIC);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    newTopicName = Strings.nullToEmpty(input.topic);
    oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (oldTopicName.equals(newTopicName)) {
        return false;
    }
    String summary;
    if (oldTopicName.isEmpty()) {
        summary = "Topic set to " + newTopicName;
    } else if (newTopicName.isEmpty()) {
        summary = "Topic " + oldTopicName + " removed";
    } else {
        summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
    }
    change.setTopic(Strings.emptyToNull(newTopicName));
    update.setTopic(change.getTopic());
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, summary, ChangeMessagesUtil.TAG_SET_TOPIC);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commit);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commit, draft, newGroups, pushCert);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewers), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(db, patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.CHANGE_INSERTER);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commit);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commit, draft, newGroups, pushCert);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewers), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(db, patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update, Account previousAssignee) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Assignee ");
    if (previousAssignee == null) {
        msg.append("added: ");
        msg.append(newAssignee.getName(anonymousCowardName));
    } else {
        msg.append("changed from: ");
        msg.append(previousAssignee.getName(anonymousCowardName));
        msg.append(" to: ");
        msg.append(newAssignee.getName(anonymousCowardName));
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.SET_ASSIGNEE_OP);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#method_after
private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update, Account previousAssignee) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Assignee ");
    if (previousAssignee == null) {
        msg.append("added: ");
        msg.append(newAssignee.getName(anonymousCowardName));
    } else {
        msg.append("changed from: ");
        msg.append(previousAssignee.getName(anonymousCowardName));
        msg.append(" to: ");
        msg.append(newAssignee.getName(anonymousCowardName));
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_SET_ASSIGNEE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#end_block

#method_before
private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update, Account deleted) throws OrmException {
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, "Assignee deleted: " + deleted.getName(anonymousCowardName), ChangeMessagesUtil.DELETE_ASSIGNEE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#method_after
private void addMessage(BatchUpdate.ChangeContext ctx, ChangeUpdate update, Account deleted) throws OrmException {
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, "Assignee deleted: " + deleted.getName(anonymousCowardName), ChangeMessagesUtil.TAG_DELETE_ASSIGNEE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws Exception {
    changeKind = changeKindCache.getChangeKind(projectControl.getProject().getNameKey(), ctx.getRepository(), priorCommit, commit);
    if (checkMergedInto) {
        Ref mergedInto = findMergedInto(ctx, dest.get(), commit);
        if (mergedInto != null) {
            mergedByPushOp = mergedByPushOpFactory.create(requestScopePropagator, patchSetId, mergedInto.getName());
        }
    }
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws Exception {
    changeKind = changeKindCache.getChangeKind(projectControl.getProject().getNameKey(), ctx.getRepository(), priorCommit, commit);
    if (checkMergedInto) {
        Ref mergedInto = findMergedInto(ctx, dest.get(), commit);
        if (mergedInto != null) {
            mergedByPushOp = mergedByPushOpFactory.create(requestScopePropagator, patchSetId, mergedInto.getName());
        }
    }
    if (updateRef) {
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, patchSetId.toRefName()));
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovalsForNewPatchSet(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = ChangeMessagesUtil.newMessage(ctx.getDb(), patchSetId, ctx.getUser(), ctx.getWhen(), message.toString(), ChangeMessagesUtil.REPLACE_OP);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx, msg);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovalsForNewPatchSet(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = ChangeMessagesUtil.newMessage(ctx.getDb(), patchSetId, ctx.getUser(), ctx.getWhen(), message.toString(), ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx, msg);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(final Context ctx) throws Exception {
    // Normally the ref updated hook is fired by BatchUpdate, but ReplaceOp is
    // special because its ref is actually updated by ReceiveCommits, so from
    // BatchUpdate's perspective there is no ref update. Thus we have to fire it
    // manually.
    final Account account = ctx.getAccount();
    gitRefUpdated.fire(ctx.getProject(), newPatchSet.getRefName(), ObjectId.zeroId(), commit, account);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(projectControl.getProject().getNameKey(), change.getId());
                    cm.setFrom(account.getId());
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
                    if (magicBranch != null && magicBranch.notify != null) {
                        cm.setNotify(magicBranch.notify);
                    }
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    NotifyHandling notify = magicBranch != null && magicBranch.notify != null ? magicBranch.notify : NotifyHandling.ALL;
    revisionCreated.fire(change, newPatchSet, ctx.getAccount(), ctx.getWhen(), notify);
    try {
        fireCommentAddedEvent(ctx);
    } catch (Exception e) {
        log.warn("comment-added event invocation failed", e);
    }
    if (mergedByPushOp != null) {
        mergedByPushOp.postUpdate(ctx);
    }
}
#method_after
@Override
public void postUpdate(final Context ctx) throws Exception {
    // Normally the ref updated hook is fired by BatchUpdate, but ReplaceOp is
    // special because its ref is actually updated by ReceiveCommits, so from
    // BatchUpdate's perspective there is no ref update. Thus we have to fire it
    // manually.
    final Account account = ctx.getAccount();
    if (!updateRef) {
        gitRefUpdated.fire(ctx.getProject(), newPatchSet.getRefName(), ObjectId.zeroId(), commit, account);
    }
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(projectControl.getProject().getNameKey(), change.getId());
                    cm.setFrom(account.getId());
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
                    if (magicBranch != null && magicBranch.notify != null) {
                        cm.setNotify(magicBranch.notify);
                    }
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    NotifyHandling notify = magicBranch != null && magicBranch.notify != null ? magicBranch.notify : NotifyHandling.ALL;
    revisionCreated.fire(change, newPatchSet, ctx.getAccount(), ctx.getWhen(), notify);
    try {
        fireCommentAddedEvent(ctx);
    } catch (Exception e) {
        log.warn("comment-added event invocation failed", e);
    }
    if (mergedByPushOp != null) {
        mergedByPushOp.postUpdate(ctx);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, ResourceNotFoundException, OrmException {
    Account.Id reviewerId = reviewer.getId();
    if (!approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).all().contains(reviewerId)) {
        throw new ResourceNotFoundException();
    }
    currChange = ctx.getChange();
    currPs = psUtil.current(ctx.getDb(), ctx.getNotes());
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    // removing a reviewer will remove all her votes
    for (LabelType lt : labelTypes.getLabelTypes()) {
        newApprovals.put(lt.getName(), (short) 0);
    }
    StringBuilder msg = new StringBuilder();
    msg.append("Removed reviewer " + reviewer.getFullName());
    StringBuilder removedVotesMsg = new StringBuilder();
    removedVotesMsg.append(" with the following votes:\n\n");
    boolean votesRemoved = false;
    for (PatchSetApproval a : approvals(ctx, reviewerId)) {
        if (ctx.getControl().canRemoveReviewer(a)) {
            del.add(a);
            if (a.getPatchSetId().equals(currPs.getId()) && a.getValue() != 0) {
                oldApprovals.put(a.getLabel(), a.getValue());
                removedVotesMsg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                votesRemoved = true;
            }
        } else {
            throw new AuthException("delete reviewer not permitted");
        }
    }
    if (votesRemoved) {
        msg.append(removedVotesMsg);
    } else {
        msg.append(".");
    }
    ctx.getDb().patchSetApprovals().delete(del);
    ChangeUpdate update = ctx.getUpdate(currPs.getId());
    update.removeReviewer(reviewerId);
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.DELETE_REVIEWER);
    cmUtil.addChangeMessage(ctx.getDb(), update, changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, ResourceNotFoundException, OrmException {
    Account.Id reviewerId = reviewer.getId();
    if (!approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).all().contains(reviewerId)) {
        throw new ResourceNotFoundException();
    }
    currChange = ctx.getChange();
    currPs = psUtil.current(ctx.getDb(), ctx.getNotes());
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    // removing a reviewer will remove all her votes
    for (LabelType lt : labelTypes.getLabelTypes()) {
        newApprovals.put(lt.getName(), (short) 0);
    }
    StringBuilder msg = new StringBuilder();
    msg.append("Removed reviewer " + reviewer.getFullName());
    StringBuilder removedVotesMsg = new StringBuilder();
    removedVotesMsg.append(" with the following votes:\n\n");
    boolean votesRemoved = false;
    for (PatchSetApproval a : approvals(ctx, reviewerId)) {
        if (ctx.getControl().canRemoveReviewer(a)) {
            del.add(a);
            if (a.getPatchSetId().equals(currPs.getId()) && a.getValue() != 0) {
                oldApprovals.put(a.getLabel(), a.getValue());
                removedVotesMsg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                votesRemoved = true;
            }
        } else {
            throw new AuthException("delete reviewer not permitted");
        }
    }
    if (votesRemoved) {
        msg.append(removedVotesMsg);
    } else {
        msg.append(".");
    }
    ctx.getDb().patchSetApprovals().delete(del);
    ChangeUpdate update = ctx.getUpdate(currPs.getId());
    update.removeReviewer(reviewerId);
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_REVIEWER);
    cmUtil.addChangeMessage(ctx.getDb(), update, changeMessage);
    return true;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, RepositoryNotFoundException, IOException {
    change = ctx.getChange();
    if (change.getStatus() != Status.NEW && change.getStatus() != Status.DRAFT) {
        throw new ResourceConflictException("Change is " + status(change));
    }
    Project.NameKey projectKey = change.getProject();
    newDestKey = new Branch.NameKey(projectKey, input.destinationBranch);
    Branch.NameKey changePrevDest = change.getDest();
    if (changePrevDest.equals(newDestKey)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    try (Repository repo = repoManager.openRepository(projectKey);
        RevWalk revWalk = new RevWalk(repo)) {
        RevCommit currPatchsetRevCommit = revWalk.parseCommit(ObjectId.fromString(psUtil.current(ctx.getDb(), ctx.getNotes()).getRevision().get()));
        if (currPatchsetRevCommit.getParentCount() > 1) {
            throw new ResourceConflictException("Merge commit cannot be moved");
        }
        ObjectId refId = repo.resolve(input.destinationBranch);
        // Check if destination ref exists in project repo
        if (refId == null) {
            throw new ResourceConflictException("Destination " + input.destinationBranch + " not found in the project");
        }
        RevCommit refCommit = revWalk.parseCommit(refId);
        if (revWalk.isMergedInto(currPatchsetRevCommit, refCommit)) {
            throw new ResourceConflictException("Current patchset revision is reachable from tip of " + input.destinationBranch);
        }
    }
    Change.Key changeKey = change.getKey();
    if (!asChanges(queryProvider.get().byBranchKey(newDestKey, changeKey)).isEmpty()) {
        throw new ResourceConflictException("Destination " + newDestKey.getShortName() + " has a different change with same change key " + changeKey);
    }
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new ResourceConflictException("Patch set is not current");
    }
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    update.setBranch(newDestKey.get());
    change.setDest(newDestKey);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change destination moved from ");
    msgBuf.append(changePrevDest.getShortName());
    msgBuf.append(" to ");
    msgBuf.append(newDestKey.getShortName());
    if (!Strings.isNullOrEmpty(input.message)) {
        msgBuf.append("\n\n");
        msgBuf.append(input.message);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msgBuf.toString(), ChangeMessagesUtil.MOVE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, RepositoryNotFoundException, IOException {
    change = ctx.getChange();
    if (change.getStatus() != Status.NEW && change.getStatus() != Status.DRAFT) {
        throw new ResourceConflictException("Change is " + status(change));
    }
    Project.NameKey projectKey = change.getProject();
    newDestKey = new Branch.NameKey(projectKey, input.destinationBranch);
    Branch.NameKey changePrevDest = change.getDest();
    if (changePrevDest.equals(newDestKey)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    try (Repository repo = repoManager.openRepository(projectKey);
        RevWalk revWalk = new RevWalk(repo)) {
        RevCommit currPatchsetRevCommit = revWalk.parseCommit(ObjectId.fromString(psUtil.current(ctx.getDb(), ctx.getNotes()).getRevision().get()));
        if (currPatchsetRevCommit.getParentCount() > 1) {
            throw new ResourceConflictException("Merge commit cannot be moved");
        }
        ObjectId refId = repo.resolve(input.destinationBranch);
        // Check if destination ref exists in project repo
        if (refId == null) {
            throw new ResourceConflictException("Destination " + input.destinationBranch + " not found in the project");
        }
        RevCommit refCommit = revWalk.parseCommit(refId);
        if (revWalk.isMergedInto(currPatchsetRevCommit, refCommit)) {
            throw new ResourceConflictException("Current patchset revision is reachable from tip of " + input.destinationBranch);
        }
    }
    Change.Key changeKey = change.getKey();
    if (!asChanges(queryProvider.get().byBranchKey(newDestKey, changeKey)).isEmpty()) {
        throw new ResourceConflictException("Destination " + newDestKey.getShortName() + " has a different change with same change key " + changeKey);
    }
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new ResourceConflictException("Patch set is not current");
    }
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    update.setBranch(newDestKey.get());
    change.setDest(newDestKey);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change destination moved from ");
    msgBuf.append(changePrevDest.getShortName());
    msgBuf.append(" to ");
    msgBuf.append(newDestKey.getShortName());
    if (!Strings.isNullOrEmpty(input.message)) {
        msgBuf.append("\n\n");
        msgBuf.append(input.message);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msgBuf.toString(), ChangeMessagesUtil.TAG_MOVE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#end_block

#method_before
private void sendReplacePatchSet(Context ctx) throws EmailException, OrmException {
    ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), "Uploaded patch set " + psId.get() + ".", ChangeMessagesUtil.PUBLISH_DRAFT_PATCH_SET);
    ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
    cm.setFrom(ctx.getAccountId());
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#method_after
private void sendReplacePatchSet(Context ctx) throws EmailException, OrmException {
    ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), "Uploaded patch set " + psId.get() + ".", ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
    cm.setFrom(ctx.getAccountId());
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#end_block

#method_before
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Restored");
    if (!Strings.nullToEmpty(input.message).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(input.message.trim());
    }
    return ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.RESTORE);
}
#method_after
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Restored");
    if (!Strings.nullToEmpty(input.message).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(input.message.trim());
    }
    return ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_RESTORE);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException {
    ChangeControl ctl = ctx.getControl();
    change = ctl.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ps = psUtil.current(db.get(), ctl.getNotes());
    boolean found = false;
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
        if (labelTypes.byLabel(a.getLabelId()) == null) {
            // Ignore undefined labels.
            continue;
        } else if (!a.getLabel().equals(label)) {
            // Populate map for non-matching labels, needed by VoteDeleted.
            newApprovals.put(a.getLabel(), a.getValue());
            continue;
        } else if (!ctl.canRemoveReviewer(a)) {
            throw new AuthException("delete vote not permitted");
        }
        // Set the approval to 0 if vote is being removed.
        newApprovals.put(a.getLabel(), (short) 0);
        found = true;
        // Set old value, as required by VoteDeleted.
        oldApprovals.put(a.getLabel(), a.getValue());
        break;
    }
    if (!found) {
        throw new ResourceNotFoundException();
    }
    ctx.getUpdate(psId).removeApprovalFor(accountId, label);
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(deletedApproval(ctx)));
    StringBuilder msg = new StringBuilder();
    msg.append("Removed ");
    LabelVote.appendTo(msg, label, checkNotNull(oldApprovals.get(label)));
    msg.append(" by ").append(userFactory.create(accountId).getNameEmail()).append("\n");
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.DELETE_VOTE);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException {
    ChangeControl ctl = ctx.getControl();
    change = ctl.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ps = psUtil.current(db.get(), ctl.getNotes());
    boolean found = false;
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
        if (labelTypes.byLabel(a.getLabelId()) == null) {
            // Ignore undefined labels.
            continue;
        } else if (!a.getLabel().equals(label)) {
            // Populate map for non-matching labels, needed by VoteDeleted.
            newApprovals.put(a.getLabel(), a.getValue());
            continue;
        } else if (!ctl.canRemoveReviewer(a)) {
            throw new AuthException("delete vote not permitted");
        }
        // Set the approval to 0 if vote is being removed.
        newApprovals.put(a.getLabel(), (short) 0);
        found = true;
        // Set old value, as required by VoteDeleted.
        oldApprovals.put(a.getLabel(), a.getValue());
        break;
    }
    if (!found) {
        throw new ResourceNotFoundException();
    }
    ctx.getUpdate(psId).removeApprovalFor(accountId, label);
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(deletedApproval(ctx)));
    StringBuilder msg = new StringBuilder();
    msg.append("Removed ");
    LabelVote.appendTo(msg, label, checkNotNull(oldApprovals.get(label)));
    msg.append(" by ").append(userFactory.create(accountId).getNameEmail()).append("\n");
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_VOTE);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    return true;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new ResourceConflictException(String.format("Cannot create new patch set of change %s because it is %s", change.getId(), change.getStatus().name().toLowerCase()));
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        PatchSet prevPs = psUtil.current(db, ctx.getNotes());
        if (prevPs != null) {
            newGroups = prevPs.getGroups();
        }
    }
    patchSet = psUtil.insert(db, ctx.getRevWalk(), ctx.getUpdate(psId), psId, commit, draft, newGroups, null);
    if (notify != NotifyHandling.NONE) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(db, patchSet.getId(), ctx.getUser(), ctx.getWhen(), message, ChangeMessagesUtil.PATCH_SET_INSERTER);
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new ResourceConflictException(String.format("Cannot create new patch set of change %s because it is %s", change.getId(), change.getStatus().name().toLowerCase()));
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        PatchSet prevPs = psUtil.current(db, ctx.getNotes());
        if (prevPs != null) {
            newGroups = prevPs.getGroups();
        }
    }
    patchSet = psUtil.insert(db, ctx.getRevWalk(), ctx.getUpdate(psId), psId, commit, draft, newGroups, null);
    if (notify != NotifyHandling.NONE) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(db, patchSet.getId(), ctx.getUser(), ctx.getWhen(), message, ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
private ChangeMessage message(ChangeContext ctx, PatchSet.Id psId, String body) throws OrmException {
    return ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), body, ChangeMessagesUtil.SUBMIT_STRATEGY_OP);
}
#method_after
private ChangeMessage message(ChangeContext ctx, PatchSet.Id psId, String body) throws OrmException {
    return ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), body, ChangeMessagesUtil.TAG_MERGED);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    StringBuilder sb = new StringBuilder("Patch Set ").append(psId.get()).append(": Cherry Picked").append("\n\n").append("This patchset was cherry picked to branch ").append(destBranch).append(" as commit ").append(cherryPickCommit.name());
    ChangeMessage changeMessage = ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), sb.toString(), ChangeMessagesUtil.CHERRY_PICK_CHANGE);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    StringBuilder sb = new StringBuilder("Patch Set ").append(psId.get()).append(": Cherry Picked").append("\n\n").append("This patchset was cherry picked to branch ").append(destBranch).append(" as commit ").append(cherryPickCommit.name());
    ChangeMessage changeMessage = ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), sb.toString(), ChangeMessagesUtil.TAG_CHERRY_PICK_CHANGE);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    return true;
}
#end_block

#method_before
private void addMessage(ChangeContext ctx, ChangeUpdate update) throws OrmException {
    StringBuilder msg = new StringBuilder();
    appendHashtagMessage(msg, "added", toAdd);
    appendHashtagMessage(msg, "removed", toRemove);
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.SET_HASHTAGS_OP);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#method_after
private void addMessage(ChangeContext ctx, ChangeUpdate update) throws OrmException {
    StringBuilder msg = new StringBuilder();
    appendHashtagMessage(msg, "added", toAdd);
    appendHashtagMessage(msg, "removed", toRemove);
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_SET_HASHTAGS);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
}
#end_block

#method_before
public List<SubmitRecord> getSubmitRecords(Change.Id id) {
    // Use the cached submit records from the original ChangeData in the input
    // ChangeSet, which were checked earlier in the integrate process. Even in
    // the case of a race where the submit records may have changed, it makes
    // more sense to store the original results of the submit rule evaluator
    // than to fail at this point.
    // 
    // However, do NOT expose that ChangeData directly, as it is way out of
    // date by this point.
    ChangeData cd = checkNotNull(changes.get(id), "ChangeData for %s", id);
    return checkNotNull(cd.getSubmitRecords(), "getSubmitRecord only valid after submit rules are evalutated");
}
#method_after
public List<SubmitRecord> getSubmitRecords(Change.Id id) {
    // Use the cached submit records from the original ChangeData in the input
    // ChangeSet, which were checked earlier in the integrate process. Even in
    // the case of a race where the submit records may have changed, it makes
    // more sense to store the original results of the submit rule evaluator
    // than to fail at this point.
    // 
    // However, do NOT expose that ChangeData directly, as it is way out of
    // date by this point.
    ChangeData cd = checkNotNull(changes.get(id), "ChangeData for %s", id);
    return checkNotNull(cd.getSubmitRecords(SUBMIT_RULE_OPTIONS), "getSubmitRecord only valid after submit rules are evalutated");
}
#end_block

#method_before
public static void checkSubmitRule(ChangeData cd) throws ResourceConflictException, OrmException {
    PatchSet patchSet = cd.currentPatchSet();
    if (patchSet == null) {
        throw new ResourceConflictException("missing current patch set for change " + cd.getId());
    }
    List<SubmitRecord> results = getSubmitRecords(cd);
    if (findOkRecord(results).isPresent()) {
        // Rules supplied a valid solution.
        return;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("SubmitRuleEvaluator.evaluate for change %s " + "returned empty list for %s in %s", cd.getId(), patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException("submit rule error: " + record.errorMessage);
            case NOT_READY:
                throw new ResourceConflictException(describeLabels(cd, record.labels));
            case FORCED:
            case OK:
            default:
                throw new IllegalStateException(String.format("Unexpected SubmitRecord status %s for %s in %s", record.status, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#method_after
public static void checkSubmitRule(ChangeData cd) throws ResourceConflictException, OrmException {
    PatchSet patchSet = cd.currentPatchSet();
    if (patchSet == null) {
        throw new ResourceConflictException("missing current patch set for change " + cd.getId());
    }
    List<SubmitRecord> results = getSubmitRecords(cd);
    if (SubmitRecord.findOkRecord(results).isPresent()) {
        // Rules supplied a valid solution.
        return;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("SubmitRuleEvaluator.evaluate for change %s " + "returned empty list for %s in %s", cd.getId(), patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException("submit rule error: " + record.errorMessage);
            case NOT_READY:
                throw new ResourceConflictException(describeLabels(cd, record.labels));
            case FORCED:
            case OK:
            default:
                throw new IllegalStateException(String.format("Unexpected SubmitRecord status %s for %s in %s", record.status, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#end_block

#method_before
private static List<SubmitRecord> getSubmitRecords(ChangeData cd) throws OrmException {
    List<SubmitRecord> results = cd.getSubmitRecords();
    if (results == null) {
        results = new SubmitRuleEvaluator(cd).evaluate();
        cd.setSubmitRecords(results);
    }
    return results;
}
#method_after
private static List<SubmitRecord> getSubmitRecords(ChangeData cd) throws OrmException {
    return cd.submitRecords(SUBMIT_RULE_OPTIONS);
}
#end_block

#method_before
private void bypassSubmitRules(ChangeSet cs) {
    checkArgument(!cs.furtherHiddenChanges(), "cannot bypass submit rules for topic with hidden change");
    for (ChangeData cd : cs.changes()) {
        List<SubmitRecord> records;
        try {
            records = new ArrayList<>(getSubmitRecords(cd));
        } catch (OrmException e) {
            log.warn("Error checking submit rules for change " + cd.getId(), e);
            records = new ArrayList<>(1);
        }
        SubmitRecord forced = new SubmitRecord();
        forced.status = SubmitRecord.Status.FORCED;
        records.add(forced);
        cd.setSubmitRecords(records);
    }
}
#method_after
private void bypassSubmitRules(ChangeSet cs) {
    checkArgument(!cs.furtherHiddenChanges(), "cannot bypass submit rules for topic with hidden change");
    for (ChangeData cd : cs.changes()) {
        List<SubmitRecord> records;
        try {
            records = new ArrayList<>(getSubmitRecords(cd));
        } catch (OrmException e) {
            log.warn("Error checking submit rules for change " + cd.getId(), e);
            records = new ArrayList<>(1);
        }
        SubmitRecord forced = new SubmitRecord();
        forced.status = SubmitRecord.Status.FORCED;
        records.add(forced);
        cd.setSubmitRecords(SUBMIT_RULE_OPTIONS, records);
    }
}
#end_block

#method_before
private void abandonAllOpenChangeForDeletedProject(Project.NameKey destProject) {
    try {
        for (ChangeData cd : internalChangeQuery.byProjectOpen(destProject)) {
            try (BatchUpdate bu = batchUpdateFactory.create(db, destProject, internalUserFactory.create(), ts)) {
                bu.setRequestId(submissionId);
                bu.addOp(cd.getId(), new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) throws OrmException {
                        Change change = ctx.getChange();
                        if (!change.getStatus().isOpen()) {
                            return false;
                        }
                        change.setStatus(Change.Status.ABANDONED);
                        ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx.getDb(), change.currentPatchSetId(), internalUserFactory.create(), change.getLastUpdatedOn(), ChangeMessagesUtil.MERGE_OP, "Project was deleted.");
                        cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(change.currentPatchSetId()), msg);
                        return true;
                    }
                });
                try {
                    bu.execute();
                } catch (UpdateException | RestApiException e) {
                    logWarn("Cannot abandon changes for deleted project " + destProject, e);
                }
            }
        }
    } catch (OrmException e) {
        logWarn("Cannot abandon changes for deleted project " + destProject, e);
    }
}
#method_after
private void abandonAllOpenChangeForDeletedProject(Project.NameKey destProject) {
    try {
        for (ChangeData cd : internalChangeQuery.byProjectOpen(destProject)) {
            try (BatchUpdate bu = batchUpdateFactory.create(db, destProject, internalUserFactory.create(), ts)) {
                bu.setRequestId(submissionId);
                bu.addOp(cd.getId(), new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) throws OrmException {
                        Change change = ctx.getChange();
                        if (!change.getStatus().isOpen()) {
                            return false;
                        }
                        change.setStatus(Change.Status.ABANDONED);
                        ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx.getDb(), change.currentPatchSetId(), internalUserFactory.create(), change.getLastUpdatedOn(), ChangeMessagesUtil.TAG_MERGED, "Project was deleted.");
                        cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(change.currentPatchSetId()), msg);
                        return true;
                    }
                });
                try {
                    bu.execute();
                } catch (UpdateException | RestApiException e) {
                    logWarn("Cannot abandon changes for deleted project " + destProject, e);
                }
            }
        }
    } catch (OrmException e) {
        logWarn("Cannot abandon changes for deleted project " + destProject, e);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    correctBranch = refName.equals(change.getDest().get());
    if (!correctBranch) {
        return false;
    }
    if (patchSetProvider != null) {
        // Caller might have also arranged for construction of a new patch set
        // that is not present in the old notes so we can't use PatchSetUtil.
        patchSet = patchSetProvider.get();
    } else {
        patchSet = checkNotNull(psUtil.get(ctx.getDb(), ctx.getNotes(), psId), "patch set %s not found", psId);
    }
    info = getPatchSetInfo(ctx);
    ChangeUpdate update = ctx.getUpdate(psId);
    if (change.getStatus().isOpen()) {
        change.setCurrentPatchSet(info);
        change.setStatus(Change.Status.MERGED);
        // we cannot reconstruct the submit records for when this change was
        // submitted, this is why we must fix the status
        update.fixStatus(Change.Status.MERGED);
    }
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!refName.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (refName.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(refName));
        } else {
            msgBuf.append(refName);
        }
    }
    msgBuf.append(".");
    ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), msgBuf.toString(), ChangeMessagesUtil.MERGED_BY_PUSH_OP);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    PatchSetApproval submitter = ApprovalsUtil.newApproval(change.currentPatchSetId(), ctx.getUser(), LabelId.legacySubmit(), 1, ctx.getWhen());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    correctBranch = refName.equals(change.getDest().get());
    if (!correctBranch) {
        return false;
    }
    if (patchSetProvider != null) {
        // Caller might have also arranged for construction of a new patch set
        // that is not present in the old notes so we can't use PatchSetUtil.
        patchSet = patchSetProvider.get();
    } else {
        patchSet = checkNotNull(psUtil.get(ctx.getDb(), ctx.getNotes(), psId), "patch set %s not found", psId);
    }
    info = getPatchSetInfo(ctx);
    ChangeUpdate update = ctx.getUpdate(psId);
    if (change.getStatus().isOpen()) {
        change.setCurrentPatchSet(info);
        change.setStatus(Change.Status.MERGED);
        // we cannot reconstruct the submit records for when this change was
        // submitted, this is why we must fix the status
        update.fixStatus(Change.Status.MERGED);
    }
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!refName.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (refName.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(refName));
        } else {
            msgBuf.append(refName);
        }
    }
    msgBuf.append(".");
    ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), msgBuf.toString(), ChangeMessagesUtil.TAG_MERGED);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    PatchSetApproval submitter = ApprovalsUtil.newApproval(change.currentPatchSetId(), ctx.getUser(), LabelId.legacySubmit(), 1, ctx.getWhen());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
    return true;
}
#end_block

#method_before
public static ChangeMessage newMessage(BatchUpdate.ChangeContext ctx, String body, String tag) throws OrmException {
    return newMessage(ctx.getDb(), ctx.getChange().currentPatchSetId(), ctx.getUser(), ctx.getWhen(), body, tag);
}
#method_after
public static ChangeMessage newMessage(BatchUpdate.ChangeContext ctx, String body, @Nullable String tag) throws OrmException {
    return newMessage(ctx.getDb(), ctx.getChange().currentPatchSetId(), ctx.getUser(), ctx.getWhen(), body, tag);
}
#end_block

#method_before
public static ChangeMessage newMessage(ReviewDb db, PatchSet.Id psId, CurrentUser user, Timestamp when, String body, String tag) throws OrmException {
    checkNotNull(psId);
    Account.Id accountId = user.isInternalUser() ? null : user.getAccountId();
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(db)), accountId, when, psId);
    m.setMessage(body);
    m.setTag(tag);
    user.updateRealAccountId(m::setRealAuthor);
    return m;
}
#method_after
public static ChangeMessage newMessage(ReviewDb db, PatchSet.Id psId, CurrentUser user, Timestamp when, String body, @Nullable String tag) throws OrmException {
    checkNotNull(psId);
    Account.Id accountId = user.isInternalUser() ? null : user.getAccountId();
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(db)), accountId, when, psId);
    m.setMessage(body);
    m.setTag(tag);
    user.updateRealAccountId(m::setRealAuthor);
    return m;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    PatchSet.Id patchSetId = change.currentPatchSetId();
    ChangeMessage changeMessage = ChangeMessagesUtil.newMessage(ctx, "Created a revert of this change as I" + computedChangeId.name(), ChangeMessagesUtil.REVERT);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(patchSetId), changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    PatchSet.Id patchSetId = change.currentPatchSetId();
    ChangeMessage changeMessage = ChangeMessagesUtil.newMessage(ctx, "Created a revert of this change as I" + computedChangeId.name(), ChangeMessagesUtil.TAG_REVERT);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(patchSetId), changeMessage);
    return true;
}
#end_block

#method_before
protected void ccExistingReviewers() {
    if (!NotifyHandling.ALL.equals(notify) && !NotifyHandling.OWNER_REVIEWERS.equals(notify)) {
        return;
    }
    try {
        for (Account.Id id : changeData.reviewers().byState(REVIEWER)) {
            add(RecipientType.CC, id);
        }
    } catch (OrmException err) {
        log.warn("Cannot CC users that commented on updated change", err);
    }
}
#method_after
protected void ccExistingReviewers() {
    if (!NotifyHandling.ALL.equals(notify) && !NotifyHandling.OWNER_REVIEWERS.equals(notify)) {
        return;
    }
    try {
        for (Account.Id id : changeData.reviewers().byState(ReviewerStateInternal.REVIEWER)) {
            add(RecipientType.CC, id);
        }
    } catch (OrmException err) {
        log.warn("Cannot CC users that commented on updated change", err);
    }
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    soyContext.put("change", changeData);
    String subject = change.getSubject();
    changeData.put("subject", subject);
    // it exceeds that.
    if (subject.length() < 64) {
        changeData.put("shortSubject", subject);
    } else {
        changeData.put("shortSubject", subject.substring(0, 60) + "...");
    }
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
    soyContext.put("reviewerEmails", getReviewerEmails());
// TODO(wyatta): patchSetInfo
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    soyContext.put("change", changeData);
    String subject = change.getSubject();
    changeData.put("subject", subject);
    // it exceeds that.
    if (subject.length() < 64) {
        changeData.put("shortSubject", subject);
    } else {
        changeData.put("shortSubject", subject.substring(0, 60) + "...");
    }
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
    soyContext.put("reviewerEmails", getEmailsByState(ReviewerStateInternal.REVIEWER));
    soyContext.put("ccEmails", getEmailsByState(ReviewerStateInternal.CC));
// TODO(wyatta): patchSetInfo
}
#end_block

#method_before
public void addReviewers(Change change, Collection<Account.Id> reviewers) throws ReviewerManagerException {
    addReviewersAs(change, reviewers, change.getOwner());
}
#method_after
public void addReviewers(Change change, Collection<Account.Id> reviewers) throws ReviewerManagerException {
    try (ManualRequestContext ctx = requestContext.openAs(change.getOwner())) {
        ChangeApi cApi = gApi.changes().id(change.getId().get());
        for (Account.Id account : reviewers) {
            cApi.addReviewer(account.toString());
        }
    } catch (RestApiException | OrmException e) {
        log.error("Couldn't add reviewers to the change", e);
        throw new ReviewerManagerException(e);
    }
}
#end_block

#method_before
private boolean isPatchSetMerged(ChangeContext ctx, PatchSet patchSet) throws IOException {
    Repository repository = ctx.getRepository();
    RevWalk revWalk = ctx.getRevWalk();
    ObjectId objectId = ObjectId.fromString(patchSet.getRevision().get());
    RevCommit revCommit = revWalk.parseCommit(objectId);
    Branch.NameKey destinationNameKey = ctx.getChange().getDest();
    Ref destinationRef = repository.exactRef(destinationNameKey.get());
    if (destinationRef == null) {
        return false;
    }
    return IncludedInResolver.includedInOne(repository, revWalk, revCommit, Collections.singletonList(destinationRef));
}
#method_after
private boolean isPatchSetMerged(ChangeContext ctx, PatchSet patchSet) throws IOException {
    Repository repository = ctx.getRepository();
    Ref destinationRef = repository.exactRef(ctx.getChange().getDest().get());
    if (destinationRef == null) {
        return false;
    }
    RevWalk revWalk = ctx.getRevWalk();
    ObjectId objectId = ObjectId.fromString(patchSet.getRevision().get());
    RevCommit revCommit = revWalk.parseCommit(objectId);
    return IncludedInResolver.includedInOne(repository, revWalk, revCommit, Collections.singletonList(destinationRef));
}
#end_block

#method_before
private void processEvent(Repository repository, Event event) {
    if (event.getRefName().startsWith(CHANGES_REF)) {
        Change.Id id = Change.Id.fromRef(event.getRefName());
        try {
            Change change = db.get().changes().get(id);
            PatchList patchList = getPatchList(event, change);
            if (patchList != null) {
                PathOwners owners = new PathOwners(accountResolver, db, repository, patchList);
                reviewerManager.addReviewers(change, owners.get().values());
            }
        } catch (OrmException e) {
            logger.warn("Could not open change: {}", id, e);
        } catch (ReviewerManagerException e) {
            logger.warn("Could not add reviewers for change: {}", id, e);
        }
    }
}
#method_after
private void processEvent(Repository repository, Event event) {
    if (event.getRefName().startsWith(CHANGES_REF)) {
        Change.Id id = Change.Id.fromRef(event.getRefName());
        try {
            ReviewDb reviewDb = db.get();
            Change change = reviewDb.changes().get(id);
            PatchList patchList = getPatchList(event, change);
            if (patchList != null) {
                PathOwners owners = new PathOwners(accountResolver, reviewDb, repository, patchList);
                reviewerManager.addReviewers(change, owners.get().values());
            }
        } catch (OrmException e) {
            logger.warn("Could not open change: {}", id, e);
        } catch (ReviewerManagerException e) {
            logger.warn("Could not add reviewers for change: {}", id, e);
        }
    }
}
#end_block

#method_before
private PatchList getPatchList(Event event, Change change) {
    ObjectId newId = null;
    if (event.getNewObjectId() != null) {
        newId = ObjectId.fromString(event.getNewObjectId());
    }
    PatchListKey plKey = new PatchListKey(change.getProject(), null, newId, IGNORE_NONE);
    try {
        return patchListCache.get(plKey);
    } catch (PatchListNotAvailableException e) {
        logger.warn("Could not load patch list: {}", plKey, e);
    }
    return null;
}
#method_after
private PatchList getPatchList(Event event, Change change) {
    ObjectId newId = null;
    if (event.getNewObjectId() != null) {
        newId = ObjectId.fromString(event.getNewObjectId());
    }
    PatchListKey plKey = new PatchListKey(null, newId, IGNORE_NONE);
    try {
        return patchListCache.get(plKey, change.getProject());
    } catch (PatchListNotAvailableException e) {
        logger.warn("Could not load patch list: {}", plKey, e);
    }
    return null;
}
#end_block

#method_before
private void renderLabels(List<String> names, NativeMap<LabelInfo> all, NativeMap<JsArrayString> permitted) {
    TreeSet<Short> values = new TreeSet<>();
    List<LabelAndValues> labels = new ArrayList<>(permitted.size());
    for (String id : names) {
        JsArrayString p = permitted.get(id);
        if (p != null) {
            Set<Short> a = new TreeSet<>();
            for (int i = 0; i < p.length(); i++) {
                a.add(LabelInfo.parseValue(p.get(i)));
            }
            if (!all.containsKey(id)) {
                continue;
            }
            labels.add(new LabelAndValues(all.get(id), a));
            values.addAll(a);
        }
    }
    List<Short> columns = new ArrayList<>(values);
    labelsTable.resize(1 + labels.size(), 2 + values.size());
    for (int c = 0; c < columns.size(); c++) {
        labelsTable.setText(0, 1 + c, LabelValue.formatValue(columns.get(c)));
        labelsTable.getCellFormatter().setStyleName(0, 1 + c, style.label_value());
    }
    List<LabelAndValues> checkboxes = new ArrayList<>(labels.size());
    int row = 1;
    for (LabelAndValues lv : labels) {
        if (isCheckBox(lv.info.valueSet())) {
            checkboxes.add(lv);
        } else {
            renderRadio(row++, columns, lv);
        }
    }
    for (LabelAndValues lv : checkboxes) {
        renderCheckBox(row++, lv);
    }
}
#method_after
private void renderLabels(List<String> names, NativeMap<LabelInfo> all, NativeMap<JsArrayString> permitted) {
    TreeSet<Short> values = new TreeSet<>();
    List<LabelAndValues> labels = new ArrayList<>(permitted.size());
    for (String id : names) {
        JsArrayString p = permitted.get(id);
        if (p != null) {
            if (!all.containsKey(id)) {
                continue;
            }
            Set<Short> a = new TreeSet<>();
            for (int i = 0; i < p.length(); i++) {
                a.add(LabelInfo.parseValue(p.get(i)));
            }
            labels.add(new LabelAndValues(all.get(id), a));
            values.addAll(a);
        }
    }
    List<Short> columns = new ArrayList<>(values);
    labelsTable.resize(1 + labels.size(), 2 + values.size());
    for (int c = 0; c < columns.size(); c++) {
        labelsTable.setText(0, 1 + c, LabelValue.formatValue(columns.get(c)));
        labelsTable.getCellFormatter().setStyleName(0, 1 + c, style.label_value());
    }
    List<LabelAndValues> checkboxes = new ArrayList<>(labels.size());
    int row = 1;
    for (LabelAndValues lv : labels) {
        if (isCheckBox(lv.info.valueSet())) {
            checkboxes.add(lv);
        } else {
            renderRadio(row++, columns, lv);
        }
    }
    for (LabelAndValues lv : checkboxes) {
        renderCheckBox(row++, lv);
    }
}
#end_block

#method_before
private Watchers getWatchersFromIndex(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    Set<Account.Id> projectWatchers = new HashSet<>();
    for (AccountState a : args.accountQueryProvider.get().byWatchedProject(project)) {
        Account.Id accountId = a.getAccount().getId();
        for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : a.getProjectWatches().entrySet()) {
            if (project.equals(e.getKey().project()) && add(matching, accountId, e.getKey(), e.getValue(), type)) {
                // We only want to prevent matching All-Projects if this filter hits
                projectWatchers.add(accountId);
            }
        }
    }
    for (AccountState a : args.accountQueryProvider.get().byWatchedProject(args.allProjectsName)) {
        for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : a.getProjectWatches().entrySet()) {
            Account.Id accountId = a.getAccount().getId();
            if (!projectWatchers.contains(accountId)) {
                add(matching, accountId, e.getKey(), e.getValue(), type);
            }
        }
    }
    return matching;
}
#method_after
private Watchers getWatchersFromIndex(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    Set<Account.Id> projectWatchers = new HashSet<>();
    for (AccountState a : args.accountQueryProvider.get().byWatchedProject(project)) {
        Account.Id accountId = a.getAccount().getId();
        for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : a.getProjectWatches().entrySet()) {
            if (project.equals(e.getKey().project()) && add(matching, accountId, e.getKey(), e.getValue(), type)) {
                // We only want to prevent matching All-Projects if this filter hits
                projectWatchers.add(accountId);
            }
        }
    }
    for (AccountState a : args.accountQueryProvider.get().byWatchedProject(args.allProjectsName)) {
        for (Map.Entry<ProjectWatchKey, Set<NotifyType>> e : a.getProjectWatches().entrySet()) {
            if (args.allProjectsName.equals(e.getKey().project())) {
                Account.Id accountId = a.getAccount().getId();
                if (!projectWatchers.contains(accountId)) {
                    add(matching, accountId, e.getKey(), e.getValue(), type);
                }
            }
        }
    }
    return matching;
}
#end_block

#method_before
protected static Iterable<Integer> ids(AccountInfo... accounts) {
    return Stream.of(accounts).map(a -> a._accountId).collect(toList());
}
#method_after
protected static Iterable<Integer> ids(AccountInfo... accounts) {
    return ids(Arrays.asList(accounts));
}
#end_block

#method_before
private List<List<ChangeInfo>> query() throws OrmException, QueryParseException {
    if (imp.isDisabled()) {
        throw new QueryParseException("query disabled");
    }
    if (queries == null || queries.isEmpty()) {
        queries = Collections.singletonList("status:open");
    } else if (queries.size() > 10) {
        // users from submitting too much to the server in a single call.
        throw new QueryParseException("limit of 10 queries");
    }
    int cnt = queries.size();
    List<QueryResult<ChangeData>> results = imp.query(qb.parse(queries));
    boolean requireLazyLoad = options.contains(DETAILED_LABELS) && !qb.getArgs().getSchema().hasField(ChangeField.STORED_SUBMIT_RECORD_LENIENT);
    List<List<ChangeInfo>> res = json.create(options).lazyLoad(requireLazyLoad || containsAnyOf(options, ChangeJson.REQUIRE_LAZY_LOAD)).formatQueryResults(results);
    for (int n = 0; n < cnt; n++) {
        List<ChangeInfo> info = res.get(n);
        if (results.get(n).more()) {
            info.get(info.size() - 1)._moreChanges = true;
        }
    }
    return res;
}
#method_after
private List<List<ChangeInfo>> query() throws OrmException, QueryParseException {
    if (imp.isDisabled()) {
        throw new QueryParseException("query disabled");
    }
    if (queries == null || queries.isEmpty()) {
        queries = Collections.singletonList("status:open");
    } else if (queries.size() > 10) {
        // users from submitting too much to the server in a single call.
        throw new QueryParseException("limit of 10 queries");
    }
    int cnt = queries.size();
    List<QueryResult<ChangeData>> results = imp.query(qb.parse(queries));
    boolean requireLazyLoad = containsAnyOf(options, ImmutableSet.of(DETAILED_LABELS, LABELS)) && !qb.getArgs().getSchema().hasField(ChangeField.STORED_SUBMIT_RECORD_LENIENT);
    List<List<ChangeInfo>> res = json.create(options).lazyLoad(requireLazyLoad || containsAnyOf(options, ChangeJson.REQUIRE_LAZY_LOAD)).formatQueryResults(results);
    for (int n = 0; n < cnt; n++) {
        List<ChangeInfo> info = res.get(n);
        if (results.get(n).more()) {
            info.get(info.size() - 1)._moreChanges = true;
        }
    }
    return res;
}
#end_block

#method_before
private Options createOptions(File base, File outputFile) {
    OptionsBuilder optionsBuilder = OptionsBuilder.options();
    optionsBuilder.backend(backend).docType(DOCTYPE).eruby(ERUBY).safe(SafeMode.UNSAFE).baseDir(base).toFile(outputFile);
    AttributesBuilder attributesBuilder = AttributesBuilder.attributes();
    attributesBuilder.attributes(getAttributes());
    optionsBuilder.attributes(attributesBuilder.get());
    return optionsBuilder.get();
}
#method_after
private Options createOptions(File base, File outputFile) {
    OptionsBuilder optionsBuilder = OptionsBuilder.options();
    optionsBuilder.backend(backend).docType(DOCTYPE).eruby(ERUBY).safe(SafeMode.UNSAFE).baseDir(base).toFile(outputFile);
    AttributesBuilder attributesBuilder = AttributesBuilder.attributes();
    attributesBuilder.attributes(getAttributes());
    if (revnumber != null) {
        attributesBuilder.attribute(REVNUMBER_NAME, revnumber);
    }
    optionsBuilder.attributes(attributesBuilder.get());
    return optionsBuilder.get();
}
#end_block

#method_before
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "asciidoctor: FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    if (bazel) {
        renderFiles(inputFiles, null);
    } else {
        try (ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile))) {
            renderFiles(inputFiles, zip);
            File[] cssFiles = tmpdir.listFiles(new FilenameFilter() {

                @Override
                public boolean accept(File dir, String name) {
                    return name.endsWith(".css");
                }
            });
            for (File css : cssFiles) {
                zipFile(css, css.getName(), zip);
            }
        }
    }
}
#method_after
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "asciidoctor: FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    if (revnumberFile != null) {
        try (BufferedReader reader = new BufferedReader(new FileReader(revnumberFile))) {
            revnumber = reader.readLine();
        }
    }
    if (mktmp) {
        tmpdir = Files.createTempDirectory("asciidoctor-").toFile();
    }
    if (bazel) {
        renderFiles(inputFiles, null);
    } else {
        try (ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile))) {
            renderFiles(inputFiles, zip);
            File[] cssFiles = tmpdir.listFiles(new FilenameFilter() {

                @Override
                public boolean accept(File dir, String name) {
                    return name.endsWith(".css");
                }
            });
            for (File css : cssFiles) {
                zipFile(css, css.getName(), zip);
            }
        }
    }
}
#end_block

#method_before
private void renderFiles(List<String> inputFiles, ZipOutputStream zip) throws IOException {
    Asciidoctor asciidoctor = JRubyAsciidoctor.create();
    for (String inputFile : inputFiles) {
        String outName = mapInFileToOutFile(inputFile, inExt, outExt);
        File out = bazel ? new File(outName) : new File(tmpdir, outName);
        if (!bazel) {
            out.getParentFile().mkdirs();
        }
        File input = new File(inputFile);
        Options options = createOptions(bazel ? input.getParentFile() : basedir, out);
        asciidoctor.renderFile(input, options);
        if (zip != null) {
            zipFile(out, outName, zip);
        }
    }
}
#method_after
private void renderFiles(List<String> inputFiles, ZipOutputStream zip) throws IOException {
    Asciidoctor asciidoctor = JRubyAsciidoctor.create();
    for (String inputFile : inputFiles) {
        String outName = mapInFileToOutFile(inputFile, inExt, outExt);
        File out = bazel ? new File(outName) : new File(tmpdir, outName);
        if (!bazel) {
            out.getParentFile().mkdirs();
        }
        File input = new File(inputFile);
        Options options = createOptions(basedir != null ? basedir : input.getParentFile(), out);
        asciidoctor.renderFile(input, options);
        if (zip != null) {
            zipFile(out, outName, zip);
        }
    }
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    if (Thread.interrupted()) {
        Thread.currentThread().interrupt();
        throw new OrmException("interrupted");
    }
    final Set<String> fields = fields(opts);
    return new ChangeDataResults(executor.submit(new Callable<List<Document>>() {

        @Override
        public List<Document> call() throws IOException {
            return doRead(fields);
        }

        @Override
        public String toString() {
            return predicate.toString();
        }
    }), fields);
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    if (Thread.interrupted()) {
        Thread.currentThread().interrupt();
        throw new OrmException("interrupted");
    }
    final Set<String> fields = IndexUtils.fields(opts);
    return new ChangeDataResults(executor.submit(new Callable<List<Document>>() {

        @Override
        public List<Document> call() throws IOException {
            return doRead(fields);
        }

        @Override
        public String toString() {
            return predicate.toString();
        }
    }), fields);
}
#end_block

#method_before
private ChangeData toChangeData(Multimap<String, IndexableField> doc, Set<String> fields, String idFieldName) {
    ChangeData cd;
    // Either change or the ID field was guaranteed to be included in the call
    // to fields() above.
    IndexableField cb = Iterables.getFirst(doc.get(CHANGE_FIELD), null);
    if (cb != null) {
        BytesRef proto = cb.binaryValue();
        cd = changeDataFactory.create(db.get(), ChangeProtoField.CODEC.decode(proto.bytes, proto.offset, proto.length));
    } else {
        IndexableField f = Iterables.getFirst(doc.get(idFieldName), null);
        Change.Id id = new Change.Id(f.numericValue().intValue());
        IndexableField project = Iterables.getFirst(doc.get(PROJECT.getName()), null);
        if (project == null) {
            // Old schema without project field: we can safely assume NoteDb is
            // disabled.
            cd = changeDataFactory.createOnlyWhenNoteDbDisabled(db.get(), id);
        } else {
            cd = changeDataFactory.create(db.get(), new Project.NameKey(project.stringValue()), id);
        }
    }
    if (fields.contains(PATCH_SET_FIELD)) {
        decodePatchSets(doc, cd);
    }
    if (fields.contains(APPROVAL_FIELD)) {
        decodeApprovals(doc, cd);
    }
    if (fields.contains(ADDED_FIELD) && fields.contains(DELETED_FIELD)) {
        decodeChangedLines(doc, cd);
    }
    if (fields.contains(MERGEABLE_FIELD)) {
        decodeMergeable(doc, cd);
    }
    if (fields.contains(REVIEWEDBY_FIELD)) {
        decodeReviewedBy(doc, cd);
    }
    if (fields.contains(ASSIGNEE_FIELD)) {
        decodeAssignee(doc, cd);
    }
    if (fields.contains(HASHTAG_FIELD)) {
        decodeHashtags(doc, cd);
    }
    if (fields.contains(STAR_FIELD)) {
        decodeStar(doc, cd);
    }
    if (fields.contains(REVIEWER_FIELD)) {
        decodeReviewers(doc, cd);
    }
    decodeSubmitRecords(doc, SUBMIT_RECORD_STRICT_FIELD, ChangeJson.SUBMIT_RULE_OPTIONS_STRICT, cd);
    decodeSubmitRecords(doc, SUBMIT_RECORD_LENIENT_FIELD, ChangeJson.SUBMIT_RULE_OPTIONS_LENIENT, cd);
    return cd;
}
#method_after
private ChangeData toChangeData(Multimap<String, IndexableField> doc, Set<String> fields, String idFieldName) {
    ChangeData cd;
    // Either change or the ID field was guaranteed to be included in the call
    // to fields() above.
    IndexableField cb = Iterables.getFirst(doc.get(CHANGE_FIELD), null);
    if (cb != null) {
        BytesRef proto = cb.binaryValue();
        cd = changeDataFactory.create(db.get(), ChangeProtoField.CODEC.decode(proto.bytes, proto.offset, proto.length));
    } else {
        IndexableField f = Iterables.getFirst(doc.get(idFieldName), null);
        Change.Id id = new Change.Id(f.numericValue().intValue());
        IndexableField project = Iterables.getFirst(doc.get(PROJECT.getName()), null);
        if (project == null) {
            // Old schema without project field: we can safely assume NoteDb is
            // disabled.
            cd = changeDataFactory.createOnlyWhenNoteDbDisabled(db.get(), id);
        } else {
            cd = changeDataFactory.create(db.get(), new Project.NameKey(project.stringValue()), id);
        }
    }
    if (fields.contains(PATCH_SET_FIELD)) {
        decodePatchSets(doc, cd);
    }
    if (fields.contains(APPROVAL_FIELD)) {
        decodeApprovals(doc, cd);
    }
    if (fields.contains(ADDED_FIELD) && fields.contains(DELETED_FIELD)) {
        decodeChangedLines(doc, cd);
    }
    if (fields.contains(MERGEABLE_FIELD)) {
        decodeMergeable(doc, cd);
    }
    if (fields.contains(REVIEWEDBY_FIELD)) {
        decodeReviewedBy(doc, cd);
    }
    if (fields.contains(HASHTAG_FIELD)) {
        decodeHashtags(doc, cd);
    }
    if (fields.contains(STAR_FIELD)) {
        decodeStar(doc, cd);
    }
    if (fields.contains(REVIEWER_FIELD)) {
        decodeReviewers(doc, cd);
    }
    decodeSubmitRecords(doc, SUBMIT_RECORD_STRICT_FIELD, ChangeField.SUBMIT_RULE_OPTIONS_STRICT, cd);
    decodeSubmitRecords(doc, SUBMIT_RECORD_LENIENT_FIELD, ChangeField.SUBMIT_RULE_OPTIONS_LENIENT, cd);
    return cd;
}
#end_block

#method_before
private void decodeReviewers(Multimap<String, IndexableField> doc, ChangeData cd) {
    cd.setReviewers(ChangeField.parseReviewerFieldValues(fieldsToStrings(doc.get(REVIEWER_FIELD))));
}
#method_after
private void decodeReviewers(Multimap<String, IndexableField> doc, ChangeData cd) {
    cd.setReviewers(ChangeField.parseReviewerFieldValues(FluentIterable.from(doc.get(REVIEWER_FIELD)).transform(IndexableField::stringValue)));
}
#end_block

#method_before
private void decodeSubmitRecords(Multimap<String, IndexableField> doc, String field, SubmitRuleOptions opts, ChangeData cd) {
    ChangeField.parseSubmitRecordValues(fieldsToStrings(doc.get(field)), opts, cd);
}
#method_after
private void decodeSubmitRecords(Multimap<String, IndexableField> doc, String field, SubmitRuleOptions opts, ChangeData cd) {
    ChangeField.parseSubmitRecords(Collections2.transform(doc.get(field), f -> f.binaryValue().utf8ToString()), opts, cd);
}
#end_block

#method_before
public ChangeInfo format(ChangeData cd) throws OrmException {
    return format(cd, Optional.<PatchSet.Id>absent(), true);
}
#method_after
public ChangeInfo format(ChangeData cd) throws OrmException {
    return format(cd, Optional.empty(), true);
}
#end_block

#method_before
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.<PatchSet.Id>absent());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#method_after
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (cd.assignee().isPresent()) {
            out.assignee = accountLoader.get(cd.assignee().get());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (includeSubmittable) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private boolean submittable(ChangeData cd) throws OrmException {
    for (SubmitRecord sr : cd.submitRecords(SUBMIT_RULE_OPTIONS_STRICT)) {
        if (sr.status == SubmitRecord.Status.OK) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean submittable(ChangeData cd) throws OrmException {
    return SubmitRecord.findOkRecord(cd.submitRecords(SUBMIT_RULE_OPTIONS_STRICT)).isPresent();
}
#end_block

#method_before
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, tag, date));
        }
    }
}
#method_after
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    Change.Status status = cd.change().getStatus();
    checkState(status.isOpen(), "should not call setAllApprovals on %s change", status);
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
                if (psa.isPostSubmit()) {
                    log.warn("unexpected post-submit approval on open change: {}", psa);
                }
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, tag, date));
        }
    }
}
#end_block

#method_before
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    // We can only approximately reconstruct what the submit rule evaluator
    // would have done. These should really come from a stored submit record.
    Set<String> labelNames = new HashSet<>();
    Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (String name : labelNames) {
        LabelType type = labelTypes.byLabel(name);
        LabelWithStatus l = LabelWithStatus.create(new LabelInfo(), null);
        if (detailed) {
            setLabelValues(type, l);
        }
        labels.put(type.getName(), l);
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        if (detailed) {
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    // We can only approximately reconstruct what the submit rule evaluator
    // would have done. These should really come from a stored submit record.
    Set<String> labelNames = new HashSet<>();
    Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (String name : labelNames) {
        LabelType type = labelTypes.byLabel(name);
        LabelWithStatus l = LabelWithStatus.create(new LabelInfo(), null);
        if (detailed) {
            setLabelValues(type, l);
        }
        labels.put(type.getName(), l);
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        if (detailed) {
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
                if (psa.isPostSubmit()) {
                    info.postSubmit = true;
                }
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#end_block

#method_before
private List<SubmitRecord> cannotSubmitDraft() {
    try {
        if (!control.isDraftVisible(cd.db(), cd)) {
            return createRuleError("Patch set " + patchSet.getId() + " not found");
        }
        initPatchSet();
        if (patchSet.isDraft()) {
            return createRuleError("Cannot submit draft patch sets");
        }
        return createRuleError("Cannot submit draft changes");
    } catch (OrmException err) {
        String msg = "Cannot check visibility of patch set " + patchSet.getId();
        log.error(msg, err);
        return createRuleError(msg);
    }
}
#method_after
private List<SubmitRecord> cannotSubmitDraft() {
    try {
        if (!control.isDraftVisible(cd.db(), cd)) {
            return createRuleError("Patch set " + patchSet.getId() + " not found");
        }
        initPatchSet();
        if (patchSet.isDraft()) {
            return createRuleError("Cannot submit draft patch sets");
        }
        return createRuleError("Cannot submit draft changes");
    } catch (OrmException err) {
        PatchSet.Id psId = patchSet != null ? patchSet.getId() : control.getChange().currentPatchSetId();
        String msg = "Cannot check visibility of patch set " + psId;
        log.error(msg, err);
        return createRuleError(msg);
    }
}
#end_block

#method_before
private SubmitRecord toSubmitRecord() {
    SubmitRecord rec = new SubmitRecord();
    rec.status = status;
    rec.errorMessage = errorMessage;
    rec.labels = new ArrayList<>(labels.size());
    for (StoredLabel label : labels) {
        SubmitRecord.Label srl = new SubmitRecord.Label();
        srl.label = label.label;
        srl.status = label.status;
        srl.appliedBy = label.appliedBy != null ? new Account.Id(label.appliedBy) : null;
    }
    return rec;
}
#method_after
private SubmitRecord toSubmitRecord() {
    SubmitRecord rec = new SubmitRecord();
    rec.status = status;
    rec.errorMessage = errorMessage;
    if (labels != null) {
        rec.labels = new ArrayList<>(labels.size());
        for (StoredLabel label : labels) {
            SubmitRecord.Label srl = new SubmitRecord.Label();
            srl.label = label.label;
            srl.status = label.status;
            srl.appliedBy = label.appliedBy != null ? new Account.Id(label.appliedBy) : null;
            rec.labels.add(srl);
        }
    }
    return rec;
}
#end_block

#method_before
private static Iterable<byte[]> storedSubmitRecords(ChangeData cd, SubmitRuleOptions opts) throws OrmException {
    return FluentIterable.from(cd.submitRecords(opts)).transform(r -> GSON.toJson(new StoredSubmitRecord(r)).getBytes(UTF_8));
}
#method_after
@VisibleForTesting
static List<byte[]> storedSubmitRecords(List<SubmitRecord> records) {
    return Lists.transform(records, r -> GSON.toJson(new StoredSubmitRecord(r)).getBytes(UTF_8));
}
#end_block

#method_before
private static Iterable<byte[]> storedSubmitRecords(ChangeData cd, SubmitRuleOptions opts) throws OrmException {
    return FluentIterable.from(cd.submitRecords(opts)).transform(r -> GSON.toJson(new StoredSubmitRecord(r)).getBytes(UTF_8));
}
#method_after
private static Iterable<byte[]> storedSubmitRecords(ChangeData cd, SubmitRuleOptions opts) throws OrmException {
    return storedSubmitRecords(cd.submitRecords(opts));
}
#end_block

#method_before
@VisibleForTesting
static List<String> formatSubmitRecordValues(List<SubmitRecord> records) {
    List<String> result = new ArrayList<>();
    for (SubmitRecord rec : records) {
        result.add(rec.status.name());
        for (SubmitRecord.Label label : rec.labels) {
            String statusLabel = label.status.name() + ',' + label.label;
            result.add(statusLabel);
            result.add(statusLabel + label.appliedBy.get());
        }
    }
    return result;
}
#method_after
public static List<String> formatSubmitRecordValues(ChangeData cd) throws OrmException {
    return formatSubmitRecordValues(cd.submitRecords(SUBMIT_RULE_OPTIONS_STRICT), cd.change().getOwner());
}
#end_block

#method_before
@Test
public void listChangeDrafts() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    setApiUser(admin);
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "nit: trailing whitespace"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "typo: content"));
    setApiUser(user);
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "+1, please fix"));
    setApiUser(admin);
    Map<String, List<CommentInfo>> actual = gApi.changes().id(r1.getChangeId()).drafts();
    assertThat((Iterable<?>) actual.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> comments = actual.get(FILE_NAME);
    assertThat(comments).hasSize(2);
    CommentInfo c1 = comments.get(0);
    assertThat(c1.author).isNull();
    assertThat(c1.patchSet).isEqualTo(1);
    assertThat(c1.message).isEqualTo("nit: trailing whitespace");
    assertThat(c1.side).isNull();
    assertThat(c1.line).isEqualTo(1);
    CommentInfo c2 = comments.get(1);
    assertThat(c2.author).isNull();
    assertThat(c2.patchSet).isEqualTo(2);
    assertThat(c2.message).isEqualTo("typo: content");
    assertThat(c2.side).isNull();
    assertThat(c2.line).isEqualTo(1);
}
#method_after
@Test
public void listChangeDrafts() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    setApiUser(admin);
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "nit: trailing whitespace"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "typo: content"));
    setApiUser(user);
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "+1, please fix"));
    setApiUser(admin);
    Map<String, List<CommentInfo>> actual = gApi.changes().id(r1.getChangeId()).drafts();
    assertThat(actual.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> comments = actual.get(FILE_NAME);
    assertThat(comments).hasSize(2);
    CommentInfo c1 = comments.get(0);
    assertThat(c1.author).isNull();
    assertThat(c1.patchSet).isEqualTo(1);
    assertThat(c1.message).isEqualTo("nit: trailing whitespace");
    assertThat(c1.side).isNull();
    assertThat(c1.line).isEqualTo(1);
    CommentInfo c2 = comments.get(1);
    assertThat(c2.author).isNull();
    assertThat(c2.patchSet).isEqualTo(2);
    assertThat(c2.message).isEqualTo("typo: content");
    assertThat(c2.side).isNull();
    assertThat(c2.line).isEqualTo(1);
}
#end_block

#method_before
@Test
public void publishCommentsAllRevisions() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new\ncntent\n", r1.getChangeId()).to("refs/for/master");
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "nit: trailing whitespace"));
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 2, "what happened to this?"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "join lines"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "typo: content"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 1, "comment 1 on base"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 2, "comment 2 on base"));
    PushOneCommit.Result other = createChange();
    // Drafts on other changes aren't returned.
    addDraft(other.getChangeId(), other.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "unrelated comment"));
    setApiUser(admin);
    // Drafts by other users aren't returned.
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "oops"));
    setApiUser(user);
    ReviewInput reviewInput = new ReviewInput();
    reviewInput.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    reviewInput.message = "comments";
    gApi.changes().id(r2.getChangeId()).current().review(reviewInput);
    assertThat(gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps1Map = gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).comments();
    assertThat(ps1Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps1List = ps1Map.get(FILE_NAME);
    assertThat(ps1List).hasSize(2);
    assertThat(ps1List.get(0).message).isEqualTo("what happened to this?");
    assertThat(ps1List.get(0).side).isEqualTo(Side.PARENT);
    assertThat(ps1List.get(1).message).isEqualTo("nit: trailing whitespace");
    assertThat(ps1List.get(1).side).isNull();
    assertThat(gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps2Map = gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).comments();
    assertThat(ps2Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps2List = ps2Map.get(FILE_NAME);
    assertThat(ps2List).hasSize(4);
    assertThat(ps2List.get(0).message).isEqualTo("comment 1 on base");
    assertThat(ps2List.get(1).message).isEqualTo("comment 2 on base");
    assertThat(ps2List.get(2).message).isEqualTo("join lines");
    assertThat(ps2List.get(3).message).isEqualTo("typo: content");
    List<Message> messages = email.getMessages(r2.getChangeId(), "comment");
    assertThat(messages).hasSize(1);
    String url = canonicalWebUrl.get();
    int c = r1.getChange().getId().get();
    assertThat(extractComments(messages.get(0).body())).isEqualTo("Patch Set 2:\n" + "\n" + "(6 comments)\n" + "\n" + "comments\n" + "\n" + url + "#/c/" + c + "/1/a.txt\n" + "File a.txt:\n" + "\n" + url + "#/c/12/1/a.txt@2\n" + "PS1, Line 2: \n" + "what happened to this?\n" + "\n" + "\n" + url + "#/c/12/1/a.txt@1\n" + "PS1, Line 1: ew\n" + "nit: trailing whitespace\n" + "\n" + "\n" + url + "#/c/" + c + "/2/a.txt\n" + "File a.txt:\n" + "\n" + url + "#/c/12/2/a.txt@1\n" + "PS2, Line 1: \n" + "comment 1 on base\n" + "\n" + "\n" + url + "#/c/12/2/a.txt@2\n" + "PS2, Line 2: \n" + "comment 2 on base\n" + "\n" + "\n" + url + "#/c/12/2/a.txt@1\n" + "PS2, Line 1: ew\n" + "join lines\n" + "\n" + "\n" + url + "#/c/12/2/a.txt@2\n" + "PS2, Line 2: nten\n" + "typo: content\n" + "\n" + "\n");
}
#method_after
@Test
public void publishCommentsAllRevisions() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new\ncntent\n", r1.getChangeId()).to("refs/for/master");
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "nit: trailing whitespace"));
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 2, "what happened to this?"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "join lines"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "typo: content"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 1, "comment 1 on base"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 2, "comment 2 on base"));
    PushOneCommit.Result other = createChange();
    // Drafts on other changes aren't returned.
    addDraft(other.getChangeId(), other.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "unrelated comment"));
    setApiUser(admin);
    // Drafts by other users aren't returned.
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "oops"));
    setApiUser(user);
    ReviewInput reviewInput = new ReviewInput();
    reviewInput.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    reviewInput.message = "comments";
    gApi.changes().id(r2.getChangeId()).current().review(reviewInput);
    assertThat(gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps1Map = gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).comments();
    assertThat(ps1Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps1List = ps1Map.get(FILE_NAME);
    assertThat(ps1List).hasSize(2);
    assertThat(ps1List.get(0).message).isEqualTo("what happened to this?");
    assertThat(ps1List.get(0).side).isEqualTo(Side.PARENT);
    assertThat(ps1List.get(1).message).isEqualTo("nit: trailing whitespace");
    assertThat(ps1List.get(1).side).isNull();
    assertThat(gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps2Map = gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).comments();
    assertThat(ps2Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps2List = ps2Map.get(FILE_NAME);
    assertThat(ps2List).hasSize(4);
    assertThat(ps2List.get(0).message).isEqualTo("comment 1 on base");
    assertThat(ps2List.get(1).message).isEqualTo("comment 2 on base");
    assertThat(ps2List.get(2).message).isEqualTo("join lines");
    assertThat(ps2List.get(3).message).isEqualTo("typo: content");
    List<Message> messages = email.getMessages(r2.getChangeId(), "comment");
    assertThat(messages).hasSize(1);
    String url = canonicalWebUrl.get();
    int c = r1.getChange().getId().get();
    assertThat(extractComments(messages.get(0).body())).isEqualTo("Patch Set 2:\n" + "\n" + "(6 comments)\n" + "\n" + "comments\n" + "\n" + url + "#/c/" + c + "/1/a.txt\n" + "File a.txt:\n" + "\n" + url + "#/c/12/1/a.txt@a2\n" + "PS1, Line 2: \n" + "what happened to this?\n" + "\n" + "\n" + url + "#/c/12/1/a.txt@1\n" + "PS1, Line 1: ew\n" + "nit: trailing whitespace\n" + "\n" + "\n" + url + "#/c/" + c + "/2/a.txt\n" + "File a.txt:\n" + "\n" + url + "#/c/12/2/a.txt@a1\n" + "PS2, Line 1: \n" + "comment 1 on base\n" + "\n" + "\n" + url + "#/c/12/2/a.txt@a2\n" + "PS2, Line 2: \n" + "comment 2 on base\n" + "\n" + "\n" + url + "#/c/12/2/a.txt@1\n" + "PS2, Line 1: ew\n" + "join lines\n" + "\n" + "\n" + url + "#/c/12/2/a.txt@2\n" + "PS2, Line 2: nten\n" + "typo: content\n" + "\n" + "\n");
}
#end_block

#method_before
public boolean hasInlineComments() {
    return !inlineComments.isEmpty();
}
#method_after
@Deprecated
public boolean hasInlineComments() {
    return !inlineComments.isEmpty();
}
#end_block

#method_before
public String getInlineComments() {
    return getInlineComments(1);
}
#method_after
@Deprecated
public String getInlineComments() {
    return getInlineComments(1);
}
#end_block

#method_before
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    for (FileCommentGroup group : getGroupedInlineComments()) {
        String link = group.getLink();
        if (link != null) {
            cmts.append(link).append('\n');
        }
        cmts.append(group.getTitle()).append(":\n\n");
        for (Comment c : group.comments) {
            appendComment(cmts, lines, group.fileData, c);
        }
        cmts.append("\n\n");
    }
    return cmts.toString();
}
#method_after
@Deprecated
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    for (FileCommentGroup group : getGroupedInlineComments()) {
        String link = group.getLink();
        if (link != null) {
            cmts.append(link).append('\n');
        }
        cmts.append(group.getTitle()).append(":\n\n");
        for (Comment c : group.comments) {
            appendComment(cmts, lines, group.fileData, c);
        }
        cmts.append("\n\n");
    }
    return cmts.toString();
}
#end_block

#method_before
private void appendComment(StringBuilder out, int contextLines, PatchFile currentFileData, Comment comment) {
    if (comment instanceof RobotComment) {
        RobotComment robotComment = (RobotComment) comment;
        out.append("Robot Comment from ").append(robotComment.robotId).append(" (run ID ").append(robotComment.robotRunId).append("):\n");
    }
    if (comment.range != null) {
        appendRangedComment(out, contextLines, currentFileData, comment);
    } else {
        appendLineComment(out, contextLines, currentFileData, comment);
    }
}
#method_after
@Deprecated
private void appendComment(StringBuilder out, int contextLines, PatchFile currentFileData, Comment comment) {
    if (comment instanceof RobotComment) {
        RobotComment robotComment = (RobotComment) comment;
        out.append("Robot Comment from ").append(robotComment.robotId).append(" (run ID ").append(robotComment.robotRunId).append("):\n");
    }
    if (comment.range != null) {
        appendRangedComment(out, contextLines, currentFileData, comment);
    } else {
        appendLineComment(out, contextLines, currentFileData, comment);
    }
}
#end_block

#method_before
private void appendRangedComment(StringBuilder out, int contextLines, PatchFile fileData, Comment comment) {
    String prefix = getCommentLinePrefix(comment);
    boolean firstLine = true;
    for (String line : getLinesByRange(comment.range, fileData, comment.side)) {
        out.append(firstLine ? prefix : Strings.padStart(": ", prefix.length(), ' ')).append(line).append('\n');
        firstLine = false;
    }
    appendQuotedParent(out, comment);
    out.append(comment.message.trim()).append('\n');
}
#method_after
@Deprecated
private void appendRangedComment(StringBuilder out, int contextLines, PatchFile fileData, Comment comment) {
    String prefix = getCommentLinePrefix(comment);
    String emptyPrefix = Strings.padStart(": ", prefix.length(), ' ');
    boolean firstLine = true;
    for (String line : getLinesByRange(comment.range, fileData, comment.side)) {
        out.append(firstLine ? prefix : emptyPrefix).append(line).append('\n');
        firstLine = false;
    }
    appendQuotedParent(out, comment);
    out.append(comment.message.trim()).append('\n');
}
#end_block

#method_before
private void appendLineComment(StringBuilder out, int contextLines, PatchFile currentFileData, Comment comment) {
    short side = comment.side;
    int lineNbr = comment.lineNbr;
    // Initialize maxLines to the known line number.
    int maxLines = lineNbr;
    try {
        maxLines = currentFileData.getLineCount(side);
    } catch (IOException exc) {
        // The file could not be read, leave the max as is.
        log.warn(String.format("Failed to read file %s on side %d", comment.key.filename, side), exc);
    } catch (NoSuchEntityException exc) {
        // The file could not be read, leave the max as is.
        log.warn(String.format("Side %d of file file %s didn't exist", side, comment.key.filename), exc);
    }
    int startLine = Math.max(1, lineNbr - contextLines + 1);
    int stopLine = Math.min(maxLines, lineNbr + contextLines);
    for (int line = startLine; line <= lineNbr; ++line) {
        appendFileLine(out, currentFileData, side, line);
    }
    appendQuotedParent(out, comment);
    out.append(comment.message.trim()).append('\n');
    for (int line = lineNbr + 1; line < stopLine; ++line) {
        appendFileLine(out, currentFileData, side, line);
    }
}
#method_after
@Deprecated
private void appendLineComment(StringBuilder out, int contextLines, PatchFile currentFileData, Comment comment) {
    short side = comment.side;
    int lineNbr = comment.lineNbr;
    // Initialize maxLines to the known line number.
    int maxLines = lineNbr;
    try {
        maxLines = currentFileData.getLineCount(side);
    } catch (IOException err) {
        // The file could not be read, leave the max as is.
        log.warn(String.format("Failed to read file %s on side %d", comment.key.filename, side), err);
    } catch (NoSuchEntityException err) {
        // The file could not be read, leave the max as is.
        log.warn(String.format("Side %d of file %s didn't exist", side, comment.key.filename), err);
    }
    int startLine = Math.max(1, lineNbr - contextLines + 1);
    int stopLine = Math.min(maxLines, lineNbr + contextLines);
    for (int line = startLine; line <= lineNbr; ++line) {
        appendFileLine(out, currentFileData, side, line);
    }
    appendQuotedParent(out, comment);
    out.append(comment.message.trim()).append('\n');
    for (int line = lineNbr + 1; line < stopLine; ++line) {
        appendFileLine(out, currentFileData, side, line);
    }
}
#end_block

#method_before
private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) {
    String lineStr = getLine(fileData, side, line);
    cmts.append("Line ").append(line).append(": ").append(lineStr).append("\n");
}
#method_after
@Deprecated
private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) {
    String lineStr = getLine(fileData, side, line);
    cmts.append("Line ").append(line).append(": ").append(lineStr).append("\n");
}
#end_block

#method_before
private void appendQuotedParent(StringBuilder out, Comment child) {
    Optional<Comment> parent = getParent(child);
    if (parent.isPresent()) {
        out.append("> ").append(getShortenedCommentMessage(parent.get())).append('\n');
    }
}
#method_after
@Deprecated
private void appendQuotedParent(StringBuilder out, Comment child) {
    Optional<Comment> parent = getParent(child);
    if (parent.isPresent()) {
        out.append("> ").append(getShortenedCommentMessage(parent.get())).append('\n');
    }
}
#end_block

#method_before
private Optional<Comment> getParent(Comment child) {
    if (child.parentUuid == null) {
        return Optional.absent();
    }
    Optional<Comment> parent;
    Comment.Key key = new Comment.Key(child.parentUuid, child.key.filename, child.key.patchSetId);
    try {
        return commentsUtil.get(args.db.get(), changeData.notes(), key);
    } catch (OrmException e) {
        log.warn("Could not find the parent of this comment: " + child.toString());
        return Optional.absent();
    }
}
#method_after
private Optional<Comment> getParent(Comment child) {
    if (child.parentUuid == null) {
        return Optional.empty();
    }
    Optional<Comment> parent;
    Comment.Key key = new Comment.Key(child.parentUuid, child.key.filename, child.key.patchSetId);
    try {
        return commentsUtil.get(args.db.get(), changeData.notes(), key);
    } catch (OrmException e) {
        log.warn("Could not find the parent of this comment: " + child.toString());
        return Optional.empty();
    }
}
#end_block

#method_before
private List<Map<String, Object>> getCommentGroupsTemplateData() {
    List<Map<String, Object>> commentGroups = new ArrayList<>();
    for (CommentSender.FileCommentGroup group : getGroupedInlineComments()) {
        Map<String, Object> groupData = new HashMap<>();
        groupData.put("link", group.getLink());
        groupData.put("title", group.getTitle());
        groupData.put("patchSetId", group.patchSetId);
        List<Map<String, Object>> commentsList = new ArrayList<>();
        for (Comment comment : group.comments) {
            Map<String, Object> commentData = new HashMap<>();
            commentData.put("lines", getLinesOfComment(comment, group.fileData));
            commentData.put("message", comment.message.trim());
            String prefix = getCommentLinePrefix(comment);
            commentData.put("linePrefix", prefix);
            commentData.put("linePrefixEmpty", Strings.padStart(": ", prefix.length(), ' '));
            if (comment.range == null) {
                commentData.put("startLine", comment.lineNbr);
            } else {
                commentData.put("startLine", comment.range.startLine);
                commentData.put("endLine", comment.range.endLine);
            }
            if (comment instanceof RobotComment) {
                RobotComment robotComment = (RobotComment) comment;
                commentData.put("isRobotComment", true);
                commentData.put("robotId", robotComment.robotId);
                commentData.put("robotRunId", robotComment.robotRunId);
                commentData.put("robotUrl", robotComment.url);
            } else {
                commentData.put("isRobotComment", false);
            }
            Optional<Comment> parent = getParent(comment);
            if (parent.isPresent()) {
                commentData.put("parentMessage", getShortenedCommentMessage(parent.get()));
            }
            commentsList.add(commentData);
        }
        groupData.put("comments", commentsList);
        commentGroups.add(groupData);
    }
    return commentGroups;
}
#method_after
private List<Map<String, Object>> getCommentGroupsTemplateData() {
    List<Map<String, Object>> commentGroups = new ArrayList<>();
    for (CommentSender.FileCommentGroup group : getGroupedInlineComments()) {
        Map<String, Object> groupData = new HashMap<>();
        groupData.put("link", group.getLink());
        groupData.put("title", group.getTitle());
        groupData.put("patchSetId", group.patchSetId);
        List<Map<String, Object>> commentsList = new ArrayList<>();
        for (Comment comment : group.comments) {
            Map<String, Object> commentData = new HashMap<>();
            commentData.put("lines", getLinesOfComment(comment, group.fileData));
            commentData.put("message", comment.message.trim());
            // Set the prefix.
            String prefix = getCommentLinePrefix(comment);
            commentData.put("linePrefix", prefix);
            commentData.put("linePrefixEmpty", Strings.padStart(": ", prefix.length(), ' '));
            // Set line numbers.
            int startLine;
            if (comment.range == null) {
                startLine = comment.lineNbr;
            } else {
                startLine = comment.range.startLine;
                commentData.put("endLine", comment.range.endLine);
            }
            commentData.put("startLine", startLine);
            // Set the comment link.
            if (comment.lineNbr == 0) {
                commentData.put("link", group.getLink());
            } else if (comment.side == 0) {
                commentData.put("link", group.getLink() + "@a" + startLine);
            } else {
                commentData.put("link", group.getLink() + '@' + startLine);
            }
            // Set robot comment data.
            if (comment instanceof RobotComment) {
                RobotComment robotComment = (RobotComment) comment;
                commentData.put("isRobotComment", true);
                commentData.put("robotId", robotComment.robotId);
                commentData.put("robotRunId", robotComment.robotRunId);
                commentData.put("robotUrl", robotComment.url);
            } else {
                commentData.put("isRobotComment", false);
            }
            // Set parent comment info.
            Optional<Comment> parent = getParent(comment);
            if (parent.isPresent()) {
                commentData.put("parentMessage", getShortenedCommentMessage(parent.get()));
            }
            commentsList.add(commentData);
        }
        groupData.put("comments", commentsList);
        commentGroups.add(groupData);
    }
    return commentGroups;
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("inlineCommentGroups", getCommentGroupsTemplateData());
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("commentFiles", getCommentGroupsTemplateData());
}
#end_block

#method_before
private String getLine(PatchFile fileInfo, short side, int lineNbr) {
    try {
        return fileInfo.getLine(side, lineNbr);
    } catch (IOException exc) {
        // Default to the empty string if the file cannot be safely read.
        log.warn(String.format("Failed to read file on side %d", side), exc);
        return "";
    } catch (IndexOutOfBoundsException exc) {
        // Default to the empty string if the given line number does not appear
        // in the file.
        log.warn(String.format("Failed to get line number of file on side %d", side), exc);
        return "";
    } catch (NoSuchEntityException exc) {
        // Default to the empty string if the side cannot be found.
        log.warn(String.format("Side %d of file file didn't exist", side), exc);
        return "";
    }
}
#method_after
private String getLine(PatchFile fileInfo, short side, int lineNbr) {
    try {
        return fileInfo.getLine(side, lineNbr);
    } catch (IOException err) {
        // Default to the empty string if the file cannot be safely read.
        log.warn(String.format("Failed to read file on side %d", side), err);
        return "";
    } catch (IndexOutOfBoundsException err) {
        // Default to the empty string if the given line number does not appear
        // in the file.
        log.warn(String.format("Failed to get line number of file on side %d", side), err);
        return "";
    } catch (NoSuchEntityException err) {
        // Default to the empty string if the side cannot be found.
        log.warn(String.format("Side %d of file didn't exist", side), err);
        return "";
    }
}
#end_block

#method_before
public static Optional<TimeZone> getTimeZone(Config config, String section, String subsection, String name) {
    return Optional.ofNullable(config.getString(section, subsection, name)).map(id -> TimeZone.getTimeZone(id));
}
#method_after
public static Optional<TimeZone> getTimeZone(Config config, String section, String subsection, String name) {
    return Optional.ofNullable(config.getString(section, subsection, name)).map(TimeZone::getTimeZone);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    checkState(ctx.getOrder() == BatchUpdate.Order.DB_BEFORE_REPO, "must use DeleteDraftChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteDraftChangeOp");
    id = ctx.getChange().getId();
    ImmutableList<PatchSet> patchSets = ImmutableList.copyOf(psUtil.byChange(ctx.getDb(), ctx.getNotes()));
    ensureDeletable(ctx, id, patchSets);
    deleteChangeElementsFromDb(ctx, id);
    cleanUpReferences(ctx, id, patchSets);
    ctx.deleteChange();
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    checkState(ctx.getOrder() == BatchUpdate.Order.DB_BEFORE_REPO, "must use DeleteDraftChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteDraftChangeOp");
    id = ctx.getChange().getId();
    Collection<PatchSet> patchSets = psUtil.byChange(ctx.getDb(), ctx.getNotes());
    ensureDeletable(ctx, id, patchSets);
    deleteChangeElementsFromDb(ctx, id);
    cleanUpReferences(ctx, id, patchSets);
    ctx.deleteChange();
    return true;
}
#end_block

#method_before
private void ensureDeletable(ChangeContext ctx, Change.Id id, List<PatchSet> patchSets) throws ResourceConflictException, MethodNotAllowedException, OrmException, AuthException {
    if (ctx.getChange().getStatus() != Change.Status.DRAFT) {
        throw new ResourceConflictException("Change is not a draft: " + id);
    }
    if (!allowDrafts) {
        throw new MethodNotAllowedException("Draft workflow is disabled");
    }
    if (!ctx.getControl().canDeleteDraft(ctx.getDb())) {
        throw new AuthException("Not permitted to delete this draft change");
    }
    for (PatchSet ps : patchSets) {
        if (!ps.isDraft()) {
            throw new ResourceConflictException("Cannot delete draft change " + id + ": patch set " + ps.getPatchSetId() + " is not a draft");
        }
    }
}
#method_after
private void ensureDeletable(ChangeContext ctx, Change.Id id, Collection<PatchSet> patchSets) throws ResourceConflictException, MethodNotAllowedException, OrmException, AuthException {
    if (ctx.getChange().getStatus() != Change.Status.DRAFT) {
        throw new ResourceConflictException("Change is not a draft: " + id);
    }
    if (!allowDrafts) {
        throw new MethodNotAllowedException("Draft workflow is disabled");
    }
    if (!ctx.getControl().canDeleteDraft(ctx.getDb())) {
        throw new AuthException("Not permitted to delete this draft change");
    }
    for (PatchSet ps : patchSets) {
        if (!ps.isDraft()) {
            throw new ResourceConflictException("Cannot delete draft change " + id + ": patch set " + ps.getPatchSetId() + " is not a draft");
        }
    }
}
#end_block

#method_before
private void cleanUpReferences(ChangeContext ctx, Change.Id id, List<PatchSet> patchSets) throws OrmException, NoSuchChangeException {
    for (PatchSet ps : patchSets) {
        accountPatchReviewStore.get().clearReviewed(ps.getId());
    }
    // Non-atomic operation on Accounts table; not much we can do to make it
    // atomic.
    starredChangesUtil.unstarAll(ctx.getChange().getProject(), id);
}
#method_after
private void cleanUpReferences(ChangeContext ctx, Change.Id id, Collection<PatchSet> patchSets) throws OrmException, NoSuchChangeException {
    for (PatchSet ps : patchSets) {
        accountPatchReviewStore.get().clearReviewed(ps.getId());
    }
    // Non-atomic operation on Accounts table; not much we can do to make it
    // atomic.
    starredChangesUtil.unstarAll(ctx.getChange().getProject(), id);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(OAUTH_TOKENS, String.class, OAuthToken.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(OAUTH_TOKENS, Account.Id.class, OAuthToken.class);
        }
    };
}
#end_block

#method_before
public OAuthToken get(String userName) {
    OAuthToken accessToken = cache.getIfPresent(userName);
    if (accessToken == null) {
        return null;
    }
    accessToken = decrypt(accessToken);
    if (accessToken.isExpired()) {
        cache.invalidate(userName);
        return null;
    }
    return accessToken;
}
#method_after
public OAuthToken get(Account.Id id) {
    OAuthToken accessToken = cache.getIfPresent(id);
    if (accessToken == null) {
        return null;
    }
    accessToken = decrypt(accessToken);
    if (accessToken.isExpired()) {
        cache.invalidate(id);
        return null;
    }
    return accessToken;
}
#end_block

#method_before
public void put(OAuthUserInfo user, OAuthToken accessToken) {
    cache.put(checkNotNull(user.getGerritUserName()), encrypt(checkNotNull(accessToken)));
}
#method_after
public void put(Account.Id id, OAuthToken accessToken) {
    cache.put(id, encrypt(checkNotNull(accessToken)));
}
#end_block

#method_before
public void remove(OAuthUserInfo user) {
    if (user != null) {
        cache.invalidate(user.getGerritUserName());
    }
}
#method_after
public void remove(Account.Id id) {
    cache.invalidate(id);
}
#end_block

#method_before
private void authenticateAndRedirect(HttpServletRequest req, HttpServletResponse rsp, OAuthToken token) throws IOException {
    AuthRequest areq = new AuthRequest(user.getExternalId());
    AuthResult arsp;
    try {
        String claimedIdentifier = user.getClaimedIdentity();
        if (!Strings.isNullOrEmpty(claimedIdentifier)) {
            if (!authenticateWithIdentityClaimedDuringHandshake(areq, rsp, claimedIdentifier)) {
                return;
            }
        } else if (linkMode) {
            if (!authenticateWithLinkedIdentity(areq, rsp)) {
                return;
            }
        }
        areq.setUserName(user.getUserName());
        areq.setEmailAddress(user.getEmailAddress());
        areq.setDisplayName(user.getDisplayName());
        arsp = accountManager.authenticate(areq);
        if (user != null) {
            user.setGerritUserName(accountCache.get(arsp.getAccountId()).getUserName());
            if (token != null && user.getGerritUserName() != null) {
                tokenCache.put(user, token);
            }
        }
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    webSession.get().login(arsp, true);
    String suffix = redirectToken.substring(OAuthWebFilter.GERRIT_LOGIN.length() + 1);
    StringBuilder rdr = new StringBuilder(urlProvider.get(req));
    rdr.append(Url.decode(suffix));
    rsp.sendRedirect(rdr.toString());
}
#method_after
private void authenticateAndRedirect(HttpServletRequest req, HttpServletResponse rsp, OAuthToken token) throws IOException {
    AuthRequest areq = new AuthRequest(user.getExternalId());
    AuthResult arsp;
    try {
        String claimedIdentifier = user.getClaimedIdentity();
        if (!Strings.isNullOrEmpty(claimedIdentifier)) {
            if (!authenticateWithIdentityClaimedDuringHandshake(areq, rsp, claimedIdentifier)) {
                return;
            }
        } else if (linkMode) {
            if (!authenticateWithLinkedIdentity(areq, rsp)) {
                return;
            }
        }
        areq.setUserName(user.getUserName());
        areq.setEmailAddress(user.getEmailAddress());
        areq.setDisplayName(user.getDisplayName());
        arsp = accountManager.authenticate(areq);
        accountId = arsp.getAccountId();
        tokenCache.put(accountId, token);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    webSession.get().login(arsp, true);
    String suffix = redirectToken.substring(OAuthWebFilter.GERRIT_LOGIN.length() + 1);
    StringBuilder rdr = new StringBuilder(urlProvider.get(req));
    rdr.append(Url.decode(suffix));
    rsp.sendRedirect(rdr.toString());
}
#end_block

#method_before
void logout() {
    if (user != null && user.getGerritUserName() != null) {
        tokenCache.remove(user);
    }
    user = null;
    redirectToken = null;
    serviceProvider = null;
}
#method_after
void logout() {
    if (accountId != null) {
        tokenCache.remove(accountId);
        accountId = null;
    }
    user = null;
    redirectToken = null;
    serviceProvider = null;
}
#end_block

#method_before
@Override
public String toString() {
    return "OAuthSession [token=" + tokenCache.get(user) + ", user=" + user + "]";
}
#method_after
@Override
public String toString() {
    return "OAuthSession [token=" + tokenCache.get(accountId) + ", user=" + user + "]";
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(UpdateChangeByMerge.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws Exception {
    changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), ctx.getRepository(), priorCommit, commit);
    if (checkMergedInto) {
        Ref mergedInto = findMergedInto(ctx, dest.get(), commit);
        if (mergedInto != null) {
            mergedByPushOp = mergedByPushOpFactory.create(requestScopePropagator, patchSetId, mergedInto.getName());
        }
    }
    if (updateRef) {
        if (updateRefCommand == null) {
            ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, patchSetId.toRefName()));
        } else {
            ctx.addRefUpdate(updateRefCommand);
        }
    }
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws Exception {
    changeKind = changeKindCache.getChangeKind(projectControl.getProject().getNameKey(), ctx.getRepository(), priorCommit, commit);
    if (checkMergedInto) {
        Ref mergedInto = findMergedInto(ctx, dest.get(), commit);
        if (mergedInto != null) {
            mergedByPushOp = mergedByPushOpFactory.create(requestScopePropagator, patchSetId, mergedInto.getName());
        }
    }
    if (updateRef) {
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, patchSetId.toRefName()));
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovals(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getAccountId(), ctx.getWhen(), patchSetId);
    msg.setMessage(message.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx, msg);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovalsForNewPatchSet(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet, newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String kindMessage = changeKindMessage(changeKind);
    StringBuilder message = new StringBuilder(approvalMessage);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    } else {
        message.append('.');
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = ChangeMessagesUtil.newMessage(ctx.getDb(), patchSetId, ctx.getUser(), ctx.getWhen(), message.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx, msg);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(final Context ctx) throws Exception {
    // Normally the ref updated hook is fired by BatchUpdate, but ReplaceOp is
    // special because its ref is actually updated by ReceiveCommits, so from
    // BatchUpdate's perspective there is no ref update. Thus we have to fire it
    // manually.
    final Account account = ctx.getAccount();
    if (!updateRef) {
        gitRefUpdated.fire(ctx.getProject(), newPatchSet.getRefName(), ObjectId.zeroId(), commit, account);
    }
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(projectControl.getProject().getNameKey(), change.getId());
                    cm.setFrom(account.getId());
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
                    if (magicBranch != null && magicBranch.notify != null) {
                        cm.setNotify(magicBranch.notify);
                    }
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    NotifyHandling notify = magicBranch != null && magicBranch.notify != null ? magicBranch.notify : NotifyHandling.ALL;
    revisionCreated.fire(change, newPatchSet, ctx.getAccountId(), ctx.getWhen(), notify);
    try {
        fireCommentAddedEvent(ctx);
    } catch (Exception e) {
        log.warn("comment-added event invocation failed", e);
    }
    if (mergedByPushOp != null) {
        mergedByPushOp.postUpdate(ctx);
    }
}
#method_after
@Override
public void postUpdate(final Context ctx) throws Exception {
    // Normally the ref updated hook is fired by BatchUpdate, but ReplaceOp is
    // special because its ref is actually updated by ReceiveCommits, so from
    // BatchUpdate's perspective there is no ref update. Thus we have to fire it
    // manually.
    final Account account = ctx.getAccount();
    if (!updateRef) {
        gitRefUpdated.fire(ctx.getProject(), newPatchSet.getRefName(), ObjectId.zeroId(), commit, account);
    }
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(projectControl.getProject().getNameKey(), change.getId());
                    cm.setFrom(account.getId());
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
                    if (magicBranch != null && magicBranch.notify != null) {
                        cm.setNotify(magicBranch.notify);
                    }
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    NotifyHandling notify = magicBranch != null && magicBranch.notify != null ? magicBranch.notify : NotifyHandling.ALL;
    revisionCreated.fire(change, newPatchSet, ctx.getAccount(), ctx.getWhen(), notify);
    try {
        fireCommentAddedEvent(ctx);
    } catch (Exception e) {
        log.warn("comment-added event invocation failed", e);
    }
    if (mergedByPushOp != null) {
        mergedByPushOp.postUpdate(ctx);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // In case the change look up from the index failed,
                // double check against the existing ref if applicable
                Collection<Ref> existingRefs = existing.get(p.commit);
                if (!existingRefs.isEmpty()) {
                    for (Ref ref : existingRefs) {
                        ChangeNotes notes = notesFactory.create(db, project.getNameKey(), Change.Id.fromRef(ref.getName()));
                        if (notes.getChange().getDest().equals(magicBranch.dest)) {
                            // find the change to the same branch
                            logDebug("Found change from existing refs.");
                            reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                            return;
                        }
                    }
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    logDebug("Finding new and replaced changes");
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return;
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).isRejectImplicitMerges() && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            if (!existingRefs.isEmpty()) {
                // Commit is already tracked.
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
                logDebug("Creating new change for {} even though it is already tracked", name);
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                logDebug("Aborting early due to invalid commit");
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logDebug("Rejecting merge commit {} with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logDebug("{} changes exceeds limit of {}", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        logDebug("Finished initial RevWalk with {} commits total: {} already" + " tracked, {} new changes with no Change-Id, and {} deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                logDebug("Multiple commits with Change-Id {}", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logDebug("Multiple changes in project with Change-Id {}: {}", p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        newChanges = Collections.emptyList();
                        return;
                    } else {
                        itr.remove();
                        continue;
                    }
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
        logDebug("Finished deferred lookups with {} updates and {} new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        logError("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logDebug("Finished updating groups from GroupCollector");
    } catch (OrmException | NoSuchChangeException e) {
        logError("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void fireChangeIndexedEvent(int id) {
    for (ChangeIndexedListener listener : indexedListeners) {
        try {
            listener.onChangeIndexed(id);
        } catch (Exception e) {
            eventUtil.logEventListenerError(listener, e);
        }
    }
}
#method_after
private void fireChangeIndexedEvent(int id) {
    for (ChangeIndexedListener listener : indexedListeners) {
        try {
            listener.onChangeIndexed(id);
        } catch (Exception e) {
            logEventListenerError(listener, e);
        }
    }
}
#end_block

#method_before
private void fireChangeDeletedFromIndexEvent(int id) {
    for (ChangeIndexedListener listener : indexedListeners) {
        try {
            listener.onChangeDeleted(id);
        } catch (Exception e) {
            eventUtil.logEventListenerError(listener, e);
        }
    }
}
#method_after
private void fireChangeDeletedFromIndexEvent(int id) {
    for (ChangeIndexedListener listener : indexedListeners) {
        try {
            listener.onChangeDeleted(id);
        } catch (Exception e) {
            logEventListenerError(listener, e);
        }
    }
}
#end_block

#method_before
public void logEventListenerError(Object listener, Exception error) {
    if (log.isDebugEnabled()) {
        log.debug(String.format("Error in event listener %s", listener.getClass().getName(), error));
    } else {
        log.warn("Error in listener {}: {}", listener.getClass().getName(), error.getMessage());
    }
}
#method_after
public static void logEventListenerError(Object listener, Exception error) {
    if (log.isDebugEnabled()) {
        log.debug(String.format("Error in event listener %s", listener.getClass().getName(), error));
    } else {
        log.warn("Error in listener {}: {}", listener.getClass().getName(), error.getMessage());
    }
}
#end_block

#method_before
static Optional<StatusChangeEvent> parseFromMessage(ChangeMessage message, Change change, Change noteDbChange) {
    String msg = message.getMessage();
    if (msg == null) {
        return Optional.absent();
    }
    for (Map.Entry<Change.Status, Pattern> e : PATTERNS.entrySet()) {
        if (e.getValue().matcher(msg).matches()) {
            return Optional.of(new StatusChangeEvent(message, change, noteDbChange, e.getKey()));
        }
    }
    return Optional.absent();
}
#method_after
static Optional<StatusChangeEvent> parseFromMessage(ChangeMessage message, Change change, Change noteDbChange) {
    String msg = message.getMessage();
    if (msg == null) {
        return Optional.empty();
    }
    for (Map.Entry<Change.Status, Pattern> e : PATTERNS.entrySet()) {
        if (e.getValue().matcher(msg).matches()) {
            return Optional.of(new StatusChangeEvent(message, change, noteDbChange, e.getKey()));
        }
    }
    return Optional.empty();
}
#end_block

#method_before
public ChangeInfo format(ChangeData cd) throws OrmException {
    return format(cd, Optional.<PatchSet.Id>absent(), true);
}
#method_after
public ChangeInfo format(ChangeData cd) throws OrmException {
    return format(cd, Optional.empty(), true);
}
#end_block

#method_before
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.<PatchSet.Id>absent());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#method_after
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#end_block

#method_before
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
                if (psa.isPostSubmit()) {
                    log.warn("unexpected post-submit approval on open change: {}", psa);
                }
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, tag, date));
        }
    }
}
#method_after
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    Change.Status status = cd.change().getStatus();
    checkState(status.isOpen(), "should not call setAllApprovals on %s change", status);
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
                if (psa.isPostSubmit()) {
                    log.warn("unexpected post-submit approval on open change: {}", psa);
                }
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, tag, date));
        }
    }
}
#end_block

#method_before
private RevisionResource onBehalfOf(RevisionResource rev, ReviewInput in) throws BadRequestException, AuthException, UnprocessableEntityException, OrmException {
    if (in.labels == null || in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    if (in.drafts == null) {
        in.drafts = DraftHandling.KEEP;
    }
    if (in.drafts != DraftHandling.KEEP) {
        throw new AuthException("not allowed to modify other user's drafts");
    }
    ChangeControl caller = rev.getControl();
    Iterator<Map.Entry<String, Short>> itr = in.labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType type = caller.getLabelTypes().byLabel(ent.getKey());
        if (type == null && in.strictLabels) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        } else if (type == null) {
            itr.remove();
            continue;
        }
        PermissionRange r = caller.getRange(Permission.forLabelAs(type.getName()));
        if (r == null || r.isEmpty() || !r.contains(ent.getValue())) {
            throw new AuthException(String.format("not permitted to modify label \"%s\" on behalf of \"%s\"", ent.getKey(), in.onBehalfOf));
        }
    }
    if (in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    ChangeControl target = caller.forUser(accounts.parseOnBehalfOf(caller.getUser(), in.onBehalfOf));
    if (!target.getRefControl().isVisible()) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see destination ref", target.getUser().getAccountId()));
    }
    return new RevisionResource(changes.parse(target), rev.getPatchSet());
}
#method_after
private RevisionResource onBehalfOf(RevisionResource rev, ReviewInput in) throws BadRequestException, AuthException, UnprocessableEntityException, OrmException {
    if (in.labels == null || in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    if (in.drafts == null) {
        in.drafts = DraftHandling.KEEP;
    }
    if (in.drafts != DraftHandling.KEEP) {
        throw new AuthException("not allowed to modify other user's drafts");
    }
    ChangeControl caller = rev.getControl();
    Iterator<Map.Entry<String, Short>> itr = in.labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType type = caller.getLabelTypes().byLabel(ent.getKey());
        if (type == null && in.strictLabels) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        } else if (type == null) {
            itr.remove();
            continue;
        }
        if (caller.getUser().isInternalUser()) {
            continue;
        }
        PermissionRange r = caller.getRange(Permission.forLabelAs(type.getName()));
        if (r == null || r.isEmpty() || !r.contains(ent.getValue())) {
            throw new AuthException(String.format("not permitted to modify label \"%s\" on behalf of \"%s\"", ent.getKey(), in.onBehalfOf));
        }
    }
    if (in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    ChangeControl target = caller.forUser(accounts.parseOnBehalfOf(caller.getUser(), in.onBehalfOf));
    if (!target.getRefControl().isVisible()) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see destination ref", target.getUser().getAccountId()));
    }
    return new RevisionResource(changes.parse(target), rev.getPatchSet());
}
#end_block

#method_before
@Override
public Result rebuild(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    try (NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject())) {
        buildUpdates(manager, bundleReader.fromReviewDb(db, changeId));
        return execute(db, changeId, manager);
    }
}
#method_after
@Override
public Result rebuild(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    db = ReviewDbUtil.unwrapDb(db);
    // Read change just to get project; this instance is then discarded so we
    // can read a consistent ChangeBundle inside a transaction.
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    try (NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject())) {
        buildUpdates(manager, bundleReader.fromReviewDb(db, changeId));
        return execute(db, changeId, manager);
    }
}
#end_block

#method_before
private void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException {
    manager.setCheckExpectedState(false);
    Change change = new Change(bundle.getChange());
    if (bundle.getPatchSets().isEmpty()) {
        throw new NoPatchSetsException(change.getId());
    }
    PatchSet.Id currPsId = change.currentPatchSetId();
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = new ArrayList<>();
    Multimap<Account.Id, DraftCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteChangeMetaRef(change, manager.getChangeRepo().cmds);
    deleteDraftRefs(change, manager.getAllUsersRepo());
    Integer minPsNum = getMinPatchSetNum(bundle);
    Map<PatchSet.Id, PatchSetEvent> patchSetEvents = Maps.newHashMapWithExpectedSize(bundle.getPatchSets().size());
    for (PatchSet ps : bundle.getPatchSets()) {
        if (ps.getId().get() > currPsId.get()) {
            log.info("Skipping patch set {}, which is higher than current patch set {}", ps.getId(), currPsId);
            continue;
        }
        PatchSetEvent pse = new PatchSetEvent(change, ps, manager.getChangeRepo().rw);
        patchSetEvents.put(ps.getId(), pse);
        events.add(pse);
        for (Comment c : getComments(bundle, serverId, Status.PUBLISHED, ps)) {
            CommentEvent e = new CommentEvent(c, change, ps, patchListCache);
            events.add(e.addDep(pse));
        }
        for (Comment c : getComments(bundle, serverId, Status.DRAFT, ps)) {
            DraftCommentEvent e = new DraftCommentEvent(c, change, ps, patchListCache);
            draftCommentEvents.put(c.author.getId(), e);
        }
    }
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        PatchSetEvent pse = patchSetEvents.get(psa.getPatchSetId());
        if (pse != null) {
            events.add(new ApprovalEvent(psa, change.getCreatedOn()).addDep(pse));
        }
    }
    for (Table.Cell<ReviewerStateInternal, Account.Id, Timestamp> r : bundle.getReviewers().asTable().cellSet()) {
        events.add(new ReviewerEvent(r, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        List<Event> msgEvents = parseChangeMessage(msg, change, noteDbChange);
        if (msg.getPatchSetId() != null) {
            PatchSetEvent pse = patchSetEvents.get(msg.getPatchSetId());
            if (pse != null) {
                for (Event e : msgEvents) {
                    e.addDep(pse);
                }
            }
        }
        events.addAll(msgEvents);
    }
    sortAndFillEvents(change, noteDbChange, events, minPsNum);
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<DraftCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (DraftCommentEvent e : Ordering.natural().sortedCopy(draftCommentEvents.get(author))) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#method_after
@Override
public void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException {
    manager.setCheckExpectedState(false);
    Change change = new Change(bundle.getChange());
    if (bundle.getPatchSets().isEmpty()) {
        throw new NoPatchSetsException(change.getId());
    }
    PatchSet.Id currPsId = change.currentPatchSetId();
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = new ArrayList<>();
    Multimap<Account.Id, DraftCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteChangeMetaRef(change, manager.getChangeRepo().cmds);
    deleteDraftRefs(change, manager.getAllUsersRepo());
    Integer minPsNum = getMinPatchSetNum(bundle);
    Map<PatchSet.Id, PatchSetEvent> patchSetEvents = Maps.newHashMapWithExpectedSize(bundle.getPatchSets().size());
    for (PatchSet ps : bundle.getPatchSets()) {
        if (ps.getId().get() > currPsId.get()) {
            log.info("Skipping patch set {}, which is higher than current patch set {}", ps.getId(), currPsId);
            continue;
        }
        PatchSetEvent pse = new PatchSetEvent(change, ps, manager.getChangeRepo().rw);
        patchSetEvents.put(ps.getId(), pse);
        events.add(pse);
        for (Comment c : getComments(bundle, serverId, Status.PUBLISHED, ps)) {
            CommentEvent e = new CommentEvent(c, change, ps, patchListCache);
            events.add(e.addDep(pse));
        }
        for (Comment c : getComments(bundle, serverId, Status.DRAFT, ps)) {
            DraftCommentEvent e = new DraftCommentEvent(c, change, ps, patchListCache);
            draftCommentEvents.put(c.author.getId(), e);
        }
    }
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        PatchSetEvent pse = patchSetEvents.get(psa.getPatchSetId());
        if (pse != null) {
            events.add(new ApprovalEvent(psa, change.getCreatedOn()).addDep(pse));
        }
    }
    for (Table.Cell<ReviewerStateInternal, Account.Id, Timestamp> r : bundle.getReviewers().asTable().cellSet()) {
        events.add(new ReviewerEvent(r, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        List<Event> msgEvents = parseChangeMessage(msg, change, noteDbChange);
        if (msg.getPatchSetId() != null) {
            PatchSetEvent pse = patchSetEvents.get(msg.getPatchSetId());
            if (pse != null) {
                for (Event e : msgEvents) {
                    e.addDep(pse);
                }
            }
        }
        events.addAll(msgEvents);
    }
    sortAndFillEvents(change, noteDbChange, events, minPsNum);
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<DraftCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (DraftCommentEvent e : Ordering.natural().sortedCopy(draftCommentEvents.get(author))) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#end_block

#method_before
private void setPostSubmitDeps(List<Event> events) {
    java.util.Optional<Event> submitEvent = Lists.reverse(events).stream().filter(Event::isSubmit).findFirst();
    if (submitEvent.isPresent()) {
        events.stream().filter(Event::isPostSubmitApproval).forEach(e -> e.addDep(submitEvent.get()));
    }
}
#method_after
private void setPostSubmitDeps(List<Event> events) {
    Optional<Event> submitEvent = Lists.reverse(events).stream().filter(Event::isSubmit).findFirst();
    if (submitEvent.isPresent()) {
        events.stream().filter(Event::isPostSubmitApproval).forEach(e -> e.addDep(submitEvent.get()));
    }
}
#end_block

#method_before
private ChangeNotesState buildState() {
    return ChangeNotesState.create(id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee != null ? assignee.orNull() : null, status, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments);
}
#method_after
private ChangeNotesState buildState() {
    return ChangeNotesState.create(id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, assignee != null ? assignee.orElse(null) : null, status, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments);
}
#end_block

#method_before
private void parseAssignee(ChangeNotesCommit commit) throws ConfigInvalidException {
    if (pastAssignees == null) {
        pastAssignees = Lists.newArrayList();
    }
    String assigneeValue = parseOneFooter(commit, FOOTER_ASSIGNEE);
    if (assigneeValue != null) {
        Optional<Account.Id> parsedAssignee;
        if (assigneeValue.equals("")) {
            // Empty footer found, assignee deleted
            parsedAssignee = Optional.absent();
        } else {
            PersonIdent ident = RawParseUtils.parsePersonIdent(assigneeValue);
            parsedAssignee = Optional.fromNullable(noteUtil.parseIdent(ident, id));
        }
        if (assignee == null) {
            assignee = parsedAssignee;
        }
        if (parsedAssignee.isPresent()) {
            pastAssignees.add(parsedAssignee.get());
        }
    }
}
#method_after
private void parseAssignee(ChangeNotesCommit commit) throws ConfigInvalidException {
    if (pastAssignees == null) {
        pastAssignees = Lists.newArrayList();
    }
    String assigneeValue = parseOneFooter(commit, FOOTER_ASSIGNEE);
    if (assigneeValue != null) {
        Optional<Account.Id> parsedAssignee;
        if (assigneeValue.equals("")) {
            // Empty footer found, assignee deleted
            parsedAssignee = Optional.empty();
        } else {
            PersonIdent ident = RawParseUtils.parsePersonIdent(assigneeValue);
            parsedAssignee = Optional.ofNullable(noteUtil.parseIdent(ident, id));
        }
        if (assignee == null) {
            assignee = parsedAssignee;
        }
        if (parsedAssignee.isPresent()) {
            pastAssignees.add(parsedAssignee.get());
        }
    }
}
#end_block

#method_before
private Change.Status parseStatus(ChangeNotesCommit commit) throws ConfigInvalidException {
    List<String> statusLines = commit.getFooterLineValues(FOOTER_STATUS);
    if (statusLines.isEmpty()) {
        return null;
    } else if (statusLines.size() > 1) {
        throw expectedOneFooter(FOOTER_STATUS, statusLines);
    }
    Optional<Change.Status> status = Enums.getIfPresent(Change.Status.class, statusLines.get(0).toUpperCase());
    if (!status.isPresent()) {
        throw invalidFooter(FOOTER_STATUS, statusLines.get(0));
    }
    // something else, but just in case.)
    if (status.get() == Change.Status.MERGED) {
        for (PatchSetApproval psa : bufferedApprovals) {
            psa.setPostSubmit(true);
        }
    }
    bufferedApprovals.clear();
    return status.get();
}
#method_after
private Change.Status parseStatus(ChangeNotesCommit commit) throws ConfigInvalidException {
    List<String> statusLines = commit.getFooterLineValues(FOOTER_STATUS);
    if (statusLines.isEmpty()) {
        return null;
    } else if (statusLines.size() > 1) {
        throw expectedOneFooter(FOOTER_STATUS, statusLines);
    }
    Change.Status status = Enums.getIfPresent(Change.Status.class, statusLines.get(0).toUpperCase()).orNull();
    if (status == null) {
        throw invalidFooter(FOOTER_STATUS, statusLines.get(0));
    }
    // something else, but just in case.)
    if (status == Change.Status.MERGED) {
        for (PatchSetApproval psa : bufferedApprovals) {
            psa.setPostSubmit(true);
        }
    }
    bufferedApprovals.clear();
    return status;
}
#end_block

#method_before
private PatchSetState parsePatchSetState(ChangeNotesCommit commit) throws ConfigInvalidException {
    String psIdLine = parseExactlyOneFooter(commit, FOOTER_PATCH_SET);
    int s = psIdLine.indexOf(' ');
    if (s < 0) {
        return null;
    }
    String withParens = psIdLine.substring(s + 1);
    if (withParens.startsWith("(") && withParens.endsWith(")")) {
        Optional<PatchSetState> state = Enums.getIfPresent(PatchSetState.class, withParens.substring(1, withParens.length() - 1).toUpperCase());
        if (state.isPresent()) {
            return state.get();
        }
    }
    throw invalidFooter(FOOTER_PATCH_SET, psIdLine);
}
#method_after
private PatchSetState parsePatchSetState(ChangeNotesCommit commit) throws ConfigInvalidException {
    String psIdLine = parseExactlyOneFooter(commit, FOOTER_PATCH_SET);
    int s = psIdLine.indexOf(' ');
    if (s < 0) {
        return null;
    }
    String withParens = psIdLine.substring(s + 1);
    if (withParens.startsWith("(") && withParens.endsWith(")")) {
        PatchSetState state = Enums.getIfPresent(PatchSetState.class, withParens.substring(1, withParens.length() - 1).toUpperCase()).orNull();
        if (state != null) {
            return state;
        }
    }
    throw invalidFooter(FOOTER_PATCH_SET, psIdLine);
}
#end_block

#method_before
private void parseSubmitRecords(List<String> lines) throws ConfigInvalidException {
    SubmitRecord rec = null;
    for (String line : lines) {
        int c = line.indexOf(": ");
        if (c < 0) {
            rec = new SubmitRecord();
            submitRecords.add(rec);
            int s = line.indexOf(' ');
            String statusStr = s >= 0 ? line.substring(0, s) : line;
            Optional<SubmitRecord.Status> status = Enums.getIfPresent(SubmitRecord.Status.class, statusStr);
            checkFooter(status.isPresent(), FOOTER_SUBMITTED_WITH, line);
            rec.status = status.get();
            if (s >= 0) {
                rec.errorMessage = line.substring(s);
            }
        } else {
            checkFooter(rec != null, FOOTER_SUBMITTED_WITH, line);
            SubmitRecord.Label label = new SubmitRecord.Label();
            if (rec.labels == null) {
                rec.labels = new ArrayList<>();
            }
            rec.labels.add(label);
            Optional<SubmitRecord.Label.Status> status = Enums.getIfPresent(SubmitRecord.Label.Status.class, line.substring(0, c));
            checkFooter(status.isPresent(), FOOTER_SUBMITTED_WITH, line);
            label.status = status.get();
            int c2 = line.indexOf(": ", c + 2);
            if (c2 >= 0) {
                label.label = line.substring(c + 2, c2);
                PersonIdent ident = RawParseUtils.parsePersonIdent(line.substring(c2 + 2));
                checkFooter(ident != null, FOOTER_SUBMITTED_WITH, line);
                label.appliedBy = noteUtil.parseIdent(ident, id);
            } else {
                label.label = line.substring(c + 2);
            }
        }
    }
}
#method_after
private void parseSubmitRecords(List<String> lines) throws ConfigInvalidException {
    SubmitRecord rec = null;
    for (String line : lines) {
        int c = line.indexOf(": ");
        if (c < 0) {
            rec = new SubmitRecord();
            submitRecords.add(rec);
            int s = line.indexOf(' ');
            String statusStr = s >= 0 ? line.substring(0, s) : line;
            rec.status = Enums.getIfPresent(SubmitRecord.Status.class, statusStr).orNull();
            checkFooter(rec.status != null, FOOTER_SUBMITTED_WITH, line);
            if (s >= 0) {
                rec.errorMessage = line.substring(s);
            }
        } else {
            checkFooter(rec != null, FOOTER_SUBMITTED_WITH, line);
            SubmitRecord.Label label = new SubmitRecord.Label();
            if (rec.labels == null) {
                rec.labels = new ArrayList<>();
            }
            rec.labels.add(label);
            label.status = Enums.getIfPresent(SubmitRecord.Label.Status.class, line.substring(0, c)).orNull();
            checkFooter(label.status != null, FOOTER_SUBMITTED_WITH, line);
            int c2 = line.indexOf(": ", c + 2);
            if (c2 >= 0) {
                label.label = line.substring(c + 2, c2);
                PersonIdent ident = RawParseUtils.parsePersonIdent(line.substring(c2 + 2));
                checkFooter(ident != null, FOOTER_SUBMITTED_WITH, line);
                label.appliedBy = noteUtil.parseIdent(ident, id);
            } else {
                label.label = line.substring(c + 2);
            }
        }
    }
}
#end_block

#method_before
private static S3Config getS3Config(LfsGlobalConfig config, LfsBackendConfig backendConfig) {
    String section = backendConfig.type.name();
    String region = config.getString(section, backendConfig.name, "region");
    String bucket = config.getString(section, backendConfig.name, "bucket");
    String storageClass = MoreObjects.firstNonNull(config.getString(section, backendConfig.name, "storageClass"), "REDUCED_REDUNDANCY");
    int expirationSeconds = config.getInt(section, backendConfig.name, "expirationSeconds", 60);
    boolean disableSslVerify = config.getBoolean(section, backendConfig.name, "disableSslVerify", false);
    String accessKey = config.getString(section, backendConfig.name, "accessKey");
    String secretKey = config.getString(section, backendConfig.name, "secretKey");
    return new S3Config(region, bucket, storageClass, accessKey, secretKey, expirationSeconds, disableSslVerify);
}
#method_after
private static S3Config getS3Config(LfsGlobalConfig config, LfsBackend backendConfig) {
    String section = backendConfig.type.name();
    String region = config.getString(section, backendConfig.name, "region");
    String bucket = config.getString(section, backendConfig.name, "bucket");
    String storageClass = MoreObjects.firstNonNull(config.getString(section, backendConfig.name, "storageClass"), "REDUCED_REDUNDANCY");
    int expirationSeconds = config.getInt(section, backendConfig.name, "expirationSeconds", 60);
    boolean disableSslVerify = config.getBoolean(section, backendConfig.name, "disableSslVerify", false);
    String accessKey = config.getString(section, backendConfig.name, "accessKey");
    String secretKey = config.getString(section, backendConfig.name, "secretKey");
    return new S3Config(region, bucket, storageClass, accessKey, secretKey, expirationSeconds, disableSslVerify);
}
#end_block

#method_before
public LfsBackendConfig getDefaultBackend() {
    LfsBackend type = cfg.getEnum("storage", null, "backend", LfsBackend.FS);
    return new LfsBackendConfig(null, type);
}
#method_after
public LfsBackend getDefaultBackend() {
    LfsBackendType type = cfg.getEnum("storage", null, "backend", LfsBackendType.FS);
    return new LfsBackend(null, type);
}
#end_block

#method_before
public Map<String, LfsBackendConfig> getBackends() {
    Builder<String, LfsBackendConfig> builder = ImmutableMap.builder();
    for (final LfsBackend type : LfsBackend.values()) {
        Map<String, LfsBackendConfig> backendsOfType = FluentIterable.from(cfg.getSubsections(type.name())).toMap(new Function<String, LfsBackendConfig>() {

            @Override
            public LfsBackendConfig apply(String input) {
                return new LfsBackendConfig(input, type);
            }
        });
        builder.putAll(backendsOfType);
    }
    return builder.build();
}
#method_after
public Map<String, LfsBackend> getBackends() {
    Builder<String, LfsBackend> builder = ImmutableMap.builder();
    for (final LfsBackendType type : LfsBackendType.values()) {
        Map<String, LfsBackend> backendsOfType = FluentIterable.from(cfg.getSubsections(type.name())).toMap(new Function<String, LfsBackend>() {

            @Override
            public LfsBackend apply(String input) {
                return new LfsBackend(input, type);
            }
        });
        builder.putAll(backendsOfType);
    }
    return builder.build();
}
#end_block

#method_before
@Override
public LfsGlobalConfigInfo apply(ProjectResource resource) throws RestApiException {
    IdentifiedUser user = self.get().asIdentifiedUser();
    if (!(resource.getNameKey().equals(allProjectsName) && user.getCapabilities().canAdministrateServer())) {
        throw new ResourceNotFoundException();
    }
    LfsGlobalConfigInfo info = new LfsGlobalConfigInfo();
    LfsGlobalConfig globalConfig = lfsConfigFactory.getGlobalConfig();
    info.defaultBackend = globalConfig.getDefaultBackend().type;
    info.backends = Maps.transformValues(globalConfig.getBackends(), TO_BACKEND_CFG);
    List<LfsProjectConfigSection> configSections = lfsConfigFactory.getProjectsConfig().getConfigSections();
    if (!configSections.isEmpty()) {
        info.namespaces = new HashMap<>(configSections.size());
        for (LfsProjectConfigSection section : configSections) {
            LfsProjectConfigInfo sectionInfo = new LfsProjectConfigInfo();
            sectionInfo.enabled = section.isEnabled();
            sectionInfo.maxObjectSize = section.getMaxObjectSize();
            sectionInfo.readOnly = section.isReadOnly();
            sectionInfo.backend = section.getBackend();
            info.namespaces.put(section.getNamespace(), sectionInfo);
        }
    }
    return info;
}
#method_after
@Override
public LfsGlobalConfigInfo apply(ProjectResource resource) throws RestApiException {
    IdentifiedUser user = self.get().asIdentifiedUser();
    if (!(resource.getNameKey().equals(allProjectsName) && user.getCapabilities().canAdministrateServer())) {
        throw new ResourceNotFoundException();
    }
    LfsGlobalConfigInfo info = new LfsGlobalConfigInfo();
    LfsGlobalConfig globalConfig = lfsConfigFactory.getGlobalConfig();
    info.defaultBackendType = globalConfig.getDefaultBackend().type;
    info.backends = Maps.transformValues(globalConfig.getBackends(), TO_BACKEND_CFG);
    List<LfsProjectConfigSection> configSections = lfsConfigFactory.getProjectsConfig().getConfigSections();
    if (!configSections.isEmpty()) {
        info.namespaces = new HashMap<>(configSections.size());
        for (LfsProjectConfigSection section : configSections) {
            LfsProjectConfigInfo sectionInfo = new LfsProjectConfigInfo();
            sectionInfo.enabled = section.isEnabled();
            sectionInfo.maxObjectSize = section.getMaxObjectSize();
            sectionInfo.readOnly = section.isReadOnly();
            sectionInfo.backend = section.getBackend();
            info.namespaces.put(section.getNamespace(), sectionInfo);
        }
    }
    return info;
}
#end_block

#method_before
@Override
protected void configureServlets() {
    serveRegex(URL_REGEX).with(LfsApiServlet.class);
    if (FS.equals(defBackendCfg.type)) {
        LocalLargeFileRepository defBackend = fsRepoFactory.create(defBackendCfg);
        serve(defBackend.getServletRegexp()).with(new LfsFsContentServlet(defBackend));
    }
    for (LfsBackendConfig backendCfg : backends.values()) {
        if (FS.equals(backendCfg.type)) {
            LocalLargeFileRepository backend = fsRepoFactory.create(backendCfg);
            serve(backend.getServletRegexp()).with(new LfsFsContentServlet(backend));
        }
    }
}
#method_after
@Override
protected void configureServlets() {
    serveRegex(URL_REGEX).with(LfsApiServlet.class);
    if (FS.equals(defaultBackend.type)) {
        LocalLargeFileRepository defRepository = fsRepoFactory.create(defaultBackend);
        serve(defRepository.getServletUrlPattern()).with(new LfsFsContentServlet(defRepository));
    }
    for (LfsBackend backendCfg : backends.values()) {
        if (FS.equals(backendCfg.type)) {
            LocalLargeFileRepository repository = fsRepoFactory.create(backendCfg);
            serve(repository.getServletUrlPattern()).with(new LfsFsContentServlet(repository));
        }
    }
}
#end_block

#method_before
public LargeFileRepository get(Project.NameKey project, String backendName) throws LfsRepositoryNotFound {
    LfsBackendConfig config = defaultBackend;
    if (!Strings.isNullOrEmpty(backendName)) {
        config = backends.get(backendName);
        if (config == null) {
            throw new LfsRepositoryNotFound(project.get());
        }
    }
    switch(config.type) {
        case FS:
            return fsRepoFactory.create(config);
        case S3:
            return s3RepoFactory.create(config);
        default:
            throw new LfsRepositoryNotFound(project.get());
    }
}
#method_after
public LargeFileRepository get(Project.NameKey project, String backendName) throws LfsRepositoryNotFound {
    LfsBackend config;
    if (Strings.isNullOrEmpty(backendName)) {
        config = defaultBackend;
    } else {
        config = backends.get(backendName);
        if (config == null) {
            throw new LfsRepositoryNotFound(project.get());
        }
    }
    switch(config.type) {
        case FS:
            return fsRepoFactory.create(config);
        case S3:
            return s3RepoFactory.create(config);
        default:
            throw new LfsRepositoryNotFound(project.get());
    }
}
#end_block

#method_before
private static String getContentUrl(String url, LfsBackendConfig backend) {
    // interfere with rest of FS backends
    return url + (url.endsWith("/") ? "" : "/") + getContentPath(backend);
}
#method_after
private static String getContentUrl(String url, LfsBackend backend) {
    // interfere with rest of FS backends
    return url + (url.endsWith("/") ? "" : "/") + getContentPath(backend);
}
#end_block

#method_before
private static String getContentPath(LfsBackendConfig backend) {
    return CONTENT_PATH + "/" + (Strings.isNullOrEmpty(backend.name) ? DEFAULT : backend.name) + "/";
}
#method_after
private static String getContentPath(LfsBackend backend) {
    return CONTENT_PATH + "/" + (Strings.isNullOrEmpty(backend.name) ? DEFAULT : backend.name) + "/";
}
#end_block

#method_before
private static Path getOrCreateDataDir(LfsGlobalConfig config, LfsBackendConfig backendConfig, Path defaultDataDir) throws IOException {
    String dataDir = config.getString(backendConfig.type.name(), backendConfig.name, "directory");
    if (Strings.isNullOrEmpty(dataDir)) {
        return defaultDataDir;
    }
    // note that the following method not only creates missing
    // directory/directories but throws exception when path
    // exists and points to file
    Path ensured = Files.createDirectories(Paths.get(dataDir));
    // we should at least make sure that directory is readable
    if (!Files.isReadable(ensured)) {
        throw new IOException("Path '" + ensured.toAbsolutePath() + "' cannot be accessed");
    }
    return ensured;
}
#method_after
private static Path getOrCreateDataDir(LfsGlobalConfig config, LfsBackend backendConfig, Path defaultDataDir) throws IOException {
    String dataDir = config.getString(backendConfig.type.name(), backendConfig.name, "directory");
    if (Strings.isNullOrEmpty(dataDir)) {
        return defaultDataDir;
    }
    // note that the following method not only creates missing
    // directory/directories but throws exception when path
    // exists and points to file
    Path ensured = Files.createDirectories(Paths.get(dataDir));
    // we should at least make sure that directory is readable
    if (!Files.isReadable(ensured)) {
        throw new IOException("Path '" + ensured.toAbsolutePath() + "' cannot be accessed");
    }
    return ensured;
}
#end_block

#method_before
public LargeFileRepository get(Project.NameKey project, String backendName) throws LfsRepositoryNotFound {
    LfsBackendConfig config = defaultBackend;
    if (!Strings.isNullOrEmpty(backendName)) {
        config = backends.get(backendName);
        if (config == null) {
            throw new LfsRepositoryNotFound(project.get());
        }
    }
    switch(config.type) {
        case FS:
            return fsRepositories.getRepository(config);
        case S3:
            return s3Repositories.getRepository(config);
        default:
            throw new LfsRepositoryNotFound(project.get());
    }
}
#method_after
public LargeFileRepository get(Project.NameKey project, String backendName) throws LfsRepositoryNotFound {
    LfsBackend backend;
    if (Strings.isNullOrEmpty(backendName)) {
        backend = defaultBackend;
    } else {
        backend = backends.get(backendName);
        if (backend == null) {
            log.error(String.format("Project %s is configured with not existing" + " backend %s", project, Strings.isNullOrEmpty(backendName) ? DEFAULT : backendName));
            throw new LfsRepositoryNotFound(project.get());
        }
    }
    LargeFileRepository repository = cache.get(backend);
    if (repository != null) {
        return repository;
    }
    // this is unlikely situation as cache is pre-populated from config but...
    log.error(String.format("Project %s is configured with not existing" + " backend %s of type %s", project, Strings.isNullOrEmpty(backendName) ? DEFAULT : backendName, backend.type));
    throw new LfsRepositoryNotFound(project.get());
}
#end_block

#method_before
@Override
protected void configureServlets() {
    serveRegex(URL_REGEX).with(LfsApiServlet.class);
    if (FS.equals(defaultBackend.type)) {
        LocalLargeFileRepository defRepository = fsRepositories.getRepository(defaultBackend);
        serve(defRepository.getServletRegexp()).with(new LfsFsContentServlet(defRepository));
    }
    for (LfsBackendConfig backendCfg : backends.values()) {
        if (FS.equals(backendCfg.type)) {
            LocalLargeFileRepository repository = fsRepositories.getRepository(backendCfg);
            serve(repository.getServletRegexp()).with(new LfsFsContentServlet(repository));
        }
    }
}
#method_after
@Override
protected void configureServlets() {
    serveRegex(URL_REGEX).with(LfsApiServlet.class);
    populateRepository(defaultBackend);
    for (LfsBackend backend : backends.values()) {
        populateRepository(backend);
    }
}
#end_block

#method_before
@Override
public boolean cancel(boolean mayInterruptIfRunning) {
    if (task.cancel(mayInterruptIfRunning)) {
        // 
        if (runnable instanceof CancelableRunnable) {
            if (running.compareAndSet(false, true)) {
                ((CancelableRunnable) runnable).cancel();
            } else if (runnable instanceof CanceledWhileRunning) {
                ((CanceledWhileRunning) runnable).setCanceledWhileRunning();
            }
        }
        if (runnable instanceof Future<?>) {
            // Creating new futures eventually passes through AbstractExecutorService#schedule,
            // which will convert the Guava Future to a Runnable, thereby making it impossible
            // for the cancellation to propagate from ScheduledThreadPool's task back to the
            // Guava future, so kludge it here.
            ((Future<?>) runnable).cancel(mayInterruptIfRunning);
        }
        executor.remove(this);
        executor.purge();
        return true;
    }
    return false;
}
#method_after
@Override
public boolean cancel(boolean mayInterruptIfRunning) {
    if (task.cancel(mayInterruptIfRunning)) {
        // 
        if (runnable instanceof CancelableRunnable) {
            if (running.compareAndSet(false, true)) {
                ((CancelableRunnable) runnable).cancel();
            } else if (runnable instanceof CanceledWhileRunning) {
                ((CanceledWhileRunning) runnable).setCanceledWhileRunning();
            }
        }
        if (runnable instanceof Future<?>) {
            // Creating new futures eventually passes through
            // AbstractExecutorService#schedule, which will convert the Guava
            // Future to a Runnable, thereby making it impossible for the
            // cancellation to propagate from ScheduledThreadPool's task back to
            // the Guava future, so kludge it here.
            ((Future<?>) runnable).cancel(mayInterruptIfRunning);
        }
        executor.remove(this);
        executor.purge();
        return true;
    }
    return false;
}
#end_block

#method_before
public Change.Id cherryPick(Change change, PatchSet patch, final String message, final String ref, final RefControl refControl, int parentIndex) throws NoSuchChangeException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    if (Strings.isNullOrEmpty(ref)) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    Project.NameKey project = change.getProject();
    String destinationBranch = RefNames.shortName(ref);
    IdentifiedUser identifiedUser = user.get();
    try (Repository git = gitManager.openRepository(project);
        // before patch sets are updated.
        ObjectInserter oi = git.newObjectInserter();
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(oi.newReader())) {
        Ref destRef = git.getRefDatabase().exactRef(ref);
        if (destRef == null) {
            throw new InvalidChangeOperationException(String.format("Branch %s does not exist.", destinationBranch));
        }
        CodeReviewCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
        CodeReviewCommit commitToCherryPick = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (parentIndex >= commitToCherryPick.getParentCount()) {
            throw new InvalidChangeOperationException(String.format("Cherry Pick: Parent %s does not exist. Only %s parent(s) available.", parentIndex + 1, commitToCherryPick.getParentCount()));
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = identifiedUser.newCommitterIdent(now, serverTimeZone);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), mergeTip, commitToCherryPick.getAuthorIdent(), committerIdent, message);
        String commitMessage = ChangeIdUtil.insertId(message, computedChangeId).trim() + '\n';
        CodeReviewCommit cherryPickCommit;
        try {
            ProjectState projectState = refControl.getProjectControl().getProjectState();
            cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, commitMessage, revWalk, parentIndex);
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            Branch.NameKey newDest = new Branch.NameKey(change.getProject(), destRef.getName());
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " reside on the same branch. " + "Cannot create a new patch set.");
            }
            try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getDest().getParentKey(), identifiedUser, now)) {
                bu.setRepository(git, revWalk, oi);
                Change.Id result;
                if (destChanges.size() == 1) {
                    // The change key exists on the destination branch. The cherry pick
                    // will be added as a new patch set.
                    ChangeControl destCtl = refControl.getProjectControl().controlFor(destChanges.get(0).notes());
                    result = insertPatchSet(bu, git, destCtl, cherryPickCommit);
                } else {
                    // Change key not found on destination branch. We can create a new
                    // change.
                    String newTopic = null;
                    if (!Strings.isNullOrEmpty(change.getTopic())) {
                        newTopic = change.getTopic() + "-" + newDest.getShortName();
                    }
                    result = createNewChange(bu, cherryPickCommit, refControl.getRefName(), newTopic, change.getDest());
                    bu.addOp(change.getId(), new AddMessageToSourceChangeOp(changeMessagesUtil, patch.getId(), destinationBranch, cherryPickCommit));
                }
                bu.execute();
                return result;
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(change.getId(), e);
    }
}
#method_after
public Change.Id cherryPick(Change change, PatchSet patch, final String message, final String ref, final RefControl refControl, int parent) throws NoSuchChangeException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    if (Strings.isNullOrEmpty(ref)) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    Project.NameKey project = change.getProject();
    String destinationBranch = RefNames.shortName(ref);
    IdentifiedUser identifiedUser = user.get();
    try (Repository git = gitManager.openRepository(project);
        // before patch sets are updated.
        ObjectInserter oi = git.newObjectInserter();
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(oi.newReader())) {
        Ref destRef = git.getRefDatabase().exactRef(ref);
        if (destRef == null) {
            throw new InvalidChangeOperationException(String.format("Branch %s does not exist.", destinationBranch));
        }
        CodeReviewCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
        CodeReviewCommit commitToCherryPick = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (parent <= 0 || parent > commitToCherryPick.getParentCount()) {
            throw new InvalidChangeOperationException(String.format("Cherry Pick: Parent %s does not exist. Please specify a parent in" + " range [1, %s].", parent, commitToCherryPick.getParentCount()));
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = identifiedUser.newCommitterIdent(now, serverTimeZone);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), mergeTip, commitToCherryPick.getAuthorIdent(), committerIdent, message);
        String commitMessage = ChangeIdUtil.insertId(message, computedChangeId).trim() + '\n';
        CodeReviewCommit cherryPickCommit;
        try {
            ProjectState projectState = refControl.getProjectControl().getProjectState();
            cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, commitMessage, revWalk, parent - 1);
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            Branch.NameKey newDest = new Branch.NameKey(change.getProject(), destRef.getName());
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " reside on the same branch. " + "Cannot create a new patch set.");
            }
            try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getDest().getParentKey(), identifiedUser, now)) {
                bu.setRepository(git, revWalk, oi);
                Change.Id result;
                if (destChanges.size() == 1) {
                    // The change key exists on the destination branch. The cherry pick
                    // will be added as a new patch set.
                    ChangeControl destCtl = refControl.getProjectControl().controlFor(destChanges.get(0).notes());
                    result = insertPatchSet(bu, git, destCtl, cherryPickCommit);
                } else {
                    // Change key not found on destination branch. We can create a new
                    // change.
                    String newTopic = null;
                    if (!Strings.isNullOrEmpty(change.getTopic())) {
                        newTopic = change.getTopic() + "-" + newDest.getShortName();
                    }
                    result = createNewChange(bu, cherryPickCommit, refControl.getRefName(), newTopic, change.getDest());
                    bu.addOp(change.getId(), new AddMessageToSourceChangeOp(changeMessagesUtil, patch.getId(), destinationBranch, cherryPickCommit));
                }
                bu.execute();
                return result;
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(change.getId(), e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo apply(RevisionResource revision, CherryPickInput input) throws OrmException, IOException, UpdateException, RestApiException {
    final ChangeControl control = revision.getControl();
    int parentIndex = input.parentNumber == null ? 0 : input.parentNumber - 1;
    if (input.message == null || input.message.trim().isEmpty()) {
        throw new BadRequestException("message must be non-empty");
    } else if (input.destination == null || input.destination.trim().isEmpty()) {
        throw new BadRequestException("destination must be non-empty");
    } else if (parentIndex < 0) {
        throw new BadRequestException("parent number must be positive if specified");
    }
    @SuppressWarnings("resource")
    ReviewDb db = dbProvider.get();
    if (!control.isVisible(db)) {
        throw new AuthException("Cherry pick not permitted");
    }
    ProjectControl projectControl = control.getProjectControl();
    Capable capable = projectControl.canPushToAtLeastOneRef();
    if (capable != Capable.OK) {
        throw new AuthException(capable.getMessage());
    }
    String refName = RefNames.fullName(input.destination);
    RefControl refControl = projectControl.controlForRef(refName);
    if (!refControl.canUpload()) {
        throw new AuthException("Not allowed to cherry pick " + revision.getChange().getId().toString() + " to " + input.destination);
    }
    try {
        Change.Id cherryPickedChangeId = cherryPickChange.cherryPick(revision.getChange(), revision.getPatchSet(), input.message, refName, refControl, parentIndex);
        return json.create(ChangeJson.NO_OPTIONS).format(revision.getProject(), cherryPickedChangeId);
    } catch (InvalidChangeOperationException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IntegrationException | NoSuchChangeException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
@Override
public ChangeInfo apply(RevisionResource revision, CherryPickInput input) throws OrmException, IOException, UpdateException, RestApiException {
    final ChangeControl control = revision.getControl();
    int parent = input.parent == null ? 1 : input.parent;
    if (input.message == null || input.message.trim().isEmpty()) {
        throw new BadRequestException("message must be non-empty");
    } else if (input.destination == null || input.destination.trim().isEmpty()) {
        throw new BadRequestException("destination must be non-empty");
    }
    @SuppressWarnings("resource")
    ReviewDb db = dbProvider.get();
    if (!control.isVisible(db)) {
        throw new AuthException("Cherry pick not permitted");
    }
    ProjectControl projectControl = control.getProjectControl();
    Capable capable = projectControl.canPushToAtLeastOneRef();
    if (capable != Capable.OK) {
        throw new AuthException(capable.getMessage());
    }
    String refName = RefNames.fullName(input.destination);
    RefControl refControl = projectControl.controlForRef(refName);
    if (!refControl.canUpload()) {
        throw new AuthException("Not allowed to cherry pick " + revision.getChange().getId().toString() + " to " + input.destination);
    }
    try {
        Change.Id cherryPickedChangeId = cherryPickChange.cherryPick(revision.getChange(), revision.getPatchSet(), input.message, refName, refControl, parent);
        return json.create(ChangeJson.NO_OPTIONS).format(revision.getProject(), cherryPickedChangeId);
    } catch (InvalidChangeOperationException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IntegrationException | NoSuchChangeException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public void requestSuggestions(Request req, Callback cb) {
    Query q = new Query(req, cb);
    if (query == null) {
        query = q;
        q.start();
    } else {
        query = q;
    }
}
#method_after
@Override
public void requestSuggestions(Request req, Callback cb) {
    if (!serveSuggestions) {
        return;
    }
    // backend for each and every keystroke we receive.
    if (requestRetentionTimer != null) {
        requestRetentionTimer.cancel();
    }
    requestRetentionTimer = new Timer() {

        @Override
        public void run() {
            Query q = new Query(req, cb);
            if (query == null) {
                query = q;
                q.start();
            } else {
                query = q;
            }
        }
    };
    requestRetentionTimer.schedule(200);
}
#end_block

#method_before
@Override
public void requestDefaultSuggestions(final Request req, final Callback cb) {
    // We don't want to deal with a null query, but an empty string instead
    req.setQuery("");
    requestSuggestions(req, cb);
}
#method_after
@Override
public void requestDefaultSuggestions(Request req, Callback cb) {
    requestSuggestions(req, cb);
}
#end_block

#method_before
@Override
public void onSuggestionsReady(Request req, Response res) {
    if (query == this) {
        // No new request was started while this query was running.
        // Propose this request's response as the suggestions.
        query = null;
        last = request.getQuery();
        callback.onSuggestionsReady(req, res);
    } else {
        // Another query came in while this one was running. Skip
        // this response and start the most recent query.
        query.start();
    }
}
#method_after
@Override
public void onSuggestionsReady(Request req, Response res) {
    if (cancelOutstandingRequest || !serveSuggestions) {
        // If cancelOutstandingRequest() was called, we ignore this response
        cancelOutstandingRequest = false;
        query = null;
    } else if (query == this) {
        // No new request was started while this query was running.
        // Propose this request's response as the suggestions.
        query = null;
        last = request.getQuery();
        callback.onSuggestionsReady(req, res);
    } else {
        // Another query came in while this one was running. Skip
        // this response and start the most recent query.
        query.start();
    }
}
#end_block

#method_before
@Override
protected void onRequestSuggestions(final Request req, final Callback cb) {
    ChangeApi.suggestReviewers(changeId.get(), req.getQuery(), req.getLimit()).get(new GerritCallback<JsArray<SuggestReviewerInfo>>() {

        @Override
        public void onSuccess(JsArray<SuggestReviewerInfo> result) {
            List<RestReviewerSuggestion> r = new ArrayList<>(result.length());
            for (SuggestReviewerInfo reviewer : Natives.asList(result)) {
                r.add(new RestReviewerSuggestion(reviewer, req.getQuery()));
            }
            cb.onSuggestionsReady(req, new Response(r));
        }

        @Override
        public void onFailure(Throwable err) {
            List<Suggestion> r = Collections.emptyList();
            cb.onSuggestionsReady(req, new Response(r));
        }
    });
}
#method_after
@Override
protected void onRequestSuggestions(final Request req, final Callback cb) {
    ChangeApi.suggestReviewers(changeId.get(), req.getQuery(), req.getLimit(), false).get(new GerritCallback<JsArray<SuggestReviewerInfo>>() {

        @Override
        public void onSuccess(JsArray<SuggestReviewerInfo> result) {
            List<RestReviewerSuggestion> r = new ArrayList<>(result.length());
            for (SuggestReviewerInfo reviewer : Natives.asList(result)) {
                r.add(new RestReviewerSuggestion(reviewer, req.getQuery()));
            }
            cb.onSuggestionsReady(req, new Response(r));
        }

        @Override
        public void onFailure(Throwable err) {
            List<Suggestion> r = Collections.emptyList();
            cb.onSuggestionsReady(req, new Response(r));
        }
    });
}
#end_block

#method_before
public List<SuggestedReviewerInfo> suggestReviewers(ChangeNotes changeNotes, SuggestReviewers suggestReviewers, ProjectControl projectControl, VisibilityControl visibilityControl) throws IOException, OrmException, BadRequestException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit();
    if (!suggestReviewers.getSuggestAccounts()) {
        return Collections.emptyList();
    }
    Map<Account.Id, Double> reviewerScores;
    if (Strings.isNullOrEmpty(query)) {
        reviewerScores = defaultReviewersForEmptyQuery();
    } else {
        List<Account.Id> suggestedAccounts = suggestAccounts(suggestReviewers, visibilityControl);
        reviewerScores = defaultRankingForCandidateList(suggestedAccounts, projectControl);
    }
    // can also return non-candidate account ids.
    for (ReviewerSuggestion r : reviewerSuggestionPlugins) {
        // TODO(hiesel) Thread Pool
        for (SuggestedReviewer s : r.suggestReviewers(query, reviewerScores.keySet())) {
            if (reviewerScores.containsKey(s.account)) {
                reviewerScores.put(s.account, reviewerScores.get(s.account) + s.score);
            } else {
                reviewerScores.put(s.account, s.score);
            }
        }
    }
    // Remove change owner
    reviewerScores.remove(changeNotes.getChange().getOwner());
    // Sort results
    List<Account.Id> sortedSuggestions = reviewerScores.entrySet().stream().sorted(Map.Entry.comparingByValue()).map(e -> e.getKey()).collect(Collectors.toList());
    Collections.reverse(sortedSuggestions);
    // Populate AccountInfo
    List<SuggestedReviewerInfo> reviewer = new ArrayList<>();
    for (Account.Id id : sortedSuggestions) {
        SuggestedReviewerInfo info = new SuggestedReviewerInfo();
        info.account = accountLoader.get(id);
        info.count = 1;
        reviewer.add(info);
    }
    accountLoader.fill();
    for (GroupReference g : suggestAccountGroup(suggestReviewers, projectControl)) {
        GroupAsReviewer result = suggestGroupAsReviewer(suggestReviewers, projectControl.getProject(), g, visibilityControl);
        if (result.allowed || result.allowedWithConfirmation) {
            GroupBaseInfo info = new GroupBaseInfo();
            info.id = Url.encode(g.getUUID().get());
            info.name = g.getName();
            SuggestedReviewerInfo suggestedReviewerInfo = new SuggestedReviewerInfo();
            suggestedReviewerInfo.group = info;
            suggestedReviewerInfo.count = result.size;
            if (result.allowedWithConfirmation) {
                suggestedReviewerInfo.confirm = true;
            }
            reviewer.add(suggestedReviewerInfo);
        }
    }
    if (reviewer.size() <= limit) {
        return reviewer;
    }
    return reviewer.subList(0, limit);
}
#method_after
public List<SuggestedReviewerInfo> suggestReviewers(ChangeNotes changeNotes, SuggestReviewers suggestReviewers, ProjectControl projectControl, VisibilityControl visibilityControl, boolean excludeGroups) throws IOException, OrmException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit();
    if (!suggestReviewers.getSuggestAccounts()) {
        return Collections.emptyList();
    }
    List<Account.Id> candidateList = new ArrayList<>();
    if (!Strings.isNullOrEmpty(query)) {
        candidateList = suggestAccounts(suggestReviewers, visibilityControl);
    }
    List<Account.Id> sortedRecommendations = reviewerRecommender.suggestReviewers(changeNotes, suggestReviewers, projectControl, candidateList);
    // Populate AccountInfo
    List<SuggestedReviewerInfo> reviewer = new ArrayList<>();
    for (Account.Id id : sortedRecommendations) {
        AccountInfo account = accountLoader.get(id);
        if (account != null) {
            SuggestedReviewerInfo info = new SuggestedReviewerInfo();
            info.account = account;
            info.count = 1;
            reviewer.add(info);
        }
    }
    accountLoader.fill();
    if (!excludeGroups && !Strings.isNullOrEmpty(query)) {
        for (GroupReference g : suggestAccountGroup(suggestReviewers, projectControl)) {
            GroupAsReviewer result = suggestGroupAsReviewer(suggestReviewers, projectControl.getProject(), g, visibilityControl);
            if (result.allowed || result.allowedWithConfirmation) {
                GroupBaseInfo info = new GroupBaseInfo();
                info.id = Url.encode(g.getUUID().get());
                info.name = g.getName();
                SuggestedReviewerInfo suggestedReviewerInfo = new SuggestedReviewerInfo();
                suggestedReviewerInfo.group = info;
                suggestedReviewerInfo.count = result.size;
                if (result.allowedWithConfirmation) {
                    suggestedReviewerInfo.confirm = true;
                }
                // Always add groups at the end as individual accounts are usually
                // more important
                reviewer.add(suggestedReviewerInfo);
            }
        }
    }
    if (reviewer.size() <= limit) {
        return reviewer;
    }
    return reviewer.subList(0, limit);
}
#end_block

#method_before
private List<Account.Id> suggestAccountsFromIndex(SuggestReviewers suggestReviewers) throws OrmException {
    try {
        Set<Account.Id> matches = new HashSet<>();
        QueryResult<AccountState> result = accountQueryProcessor.setLimit(suggestReviewers.getLimit()).query(accountQueryBuilder.defaultQuery(suggestReviewers.getQuery()));
        for (AccountState accountState : result.entities()) {
            Account.Id id = accountState.getAccount().getId();
            matches.add(id);
        }
        return new ArrayList<>(matches);
    } catch (QueryParseException e) {
        return ImmutableList.of();
    }
}
#method_after
private List<Account.Id> suggestAccountsFromIndex(SuggestReviewers suggestReviewers) throws OrmException {
    try {
        Set<Account.Id> matches = new HashSet<>();
        QueryResult<AccountState> result = accountQueryProcessor.setLimit(suggestReviewers.getLimit() * CANDIDATE_LIST_MULTIPLIER).query(accountQueryBuilder.defaultQuery(suggestReviewers.getQuery()));
        for (AccountState accountState : result.entities()) {
            Account.Id id = accountState.getAccount().getId();
            matches.add(id);
        }
        return new ArrayList<>(matches);
    } catch (QueryParseException e) {
        return ImmutableList.of();
    }
}
#end_block

#method_before
private List<Account.Id> suggestAccountsFromDb(SuggestReviewers suggestReviewers, VisibilityControl visibilityControl) throws OrmException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit();
    String a = query;
    String b = a + MAX_SUFFIX;
    Set<Account.Id> r = new HashSet<>();
    for (Account p : dbProvider.get().accounts().suggestByFullName(a, b, limit)) {
        if (p.isActive()) {
            addSuggestion(r, p.getId(), visibilityControl);
        }
    }
    if (r.size() < limit) {
        for (Account p : dbProvider.get().accounts().suggestByPreferredEmail(a, b, limit - r.size())) {
            if (p.isActive()) {
                addSuggestion(r, p.getId(), visibilityControl);
            }
        }
    }
    if (r.size() < limit) {
        for (AccountExternalId e : dbProvider.get().accountExternalIds().suggestByEmailAddress(a, b, limit - r.size())) {
            if (!r.contains(e.getAccountId())) {
                Account p = accountCache.get(e.getAccountId()).getAccount();
                if (p.isActive()) {
                    addSuggestion(r, p.getId(), visibilityControl);
                }
            }
        }
    }
    accountLoader.fill();
    return new ArrayList<>(r);
}
#method_after
private List<Account.Id> suggestAccountsFromDb(SuggestReviewers suggestReviewers, VisibilityControl visibilityControl) throws OrmException {
    String query = suggestReviewers.getQuery();
    int limit = suggestReviewers.getLimit() * CANDIDATE_LIST_MULTIPLIER;
    String a = query;
    String b = a + MAX_SUFFIX;
    Set<Account.Id> r = new HashSet<>();
    for (Account p : dbProvider.get().accounts().suggestByFullName(a, b, limit)) {
        if (p.isActive()) {
            addSuggestion(r, p.getId(), visibilityControl);
        }
    }
    if (r.size() < limit) {
        for (Account p : dbProvider.get().accounts().suggestByPreferredEmail(a, b, limit - r.size())) {
            if (p.isActive()) {
                addSuggestion(r, p.getId(), visibilityControl);
            }
        }
    }
    if (r.size() < limit) {
        for (AccountExternalId e : dbProvider.get().accountExternalIds().suggestByEmailAddress(a, b, limit - r.size())) {
            if (!r.contains(e.getAccountId())) {
                Account p = accountCache.get(e.getAccountId()).getAccount();
                if (p.isActive()) {
                    addSuggestion(r, p.getId(), visibilityControl);
                }
            }
        }
    }
    return new ArrayList<>(r);
}
#end_block

#method_before
public void suggestReviewersFullTextSearch() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(changeId, "first", 20);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "first1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "last", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "last1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "fi la", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "la fi", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "first1 la", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "fi last1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "first1 last2", 1);
    assertThat(reviewers).hasSize(0);
    reviewers = suggestReviewers(changeId, name("user"), 7);
    assertThat(reviewers).hasSize(6);
    reviewers = suggestReviewers(changeId, user1.username, 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "example.com", 7);
    assertThat(reviewers).hasSize(6);
    reviewers = suggestReviewers(changeId, user1.email, 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, user1.username + " example", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, user4.email.toLowerCase(), 2);
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.get(0).account.email).isEqualTo(user4.email);
}
#method_after
@Test
public void suggestReviewersFullTextSearch() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(changeId, "first", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "first1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "last", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "last1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "fi la", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "la fi", 4);
    assertThat(reviewers).hasSize(3);
    reviewers = suggestReviewers(changeId, "first1 la", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "fi last1", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "first1 last2", 1);
    assertThat(reviewers).hasSize(0);
    reviewers = suggestReviewers(changeId, name("user"), 7);
    assertThat(reviewers).hasSize(6);
    reviewers = suggestReviewers(changeId, user1.username, 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, "example.com", 7);
    assertThat(reviewers).hasSize(5);
    reviewers = suggestReviewers(changeId, user1.email, 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, user1.username + " example", 2);
    assertThat(reviewers).hasSize(1);
    reviewers = suggestReviewers(changeId, user4.email.toLowerCase(), 2);
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.get(0).account.email).isEqualTo(user4.email);
}
#end_block

#method_before
@Test
public void defaultReviewerSuggestion() throws Exception {
    String prefix = "defaultReviewerSuggestion-";
    TestAccount user1 = accounts.create(prefix + "user1", prefix + "user1@example.com", "User1", null);
    TestAccount reviewer1 = accounts.create(prefix + "user2", prefix + "user2@example.com", "User2", null);
    TestAccount reviewer2 = accounts.create(prefix + "user3", prefix + "user3@example.com", "User3", null);
    setApiUser(user1);
    String changeId1 = createChangeFromAPI();
    addReviewer(changeId1, reviewer1.email);
    String changeId2 = createChangeFromAPI();
    addReviewer(changeId2, reviewer1.email);
    addReviewer(changeId2, reviewer2.email);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChangeFromAPI(), "", 4);
    assertThat(reviewers.stream().map(r -> r.account._accountId).collect(Collectors.toList())).containsExactly(reviewer1.id.get(), reviewer2.id.get()).inOrder();
}
#method_after
@Test
public void defaultReviewerSuggestion() throws Exception {
    TestAccount user1 = user("customuser1", "User1");
    TestAccount reviewer1 = user("customuser2", "User2");
    TestAccount reviewer2 = user("customuser3", "User3");
    setApiUser(user1);
    String changeId1 = createChangeFromApi();
    setApiUser(reviewer1);
    reviewChange(changeId1);
    setApiUser(user1);
    String changeId2 = createChangeFromApi();
    setApiUser(reviewer1);
    reviewChange(changeId2);
    setApiUser(reviewer2);
    reviewChange(changeId2);
    setApiUser(user1);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChangeFromApi(), null, 4);
    assertThat(reviewers.stream().map(r -> r.account._accountId).collect(Collectors.toList())).containsExactly(reviewer1.id.get(), reviewer2.id.get()).inOrder();
}
#end_block

#method_before
@Test
public void defaultReviewerSuggestionOnFirstChange() throws Exception {
    String prefix = "defaultReviewerSuggestionOnFChange-";
    TestAccount user1 = accounts.create(prefix + "user1", prefix + "user1@example.com", "User1", null);
    setApiUser(user1);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChange().getChangeId(), "", 4);
    assertThat(reviewers).isEmpty();
}
#method_after
@Test
public void defaultReviewerSuggestionOnFirstChange() throws Exception {
    TestAccount user1 = user("customuser1", "User1");
    setApiUser(user1);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChange().getChangeId(), "", 4);
    assertThat(reviewers).isEmpty();
}
#end_block

#method_before
@Test
@GerritConfig(name = "suggest.maxSuggestedReviewers", value = "10")
public void reviewerRanking() throws Exception {
    // Assert that user are ranked by the number of times they have reviewed a
    // change (highest), added comments (medium) or owned a change (low).
    String prefix = "reviewerRanking-";
    TestAccount userWhoOwns = accounts.create(prefix + "user1", prefix + "user1@example.com", "Primum1 Finalis1", null);
    TestAccount reviewer1 = accounts.create(prefix + "user2", prefix + "user2@example.com", "Primum2 Finalis2", null);
    TestAccount reviewer2 = accounts.create(prefix + "user3", prefix + "user3@example.com", "Primum3 Finalis3", null);
    TestAccount userWhoComments = accounts.create(prefix + "user4", prefix + "user4@example.com", "Primum4 Finalis4", null);
    TestAccount userWhoLooksForSuggestions = accounts.create(prefix + "user5", prefix + "user5@example.com", "Primum5 Finalis5", null);
    // Create a changee as userWhoOwns and add some reviewers
    setApiUser(userWhoOwns);
    String changeId1 = createChangeFromAPI();
    addReviewer(changeId1, reviewer1.email);
    setApiUser(user1);
    String changeId2 = createChangeFromAPI();
    addReviewer(changeId2, reviewer1.email);
    addReviewer(changeId2, reviewer2.email);
    // Create a comment as a different user
    setApiUser(userWhoComments);
    ReviewInput ri = new ReviewInput();
    ri.message = "Test";
    gApi.changes().id(changeId1).revision(1).review(ri);
    // Create a change as a new user to assert that we receive the correct
    // ranking
    setApiUser(userWhoLooksForSuggestions);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChangeFromAPI(), "Primum", 4);
    assertThat(reviewers.stream().map(r -> r.account._accountId).collect(Collectors.toList())).containsExactly(reviewer1.id.get(), reviewer2.id.get(), userWhoOwns.id.get(), userWhoComments.id.get()).inOrder();
}
#method_after
@Test
@GerritConfig(name = "suggest.maxSuggestedReviewers", value = "10")
public void reviewerRanking() throws Exception {
    // Assert that user are ranked by the number of times they have applied a
    // a label to a change (highest), added comments (medium) or owned a
    // change (low).
    String fullName = "Primum Finalis";
    TestAccount userWhoOwns = user("customuser1", fullName);
    TestAccount reviewer1 = user("customuser2", fullName);
    TestAccount reviewer2 = user("customuser3", fullName);
    TestAccount userWhoComments = user("customuser4", fullName);
    TestAccount userWhoLooksForSuggestions = user("customuser5", fullName);
    // Create a change as userWhoOwns and add some reviews
    setApiUser(userWhoOwns);
    String changeId1 = createChangeFromApi();
    setApiUser(reviewer1);
    reviewChange(changeId1);
    setApiUser(user1);
    String changeId2 = createChangeFromApi();
    setApiUser(reviewer1);
    reviewChange(changeId2);
    setApiUser(reviewer2);
    reviewChange(changeId2);
    // Create a comment as a different user
    setApiUser(userWhoComments);
    ReviewInput ri = new ReviewInput();
    ri.message = "Test";
    gApi.changes().id(changeId1).revision(1).review(ri);
    // Create a change as a new user to assert that we receive the correct
    // ranking
    setApiUser(userWhoLooksForSuggestions);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChangeFromApi(), "Pri", 4);
    assertThat(reviewers.stream().map(r -> r.account._accountId).collect(Collectors.toList())).containsExactly(reviewer1.id.get(), reviewer2.id.get(), userWhoOwns.id.get(), userWhoComments.id.get()).inOrder();
}
#end_block

#method_before
@Test
public void reviewerRankingProjectIsolation() throws Exception {
    // Create new project
    Project.NameKey newProject = createProject("test");
    // Create users who review changes in both the default and the new project
    String prefix = "reviewerRankingProjectIsolation-";
    TestAccount user1 = accounts.create(prefix + "user1", prefix + "user1@example.com", "Primum1 Finalis1", null);
    TestAccount reviewer1 = accounts.create(prefix + "user2", prefix + "user2@example.com", "Primum2 Finalis2", null);
    TestAccount reviewer2 = accounts.create(prefix + "user3", prefix + "user3@example.com", "Primum3 Finalis3", null);
    setApiUser(user1);
    String changeId1 = createChangeFromAPI();
    addReviewer(changeId1, reviewer1.email);
    String changeId2 = createChangeFromAPI(newProject);
    addReviewer(changeId2, reviewer2.email);
    String changeId3 = createChangeFromAPI(newProject);
    addReviewer(changeId3, reviewer2.email);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChangeFromAPI(), "Prim", 4);
    // Assert that reviewer1 is on top, even though reviewer2 has more reviews
    // in other projects
    assertThat(reviewers.stream().map(r -> r.account._accountId).collect(Collectors.toList())).containsExactly(reviewer1.id.get(), reviewer2.id.get()).inOrder();
}
#method_after
@Test
public void reviewerRankingProjectIsolation() throws Exception {
    // Create new project
    Project.NameKey newProject = createProject("test");
    // Create users who review changes in both the default and the new project
    String fullName = "Primum Finalis";
    TestAccount userWhoOwns = user("customuser1", fullName);
    TestAccount reviewer1 = user("customuser2", fullName);
    TestAccount reviewer2 = user("customuser3", fullName);
    setApiUser(userWhoOwns);
    String changeId1 = createChangeFromApi();
    setApiUser(reviewer1);
    reviewChange(changeId1);
    setApiUser(userWhoOwns);
    String changeId2 = createChangeFromApi(newProject);
    setApiUser(reviewer2);
    reviewChange(changeId2);
    setApiUser(userWhoOwns);
    String changeId3 = createChangeFromApi(newProject);
    setApiUser(reviewer2);
    reviewChange(changeId3);
    setApiUser(userWhoOwns);
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(createChangeFromApi(), "Prim", 4);
    // Assert that reviewer1 is on top, even though reviewer2 has more reviews
    // in other projects
    assertThat(reviewers.stream().map(r -> r.account._accountId).collect(Collectors.toList())).containsExactly(reviewer1.id.get(), reviewer2.id.get()).inOrder();
}
#end_block

#method_before
private TestAccount user(String name, String fullName, String emailName, AccountGroup... groups) throws Exception {
    String[] groupNames = FluentIterable.from(Arrays.asList(groups)).transform(new Function<AccountGroup, String>() {

        @Override
        public String apply(AccountGroup in) {
            return in.getName();
        }
    }).toArray(String.class);
    return accounts.create(name(name), name(emailName) + "@example.com", fullName, groupNames);
}
#method_after
private TestAccount user(String name, String fullName, String emailName, AccountGroup... groups) throws Exception {
    String[] groupNames = Arrays.stream(groups).map(AccountGroup::getName).toArray(String[]::new);
    return accounts.create(name(name), name(emailName) + "@example.com", fullName, groupNames);
}
#end_block

#method_before
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(error, false);
    addReviewerIcon.setVisible(false);
    suggestBox.setFocus(true);
}
#method_after
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(error, false);
    addReviewerIcon.setVisible(false);
    suggestBox.setServeSuggestionsOnOracle(true);
    suggestBox.setFocus(true);
}
#end_block

#method_before
@UiHandler("cancel")
void onCancel(@SuppressWarnings("unused") ClickEvent e) {
    addReviewerIcon.setVisible(true);
    UIObject.setVisible(form, false);
    suggestBox.setFocus(false);
    suggestBox.setText("");
}
#method_after
@UiHandler("cancel")
void onCancel(@SuppressWarnings("unused") ClickEvent e) {
    addReviewerIcon.setVisible(true);
    UIObject.setVisible(form, false);
    suggestBox.setFocus(false);
    suggestBox.setText("");
    suggestBox.setServeSuggestionsOnOracle(false);
}
#end_block

#method_before
private void updateReviewerList() {
    ChangeApi.detail(changeId.get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            display(result);
        }
    });
}
#method_after
void updateReviewerList() {
    ChangeApi.detail(changeId.get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            display(result);
        }
    });
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    return reviewersUtil.suggestReviewers(rsrc.getNotes(), this, rsrc.getControl().getProjectControl(), getVisibility(rsrc));
}
#method_after
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    return reviewersUtil.suggestReviewers(rsrc.getNotes(), this, rsrc.getControl().getProjectControl(), getVisibility(rsrc), excludeGroups);
}
#end_block

#method_before
@Override
public final void requestSuggestions(final Request request, final Callback cb) {
    onRequestSuggestions(request, new Callback() {

        @Override
        public void onSuggestionsReady(final Request request, final Response response) {
            final String qpat = getQueryPattern(request.getQuery());
            final boolean html = isHTML();
            final ArrayList<Suggestion> r = new ArrayList<>();
            for (final Suggestion s : response.getSuggestions()) {
                r.add(new BoldSuggestion(qpat, s, html));
            }
            cb.onSuggestionsReady(request, new Response(r));
        }
    });
}
#method_after
@Override
public final void requestSuggestions(Request request, Callback cb) {
    onRequestSuggestions(request, new Callback() {

        @Override
        public void onSuggestionsReady(final Request request, final Response response) {
            final String qpat = getQueryPattern(request.getQuery());
            final boolean html = isHTML();
            final ArrayList<Suggestion> r = new ArrayList<>();
            for (final Suggestion s : response.getSuggestions()) {
                r.add(new BoldSuggestion(qpat, s, html));
            }
            cb.onSuggestionsReady(request, new Response(r));
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCache.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    factory(SubmoduleOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
public void logEventListenerError(Object event, Object listener, Exception error) {
    if (log.isDebugEnabled()) {
        log.debug(String.format("Error in event listener %s", listener.getClass().getName()), error);
    } else {
        log.warn("Error in listener {} for event {}: {}", listener.getClass().getName(), event.getClass().getName(), error.getMessage());
    }
}
#method_after
public void logEventListenerError(Object event, Object listener, Exception error) {
    if (log.isDebugEnabled()) {
        log.debug(String.format("Error in event listener %s for event %s", listener.getClass().getName(), event.getClass().getName()), error);
    } else {
        log.warn("Error in listener {} for event {}: {}", listener.getClass().getName(), event.getClass().getName(), error.getMessage());
    }
}
#end_block

#method_before
private void appendComment(StringBuilder out, int contextLines, PatchFile currentFileData, Comment comment) {
    if (comment instanceof RobotComment) {
        RobotComment robotComment = (RobotComment) comment;
        out.append("Robot Comment from ").append(robotComment.robotId).append(" (run ID ").append(robotComment.robotRunId).append("):\n");
    }
    short side = comment.side;
    Comment.Range range = comment.range;
    if (range != null) {
        String prefix = "PS" + comment.key.patchSetId + ", Line " + range.startLine + ": ";
        for (int n = range.startLine; n <= range.endLine; n++) {
            out.append(n == range.startLine ? prefix : Strings.padStart(": ", prefix.length(), ' '));
            String s = getLine(currentFileData, side, n);
            if (n == range.startLine && n == range.endLine) {
                s = s.substring(Math.min(range.startChar, s.length()), Math.min(range.endChar, s.length()));
            } else if (n == range.startLine) {
                s = s.substring(Math.min(range.startChar, s.length()));
            } else if (n == range.endLine) {
                s = s.substring(0, Math.min(range.endChar, s.length()));
            }
            out.append(s).append('\n');
        }
        appendQuotedParent(out, comment);
        out.append(comment.message.trim()).append('\n');
    } else {
        int lineNbr = comment.lineNbr;
        // Initialize maxLines to the known line number.
        int maxLines = lineNbr;
        if (side == 1 || side == 2) {
            try {
                maxLines = currentFileData.getLineCount(side);
            } catch (IOException exc) {
            // The file could not be read, leave the max as is.
            } catch (NoSuchEntityException exc) {
                // Should never be reached.
                throw new AssertionError(exc);
            }
        }
        final int startLine = Math.max(1, lineNbr - contextLines + 1);
        final int stopLine = Math.min(maxLines, lineNbr + contextLines);
        for (int line = startLine; line <= lineNbr; ++line) {
            appendFileLine(out, currentFileData, side, line);
        }
        appendQuotedParent(out, comment);
        out.append(comment.message.trim()).append('\n');
        for (int line = lineNbr + 1; line < stopLine; ++line) {
            appendFileLine(out, currentFileData, side, line);
        }
    }
}
#method_after
private void appendComment(StringBuilder out, int contextLines, PatchFile currentFileData, Comment comment) {
    if (comment instanceof RobotComment) {
        RobotComment robotComment = (RobotComment) comment;
        out.append("Robot Comment from ").append(robotComment.robotId).append(" (run ID ").append(robotComment.robotRunId).append("):\n");
    }
    short side = comment.side;
    Comment.Range range = comment.range;
    if (range != null) {
        String prefix = "PS" + comment.key.patchSetId + ", Line " + range.startLine + ": ";
        for (int n = range.startLine; n <= range.endLine; n++) {
            out.append(n == range.startLine ? prefix : Strings.padStart(": ", prefix.length(), ' '));
            String s = getLine(currentFileData, side, n);
            if (n == range.startLine && n == range.endLine) {
                s = s.substring(Math.min(range.startChar, s.length()), Math.min(range.endChar, s.length()));
            } else if (n == range.startLine) {
                s = s.substring(Math.min(range.startChar, s.length()));
            } else if (n == range.endLine) {
                s = s.substring(0, Math.min(range.endChar, s.length()));
            }
            out.append(s).append('\n');
        }
        appendQuotedParent(out, comment);
        out.append(comment.message.trim()).append('\n');
    } else {
        int lineNbr = comment.lineNbr;
        // Initialize maxLines to the known line number.
        int maxLines = lineNbr;
        try {
            maxLines = currentFileData.getLineCount(side);
        } catch (IOException err) {
            // The file could not be read, leave the max as is.
            log.warn(String.format("Failed to read file %s on side %d", comment.key.filename, side), err);
        } catch (NoSuchEntityException err) {
            // The file could not be read, leave the max as is.
            log.warn(String.format("Side %d of file %s didn't exist", side, comment.key.filename), err);
        }
        final int startLine = Math.max(1, lineNbr - contextLines + 1);
        final int stopLine = Math.min(maxLines, lineNbr + contextLines);
        for (int line = startLine; line <= lineNbr; ++line) {
            appendFileLine(out, currentFileData, side, line);
        }
        appendQuotedParent(out, comment);
        out.append(comment.message.trim()).append('\n');
        for (int line = lineNbr + 1; line < stopLine; ++line) {
            appendFileLine(out, currentFileData, side, line);
        }
    }
}
#end_block

#method_before
private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) {
    String lineStr = getLine(fileData, side, line);
    cmts.append("Line " + line + ": " + lineStr + "\n");
}
#method_after
private void appendFileLine(StringBuilder cmts, PatchFile fileData, short side, int line) {
    String lineStr = getLine(fileData, side, line);
    cmts.append("Line ").append(line).append(": ").append(lineStr).append("\n");
}
#end_block

#method_before
private String getLine(PatchFile fileInfo, short side, int lineNbr) {
    if (side != 0 && side != 1) {
        throw new IllegalArgumentException("side should be 0 or 1, was " + side);
    }
    try {
        return fileInfo.getLine(side, lineNbr);
    } catch (IOException exc) {
        // Default to the empty string if the file cannot be safely read.
        return "";
    } catch (IndexOutOfBoundsException exc) {
        // in the file.
        return "";
    } catch (NoSuchEntityException exc) {
        // Should never be reached.
        throw new AssertionError(exc);
    }
}
#method_after
private String getLine(PatchFile fileInfo, short side, int lineNbr) {
    try {
        return fileInfo.getLine(side, lineNbr);
    } catch (IOException err) {
        // Default to the empty string if the file cannot be safely read.
        log.warn(String.format("Failed to read file on side %d", side), err);
        return "";
    } catch (IndexOutOfBoundsException err) {
        // Default to the empty string if the given line number does not appear
        // in the file.
        log.warn(String.format("Failed to get line number of file on side %d", side), err);
        return "";
    } catch (NoSuchEntityException err) {
        // Default to the empty string if the side cannot be found.
        log.warn(String.format("Side %d of file didn't exist", side), err);
        return "";
    }
}
#end_block

#method_before
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
        checkState(input.drafts == DraftHandling.KEEP);
    }
    if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        // updated set of reviewers.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, reviewerResults));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
    }
    return Response.ok(output);
}
#method_after
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        // updated set of reviewers.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, reviewerResults));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
    }
    return Response.ok(output);
}
#end_block

#method_before
private RevisionResource onBehalfOf(RevisionResource rev, ReviewInput in) throws BadRequestException, AuthException, UnprocessableEntityException, OrmException {
    if (in.labels == null || in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    if (in.drafts == null) {
        in.drafts = DraftHandling.KEEP;
    }
    if (in.drafts != DraftHandling.KEEP || !isEmpty(in.comments) || !isEmpty(in.robotComments)) {
        // well for simplicity and consistency.
        throw new AuthException("not allowed to modify other user's comments");
    }
    ChangeControl caller = rev.getControl();
    Iterator<Map.Entry<String, Short>> itr = in.labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType type = caller.getLabelTypes().byLabel(ent.getKey());
        if (type == null && in.strictLabels) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        } else if (type == null) {
            itr.remove();
            continue;
        }
        PermissionRange r = caller.getRange(Permission.forLabelAs(type.getName()));
        if (r == null || r.isEmpty() || !r.contains(ent.getValue())) {
            throw new AuthException(String.format("not permitted to modify label \"%s\" on behalf of \"%s\"", ent.getKey(), in.onBehalfOf));
        }
    }
    if (in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    ChangeControl target = caller.forUser(accounts.parseOnBehalfOf(caller.getUser(), in.onBehalfOf));
    if (!target.getRefControl().isVisible()) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see destination ref", target.getUser().getAccountId()));
    }
    return new RevisionResource(changes.parse(target), rev.getPatchSet());
}
#method_after
private RevisionResource onBehalfOf(RevisionResource rev, ReviewInput in) throws BadRequestException, AuthException, UnprocessableEntityException, OrmException {
    if (in.labels == null || in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    if (in.drafts == null) {
        in.drafts = DraftHandling.KEEP;
    }
    if (in.drafts != DraftHandling.KEEP) {
        throw new AuthException("not allowed to modify other user's drafts");
    }
    ChangeControl caller = rev.getControl();
    Iterator<Map.Entry<String, Short>> itr = in.labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType type = caller.getLabelTypes().byLabel(ent.getKey());
        if (type == null && in.strictLabels) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        } else if (type == null) {
            itr.remove();
            continue;
        }
        PermissionRange r = caller.getRange(Permission.forLabelAs(type.getName()));
        if (r == null || r.isEmpty() || !r.contains(ent.getValue())) {
            throw new AuthException(String.format("not permitted to modify label \"%s\" on behalf of \"%s\"", ent.getKey(), in.onBehalfOf));
        }
    }
    if (in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    ChangeControl target = caller.forUser(accounts.parseOnBehalfOf(caller.getUser(), in.onBehalfOf));
    if (!target.getRefControl().isVisible()) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see destination ref", target.getUser().getAccountId()));
    }
    return new RevisionResource(changes.parse(target), rev.getPatchSet());
}
#end_block

#method_before
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, Comment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<Comment> toDel = new ArrayList<>();
    List<Comment> toPublish = new ArrayList<>();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            Comment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new Comment(new Comment.Key(ChangeUtil.messageUUID(ctx.getDb()), path, psId.get()), user.getAccountId(), ctx.getWhen(), c.side(), c.message, serverId);
            } else {
                e.writtenOn = ctx.getWhen();
                e.side = c.side();
                e.message = c.message;
            }
            if (parent != null) {
                e.parentUuid = parent;
            }
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setLineNbrAndRange(c.line, c.range);
            e.tag = in.tag;
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toPublish.add(e);
        }
    }
    switch(in.drafts) {
        case KEEP:
        default:
            break;
        case DELETE:
            toDel.addAll(drafts.values());
            break;
        case PUBLISH:
            for (Comment e : drafts.values()) {
                toPublish.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, toPublish);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    commentsUtil.deleteComments(ctx.getDb(), u, toDel);
    commentsUtil.putComments(ctx.getDb(), u, Status.PUBLISHED, toPublish);
    comments.addAll(toPublish);
    return !toDel.isEmpty() || !toPublish.isEmpty();
}
#method_after
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, Comment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<Comment> toDel = new ArrayList<>();
    List<Comment> toPublish = new ArrayList<>();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            Comment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = commentsUtil.newComment(ctx, path, psId, c.side(), c.message);
            } else {
                e.writtenOn = ctx.getWhen();
                e.side = c.side();
                e.message = c.message;
            }
            if (parent != null) {
                e.parentUuid = parent;
            }
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setLineNbrAndRange(c.line, c.range);
            e.tag = in.tag;
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toPublish.add(e);
        }
    }
    switch(in.drafts) {
        case KEEP:
        default:
            break;
        case DELETE:
            toDel.addAll(drafts.values());
            break;
        case PUBLISH:
            for (Comment e : drafts.values()) {
                toPublish.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, toPublish);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    commentsUtil.deleteComments(ctx.getDb(), u, toDel);
    commentsUtil.putComments(ctx.getDb(), u, Status.PUBLISHED, toPublish);
    comments.addAll(toPublish);
    return !toDel.isEmpty() || !toPublish.isEmpty();
}
#end_block

#method_before
private boolean insertRobotComments(ChangeContext ctx) throws OrmException {
    if (in.robotComments == null) {
        return false;
    }
    List<RobotComment> toAdd = new ArrayList<>(in.robotComments.size());
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingRobotComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<RobotCommentInput>> ent : in.robotComments.entrySet()) {
        String path = ent.getKey();
        for (RobotCommentInput c : ent.getValue()) {
            RobotComment e = new RobotComment(new Comment.Key(ChangeUtil.messageUUID(ctx.getDb()), path, psId.get()), user.getAccountId(), ctx.getWhen(), c.side(), c.message, serverId, c.robotId, c.robotRunId);
            e.parentUuid = Url.decode(c.inReplyTo);
            e.url = c.url;
            e.setLineNbrAndRange(c.line, c.range);
            e.tag = in.tag;
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toAdd.add(e);
        }
    }
    commentsUtil.putRobotComments(ctx.getUpdate(psId), toAdd);
    comments.addAll(toAdd);
    return !toAdd.isEmpty();
}
#method_after
private boolean insertRobotComments(ChangeContext ctx) throws OrmException {
    if (in.robotComments == null) {
        return false;
    }
    List<RobotComment> toAdd = new ArrayList<>(in.robotComments.size());
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingRobotComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<RobotCommentInput>> ent : in.robotComments.entrySet()) {
        String path = ent.getKey();
        for (RobotCommentInput c : ent.getValue()) {
            RobotComment e = commentsUtil.newRobotComment(ctx, path, psId, c.side(), c.message, c.robotId, c.robotRunId);
            e.parentUuid = Url.decode(c.inReplyTo);
            e.url = c.url;
            e.properties = c.properties;
            e.setLineNbrAndRange(c.line, c.range);
            e.tag = in.tag;
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toAdd.add(e);
        }
    }
    commentsUtil.putRobotComments(ctx.getUpdate(psId), toAdd);
    comments.addAll(toAdd);
    return !toAdd.isEmpty();
}
#end_block

#method_before
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = new ArrayList<>();
    List<PatchSetApproval> ups = new ArrayList<>();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> allApprovals = getAllApprovals(labelTypes, approvalsByKey(current.values()), inLabels);
    Map<String, Short> previous = getPreviousApprovals(allApprovals, approvalsByKey(current.values()));
    ChangeUpdate update = ctx.getUpdate(psId);
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    if ((!del.isEmpty() || !ups.isEmpty()) && ctx.getChange().getStatus().isClosed()) {
        throw new ResourceConflictException("change is closed");
    }
    // This allows us to preserve their CC status.
    if (current.isEmpty() && del.isEmpty() && ups.isEmpty() && !isReviewer(ctx)) {
        return false;
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = new ArrayList<>();
    List<PatchSetApproval> ups = new ArrayList<>();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> allApprovals = getAllApprovals(labelTypes, approvalsByKey(current.values()), inLabels);
    Map<String, Short> previous = getPreviousApprovals(allApprovals, approvalsByKey(current.values()));
    ChangeUpdate update = ctx.getUpdate(psId);
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = ApprovalsUtil.newApproval(psId, user, lt.getLabelId(), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    if ((!del.isEmpty() || !ups.isEmpty()) && ctx.getChange().getStatus().isClosed()) {
        throw new ResourceConflictException("change is closed");
    }
    // This allows us to preserve their CC status.
    if (current.isEmpty() && del.isEmpty() && ups.isEmpty() && !isReviewer(ctx)) {
        return false;
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
    ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), REVIEWER);
}
#method_after
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            LabelId labelId = ctx.getControl().getLabelTypes().getLabelTypes().get(0).getLabelId();
            PatchSetApproval c = ApprovalsUtil.newApproval(psId, user, labelId, 0, ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
    ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), REVIEWER);
}
#end_block

#method_before
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId);
    message.setTag(in.tag);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#method_after
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = ChangeMessagesUtil.newMessage(ctx.getDb(), psId, user, ctx.getWhen(), "Patch Set " + psId.get() + ":" + buf);
    message.setTag(in.tag);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#end_block

#method_before
private IdentifiedUser parseIdOnBehalfOf(@Nullable CurrentUser caller, String id) throws AuthException, OrmException {
    if (id.equals("self")) {
        CurrentUser user = self.get();
        if (user.isIdentifiedUser()) {
            return user.asIdentifiedUser();
        } else if (user instanceof AnonymousUser) {
            throw new AuthException("Authentication required");
        } else {
            return null;
        }
    }
    Account match = resolver.find(db.get(), id);
    if (match == null) {
        return null;
    }
    return userFactory.runAs(null, match.getId(), caller.getRealUser());
}
#method_after
private IdentifiedUser parseIdOnBehalfOf(@Nullable CurrentUser caller, String id) throws AuthException, OrmException {
    if (id.equals("self")) {
        CurrentUser user = self.get();
        if (user.isIdentifiedUser()) {
            return user.asIdentifiedUser();
        } else if (user instanceof AnonymousUser) {
            throw new AuthException("Authentication required");
        } else {
            return null;
        }
    }
    Account match = resolver.find(db.get(), id);
    if (match == null) {
        return null;
    }
    CurrentUser realUser = caller != null ? caller.getRealUser() : null;
    return userFactory.runAs(null, match.getId(), realUser);
}
#end_block

#method_before
@Override
void apply(ChangeUpdate update) throws OrmException {
    checkUpdate(update);
    update.setChangeMessage(message.getMessage());
    setTopic(update);
    setStatus(update);
}
#method_after
@Override
void apply(ChangeUpdate update) throws OrmException {
    checkUpdate(update);
    update.setChangeMessage(message.getMessage());
    setTopic(update);
}
#end_block

#method_before
@Override
protected String getRefName() {
    return RefNames.refsDraftComments(getId(), effectiveAccountId);
}
#method_after
@Override
protected String getRefName() {
    return RefNames.refsDraftComments(getId(), accountId);
}
#end_block

#method_before
private void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException {
    manager.setCheckExpectedState(false);
    Change change = new Change(bundle.getChange());
    if (bundle.getPatchSets().isEmpty()) {
        throw new NoPatchSetsException(change.getId());
    }
    PatchSet.Id currPsId = change.currentPatchSetId();
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = new ArrayList<>();
    Multimap<Account.Id, DraftCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteChangeMetaRef(change, manager.getChangeRepo().cmds);
    deleteDraftRefs(change, manager.getAllUsersRepo());
    Integer minPsNum = getMinPatchSetNum(bundle);
    Map<PatchSet.Id, PatchSetEvent> patchSetEvents = Maps.newHashMapWithExpectedSize(bundle.getPatchSets().size());
    for (PatchSet ps : bundle.getPatchSets()) {
        if (ps.getId().get() > currPsId.get()) {
            log.info("Skipping patch set {}, which is higher than current patch set {}", ps.getId(), currPsId);
            continue;
        }
        PatchSetEvent pse = new PatchSetEvent(change, ps, manager.getChangeRepo().rw);
        patchSetEvents.put(ps.getId(), pse);
        events.add(pse);
        for (Comment c : getComments(bundle, serverId, Status.PUBLISHED, ps)) {
            CommentEvent e = new CommentEvent(c, change, ps, patchListCache);
            events.add(e.addDep(pse));
        }
        for (Comment c : getComments(bundle, serverId, Status.DRAFT, ps)) {
            DraftCommentEvent e = new DraftCommentEvent(c, change, ps, patchListCache);
            draftCommentEvents.put(c.author.getId(), e);
        }
    }
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        PatchSetEvent pse = patchSetEvents.get(psa.getPatchSetId());
        if (pse != null) {
            events.add(new ApprovalEvent(psa, change.getCreatedOn()).addDep(pse));
        }
    }
    for (Table.Cell<ReviewerStateInternal, Account.Id, Timestamp> r : bundle.getReviewers().asTable().cellSet()) {
        events.add(new ReviewerEvent(r, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        if (msg.getPatchSetId() == null) {
            // No dependency necessary; will get assigned to most recent patch set
            // in sortAndFillEvents.
            events.add(new ChangeMessageEvent(msg, noteDbChange, change.getCreatedOn()));
            continue;
        }
        PatchSetEvent pse = patchSetEvents.get(msg.getPatchSetId());
        if (pse != null) {
            events.add(new ChangeMessageEvent(msg, noteDbChange, change.getCreatedOn()).addDep(pse));
        }
    }
    sortAndFillEvents(change, noteDbChange, events, minPsNum);
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<DraftCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (DraftCommentEvent e : Ordering.natural().sortedCopy(draftCommentEvents.get(author))) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#method_after
private void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException {
    manager.setCheckExpectedState(false);
    Change change = new Change(bundle.getChange());
    if (bundle.getPatchSets().isEmpty()) {
        throw new NoPatchSetsException(change.getId());
    }
    PatchSet.Id currPsId = change.currentPatchSetId();
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = new ArrayList<>();
    Multimap<Account.Id, DraftCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteChangeMetaRef(change, manager.getChangeRepo().cmds);
    deleteDraftRefs(change, manager.getAllUsersRepo());
    Integer minPsNum = getMinPatchSetNum(bundle);
    Map<PatchSet.Id, PatchSetEvent> patchSetEvents = Maps.newHashMapWithExpectedSize(bundle.getPatchSets().size());
    for (PatchSet ps : bundle.getPatchSets()) {
        if (ps.getId().get() > currPsId.get()) {
            log.info("Skipping patch set {}, which is higher than current patch set {}", ps.getId(), currPsId);
            continue;
        }
        PatchSetEvent pse = new PatchSetEvent(change, ps, manager.getChangeRepo().rw);
        patchSetEvents.put(ps.getId(), pse);
        events.add(pse);
        for (Comment c : getComments(bundle, serverId, Status.PUBLISHED, ps)) {
            CommentEvent e = new CommentEvent(c, change, ps, patchListCache);
            events.add(e.addDep(pse));
        }
        for (Comment c : getComments(bundle, serverId, Status.DRAFT, ps)) {
            DraftCommentEvent e = new DraftCommentEvent(c, change, ps, patchListCache);
            draftCommentEvents.put(c.author.getId(), e);
        }
    }
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        PatchSetEvent pse = patchSetEvents.get(psa.getPatchSetId());
        if (pse != null) {
            events.add(new ApprovalEvent(psa, change.getCreatedOn()).addDep(pse));
        }
    }
    for (Table.Cell<ReviewerStateInternal, Account.Id, Timestamp> r : bundle.getReviewers().asTable().cellSet()) {
        events.add(new ReviewerEvent(r, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        List<Event> msgEvents = parseChangeMessage(msg, change, noteDbChange);
        if (msg.getPatchSetId() != null) {
            PatchSetEvent pse = patchSetEvents.get(msg.getPatchSetId());
            if (pse != null) {
                for (Event e : msgEvents) {
                    e.addDep(pse);
                }
            }
        }
        events.addAll(msgEvents);
    }
    sortAndFillEvents(change, noteDbChange, events, minPsNum);
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<DraftCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (DraftCommentEvent e : Ordering.natural().sortedCopy(draftCommentEvents.get(author))) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#end_block

#method_before
private void sortAndFillEvents(Change change, Change noteDbChange, List<Event> events, Integer minPsNum) {
    new EventSorter(events).sort();
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    // Ensure the first event in the list creates the change, setting the author
    // and any required footers.
    Event first = events.get(0);
    if (first instanceof PatchSetEvent && change.getOwner().equals(first.effectiveUser)) {
        ((PatchSetEvent) first).createChange = true;
    } else {
        events.add(0, new CreateChangeEvent(change, minPsNum));
    }
    // Final pass to correct some inconsistencies.
    // 
    // First, fill in any missing patch set IDs using the latest patch set of
    // the change at the time of the event, because NoteDb can't represent
    // actions with no associated patch set ID. This workaround is as if a user
    // added a ChangeMessage on the change by replying from the latest patch
    // set.
    // 
    // Start with the first patch set that actually exists. If there are no
    // patch sets at all, minPsNum will be null, so just bail and use 1 as the
    // patch set ID. The corresponding patch set won't exist, but this change is
    // probably corrupt anyway, as deleting the last draft patch set should have
    // deleted the whole change.
    // 
    // Second, ensure timestamps are nondecreasing, by copying the previous
    // timestamp if this happens. This assumes that the only way this can happen
    // is due to dependency constraints, and it is ok to give an event the same
    // timestamp as one of its dependencies.
    int ps = firstNonNull(minPsNum, 1);
    for (int i = 0; i < events.size(); i++) {
        Event e = events.get(i);
        if (e.psId == null) {
            e.psId = new PatchSet.Id(change.getId(), ps);
        } else {
            ps = Math.max(ps, e.psId.get());
        }
        if (i > 0) {
            Event p = events.get(i - 1);
            if (e.when.before(p.when)) {
                e.when = p.when;
            }
        }
    }
}
#method_after
private void sortAndFillEvents(Change change, Change noteDbChange, List<Event> events, Integer minPsNum) {
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    new EventSorter(events).sort();
    // Ensure the first event in the list creates the change, setting the author
    // and any required footers.
    Event first = events.get(0);
    if (first instanceof PatchSetEvent && change.getOwner().equals(first.user)) {
        ((PatchSetEvent) first).createChange = true;
    } else {
        events.add(0, new CreateChangeEvent(change, minPsNum));
    }
    // Final pass to correct some inconsistencies.
    // 
    // First, fill in any missing patch set IDs using the latest patch set of
    // the change at the time of the event, because NoteDb can't represent
    // actions with no associated patch set ID. This workaround is as if a user
    // added a ChangeMessage on the change by replying from the latest patch
    // set.
    // 
    // Start with the first patch set that actually exists. If there are no
    // patch sets at all, minPsNum will be null, so just bail and use 1 as the
    // patch set ID. The corresponding patch set won't exist, but this change is
    // probably corrupt anyway, as deleting the last draft patch set should have
    // deleted the whole change.
    // 
    // Second, ensure timestamps are nondecreasing, by copying the previous
    // timestamp if this happens. This assumes that the only way this can happen
    // is due to dependency constraints, and it is ok to give an event the same
    // timestamp as one of its dependencies.
    int ps = firstNonNull(minPsNum, 1);
    for (int i = 0; i < events.size(); i++) {
        Event e = events.get(i);
        if (e.psId == null) {
            e.psId = new PatchSet.Id(change.getId(), ps);
        } else {
            ps = Math.max(ps, e.psId.get());
        }
        if (i > 0) {
            Event p = events.get(i - 1);
            if (e.when.before(p.when)) {
                e.when = p.when;
            }
        }
    }
}
#end_block

#method_before
private void flushEventsToUpdate(NoteDbUpdateManager manager, EventList<Event> events, Change change) throws OrmException, IOException {
    if (events.isEmpty()) {
        return;
    }
    Comparator<String> labelNameComparator;
    if (projectCache != null) {
        labelNameComparator = projectCache.get(change.getProject()).getLabelTypes().nameComparator();
    } else {
        // No project cache available, bail and use natural ordering; there's no
        // semantic difference anyway difference.
        labelNameComparator = Ordering.natural();
    }
    ChangeUpdate update = updateFactory.create(change, events.getAccountId(), newAuthorIdent(events), events.getWhen(), labelNameComparator);
    update.setAllowWriteToNewRef(true);
    update.setPatchSetId(events.getPatchSetId());
    update.setTag(events.getTag());
    for (Event e : events) {
        e.apply(update);
    }
    manager.add(update);
    events.clear();
}
#method_after
private void flushEventsToUpdate(NoteDbUpdateManager manager, EventList<Event> events, Change change) throws OrmException, IOException {
    if (events.isEmpty()) {
        return;
    }
    Comparator<String> labelNameComparator;
    if (projectCache != null) {
        labelNameComparator = projectCache.get(change.getProject()).getLabelTypes().nameComparator();
    } else {
        // No project cache available, bail and use natural ordering; there's no
        // semantic difference anyway difference.
        labelNameComparator = Ordering.natural();
    }
    ChangeUpdate update = updateFactory.create(change, events.getAccountId(), events.getRealAccountId(), newAuthorIdent(events), events.getWhen(), labelNameComparator);
    update.setAllowWriteToNewRef(true);
    update.setPatchSetId(events.getPatchSetId());
    update.setTag(events.getTag());
    for (Event e : events) {
        e.apply(update);
    }
    manager.add(update);
    events.clear();
}
#end_block

#method_before
private void flushEventsToDraftUpdate(NoteDbUpdateManager manager, EventList<DraftCommentEvent> events, Change change) throws OrmException {
    if (events.isEmpty()) {
        return;
    }
    ChangeDraftUpdate update = draftUpdateFactory.create(change, events.getAccountId(), newAuthorIdent(events), events.getWhen());
    update.setPatchSetId(events.getPatchSetId());
    for (DraftCommentEvent e : events) {
        e.applyDraft(update);
    }
    manager.add(update);
    events.clear();
}
#method_after
private void flushEventsToDraftUpdate(NoteDbUpdateManager manager, EventList<DraftCommentEvent> events, Change change) throws OrmException {
    if (events.isEmpty()) {
        return;
    }
    ChangeDraftUpdate update = draftUpdateFactory.create(change, events.getAccountId(), events.getRealAccountId(), newAuthorIdent(events), events.getWhen());
    update.setPatchSetId(events.getPatchSetId());
    for (DraftCommentEvent e : events) {
        e.applyDraft(update);
    }
    manager.add(update);
    events.clear();
}
#end_block

#method_before
public static ChangeMessage newMessage(ReviewDb db, PatchSet.Id psId, CurrentUser user, Timestamp when, String body) throws OrmException {
    checkNotNull(psId);
    Account.Id accountId = user.isInternalUser() ? null : user.getAccountId();
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(db)), accountId, when, psId);
    m.setMessage(body);
    if (user.getRealUser().isIdentifiedUser()) {
        m.setRealAuthor(user.getRealUser().getAccountId());
    }
    return m;
}
#method_after
public static ChangeMessage newMessage(ReviewDb db, PatchSet.Id psId, CurrentUser user, Timestamp when, String body) throws OrmException {
    checkNotNull(psId);
    Account.Id accountId = user.isInternalUser() ? null : user.getAccountId();
    ChangeMessage m = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(db)), accountId, when, psId);
    m.setMessage(body);
    user.updateRealAccountId(m::setRealAuthor);
    return m;
}
#end_block

#method_before
public void putApproval(String label, short value) {
    putApprovalFor(getEffectiveAccountId(), label, value);
}
#method_after
public void putApproval(String label, short value) {
    putApprovalFor(getAccountId(), label, value);
}
#end_block

#method_before
public void removeApproval(String label) {
    removeApprovalFor(getEffectiveAccountId(), label);
}
#method_after
public void removeApproval(String label) {
    removeApprovalFor(getAccountId(), label);
}
#end_block

#method_before
public void putComment(PatchLineComment.Status status, Comment c) {
    checkRealAccount("update comments");
    verifyComment(c);
    createDraftUpdateIfNull();
    if (status == PatchLineComment.Status.DRAFT) {
        draftUpdate.putComment(c);
    } else {
        comments.add(c);
        // Always delete the corresponding comment from drafts. Published comments
        // are immutable, meaning in normal operation we only hit this path when
        // publishing a comment. It's exactly in that case that we have to delete
        // the draft.
        draftUpdate.deleteComment(c);
    }
}
#method_after
public void putComment(PatchLineComment.Status status, Comment c) {
    verifyComment(c);
    createDraftUpdateIfNull();
    if (status == PatchLineComment.Status.DRAFT) {
        draftUpdate.putComment(c);
    } else {
        comments.add(c);
        // Always delete the corresponding comment from drafts. Published comments
        // are immutable, meaning in normal operation we only hit this path when
        // publishing a comment. It's exactly in that case that we have to delete
        // the draft.
        draftUpdate.deleteComment(c);
    }
}
#end_block

#method_before
public void putRobotComment(RobotComment c) {
    checkRealAccount("update robot comments");
    verifyComment(c);
    createRobotCommentUpdateIfNull();
    robotCommentUpdate.putComment(c);
}
#method_after
public void putRobotComment(RobotComment c) {
    verifyComment(c);
    createRobotCommentUpdateIfNull();
    robotCommentUpdate.putComment(c);
}
#end_block

#method_before
public void deleteComment(Comment c) {
    checkRealAccount("update comments");
    verifyComment(c);
    createDraftUpdateIfNull().deleteComment(c);
}
#method_after
public void deleteComment(Comment c) {
    verifyComment(c);
    createDraftUpdateIfNull().deleteComment(c);
}
#end_block

#method_before
@VisibleForTesting
ChangeDraftUpdate createDraftUpdateIfNull() {
    if (draftUpdate == null) {
        checkRealAccount("update drafts");
        ChangeNotes notes = getNotes();
        if (notes != null) {
            draftUpdate = draftUpdateFactory.create(notes, effectiveAccountId, authorIdent, when);
        } else {
            draftUpdate = draftUpdateFactory.create(getChange(), effectiveAccountId, authorIdent, when);
        }
    }
    return draftUpdate;
}
#method_after
@VisibleForTesting
ChangeDraftUpdate createDraftUpdateIfNull() {
    if (draftUpdate == null) {
        ChangeNotes notes = getNotes();
        if (notes != null) {
            draftUpdate = draftUpdateFactory.create(notes, accountId, realAccountId, authorIdent, when);
        } else {
            draftUpdate = draftUpdateFactory.create(getChange(), accountId, realAccountId, authorIdent, when);
        }
    }
    return draftUpdate;
}
#end_block

#method_before
@VisibleForTesting
RobotCommentUpdate createRobotCommentUpdateIfNull() {
    if (robotCommentUpdate == null) {
        checkRealAccount("update robot comments");
        ChangeNotes notes = getNotes();
        if (notes != null) {
            robotCommentUpdate = robotCommentUpdateFactory.create(notes, effectiveAccountId, authorIdent, when);
        } else {
            robotCommentUpdate = robotCommentUpdateFactory.create(getChange(), effectiveAccountId, authorIdent, when);
        }
    }
    return robotCommentUpdate;
}
#method_after
@VisibleForTesting
RobotCommentUpdate createRobotCommentUpdateIfNull() {
    if (robotCommentUpdate == null) {
        ChangeNotes notes = getNotes();
        if (notes != null) {
            robotCommentUpdate = robotCommentUpdateFactory.create(notes, accountId, realAccountId, authorIdent, when);
        } else {
            robotCommentUpdate = robotCommentUpdateFactory.create(getChange(), accountId, realAccountId, authorIdent, when);
        }
    }
    return robotCommentUpdate;
}
#end_block

#method_before
@Override
protected CommitBuilder applyImpl(RevWalk rw, ObjectInserter ins, ObjectId curr) throws OrmException, IOException {
    CommitBuilder cb = new CommitBuilder();
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (commitSubject != null) {
        msg.append(commitSubject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addPatchSetFooter(msg, ps);
    if (changeId != null) {
        addFooter(msg, FOOTER_CHANGE_ID, changeId);
    }
    if (subject != null) {
        addFooter(msg, FOOTER_SUBJECT, subject);
    }
    if (branch != null) {
        addFooter(msg, FOOTER_BRANCH, branch);
    }
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (commit != null) {
        addFooter(msg, FOOTER_COMMIT, commit);
    }
    if (assignee != null) {
        if (assignee.isPresent()) {
            addFooter(msg, FOOTER_ASSIGNEE);
            addIdent(msg, assignee.get()).append('\n');
        } else {
            addFooter(msg, FOOTER_ASSIGNEE).append('\n');
        }
    }
    Joiner comma = Joiner.on(',');
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, comma.join(hashtags));
    }
    if (tag != null) {
        addFooter(msg, FOOTER_TAG, tag);
    }
    if (groups != null) {
        addFooter(msg, FOOTER_GROUPS, comma.join(groups));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        addFooter(msg, e.getValue().getFooterKey());
        addIdent(msg, e.getKey()).append('\n');
    }
    for (Table.Cell<String, Account.Id, Optional<Short>> c : approvals.cellSet()) {
        addFooter(msg, FOOTER_LABEL);
        if (!c.getValue().isPresent()) {
            msg.append('-').append(c.getRowKey());
        } else {
            msg.append(LabelVote.create(c.getRowKey(), c.getValue().get()).formatWithEquals());
        }
        Account.Id id = c.getColumnKey();
        if (!id.equals(getEffectiveAccountId())) {
            addIdent(msg.append(' '), id);
        }
        msg.append('\n');
    }
    if (submissionId != null) {
        addFooter(msg, FOOTER_SUBMISSION_ID, submissionId);
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        PersonIdent ident = newIdent(accountCache.get(label.appliedBy).getAccount(), when);
                        msg.append(": ").append(ident.getName()).append(" <").append(ident.getEmailAddress()).append('>');
                    }
                    msg.append('\n');
                }
            }
        }
    }
    if (!Objects.equals(effectiveAccountId, realAccountId)) {
        addFooter(msg, FOOTER_REAL_USER);
        addIdent(msg, realAccountId).append('\n');
    }
    cb.setMessage(msg.toString());
    try {
        ObjectId treeId = storeRevisionNotes(rw, ins, curr);
        if (treeId != null) {
            cb.setTreeId(treeId);
        }
    } catch (ConfigInvalidException e) {
        throw new OrmException(e);
    }
    return cb;
}
#method_after
@Override
protected CommitBuilder applyImpl(RevWalk rw, ObjectInserter ins, ObjectId curr) throws OrmException, IOException {
    CommitBuilder cb = new CommitBuilder();
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (commitSubject != null) {
        msg.append(commitSubject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addPatchSetFooter(msg, ps);
    if (changeId != null) {
        addFooter(msg, FOOTER_CHANGE_ID, changeId);
    }
    if (subject != null) {
        addFooter(msg, FOOTER_SUBJECT, subject);
    }
    if (branch != null) {
        addFooter(msg, FOOTER_BRANCH, branch);
    }
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (commit != null) {
        addFooter(msg, FOOTER_COMMIT, commit);
    }
    if (assignee != null) {
        if (assignee.isPresent()) {
            addFooter(msg, FOOTER_ASSIGNEE);
            addIdent(msg, assignee.get()).append('\n');
        } else {
            addFooter(msg, FOOTER_ASSIGNEE).append('\n');
        }
    }
    Joiner comma = Joiner.on(',');
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, comma.join(hashtags));
    }
    if (tag != null) {
        addFooter(msg, FOOTER_TAG, tag);
    }
    if (groups != null) {
        addFooter(msg, FOOTER_GROUPS, comma.join(groups));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        addFooter(msg, e.getValue().getFooterKey());
        addIdent(msg, e.getKey()).append('\n');
    }
    for (Table.Cell<String, Account.Id, Optional<Short>> c : approvals.cellSet()) {
        addFooter(msg, FOOTER_LABEL);
        if (!c.getValue().isPresent()) {
            msg.append('-').append(c.getRowKey());
        } else {
            msg.append(LabelVote.create(c.getRowKey(), c.getValue().get()).formatWithEquals());
        }
        Account.Id id = c.getColumnKey();
        if (!id.equals(getAccountId())) {
            addIdent(msg.append(' '), id);
        }
        msg.append('\n');
    }
    if (submissionId != null) {
        addFooter(msg, FOOTER_SUBMISSION_ID, submissionId);
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        msg.append(": ");
                        addIdent(msg, label.appliedBy);
                    }
                    msg.append('\n');
                }
            }
        }
    }
    if (!Objects.equals(accountId, realAccountId)) {
        addFooter(msg, FOOTER_REAL_USER);
        addIdent(msg, realAccountId).append('\n');
    }
    cb.setMessage(msg.toString());
    try {
        ObjectId treeId = storeRevisionNotes(rw, ins, curr);
        if (treeId != null) {
            cb.setTreeId(treeId);
        }
    } catch (ConfigInvalidException e) {
        throw new OrmException(e);
    }
    return cb;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
@Override
void apply(ChangeUpdate update) throws OrmException {
    if (!Objects.equals(change.getTopic(), noteDbChange.getTopic())) {
        update.setTopic(change.getTopic());
    }
    if (!Objects.equals(change.getStatus(), noteDbChange.getStatus())) {
        // TODO(dborowitz): Stamp approximate approvals at this time.
        update.fixStatus(change.getStatus());
    }
    if (change.getSubmissionId() != null) {
        update.setSubmissionId(change.getSubmissionId());
    }
    if (!update.isEmpty()) {
        update.setSubjectForCommit("Final NoteDb migration updates");
    }
}
#method_after
@SuppressWarnings("deprecation")
@Override
void apply(ChangeUpdate update) throws OrmException {
    if (!Objects.equals(change.getTopic(), noteDbChange.getTopic())) {
        update.setTopic(change.getTopic());
    }
    if (!Objects.equals(change.getStatus(), noteDbChange.getStatus())) {
        // TODO(dborowitz): Stamp approximate approvals at this time.
        update.fixStatus(change.getStatus());
    }
    if (change.getSubmissionId() != null && noteDbChange.getSubmissionId() == null) {
        update.setSubmissionId(change.getSubmissionId());
    }
    if (!Objects.equals(change.getAssignee(), noteDbChange.getAssignee())) {
        // TODO(dborowitz): Parse intermediate values out from messages.
        update.setAssignee(change.getAssignee());
    }
    if (!update.isEmpty()) {
        update.setSubjectForCommit("Final NoteDb migration updates");
    }
}
#end_block

#method_before
boolean canAdd(E e) {
    if (isEmpty()) {
        return true;
    }
    if (e instanceof FinalUpdatesEvent) {
        // FinalUpdatesEvent always gets its own update.
        return false;
    }
    Event last = getLast();
    if (!Objects.equals(e.effectiveUser, last.effectiveUser) || !Objects.equals(e.realUser, last.realUser) || !e.psId.equals(last.psId) || !Objects.equals(e.tag, last.tag)) {
        // Different patch set, author, or tag.
        return false;
    }
    long t = e.when.getTime();
    long tFirst = getFirstTime();
    long tLast = getLastTime();
    checkArgument(t >= tLast, "event %s is before previous event in list %s", e, last);
    if (t - tLast > ChangeRebuilderImpl.MAX_DELTA_MS || t - tFirst > ChangeRebuilderImpl.MAX_WINDOW_MS) {
        // Too much time elapsed.
        return false;
    }
    if (!e.uniquePerUpdate()) {
        return true;
    }
    for (Event o : this) {
        if (e.getClass() == o.getClass()) {
            // Only one event of this type allowed per update.
            return false;
        }
    }
    return true;
}
#method_after
boolean canAdd(E e) {
    if (isEmpty()) {
        return true;
    }
    if (e instanceof FinalUpdatesEvent) {
        // FinalUpdatesEvent always gets its own update.
        return false;
    }
    Event last = getLast();
    if (!Objects.equals(e.user, last.user) || !Objects.equals(e.realUser, last.realUser) || !e.psId.equals(last.psId) || !Objects.equals(e.tag, last.tag)) {
        // Different patch set, author, or tag.
        return false;
    }
    long t = e.when.getTime();
    long tFirst = getFirstTime();
    long tLast = getLastTime();
    checkArgument(t >= tLast, "event %s is before previous event in list %s", e, last);
    if (t - tLast > ChangeRebuilderImpl.MAX_DELTA_MS || t - tFirst > ChangeRebuilderImpl.MAX_WINDOW_MS) {
        // Too much time elapsed.
        return false;
    }
    if (!e.uniquePerUpdate()) {
        return true;
    }
    for (Event o : this) {
        if (e.getClass() == o.getClass()) {
            // Only one event of this type allowed per update.
            return false;
        }
    }
    return true;
}
#end_block

#method_before
Account.Id getAccountId() {
    Account.Id id = get(0).effectiveUser;
    for (int i = 1; i < size(); i++) {
        checkState(Objects.equals(id, get(i).effectiveUser), "mismatched users in EventList: %s != %s", id, get(i).effectiveUser);
    }
    return id;
}
#method_after
Account.Id getAccountId() {
    Account.Id id = get(0).user;
    for (int i = 1; i < size(); i++) {
        checkState(Objects.equals(id, get(i).user), "mismatched users in EventList: %s != %s", id, get(i).user);
    }
    return id;
}
#end_block

#method_before
protected void checkUpdate(AbstractChangeUpdate update) {
    checkState(Objects.equals(update.getPatchSetId(), psId), "cannot apply event for %s to update for %s", update.getPatchSetId(), psId);
    checkState(when.getTime() - update.getWhen().getTime() <= MAX_WINDOW_MS, "event at %s outside update window starting at %s", when, update.getWhen());
    checkState(Objects.equals(update.getNullableAccountId(), effectiveUser), "cannot apply event by %s to update by %s", effectiveUser, update.getNullableAccountId());
}
#method_after
protected void checkUpdate(AbstractChangeUpdate update) {
    checkState(Objects.equals(update.getPatchSetId(), psId), "cannot apply event for %s to update for %s", update.getPatchSetId(), psId);
    checkState(when.getTime() - update.getWhen().getTime() <= MAX_WINDOW_MS, "event at %s outside update window starting at %s", when, update.getWhen());
    checkState(Objects.equals(update.getNullableAccountId(), user), "cannot apply event by %s to update by %s", user, update.getNullableAccountId());
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("psId", psId).add("effectiveUser", effectiveUser).add("realUser", realUser).add("when", when).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("psId", psId).add("effectiveUser", user).add("realUser", realUser).add("when", when).toString();
}
#end_block

#method_before
@Override
public int compareTo(Event other) {
    return ComparisonChain.start().compare(this.when, other.when).compareTrueFirst(isPatchSet(), isPatchSet()).compareTrueFirst(this.predatesChange, other.predatesChange).compare(this.effectiveUser, other.effectiveUser, ReviewDbUtil.intKeyOrdering()).compare(this.realUser, other.realUser, ReviewDbUtil.intKeyOrdering()).compare(this.psId, other.psId, ReviewDbUtil.intKeyOrdering().nullsLast()).result();
}
#method_after
@Override
public int compareTo(Event other) {
    return ComparisonChain.start().compareFalseFirst(this.isFinalUpdates(), other.isFinalUpdates()).compare(this.when, other.when).compareTrueFirst(isPatchSet(), isPatchSet()).compareTrueFirst(this.predatesChange, other.predatesChange).compare(this.user, other.user, ReviewDbUtil.intKeyOrdering()).compare(this.realUser, other.realUser, ReviewDbUtil.intKeyOrdering()).compare(this.psId, other.psId, ReviewDbUtil.intKeyOrdering().nullsLast()).result();
}
#end_block

#method_before
protected boolean isPatchSet() {
    return false;
}
#method_after
private boolean isPatchSet() {
    return this instanceof PatchSetEvent;
}
#end_block

#method_before
public static PatchSetApproval newApproval(PatchSet.Id psId, CurrentUser user, LabelId labelId, int value, Date when) {
    PatchSetApproval psa = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), labelId), Shorts.checkedCast(value), when);
    if (user.getRealUser().isIdentifiedUser()) {
        psa.setRealAccountId(user.getRealUser().getAccountId());
    }
    return psa;
}
#method_after
public static PatchSetApproval newApproval(PatchSet.Id psId, CurrentUser user, LabelId labelId, int value, Date when) {
    PatchSetApproval psa = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), labelId), Shorts.checkedCast(value), when);
    user.updateRealAccountId(psa::setRealAccountId);
    return psa;
}
#end_block

#method_before
private Comment parseComment(byte[] note, MutableInteger curr, String currentFileName, PatchSet.Id psId, RevId revId, boolean isForBase, Integer parentNumber) throws ConfigInvalidException {
    Change.Id changeId = psId.getParentKey();
    // Check if there is a new file.
    boolean newFile = (RawParseUtils.match(note, curr.value, FILE.getBytes(UTF_8))) != -1;
    if (newFile) {
        // If so, parse the new file name.
        currentFileName = parseFilename(note, curr, changeId);
    } else if (currentFileName == null) {
        throw parseException(changeId, "could not parse %s", FILE);
    }
    CommentRange range = parseCommentRange(note, curr);
    if (range == null) {
        throw parseException(changeId, "could not parse %s", COMMENT_RANGE);
    }
    Timestamp commentTime = parseTimestamp(note, curr, changeId);
    Account.Id aId = parseAuthor(note, curr, changeId);
    boolean hasParent = (RawParseUtils.match(note, curr.value, PARENT.getBytes(UTF_8))) != -1;
    String parentUUID = null;
    if (hasParent) {
        parentUUID = parseStringField(note, curr, changeId, PARENT);
    }
    String uuid = parseStringField(note, curr, changeId, UUID);
    boolean hasTag = (RawParseUtils.match(note, curr.value, TAG.getBytes(UTF_8))) != -1;
    String tag = null;
    if (hasTag) {
        tag = parseStringField(note, curr, changeId, TAG);
    }
    int commentLength = parseCommentLength(note, curr, changeId);
    String message = RawParseUtils.decode(UTF_8, note, curr.value, curr.value + commentLength);
    checkResult(message, "message contents", changeId);
    Comment c = new Comment(new Comment.Key(uuid, currentFileName, psId.get()), aId, commentTime, isForBase ? (short) (parentNumber == null ? 0 : -parentNumber) : (short) 1, message, serverId);
    c.lineNbr = range.getEndLine();
    c.parentUuid = parentUUID;
    c.tag = tag;
    c.setRevId(revId);
    if (range.getStartCharacter() != -1) {
        c.setRange(range);
    }
    curr.value = RawParseUtils.nextLF(note, curr.value + commentLength);
    curr.value = RawParseUtils.nextLF(note, curr.value);
    return c;
}
#method_after
private Comment parseComment(byte[] note, MutableInteger curr, String currentFileName, PatchSet.Id psId, RevId revId, boolean isForBase, Integer parentNumber) throws ConfigInvalidException {
    Change.Id changeId = psId.getParentKey();
    // Check if there is a new file.
    boolean newFile = (RawParseUtils.match(note, curr.value, FILE.getBytes(UTF_8))) != -1;
    if (newFile) {
        // If so, parse the new file name.
        currentFileName = parseFilename(note, curr, changeId);
    } else if (currentFileName == null) {
        throw parseException(changeId, "could not parse %s", FILE);
    }
    CommentRange range = parseCommentRange(note, curr);
    if (range == null) {
        throw parseException(changeId, "could not parse %s", COMMENT_RANGE);
    }
    Timestamp commentTime = parseTimestamp(note, curr, changeId);
    Account.Id aId = parseAuthor(note, curr, changeId, AUTHOR);
    boolean hasRealAuthor = (RawParseUtils.match(note, curr.value, REAL_AUTHOR.getBytes(UTF_8))) != -1;
    Account.Id raId = null;
    if (hasRealAuthor) {
        raId = parseAuthor(note, curr, changeId, REAL_AUTHOR);
    }
    boolean hasParent = (RawParseUtils.match(note, curr.value, PARENT.getBytes(UTF_8))) != -1;
    String parentUUID = null;
    if (hasParent) {
        parentUUID = parseStringField(note, curr, changeId, PARENT);
    }
    String uuid = parseStringField(note, curr, changeId, UUID);
    boolean hasTag = (RawParseUtils.match(note, curr.value, TAG.getBytes(UTF_8))) != -1;
    String tag = null;
    if (hasTag) {
        tag = parseStringField(note, curr, changeId, TAG);
    }
    int commentLength = parseCommentLength(note, curr, changeId);
    String message = RawParseUtils.decode(UTF_8, note, curr.value, curr.value + commentLength);
    checkResult(message, "message contents", changeId);
    Comment c = new Comment(new Comment.Key(uuid, currentFileName, psId.get()), aId, commentTime, isForBase ? (short) (parentNumber == null ? 0 : -parentNumber) : (short) 1, message, serverId);
    c.lineNbr = range.getEndLine();
    c.parentUuid = parentUUID;
    c.tag = tag;
    c.setRevId(revId);
    if (raId != null) {
        c.setRealAuthor(raId);
    }
    if (range.getStartCharacter() != -1) {
        c.setRange(range);
    }
    curr.value = RawParseUtils.nextLF(note, curr.value + commentLength);
    curr.value = RawParseUtils.nextLF(note, curr.value);
    return c;
}
#end_block

#method_before
private Account.Id parseAuthor(byte[] note, MutableInteger curr, Change.Id changeId) throws ConfigInvalidException {
    checkHeaderLineFormat(note, curr, AUTHOR, changeId);
    int startOfAccountId = RawParseUtils.endOfFooterLineKey(note, curr.value) + 2;
    PersonIdent ident = RawParseUtils.parsePersonIdent(note, startOfAccountId);
    Account.Id aId = parseIdent(ident, changeId);
    curr.value = RawParseUtils.nextLF(note, curr.value);
    return checkResult(aId, "comment author", changeId);
}
#method_after
private Account.Id parseAuthor(byte[] note, MutableInteger curr, Change.Id changeId, String fieldName) throws ConfigInvalidException {
    checkHeaderLineFormat(note, curr, fieldName, changeId);
    int startOfAccountId = RawParseUtils.endOfFooterLineKey(note, curr.value) + 2;
    PersonIdent ident = RawParseUtils.parsePersonIdent(note, startOfAccountId);
    Account.Id aId = parseIdent(ident, changeId);
    curr.value = RawParseUtils.nextLF(note, curr.value);
    return checkResult(aId, fieldName, changeId);
}
#end_block

#method_before
private void appendOneComment(PrintWriter writer, Comment c) {
    // The CommentRange field for a comment is allowed to be null. If it is
    // null, then in the first line, we simply use the line number field for a
    // comment instead. If it isn't null, we write the comment range itself.
    Comment.Range range = c.range;
    if (range != null) {
        writer.print(range.startLine);
        writer.print(':');
        writer.print(range.startChar);
        writer.print('-');
        writer.print(range.endLine);
        writer.print(':');
        writer.print(range.endChar);
    } else {
        writer.print(c.lineNbr);
    }
    writer.print("\n");
    writer.print(formatTime(serverIdent, c.writtenOn));
    writer.print("\n");
    PersonIdent ident = newIdent(accountCache.get(c.author.getId()).getAccount(), c.writtenOn, serverIdent, anonymousCowardName);
    StringBuilder name = new StringBuilder();
    PersonIdent.appendSanitized(name, ident.getName());
    name.append(" <");
    PersonIdent.appendSanitized(name, ident.getEmailAddress());
    name.append('>');
    appendHeaderField(writer, AUTHOR, name.toString());
    String parent = c.parentUuid;
    if (parent != null) {
        appendHeaderField(writer, PARENT, parent);
    }
    appendHeaderField(writer, UUID, c.key.uuid);
    if (c.tag != null) {
        appendHeaderField(writer, TAG, c.tag);
    }
    byte[] messageBytes = c.message.getBytes(UTF_8);
    appendHeaderField(writer, LENGTH, Integer.toString(messageBytes.length));
    writer.print(c.message);
    writer.print("\n\n");
}
#method_after
private void appendOneComment(PrintWriter writer, Comment c) {
    // The CommentRange field for a comment is allowed to be null. If it is
    // null, then in the first line, we simply use the line number field for a
    // comment instead. If it isn't null, we write the comment range itself.
    Comment.Range range = c.range;
    if (range != null) {
        writer.print(range.startLine);
        writer.print(':');
        writer.print(range.startChar);
        writer.print('-');
        writer.print(range.endLine);
        writer.print(':');
        writer.print(range.endChar);
    } else {
        writer.print(c.lineNbr);
    }
    writer.print("\n");
    writer.print(formatTime(serverIdent, c.writtenOn));
    writer.print("\n");
    appendIdent(writer, AUTHOR, c.author.getId(), c.writtenOn);
    if (!c.getRealAuthor().equals(c.author)) {
        appendIdent(writer, REAL_AUTHOR, c.getRealAuthor().getId(), c.writtenOn);
    }
    String parent = c.parentUuid;
    if (parent != null) {
        appendHeaderField(writer, PARENT, parent);
    }
    appendHeaderField(writer, UUID, c.key.uuid);
    if (c.tag != null) {
        appendHeaderField(writer, TAG, c.tag);
    }
    byte[] messageBytes = c.message.getBytes(UTF_8);
    appendHeaderField(writer, LENGTH, Integer.toString(messageBytes.length));
    writer.print(c.message);
    writer.print("\n\n");
}
#end_block

#method_before
private void parseChangeMessage(PatchSet.Id psId, Account.Id effectiveAccountId, Account.Id realAccountId, ChangeNotesCommit commit, Timestamp ts) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMsgString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), effectiveAccountId, ts, psId);
    changeMessage.setMessage(changeMsgString);
    changeMessage.setTag(tag);
    changeMessage.setRealAuthor(realAccountId);
    changeMessagesByPatchSet.put(psId, changeMessage);
    allChangeMessages.add(changeMessage);
}
#method_after
private void parseChangeMessage(PatchSet.Id psId, Account.Id accountId, Account.Id realAccountId, ChangeNotesCommit commit, Timestamp ts) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMsgString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, ts, psId);
    changeMessage.setMessage(changeMsgString);
    changeMessage.setTag(tag);
    changeMessage.setRealAuthor(realAccountId);
    changeMessagesByPatchSet.put(psId, changeMessage);
    allChangeMessages.add(changeMessage);
}
#end_block

#method_before
public Account.Id getNullableAccountId() {
    return effectiveAccountId;
}
#method_after
public Account.Id getNullableAccountId() {
    return accountId;
}
#end_block

#method_before
private void assertRobotComment(RobotCommentInfo c, RobotCommentInput expected, boolean expectPath) {
    assertThat(c.robotId).isEqualTo(expected.robotId);
    assertThat(c.robotRunId).isEqualTo(expected.robotRunId);
    assertThat(c.url).isEqualTo(expected.url);
    if (expected.properties != null) {
        assertThat(c.properties).containsExactlyEntriesIn(expected.properties).inOrder();
    } else {
        assertThat(c.properties).isNull();
    }
    assertThat(c.line).isEqualTo(expected.line);
    assertThat(c.message).isEqualTo(expected.message);
    assertThat(c.author.email).isEqualTo(admin.email);
    if (expectPath) {
        assertThat(c.path).isEqualTo(expected.path);
    } else {
        assertThat(c.path).isNull();
    }
}
#method_after
private void assertRobotComment(RobotCommentInfo c, RobotCommentInput expected, boolean expectPath) {
    assertThat(c.robotId).isEqualTo(expected.robotId);
    assertThat(c.robotRunId).isEqualTo(expected.robotRunId);
    assertThat(c.url).isEqualTo(expected.url);
    assertThat(c.properties).isEqualTo(expected.properties);
    assertThat(c.line).isEqualTo(expected.line);
    assertThat(c.message).isEqualTo(expected.message);
    assertThat(c.author.email).isEqualTo(admin.email);
    if (expectPath) {
        assertThat(c.path).isEqualTo(expected.path);
    } else {
        assertThat(c.path).isNull();
    }
}
#end_block

#method_before
@Override
public String toString() {
    return new StringBuilder().append("RobotComment{").append("key=").append(key).append(',').append("robotId=").append(robotId).append(',').append("robotRunId=").append(robotRunId).append(',').append("lineNbr=").append(lineNbr).append(',').append("author=").append(author.getId().get()).append(',').append("writtenOn=").append(writtenOn.toString()).append(',').append("side=").append(side).append(',').append("message=").append(Objects.toString(message, "")).append(',').append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',').append("range=").append(Objects.toString(range, "")).append(',').append("revId=").append(revId != null ? revId : "").append(',').append("tag=").append(Objects.toString(tag, "")).append(',').append("url=").append(url).append(',').append("properties={").append(join(properties.entrySet().stream().map(e -> e.getKey() + "=" + e.getValue()).collect(toList()))).append('}').append('}').toString();
}
#method_after
@Override
public String toString() {
    return new StringBuilder().append("RobotComment{").append("key=").append(key).append(',').append("robotId=").append(robotId).append(',').append("robotRunId=").append(robotRunId).append(',').append("lineNbr=").append(lineNbr).append(',').append("author=").append(author.getId().get()).append(',').append("writtenOn=").append(writtenOn.toString()).append(',').append("side=").append(side).append(',').append("message=").append(Objects.toString(message, "")).append(',').append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',').append("range=").append(Objects.toString(range, "")).append(',').append("revId=").append(revId != null ? revId : "").append(',').append("tag=").append(Objects.toString(tag, "")).append(',').append("url=").append(url).append(',').append("properties=").append(properties != null ? properties : "").append('}').toString();
}
#end_block

#method_before
void set(ChangeInfo info) {
    this.changeId = info.legacyId();
    assigneeLink.setText(info.assignee() != null ? info.assignee().name() : "");
    assigneeSuggestOracle.setChange(changeId);
    editAssigneeIcon.setVisible(Gerrit.isSignedIn());
}
#method_after
void set(ChangeInfo info) {
    this.changeId = info.legacyId();
    this.canEdit = info.hasActions() && info.actions().containsKey("assignee");
    setAssignee(info.assignee());
    assigneeSuggestOracle.setChange(changeId);
    editAssigneeIcon.setVisible(canEdit);
    if (!canEdit) {
        show.setTitle(null);
    }
}
#end_block

#method_before
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(error, false);
    editAssigneeIcon.setVisible(false);
    suggestBox.setFocus(true);
    suggestBox.setText("");
}
#method_after
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(show, false);
    UIObject.setVisible(error, false);
    editAssigneeIcon.setVisible(false);
    suggestBox.setFocus(true);
    suggestBox.setText(FormatUtil.nameEmail(currentAssignee));
    suggestBox.selectAll();
}
#end_block

#method_before
void onCloseForm() {
    UIObject.setVisible(form, false);
    UIObject.setVisible(error, false);
    editAssigneeIcon.setVisible(true);
    suggestBox.setFocus(false);
}
#method_after
void onCloseForm() {
    UIObject.setVisible(form, false);
    UIObject.setVisible(show, true);
    UIObject.setVisible(error, false);
    editAssigneeIcon.setVisible(true);
    suggestBox.setFocus(false);
}
#end_block

#method_before
@UiHandler("assign")
void onEditAssignee(@SuppressWarnings("unused") ClickEvent e) {
    editAssignee(suggestBox.getText());
}
#method_after
@UiHandler("assign")
void onEditAssignee(@SuppressWarnings("unused") ClickEvent e) {
    if (canEdit) {
        editAssignee(suggestBox.getText());
    }
}
#end_block

#method_before
private void editAssignee(final String assignee) {
    if (assignee.isEmpty()) {
        ChangeApi.deleteAssignee(changeId.get(), new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                assigneeLink.setText("");
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    } else {
        ChangeApi.setAssignee(changeId.get(), assignee, new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                assigneeLink.setText(getName(result));
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    }
}
#method_after
private void editAssignee(final String assignee) {
    if (assignee.isEmpty()) {
        ChangeApi.deleteAssignee(changeId.get(), new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                setAssignee(null);
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    } else {
        ChangeApi.setAssignee(changeId.get(), assignee, new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                setAssignee(result);
                Reviewers reviewers = getReviewers();
                if (reviewers != null) {
                    reviewers.updateReviewerList();
                }
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    }
}
#end_block

#method_before
private String getName(AccountInfo info) {
    if (info.name() != null) {
        return info.name();
    }
    return info.username();
}
#method_after
private String getName(AccountInfo info) {
    if (info.name() != null) {
        return info.name();
    }
    if (info.email() != null) {
        return info.email();
    }
    return Gerrit.info().user().anonymousCowardName();
}
#end_block

#method_before
void format(StringBuilder s) {
    if (!Strings.isNullOrEmpty(name)) {
        s.append(name).append(": ");
    }
    synchronized (this) {
        if (total == UNKNOWN) {
            s.append(count);
        } else {
            s.append(String.format("%d%% (%d/%d)", count * 100 / total, count, total));
        }
    }
}
#method_after
synchronized void format(StringBuilder s, boolean first) {
    if (count == 0) {
        return;
    }
    if (!first) {
        s.append(',');
    }
    s.append(' ');
    if (!Strings.isNullOrEmpty(name)) {
        s.append(name).append(": ");
    }
    if (total == UNKNOWN) {
        s.append(count);
    } else {
        s.append(String.format("%d%% (%d/%d)", count * 100 / total, count, total));
    }
}
#end_block

#method_before
private StringBuilder format() {
    StringBuilder s = new StringBuilder().append("\r").append(taskName).append(':');
    if (!tasks.isEmpty()) {
        boolean first = true;
        for (Task t : tasks) {
            int count = t.count;
            if (count == 0) {
                continue;
            }
            if (!first) {
                s.append(',');
            } else {
                first = false;
            }
            s.append(' ');
            t.format(s);
        }
    }
    if (spinnerState != NO_SPINNER) {
        // Don't output a spinner until the alarm fires for the first time.
        s.append(" (").append(spinnerState).append(')');
    }
    return s;
}
#method_after
private StringBuilder format() {
    StringBuilder s = new StringBuilder().append("\r").append(taskName).append(':');
    int firstLength = s.length();
    for (Task t : tasks) {
        t.format(s, s.length() == firstLength);
    }
    if (spinnerState != NO_SPINNER) {
        // Don't output a spinner until the alarm fires for the first time.
        s.append(" (").append(spinnerState).append(')');
    }
    return s;
}
#end_block

#method_before
void set(ChangeInfo info) {
    this.changeId = info.legacyId();
    assigneeLink.setText(info.assignee() != null ? info.assignee().name() : "");
    assigneeSuggestOracle.setChange(changeId);
    editAssigneeIcon.setVisible(Gerrit.isSignedIn());
}
#method_after
void set(ChangeInfo info) {
    this.changeId = info.legacyId();
    this.canEdit = info.hasActions() && info.actions().containsKey("assignee");
    setAssignee(info.assignee());
    assigneeSuggestOracle.setChange(changeId);
    editAssigneeIcon.setVisible(canEdit);
    if (!canEdit) {
        show.setTitle(null);
    }
}
#end_block

#method_before
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(error, false);
    editAssigneeIcon.setVisible(false);
    suggestBox.setFocus(true);
    suggestBox.setText("");
}
#method_after
void onOpenForm() {
    UIObject.setVisible(form, true);
    UIObject.setVisible(show, false);
    UIObject.setVisible(error, false);
    editAssigneeIcon.setVisible(false);
    suggestBox.setFocus(true);
    suggestBox.setText(FormatUtil.nameEmail(currentAssignee));
    suggestBox.selectAll();
}
#end_block

#method_before
void onCloseForm() {
    UIObject.setVisible(form, false);
    UIObject.setVisible(error, false);
    editAssigneeIcon.setVisible(true);
    suggestBox.setFocus(false);
}
#method_after
void onCloseForm() {
    UIObject.setVisible(form, false);
    UIObject.setVisible(show, true);
    UIObject.setVisible(error, false);
    editAssigneeIcon.setVisible(true);
    suggestBox.setFocus(false);
}
#end_block

#method_before
@UiHandler("assign")
void onEditAssignee(@SuppressWarnings("unused") ClickEvent e) {
    editAssignee(suggestBox.getText());
}
#method_after
@UiHandler("assign")
void onEditAssignee(@SuppressWarnings("unused") ClickEvent e) {
    if (canEdit) {
        editAssignee(suggestBox.getText());
    }
}
#end_block

#method_before
private void editAssignee(final String assignee) {
    if (assignee.isEmpty()) {
        ChangeApi.deleteAssignee(changeId.get(), new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                assigneeLink.setText("");
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    } else {
        ChangeApi.setAssignee(changeId.get(), assignee, new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                assigneeLink.setText(result.name());
                getReviewers().updateReviewerList();
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    }
}
#method_after
private void editAssignee(final String assignee) {
    if (assignee.isEmpty()) {
        ChangeApi.deleteAssignee(changeId.get(), new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                setAssignee(null);
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    } else {
        ChangeApi.setAssignee(changeId.get(), assignee, new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                setAssignee(result);
                Reviewers reviewers = getReviewers();
                if (reviewers != null) {
                    reviewers.updateReviewerList();
                }
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    }
}
#end_block

#method_before
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
        checkState(input.drafts == DraftHandling.KEEP);
    }
    if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        // updated set of reviewers.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, reviewerResults));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
    }
    return Response.ok(output);
}
#method_after
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        // updated set of reviewers.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, reviewerResults));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
    }
    return Response.ok(output);
}
#end_block

#method_before
private RevisionResource onBehalfOf(RevisionResource rev, ReviewInput in) throws BadRequestException, AuthException, UnprocessableEntityException, OrmException {
    if (in.labels == null || in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    if (in.drafts == null) {
        in.drafts = DraftHandling.KEEP;
    }
    if (in.drafts != DraftHandling.KEEP || !isEmpty(in.comments) || !isEmpty(in.robotComments)) {
        // well for simplicity and consistency.
        throw new AuthException("not allowed to modify other user's comments");
    }
    ChangeControl caller = rev.getControl();
    Iterator<Map.Entry<String, Short>> itr = in.labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType type = caller.getLabelTypes().byLabel(ent.getKey());
        if (type == null && in.strictLabels) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        } else if (type == null) {
            itr.remove();
            continue;
        }
        PermissionRange r = caller.getRange(Permission.forLabelAs(type.getName()));
        if (r == null || r.isEmpty() || !r.contains(ent.getValue())) {
            throw new AuthException(String.format("not permitted to modify label \"%s\" on behalf of \"%s\"", ent.getKey(), in.onBehalfOf));
        }
    }
    if (in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    ChangeControl target = caller.forUser(accounts.parse(in.onBehalfOf));
    if (!target.getRefControl().isVisible()) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see destination ref", target.getUser().getAccountId()));
    }
    return new RevisionResource(changes.parse(target), rev.getPatchSet());
}
#method_after
private RevisionResource onBehalfOf(RevisionResource rev, ReviewInput in) throws BadRequestException, AuthException, UnprocessableEntityException, OrmException {
    if (in.labels == null || in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    if (in.drafts == null) {
        in.drafts = DraftHandling.KEEP;
    }
    if (in.drafts != DraftHandling.KEEP) {
        throw new AuthException("not allowed to modify other user's drafts");
    }
    ChangeControl caller = rev.getControl();
    Iterator<Map.Entry<String, Short>> itr = in.labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType type = caller.getLabelTypes().byLabel(ent.getKey());
        if (type == null && in.strictLabels) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        } else if (type == null) {
            itr.remove();
            continue;
        }
        PermissionRange r = caller.getRange(Permission.forLabelAs(type.getName()));
        if (r == null || r.isEmpty() || !r.contains(ent.getValue())) {
            throw new AuthException(String.format("not permitted to modify label \"%s\" on behalf of \"%s\"", ent.getKey(), in.onBehalfOf));
        }
    }
    if (in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    ChangeControl target = caller.forUser(accounts.parse(in.onBehalfOf));
    if (!target.getRefControl().isVisible()) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see destination ref", target.getUser().getAccountId()));
    }
    return new RevisionResource(changes.parse(target), rev.getPatchSet());
}
#end_block

#method_before
@Override
public void run() {
    String path = cache.get("directory");
    if (path != null && path.isEmpty()) {
        // 
        return;
    }
    if (path == null) {
        path = "cache";
        cache.set("directory", path);
    }
    Path loc = site.resolve(path);
    FileUtil.mkdirsOrDie(loc, "cannot create cache.directory");
    List<Path> result = new ArrayList<>();
    try (DirectoryStream<Path> stream = Files.newDirectoryStream(loc, "*.{loc,h2}.db")) {
        for (Path entry : stream) {
            result.add(entry);
        }
    } catch (IOException e) {
        ui.message("IO error during cache directory scan");
        return;
    }
    if (!result.isEmpty() && ui.yesno(true, "Clear persistent caches")) {
        for (Path entry : result) {
            try {
                Files.deleteIfExists(entry);
            } catch (IOException e) {
                ui.message("Could not delete " + entry);
            }
        }
    }
}
#method_after
@Override
public void run() {
    ui.header("Cache");
    String path = cache.get("directory");
    if (path != null && path.isEmpty()) {
        // 
        return;
    }
    if (path == null) {
        path = "cache";
        cache.set("directory", path);
    }
    Path loc = site.resolve(path);
    FileUtil.mkdirsOrDie(loc, "cannot create cache.directory");
    List<Path> cacheFiles = new ArrayList<>();
    try (DirectoryStream<Path> stream = Files.newDirectoryStream(loc, "*.{lock,h2,trace}.db")) {
        for (Path entry : stream) {
            cacheFiles.add(entry);
        }
    } catch (IOException e) {
        ui.message("IO error during cache directory scan");
        return;
    }
    if (!cacheFiles.isEmpty()) {
        for (Path entry : cacheFiles) {
            if (ui.yesno(false, "Delete cache file %s", entry)) {
                try {
                    Files.deleteIfExists(entry);
                } catch (IOException e) {
                    ui.message("Could not delete " + entry);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    final SiteInit init = createSiteInit();
    if (beforeInit(init)) {
        return 0;
    }
    init.flags.autoStart = getAutoStart() && init.site.isNew;
    init.flags.dev = isDev() && init.site.isNew;
    init.flags.skipPlugins = skipPlugins();
    init.flags.deleteCache = getDeleteCache();
    final SiteRun run;
    try {
        init.initializer.run();
        init.flags.deleteOnFailure = false;
        run = createSiteRun(init);
        run.upgradeSchema();
        init.initializer.postRun(createSysInjector(init));
    } catch (Exception | Error failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    }
    System.err.println("Initialized " + getSitePath().toRealPath().normalize());
    afterInit(run);
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    final SiteInit init = createSiteInit();
    if (beforeInit(init)) {
        return 0;
    }
    init.flags.autoStart = getAutoStart() && init.site.isNew;
    init.flags.dev = isDev() && init.site.isNew;
    init.flags.skipPlugins = skipPlugins();
    init.flags.deleteCaches = getDeleteCaches();
    final SiteRun run;
    try {
        init.initializer.run();
        init.flags.deleteOnFailure = false;
        run = createSiteRun(init);
        run.upgradeSchema();
        init.initializer.postRun(createSysInjector(init));
    } catch (Exception | Error failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    }
    System.err.println("Initialized " + getSitePath().toRealPath().normalize());
    afterInit(run);
    return 0;
}
#end_block

#method_before
@Override
public void run() {
    ui.header("Cache");
    String path = cache.get("directory");
    if (path != null && path.isEmpty()) {
        // 
        return;
    }
    if (path == null) {
        path = "cache";
        cache.set("directory", path);
    }
    Path loc = site.resolve(path);
    FileUtil.mkdirsOrDie(loc, "cannot create cache.directory");
    List<Path> cacheFiles = new ArrayList<>();
    try (DirectoryStream<Path> stream = Files.newDirectoryStream(loc, "*.{lock,h2,trace}.db")) {
        for (Path entry : stream) {
            cacheFiles.add(entry);
        }
    } catch (IOException e) {
        ui.message("IO error during cache directory scan");
        return;
    }
    if (!cacheFiles.isEmpty()) {
        for (Path entry : cacheFiles) {
            if (flags.deleteCache || ui.yesno(false, "Delete cache file %s", entry)) {
                try {
                    Files.deleteIfExists(entry);
                } catch (IOException e) {
                    ui.message("Could not delete " + entry);
                }
            }
        }
    }
}
#method_after
@Override
public void run() {
    ui.header("Cache");
    String path = cache.get("directory");
    if (path != null && path.isEmpty()) {
        // 
        return;
    }
    if (path == null) {
        path = "cache";
        cache.set("directory", path);
    }
    Path loc = site.resolve(path);
    FileUtil.mkdirsOrDie(loc, "cannot create cache.directory");
    List<Path> cacheFiles = new ArrayList<>();
    try (DirectoryStream<Path> stream = Files.newDirectoryStream(loc, "*.{lock,h2,trace}.db")) {
        for (Path entry : stream) {
            cacheFiles.add(entry);
        }
    } catch (IOException e) {
        ui.message("IO error during cache directory scan");
        return;
    }
    if (!cacheFiles.isEmpty()) {
        for (Path entry : cacheFiles) {
            if (flags.deleteCaches || ui.yesno(false, "Delete cache file %s", entry)) {
                try {
                    Files.deleteIfExists(entry);
                } catch (IOException e) {
                    ui.message("Could not delete " + entry);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected Predicate<AccountState> defaultField(String query) {
    List<Predicate<AccountState>> preds = Lists.newArrayListWithCapacity(4);
    if ("self".equalsIgnoreCase(query)) {
        try {
            preds.add(AccountPredicates.id(self()));
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    Integer id = Ints.tryParse(query);
    if (id != null) {
        preds.add(AccountPredicates.id(new Account.Id(id)));
    }
    preds.add(name(query));
    preds.add(username(query));
    return Predicate.or(preds);
}
#method_after
@Override
protected Predicate<AccountState> defaultField(String query) {
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<AccountState>> preds = Lists.newArrayListWithCapacity(4);
    if ("self".equalsIgnoreCase(query)) {
        try {
            preds.add(AccountPredicates.id(self()));
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    Integer id = Ints.tryParse(query);
    if (id != null) {
        preds.add(AccountPredicates.id(new Account.Id(id)));
    }
    preds.add(name(query));
    preds.add(username(query));
    // predicates.
    return Predicate.or(preds);
}
#end_block

#method_before
@Override
public BinaryResult apply(RevisionResource rsrc) throws RestApiException {
    if (Strings.isNullOrEmpty(format)) {
        throw new BadRequestException("format is not specified");
    }
    ArchiveFormat f = allowedFormats.extensions.get("." + format);
    if (allowedFormats.getAllowed().isEmpty() && format.equals("tar")) {
        // When no formats are allowed, this is because the server admin wants
        // to disallow downloading patchsets/changes as archives, this
        // is not applicable to the preview_submit call. Allow tar as a
        // fall back.
        f = ArchiveFormat.TAR;
    }
    if (f == null) {
        throw new BadRequestException("unknown archive format");
    }
    Change change = rsrc.getChange();
    if (!change.getStatus().isOpen()) {
        throw new PreconditionFailedException("change is " + Submit.status(change));
    }
    ChangeControl control = rsrc.getControl();
    if (!control.getUser().isIdentifiedUser()) {
        throw new MethodNotAllowedException("Anonymous users cannot submit");
    }
    try (BinaryResult b = getBundles(rsrc, f)) {
        b.disableGzip().setContentType(f.getMimeType()).setAttachmentName("submit-preview-" + change.getChangeId() + "." + format);
        return b;
    } catch (OrmException | IOException e) {
        throw new RestApiException("Error generating submit preview");
    }
}
#method_after
@Override
public BinaryResult apply(RevisionResource rsrc) throws RestApiException {
    if (Strings.isNullOrEmpty(format)) {
        throw new BadRequestException("format is not specified");
    }
    ArchiveFormat f = allowedFormats.extensions.get("." + format);
    if (f == null && format.equals("tgz")) {
        // Always allow tgz, even when the allowedFormats doesn't contain it.
        // Then we allow at least one format even if the list of allowed
        // formats is empty.
        f = ArchiveFormat.TGZ;
    }
    if (f == null) {
        throw new BadRequestException("unknown archive format");
    }
    Change change = rsrc.getChange();
    if (!change.getStatus().isOpen()) {
        throw new PreconditionFailedException("change is " + Submit.status(change));
    }
    ChangeControl control = rsrc.getControl();
    if (!control.getUser().isIdentifiedUser()) {
        throw new MethodNotAllowedException("Anonymous users cannot submit");
    }
    try (BinaryResult b = getBundles(rsrc, f)) {
        b.disableGzip().setContentType(f.getMimeType()).setAttachmentName("submit-preview-" + change.getChangeId() + "." + format);
        return b;
    } catch (OrmException | IOException e) {
        throw new RestApiException("Error generating submit preview");
    }
}
#end_block

#method_before
void set(ChangeInfo info) {
    this.changeId = info.legacyId();
    this.canEdit = info.hasActions() && info.actions().containsKey("topic");
    this.currentAssignee = info.assignee() != null ? info.assignee().name() : "";
    assigneeLink.setText(currentAssignee);
    assigneeSuggestOracle.setChange(changeId);
    editAssigneeIcon.setVisible(canEdit);
}
#method_after
void set(ChangeInfo info) {
    this.changeId = info.legacyId();
    this.canEdit = info.hasActions() && info.actions().containsKey("assignee");
    assigneeLink.setText(info.assignee() != null ? info.assignee().name() : "");
    assigneeSuggestOracle.setChange(changeId);
    editAssigneeIcon.setVisible(canEdit);
}
#end_block

#method_before
private void editAssignee(final String assignee) {
    if (currentAssignee.equals(assignee)) {
        return;
    }
    if (assignee.isEmpty()) {
        ChangeApi.deleteAssignee(changeId.get(), new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                currentAssignee = "";
                assigneeLink.setText("");
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    } else {
        ChangeApi.setAssignee(changeId.get(), assignee, new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                currentAssignee = result.name();
                assigneeLink.setText(result.name());
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    }
}
#method_after
private void editAssignee(final String assignee) {
    if (assignee.isEmpty()) {
        ChangeApi.deleteAssignee(changeId.get(), new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                assigneeLink.setText("");
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    } else {
        ChangeApi.setAssignee(changeId.get(), assignee, new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                assigneeLink.setText(result.name());
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    }
}
#end_block

#method_before
@Test
public void publishesWhenExpected() throws Exception {
    // Setup mocks
    mockEvent.change = () -> mockChange;
    mockChange.commitMessage = "This is a title\nAnd a the body.";
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#method_after
@Test
public void publishesWhenExpected() throws Exception {
    // Setup mocks
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockChange.commitMessage = "This is a title\nAnd a the body.";
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#end_block

#method_before
@Test
public void doesNotPublishWhenExpected() throws Exception {
    // Setup mocks
    mockEvent.change = () -> mockChange;
    mockChange.commitMessage = "WIP:This is a title\nAnd a the body.";
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#method_after
@Test
public void doesNotPublishWhenExpected() throws Exception {
    // Setup mocks
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockChange.commitMessage = "WIP:This is a title\nAnd a the body.";
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#end_block

#method_before
@Test
public void generatesExpectedMessage() throws Exception {
    // Setup mocks
    mockEvent.change = () -> mockChange;
    mockEvent.submitter = () -> mockAccount;
    mockChange.project = "testproject";
    mockChange.branch = "master";
    mockChange.url = "https://change/";
    mockChange.commitMessage = "This is a title\nAnd a the body.";
    mockAccount.name = "Unit Tester";
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    String expectedResult;
    expectedResult = "{\"text\": \"Unit Tester merged\\n>>>" + "testproject (master): This is a title (https://change/)\"," + "\"channel\": \"#testchannel\",\"username\": \"testuser\"}\n";
    String actualResult;
    actualResult = messageGenerator.generate();
    assertThat(actualResult, is(equalTo(expectedResult)));
}
#method_after
@Test
public void generatesExpectedMessage() throws Exception {
    // Setup mocks
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.submitter = Suppliers.ofInstance(mockAccount);
    mockChange.project = "testproject";
    mockChange.branch = "master";
    mockChange.url = "https://change/";
    mockChange.commitMessage = "This is a title\nAnd a the body.";
    mockAccount.name = "Unit Tester";
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    String expectedResult;
    expectedResult = "{\"text\": \"Unit Tester merged\\n>>>" + "testproject (master): This is a title (https://change/)\"," + "\"channel\": \"#testchannel\",\"username\": \"testuser\"}\n";
    String actualResult;
    actualResult = messageGenerator.generate();
    assertThat(actualResult, is(equalTo(expectedResult)));
}
#end_block

#method_before
@Test
public void generatesExpectedMessage() throws Exception {
    // Setup mocks
    mockEvent.change = () -> mockChange;
    mockEvent.author = () -> mockAccount;
    mockEvent.comment = "This is the first line\nAnd the second line.";
    mockChange.project = "testproject";
    mockChange.branch = "master";
    mockChange.url = "https://change/";
    mockAccount.name = "Unit Tester";
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    String expectedResult;
    expectedResult = "{\"text\": \"Unit Tester commented\\n>>>" + "testproject (master): This is the first line\n" + "And the second line. (https://change/)\"," + "\"channel\": \"#testchannel\",\"username\": \"testuser\"}\n";
    String actualResult;
    actualResult = messageGenerator.generate();
    assertThat(actualResult, is(equalTo(expectedResult)));
}
#method_after
@Test
public void generatesExpectedMessage() throws Exception {
    // Setup mocks
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.author = Suppliers.ofInstance(mockAccount);
    mockEvent.comment = "This is the first line\nAnd the second line.";
    mockChange.project = "testproject";
    mockChange.branch = "master";
    mockChange.url = "https://change/";
    mockAccount.name = "Unit Tester";
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    String expectedResult;
    expectedResult = "{\"text\": \"Unit Tester commented\\n>>>" + "testproject (master): This is the first line\n" + "And the second line. (https://change/)\"," + "\"channel\": \"#testchannel\",\"username\": \"testuser\"}\n";
    String actualResult;
    actualResult = messageGenerator.generate();
    assertThat(actualResult, is(equalTo(expectedResult)));
}
#end_block

#method_before
@Test
public void generatesExpectedMessageForLongComment() throws Exception {
    // Setup mocks
    mockEvent.change = () -> mockChange;
    mockEvent.author = () -> mockAccount;
    mockEvent.comment = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. " + "Integer tristique ligula nec dapibus lobortis. Nulla venenatis, lacus quis vulputate volutpat, " + "sem neque ornare eros, vel sodales magna risus et diam. Maecenas ultricies justo dictum orci " + "scelerisque consequat a vel purus.";
    mockChange.project = "testproject";
    mockChange.branch = "master";
    mockChange.url = "https://change/";
    mockAccount.name = "Unit Tester";
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    String expectedResult;
    expectedResult = "{\"text\": \"Unit Tester commented\\n>>>" + "testproject (master): " + mockEvent.comment.substring(0, 197) + "... (https://change/)\"," + "\"channel\": \"#testchannel\",\"username\": \"testuser\"}\n";
    String actualResult;
    actualResult = messageGenerator.generate();
    assertThat(actualResult, is(equalTo(expectedResult)));
}
#method_after
@Test
public void generatesExpectedMessageForLongComment() throws Exception {
    // Setup mocks
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.author = Suppliers.ofInstance(mockAccount);
    mockEvent.comment = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. " + "Integer tristique ligula nec dapibus lobortis. Nulla venenatis, lacus quis vulputate volutpat, " + "sem neque ornare eros, vel sodales magna risus et diam. Maecenas ultricies justo dictum orci " + "scelerisque consequat a vel purus.";
    mockChange.project = "testproject";
    mockChange.branch = "master";
    mockChange.url = "https://change/";
    mockAccount.name = "Unit Tester";
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    String expectedResult;
    expectedResult = "{\"text\": \"Unit Tester commented\\n>>>" + "testproject (master): " + mockEvent.comment.substring(0, 197) + "... (https://change/)\"," + "\"channel\": \"#testchannel\",\"username\": \"testuser\"}\n";
    String actualResult;
    actualResult = messageGenerator.generate();
    assertThat(actualResult, is(equalTo(expectedResult)));
}
#end_block

#method_before
@Test
public void publishesWhenExpected() throws Exception {
    // Setup mocks
    mockEvent.change = () -> mockChange;
    mockChange.commitMessage = "This is a title\nAnd a the body.";
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#method_after
@Test
public void publishesWhenExpected() throws Exception {
    // Setup mocks
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockChange.commitMessage = "This is a title\nAnd a the body.";
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(true));
}
#end_block

#method_before
@Test
public void doesNotPublishWhenExpected() throws Exception {
    // Setup mocks
    mockEvent.change = () -> mockChange;
    mockChange.commitMessage = "WIP-This is a title\nAnd a the body.";
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(false));
}
#method_after
@Test
public void doesNotPublishWhenExpected() throws Exception {
    // Setup mocks
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockChange.commitMessage = "WIP-This is a title\nAnd a the body.";
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    assertThat(messageGenerator.shouldPublish(), is(false));
}
#end_block

#method_before
@Test
public void generatesExpectedMessage() throws Exception {
    // Setup mocks
    mockEvent.change = () -> mockChange;
    mockEvent.uploader = () -> mockAccount;
    mockChange.project = "testproject";
    mockChange.branch = "master";
    mockChange.url = "https://change/";
    mockChange.commitMessage = "This is a title\nAnd a the body.";
    mockAccount.name = "Unit Tester";
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    String expectedResult;
    expectedResult = "{\"text\": \"Unit Tester proposed\\n>>>" + "testproject (master): This is a title (https://change/)\"," + "\"channel\": \"#testchannel\",\"username\": \"testuser\"}\n";
    String actualResult;
    actualResult = messageGenerator.generate();
    assertThat(actualResult, is(equalTo(expectedResult)));
}
#method_after
@Test
public void generatesExpectedMessage() throws Exception {
    // Setup mocks
    mockEvent.change = Suppliers.ofInstance(mockChange);
    mockEvent.uploader = Suppliers.ofInstance(mockAccount);
    mockChange.project = "testproject";
    mockChange.branch = "master";
    mockChange.url = "https://change/";
    mockChange.commitMessage = "This is a title\nAnd a the body.";
    mockAccount.name = "Unit Tester";
    // Test
    MessageGenerator messageGenerator;
    messageGenerator = MessageGeneratorFactory.newInstance(mockEvent, config);
    String expectedResult;
    expectedResult = "{\"text\": \"Unit Tester proposed\\n>>>" + "testproject (master): This is a title (https://change/)\"," + "\"channel\": \"#testchannel\",\"username\": \"testuser\"}\n";
    String actualResult;
    actualResult = messageGenerator.generate();
    assertThat(actualResult, is(equalTo(expectedResult)));
}
#end_block

#method_before
private static void formatLink(GitPerson person, FlowPanel p, InlineHyperlink name, Element date, ChangeInfo change) {
    // no avatar plugin is installed
    if (change.owner().hasAvatarInfo()) {
        AvatarImage avatar;
        if (change.owner().email() != null && person != null && person.email() != null && change.owner().email().equals(person.email())) {
            avatar = new AvatarImage(change.owner());
        } else {
            avatar = new AvatarImage(AccountInfo.create(0, person.name(), person.email(), null));
        }
        p.insert(avatar, 0);
    }
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(owner(person), change.status()));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#method_after
private static void formatLink(GitPerson person, FlowPanel p, InlineHyperlink name, Element date, ChangeInfo change) {
    // no avatar plugin is installed
    if (change.owner().hasAvatarInfo()) {
        AvatarImage avatar;
        if (sameEmail(change.owner(), person)) {
            avatar = new AvatarImage(change.owner());
        } else {
            avatar = new AvatarImage(AccountInfo.create(0, person.name(), person.email(), null));
        }
        p.insert(avatar, 0);
    }
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(owner(person), change.status()));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#end_block

#method_before
@Override
public Set<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#method_after
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(ChangeResource rsrc, AssigneeInput input) throws RestApiException, UpdateException, OrmException, IOException {
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getControl().getUser(), TimeUtil.nowTs())) {
        SetAssigneeOp op = assigneeFactory.create(input);
        bu.addOp(rsrc.getId(), op);
        PostReviewers.Addition reviewersAddition = addAssigneAsCC(rsrc, input.assignee);
        bu.addOp(rsrc.getId(), reviewersAddition.op);
        bu.execute();
        reviewersAddition.gatherResults();
        return Response.ok(AccountJson.toAccountInfo(op.getNewAssignee()));
    }
}
#method_after
@Override
public Response<AccountInfo> apply(ChangeResource rsrc, AssigneeInput input) throws RestApiException, UpdateException, OrmException, IOException {
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getControl().getUser(), TimeUtil.nowTs())) {
        SetAssigneeOp op = assigneeFactory.create(input);
        bu.addOp(rsrc.getId(), op);
        PostReviewers.Addition reviewersAddition = addAssigneeAsCC(rsrc, input.assignee);
        bu.addOp(rsrc.getId(), reviewersAddition.op);
        bu.execute();
        reviewersAddition.gatherResults();
        return Response.ok(AccountJson.toAccountInfo(op.getNewAssignee()));
    }
}
#end_block

#method_before
@Test
public void approvalsTombstone() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId().get()).isEqualTo(1);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApproval("Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).isEmpty();
}
#method_after
@Test
public void approvalsTombstone() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId().get()).isEqualTo(1);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApproval("Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).containsExactlyEntriesIn(ImmutableMultimap.of(psa.getPatchSetId(), new PatchSetApproval(psa.getKey(), (short) 0, update.getWhen())));
}
#end_block

#method_before
@Test
public void removeOtherUsersApprovals() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApprovalFor(otherUserId, "Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).isEmpty();
    // Add back approval on same label.
    update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 2);
    update.commit();
    notes = newNotes(c);
    psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 2);
}
#method_after
@Test
public void removeOtherUsersApprovals() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSetApproval psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 1);
    update = newUpdate(c, changeOwner);
    update.removeApprovalFor(otherUserId, "Not-For-Long");
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getApprovals()).containsExactlyEntriesIn(ImmutableMultimap.of(psa.getPatchSetId(), new PatchSetApproval(psa.getKey(), (short) 0, update.getWhen())));
    // Add back approval on same label.
    update = newUpdate(c, otherUser);
    update.putApproval("Not-For-Long", (short) 2);
    update.commit();
    notes = newNotes(c);
    psa = Iterables.getOnlyElement(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(psa.getAccountId()).isEqualTo(otherUserId);
    assertThat(psa.getLabel()).isEqualTo("Not-For-Long");
    assertThat(psa.getValue()).isEqualTo((short) 2);
}
#end_block

#method_before
@Test
public void pushCertificate() throws Exception {
    String pushCert = "certificate version 0.1\n" + "pusher This is not a real push cert\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: GnuPG v1\n" + "\n" + "Nor is this a real signature.\n" + "-----END PGP SIGNATURE-----\n";
    // ps2 with push cert
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    RevCommit commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit, pushCert);
    update.commit();
    ChangeNotes notes = newNotes(c);
    String note = readNote(notes, commit);
    assertThat(note).isEqualTo(pushCert);
    Map<PatchSet.Id, PatchSet> patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isEmpty();
    // comment on ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    Timestamp ts = TimeUtil.nowTs();
    update.putComment(newPublishedComment(psId2, "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, ts, "Comment", (short) 1, commit.name()));
    update.commit();
    notes = newNotes(c);
    // TODO(hanwen): test fails. What do we really want to check here?
    assertThat(readNote(notes, commit)).isEqualTo(pushCert + "Revision: " + commit.name() + "\n" + "Patch-set: 2\n" + "File: a.txt\n" + "\n" + "1:2-3:4\n" + ChangeNoteUtil.formatTime(serverIdent, ts) + "\n" + "Author: Change Owner <1@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 7\n" + "Comment\n" + "\n");
    patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isNotEmpty();
}
#method_after
@Test
public void pushCertificate() throws Exception {
    String pushCert = "certificate version 0.1\n" + "pusher This is not a real push cert\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: GnuPG v1\n" + "\n" + "Nor is this a real signature.\n" + "-----END PGP SIGNATURE-----\n";
    // ps2 with push cert
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    RevCommit commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit, pushCert);
    update.commit();
    ChangeNotes notes = newNotes(c);
    String note = readNote(notes, commit);
    if (!testJson()) {
        assertThat(note).isEqualTo(pushCert);
    }
    Map<PatchSet.Id, PatchSet> patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isEmpty();
    // comment on ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    Timestamp ts = TimeUtil.nowTs();
    update.putComment(newPublishedComment(psId2, "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, ts, "Comment", (short) 1, commit.name()));
    update.commit();
    notes = newNotes(c);
    patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isNotEmpty();
    if (!testJson()) {
        assertThat(readNote(notes, commit)).isEqualTo(pushCert + "Revision: " + commit.name() + "\n" + "Patch-set: 2\n" + "File: a.txt\n" + "\n" + "1:2-3:4\n" + ChangeNoteUtil.formatTime(serverIdent, ts) + "\n" + "Author: Change Owner <1@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 7\n" + "Comment\n" + "\n");
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatSide1() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    Timestamp time3 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range3 = new CommentRange(3, 0, 4, 1);
    PatchLineComment comment3 = newPublishedComment(psId, "file2", uuid3, range3, range3.getEndLine(), otherUser, null, time3, message3, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment3);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        // TODO(hanwen): test fails. What do we really want to check here?
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "File: file2\n" + "\n" + "3:0-4:1\n" + ChangeNoteUtil.formatTime(serverIdent, time3) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
    }
}
#method_after
@Test
public void patchLineCommentNotesFormatSide1() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    Timestamp time3 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range3 = new CommentRange(3, 0, 4, 1);
    PatchLineComment comment3 = newPublishedComment(psId, "file2", uuid3, range3, range3.getEndLine(), otherUser, null, time3, message3, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment3);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "File: file2\n" + "\n" + "3:0-4:1\n" + ChangeNoteUtil.formatTime(serverIdent, time3) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatSide0() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String message1 = "comment 1";
    String message2 = "comment 2";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        // TODO(hanwen): test fails. What do we really want to check here?
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n");
    }
}
#method_after
@Test
public void patchLineCommentNotesFormatSide0() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String message1 = "comment 1";
    String message2 = "comment 2";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n");
        }
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatMultiplePatchSetsSameRevId() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Timestamp time = TimeUtil.nowTs();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    PatchSet.Id psId1 = c.currentPatchSetId();
    PatchSet.Id psId2 = new PatchSet.Id(c.getId(), psId1.get() + 1);
    PatchLineComment comment1 = newPublishedComment(psId1, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time, message1, (short) 0, revId.get());
    PatchLineComment comment2 = newPublishedComment(psId1, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time, message2, (short) 0, revId.get());
    PatchLineComment comment3 = newPublishedComment(psId2, "file1", uuid3, range1, range1.getEndLine(), otherUser, null, time, message3, (short) 0, revId.get());
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId2);
    update.putComment(comment3);
    update.putComment(comment2);
    update.putComment(comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        // TODO(hanwen): test fails. What do we really want to check here?
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "Base-for-patch-set: 2\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment1, revId, comment2, revId, comment3));
}
#method_after
@Test
public void patchLineCommentNotesFormatMultiplePatchSetsSameRevId() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Timestamp time = TimeUtil.nowTs();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    PatchSet.Id psId1 = c.currentPatchSetId();
    PatchSet.Id psId2 = new PatchSet.Id(c.getId(), psId1.get() + 1);
    PatchLineComment comment1 = newPublishedComment(psId1, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time, message1, (short) 0, revId.get());
    PatchLineComment comment2 = newPublishedComment(psId1, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time, message2, (short) 0, revId.get());
    PatchLineComment comment3 = newPublishedComment(psId2, "file1", uuid3, range1, range1.getEndLine(), otherUser, null, time, message3, (short) 0, revId.get());
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId2);
    update.putComment(comment3);
    update.putComment(comment2);
    update.putComment(comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "Base-for-patch-set: 2\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment1, revId, comment2, revId, comment3));
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatWeirdUser() throws Exception {
    Account account = new Account(new Account.Id(3), TimeUtil.nowTs());
    account.setFullName("Weird\n\u0002<User>\n");
    account.setPreferredEmail(" we\r\nird@ex>ample<.com");
    accountCache.put(account);
    IdentifiedUser user = userFactory.create(account.getId());
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, user);
    String uuid = "uuid";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment = newPublishedComment(psId, "file1", uuid, range, range.getEndLine(), user, null, time, "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        // TODO(hanwen): test fails. What do we really want to check here?
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Weird\u0002User <3@gerrit>\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(comment.getRevId(), comment));
}
#method_after
@Test
public void patchLineCommentNotesFormatWeirdUser() throws Exception {
    Account account = new Account(new Account.Id(3), TimeUtil.nowTs());
    account.setFullName("Weird\n\u0002<User>\n");
    account.setPreferredEmail(" we\r\nird@ex>ample<.com");
    accountCache.put(account);
    IdentifiedUser user = userFactory.create(account.getId());
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, user);
    String uuid = "uuid";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment = newPublishedComment(psId, "file1", uuid, range, range.getEndLine(), user, null, time, "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Weird\u0002User <3@gerrit>\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(comment.getRevId(), comment));
}
#end_block

#method_before
@Test
public void patchLineCommentsDeleteAllDrafts() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ObjectId objId = ObjectId.fromString(rev);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment = newComment(psId, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.DRAFT);
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    assertThat(notes.getDraftCommentNotes().getNoteMap().contains(objId)).isTrue();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(psId);
    update.deleteComment(comment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    // TODO
    assertThat(notes.getDraftCommentNotes().getNoteMap()).isNull();
}
#method_after
@Test
public void patchLineCommentsDeleteAllDrafts() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ObjectId objId = ObjectId.fromString(rev);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment = newComment(psId, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.DRAFT);
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    assertThat(notes.getDraftCommentNotes().getNoteMap().contains(objId)).isTrue();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(psId);
    update.deleteComment(comment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getDraftCommentNotes().getNoteMap()).isNull();
}
#end_block

#method_before
public List<PatchLineComment> parseNote(byte[] note, MutableInteger p, Change.Id changeId, Status status) throws ConfigInvalidException {
    if (p.value >= note.length) {
        return ImmutableList.of();
    }
    Set<PatchLineComment.Key> seen = new HashSet<>();
    List<PatchLineComment> result = new ArrayList<>();
    int sizeOfNote = note.length;
    byte[] psb = PATCH_SET.getBytes(UTF_8);
    byte[] bpsb = BASE_PATCH_SET.getBytes(UTF_8);
    byte[] bpn = PARENT_NUMBER.getBytes(UTF_8);
    if (note[p.value] == '{' || note[p.value] == '[') {
        return parseNoteJSON(note, p);
    }
    RevId revId = new RevId(parseStringField(note, p, changeId, REVISION));
    String fileName = null;
    PatchSet.Id psId = null;
    boolean isForBase = false;
    Integer parentNumber = null;
    while (p.value < sizeOfNote) {
        boolean matchPs = match(note, p, psb);
        boolean matchBase = match(note, p, bpsb);
        if (matchPs) {
            fileName = null;
            psId = parsePsId(note, p, changeId, PATCH_SET);
            isForBase = false;
        } else if (matchBase) {
            fileName = null;
            psId = parsePsId(note, p, changeId, BASE_PATCH_SET);
            isForBase = true;
            if (match(note, p, bpn)) {
                parentNumber = parseParentNumber(note, p, changeId);
            }
        } else if (psId == null) {
            throw parseException(changeId, "missing %s or %s header", PATCH_SET, BASE_PATCH_SET);
        }
        PatchLineComment c = parseComment(note, p, fileName, psId, revId, isForBase, parentNumber, status);
        fileName = c.getKey().getParentKey().getFileName();
        if (!seen.add(c.getKey())) {
            throw parseException(changeId, "multiple comments for %s in note", c.getKey());
        }
        result.add(c);
    }
    return result;
}
#method_after
public List<PatchLineComment> parseNote(byte[] note, MutableInteger p, Change.Id changeId, Status status) throws ConfigInvalidException {
    if (p.value >= note.length) {
        return ImmutableList.of();
    }
    Set<PatchLineComment.Key> seen = new HashSet<>();
    List<PatchLineComment> result = new ArrayList<>();
    int sizeOfNote = note.length;
    byte[] psb = PATCH_SET.getBytes(UTF_8);
    byte[] bpsb = BASE_PATCH_SET.getBytes(UTF_8);
    byte[] bpn = PARENT_NUMBER.getBytes(UTF_8);
    RevId revId = new RevId(parseStringField(note, p, changeId, REVISION));
    String fileName = null;
    PatchSet.Id psId = null;
    boolean isForBase = false;
    Integer parentNumber = null;
    while (p.value < sizeOfNote) {
        boolean matchPs = match(note, p, psb);
        boolean matchBase = match(note, p, bpsb);
        if (matchPs) {
            fileName = null;
            psId = parsePsId(note, p, changeId, PATCH_SET);
            isForBase = false;
        } else if (matchBase) {
            fileName = null;
            psId = parsePsId(note, p, changeId, BASE_PATCH_SET);
            isForBase = true;
            if (match(note, p, bpn)) {
                parentNumber = parseParentNumber(note, p, changeId);
            }
        } else if (psId == null) {
            throw parseException(changeId, "missing %s or %s header", PATCH_SET, BASE_PATCH_SET);
        }
        PatchLineComment c = parseComment(note, p, fileName, psId, revId, isForBase, parentNumber, status);
        fileName = c.getKey().getParentKey().getFileName();
        if (!seen.add(c.getKey())) {
            throw parseException(changeId, "multiple comments for %s in note", c.getKey());
        }
        result.add(c);
    }
    return result;
}
#end_block

#method_before
void buildNote(Multimap<PatchSet.Id, PatchLineComment> comments, OutputStream out) {
    if (gson != null) {
        buildNoteJSON(comments, out);
        return;
    }
    if (comments.isEmpty()) {
        return;
    }
    List<PatchSet.Id> psIds = ReviewDbUtil.intKeyOrdering().sortedCopy(comments.keySet());
    OutputStreamWriter streamWriter = new OutputStreamWriter(out, UTF_8);
    try (PrintWriter writer = new PrintWriter(streamWriter)) {
        RevId revId = comments.values().iterator().next().getRevId();
        appendHeaderField(writer, REVISION, revId.get());
        for (PatchSet.Id psId : psIds) {
            List<PatchLineComment> psComments = PLC_ORDER.sortedCopy(comments.get(psId));
            PatchLineComment first = psComments.get(0);
            short side = first.getSide();
            appendHeaderField(writer, side <= 0 ? BASE_PATCH_SET : PATCH_SET, Integer.toString(psId.get()));
            if (side < 0) {
                appendHeaderField(writer, PARENT_NUMBER, Integer.toString(-side));
            }
            String currentFilename = null;
            for (PatchLineComment c : psComments) {
                checkArgument(revId.equals(c.getRevId()), "All comments being added must have all the same RevId. The " + "comment below does not have the same RevId as the others " + "(%s).\n%s", revId, c);
                checkArgument(side == c.getSide(), "All comments being added must all have the same side. The " + "comment below does not have the same side as the others " + "(%s).\n%s", side, c);
                String commentFilename = QuotedString.GIT_PATH.quote(c.getKey().getParentKey().getFileName());
                if (!commentFilename.equals(currentFilename)) {
                    currentFilename = commentFilename;
                    writer.print("File: ");
                    writer.print(commentFilename);
                    writer.print("\n\n");
                }
                appendOneComment(writer, c);
            }
        }
    }
}
#method_after
void buildNote(Multimap<PatchSet.Id, PatchLineComment> comments, OutputStream out) {
    if (comments.isEmpty()) {
        return;
    }
    List<PatchSet.Id> psIds = ReviewDbUtil.intKeyOrdering().sortedCopy(comments.keySet());
    OutputStreamWriter streamWriter = new OutputStreamWriter(out, UTF_8);
    try (PrintWriter writer = new PrintWriter(streamWriter)) {
        RevId revId = comments.values().iterator().next().getRevId();
        appendHeaderField(writer, REVISION, revId.get());
        for (PatchSet.Id psId : psIds) {
            List<PatchLineComment> psComments = PLC_ORDER.sortedCopy(comments.get(psId));
            PatchLineComment first = psComments.get(0);
            short side = first.getSide();
            appendHeaderField(writer, side <= 0 ? BASE_PATCH_SET : PATCH_SET, Integer.toString(psId.get()));
            if (side < 0) {
                appendHeaderField(writer, PARENT_NUMBER, Integer.toString(-side));
            }
            String currentFilename = null;
            for (PatchLineComment c : psComments) {
                checkArgument(revId.equals(c.getRevId()), "All comments being added must have all the same RevId. The " + "comment below does not have the same RevId as the others " + "(%s).\n%s", revId, c);
                checkArgument(side == c.getSide(), "All comments being added must all have the same side. The " + "comment below does not have the same side as the others " + "(%s).\n%s", side, c);
                String commentFilename = QuotedString.GIT_PATH.quote(c.getKey().getParentKey().getFileName());
                if (!commentFilename.equals(currentFilename)) {
                    currentFilename = commentFilename;
                    writer.print("File: ");
                    writer.print(commentFilename);
                    writer.print("\n\n");
                }
                appendOneComment(writer, c);
            }
        }
    }
}
#end_block

#method_before
public static Set<String> fields(Schema<ChangeData> schema, QueryOptions opts) {
    // Ensure we request enough fields to construct a ChangeData.
    Set<String> fs = opts.fields();
    if (fs.contains(CHANGE.getName())) {
        // A Change is always sufficient.
        return fs;
    }
    if (!schema.hasField(PROJECT)) {
        // field, and call createOnlyWhenNoteDbDisabled from toChangeData below.
        if (fs.contains(LEGACY_ID.getName())) {
            return fs;
        }
        return Sets.union(fs, ImmutableSet.of(LEGACY_ID.getName()));
    }
    // New enough schema to have project field, so ensure that is requested.
    if (fs.contains(PROJECT.getName()) && fs.contains(LEGACY_ID.getName())) {
        return fs;
    }
    return Sets.union(fs, ImmutableSet.of(LEGACY_ID.getName(), PROJECT.getName()));
}
#method_after
public static Set<String> fields(QueryOptions opts) {
    // Ensure we request enough fields to construct a ChangeData. We need both
    // change ID and project, which can either come via the Change field or
    // separate fields.
    Set<String> fs = opts.fields();
    if (fs.contains(CHANGE.getName())) {
        // A Change is always sufficient.
        return fs;
    }
    if (fs.contains(PROJECT.getName()) && fs.contains(LEGACY_ID.getName())) {
        return fs;
    }
    return Sets.union(fs, ImmutableSet.of(LEGACY_ID.getName(), PROJECT.getName()));
}
#end_block

#method_before
@Override
protected String getMappings() {
    return "{\"mappings\" : " + getMappingProperties("open_changes") + "," + getMappingProperties("closed_changes") + "}";
}
#method_after
@Override
protected String getMappings() {
    return gson.toJson(ImmutableMap.of("mappings", mapping));
}
#end_block

#method_before
@Override
public void close() {
    MoreExecutors.shutdownAndAwaitTermination(executor, Long.MAX_VALUE, TimeUnit.SECONDS);
    try {
        openIndex.close();
    } finally {
        closedIndex.close();
    }
}
#method_after
@Override
public void close() {
    List<ListenableFuture<?>> closeFutures = Lists.newArrayListWithCapacity(2);
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            openIndex.close();
        }
    }));
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            closedIndex.close();
        }
    }));
    Futures.getUnchecked(Futures.allAsList(closeFutures));
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    if (Thread.interrupted()) {
        Thread.currentThread().interrupt();
        throw new OrmException("interrupted");
    }
    final Set<String> fields = IndexUtils.fields(schema, opts);
    return new ChangeDataResults(executor.submit(new Callable<List<Document>>() {

        @Override
        public List<Document> call() throws IOException {
            return doRead(fields);
        }

        @Override
        public String toString() {
            return predicate.toString();
        }
    }), fields);
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    if (Thread.interrupted()) {
        Thread.currentThread().interrupt();
        throw new OrmException("interrupted");
    }
    final Set<String> fields = IndexUtils.fields(opts);
    return new ChangeDataResults(executor.submit(new Callable<List<Document>>() {

        @Override
        public List<Document> call() throws IOException {
            return doRead(fields);
        }

        @Override
        public String toString() {
            return predicate.toString();
        }
    }), fields);
}
#end_block

#method_before
private ChangeData toChangeData(Multimap<String, IndexableField> doc, Set<String> fields, String idFieldName) {
    ChangeData cd;
    // Either change or the ID field was guaranteed to be included in the call
    // to fields() above.
    IndexableField cb = Iterables.getFirst(doc.get(CHANGE_FIELD), null);
    if (cb != null) {
        BytesRef proto = cb.binaryValue();
        cd = changeDataFactory.create(db.get(), ChangeProtoField.CODEC.decode(proto.bytes, proto.offset, proto.length));
    } else {
        IndexableField f = Iterables.getFirst(doc.get(idFieldName), null);
        Change.Id id = new Change.Id(f.numericValue().intValue());
        IndexableField project = Iterables.getFirst(doc.get(PROJECT.getName()), null);
        if (project == null) {
            // Old schema without project field: we can safely assume NoteDb is
            // disabled.
            cd = changeDataFactory.createOnlyWhenNoteDbDisabled(db.get(), id);
        } else {
            cd = changeDataFactory.create(db.get(), new Project.NameKey(project.stringValue()), id);
        }
    }
    if (fields.contains(PATCH_SET_FIELD)) {
        decodePatchSets(doc, cd);
    }
    if (fields.contains(APPROVAL_FIELD)) {
        decodeApprovals(doc, cd);
    }
    if (fields.contains(ADDED_FIELD) && fields.contains(DELETED_FIELD)) {
        decodeChangedLines(doc, cd);
    }
    if (fields.contains(MERGEABLE_FIELD)) {
        decodeMergeable(doc, cd);
    }
    if (fields.contains(REVIEWEDBY_FIELD)) {
        decodeReviewedBy(doc, cd);
    }
    if (fields.contains(HASHTAG_FIELD)) {
        decodeHashtags(doc, cd);
    }
    if (fields.contains(STARREDBY_FIELD)) {
        decodeStarredBy(doc, cd);
    }
    if (fields.contains(STAR_FIELD)) {
        decodeStar(doc, cd);
    }
    if (fields.contains(REVIEWER_FIELD)) {
        decodeReviewers(doc, cd);
    }
    return cd;
}
#method_after
private ChangeData toChangeData(Multimap<String, IndexableField> doc, Set<String> fields, String idFieldName) {
    ChangeData cd;
    // Either change or the ID field was guaranteed to be included in the call
    // to fields() above.
    IndexableField cb = Iterables.getFirst(doc.get(CHANGE_FIELD), null);
    if (cb != null) {
        BytesRef proto = cb.binaryValue();
        cd = changeDataFactory.create(db.get(), ChangeProtoField.CODEC.decode(proto.bytes, proto.offset, proto.length));
    } else {
        IndexableField f = Iterables.getFirst(doc.get(idFieldName), null);
        Change.Id id = new Change.Id(f.numericValue().intValue());
        IndexableField project = Iterables.getFirst(doc.get(PROJECT.getName()), null);
        if (project == null) {
            // Old schema without project field: we can safely assume NoteDb is
            // disabled.
            cd = changeDataFactory.createOnlyWhenNoteDbDisabled(db.get(), id);
        } else {
            cd = changeDataFactory.create(db.get(), new Project.NameKey(project.stringValue()), id);
        }
    }
    if (fields.contains(PATCH_SET_FIELD)) {
        decodePatchSets(doc, cd);
    }
    if (fields.contains(APPROVAL_FIELD)) {
        decodeApprovals(doc, cd);
    }
    if (fields.contains(ADDED_FIELD) && fields.contains(DELETED_FIELD)) {
        decodeChangedLines(doc, cd);
    }
    if (fields.contains(MERGEABLE_FIELD)) {
        decodeMergeable(doc, cd);
    }
    if (fields.contains(REVIEWEDBY_FIELD)) {
        decodeReviewedBy(doc, cd);
    }
    if (fields.contains(HASHTAG_FIELD)) {
        decodeHashtags(doc, cd);
    }
    if (fields.contains(STAR_FIELD)) {
        decodeStar(doc, cd);
    }
    if (fields.contains(REVIEWER_FIELD)) {
        decodeReviewers(doc, cd);
    }
    return cd;
}
#end_block

#method_before
private void readObject(ObjectInputStream input) throws IOException {
    String[] paths = new String[readVarInt32(input)];
    int i = 0;
    try (InflaterInputStream in = new InflaterInputStream(input)) {
        if (i >= paths.length) {
            throw new IOException("too many paths, expected " + paths.length);
        }
        paths[i++] = readString(in);
    }
    if (i != paths.length) {
        throw new IOException("expected " + paths.length + "paths, got " + i);
    }
}
#method_after
private void readObject(ObjectInputStream input) throws IOException {
    paths = new String[readVarInt32(input)];
    try (InflaterInputStream in = new InflaterInputStream(input)) {
        for (int i = 0; i < paths.length; i++) {
            paths[i] = readString(in);
        }
    }
}
#end_block

#method_before
private void readObject(ObjectInputStream input) throws IOException {
    String[] paths = new String[readVarInt32(input)];
    int i = 0;
    try (InflaterInputStream in = new InflaterInputStream(input)) {
        if (i >= paths.length) {
            throw new IOException("too many paths, expected " + paths.length);
        }
        paths[i++] = readString(in);
    }
    if (i != paths.length) {
        throw new IOException("expected " + paths.length + "paths, got " + i);
    }
}
#method_after
private void readObject(ObjectInputStream input) throws IOException {
    paths = new String[readVarInt32(input)];
    try (InflaterInputStream in = new InflaterInputStream(input)) {
        for (int i = 0; i < paths.length; i++) {
            paths[i] = readString(in);
        }
    }
}
#end_block

#method_before
@Override
public int weigh(PatchListKey key, DiffSummary value) {
    // Size of PatchListKey, 64 bit JVM
    int size = 16 + 4 * 8 + 2 * 36;
    // Size of the list of paths ...
    for (String p : value.getPaths()) {
        size += p.length();
    }
    // ... plus new-line separators between paths
    size += value.getPaths().size() - 1;
    // ... plus insertions/deletions.
    size += 8;
    return size;
}
#method_after
@Override
public int weigh(PatchListKey key, DiffSummary value) {
    // Size of PatchListKey, 64 bit JVM
    int size = 16 + 4 * 8 + 2 * 36;
    // Size of the list of paths ...
    for (String p : value.getPaths()) {
        size += p.length();
    }
    // ... plus new-line separators between paths
    size += value.getPaths().size() - 1;
    return size;
}
#end_block

#method_before
public final boolean canEdit(Account.FieldName f) {
    return editableAccountFields().contains(f);
}
#method_after
public final boolean canEdit(AccountFieldName f) {
    return editableAccountFields().contains(f);
}
#end_block

#method_before
public final List<Account.FieldName> editableAccountFields() {
    List<Account.FieldName> fields = new ArrayList<>();
    for (String f : Natives.asList(_editableAccountFields())) {
        fields.add(Account.FieldName.valueOf(f));
    }
    return fields;
}
#method_after
public final List<AccountFieldName> editableAccountFields() {
    List<AccountFieldName> fields = new ArrayList<>();
    for (String f : Natives.asList(_editableAccountFields())) {
        fields.add(AccountFieldName.valueOf(f));
    }
    return fields;
}
#end_block

#method_before
public final boolean siteHasUsernames() {
    if (isCustomExtension() && httpPasswordUrl() != null && !canEdit(FieldName.USER_NAME)) {
        return false;
    }
    return true;
}
#method_after
public final boolean siteHasUsernames() {
    if (isCustomExtension() && httpPasswordUrl() != null && !canEdit(AccountFieldName.USER_NAME)) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (passwordMatchesTheUserGeneratedOne(who, username, password)) {
        setUserIdentified(who.getAccount().getId());
        return true;
    } else if (!authConfig.isLdapAuthType()) {
        log.warn("Authentication failed for {}: password does not match the one" + " stored in Gerrit", username);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        setUserIdentified(whoAuthResult.getAccountId());
        return true;
    } catch (NoSuchUserException e) {
        if (password.equals(who.getPassword(who.getUserName()))) {
            setUserIdentified(who.getAccount().getId());
            return true;
        }
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AuthenticationFailedException e) {
        log.warn("Authentication failed for " + username + ": " + e.getMessage());
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#method_after
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    final String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    final byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String password = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(password)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    GitBasicAuthPolicy gitBasicAuthPolicy = authConfig.getGitBasicAuthPolicy();
    if (gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP || gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP_LDAP) {
        if (passwordMatchesTheUserGeneratedOne(who, username, password)) {
            return succeedAuthentication(who);
        }
    }
    if (gitBasicAuthPolicy == GitBasicAuthPolicy.HTTP) {
        return failAuthentication(rsp, username);
    }
    AuthRequest whoAuth = AuthRequest.forUser(username);
    whoAuth.setPassword(password);
    try {
        AuthResult whoAuthResult = accountManager.authenticate(whoAuth);
        setUserIdentified(whoAuthResult.getAccountId());
        return true;
    } catch (NoSuchUserException e) {
        if (password.equals(who.getPassword(who.getUserName()))) {
            return succeedAuthentication(who);
        }
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AuthenticationFailedException e) {
        log.warn("Authentication failed for " + username + ": " + e.getMessage());
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#end_block

#method_before
private void setUserIdentified(final Account.Id id) {
    WebSession ws = session.get();
    ws.setUserAccountId(id);
    ws.setAccessPathOk(AccessPath.GIT, true);
    ws.setAccessPathOk(AccessPath.REST_API, true);
}
#method_after
private void setUserIdentified(Account.Id id) {
    WebSession ws = session.get();
    ws.setUserAccountId(id);
    ws.setAccessPathOk(AccessPath.GIT, true);
    ws.setAccessPathOk(AccessPath.REST_API, true);
}
#end_block

#method_before
private void generateSshHostKeys() throws InterruptedException, IOException {
    if (// 
    !exists(site.ssh_key) && // 
    !exists(site.ssh_rsa) && !exists(site.ssh_dsa)) {
        System.err.print("Generating SSH host key ...");
        System.err.flush();
        if (SecurityUtils.isBouncyCastleRegistered()) {
            // Generate the SSH daemon host key using ssh-keygen.
            // 
            final String comment = "gerrit-code-review@" + hostname();
            System.err.print(" rsa...");
            System.err.flush();
            ProcessBuilder sshKeygenRsa = new // 
            ProcessBuilder(// 
            "ssh-keygen", // 
            "-q", // 
            "-t", // 
            "rsa", // 
            "-P", // 
            "", // 
            "-C", // 
            comment, // 
            "-f", // 
            site.ssh_rsa.toAbsolutePath().toString());
            sshKeygenRsa.redirectError(Redirect.INHERIT);
            sshKeygenRsa.redirectOutput(Redirect.INHERIT);
            sshKeygenRsa.start().waitFor();
            System.err.print(" dsa...");
            System.err.flush();
            ProcessBuilder sshKeygenDsa = new // 
            ProcessBuilder(// 
            "ssh-keygen", // 
            "-q", // 
            "-t", // 
            "dsa", // 
            "-P", // 
            "", // 
            "-C", // 
            comment, // 
            "-f", // 
            site.ssh_dsa.toAbsolutePath().toString());
            sshKeygenDsa.redirectError(Redirect.INHERIT);
            sshKeygenDsa.redirectOutput(Redirect.INHERIT);
            sshKeygenDsa.start().waitFor();
        } else {
            // Generate the SSH daemon host key ourselves. This is complex
            // because SimpleGeneratorHostKeyProvider doesn't mark the data
            // file as only readable by us, exposing the private key for a
            // short period of time. We try to reduce that risk by creating
            // the key within a temporary directory.
            // 
            Path tmpdir = site.etc_dir.resolve("tmp.sshkeygen");
            try {
                Files.createDirectory(tmpdir);
            } catch (IOException e) {
                throw die("Cannot create directory " + tmpdir, e);
            }
            chmod(0600, tmpdir);
            Path tmpkey = tmpdir.resolve(site.ssh_key.getFileName().toString());
            SimpleGeneratorHostKeyProvider p;
            System.err.print(" rsa(simple)...");
            System.err.flush();
            p = new SimpleGeneratorHostKeyProvider();
            p.setPath(tmpkey.toAbsolutePath().toString());
            p.setAlgorithm("RSA");
            // forces the key to generate.
            p.loadKeys();
            chmod(0600, tmpkey);
            try {
                Files.move(tmpkey, site.ssh_key);
            } catch (IOException e) {
                throw die("Cannot rename " + tmpkey + " to " + site.ssh_key, e);
            }
            try {
                Files.delete(tmpdir);
            } catch (IOException e) {
                throw die("Cannot delete " + tmpdir, e);
            }
        }
        System.err.println(" done");
    }
}
#method_after
private void generateSshHostKeys() throws InterruptedException, IOException {
    if (// 
    !exists(site.ssh_key) && // 
    !exists(site.ssh_rsa) && !exists(site.ssh_dsa)) {
        System.err.print("Generating SSH host key ...");
        System.err.flush();
        if (SecurityUtils.isBouncyCastleRegistered()) {
            // Generate the SSH daemon host key using ssh-keygen.
            // 
            final String comment = "gerrit-code-review@" + hostname();
            System.err.print(" rsa...");
            System.err.flush();
            new ProcessBuilder("ssh-keygen", "-q", /* quiet */
            "-t", "rsa", "-P", "", "-C", comment, "-f", site.ssh_rsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
            System.err.print(" dsa...");
            System.err.flush();
            new ProcessBuilder("ssh-keygen", "-q", /* quiet */
            "-t", "dsa", "-P", "", "-C", comment, "-f", site.ssh_dsa.toAbsolutePath().toString()).redirectError(Redirect.INHERIT).redirectOutput(Redirect.INHERIT).start().waitFor();
        } else {
            // Generate the SSH daemon host key ourselves. This is complex
            // because SimpleGeneratorHostKeyProvider doesn't mark the data
            // file as only readable by us, exposing the private key for a
            // short period of time. We try to reduce that risk by creating
            // the key within a temporary directory.
            // 
            Path tmpdir = site.etc_dir.resolve("tmp.sshkeygen");
            try {
                Files.createDirectory(tmpdir);
            } catch (IOException e) {
                throw die("Cannot create directory " + tmpdir, e);
            }
            chmod(0600, tmpdir);
            Path tmpkey = tmpdir.resolve(site.ssh_key.getFileName().toString());
            SimpleGeneratorHostKeyProvider p;
            System.err.print(" rsa(simple)...");
            System.err.flush();
            p = new SimpleGeneratorHostKeyProvider();
            p.setPath(tmpkey.toAbsolutePath());
            p.setAlgorithm("RSA");
            // forces the key to generate.
            p.loadKeys();
            chmod(0600, tmpkey);
            try {
                Files.move(tmpkey, site.ssh_key);
            } catch (IOException e) {
                throw die("Cannot rename " + tmpkey + " to " + site.ssh_key, e);
            }
            try {
                Files.delete(tmpdir);
            } catch (IOException e) {
                throw die("Cannot delete " + tmpdir, e);
            }
        }
        System.err.println(" done");
    }
}
#end_block

#method_before
public static int mainImpl(final String[] argv) throws Exception {
    if (argv.length == 0) {
        File me;
        try {
            me = getDistributionArchive();
        } catch (FileNotFoundException e) {
            me = null;
        }
        String jar = me != null ? me.getName() : "gerrit.war";
        System.err.println("Gerrit Code Review " + getVersion(me));
        System.err.println("usage: java -jar " + jar + " command [ARG ...]");
        System.err.println();
        System.err.println("The most commonly used commands are:");
        System.err.println("  init            Initialize a Gerrit installation");
        System.err.println("  rebuild-notedb  Rebuild the review notes database");
        System.err.println("  reindex         Rebuild the secondary index");
        System.err.println("  daemon          Run the Gerrit network daemons");
        System.err.println("  gsql            Run the interactive query console");
        System.err.println("  version         Display the build version number");
        System.err.println();
        System.err.println("  ls              List files available for cat");
        System.err.println("  cat FILE        Display a file from the archive");
        System.err.println();
        return 1;
    }
    // 
    if ("-v".equals(argv[0]) || "--version".equals(argv[0])) {
        argv[0] = "version";
    } else if ("-p".equals(argv[0]) || "--cat".equals(argv[0])) {
        argv[0] = "cat";
    } else if ("-l".equals(argv[0]) || "--ls".equals(argv[0])) {
        argv[0] = "ls";
    }
    // Run the application class
    // 
    final ClassLoader cl = libClassLoader(isProlog(programClassName(argv[0])));
    Thread.currentThread().setContextClassLoader(cl);
    return invokeProgram(cl, argv);
}
#method_after
public static int mainImpl(final String[] argv) throws Exception {
    if (argv.length == 0) {
        File me;
        try {
            me = getDistributionArchive();
        } catch (FileNotFoundException e) {
            me = null;
        }
        String jar = me != null ? me.getName() : "gerrit.war";
        System.err.println("Gerrit Code Review " + getVersion(me));
        System.err.println("usage: java -jar " + jar + " command [ARG ...]");
        System.err.println();
        System.err.println("The most commonly used commands are:");
        System.err.println("  init            Initialize a Gerrit installation");
        System.err.println("  reindex         Rebuild the secondary index");
        System.err.println("  daemon          Run the Gerrit network daemons");
        System.err.println("  gsql            Run the interactive query console");
        System.err.println("  version         Display the build version number");
        System.err.println();
        System.err.println("  ls              List files available for cat");
        System.err.println("  cat FILE        Display a file from the archive");
        System.err.println();
        return 1;
    }
    // 
    if ("-v".equals(argv[0]) || "--version".equals(argv[0])) {
        argv[0] = "version";
    } else if ("-p".equals(argv[0]) || "--cat".equals(argv[0])) {
        argv[0] = "cat";
    } else if ("-l".equals(argv[0]) || "--ls".equals(argv[0])) {
        argv[0] = "ls";
    }
    // Run the application class
    // 
    final ClassLoader cl = libClassLoader(isProlog(programClassName(argv[0])));
    Thread.currentThread().setContextClassLoader(cl);
    return invokeProgram(cl, argv);
}
#end_block

#method_before
private static FileSystem newZipFileSystem(Path zip) throws IOException {
    return FileSystems.newFileSystem(URI.create("jar:" + zip.toUri()), Collections.<String, String>emptyMap());
}
#method_after
public static FileSystem newZipFileSystem(Path zip) throws IOException {
    return FileSystems.newFileSystem(URI.create("jar:" + zip.toUri()), Collections.<String, String>emptyMap());
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new ChangeCacheImplModule(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new ChangeCleanupRunner.Module());
    }
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new EventBroker.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new ChangeCacheImplModule(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new ChangeCleanupRunner.Module());
    }
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private AbstractModule createIndexModule() {
    if (slave) {
        return new DummyIndexModule();
    }
    switch(indexType) {
        case LUCENE:
            return luceneModule != null ? luceneModule : new LuceneIndexModule();
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
}
#method_after
private AbstractModule createIndexModule() {
    if (slave) {
        return new DummyIndexModule();
    }
    switch(indexType) {
        case LUCENE:
            return luceneModule != null ? luceneModule : LuceneIndexModule.latestVersionWithOnlineUpgrade();
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(RequestMetricsFilter.module());
    modules.add(H2CacheBasedWebSession.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(StaticModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(RequestMetricsFilter.module());
    modules.add(H2CacheBasedWebSession.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    // StaticModule contains a "/*" wildcard, place it last.
    modules.add(sysInjector.getInstance(StaticModule.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
private static Optional<SubmitRecord> findOkRecord(Collection<SubmitRecord> in) {
    if (in == null) {
        return Optional.absent();
    }
    return Iterables.tryFind(in, new Predicate<SubmitRecord>() {

        @Override
        public boolean apply(SubmitRecord input) {
            return input.status == SubmitRecord.Status.OK;
        }
    });
}
#method_after
private static Optional<SubmitRecord> findOkRecord(Collection<SubmitRecord> in) {
    if (in == null) {
        return Optional.absent();
    }
    return Iterables.tryFind(in, r -> r.status == SubmitRecord.Status.OK);
}
#end_block

#method_before
private List<SubmitStrategy> getSubmitStrategies(Map<Branch.NameKey, BranchBatch> toSubmit, SubmoduleOp submoduleOp, boolean dryrun) throws IntegrationException {
    List<SubmitStrategy> strategies = new ArrayList<>();
    Set<Branch.NameKey> allBranches = submoduleOp.getBranchesInOrder();
    for (Branch.NameKey branch : allBranches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        if (toSubmit.containsKey(branch)) {
            BranchBatch submitting = toSubmit.get(branch);
            OpenBranch ob = or.getBranch(branch);
            checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
            Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
            ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
            SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip, submoduleOp, dryrun);
            strategies.add(strategy);
            strategy.addOps(or.getUpdate(), commitsToSubmit);
        } else {
            // no open change for this branch
            // add submodule triggered op into BatchUpdate
            submoduleOp.addOp(or.getUpdate(), branch);
        }
    }
    return strategies;
}
#method_after
private List<SubmitStrategy> getSubmitStrategies(Map<Branch.NameKey, BranchBatch> toSubmit, SubmoduleOp submoduleOp, boolean dryrun) throws IntegrationException {
    List<SubmitStrategy> strategies = new ArrayList<>();
    Set<Branch.NameKey> allBranches = submoduleOp.getBranchesInOrder();
    for (Branch.NameKey branch : allBranches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        if (toSubmit.containsKey(branch)) {
            BranchBatch submitting = toSubmit.get(branch);
            OpenBranch ob = or.getBranch(branch);
            checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
            Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
            ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
            SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip, submoduleOp, dryrun);
            strategies.add(strategy);
            strategy.addOps(or.getUpdate(), commitsToSubmit);
            if (submitting.submitType().equals(SubmitType.FAST_FORWARD_ONLY) && submoduleOp.hasSubscription(branch)) {
                submoduleOp.addOp(or.getUpdate(), branch);
            }
        } else {
            // no open change for this branch
            // add submodule triggered op into BatchUpdate
            submoduleOp.addOp(or.getUpdate(), branch);
        }
    }
    return strategies;
}
#end_block

#method_before
@Test
public void testProjectNoSubscriptionWholeTopic() throws Exception {
    TestRepository<?> repoA = createProjectWithPush("project-a");
    TestRepository<?> repoB = createProjectWithPush("project-b");
    // bootstrap the dev branch
    ObjectId a0 = pushChangeTo(repoA, "dev");
    // bootstrap the dev branch
    ObjectId b0 = pushChangeTo(repoB, "dev");
    // create a change for master branch in repo a
    ObjectId aHead = pushChangeTo(repoA, "refs/for/master", "master.txt", "content master", "some message in master.txt", "same-topic");
    // create a change for master branch in repo b
    ObjectId bHead = pushChangeTo(repoB, "refs/for/master", "master.txt", "content master", "some message in master.txt", "same-topic");
    // create a change for dev branch in repo a
    repoA.reset(a0);
    ObjectId aDevHead = pushChangeTo(repoA, "refs/for/dev", "dev.txt", "content dev", "some message in dev.txt", "same-topic");
    // create a change for dev branch in repo b
    repoB.reset(b0);
    ObjectId bDevHead = pushChangeTo(repoB, "refs/for/dev", "dev.txt", "content dev", "some message in dev.txt", "same-topic");
    approve(getChangeId(repoA, aHead).get());
    approve(getChangeId(repoB, bHead).get());
    approve(getChangeId(repoA, aDevHead).get());
    approve(getChangeId(repoB, bDevHead).get());
    gApi.changes().id(getChangeId(repoA, aDevHead).get()).current().submit();
    assertThat(getRemoteHead(name("project-a"), "refs/heads/master").getShortMessage()).contains("some message in master.txt");
    assertThat(getRemoteHead(name("project-a"), "refs/heads/dev").getShortMessage()).contains("some message in dev.txt");
    assertThat(getRemoteHead(name("project-b"), "refs/heads/master").getShortMessage()).contains("some message in master.txt");
    assertThat(getRemoteHead(name("project-b"), "refs/heads/dev").getShortMessage()).contains("some message in dev.txt");
}
#method_after
@Test
public void testProjectNoSubscriptionWholeTopic() throws Exception {
    TestRepository<?> repoA = createProjectWithPush("project-a");
    TestRepository<?> repoB = createProjectWithPush("project-b");
    // bootstrap the dev branch
    ObjectId a0 = pushChangeTo(repoA, "dev");
    // bootstrap the dev branch
    ObjectId b0 = pushChangeTo(repoB, "dev");
    // create a change for master branch in repo a
    ObjectId aHead = pushChangeTo(repoA, "refs/for/master", "master.txt", "content master A", "some message in a master.txt", "same-topic");
    // create a change for master branch in repo b
    ObjectId bHead = pushChangeTo(repoB, "refs/for/master", "master.txt", "content master B", "some message in b master.txt", "same-topic");
    // create a change for dev branch in repo a
    repoA.reset(a0);
    ObjectId aDevHead = pushChangeTo(repoA, "refs/for/dev", "dev.txt", "content dev A", "some message in a dev.txt", "same-topic");
    // create a change for dev branch in repo b
    repoB.reset(b0);
    ObjectId bDevHead = pushChangeTo(repoB, "refs/for/dev", "dev.txt", "content dev B", "some message in b dev.txt", "same-topic");
    approve(getChangeId(repoA, aHead).get());
    approve(getChangeId(repoB, bHead).get());
    approve(getChangeId(repoA, aDevHead).get());
    approve(getChangeId(repoB, bDevHead).get());
    gApi.changes().id(getChangeId(repoA, aDevHead).get()).current().submit();
    assertThat(getRemoteHead(name("project-a"), "refs/heads/master").getShortMessage()).contains("some message in a master.txt");
    assertThat(getRemoteHead(name("project-a"), "refs/heads/dev").getShortMessage()).contains("some message in a dev.txt");
    assertThat(getRemoteHead(name("project-b"), "refs/heads/master").getShortMessage()).contains("some message in b master.txt");
    assertThat(getRemoteHead(name("project-b"), "refs/heads/dev").getShortMessage()).contains("some message in b dev.txt");
}
#end_block

#method_before
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber) throws IOException, SubmoduleException {
    OpenRepo or;
    try {
        or = orm.openRepo(subscriber.getParentKey());
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    CodeReviewCommit currentCommit;
    Ref r = or.repo.exactRef(subscriber.get());
    if (r == null) {
        throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
    }
    currentCommit = or.rw.parseCommit(r.getObjectId());
    StringBuilder msgbuf = new StringBuilder("");
    PersonIdent author = null;
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        RevCommit newCommit = updateSubmodule(dc, ed, msgbuf, s);
        if (newCommit != null) {
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                author = myIdent;
            }
        }
    }
    ed.finish();
    ObjectId newTreeId = dc.writeTree(or.ins);
    // Gitlinks are already in the branch, return null
    if (newTreeId.equals(currentCommit.getTree())) {
        return null;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(newTreeId);
    commit.setParentId(currentCommit);
    StringBuilder commitMsg = new StringBuilder("Update git submodules\n\n");
    if (verboseSuperProject != VerboseSuperprojectUpdate.FALSE) {
        commitMsg.append(msgbuf);
    }
    commit.setMessage(commitMsg.toString());
    commit.setAuthor(author);
    commit.setCommitter(myIdent);
    ObjectId id = or.ins.insert(commit);
    return or.rw.parseCommit(id);
}
#method_after
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber) throws IOException, SubmoduleException {
    OpenRepo or;
    try {
        or = orm.openRepo(subscriber.getParentKey());
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    CodeReviewCommit currentCommit;
    if (branchTips.containsKey(subscriber)) {
        currentCommit = branchTips.get(subscriber);
    } else {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        currentCommit = or.rw.parseCommit(r.getObjectId());
    }
    StringBuilder msgbuf = new StringBuilder("");
    PersonIdent author = null;
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        RevCommit newCommit = updateSubmodule(dc, ed, msgbuf, s);
        if (newCommit != null) {
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                author = myIdent;
            }
        }
    }
    ed.finish();
    ObjectId newTreeId = dc.writeTree(or.ins);
    // Gitlinks are already in the branch, return null
    if (newTreeId.equals(currentCommit.getTree())) {
        return null;
    }
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(newTreeId);
    commit.setParentId(currentCommit);
    StringBuilder commitMsg = new StringBuilder("Update git submodules\n\n");
    if (verboseSuperProject != VerboseSuperprojectUpdate.FALSE) {
        commitMsg.append(msgbuf);
    }
    commit.setMessage(commitMsg.toString());
    commit.setAuthor(author);
    commit.setCommitter(myIdent);
    ObjectId id = or.ins.insert(commit);
    return or.rw.parseCommit(id);
}
#end_block

#method_before
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, CodeReviewCommit currentCommit) throws IOException, SubmoduleException {
    OpenRepo or;
    try {
        or = orm.openRepo(subscriber.getParentKey());
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    StringBuilder msgbuf = new StringBuilder("");
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        updateSubmodule(dc, ed, msgbuf, s);
    }
    ed.finish();
    ObjectId newTreeId = dc.writeTree(or.ins);
    // Gitlinks are already updated, just return the commit
    if (newTreeId.equals(currentCommit.getTree())) {
        return currentCommit;
    }
    or.rw.parseBody(currentCommit);
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(newTreeId);
    commit.setParentIds(currentCommit.getParents());
    if (verboseSuperProject != VerboseSuperprojectUpdate.FALSE) {
        // TODO:czhen handle cherrypick footer
        commit.setMessage(currentCommit.getFullMessage() + "\n\n* submodules:\n" + msgbuf.toString());
    } else {
        commit.setMessage(currentCommit.getFullMessage());
    }
    commit.setAuthor(currentCommit.getAuthorIdent());
    commit.setCommitter(myIdent);
    ObjectId id = or.ins.insert(commit);
    return or.rw.parseCommit(id);
}
#method_after
public CodeReviewCommit composeGitlinksCommit(final Branch.NameKey subscriber, CodeReviewCommit currentCommit) throws IOException, SubmoduleException {
    OpenRepo or;
    try {
        or = orm.openRepo(subscriber.getParentKey());
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    StringBuilder msgbuf = new StringBuilder("");
    DirCache dc = readTree(or.rw, currentCommit);
    DirCacheEditor ed = dc.editor();
    for (SubmoduleSubscription s : targets.get(subscriber)) {
        updateSubmodule(dc, ed, msgbuf, s);
    }
    ed.finish();
    ObjectId newTreeId = dc.writeTree(or.ins);
    // Gitlinks are already updated, just return the commit
    if (newTreeId.equals(currentCommit.getTree())) {
        return currentCommit;
    }
    or.rw.parseBody(currentCommit);
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(newTreeId);
    commit.setParentIds(currentCommit.getParents());
    if (verboseSuperProject != VerboseSuperprojectUpdate.FALSE) {
        // TODO:czhen handle cherrypick footer
        commit.setMessage(currentCommit.getFullMessage() + "\n\n* submodules:\n" + msgbuf.toString());
    } else {
        commit.setMessage(currentCommit.getFullMessage());
    }
    commit.setAuthor(currentCommit.getAuthorIdent());
    commit.setCommitter(myIdent);
    ObjectId id = or.ins.insert(commit);
    CodeReviewCommit newCommit = or.rw.parseCommit(id);
    newCommit.copyFrom(currentCommit);
    return newCommit;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                accounts = parseAccount(pair.getValue());
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                accounts = parseAccount(value);
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = args.listMembers.get().setRecursive(true).apply(group).stream().map(a -> new Account.Id(a._accountId)).collect(toSet());
        int maxLimit = args.indexConfig.maxLimit();
        if (allMembers.size() > maxLimit) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxLimit));
        } else {
            accounts = allMembers;
        }
    }
    return new LabelPredicate(args.projectCache, args.changeControlGenericFactory, args.userFactory, args.db, name, accounts, group);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    // Special case: votes by owners can be tracked with ",owner":
    // label:Code-Review+2,owner
    // label:Code-Review+2,user=owner
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                if (pair.getValue().equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(pair.getValue());
                }
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                if (value.equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(value);
                }
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = args.listMembers.get().setRecursive(true).apply(group).stream().map(a -> new Account.Id(a._accountId)).collect(toSet());
        int maxLimit = args.indexConfig.maxLimit();
        if (allMembers.size() > maxLimit) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxLimit));
        } else {
            accounts = allMembers;
        }
    }
    return new LabelPredicate(args, name, accounts, group);
}
#end_block

#method_before
private Predicate<ChangeData> starredby(Set<Account.Id> who) throws QueryParseException {
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(who.size());
    for (Account.Id id : who) {
        p.add(starredby(id));
    }
    return Predicate.or(p);
}
#method_after
private Predicate<ChangeData> starredby(Set<Account.Id> who) {
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(who.size());
    for (Account.Id id : who) {
        p.add(starredby(id));
    }
    return Predicate.or(p);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private Predicate<ChangeData> starredby(Account.Id who) throws QueryParseException {
    if (args.getSchema().hasField(ChangeField.STAR)) {
        return new StarPredicate(who, StarredChangesUtil.DEFAULT_LABEL);
    }
    try {
        // git
        return new IsStarredByLegacyPredicate(who, args.starredChangesUtil.byAccount(who, StarredChangesUtil.DEFAULT_LABEL));
    } catch (OrmException e) {
        throw new QueryParseException("Failed to query starred changes.", e);
    }
}
#method_after
private Predicate<ChangeData> starredby(Account.Id who) {
    return new StarPredicate(who, StarredChangesUtil.DEFAULT_LABEL);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private Predicate<ChangeData> draftby(Account.Id who) {
    return args.getSchema().hasField(ChangeField.DRAFTBY) ? new HasDraftByPredicate(who) : new HasDraftByLegacyPredicate(args, who);
}
#method_after
private Predicate<ChangeData> draftby(Account.Id who) {
    return new HasDraftByPredicate(who);
}
#end_block

#method_before
public List<ChangeData> bySubmissionId(String cs) throws OrmException {
    if (Strings.isNullOrEmpty(cs) || !schema().hasField(SUBMISSIONID)) {
        return Collections.emptyList();
    }
    return query(new SubmissionIdPredicate(cs));
}
#method_after
public List<ChangeData> bySubmissionId(String cs) throws OrmException {
    if (Strings.isNullOrEmpty(cs)) {
        return Collections.emptyList();
    }
    return query(new SubmissionIdPredicate(cs));
}
#end_block

#method_before
public static String formatLabel(String label, int value, Account.Id accountId) {
    return label.toLowerCase() + (value >= 0 ? "+" : "") + value + (accountId != null ? "," + accountId.get() : "");
}
#method_after
public static String formatLabel(String label, int value, Account.Id accountId) {
    return label.toLowerCase() + (value >= 0 ? "+" : "") + value + (accountId != null ? "," + formatAccount(accountId) : "");
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException, RestApiException {
    if (!notesMigration.readChanges()) {
        throw new BadRequestException("Cannot add Assignee; NoteDb is disabled");
    }
    if (!ctx.getControl().canEditAssignee()) {
        throw new AuthException("Changing Assignee not permitted");
    }
    ChangeUpdate update = ctx.getUpdate(ctx.getChange().currentPatchSetId());
    Optional<Account.Id> oldAssigneeId = update.getNotes().getAssignee();
    if (input.assignee == null) {
        if (oldAssigneeId != null && oldAssigneeId.isPresent()) {
            throw new AuthException("Cannot set Assignee to empty");
        }
        return false;
    }
    Account oldAssignee = null;
    if (oldAssigneeId != null && oldAssigneeId.isPresent()) {
        oldAssignee = accountInfosFactory.create().get(oldAssigneeId.get());
    }
    IdentifiedUser newAssigneeUser = accounts.parse(input.assignee);
    if (oldAssigneeId != null && oldAssigneeId.equals(newAssigneeUser.getAccountId())) {
        newAssignee = oldAssignee;
        return false;
    }
    if (!newAssigneeUser.getAccount().isActive()) {
        throw new UnprocessableEntityException(String.format("Account of %s is not active", newAssigneeUser.getUserName()));
    }
    if (!ctx.getControl().forUser(newAssigneeUser).isRefVisible()) {
        throw new AuthException(String.format("Change %s is not visible to %s.", ctx.getChange().getChangeId(), newAssigneeUser.getUserName()));
    }
    try {
        for (AssigneeValidationListener validator : validationListeners) {
            validator.validateAssignee(change, newAssigneeUser.getAccount());
        }
    } catch (ValidationException e) {
        throw new BadRequestException(e.getMessage());
    }
    update.setAssignee(Optional.fromNullable(newAssigneeUser.getAccountId()));
    this.newAssignee = newAssigneeUser.getAccount();
    addMessage(ctx, update, oldAssignee);
    return true;
}
#method_after
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException, RestApiException {
    if (!notesMigration.readChanges()) {
        throw new BadRequestException("Cannot add Assignee; NoteDb is disabled");
    }
    if (!ctx.getControl().canEditAssignee()) {
        throw new AuthException("Changing Assignee not permitted");
    }
    ChangeUpdate update = ctx.getUpdate(ctx.getChange().currentPatchSetId());
    Optional<Account.Id> oldAssigneeId = update.getNotes().getAssignee();
    if (input.assignee == null) {
        if (oldAssigneeId != null && oldAssigneeId.isPresent()) {
            throw new AuthException("Cannot set Assignee to empty");
        }
        return false;
    }
    Account oldAssignee = null;
    if (oldAssigneeId != null && oldAssigneeId.isPresent()) {
        oldAssignee = accountInfosFactory.create().get(oldAssigneeId.get());
    }
    IdentifiedUser newAssigneeUser = accounts.parse(input.assignee);
    if (oldAssigneeId != null && oldAssigneeId.equals(newAssigneeUser.getAccountId())) {
        newAssignee = oldAssignee;
        return false;
    }
    if (!newAssigneeUser.getAccount().isActive()) {
        throw new UnprocessableEntityException(String.format("Account of %s is not active", newAssigneeUser.getUserName()));
    }
    if (!ctx.getControl().forUser(newAssigneeUser).isRefVisible()) {
        throw new AuthException(String.format("Change %s is not visible to %s.", ctx.getChange().getChangeId(), newAssigneeUser.getUserName()));
    }
    try {
        for (AssigneeValidationListener validator : validationListeners) {
            validator.validateAssignee(change, newAssigneeUser.getAccount());
        }
    } catch (ValidationException e) {
        throw new BadRequestException(e.getMessage());
    }
    update.setAssignee(newAssigneeUser.getAccountId());
    this.newAssignee = newAssigneeUser.getAccount();
    addMessage(ctx, update, oldAssignee);
    return true;
}
#end_block

#method_before
@Override
public void validateAssignee(Change change, Account assignee) throws ValidationException {
    try {
        if (queryProcessor.query(queryBuilder.assignee(assignee.getPreferredEmail())).entities().size() > MAX_ASSIGNED_CHANGES) {
            throw new ValidationException("Cannot assign user to more than " + MAX_ASSIGNED_CHANGES + " changes");
        }
    } catch (OrmException e1) {
    } catch (QueryParseException e2) {
    }
}
#method_after
@Override
public void validateAssignee(Change change, Account assignee) throws ValidationException {
    try {
        if (queryProcessor.query(queryBuilder.assignee(assignee.getPreferredEmail())).entities().size() > MAX_ASSIGNED_CHANGES) {
            throw new ValidationException("Cannot assign user to more than " + MAX_ASSIGNED_CHANGES + " changes");
        }
    } catch (OrmException | QueryParseException e) {
        log.error("Failed to validate assignee for change " + change.getId(), e);
    // Allow assignee.
    }
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    if (!showLegacyId) {
        fmt.addStyleName(row, C_ID, Gerrit.RESOURCES.css().dataCellHidden());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().cSTATUS());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_ASSIGNEE, Gerrit.info().change().showAssignee() ? Gerrit.RESOURCES.css().cASSIGNEE() : Gerrit.RESOURCES.css().dataCellHidden());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    fmt.addStyleName(row, C_SIZE, Gerrit.RESOURCES.css().cSIZE());
    for (int i = C_SIZE + 1; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#method_after
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    if (!showLegacyId) {
        fmt.addStyleName(row, C_ID, Gerrit.RESOURCES.css().dataCellHidden());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().cSTATUS());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_ASSIGNEE, showAssignee ? Gerrit.RESOURCES.css().cASSIGNEE() : Gerrit.RESOURCES.css().dataCellHidden());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    fmt.addStyleName(row, C_SIZE, Gerrit.RESOURCES.css().cSIZE());
    for (int i = C_SIZE + 1; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacyId(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacyId()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    if (Gerrit.info().change().showAssignee()) {
        if (c.assignee() != null) {
            table.setWidget(row, C_ASSIGNEE, new AssigneeLinkPanel(c.assignee()));
            if (Gerrit.getUserPreferences().highlightAssigneeInChangeTable() && c.assignee().getId().get() == Gerrit.getUserAccount().getId().get()) {
                table.getRowFormatter().addStyleName(row, Gerrit.RESOURCES.css().cASSIGNEDTOME());
            }
        } else {
            table.setText(row, C_ASSIGNEE, "");
        }
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.projectNameKey()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.projectNameKey(), c.status(), c.branch(), c.topic()));
    if (Gerrit.getUserPreferences().relativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (!Gerrit.getUserPreferences().sizeBarInChangeTable()) {
        table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    } else {
        table.setWidget(row, col, getSizeWidget(c));
        fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    }
    col++;
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        String info;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.getUserPreferences().reviewCategoryStrategy();
        if (label.rejected() != null) {
            user = label.rejected().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacyId(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacyId()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, AccountLinkPanel.withStatus(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    if (showAssignee) {
        if (c.assignee() != null) {
            table.setWidget(row, C_ASSIGNEE, AccountLinkPanel.forAssignee(c.assignee()));
            if (Gerrit.getUserPreferences().highlightAssigneeInChangeTable() && Objects.equals(c.assignee().getId(), Gerrit.getUserAccount().getId())) {
                table.getRowFormatter().addStyleName(row, Gerrit.RESOURCES.css().cASSIGNEDTOME());
            }
        } else {
            table.setText(row, C_ASSIGNEE, "");
        }
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.projectNameKey()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.projectNameKey(), c.status(), c.branch(), c.topic()));
    if (Gerrit.getUserPreferences().relativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (!Gerrit.getUserPreferences().sizeBarInChangeTable()) {
        table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    } else {
        table.setWidget(row, col, getSizeWidget(c));
        fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    }
    col++;
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        String info;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.getUserPreferences().reviewCategoryStrategy();
        if (label.rejected() != null) {
            user = label.rejected().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input).value();
    } catch (UpdateException e) {
        throw new RestApiException("Cannot set assigne", e);
    }
}
#method_after
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input).value();
    } catch (UpdateException e) {
        throw new RestApiException("Cannot set assignee", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo getAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = getAssignee.apply(change);
        if (r.isNone()) {
            return null;
        }
        return r.value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get assigne", e);
    }
}
#method_after
@Override
public AccountInfo getAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = getAssignee.apply(change);
        return r.isNone() ? null : r.value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get assignee", e);
    }
}
#end_block

#method_before
@Override
public Set<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw new RestApiException("Cannot get past assignees assigne", e);
    }
}
#method_after
@Override
public Set<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = (Response<AccountInfo>) deleteAssignee.apply(change, null);
        if (r.isNone()) {
            return null;
        }
        return r.value();
    } catch (UpdateException e) {
        throw new RestApiException("Cannot delete assigne", e);
    }
}
#method_after
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = deleteAssignee.apply(change, null);
        return r.isNone() ? null : r.value();
    } catch (UpdateException e) {
        throw new RestApiException("Cannot delete assignee", e);
    }
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    if (!showLegacyId) {
        fmt.addStyleName(row, C_ID, Gerrit.RESOURCES.css().dataCellHidden());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().cSTATUS());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_ASSIGNEE, Gerrit.info().change().showAssignee() ? Gerrit.RESOURCES.css().cASSIGNEE() : Gerrit.RESOURCES.css().dataCellHidden());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    fmt.addStyleName(row, C_SIZE, Gerrit.RESOURCES.css().cSIZE());
    for (int i = C_SIZE + 1; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#method_after
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    if (!showLegacyId) {
        fmt.addStyleName(row, C_ID, Gerrit.RESOURCES.css().dataCellHidden());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().cSTATUS());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_ASSIGNEE, showAssignee ? Gerrit.RESOURCES.css().cASSIGNEE() : Gerrit.RESOURCES.css().dataCellHidden());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    fmt.addStyleName(row, C_SIZE, Gerrit.RESOURCES.css().cSIZE());
    for (int i = C_SIZE + 1; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacyId(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacyId()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    if (Gerrit.info().change().showAssignee()) {
        if (c.assignee() != null) {
            table.setWidget(row, C_ASSIGNEE, new AssigneeLinkPanel(c.assignee()));
            if (c.assignee().getId().get() == Gerrit.getUserAccount().getId().get()) {
                table.getRowFormatter().addStyleName(row, Gerrit.RESOURCES.css().cASSIGNEDTOME());
            }
        } else {
            table.setText(row, C_ASSIGNEE, "");
        }
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.projectNameKey()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.projectNameKey(), c.status(), c.branch(), c.topic()));
    if (Gerrit.getUserPreferences().relativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (!Gerrit.getUserPreferences().sizeBarInChangeTable()) {
        table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    } else {
        table.setWidget(row, col, getSizeWidget(c));
        fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    }
    col++;
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        String info;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.getUserPreferences().reviewCategoryStrategy();
        if (label.rejected() != null) {
            user = label.rejected().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacyId(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacyId()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, AccountLinkPanel.withStatus(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    if (showAssignee) {
        if (c.assignee() != null) {
            table.setWidget(row, C_ASSIGNEE, AccountLinkPanel.forAssignee(c.assignee()));
            if (Objects.equals(c.assignee().getId(), Gerrit.getUserAccount().getId())) {
                table.getRowFormatter().addStyleName(row, Gerrit.RESOURCES.css().cASSIGNEDTOME());
            }
        } else {
            table.setText(row, C_ASSIGNEE, "");
        }
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.projectNameKey()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.projectNameKey(), c.status(), c.branch(), c.topic()));
    if (Gerrit.getUserPreferences().relativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (!Gerrit.getUserPreferences().sizeBarInChangeTable()) {
        table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    } else {
        table.setWidget(row, col, getSizeWidget(c));
        fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    }
    col++;
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        String info;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.getUserPreferences().reviewCategoryStrategy();
        if (label.rejected() != null) {
            user = label.rejected().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacyId(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacyId()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    if (c.assignee() != null) {
        table.setWidget(row, C_ASSIGNEE, new AssigneeLinkPanel(c.assignee()));
        if (c.assignee().getId().get() == Gerrit.getUserAccount().getId().get()) {
            table.getRowFormatter().addStyleName(row, Gerrit.RESOURCES.css().cASSIGNEDTOME());
        }
    } else {
        table.setText(row, C_ASSIGNEE, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.projectNameKey()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.projectNameKey(), c.status(), c.branch(), c.topic()));
    if (Gerrit.getUserPreferences().relativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (!Gerrit.getUserPreferences().sizeBarInChangeTable()) {
        table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    } else {
        table.setWidget(row, col, getSizeWidget(c));
        fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    }
    col++;
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        String info;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.getUserPreferences().reviewCategoryStrategy();
        if (label.rejected() != null) {
            user = label.rejected().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacyId(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacyId()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    if (c.assignee() != null) {
        table.setWidget(row, C_ASSIGNEE, new AssigneeLinkPanel(c.assignee()));
        if (Objects.equals(c.assignee().getId(), Gerrit.getUserAccount().getId())) {
            table.getRowFormatter().addStyleName(row, Gerrit.RESOURCES.css().cASSIGNEDTOME());
        }
    } else {
        table.setText(row, C_ASSIGNEE, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.projectNameKey()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.projectNameKey(), c.status(), c.branch(), c.topic()));
    if (Gerrit.getUserPreferences().relativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (!Gerrit.getUserPreferences().sizeBarInChangeTable()) {
        table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    } else {
        table.setWidget(row, col, getSizeWidget(c));
        fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    }
    col++;
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        String info;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.getUserPreferences().reviewCategoryStrategy();
        if (label.rejected() != null) {
            user = label.rejected().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
public static String assignedTo(AccountInfo ai) {
    if (ai.email() != null) {
        return ai.email();
    } else if (ai.name() != null) {
        return ai.name();
    } else if (ai._accountId() != 0) {
        return "" + ai._accountId();
    } else {
        return "";
    }
}
#method_after
public static String assignedTo(AccountInfo ai) {
    if (ai.email() != null) {
        return ai.email();
    } else if (ai.name() != null) {
        return ai.name();
    } else {
        return "";
    }
}
#end_block

#method_before
static Description forTestClass(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(configName, // @UseLocalDisk is only valid on methods.
    true, !has(NoHttpd.class, testDesc.getTestClass()), !has(Hermetic.class, testDesc.getTestClass()), // @GerritConfig is only valid on methods.
    null, // @GerritConfigs is only valid on methods.
    null);
}
#method_after
static Description forTestClass(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(configName, // @UseLocalDisk is only valid on methods.
    true, !has(NoHttpd.class, testDesc.getTestClass()), has(Sandboxed.class, testDesc.getTestClass()), // @GerritConfig is only valid on methods.
    null, // @GerritConfigs is only valid on methods.
    null);
}
#end_block

#method_before
static Description forTestMethod(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(configName, testDesc.getAnnotation(UseLocalDisk.class) == null, testDesc.getAnnotation(NoHttpd.class) == null && !has(NoHttpd.class, testDesc.getTestClass()), testDesc.getAnnotation(Hermetic.class) == null && !has(Hermetic.class, testDesc.getTestClass()), testDesc.getAnnotation(GerritConfig.class), testDesc.getAnnotation(GerritConfigs.class));
}
#method_after
static Description forTestMethod(org.junit.runner.Description testDesc, String configName) {
    return new AutoValue_GerritServer_Description(configName, testDesc.getAnnotation(UseLocalDisk.class) == null, testDesc.getAnnotation(NoHttpd.class) == null && !has(NoHttpd.class, testDesc.getTestClass()), testDesc.getAnnotation(Sandboxed.class) != null || has(Sandboxed.class, testDesc.getTestClass()), testDesc.getAnnotation(GerritConfig.class), testDesc.getAnnotation(GerritConfigs.class));
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) || classDesc.hermethic()) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    notesMigration.setFromEnv();
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    initSsh(admin);
    db = reviewDbProvider.open();
    Context ctx = newRequestContext(user);
    atrScope.set(ctx);
    userSshSession = ctx.getSession();
    userSshSession.open();
    ctx = newRequestContext(admin);
    atrScope.set(ctx);
    adminSshSession = ctx.getSession();
    adminSshSession.open();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    notesMigration.setFromEnv();
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    initSsh(admin);
    db = reviewDbProvider.open();
    Context ctx = newRequestContext(user);
    atrScope.set(ctx);
    userSshSession = ctx.getSession();
    userSshSession.open();
    ctx = newRequestContext(admin);
    atrScope.set(ctx);
    adminSshSession = ctx.getSession();
    adminSshSession.open();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeList.query("change:" + changeId.get() + " has:draft", Collections.<ListChangesOption>emptySet(), group.add(new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                hasDraftComments = result.length() > 0;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(final ChangeInfo info) {
            info.init();
            addExtensionPoints(info, initCurrentRevision(info));
            final RevisionInfo rev = info.revision(revision);
            CallbackGroup group = new CallbackGroup();
            loadCommit(rev, group);
            group.addListener(new GerritCallback<Void>() {

                @Override
                public void onSuccess(Void result) {
                    if (base == null && rev.commit().parents().length() > 1) {
                        base = Gerrit.getUserPreferences().defaultBaseForMerges().getBase();
                    }
                    loadConfigInfo(info, base);
                }
            });
            group.done();
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeList.query("change:" + changeId.get() + " has:draft", Collections.<ListChangesOption>emptySet(), group.add(new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                hasDraftComments = result.length() > 0;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(final ChangeInfo info) {
            info.init();
            addExtensionPoints(info, initCurrentRevision(info));
            final RevisionInfo rev = info.revision(revision);
            CallbackGroup group = new CallbackGroup();
            loadCommit(rev, group);
            group.addListener(new GerritCallback<Void>() {

                @Override
                public void onSuccess(Void result) {
                    if (base == null && rev.commit().parents().length() > 1) {
                        base = Gerrit.getUserPreferences().defaultBaseForMerges().getBase();
                    }
                    loadConfigInfo(info, base);
                    JsArray<MessageInfo> mAr = info.messages();
                    for (int i = 0; i < mAr.length(); i++) {
                        if (mAr.get(i).tag() != null) {
                            hideTaggedComments.setVisible(true);
                            break;
                        }
                    }
                }
            });
            group.done();
        }
    }));
}
#end_block

#method_before
private void addExtensionPoints(ChangeInfo change, RevisionInfo rev) {
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER, headerExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_BUTTONS, headerExtensionMiddle, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, headerExtensionRight, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, changeExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_RELATED_INFO_BLOCK, relatedExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_COMMIT_INFO_BLOCK, commitExtension, change, rev);
}
#method_after
private void addExtensionPoints(ChangeInfo change, RevisionInfo rev) {
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER, headerExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_BUTTONS, headerExtensionMiddle, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, headerExtensionRight, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, changeExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_RELATED_INFO_BLOCK, relatedExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_COMMIT_INFO_BLOCK, commitExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HISTORY_RIGHT_OF_BUTTONS, historyExtensionRight, change, rev);
}
#end_block

#method_before
void set(ChangeInfo info) {
    this.changeId = info.legacyId();
    assigneeLink.setText(info.assignee().name());
    assigneeSuggestOracle.setChange(changeId);
    editAssigneeIcon.setVisible(Gerrit.isSignedIn());
}
#method_after
void set(ChangeInfo info) {
    this.changeId = info.legacyId();
    assigneeLink.setText(info.assignee() != null ? info.assignee().name() : "");
    assigneeSuggestOracle.setChange(changeId);
    editAssigneeIcon.setVisible(Gerrit.isSignedIn());
}
#end_block

#method_before
private void editAssignee(final String assignee) {
    if (assignee.isEmpty()) {
        // delete assignee
        return;
    }
    ChangeApi.assignee(changeId.get(), assignee, new GerritCallback<AccountInfo>() {

        @Override
        public void onSuccess(AccountInfo result) {
            onCloseForm();
            assigneeLink.setText(result.name());
        }

        @Override
        public void onFailure(Throwable err) {
            if (isSigninFailure(err)) {
                new NotSignedInDialog().center();
            } else {
                UIObject.setVisible(error, true);
                error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
            }
        }
    });
}
#method_after
private void editAssignee(final String assignee) {
    if (assignee.isEmpty()) {
        ChangeApi.deleteAssignee(changeId.get(), new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                assigneeLink.setText("");
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    } else {
        ChangeApi.setAssignee(changeId.get(), assignee, new GerritCallback<AccountInfo>() {

            @Override
            public void onSuccess(AccountInfo result) {
                onCloseForm();
                assigneeLink.setText(result.name());
            }

            @Override
            public void onFailure(Throwable err) {
                if (isSigninFailure(err)) {
                    new NotSignedInDialog().center();
                } else {
                    UIObject.setVisible(error, true);
                    error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
                }
            }
        });
    }
}
#end_block

#method_before
@Override
public Response<Set<AccountInfo>> apply(ChangeResource rsrc) throws RestApiException {
    try {
        Set<Account.Id> pastAssignees = rsrc.getControl().getNotes().load().getPastAssignees();
        if (pastAssignees == null) {
            return Response.ok(Collections.emptySet());
        }
        AccountInfoCacheFactory accountInfoFactory = accountInfos.create();
        return Response.ok(pastAssignees.stream().map(accountInfoFactory::get).map(AccountJson::toAccountInfo).collect(toSet()));
    } catch (OrmException e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#method_after
@Override
public Response<Set<AccountInfo>> apply(ChangeResource rsrc) throws OrmException {
    Set<Account.Id> pastAssignees = rsrc.getControl().getNotes().load().getPastAssignees();
    if (pastAssignees == null) {
        return Response.ok(Collections.emptySet());
    }
    AccountInfoCacheFactory accountInfoFactory = accountInfos.create();
    return Response.ok(pastAssignees.stream().map(accountInfoFactory::get).map(AccountJson::toAccountInfo).collect(toSet()));
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, allowsDrafts);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    // Special case: votes by owners can be tracked with ",change_owner":
    // label:Code-Review+2,user=0
    // label:Code-Review+2,change_owner
    // label:Code-Review+2,user=change_owner
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                accounts = parseAccount(pair.getValue());
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                accounts = parseAccount(value);
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = new HashSet<>(Lists.transform(args.listMembers.get().setRecursive(true).apply(group), new Function<AccountInfo, Account.Id>() {

            @Override
            public Account.Id apply(AccountInfo accountInfo) {
                return new Account.Id(accountInfo._accountId);
            }
        }));
        int maxLimit = args.indexConfig.maxLimit();
        if (allMembers.size() > maxLimit) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxLimit));
        } else {
            accounts = allMembers;
        }
    }
    return new LabelPredicate(args.projectCache, args.changeControlGenericFactory, args.userFactory, args.db, name, accounts, group);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    // Special case: votes by owners can be tracked with ",owner":
    // label:Code-Review+2,owner
    // label:Code-Review+2,user=owner
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                if (pair.getValue().equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(pair.getValue());
                }
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                if (value.equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(value);
                }
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = args.listMembers.get().setRecursive(true).apply(group).stream().map(a -> new Account.Id(a._accountId)).collect(toSet());
        int maxLimit = args.indexConfig.maxLimit();
        if (allMembers.size() > maxLimit) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxLimit));
        } else {
            accounts = allMembers;
        }
    }
    return new LabelPredicate(args, name, accounts, group);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(9);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return Collections.singleton(self());
    }
    if (who.equals(ARG_ID_CHANGE_OWNER) || who.equals(CHANGE_OWNER_ACCOUNT_ID.toString())) {
        return Collections.singleton(CHANGE_OWNER_ACCOUNT_ID);
    }
    Set<Account.Id> matches = args.accountResolver.findAll(who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#method_after
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#end_block

#method_before
private static String formatAccount(Account.Id accountId) {
    if (ChangeQueryBuilder.CHANGE_OWNER_ACCOUNT_ID.equals(accountId)) {
        return ChangeQueryBuilder.ARG_ID_CHANGE_OWNER;
    }
    return Integer.toString(accountId.get());
}
#method_after
private static String formatAccount(Account.Id accountId) {
    if (ChangeQueryBuilder.OWNER_ACCOUNT_ID.equals(accountId)) {
        return ChangeQueryBuilder.ARG_ID_OWNER;
    }
    return Integer.toString(accountId.get());
}
#end_block

#method_before
public List<ChangeNotes> create(ReviewDb db, Project.NameKey project, Collection<Change.Id> changeIds, Predicate<ChangeNotes> predicate) throws OrmException {
    List<ChangeNotes> notes = new ArrayList<>();
    if (args.migration.enabled()) {
        for (Change.Id cid : changeIds) {
            ChangeNotes cn = create(db, project, cid);
            if (cn.getChange() != null && predicate.apply(cn)) {
                notes.add(cn);
            }
        }
        return notes;
    }
    for (Change c : ReviewDbUtil.unwrapDb(db).changes().get(changeIds)) {
        if (c != null && project.equals(c.getDest().getParentKey())) {
            ChangeNotes cn = createFromChangeOnlyWhenNoteDbDisabled(c);
            if (predicate.apply(cn)) {
                notes.add(cn);
            }
        }
    }
    return notes;
}
#method_after
public List<ChangeNotes> create(ReviewDb db, Project.NameKey project, Collection<Change.Id> changeIds, Predicate<ChangeNotes> predicate) throws OrmException {
    List<ChangeNotes> notes = new ArrayList<>();
    if (args.migration.enabled()) {
        for (Change.Id cid : changeIds) {
            ChangeNotes cn = create(db, project, cid);
            if (cn.getChange() != null && predicate.test(cn)) {
                notes.add(cn);
            }
        }
        return notes;
    }
    for (Change c : ReviewDbUtil.unwrapDb(db).changes().get(changeIds)) {
        if (c != null && project.equals(c.getDest().getParentKey())) {
            ChangeNotes cn = createFromChangeOnlyWhenNoteDbDisabled(c);
            if (predicate.test(cn)) {
                notes.add(cn);
            }
        }
    }
    return notes;
}
#end_block

#method_before
public ListMultimap<Project.NameKey, ChangeNotes> create(ReviewDb db, Predicate<ChangeNotes> predicate) throws IOException, OrmException {
    ListMultimap<Project.NameKey, ChangeNotes> m = ArrayListMultimap.create();
    if (args.migration.readChanges()) {
        for (Project.NameKey project : projectCache.all()) {
            try (Repository repo = args.repoManager.openRepository(project)) {
                List<ChangeNotes> changes = scanNoteDb(repo, db, project);
                for (ChangeNotes cn : changes) {
                    if (predicate.apply(cn)) {
                        m.put(project, cn);
                    }
                }
            }
        }
    } else {
        for (Change change : ReviewDbUtil.unwrapDb(db).changes().all()) {
            ChangeNotes notes = createFromChangeOnlyWhenNoteDbDisabled(change);
            if (predicate.apply(notes)) {
                m.put(change.getProject(), notes);
            }
        }
    }
    return ImmutableListMultimap.copyOf(m);
}
#method_after
public ListMultimap<Project.NameKey, ChangeNotes> create(ReviewDb db, Predicate<ChangeNotes> predicate) throws IOException, OrmException {
    ListMultimap<Project.NameKey, ChangeNotes> m = ArrayListMultimap.create();
    if (args.migration.readChanges()) {
        for (Project.NameKey project : projectCache.all()) {
            try (Repository repo = args.repoManager.openRepository(project)) {
                List<ChangeNotes> changes = scanNoteDb(repo, db, project);
                for (ChangeNotes cn : changes) {
                    if (predicate.test(cn)) {
                        m.put(project, cn);
                    }
                }
            }
        }
    } else {
        for (Change change : ReviewDbUtil.unwrapDb(db).changes().all()) {
            ChangeNotes notes = createFromChangeOnlyWhenNoteDbDisabled(change);
            if (predicate.test(notes)) {
                m.put(change.getProject(), notes);
            }
        }
    }
    return ImmutableListMultimap.copyOf(m);
}
#end_block

#method_before
public ImmutableListMultimap<RevId, PatchLineComment> getComments() {
    return state.publishedComments();
}
#method_after
public ImmutableListMultimap<RevId, Comment> getComments() {
    return state.publishedComments();
}
#end_block

#method_before
public ImmutableListMultimap<RevId, PatchLineComment> getDraftComments(Account.Id author) throws OrmException {
    loadDraftComments(author);
    final Multimap<RevId, PatchLineComment> published = state.publishedComments();
    // Filter out any draft comments that also exist in the published map, in
    // case the update to All-Users to delete them during the publish operation
    // failed.
    Multimap<RevId, PatchLineComment> filtered = Multimaps.filterEntries(draftCommentNotes.getComments(), new Predicate<Map.Entry<RevId, PatchLineComment>>() {

        @Override
        public boolean apply(Map.Entry<RevId, PatchLineComment> in) {
            for (PatchLineComment c : published.get(in.getKey())) {
                if (c.getKey().equals(in.getValue().getKey())) {
                    return false;
                }
            }
            return true;
        }
    });
    return ImmutableListMultimap.copyOf(filtered);
}
#method_after
public ImmutableListMultimap<RevId, Comment> getDraftComments(Account.Id author) throws OrmException {
    loadDraftComments(author);
    final Multimap<RevId, Comment> published = state.publishedComments();
    // Filter out any draft comments that also exist in the published map, in
    // case the update to All-Users to delete them during the publish operation
    // failed.
    Multimap<RevId, Comment> filtered = Multimaps.filterEntries(draftCommentNotes.getComments(), (Map.Entry<RevId, Comment> e) -> {
        for (Comment c : published.get(e.getKey())) {
            if (c.key.equals(e.getValue().key)) {
                return false;
            }
        }
        return true;
    });
    return ImmutableListMultimap.copyOf(filtered);
}
#end_block

#method_before
public boolean containsComment(PatchLineComment c) throws OrmException {
    if (containsCommentPublished(c)) {
        return true;
    }
    loadDraftComments(c.getAuthor());
    return draftCommentNotes.containsComment(c);
}
#method_after
public boolean containsComment(Comment c) throws OrmException {
    if (containsCommentPublished(c)) {
        return true;
    }
    loadDraftComments(c.author.getId());
    return draftCommentNotes.containsComment(c);
}
#end_block

#method_before
public boolean containsCommentPublished(PatchLineComment c) {
    for (PatchLineComment l : getComments().values()) {
        if (c.getKey().equals(l.getKey())) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean containsCommentPublished(Comment c) {
    for (Comment l : getComments().values()) {
        if (c.key.equals(l.key)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private ChangeNotesState buildState() {
    return ChangeNotesState.create(id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, status, assignee, historicalAssignees, hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments);
}
#method_after
private ChangeNotesState buildState() {
    return ChangeNotesState.create(id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, status, assignee != null ? assignee.orNull() : null, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments);
}
#end_block

#method_before
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    if (currentPatchSetId == null || psId.get() > currentPatchSetId.get()) {
        currentPatchSetId = psId;
    }
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null) {
        if (!patchSetStates.containsKey(psId)) {
            patchSetStates.put(psId, psState);
        }
        if (psState == PatchSetState.DELETED) {
            deletedPatchSets.add(psId);
        }
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    parseAssignee(commit);
    parseHistoricalAssignees(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(ts, state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
}
#method_after
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    if (currentPatchSetId == null || psId.get() > currentPatchSetId.get()) {
        currentPatchSetId = psId;
    }
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null) {
        if (!patchSetStates.containsKey(psId)) {
            patchSetStates.put(psId, psState);
        }
        if (psState == PatchSetState.DELETED) {
            deletedPatchSets.add(psId);
        }
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    parseAssignee(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(ts, state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
}
#end_block

#method_before
private void parseAssignee(ChangeNotesCommit commit) throws ConfigInvalidException {
    if (isAssigneeParsed) {
        return;
    }
    String assigneeValue = parseOneFooter(commit, FOOTER_ASSIGNEE);
    if (assigneeValue == null) {
    // footer not found
    } else if (assigneeValue.equals("")) {
        // empty footer found, assignee deleted
        assignee = null;
        isAssigneeParsed = true;
    } else {
        PersonIdent ident = RawParseUtils.parsePersonIdent(assigneeValue);
        assignee = noteUtil.parseIdent(ident, id);
        isAssigneeParsed = true;
    }
}
#method_after
private void parseAssignee(ChangeNotesCommit commit) throws ConfigInvalidException {
    if (pastAssignees == null) {
        pastAssignees = Lists.newArrayList();
    }
    String assigneeValue = parseOneFooter(commit, FOOTER_ASSIGNEE);
    if (assigneeValue != null) {
        Optional<Account.Id> parsedAssignee;
        if (assigneeValue.equals("")) {
            // Empty footer found, assignee deleted
            parsedAssignee = Optional.absent();
        } else {
            PersonIdent ident = RawParseUtils.parsePersonIdent(assigneeValue);
            parsedAssignee = Optional.fromNullable(noteUtil.parseIdent(ident, id));
        }
        if (assignee == null) {
            assignee = parsedAssignee;
        }
        if (parsedAssignee.isPresent()) {
            pastAssignees.add(parsedAssignee.get());
        }
    }
}
#end_block

#method_before
private void parseNotes() throws IOException, ConfigInvalidException {
    ObjectReader reader = walk.getObjectReader();
    ChangeNotesCommit tipCommit = walk.parseCommit(tip);
    revisionNoteMap = RevisionNoteMap.parse(noteUtil, id, reader, NoteMap.read(reader, tipCommit), PatchLineComment.Status.PUBLISHED);
    Map<RevId, RevisionNote> rns = revisionNoteMap.revisionNotes;
    for (Map.Entry<RevId, RevisionNote> e : rns.entrySet()) {
        for (PatchLineComment plc : e.getValue().comments) {
            comments.put(e.getKey(), plc);
        }
    }
    for (PatchSet ps : patchSets.values()) {
        RevisionNote rn = rns.get(ps.getRevision());
        if (rn != null && rn.pushCert != null) {
            ps.setPushCertificate(rn.pushCert);
        }
    }
}
#method_after
private void parseNotes() throws IOException, ConfigInvalidException {
    ObjectReader reader = walk.getObjectReader();
    ChangeNotesCommit tipCommit = walk.parseCommit(tip);
    revisionNoteMap = RevisionNoteMap.parse(noteUtil, id, reader, NoteMap.read(reader, tipCommit), PatchLineComment.Status.PUBLISHED);
    Map<RevId, RevisionNote> rns = revisionNoteMap.revisionNotes;
    for (Map.Entry<RevId, RevisionNote> e : rns.entrySet()) {
        for (Comment c : e.getValue().comments) {
            comments.put(e.getKey(), c);
        }
    }
    for (PatchSet ps : patchSets.values()) {
        RevisionNote rn = rns.get(ps.getRevision());
        if (rn != null && rn.pushCert != null) {
            ps.setPushCertificate(rn.pushCert);
        }
    }
}
#end_block

#method_before
private void updatePatchSetStates() throws ConfigInvalidException {
    for (PatchSet ps : patchSets.values()) {
        if (ps.getRevision().equals(PARTIAL_PATCH_SET)) {
            throw parseException("No %s found for patch set %s", FOOTER_COMMIT, ps.getPatchSetId());
        }
    }
    if (patchSetStates.isEmpty()) {
        return;
    }
    boolean deleted = false;
    for (Map.Entry<PatchSet.Id, PatchSetState> e : patchSetStates.entrySet()) {
        switch(e.getValue()) {
            case PUBLISHED:
            default:
                break;
            case DELETED:
                deleted = true;
                patchSets.remove(e.getKey());
                break;
            case DRAFT:
                PatchSet ps = patchSets.get(e.getKey());
                if (ps != null) {
                    ps.setDraft(true);
                }
                break;
        }
    }
    if (!deleted) {
        return;
    }
    // Post-process other collections to remove items corresponding to deleted
    // patch sets. This is safer than trying to prevent insertion, as it will
    // also filter out items racily added after the patch set was deleted.
    // 
    // Approvals are filtered in buildApprovals().
    NavigableSet<PatchSet.Id> all = patchSets.navigableKeySet();
    if (!all.isEmpty()) {
        currentPatchSetId = all.last();
    } else {
        currentPatchSetId = null;
    }
    changeMessagesByPatchSet.keys().retainAll(all);
    for (Iterator<ChangeMessage> it = allChangeMessages.iterator(); it.hasNext(); ) {
        if (!all.contains(it.next().getPatchSetId())) {
            it.remove();
        }
    }
    for (Iterator<PatchLineComment> it = comments.values().iterator(); it.hasNext(); ) {
        PatchSet.Id psId = it.next().getKey().getParentKey().getParentKey();
        if (!all.contains(psId)) {
            it.remove();
        }
    }
}
#method_after
private void updatePatchSetStates() throws ConfigInvalidException {
    for (PatchSet ps : patchSets.values()) {
        if (ps.getRevision().equals(PARTIAL_PATCH_SET)) {
            throw parseException("No %s found for patch set %s", FOOTER_COMMIT, ps.getPatchSetId());
        }
    }
    if (patchSetStates.isEmpty()) {
        return;
    }
    boolean deleted = false;
    for (Map.Entry<PatchSet.Id, PatchSetState> e : patchSetStates.entrySet()) {
        switch(e.getValue()) {
            case PUBLISHED:
            default:
                break;
            case DELETED:
                deleted = true;
                patchSets.remove(e.getKey());
                break;
            case DRAFT:
                PatchSet ps = patchSets.get(e.getKey());
                if (ps != null) {
                    ps.setDraft(true);
                }
                break;
        }
    }
    if (!deleted) {
        return;
    }
    // Post-process other collections to remove items corresponding to deleted
    // patch sets. This is safer than trying to prevent insertion, as it will
    // also filter out items racily added after the patch set was deleted.
    // 
    // Approvals are filtered in buildApprovals().
    NavigableSet<PatchSet.Id> all = patchSets.navigableKeySet();
    if (!all.isEmpty()) {
        currentPatchSetId = all.last();
    } else {
        currentPatchSetId = null;
    }
    changeMessagesByPatchSet.keys().retainAll(all);
    for (Iterator<ChangeMessage> it = allChangeMessages.iterator(); it.hasNext(); ) {
        if (!all.contains(it.next().getPatchSetId())) {
            it.remove();
        }
    }
    for (Iterator<Comment> it = comments.values().iterator(); it.hasNext(); ) {
        PatchSet.Id psId = new PatchSet.Id(id, it.next().key.patchSetId);
        if (!all.contains(psId)) {
            it.remove();
        }
    }
}
#end_block

#method_before
private void checkMandatoryFooters() throws ConfigInvalidException {
    List<FooterKey> missing = new ArrayList<>();
    if (branch == null) {
        missing.add(FOOTER_BRANCH);
    }
    if (changeId == null) {
        missing.add(FOOTER_CHANGE_ID);
    }
    if (originalSubject == null || subject == null) {
        missing.add(FOOTER_SUBJECT);
    }
    if (!missing.isEmpty()) {
        throw parseException("Missing footers: " + Joiner.on(", ").join(Lists.transform(missing, new Function<FooterKey, String>() {

            @Override
            public String apply(FooterKey input) {
                return input.getName();
            }
        })));
    }
}
#method_after
private void checkMandatoryFooters() throws ConfigInvalidException {
    List<FooterKey> missing = new ArrayList<>();
    if (branch == null) {
        missing.add(FOOTER_BRANCH);
    }
    if (changeId == null) {
        missing.add(FOOTER_CHANGE_ID);
    }
    if (originalSubject == null || subject == null) {
        missing.add(FOOTER_SUBJECT);
    }
    if (!missing.isEmpty()) {
        throw parseException("Missing footers: " + missing.stream().map(FooterKey::getName).collect(joining(", ")));
    }
}
#end_block

#method_before
static ChangeNotesState empty(Change change) {
    return new AutoValue_ChangeNotesState(change.getId(), null, null, ImmutableSet.<Account.Id>of(), ImmutableSet.<String>of(), ImmutableSortedMap.<PatchSet.Id, PatchSet>of(), ImmutableListMultimap.<PatchSet.Id, PatchSetApproval>of(), ReviewerSet.empty(), ImmutableList.<Account.Id>of(), ImmutableList.<ReviewerStatusUpdate>of(), ImmutableList.<SubmitRecord>of(), ImmutableList.<ChangeMessage>of(), ImmutableListMultimap.<PatchSet.Id, ChangeMessage>of(), ImmutableListMultimap.<RevId, PatchLineComment>of());
}
#method_after
static ChangeNotesState empty(Change change) {
    return new AutoValue_ChangeNotesState(change.getId(), null, null, ImmutableSet.<Account.Id>of(), ImmutableSet.<String>of(), ImmutableSortedMap.<PatchSet.Id, PatchSet>of(), ImmutableListMultimap.<PatchSet.Id, PatchSetApproval>of(), ReviewerSet.empty(), ImmutableList.<Account.Id>of(), ImmutableList.<ReviewerStatusUpdate>of(), ImmutableList.<SubmitRecord>of(), ImmutableList.<ChangeMessage>of(), ImmutableListMultimap.<PatchSet.Id, ChangeMessage>of(), ImmutableListMultimap.<RevId, Comment>of());
}
#end_block

#method_before
static ChangeNotesState create(Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Change.Status status, @Nullable Account.Id assignee, @Nullable Set<Account.Id> historicalAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, Multimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, Multimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, Multimap<RevId, PatchLineComment> publishedComments) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, status), assignee, ImmutableSet.copyOf(historicalAssignees), ImmutableSet.copyOf(hashtags), ImmutableSortedMap.copyOf(patchSets, ReviewDbUtil.intKeyOrdering()), ImmutableListMultimap.copyOf(approvals), reviewers, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments));
}
#method_after
static ChangeNotesState create(Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Change.Status status, @Nullable Account.Id assignee, @Nullable Set<Account.Id> pastAssignees, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, Multimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, Multimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, Multimap<RevId, Comment> publishedComments) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, status), assignee, ImmutableSet.copyOf(pastAssignees), ImmutableSet.copyOf(hashtags), ImmutableSortedMap.copyOf(patchSets, comparing(PatchSet.Id::get)), ImmutableListMultimap.copyOf(approvals), reviewers, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments));
}
#end_block

#method_before
@Test
public void tagInlineCommenrts() throws Exception {
    String tag = "jenkins";
    Change c = newChange();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putComment(newPublishedComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name()));
    update.setTag(tag);
    update.commit();
    ChangeNotes notes = newNotes(c);
    ImmutableListMultimap<RevId, PatchLineComment> comments = notes.getComments();
    assertThat(comments).hasSize(1);
    assertThat(comments.entries().asList().get(0).getValue().getTag()).isEqualTo(tag);
}
#method_after
@Test
public void tagInlineCommenrts() throws Exception {
    String tag = "jenkins";
    Change c = newChange();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putComment(Status.PUBLISHED, newComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name()));
    update.setTag(tag);
    update.commit();
    ChangeNotes notes = newNotes(c);
    ImmutableListMultimap<RevId, Comment> comments = notes.getComments();
    assertThat(comments).hasSize(1);
    assertThat(comments.entries().asList().get(0).getValue().tag).isEqualTo(tag);
}
#end_block

#method_before
@Test
public void multipleTags() throws Exception {
    String ipTag = "ip";
    String coverageTag = "coverage";
    String integrationTag = "integration";
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Verified", (short) -1);
    update.setChangeMessage("integration verification");
    update.setTag(integrationTag);
    update.commit();
    RevCommit commit = tr.commit().message("PS2").create();
    update = newUpdate(c, changeOwner);
    update.putComment(newPublishedComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name()));
    update.setChangeMessage("coverage verification");
    update.setTag(coverageTag);
    update.commit();
    update = newUpdate(c, changeOwner);
    update.setChangeMessage("ip clear");
    update.setTag(ipTag);
    update.commit();
    ChangeNotes notes = newNotes(c);
    ImmutableListMultimap<PatchSet.Id, PatchSetApproval> approvals = notes.getApprovals();
    assertThat(approvals).hasSize(1);
    PatchSetApproval approval = approvals.entries().asList().get(0).getValue();
    assertThat(approval.getTag()).isEqualTo(integrationTag);
    assertThat(approval.getValue()).isEqualTo(-1);
    ImmutableListMultimap<RevId, PatchLineComment> comments = notes.getComments();
    assertThat(comments).hasSize(1);
    assertThat(comments.entries().asList().get(0).getValue().getTag()).isEqualTo(coverageTag);
    ImmutableList<ChangeMessage> messages = notes.getChangeMessages();
    assertThat(messages).hasSize(3);
    assertThat(messages.get(0).getTag()).isEqualTo(integrationTag);
    assertThat(messages.get(1).getTag()).isEqualTo(coverageTag);
    assertThat(messages.get(2).getTag()).isEqualTo(ipTag);
}
#method_after
@Test
public void multipleTags() throws Exception {
    String ipTag = "ip";
    String coverageTag = "coverage";
    String integrationTag = "integration";
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Verified", (short) -1);
    update.setChangeMessage("integration verification");
    update.setTag(integrationTag);
    update.commit();
    RevCommit commit = tr.commit().message("PS2").create();
    update = newUpdate(c, changeOwner);
    update.putComment(Status.PUBLISHED, newComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name()));
    update.setChangeMessage("coverage verification");
    update.setTag(coverageTag);
    update.commit();
    update = newUpdate(c, changeOwner);
    update.setChangeMessage("ip clear");
    update.setTag(ipTag);
    update.commit();
    ChangeNotes notes = newNotes(c);
    ImmutableListMultimap<PatchSet.Id, PatchSetApproval> approvals = notes.getApprovals();
    assertThat(approvals).hasSize(1);
    PatchSetApproval approval = approvals.entries().asList().get(0).getValue();
    assertThat(approval.getTag()).isEqualTo(integrationTag);
    assertThat(approval.getValue()).isEqualTo(-1);
    ImmutableListMultimap<RevId, Comment> comments = notes.getComments();
    assertThat(comments).hasSize(1);
    assertThat(comments.entries().asList().get(0).getValue().tag).isEqualTo(coverageTag);
    ImmutableList<ChangeMessage> messages = notes.getChangeMessages();
    assertThat(messages).hasSize(3);
    assertThat(messages.get(0).getTag()).isEqualTo(integrationTag);
    assertThat(messages.get(1).getTag()).isEqualTo(coverageTag);
    assertThat(messages.get(2).getTag()).isEqualTo(ipTag);
}
#end_block

#method_before
@Test
public void putOtherUsersApprovals() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Code-Review", (short) 1);
    update.putApprovalFor(otherUser.getAccountId(), "Code-Review", (short) -1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    List<PatchSetApproval> approvals = Ordering.natural().onResultOf(new Function<PatchSetApproval, Integer>() {

        @Override
        public Integer apply(PatchSetApproval in) {
            return in.getAccountId().get();
        }
    }).sortedCopy(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(approvals).hasSize(2);
    assertThat(approvals.get(0).getAccountId()).isEqualTo(changeOwner.getAccountId());
    assertThat(approvals.get(0).getLabel()).isEqualTo("Code-Review");
    assertThat(approvals.get(0).getValue()).isEqualTo((short) 1);
    assertThat(approvals.get(1).getAccountId()).isEqualTo(otherUser.getAccountId());
    assertThat(approvals.get(1).getLabel()).isEqualTo("Code-Review");
    assertThat(approvals.get(1).getValue()).isEqualTo((short) -1);
}
#method_after
@Test
public void putOtherUsersApprovals() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Code-Review", (short) 1);
    update.putApprovalFor(otherUser.getAccountId(), "Code-Review", (short) -1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    List<PatchSetApproval> approvals = ReviewDbUtil.intKeyOrdering().onResultOf(PatchSetApproval::getAccountId).sortedCopy(notes.getApprovals().get(c.currentPatchSetId()));
    assertThat(approvals).hasSize(2);
    assertThat(approvals.get(0).getAccountId()).isEqualTo(changeOwner.getAccountId());
    assertThat(approvals.get(0).getLabel()).isEqualTo("Code-Review");
    assertThat(approvals.get(0).getValue()).isEqualTo((short) 1);
    assertThat(approvals.get(1).getAccountId()).isEqualTo(otherUser.getAccountId());
    assertThat(approvals.get(1).getLabel()).isEqualTo("Code-Review");
    assertThat(approvals.get(1).getValue()).isEqualTo((short) -1);
}
#end_block

#method_before
@Test
public void assigneeCommit() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setAssignee(otherUserId);
    ObjectId result = update.commit();
    assertThat(result).isNotNull();
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(update.getResult());
        rw.parseBody(commit);
        String strIdent = otherUser.getName() + " <" + otherUserId + "@" + serverId + ">";
        assertThat(commit.getFullMessage()).contains("Assignee: " + strIdent);
    }
}
#method_after
@Test
public void assigneeCommit() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setAssignee(Optional.fromNullable(otherUserId));
    ObjectId result = update.commit();
    assertThat(result).isNotNull();
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(update.getResult());
        rw.parseBody(commit);
        String strIdent = otherUser.getName() + " <" + otherUserId + "@" + serverId + ">";
        assertThat(commit.getFullMessage()).contains("Assignee: " + strIdent);
    }
}
#end_block

#method_before
@Test
public void assigneeChangeNotes() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setAssignee(otherUserId);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getAssignee()).isEqualTo(otherUserId);
    update = newUpdate(c, changeOwner);
    update.setAssignee(changeOwner.getAccountId());
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getAssignee()).isEqualTo(changeOwner.getAccountId());
}
#method_after
@Test
public void assigneeChangeNotes() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setAssignee(Optional.fromNullable(otherUserId));
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getAssignee().get()).isEqualTo(otherUserId);
    update = newUpdate(c, changeOwner);
    update.setAssignee(Optional.fromNullable(changeOwner.getAccountId()));
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getAssignee().get()).isEqualTo(changeOwner.getAccountId());
}
#end_block

#method_before
@Test
public void patchSetStates() throws Exception {
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    // ps2
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.setPatchSetState(PatchSetState.DRAFT);
    update.putApproval("Code-Review", (short) 1);
    update.setChangeMessage("This is a message");
    update.putComment(newPublishedComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name()));
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isTrue();
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getApprovals()).isNotEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isNotEmpty();
    assertThat(notes.getChangeMessages()).isNotEmpty();
    assertThat(notes.getComments()).isNotEmpty();
    // publish ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.PUBLISHED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isFalse();
    // delete ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.DELETED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1);
    assertThat(notes.getApprovals()).isEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isEmpty();
    assertThat(notes.getChangeMessages()).isEmpty();
    assertThat(notes.getComments()).isEmpty();
}
#method_after
@Test
public void patchSetStates() throws Exception {
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    // ps2
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.setPatchSetState(PatchSetState.DRAFT);
    update.putApproval("Code-Review", (short) 1);
    update.setChangeMessage("This is a message");
    update.putComment(Status.PUBLISHED, newComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name()));
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isTrue();
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getApprovals()).isNotEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isNotEmpty();
    assertThat(notes.getChangeMessages()).isNotEmpty();
    assertThat(notes.getComments()).isNotEmpty();
    // publish ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.PUBLISHED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isFalse();
    // delete ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.DELETED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1);
    assertThat(notes.getApprovals()).isEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isEmpty();
    assertThat(notes.getChangeMessages()).isEmpty();
    assertThat(notes.getComments()).isEmpty();
}
#end_block

#method_before
@Test
public void pushCertificate() throws Exception {
    String pushCert = "certificate version 0.1\n" + "pusher This is not a real push cert\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: GnuPG v1\n" + "\n" + "Nor is this a real signature.\n" + "-----END PGP SIGNATURE-----\n";
    // ps2 with push cert
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    RevCommit commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit, pushCert);
    update.commit();
    ChangeNotes notes = newNotes(c);
    String note = readNote(notes, commit);
    if (!testJson()) {
        assertThat(note).isEqualTo(pushCert);
    }
    Map<PatchSet.Id, PatchSet> patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isEmpty();
    // comment on ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    Timestamp ts = TimeUtil.nowTs();
    update.putComment(newPublishedComment(psId2, "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, ts, "Comment", (short) 1, commit.name()));
    update.commit();
    notes = newNotes(c);
    patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isNotEmpty();
    if (!testJson()) {
        assertThat(readNote(notes, commit)).isEqualTo(pushCert + "Revision: " + commit.name() + "\n" + "Patch-set: 2\n" + "File: a.txt\n" + "\n" + "1:2-3:4\n" + ChangeNoteUtil.formatTime(serverIdent, ts) + "\n" + "Author: Change Owner <1@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 7\n" + "Comment\n" + "\n");
    }
}
#method_after
@Test
public void pushCertificate() throws Exception {
    String pushCert = "certificate version 0.1\n" + "pusher This is not a real push cert\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: GnuPG v1\n" + "\n" + "Nor is this a real signature.\n" + "-----END PGP SIGNATURE-----\n";
    // ps2 with push cert
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    RevCommit commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit, pushCert);
    update.commit();
    ChangeNotes notes = newNotes(c);
    String note = readNote(notes, commit);
    if (!testJson()) {
        assertThat(note).isEqualTo(pushCert);
    }
    Map<PatchSet.Id, PatchSet> patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isEmpty();
    // comment on ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    Timestamp ts = TimeUtil.nowTs();
    update.putComment(Status.PUBLISHED, newComment(psId2, "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, ts, "Comment", (short) 1, commit.name()));
    update.commit();
    notes = newNotes(c);
    patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isNotEmpty();
    if (!testJson()) {
        assertThat(readNote(notes, commit)).isEqualTo(pushCert + "Revision: " + commit.name() + "\n" + "Patch-set: 2\n" + "File: a.txt\n" + "\n" + "1:2-3:4\n" + ChangeNoteUtil.formatTime(serverIdent, ts) + "\n" + "Author: Change Owner <1@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 7\n" + "Comment\n" + "\n");
    }
}
#end_block

#method_before
@Test
public void multipleUpdatesIncludingComments() throws Exception {
    Change c = newChange();
    ChangeUpdate update1 = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String message1 = "comment 1";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    RevCommit tipCommit;
    try (NoteDbUpdateManager updateManager = updateManagerFactory.create(project)) {
        PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
        update1.setPatchSetId(psId);
        update1.putComment(comment1);
        updateManager.add(update1);
        ChangeUpdate update2 = newUpdate(c, otherUser);
        update2.putApproval("Code-Review", (short) 2);
        updateManager.add(update2);
        updateManager.execute();
    }
    ChangeNotes notes = newNotes(c);
    ObjectId tip = notes.getRevision();
    tipCommit = rw.parseCommit(tip);
    RevCommit commitWithApprovals = tipCommit;
    assertThat(commitWithApprovals).isNotNull();
    RevCommit commitWithComments = commitWithApprovals.getParent(0);
    assertThat(commitWithComments).isNotNull();
    try (ChangeNotesRevWalk rw = ChangeNotesCommit.newRevWalk(repo)) {
        ChangeNotesParser notesWithComments = new ChangeNotesParser(c.getId(), commitWithComments.copy(), rw, noteUtil, args.metrics);
        ChangeNotesState state = notesWithComments.parseAll();
        assertThat(state.approvals()).isEmpty();
        assertThat(state.publishedComments()).hasSize(1);
    }
    try (ChangeNotesRevWalk rw = ChangeNotesCommit.newRevWalk(repo)) {
        ChangeNotesParser notesWithApprovals = new ChangeNotesParser(c.getId(), commitWithApprovals.copy(), rw, noteUtil, args.metrics);
        ChangeNotesState state = notesWithApprovals.parseAll();
        assertThat(state.approvals()).hasSize(1);
        assertThat(state.publishedComments()).hasSize(1);
    }
}
#method_after
@Test
public void multipleUpdatesIncludingComments() throws Exception {
    Change c = newChange();
    ChangeUpdate update1 = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String message1 = "comment 1";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    RevCommit tipCommit;
    try (NoteDbUpdateManager updateManager = updateManagerFactory.create(project)) {
        Comment comment1 = newComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
        update1.setPatchSetId(psId);
        update1.putComment(Status.PUBLISHED, comment1);
        updateManager.add(update1);
        ChangeUpdate update2 = newUpdate(c, otherUser);
        update2.putApproval("Code-Review", (short) 2);
        updateManager.add(update2);
        updateManager.execute();
    }
    ChangeNotes notes = newNotes(c);
    ObjectId tip = notes.getRevision();
    tipCommit = rw.parseCommit(tip);
    RevCommit commitWithApprovals = tipCommit;
    assertThat(commitWithApprovals).isNotNull();
    RevCommit commitWithComments = commitWithApprovals.getParent(0);
    assertThat(commitWithComments).isNotNull();
    try (ChangeNotesRevWalk rw = ChangeNotesCommit.newRevWalk(repo)) {
        ChangeNotesParser notesWithComments = new ChangeNotesParser(c.getId(), commitWithComments.copy(), rw, noteUtil, args.metrics);
        ChangeNotesState state = notesWithComments.parseAll();
        assertThat(state.approvals()).isEmpty();
        assertThat(state.publishedComments()).hasSize(1);
    }
    try (ChangeNotesRevWalk rw = ChangeNotesCommit.newRevWalk(repo)) {
        ChangeNotesParser notesWithApprovals = new ChangeNotesParser(c.getId(), commitWithApprovals.copy(), rw, noteUtil, args.metrics);
        ChangeNotesState state = notesWithApprovals.parseAll();
        assertThat(state.approvals()).hasSize(1);
        assertThat(state.publishedComments()).hasSize(1);
    }
}
#end_block

#method_before
@Test
public void patchLineCommentsFileComment() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    PatchLineComment comment = newPublishedComment(psId, "file1", "uuid", null, 0, otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#method_after
@Test
public void patchLineCommentsFileComment() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    Comment comment = newComment(psId, "file1", "uuid", null, 0, otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#end_block

#method_before
@Test
public void patchLineCommentsZeroColumns() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 0, 2, 0);
    PatchLineComment comment = newPublishedComment(psId, "file1", "uuid", range, range.getEndLine(), otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#method_after
@Test
public void patchLineCommentsZeroColumns() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 0, 2, 0);
    Comment comment = newComment(psId, "file1", "uuid", range, range.getEndLine(), otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#end_block

#method_before
@Test
public void patchLineCommentZeroRange() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(0, 0, 0, 0);
    PatchLineComment comment = newPublishedComment(psId, "file", "uuid", range, range.getEndLine(), otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#method_after
@Test
public void patchLineCommentZeroRange() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(0, 0, 0, 0);
    Comment comment = newComment(psId, "file", "uuid", range, range.getEndLine(), otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#end_block

#method_before
@Test
public void patchLineCommentEmptyFilename() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 2, 3, 4);
    PatchLineComment comment = newPublishedComment(psId, "", "uuid", range, range.getEndLine(), otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#method_after
@Test
public void patchLineCommentEmptyFilename() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    PatchSet.Id psId = c.currentPatchSetId();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 2, 3, 4);
    Comment comment = newComment(psId, "", "uuid", range, range.getEndLine(), otherUser, null, TimeUtil.nowTs(), "message", (short) 1, revId.get());
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment));
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatSide1() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    Timestamp time3 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range3 = new CommentRange(3, 0, 4, 1);
    PatchLineComment comment3 = newPublishedComment(psId, "file2", uuid3, range3, range3.getEndLine(), otherUser, null, time3, message3, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment3);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "File: file2\n" + "\n" + "3:0-4:1\n" + ChangeNoteUtil.formatTime(serverIdent, time3) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
}
#method_after
@Test
public void patchLineCommentNotesFormatSide1() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    Timestamp time3 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment1 = newComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Comment comment2 = newComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range3 = new CommentRange(3, 0, 4, 1);
    Comment comment3 = newComment(psId, "file2", uuid3, range3, range3.getEndLine(), otherUser, null, time3, message3, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment3);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "File: file2\n" + "\n" + "3:0-4:1\n" + ChangeNoteUtil.formatTime(serverIdent, time3) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatSide0() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String message1 = "comment 1";
    String message2 = "comment 2";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n");
        }
    }
}
#method_after
@Test
public void patchLineCommentNotesFormatSide0() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String message1 = "comment 1";
    String message2 = "comment 2";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment1 = newComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Comment comment2 = newComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n");
        }
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatMultiplePatchSetsSameRevId() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Timestamp time = TimeUtil.nowTs();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    PatchSet.Id psId1 = c.currentPatchSetId();
    PatchSet.Id psId2 = new PatchSet.Id(c.getId(), psId1.get() + 1);
    PatchLineComment comment1 = newPublishedComment(psId1, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time, message1, (short) 0, revId.get());
    PatchLineComment comment2 = newPublishedComment(psId1, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time, message2, (short) 0, revId.get());
    PatchLineComment comment3 = newPublishedComment(psId2, "file1", uuid3, range1, range1.getEndLine(), otherUser, null, time, message3, (short) 0, revId.get());
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId2);
    update.putComment(comment3);
    update.putComment(comment2);
    update.putComment(comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "Base-for-patch-set: 2\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment1, revId, comment2, revId, comment3));
}
#method_after
@Test
public void patchLineCommentNotesFormatMultiplePatchSetsSameRevId() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Timestamp time = TimeUtil.nowTs();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    PatchSet.Id psId1 = c.currentPatchSetId();
    PatchSet.Id psId2 = new PatchSet.Id(c.getId(), psId1.get() + 1);
    Comment comment1 = newComment(psId1, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time, message1, (short) 0, revId.get());
    Comment comment2 = newComment(psId1, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time, message2, (short) 0, revId.get());
    Comment comment3 = newComment(psId2, "file1", uuid3, range1, range1.getEndLine(), otherUser, null, time, message3, (short) 0, revId.get());
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId2);
    update.putComment(Status.PUBLISHED, comment3);
    update.putComment(Status.PUBLISHED, comment2);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "Base-for-patch-set: 2\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment1, revId, comment2, revId, comment3));
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatWeirdUser() throws Exception {
    Account account = new Account(new Account.Id(3), TimeUtil.nowTs());
    account.setFullName("Weird\n\u0002<User>\n");
    account.setPreferredEmail(" we\r\nird@ex>ample<.com");
    accountCache.put(account);
    IdentifiedUser user = userFactory.create(account.getId());
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, user);
    String uuid = "uuid";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment = newPublishedComment(psId, "file1", uuid, range, range.getEndLine(), user, null, time, "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Weird\u0002User <3@gerrit>\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(comment.getRevId(), comment));
}
#method_after
@Test
public void patchLineCommentNotesFormatWeirdUser() throws Exception {
    Account account = new Account(new Account.Id(3), TimeUtil.nowTs());
    account.setFullName("Weird\n\u0002<User>\n");
    account.setPreferredEmail(" we\r\nird@ex>ample<.com");
    accountCache.put(account);
    IdentifiedUser user = userFactory.create(account.getId());
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, user);
    String uuid = "uuid";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment = newComment(psId, "file1", uuid, range, range.getEndLine(), user, null, time, "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Weird\u0002User <3@gerrit>\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(new RevId(comment.revId), comment));
}
#end_block

#method_before
@Test
public void patchLineCommentMultipleOnePatchsetOneFileBothSides() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    String messageForBase = "comment for base";
    String messageForPS = "comment for ps";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment commentForBase = newPublishedComment(psId, "filename", uuid1, range, range.getEndLine(), otherUser, null, now, messageForBase, (short) 0, rev1);
    update.setPatchSetId(psId);
    update.putComment(commentForBase);
    update.commit();
    update = newUpdate(c, otherUser);
    PatchLineComment commentForPS = newPublishedComment(psId, "filename", uuid2, range, range.getEndLine(), otherUser, null, now, messageForPS, (short) 1, rev2);
    update.setPatchSetId(psId);
    update.putComment(commentForPS);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), commentForBase, new RevId(rev2), commentForPS));
}
#method_after
@Test
public void patchLineCommentMultipleOnePatchsetOneFileBothSides() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    String messageForBase = "comment for base";
    String messageForPS = "comment for ps";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment commentForBase = newComment(psId, "filename", uuid1, range, range.getEndLine(), otherUser, null, now, messageForBase, (short) 0, rev1);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, commentForBase);
    update.commit();
    update = newUpdate(c, otherUser);
    Comment commentForPS = newComment(psId, "filename", uuid2, range, range.getEndLine(), otherUser, null, now, messageForPS, (short) 1, rev2);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, commentForPS);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), commentForBase, new RevId(rev2), commentForPS));
}
#end_block

#method_before
@Test
public void patchLineCommentMultipleOnePatchsetOneFile() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp timeForComment1 = TimeUtil.nowTs();
    Timestamp timeForComment2 = TimeUtil.nowTs();
    PatchLineComment comment1 = newPublishedComment(psId, filename, uuid1, range, range.getEndLine(), otherUser, null, timeForComment1, "comment 1", side, rev);
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    PatchLineComment comment2 = newPublishedComment(psId, filename, uuid2, range, range.getEndLine(), otherUser, null, timeForComment2, "comment 2", side, rev);
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
}
#method_after
@Test
public void patchLineCommentMultipleOnePatchsetOneFile() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp timeForComment1 = TimeUtil.nowTs();
    Timestamp timeForComment2 = TimeUtil.nowTs();
    Comment comment1 = newComment(psId, filename, uuid1, range, range.getEndLine(), otherUser, null, timeForComment1, "comment 1", side, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    Comment comment2 = newComment(psId, filename, uuid2, range, range.getEndLine(), otherUser, null, timeForComment2, "comment 2", side, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
}
#end_block

#method_before
@Test
public void patchLineCommentMultipleOnePatchsetMultipleFiles() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename1 = "filename1";
    String filename2 = "filename2";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment1 = newPublishedComment(psId, filename1, uuid, range, range.getEndLine(), otherUser, null, now, "comment 1", side, rev);
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    PatchLineComment comment2 = newPublishedComment(psId, filename2, uuid, range, range.getEndLine(), otherUser, null, now, "comment 2", side, rev);
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
}
#method_after
@Test
public void patchLineCommentMultipleOnePatchsetMultipleFiles() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename1 = "filename1";
    String filename2 = "filename2";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(psId, filename1, uuid, range, range.getEndLine(), otherUser, null, now, "comment 1", side, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    Comment comment2 = newComment(psId, filename2, uuid, range, range.getEndLine(), otherUser, null, now, "comment 2", side, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
}
#end_block

#method_before
@Test
public void patchLineCommentMultiplePatchsets() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment1 = newPublishedComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1);
    update.setPatchSetId(ps1);
    update.putComment(comment1);
    update.commit();
    incrementPatchSet(c);
    PatchSet.Id ps2 = c.currentPatchSetId();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    PatchLineComment comment2 = newPublishedComment(ps2, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps2", side, rev2);
    update.setPatchSetId(ps2);
    update.putComment(comment2);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), comment1, new RevId(rev2), comment2));
}
#method_after
@Test
public void patchLineCommentMultiplePatchsets() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    incrementPatchSet(c);
    PatchSet.Id ps2 = c.currentPatchSetId();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    Comment comment2 = newComment(ps2, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps2", side, rev2);
    update.setPatchSetId(ps2);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), comment1, new RevId(rev2), comment2));
}
#end_block

#method_before
@Test
public void patchLineCommentSingleDraftToPublished() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.DRAFT);
    update.setPatchSetId(ps1);
    update.putComment(comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1));
    assertThat(notes.getComments()).isEmpty();
    comment1.setStatus(Status.PUBLISHED);
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    update.putComment(comment1);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1));
}
#method_after
@Test
public void patchLineCommentSingleDraftToPublished() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev);
    update.setPatchSetId(ps1);
    update.putComment(Status.DRAFT, comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1));
    assertThat(notes.getComments()).isEmpty();
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1));
}
#end_block

#method_before
@Test
public void patchLineCommentMultipleDraftsSameSidePublishOne() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range1 = new CommentRange(1, 1, 2, 2);
    CommentRange range2 = new CommentRange(2, 2, 3, 3);
    String filename = "filename1";
    short side = (short) 1;
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    // Write two drafts on the same side of one patch set.
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    PatchLineComment comment1 = newComment(psId, filename, uuid1, range1, range1.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.DRAFT);
    PatchLineComment comment2 = newComment(psId, filename, uuid2, range2, range2.getEndLine(), otherUser, null, now, "other on ps1", side, rev, Status.DRAFT);
    update.putComment(comment1);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
    assertThat(notes.getComments()).isEmpty();
    // Publish first draft.
    update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    comment1.setStatus(Status.PUBLISHED);
    update.putComment(comment1);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment2));
    assertThat(notes.getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1));
}
#method_after
@Test
public void patchLineCommentMultipleDraftsSameSidePublishOne() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range1 = new CommentRange(1, 1, 2, 2);
    CommentRange range2 = new CommentRange(2, 2, 3, 3);
    String filename = "filename1";
    short side = (short) 1;
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    // Write two drafts on the same side of one patch set.
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    Comment comment1 = newComment(psId, filename, uuid1, range1, range1.getEndLine(), otherUser, null, now, "comment on ps1", side, rev);
    Comment comment2 = newComment(psId, filename, uuid2, range2, range2.getEndLine(), otherUser, null, now, "other on ps1", side, rev);
    update.putComment(Status.DRAFT, comment1);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1, new RevId(rev), comment2)).inOrder();
    assertThat(notes.getComments()).isEmpty();
    // Publish first draft.
    update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment2));
    assertThat(notes.getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment1));
}
#end_block

#method_before
@Test
public void patchLineCommentsMultipleDraftsBothSidesPublishAll() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range1 = new CommentRange(1, 1, 2, 2);
    CommentRange range2 = new CommentRange(2, 2, 3, 3);
    String filename = "filename1";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    // Write two drafts, one on each side of the patchset.
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    PatchLineComment baseComment = newComment(psId, filename, uuid1, range1, range1.getEndLine(), otherUser, null, now, "comment on base", (short) 0, rev1, Status.DRAFT);
    PatchLineComment psComment = newComment(psId, filename, uuid2, range2, range2.getEndLine(), otherUser, null, now, "comment on ps", (short) 1, rev2, Status.DRAFT);
    update.putComment(baseComment);
    update.putComment(psComment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), baseComment, new RevId(rev2), psComment));
    assertThat(notes.getComments()).isEmpty();
    // Publish both comments.
    update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    baseComment.setStatus(Status.PUBLISHED);
    psComment.setStatus(Status.PUBLISHED);
    update.putComment(baseComment);
    update.putComment(psComment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), baseComment, new RevId(rev2), psComment));
}
#method_after
@Test
public void patchLineCommentsMultipleDraftsBothSidesPublishAll() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range1 = new CommentRange(1, 1, 2, 2);
    CommentRange range2 = new CommentRange(2, 2, 3, 3);
    String filename = "filename1";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    // Write two drafts, one on each side of the patchset.
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    Comment baseComment = newComment(psId, filename, uuid1, range1, range1.getEndLine(), otherUser, null, now, "comment on base", (short) 0, rev1);
    Comment psComment = newComment(psId, filename, uuid2, range2, range2.getEndLine(), otherUser, null, now, "comment on ps", (short) 1, rev2);
    update.putComment(Status.DRAFT, baseComment);
    update.putComment(Status.DRAFT, psComment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), baseComment, new RevId(rev2), psComment));
    assertThat(notes.getComments()).isEmpty();
    // Publish both comments.
    update = newUpdate(c, otherUser);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, baseComment);
    update.putComment(Status.PUBLISHED, psComment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev1), baseComment, new RevId(rev2), psComment));
}
#end_block

#method_before
@Test
public void patchLineCommentsDeleteAllDrafts() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ObjectId objId = ObjectId.fromString(rev);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment = newComment(psId, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.DRAFT);
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    assertThat(notes.getDraftCommentNotes().getNoteMap().contains(objId)).isTrue();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(psId);
    update.deleteComment(comment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getDraftCommentNotes().getNoteMap()).isNull();
}
#method_after
@Test
public void patchLineCommentsDeleteAllDrafts() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ObjectId objId = ObjectId.fromString(rev);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id psId = c.currentPatchSetId();
    String filename = "filename";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment = newComment(psId, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.DRAFT, comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    assertThat(notes.getDraftCommentNotes().getNoteMap().contains(objId)).isTrue();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(psId);
    update.deleteComment(comment);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getDraftCommentNotes().getNoteMap()).isNull();
}
#end_block

#method_before
@Test
public void patchLineCommentsDeleteAllDraftsForOneRevision() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    ObjectId objId1 = ObjectId.fromString(rev1);
    ObjectId objId2 = ObjectId.fromString(rev2);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1, Status.DRAFT);
    update.setPatchSetId(ps1);
    update.putComment(comment1);
    update.commit();
    incrementPatchSet(c);
    PatchSet.Id ps2 = c.currentPatchSetId();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    PatchLineComment comment2 = newComment(ps2, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps2", side, rev2, Status.DRAFT);
    update.setPatchSetId(ps2);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(2);
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(ps2);
    update.deleteComment(comment2);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    NoteMap noteMap = notes.getDraftCommentNotes().getNoteMap();
    assertThat(noteMap.contains(objId1)).isTrue();
    assertThat(noteMap.contains(objId2)).isFalse();
}
#method_after
@Test
public void patchLineCommentsDeleteAllDraftsForOneRevision() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    ObjectId objId1 = ObjectId.fromString(rev1);
    ObjectId objId2 = ObjectId.fromString(rev2);
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1);
    update.setPatchSetId(ps1);
    update.putComment(Status.DRAFT, comment1);
    update.commit();
    incrementPatchSet(c);
    PatchSet.Id ps2 = c.currentPatchSetId();
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    Comment comment2 = newComment(ps2, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps2", side, rev2);
    update.setPatchSetId(ps2);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(2);
    update = newUpdate(c, otherUser);
    now = TimeUtil.nowTs();
    update.setPatchSetId(ps2);
    update.deleteComment(comment2);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(1);
    NoteMap noteMap = notes.getDraftCommentNotes().getNoteMap();
    assertThat(noteMap.contains(objId1)).isTrue();
    assertThat(noteMap.contains(objId2)).isFalse();
}
#end_block

#method_before
@Test
public void addingPublishedCommentDoesNotCreateNoOpCommitOnEmptyDraftRef() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.PUBLISHED);
    update.putComment(comment);
    update.commit();
    assertThat(repo.exactRef(changeMetaRef(c.getId()))).isNotNull();
    String draftRef = refsDraftComments(c.getId(), otherUser.getAccountId());
    assertThat(exactRefAllUsers(draftRef)).isNull();
}
#method_after
@Test
public void addingPublishedCommentDoesNotCreateNoOpCommitOnEmptyDraftRef() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    assertThat(repo.exactRef(changeMetaRef(c.getId()))).isNotNull();
    String draftRef = refsDraftComments(c.getId(), otherUser.getAccountId());
    assertThat(exactRefAllUsers(draftRef)).isNull();
}
#end_block

#method_before
@Test
public void addingPublishedCommentDoesNotCreateNoOpCommitOnNonEmptyDraftRef() throws Exception {
    Change c = newChange();
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment draft = newComment(ps1, filename, "uuid1", range, range.getEndLine(), otherUser, null, now, "draft comment on ps1", side, rev, Status.DRAFT);
    update.putComment(draft);
    update.commit();
    String draftRef = refsDraftComments(c.getId(), otherUser.getAccountId());
    ObjectId old = exactRefAllUsers(draftRef);
    assertThat(old).isNotNull();
    update = newUpdate(c, otherUser);
    PatchLineComment pub = newComment(ps1, filename, "uuid2", range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev, Status.PUBLISHED);
    update.putComment(pub);
    update.commit();
    assertThat(exactRefAllUsers(draftRef)).isEqualTo(old);
}
#method_after
@Test
public void addingPublishedCommentDoesNotCreateNoOpCommitOnNonEmptyDraftRef() throws Exception {
    Change c = newChange();
    String rev = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment draft = newComment(ps1, filename, "uuid1", range, range.getEndLine(), otherUser, null, now, "draft comment on ps1", side, rev);
    update.putComment(Status.DRAFT, draft);
    update.commit();
    String draftRef = refsDraftComments(c.getId(), otherUser.getAccountId());
    ObjectId old = exactRefAllUsers(draftRef);
    assertThat(old).isNotNull();
    update = newUpdate(c, otherUser);
    Comment pub = newComment(ps1, filename, "uuid2", range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev);
    update.putComment(Status.PUBLISHED, pub);
    update.commit();
    assertThat(exactRefAllUsers(draftRef)).isEqualTo(old);
}
#end_block

#method_before
@Test
public void fileComment() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String messageForBase = "comment for base";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment = newPublishedComment(psId, "filename", uuid, null, 0, otherUser, null, now, messageForBase, (short) 0, rev);
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment));
}
#method_after
@Test
public void fileComment() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String messageForBase = "comment for base";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment = newComment(psId, "filename", uuid, null, 0, otherUser, null, now, messageForBase, (short) 0, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment));
}
#end_block

#method_before
@Test
public void patchLineCommentNoRange() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String messageForBase = "comment for base";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment = newPublishedComment(psId, "filename", uuid, null, 1, otherUser, null, now, messageForBase, (short) 0, rev);
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment));
}
#method_after
@Test
public void patchLineCommentNoRange() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid = "uuid";
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String messageForBase = "comment for base";
    Timestamp now = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    Comment comment = newComment(psId, "filename", uuid, null, 1, otherUser, null, now, messageForBase, (short) 0, rev);
    update.setPatchSetId(psId);
    update.putComment(Status.PUBLISHED, comment);
    update.commit();
    assertThat(newNotes(c).getComments()).containsExactlyEntriesIn(ImmutableMultimap.of(new RevId(rev), comment));
}
#end_block

#method_before
@Test
public void putCommentsForMultipleRevisions() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    incrementPatchSet(c);
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(ps2);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1, Status.DRAFT);
    PatchLineComment comment2 = newComment(ps2, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps2", side, rev2, Status.DRAFT);
    update.putComment(comment1);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(2);
    assertThat(notes.getComments()).isEmpty();
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps2);
    comment1.setStatus(Status.PUBLISHED);
    comment2.setStatus(Status.PUBLISHED);
    update.putComment(comment1);
    update.putComment(comment2);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).hasSize(2);
}
#method_after
@Test
public void putCommentsForMultipleRevisions() throws Exception {
    Change c = newChange();
    String uuid = "uuid";
    String rev1 = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    String rev2 = "abcd4567abcd4567abcd4567abcd4567abcd4567";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    String filename = "filename1";
    short side = (short) 1;
    incrementPatchSet(c);
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(ps2);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1);
    Comment comment2 = newComment(ps2, filename, uuid, range, range.getEndLine(), otherUser, null, now, "comment on ps2", side, rev2);
    update.putComment(Status.DRAFT, comment1);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).hasSize(2);
    assertThat(notes.getComments()).isEmpty();
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps2);
    update.putComment(Status.PUBLISHED, comment1);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId)).isEmpty();
    assertThat(notes.getComments()).hasSize(2);
}
#end_block

#method_before
@Test
public void publishSubsetOfCommentsOnRevision() throws Exception {
    Change c = newChange();
    RevId rev1 = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment1 = newComment(ps1, "file1", "uuid1", range, range.getEndLine(), otherUser, null, now, "comment1", side, rev1.get(), Status.DRAFT);
    PatchLineComment comment2 = newComment(ps1, "file2", "uuid2", range, range.getEndLine(), otherUser, null, now, "comment2", side, rev1.get(), Status.DRAFT);
    update.putComment(comment1);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId).get(rev1)).containsExactly(comment1, comment2);
    assertThat(notes.getComments()).isEmpty();
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    comment2.setStatus(Status.PUBLISHED);
    update.putComment(comment2);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId).get(rev1)).containsExactly(comment1);
    assertThat(notes.getComments().get(rev1)).containsExactly(comment2);
}
#method_after
@Test
public void publishSubsetOfCommentsOnRevision() throws Exception {
    Change c = newChange();
    RevId rev1 = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, "file1", "uuid1", range, range.getEndLine(), otherUser, null, now, "comment1", side, rev1.get());
    Comment comment2 = newComment(ps1, "file2", "uuid2", range, range.getEndLine(), otherUser, null, now, "comment2", side, rev1.get());
    update.putComment(Status.DRAFT, comment1);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId).get(rev1)).containsExactly(comment1, comment2);
    assertThat(notes.getComments()).isEmpty();
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId).get(rev1)).containsExactly(comment1);
    assertThat(notes.getComments().get(rev1)).containsExactly(comment2);
}
#end_block

#method_before
@Test
public void filterOutAndFixUpZombieDraftComments() throws Exception {
    Change c = newChange();
    RevId rev1 = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    PatchLineComment comment1 = newComment(ps1, "file1", "uuid1", range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1.get(), Status.DRAFT);
    PatchLineComment comment2 = newComment(ps1, "file2", "uuid2", range, range.getEndLine(), otherUser, null, now, "another comment", side, rev1.get(), Status.DRAFT);
    update.putComment(comment1);
    update.putComment(comment2);
    update.commit();
    String refName = refsDraftComments(c.getId(), otherUserId);
    ObjectId oldDraftId = exactRefAllUsers(refName);
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    comment2.setStatus(Status.PUBLISHED);
    update.putComment(comment2);
    update.commit();
    assertThat(exactRefAllUsers(refName)).isNotNull();
    assertThat(exactRefAllUsers(refName)).isNotEqualTo(oldDraftId);
    // Re-add draft version of comment2 back to draft ref without updating
    // change ref. Simulates the case where deleting the draft failed
    // non-atomically after adding the published comment succeeded.
    ChangeDraftUpdate draftUpdate = newUpdate(c, otherUser).createDraftUpdateIfNull();
    comment2.setStatus(Status.DRAFT);
    draftUpdate.putComment(comment2);
    try (NoteDbUpdateManager manager = updateManagerFactory.create(c.getProject())) {
        manager.add(draftUpdate);
        manager.execute();
    }
    // Looking at drafts directly shows the zombie comment.
    DraftCommentNotes draftNotes = draftNotesFactory.create(c, otherUserId);
    assertThat(draftNotes.load().getComments().get(rev1)).containsExactly(comment1, comment2);
    // Reset for later assertions.
    comment2.setStatus(Status.PUBLISHED);
    // Zombie comment is filtered out of drafts via ChangeNotes.
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId).get(rev1)).containsExactly(comment1);
    assertThat(notes.getComments().get(rev1)).containsExactly(comment2);
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    comment1.setStatus(Status.PUBLISHED);
    update.putComment(comment1);
    update.commit();
    // Updating an unrelated comment causes the zombie comment to get fixed up.
    assertThat(exactRefAllUsers(refName)).isNull();
}
#method_after
@Test
public void filterOutAndFixUpZombieDraftComments() throws Exception {
    Change c = newChange();
    RevId rev1 = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    CommentRange range = new CommentRange(1, 1, 2, 1);
    PatchSet.Id ps1 = c.currentPatchSetId();
    short side = (short) 1;
    ChangeUpdate update = newUpdate(c, otherUser);
    Timestamp now = TimeUtil.nowTs();
    Comment comment1 = newComment(ps1, "file1", "uuid1", range, range.getEndLine(), otherUser, null, now, "comment on ps1", side, rev1.get());
    Comment comment2 = newComment(ps1, "file2", "uuid2", range, range.getEndLine(), otherUser, null, now, "another comment", side, rev1.get());
    update.putComment(Status.DRAFT, comment1);
    update.putComment(Status.DRAFT, comment2);
    update.commit();
    String refName = refsDraftComments(c.getId(), otherUserId);
    ObjectId oldDraftId = exactRefAllUsers(refName);
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment2);
    update.commit();
    assertThat(exactRefAllUsers(refName)).isNotNull();
    assertThat(exactRefAllUsers(refName)).isNotEqualTo(oldDraftId);
    // Re-add draft version of comment2 back to draft ref without updating
    // change ref. Simulates the case where deleting the draft failed
    // non-atomically after adding the published comment succeeded.
    ChangeDraftUpdate draftUpdate = newUpdate(c, otherUser).createDraftUpdateIfNull();
    draftUpdate.putComment(comment2);
    try (NoteDbUpdateManager manager = updateManagerFactory.create(c.getProject())) {
        manager.add(draftUpdate);
        manager.execute();
    }
    // Looking at drafts directly shows the zombie comment.
    DraftCommentNotes draftNotes = draftNotesFactory.create(c, otherUserId);
    assertThat(draftNotes.load().getComments().get(rev1)).containsExactly(comment1, comment2);
    // Zombie comment is filtered out of drafts via ChangeNotes.
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getDraftComments(otherUserId).get(rev1)).containsExactly(comment1);
    assertThat(notes.getComments().get(rev1)).containsExactly(comment2);
    update = newUpdate(c, otherUser);
    update.setPatchSetId(ps1);
    update.putComment(Status.PUBLISHED, comment1);
    update.commit();
    // Updating an unrelated comment causes the zombie comment to get fixed up.
    assertThat(exactRefAllUsers(refName)).isNull();
}
#end_block

#method_before
@Test
public void updateCommentsInSequentialUpdates() throws Exception {
    Change c = newChange();
    CommentRange range = new CommentRange(1, 1, 2, 1);
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ChangeUpdate update1 = newUpdate(c, otherUser);
    PatchLineComment comment1 = newComment(c.currentPatchSetId(), "filename", "uuid1", range, range.getEndLine(), otherUser, null, new Timestamp(update1.getWhen().getTime()), "comment 1", (short) 1, rev, Status.PUBLISHED);
    update1.putComment(comment1);
    ChangeUpdate update2 = newUpdate(c, otherUser);
    PatchLineComment comment2 = newComment(c.currentPatchSetId(), "filename", "uuid2", range, range.getEndLine(), otherUser, null, new Timestamp(update2.getWhen().getTime()), "comment 2", (short) 1, rev, Status.PUBLISHED);
    update2.putComment(comment2);
    try (NoteDbUpdateManager manager = updateManagerFactory.create(project)) {
        manager.add(update1);
        manager.add(update2);
        manager.execute();
    }
    ChangeNotes notes = newNotes(c);
    List<PatchLineComment> comments = notes.getComments().get(new RevId(rev));
    assertThat(comments).hasSize(2);
    assertThat(comments.get(0).getMessage()).isEqualTo("comment 1");
    assertThat(comments.get(1).getMessage()).isEqualTo("comment 2");
}
#method_after
@Test
public void updateCommentsInSequentialUpdates() throws Exception {
    Change c = newChange();
    CommentRange range = new CommentRange(1, 1, 2, 1);
    String rev = "abcd1234abcd1234abcd1234abcd1234abcd1234";
    ChangeUpdate update1 = newUpdate(c, otherUser);
    Comment comment1 = newComment(c.currentPatchSetId(), "filename", "uuid1", range, range.getEndLine(), otherUser, null, new Timestamp(update1.getWhen().getTime()), "comment 1", (short) 1, rev);
    update1.putComment(Status.PUBLISHED, comment1);
    ChangeUpdate update2 = newUpdate(c, otherUser);
    Comment comment2 = newComment(c.currentPatchSetId(), "filename", "uuid2", range, range.getEndLine(), otherUser, null, new Timestamp(update2.getWhen().getTime()), "comment 2", (short) 1, rev);
    update2.putComment(Status.PUBLISHED, comment2);
    try (NoteDbUpdateManager manager = updateManagerFactory.create(project)) {
        manager.add(update1);
        manager.add(update2);
        manager.execute();
    }
    ChangeNotes notes = newNotes(c);
    List<Comment> comments = notes.getComments().get(new RevId(rev));
    assertThat(comments).hasSize(2);
    assertThat(comments.get(0).message).isEqualTo("comment 1");
    assertThat(comments.get(1).message).isEqualTo("comment 2");
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "all_assignees").to(GetAllAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#end_block

#method_before
public List<String> filePaths(PatchSet ps) throws OrmException {
    Integer psId = ps.getPatchSetId();
    List<String> r = initFiles().get(psId);
    if (r == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        Optional<PatchList> p = getPatchList(c, ps);
        if (!p.isPresent()) {
            List<String> emptyFileList = Collections.emptyList();
            if (lazyLoad) {
                files.put(ps.getPatchSetId(), emptyFileList);
            }
            return emptyFileList;
        }
        r = new ArrayList<>(p.get().getPatches().size());
        for (PatchListEntry e : p.get().getPatches()) {
            if (Patch.COMMIT_MSG.equals(e.getNewName())) {
                continue;
            }
            switch(e.getChangeType()) {
                case ADDED:
                case MODIFIED:
                case DELETED:
                case COPIED:
                case REWRITE:
                    r.add(e.getNewName());
                    break;
                case RENAMED:
                    r.add(e.getOldName());
                    r.add(e.getNewName());
                    break;
            }
        }
        Collections.sort(r);
        r = Collections.unmodifiableList(r);
        files.put(psId, r);
    }
    return r;
}
#method_after
public List<String> filePaths(PatchSet ps) throws OrmException {
    Integer psId = ps.getPatchSetId();
    List<String> r = initFiles().get(psId);
    if (r == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        Optional<PatchList> p = getPatchList(c, ps);
        if (!p.isPresent()) {
            List<String> emptyFileList = Collections.emptyList();
            if (lazyLoad) {
                files.put(ps.getPatchSetId(), emptyFileList);
            }
            return emptyFileList;
        }
        r = new ArrayList<>(p.get().getPatches().size());
        for (PatchListEntry e : p.get().getPatches()) {
            if (Patch.isMagic(e.getNewName())) {
                continue;
            }
            switch(e.getChangeType()) {
                case ADDED:
                case MODIFIED:
                case DELETED:
                case COPIED:
                case REWRITE:
                    r.add(e.getNewName());
                    break;
                case RENAMED:
                    r.add(e.getOldName());
                    r.add(e.getNewName());
                    break;
            }
        }
        Collections.sort(r);
        r = Collections.unmodifiableList(r);
        files.put(psId, r);
    }
    return r;
}
#end_block

#method_before
public Collection<PatchSet> visiblePatchSets() throws OrmException {
    Predicate<PatchSet> predicate = new Predicate<PatchSet>() {

        @Override
        public boolean apply(PatchSet input) {
            try {
                return changeControl().isPatchVisible(input, db);
            } catch (OrmException e) {
                return false;
            }
        }
    };
    return FluentIterable.from(patchSets()).filter(predicate).toList();
}
#method_after
public Collection<PatchSet> visiblePatchSets() throws OrmException {
    Predicate<PatchSet> predicate = ps -> {
        try {
            return changeControl().isPatchVisible(ps, db);
        } catch (OrmException e) {
            return false;
        }
    };
    return FluentIterable.from(patchSets()).filter(predicate).toList();
}
#end_block

#method_before
public Account.Id assignee() throws OrmException {
    if (assignee == null) {
        if (!lazyLoad) {
            return null;
        }
        assignee = notes().getAssignee();
    }
    return assignee;
}
#method_after
public Optional<Account.Id> assignee() throws OrmException {
    if (assignee == null) {
        if (!lazyLoad) {
            return Optional.absent();
        }
        assignee = notes().getAssignee();
    }
    return assignee;
}
#end_block

#method_before
public void setAssignee(Account.Id assignee) {
    this.assignee = assignee;
}
#method_after
public void setAssignee(Optional<Account.Id> assignee) {
    this.assignee = assignee;
}
#end_block

#method_before
private void decodeAssignee(Multimap<String, IndexableField> doc, ChangeData cd) {
    Collection<IndexableField> ac = doc.get(ASSIGNEE_FIELD);
    Account.Id assignee = null;
    for (IndexableField a : ac) {
        int id = a.numericValue().intValue();
        assignee = new Account.Id(id);
    }
    cd.setAssignee(assignee);
}
#method_after
private void decodeAssignee(Multimap<String, IndexableField> doc, ChangeData cd) {
    IndexableField af = Iterables.getFirst(doc.get(ASSIGNEE_FIELD), null);
    Account.Id assignee = null;
    if (af != null) {
        int id = af.numericValue().intValue();
        if (id > 0) {
            assignee = new Account.Id(id);
        }
    }
    cd.setAssignee(Optional.fromNullable(assignee));
}
#end_block

#method_before
private void decodeReviewers(Multimap<String, IndexableField> doc, ChangeData cd) {
    cd.setReviewers(ChangeField.parseReviewerFieldValues(FluentIterable.from(doc.get(REVIEWER_FIELD)).transform(new Function<IndexableField, String>() {

        @Override
        public String apply(IndexableField in) {
            return in.stringValue();
        }
    })));
}
#method_after
private void decodeReviewers(Multimap<String, IndexableField> doc, ChangeData cd) {
    cd.setReviewers(ChangeField.parseReviewerFieldValues(FluentIterable.from(doc.get(REVIEWER_FIELD)).transform(IndexableField::stringValue)));
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeList.query("change:" + changeId.get() + " has:draft", Collections.<ListChangesOption>emptySet(), group.add(new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                hasDraftComments = result.length() > 0;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeList.query("change:" + changeId.get() + " has:draft", Collections.<ListChangesOption>emptySet(), group.add(new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                hasDraftComments = result.length() > 0;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(final ChangeInfo info) {
            info.init();
            addExtensionPoints(info, initCurrentRevision(info));
            final RevisionInfo rev = info.revision(revision);
            CallbackGroup group = new CallbackGroup();
            loadCommit(rev, group);
            group.addListener(new GerritCallback<Void>() {

                @Override
                public void onSuccess(Void result) {
                    if (base == null && rev.commit().parents().length() > 1) {
                        base = Gerrit.getUserPreferences().defaultBaseForMerges().getBase();
                    }
                    loadConfigInfo(info, base);
                }
            });
            group.done();
        }
    }));
}
#end_block

#method_before
private void addExtensionPoints(ChangeInfo change, RevisionInfo rev) {
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER, headerExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_BUTTONS, headerExtensionMiddle, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, headerExtensionRight, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, changeExtension, change, rev);
}
#method_after
private void addExtensionPoints(ChangeInfo change, RevisionInfo rev) {
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER, headerExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_BUTTONS, headerExtensionMiddle, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, headerExtensionRight, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, changeExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_RELATED_INFO_BLOCK, relatedExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_COMMIT_INFO_BLOCK, commitExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HISTORY_RIGHT_OF_BUTTONS, historyExtensionRight, change, rev);
}
#end_block

#method_before
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.currentRevision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacyId(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#method_after
private void gotoSibling(int offset) {
    if (offset > 0 && changeInfo.currentRevision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacyId(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#end_block

#method_before
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            renameFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile, files);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
            renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.isEdit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn()) {
        RevisionInfo rev = info.revision(revision);
        if (info.status().isOpen()) {
            if (isEditModeEnabled(info, rev)) {
                editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
                addFile.setVisible(!editMode.isVisible());
                deleteFile.setVisible(!editMode.isVisible());
                renameFile.setVisible(!editMode.isVisible());
                reviewMode.setVisible(!editMode.isVisible());
                addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile, files);
                deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
                renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
            } else {
                editMode.setVisible(false);
                addFile.setVisible(false);
                reviewMode.setVisible(false);
            }
            if (rev.isEdit()) {
                if (info.hasEditBasedOnCurrentPatchSet()) {
                    publishEdit.setVisible(true);
                } else {
                    rebaseEdit.setVisible(true);
                }
                deleteEdit.setVisible(true);
            }
        } else if (rev.isEdit()) {
            deleteEdit.setStyleName(style.highlight());
            deleteEdit.setVisible(true);
        }
    }
}
#end_block

#method_before
@UiHandler("publishEdit")
void onPublishEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.publishEdit(changeId);
}
#method_after
@UiHandler("publishEdit")
void onPublishEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.publishEdit(changeId, publishEdit, rebaseEdit, deleteEdit);
}
#end_block

#method_before
@UiHandler("rebaseEdit")
void onRebaseEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.rebaseEdit(changeId);
}
#method_after
@UiHandler("rebaseEdit")
void onRebaseEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.rebaseEdit(changeId, publishEdit, rebaseEdit, deleteEdit);
}
#end_block

#method_before
@UiHandler("deleteEdit")
void onDeleteEdit(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteChangeEdit())) {
        EditActions.deleteEdit(changeId);
    }
}
#method_after
@UiHandler("deleteEdit")
void onDeleteEdit(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteChangeEdit())) {
        EditActions.deleteEdit(changeId, publishEdit, rebaseEdit, deleteEdit);
    }
}
#end_block

#method_before
@UiHandler("publish")
void onPublish(@SuppressWarnings("unused") ClickEvent e) {
    DraftActions.publish(changeId, revision);
}
#method_after
@UiHandler("publish")
void onPublish(@SuppressWarnings("unused") ClickEvent e) {
    DraftActions.publish(changeId, revision, publish, deleteRevision, deleteChange);
}
#end_block

#method_before
@UiHandler("deleteRevision")
void onDeleteRevision(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteDraftRevision())) {
        DraftActions.delete(changeId, revision);
    }
}
#method_after
@UiHandler("deleteRevision")
void onDeleteRevision(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteDraftRevision())) {
        DraftActions.delete(changeId, revision, publish, deleteRevision, deleteChange);
    }
}
#end_block

#method_before
@UiHandler("deleteChange")
void onDeleteChange(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteDraftChange())) {
        DraftActions.delete(changeId);
    }
}
#method_after
@UiHandler("deleteChange")
void onDeleteChange(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteDraftChange())) {
        DraftActions.delete(changeId, publish, deleteRevision, deleteChange);
    }
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    KeyCommandSet keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    handlers.add(GlobalKey.add(this, keysNavigation));
    KeyCommandSet keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                star.setValue(!star.getValue(), true);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                reviewers.onOpenForm();
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                // differentiate F5 from 't' by checking the charCode(F5=0, t=116).
                if (event.getNativeEvent().getCharCode() == 0) {
                    Window.Location.reload();
                    return;
                }
                if (topic.canEdit()) {
                    topic.onEdit();
                }
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    handlers.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    KeyCommandSet keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    handlers.add(GlobalKey.add(this, keysNavigation));
    KeyCommandSet keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                star.setValue(!star.getValue(), true);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                reviewers.onOpenForm();
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                // differentiate F5 from 't' by checking the charCode(F5=0, t=116).
                if (event.getNativeEvent().getCharCode() == 0) {
                    Window.Location.reload();
                    return;
                }
                if (topic.canEdit()) {
                    topic.onEdit();
                }
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    handlers.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.setName(edit.commit().commit());
        info.setEdit(edit);
        if (edit.hasFiles()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.isEdit()) {
                info.setCurrentRevision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.isEdit()) {
                    info.setCurrentRevision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    addExtensionPoints(info, rev);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        // Comments are filtered for the current revision. Use parent
        // patch set for edits, as edits themself can never have comments.
        RevisionInfo p = RevisionInfo.findEditParentRevision(info.revisions().values());
        List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(p, group);
        loadFileList(b, rev, lastReply, group, comments, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.projectNameKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, String base) {
    final RevisionInfo rev = info.revision(revision);
    RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        // Comments are filtered for the current revision. Use parent
        // patch set for edits, as edits themself can never have comments.
        RevisionInfo p = RevisionInfo.findEditParentRevision(info.revisions().values());
        List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(p, group);
        loadFileList(b, rev, lastReply, group, comments, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    group.addListener(new AsyncCallback<Void>() {

        @Override
        public void onSuccess(Void result) {
            loadConfigInfo(info, rev);
        }

        @Override
        public void onFailure(Throwable caught) {
            logger.log(Level.SEVERE, "Loading file list and inline comments failed: " + caught.getMessage());
            loadConfigInfo(info, rev);
        }
    });
    group.done();
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.setName(edit.commit().commit());
        info.setEdit(edit);
        if (edit.hasFiles()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.isEdit()) {
                info.setCurrentRevision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.isEdit()) {
                    info.setCurrentRevision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    addExtensionPoints(info, rev);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        // Comments are filtered for the current revision. Use parent
        // patch set for edits, as edits themself can never have comments.
        RevisionInfo p = RevisionInfo.findEditParentRevision(info.revisions().values());
        List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(p, group);
        loadFileList(b, rev, lastReply, group, comments, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.projectNameKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, RevisionInfo rev) {
    if (loaded) {
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.projectNameKey(), new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    });
}
#end_block

#method_before
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    loadFileList(base, rev, myLastReply, group, comments, drafts);
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#method_after
private void loadDiff(RevisionInfo base, RevisionInfo rev, Timestamp myLastReply, CallbackGroup group) {
    List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    loadFileList(base, rev, myLastReply, group, comments, drafts);
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void loadFileList(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group, final List<NativeMap<JsArray<CommentInfo>>> comments, final List<NativeMap<JsArray<CommentInfo>>> drafts) {
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments != null ? comments.get(0) : null, drafts != null ? drafts.get(0) : null);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadFileList(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group, final List<NativeMap<JsArray<CommentInfo>>> comments, final List<NativeMap<JsArray<CommentInfo>>> drafts) {
    DiffApi.list(changeId.get(), rev.name(), base, group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments != null ? comments.get(0) : null, drafts != null ? drafts.get(0) : null);
        }

        @Override
        public void onFailure(Throwable caught) {
            files.showError(caught);
        }
    }));
}
#end_block

#method_before
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.isEdit()) {
        return;
    }
    ChangeApi.commitWithLinks(changeId.get(), rev.name(), group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.setCommit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.isEdit() || rev.commit() != null) {
        return;
    }
    ChangeApi.commitWithLinks(changeId.get(), rev.name(), group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.setCommit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#end_block

#method_before
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.currentRevision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacyId().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#method_after
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.currentRevision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    }
    new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacyId().get())).center();
    throw new IllegalStateException("no revision, cannot proceed");
}
#end_block

#method_before
private RevisionInfo resolveRevisionOrPatchSetId(ChangeInfo info, String revOrId, String defaultValue) {
    if (revOrId == null) {
        revOrId = defaultValue;
    } else if (!info.revisions().containsKey(revOrId)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revOrId.equals(String.valueOf(r._number()))) {
                revOrId = r.name();
                break;
            }
        }
    }
    return revOrId != null ? info.revision(revOrId) : null;
}
#method_after
private RevisionInfo resolveRevisionOrPatchSetId(ChangeInfo info, String revOrId, String defaultValue) {
    int parentNum;
    if (revOrId == null) {
        revOrId = defaultValue;
    } else if ((parentNum = toParentNum(revOrId)) > 0) {
        CommitInfo commitInfo = info.revision(revision).commit();
        JsArray<CommitInfo> parents = commitInfo.parents();
        if (parents.length() >= parentNum) {
            return RevisionInfo.forParent(-parentNum, parents.get(parentNum - 1));
        }
    } else if (!info.revisions().containsKey(revOrId)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revOrId.equals(String.valueOf(r._number()))) {
                revOrId = r.name();
                break;
            }
        }
    }
    return revOrId != null ? info.revision(revOrId) : null;
}
#end_block

#method_before
private boolean isSubmittable(ChangeInfo info) {
    boolean canSubmit = info.status().isOpen() && revision.equals(info.currentRevision()) && !info.revision(revision).draft();
    if (canSubmit && info.status() == Change.Status.NEW) {
        for (String name : info.labels()) {
            LabelInfo label = info.label(name);
            switch(label.status()) {
                case NEED:
                    statusText.setInnerText("Needs " + name);
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (label.blocking()) {
                        statusText.setInnerText("Not " + name);
                        canSubmit = false;
                    }
                    break;
                case MAY:
                case OK:
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#method_after
private boolean isSubmittable(ChangeInfo info) {
    boolean canSubmit = info.status().isOpen() && revision.equals(info.currentRevision()) && !info.revision(revision).draft();
    if (canSubmit && info.status() == Change.Status.NEW) {
        for (String name : info.labels()) {
            LabelInfo label = info.label(name);
            switch(label.status()) {
                case NEED:
                    statusText.setInnerText(Util.M.needs(name));
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (label.blocking()) {
                        statusText.setInnerText(Util.M.blockedOn(name));
                        canSubmit = false;
                    }
                    break;
                case MAY:
                case OK:
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#end_block

#method_before
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r.id() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(String.valueOf(r._number()))) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(selectedIdx);
}
#method_after
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r.id() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(String.valueOf(r._number()))) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    if (parents.length() > 1) {
        diffBase.addItem(Util.C.autoMerge(), "");
        for (int i = 0; i < parents.length(); i++) {
            int parentNum = i + 1;
            diffBase.addItem(Util.M.diffBaseParent(parentNum), String.valueOf(-parentNum));
        }
        int parentNum = toParentNum(base);
        if (parentNum > 0) {
            selectedIdx = list.length() + parentNum;
        }
    } else {
        diffBase.addItem(Util.C.baseDiffItem(), "");
    }
    diffBase.setSelectedIndex(selectedIdx);
}
#end_block

#method_before
public final int getMissingLabelIndex() {
    int i = -1;
    int ret = -1;
    List<LabelInfo> labels = Natives.asList(allLabels().values());
    for (LabelInfo label : labels) {
        i++;
        if (!permittedLabels().containsKey(label.name())) {
            continue;
        }
        JsArrayString values = permittedValues(label.name());
        if (values.length() == 0) {
            continue;
        }
        switch(label.status()) {
            case // Label is required for submit.
            NEED:
                if (ret != -1) {
                    // approve, return -1
                    return -1;
                } else {
                    ret = i;
                }
                continue;
            // Label already applied.
            case OK:
            case // Label is not required.
            MAY:
                continue;
            // Submit cannot happen, do not quick approve.
            case REJECT:
            case IMPOSSIBLE:
                return -1;
        }
    }
    return ret;
}
#method_after
public final int getMissingLabelIndex() {
    int i = -1;
    int ret = -1;
    List<LabelInfo> labels = Natives.asList(allLabels().values());
    for (LabelInfo label : labels) {
        i++;
        if (!permittedLabels().containsKey(label.name())) {
            continue;
        }
        JsArrayString values = permittedValues(label.name());
        if (values.length() == 0) {
            continue;
        }
        switch(label.status()) {
            case // Label is required for submit.
            NEED:
                if (ret != -1) {
                    // approve, return -1
                    return -1;
                }
                ret = i;
                continue;
            // Label already applied.
            case OK:
            case // Label is not required.
            MAY:
                continue;
            // Submit cannot happen, do not quick approve.
            case REJECT:
            case IMPOSSIBLE:
                return -1;
        }
    }
    return ret;
}
#end_block

#method_before
@Override
public boolean match(final ChangeData object) throws OrmException {
    return id.equals(object.notes().load().getAssignee());
}
#method_after
@Override
public boolean match(final ChangeData object) throws OrmException {
    if (id.get() == ChangeField.NO_ASSIGNEE) {
        return object.notes().load().getAssignee() == null;
    }
    return id.equals(object.notes().load().getAssignee());
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
private boolean checkPatchSets() {
    List<PatchSet> all;
    try {
        // Iterate in descending order.
        all = PS_ID_ORDER.sortedCopy(psUtil.byChange(db.get(), ctl.getNotes()));
    } catch (OrmException e) {
        return error("Failed to look up patch sets", e);
    }
    patchSetsBySha = MultimapBuilder.hashKeys(all.size()).treeSetValues(PS_ID_ORDER).build();
    Map<String, Ref> refs;
    try {
        refs = repo.getRefDatabase().exactRef(all.stream().map(ps -> ps.getId().toRefName()).toArray(i -> new String[i]));
    } catch (IOException e) {
        error("error reading refs", e);
        refs = Collections.emptyMap();
    }
    List<DeletePatchSetFromDbOp> deletePatchSetOps = new ArrayList<>();
    for (PatchSet ps : all) {
        // Check revision format.
        int psNum = ps.getId().get();
        String refName = ps.getId().toRefName();
        ObjectId objId = parseObjectId(ps.getRevision().get(), "patch set " + psNum);
        if (objId == null) {
            continue;
        }
        patchSetsBySha.put(objId, ps);
        // Check ref existence.
        ProblemInfo refProblem = null;
        Ref ref = refs.get(refName);
        if (ref == null) {
            refProblem = problem("Ref missing: " + refName);
        } else if (!objId.equals(ref.getObjectId())) {
            String actual = ref.getObjectId() != null ? ref.getObjectId().name() : "null";
            refProblem = problem(String.format("Expected %s to point to %s, found %s", ref.getName(), objId.name(), actual));
        }
        // Check object existence.
        RevCommit psCommit = parseCommit(objId, String.format("patch set %d", psNum));
        if (psCommit == null) {
            if (fix != null && fix.deletePatchSetIfCommitMissing) {
                deletePatchSetOps.add(new DeletePatchSetFromDbOp(lastProblem(), ps.getId()));
            }
            continue;
        } else if (refProblem != null && fix != null) {
            fixPatchSetRef(refProblem, ps);
        }
        if (ps.getId().equals(change().currentPatchSetId())) {
            currPsCommit = psCommit;
        }
    }
    // Delete any bad patch sets found above, in a single update.
    deletePatchSets(deletePatchSetOps);
    // Check for duplicates.
    for (Map.Entry<ObjectId, Collection<PatchSet>> e : patchSetsBySha.asMap().entrySet()) {
        if (e.getValue().size() > 1) {
            problem(String.format("Multiple patch sets pointing to %s: %s", e.getKey().name(), Collections2.transform(e.getValue(), PatchSet::getPatchSetId)));
        }
    }
    return currPs != null && currPsCommit != null;
}
#method_after
private boolean checkPatchSets() {
    List<PatchSet> all;
    try {
        // Iterate in descending order.
        all = PS_ID_ORDER.sortedCopy(psUtil.byChange(db.get(), ctl.getNotes()));
    } catch (OrmException e) {
        return error("Failed to look up patch sets", e);
    }
    patchSetsBySha = MultimapBuilder.hashKeys(all.size()).treeSetValues(PS_ID_ORDER).build();
    Map<String, Ref> refs;
    try {
        refs = repo.getRefDatabase().exactRef(all.stream().map(ps -> ps.getId().toRefName()).toArray(String[]::new));
    } catch (IOException e) {
        error("error reading refs", e);
        refs = Collections.emptyMap();
    }
    List<DeletePatchSetFromDbOp> deletePatchSetOps = new ArrayList<>();
    for (PatchSet ps : all) {
        // Check revision format.
        int psNum = ps.getId().get();
        String refName = ps.getId().toRefName();
        ObjectId objId = parseObjectId(ps.getRevision().get(), "patch set " + psNum);
        if (objId == null) {
            continue;
        }
        patchSetsBySha.put(objId, ps);
        // Check ref existence.
        ProblemInfo refProblem = null;
        Ref ref = refs.get(refName);
        if (ref == null) {
            refProblem = problem("Ref missing: " + refName);
        } else if (!objId.equals(ref.getObjectId())) {
            String actual = ref.getObjectId() != null ? ref.getObjectId().name() : "null";
            refProblem = problem(String.format("Expected %s to point to %s, found %s", ref.getName(), objId.name(), actual));
        }
        // Check object existence.
        RevCommit psCommit = parseCommit(objId, String.format("patch set %d", psNum));
        if (psCommit == null) {
            if (fix != null && fix.deletePatchSetIfCommitMissing) {
                deletePatchSetOps.add(new DeletePatchSetFromDbOp(lastProblem(), ps.getId()));
            }
            continue;
        } else if (refProblem != null && fix != null) {
            fixPatchSetRef(refProblem, ps);
        }
        if (ps.getId().equals(change().currentPatchSetId())) {
            currPsCommit = psCommit;
        }
    }
    // Delete any bad patch sets found above, in a single update.
    deletePatchSets(deletePatchSetOps);
    // Check for duplicates.
    for (Map.Entry<ObjectId, Collection<PatchSet>> e : patchSetsBySha.asMap().entrySet()) {
        if (e.getValue().size() > 1) {
            problem(String.format("Multiple patch sets pointing to %s: %s", e.getKey().name(), Collections2.transform(e.getValue(), PatchSet::getPatchSetId)));
        }
    }
    return currPs != null && currPsCommit != null;
}
#end_block

#method_before
private void sortAndFillEvents(Change change, Change noteDbChange, List<Event> events, Integer minPsNum) {
    Collections.sort(events);
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    // Ensure the first event in the list creates the change, setting the author
    // and any required footers.
    Event first = events.get(0);
    if (first instanceof PatchSetEvent && change.getOwner().equals(first.who)) {
        ((PatchSetEvent) first).createChange = true;
    } else {
        events.add(0, new CreateChangeEvent(change, minPsNum));
    }
    // Fill in any missing patch set IDs using the latest patch set of the
    // change at the time of the event, because NoteDb can't represent actions
    // with no associated patch set ID. This workaround is as if a user added a
    // ChangeMessage on the change by replying from the latest patch set.
    // 
    // Start with the first patch set that actually exists. If there are no
    // patch sets at all, minPsNum will be null, so just bail and use 1 as the
    // patch set ID. The corresponding patch set won't exist, but this change is
    // probably corrupt anyway, as deleting the last draft patch set should have
    // deleted the whole change.
    int ps = firstNonNull(minPsNum, 1);
    for (Event e : events) {
        if (e.psId == null) {
            e.psId = new PatchSet.Id(change.getId(), ps);
        } else {
            ps = Math.max(ps, e.psId.get());
        }
    }
}
#method_after
private void sortAndFillEvents(Change change, Change noteDbChange, List<Event> events, Integer minPsNum) {
    new EventSorter(events).sort();
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    // Ensure the first event in the list creates the change, setting the author
    // and any required footers.
    Event first = events.get(0);
    if (first instanceof PatchSetEvent && change.getOwner().equals(first.who)) {
        ((PatchSetEvent) first).createChange = true;
    } else {
        events.add(0, new CreateChangeEvent(change, minPsNum));
    }
    // Final pass to correct some inconsistencies.
    // 
    // First, fill in any missing patch set IDs using the latest patch set of
    // the change at the time of the event, because NoteDb can't represent
    // actions with no associated patch set ID. This workaround is as if a user
    // added a ChangeMessage on the change by replying from the latest patch
    // set.
    // 
    // Start with the first patch set that actually exists. If there are no
    // patch sets at all, minPsNum will be null, so just bail and use 1 as the
    // patch set ID. The corresponding patch set won't exist, but this change is
    // probably corrupt anyway, as deleting the last draft patch set should have
    // deleted the whole change.
    // 
    // Second, ensure timestamps are nondecreasing, by copying the previous
    // timestamp if this happens. This assumes that the only way this can happen
    // is due to dependency constraints, and it is ok to give an event the same
    // timestamp as one of its dependencies.
    int ps = firstNonNull(minPsNum, 1);
    for (int i = 0; i < events.size(); i++) {
        Event e = events.get(i);
        if (e.psId == null) {
            e.psId = new PatchSet.Id(change.getId(), ps);
        } else {
            ps = Math.max(ps, e.psId.get());
        }
        if (i > 0) {
            Event p = events.get(i - 1);
            if (e.when.before(p.when)) {
                e.when = p.when;
            }
        }
    }
}
#end_block

#method_before
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) {
    List<CodeReviewCommit> sorted = CodeReviewCommit.ORDER.sortedCopy(toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    boolean first = true;
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (first && args.mergeTip.getInitialTip() == null) {
            ops.add(new CherryPickUnbornRootOp(n));
        } else if (n.getParentCount() == 0) {
            ops.add(new CherryPickRootOp(n));
        } else if (n.getParentCount() == 1) {
            ops.add(new CherryPickOneOp(n));
        } else {
            ops.add(new CherryPickMultipleParentsOp(n));
        }
        first = false;
    }
    return ops;
}
#method_after
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = CodeReviewCommit.ORDER.sortedCopy(toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    boolean first = true;
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (first && args.mergeTip.getInitialTip() == null) {
            ops.add(new FastForwardOp(args, n));
        } else if (n.getParentCount() == 0) {
            ops.add(new CherryPickRootOp(n));
        } else if (n.getParentCount() == 1) {
            ops.add(new CherryPickOneOp(n));
        } else {
            ops.add(new CherryPickMultipleParentsOp(n));
        }
        first = false;
    }
    return ops;
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    if (args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge)) {
        // on the commit so we have nothing further to perform at this time.
        return;
    }
    // There are multiple parents, so this is a merge commit. We don't want
    // to cherry-pick the merge as clients can't easily rebase their history
    // with that merge present and replaced by an equivalent merge with a
    // different first parent. So instead behave as though MERGE_IF_NECESSARY
    // was configured.
    MergeTip mergeTip = args.mergeTip;
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge)) {
        mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
        toMerge.setStatusCode(CLEAN_MERGE);
    } else {
        PersonIdent myIdent = new PersonIdent(args.serverIdent, ctx.getWhen());
        CodeReviewCommit result = args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.repo, args.rw, args.inserter, args.destBranch, mergeTip.getCurrentTip(), toMerge);
        result = amendGitlink(result);
        mergeTip.moveTipTo(result, toMerge);
        args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    }
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    if (args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge)) {
        // on the commit so we have nothing further to perform at this time.
        return;
    }
    // There are multiple parents, so this is a merge commit. We don't want
    // to cherry-pick the merge as clients can't easily rebase their history
    // with that merge present and replaced by an equivalent merge with a
    // different first parent. So instead behave as though MERGE_IF_NECESSARY
    // was configured.
    MergeTip mergeTip = args.mergeTip;
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge) && !args.submoduleOp.hasSubscription(args.destBranch)) {
        mergeTip.moveTipTo(toMerge, toMerge);
    } else {
        PersonIdent myIdent = new PersonIdent(args.serverIdent, ctx.getWhen());
        CodeReviewCommit result = args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.repo, args.rw, args.inserter, args.destBranch, mergeTip.getCurrentTip(), toMerge);
        result = amendGitlink(result);
        mergeTip.moveTipTo(result, toMerge);
        args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    }
}
#end_block

#method_before
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = sort(toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    boolean first = true;
    for (CodeReviewCommit c : sorted) {
        if (c.getParentCount() > 1) {
            // Since there is a merge commit, sort and prune again using
            // MERGE_IF_NECESSARY semantics to avoid creating duplicate
            // commits.
            // 
            sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, sorted);
            break;
        }
    }
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (first && args.mergeTip.getInitialTip() == null) {
            ops.add(new RebaseUnbornRootOp(n));
        } else if (n.getParentCount() == 0) {
            ops.add(new RebaseRootOp(n));
        } else if (n.getParentCount() == 1) {
            ops.add(new RebaseOneOp(n));
        } else {
            ops.add(new RebaseMultipleParentsOp(n));
        }
        first = false;
    }
    return ops;
}
#method_after
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = sort(toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    boolean first = true;
    for (CodeReviewCommit c : sorted) {
        if (c.getParentCount() > 1) {
            // Since there is a merge commit, sort and prune again using
            // MERGE_IF_NECESSARY semantics to avoid creating duplicate
            // commits.
            // 
            sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, sorted);
            break;
        }
    }
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (first && args.mergeTip.getInitialTip() == null) {
            ops.add(new FastForwardOp(args, n));
        } else if (n.getParentCount() == 0) {
            ops.add(new RebaseRootOp(n));
        } else if (n.getParentCount() == 1) {
            ops.add(new RebaseOneOp(n));
        } else {
            ops.add(new RebaseMultipleParentsOp(n));
        }
        first = false;
    }
    return ops;
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    // There are multiple parents, so this is a merge commit. We don't want
    // to rebase the merge as clients can't easily rebase their history with
    // that merge present and replaced by an equivalent merge with a different
    // first parent. So instead behave as though MERGE_IF_NECESSARY was
    // configured.
    MergeTip mergeTip = args.mergeTip;
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge)) {
        mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
        toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
    } else {
        CodeReviewCommit newTip = args.mergeUtil.mergeOneCommit(args.serverIdent, args.serverIdent, args.repo, args.rw, args.inserter, args.destBranch, mergeTip.getCurrentTip(), toMerge);
        mergeTip.moveTipTo(amendGitlink(newTip), toMerge);
        args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    }
    acceptMergeTip(mergeTip);
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    // There are multiple parents, so this is a merge commit. We don't want
    // to rebase the merge as clients can't easily rebase their history with
    // that merge present and replaced by an equivalent merge with a different
    // first parent. So instead behave as though MERGE_IF_NECESSARY was
    // configured.
    MergeTip mergeTip = args.mergeTip;
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge) && !args.submoduleOp.hasSubscription(args.destBranch)) {
        mergeTip.moveTipTo(toMerge, toMerge);
    } else {
        CodeReviewCommit newTip = args.mergeUtil.mergeOneCommit(args.serverIdent, args.serverIdent, args.repo, args.rw, args.inserter, args.destBranch, mergeTip.getCurrentTip(), toMerge);
        mergeTip.moveTipTo(amendGitlink(newTip), toMerge);
    }
    args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    acceptMergeTip(mergeTip);
}
#end_block

#method_before
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription());
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.notifyHandling).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null) {
        args.changeMerged.fire(updatedChange, mergedPatchSet, args.accountCache.get(submitter.getAccountId()).getAccount(), args.mergeTip.getCurrentTip().name(), ctx.getWhen());
    }
}
#method_after
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            args.repoManager.setProjectDescription(p.getProject().getNameKey(), p.getProject().getDescription());
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.notifyHandling).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null && !args.dryrun) {
        args.changeMerged.fire(updatedChange, mergedPatchSet, args.accountCache.get(submitter.getAccountId()).getAccount(), args.mergeTip.getCurrentTip().name(), ctx.getWhen());
    }
}
#end_block

#method_before
protected CodeReviewCommit amendGitlink(CodeReviewCommit commit) throws IntegrationException {
    if (!args.submoduleOp.hasSubscription(args.destBranch)) {
        return commit;
    }
    // Modify the commit with gitlink update
    try {
        CodeReviewCommit newCommit = args.submoduleOp.composeGitlinksCommit(args.destBranch, commit);
        newCommit.copyFrom(commit);
        return newCommit;
    } catch (SubmoduleException | IOException e) {
        throw new IntegrationException("cannot update gitlink for the commit at branch: " + args.destBranch);
    }
}
#method_after
protected CodeReviewCommit amendGitlink(CodeReviewCommit commit) throws IntegrationException {
    if (!args.submoduleOp.hasSubscription(args.destBranch)) {
        return commit;
    }
    // Modify the commit with gitlink update
    try {
        return args.submoduleOp.composeGitlinksCommit(args.destBranch, commit);
    } catch (SubmoduleException | IOException e) {
        throw new IntegrationException("cannot update gitlink for the commit at branch: " + args.destBranch);
    }
}
#end_block

#method_before
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    if (!args.submoduleOp.hasSubscription(args.destBranch)) {
        CodeReviewCommit firstFastForward = args.mergeUtil.getFirstFastForward(args.mergeTip.getInitialTip(), args.rw, sorted);
        if (firstFastForward != null && !firstFastForward.equals(args.mergeTip.getInitialTip())) {
            ops.add(new FastForwardOp(args, firstFastForward));
        }
    }
    // For every other commit do a pair-wise merge.
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        ops.add(new MergeOneOp(args, n));
    }
    return ops;
}
#method_after
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    if (args.mergeTip.getInitialTip() == null || !args.submoduleOp.hasSubscription(args.destBranch)) {
        CodeReviewCommit firstFastForward = args.mergeUtil.getFirstFastForward(args.mergeTip.getInitialTip(), args.rw, sorted);
        if (firstFastForward != null && !firstFastForward.equals(args.mergeTip.getInitialTip())) {
            ops.add(new FastForwardOp(args, firstFastForward));
        }
    }
    // For every other commit do a pair-wise merge.
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        ops.add(new MergeOneOp(args, n));
    }
    return ops;
}
#end_block

#method_before
void process(Event e) {
    if (sorted.contains(e)) {
        return;
    }
    if (deps.get(e).isEmpty()) {
        sorted.add(e);
        for (Event w : waiting.get(e)) {
            deps.get(w).remove(e);
            process(w);
        }
    }
}
#method_after
void process(Event e) {
    if (sorted.contains(e)) {
        return;
    }
    // re-process those events in case they can now be emitted.
    if (deps.get(e).isEmpty()) {
        sorted.add(e);
        for (Event w : waiting.get(e)) {
            deps.get(w).remove(e);
            process(w);
        }
    }
}
#end_block

#method_before
@Override
public Result rebuild(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    try (NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject())) {
        buildUpdates(manager, ChangeBundle.fromReviewDb(db, changeId));
        return execute(db, changeId, manager);
    }
}
#method_after
@Override
public Result rebuild(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    try (NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject())) {
        buildUpdates(manager, bundleReader.fromReviewDb(db, changeId));
        return execute(db, changeId, manager);
    }
}
#end_block

#method_before
@Override
public NoteDbUpdateManager stage(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject());
    buildUpdates(manager, ChangeBundle.fromReviewDb(db, changeId));
    manager.stage();
    return manager;
}
#method_after
@Override
public NoteDbUpdateManager stage(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject());
    buildUpdates(manager, bundleReader.fromReviewDb(db, changeId));
    manager.stage();
    return manager;
}
#end_block

#method_before
@Override
public boolean rebuildProject(ReviewDb db, ImmutableMultimap<Project.NameKey, Change.Id> allChanges, Project.NameKey project, Repository allUsersRepo) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    checkArgument(allChanges.containsKey(project));
    boolean ok = true;
    ProgressMonitor pm = new TextProgressMonitor(new PrintWriter(System.out));
    pm.beginTask(FormatUtil.elide(project.get(), 50), allChanges.get(project).size());
    try (NoteDbUpdateManager manager = updateManagerFactory.create(project);
        ObjectInserter allUsersInserter = allUsersRepo.newObjectInserter();
        RevWalk allUsersRw = new RevWalk(allUsersInserter.newReader())) {
        manager.setAllUsersRepo(allUsersRepo, allUsersRw, allUsersInserter, new ChainedReceiveCommands(allUsersRepo));
        for (Change.Id changeId : allChanges.get(project)) {
            try {
                buildUpdates(manager, ChangeBundle.fromReviewDb(db, changeId));
            } catch (NoPatchSetsException e) {
                log.warn(e.getMessage());
            } catch (Throwable t) {
                log.error("Failed to rebuild change " + changeId, t);
                ok = false;
            }
            pm.update(1);
        }
        manager.execute();
    } finally {
        pm.endTask();
    }
    return ok;
}
#method_after
@Override
public boolean rebuildProject(ReviewDb db, ImmutableMultimap<Project.NameKey, Change.Id> allChanges, Project.NameKey project, Repository allUsersRepo) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    checkArgument(allChanges.containsKey(project));
    boolean ok = true;
    ProgressMonitor pm = new TextProgressMonitor(new PrintWriter(System.out));
    pm.beginTask(FormatUtil.elide(project.get(), 50), allChanges.get(project).size());
    try (NoteDbUpdateManager manager = updateManagerFactory.create(project);
        ObjectInserter allUsersInserter = allUsersRepo.newObjectInserter();
        RevWalk allUsersRw = new RevWalk(allUsersInserter.newReader())) {
        manager.setAllUsersRepo(allUsersRepo, allUsersRw, allUsersInserter, new ChainedReceiveCommands(allUsersRepo));
        for (Change.Id changeId : allChanges.get(project)) {
            try {
                buildUpdates(manager, bundleReader.fromReviewDb(db, changeId));
            } catch (NoPatchSetsException e) {
                log.warn(e.getMessage());
            } catch (Throwable t) {
                log.error("Failed to rebuild change " + changeId, t);
                ok = false;
            }
            pm.update(1);
        }
        manager.execute();
    } finally {
        pm.endTask();
    }
    return ok;
}
#end_block

#method_before
@Override
protected void configure() {
    install(new RestApiModule() {

        @Override
        protected void configure() {
            get(PROJECT_KIND, "lfs:config").to(GetLfsConfig.class);
            get(PROJECT_KIND, "lfs:settings").to(GetLfsSettings.class);
            put(PROJECT_KIND, "lfs:settings").to(PutLfsSettings.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    install(new RestApiModule() {

        @Override
        protected void configure() {
            get(PROJECT_KIND, "lfs:config-project").to(GetLfsProjectConfig.class);
            get(PROJECT_KIND, "lfs:config-global").to(GetLfsGlobalConfig.class);
            put(PROJECT_KIND, "lfs:config-global").to(PutLfsGlobalConfig.class);
        }
    });
}
#end_block

#method_before
public boolean isAssignee() {
    Account.Id current_assignee = notes.getAssignee();
    if (current_assignee != null && getUser().isIdentifiedUser()) {
        Account.Id id = getUser().asIdentifiedUser().getAccountId();
        return id.equals(current_assignee);
    }
    return false;
}
#method_after
public boolean isAssignee() {
    Account.Id currentAssignee = notes.getAssignee();
    if (currentAssignee != null && getUser().isIdentifiedUser()) {
        Account.Id id = getUser().getAccountId();
        return id.equals(currentAssignee);
    }
    return false;
}
#end_block

#method_before
public boolean canEditAssignee() {
    return isOwner() || getProjectControl().isOwner() || getUser().getCapabilities().canAdministrateServer() || getRefControl().canEditAssignee() || isAssignee();
}
#method_after
public boolean canEditAssignee() {
    return isOwner() || getProjectControl().isOwner() || getRefControl().canEditAssignee() || isAssignee();
}
#end_block

#method_before
private RevisionNoteMap getRevisionNoteMap(RevWalk rw, ObjectId curr) throws ConfigInvalidException, OrmException, IOException {
    if (curr.equals(ObjectId.zeroId())) {
        return RevisionNoteMap.emptyMap();
    }
    if (migration.readChanges()) {
        // If reading from changes is enabled, then the old ChangeNotes may have
        // already parsed the revision notes. We can reuse them as long as the ref
        // hasn't advanced.
        ChangeNotes notes = getNotes();
        if (notes != null && notes.revisionNoteMap != null) {
            ObjectId idFromNotes = firstNonNull(notes.load().getRevision(), ObjectId.zeroId());
            if (idFromNotes.equals(curr)) {
                return notes.revisionNoteMap;
            }
        }
    }
    NoteMap noteMap = NoteMap.read(rw.getObjectReader(), rw.parseCommit(curr));
    // parse any existing revision notes so we can merge them.
    return RevisionNoteMap.parse(noteUtil, getId(), rw.getObjectReader(), noteMap, false);
}
#method_after
private RevisionNoteMap getRevisionNoteMap(RevWalk rw, ObjectId curr) throws ConfigInvalidException, OrmException, IOException {
    if (curr.equals(ObjectId.zeroId())) {
        return RevisionNoteMap.emptyMap();
    }
    if (migration.readChanges()) {
        // If reading from changes is enabled, then the old ChangeNotes may have
        // already parsed the revision notes. We can reuse them as long as the ref
        // hasn't advanced.
        ChangeNotes notes = getNotes();
        if (notes != null && notes.revisionNoteMap != null) {
            ObjectId idFromNotes = firstNonNull(notes.load().getRevision(), ObjectId.zeroId());
            if (idFromNotes.equals(curr)) {
                return notes.revisionNoteMap;
            }
        }
    }
    NoteMap noteMap = NoteMap.read(rw.getObjectReader(), rw.parseCommit(curr));
    // parse any existing revision notes so we can merge them.
    return RevisionNoteMap.parse(noteUtil, getId(), rw.getObjectReader(), noteMap, PatchLineComment.Status.PUBLISHED);
}
#end_block

#method_before
private void parseAssignee(ChangeNotesCommit commit) throws ConfigInvalidException {
    // Only last assignee
    if (assignee != null) {
        return;
    }
    String assigneeValue = parseOneFooter(commit, FOOTER_ASSIGNEE);
    if (assigneeValue != null) {
        PersonIdent ident = RawParseUtils.parsePersonIdent(assigneeValue);
        assignee = noteUtil.parseIdent(ident, id);
    }
}
#method_after
private void parseAssignee(ChangeNotesCommit commit) throws ConfigInvalidException {
    if (assignee != null) {
        return;
    }
    String assigneeValue = parseOneFooter(commit, FOOTER_ASSIGNEE);
    if (assigneeValue != null) {
        PersonIdent ident = RawParseUtils.parsePersonIdent(assigneeValue);
        assignee = noteUtil.parseIdent(ident, id);
    }
}
#end_block

#method_before
private void parseNotes() throws IOException, ConfigInvalidException {
    ObjectReader reader = walk.getObjectReader();
    ChangeNotesCommit tipCommit = walk.parseCommit(tip);
    revisionNoteMap = RevisionNoteMap.parse(noteUtil, id, reader, NoteMap.read(reader, tipCommit), false);
    Map<RevId, RevisionNote> rns = revisionNoteMap.revisionNotes;
    for (Map.Entry<RevId, RevisionNote> e : rns.entrySet()) {
        for (PatchLineComment plc : e.getValue().comments) {
            comments.put(e.getKey(), plc);
        }
    }
    for (PatchSet ps : patchSets.values()) {
        RevisionNote rn = rns.get(ps.getRevision());
        if (rn != null && rn.pushCert != null) {
            ps.setPushCertificate(rn.pushCert);
        }
    }
}
#method_after
private void parseNotes() throws IOException, ConfigInvalidException {
    ObjectReader reader = walk.getObjectReader();
    ChangeNotesCommit tipCommit = walk.parseCommit(tip);
    revisionNoteMap = RevisionNoteMap.parse(noteUtil, id, reader, NoteMap.read(reader, tipCommit), PatchLineComment.Status.PUBLISHED);
    Map<RevId, RevisionNote> rns = revisionNoteMap.revisionNotes;
    for (Map.Entry<RevId, RevisionNote> e : rns.entrySet()) {
        for (PatchLineComment plc : e.getValue().comments) {
            comments.put(e.getKey(), plc);
        }
    }
    for (PatchSet ps : patchSets.values()) {
        RevisionNote rn = rns.get(ps.getRevision());
        if (rn != null && rn.pushCert != null) {
            ps.setPushCertificate(rn.pushCert);
        }
    }
}
#end_block

#method_before
@Test
public void assigneeCommit() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setAssignee(otherUserId);
    ObjectId result = update.commit();
    assertThat(result).isNotNull();
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(update.getResult());
        rw.parseBody(commit);
        assertThat(commit.getFullMessage()).endsWith("Assignee: " + otherUser.getNameEmail());
    }
}
#method_after
@Test
public void assigneeCommit() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setAssignee(otherUserId);
    ObjectId result = update.commit();
    assertThat(result).isNotNull();
    try (RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(update.getResult());
        rw.parseBody(commit);
        String strIdent = otherUser.getName() + " <" + otherUserId + "@" + serverId + ">";
        assertThat(commit.getFullMessage()).contains("Assignee: " + strIdent);
    }
}
#end_block

#method_before
@Test
public void assigneeChangeNotes() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setAssignee(otherUserId);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getAssignee()).isEqualTo(otherUserId);
}
#method_after
@Test
public void assigneeChangeNotes() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setAssignee(otherUserId);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getAssignee()).isEqualTo(otherUserId);
    update = newUpdate(c, changeOwner);
    update.setAssignee(changeOwner.getAccountId());
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getAssignee()).isEqualTo(changeOwner.getAccountId());
}
#end_block

#method_before
@Test
public void pushCertificate() throws Exception {
    String pushCert = "certificate version 0.1\n" + "pusher This is not a real push cert\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: GnuPG v1\n" + "\n" + "Nor is this a real signature.\n" + "-----END PGP SIGNATURE-----\n";
    // ps2 with push cert
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    RevCommit commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit, pushCert);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(readNote(notes, commit)).isEqualTo(pushCert);
    Map<PatchSet.Id, PatchSet> patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isEmpty();
    // comment on ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    Timestamp ts = TimeUtil.nowTs();
    update.putComment(newPublishedComment(psId2, "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, ts, "Comment", (short) 1, commit.name()));
    update.commit();
    notes = newNotes(c);
    assertThat(readNote(notes, commit)).isEqualTo(pushCert + "Revision: " + commit.name() + "\n" + "Patch-set: 2\n" + "File: a.txt\n" + "\n" + "1:2-3:4\n" + ChangeNoteUtil.formatTime(serverIdent, ts) + "\n" + "Author: Change Owner <1@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 7\n" + "Comment\n" + "\n");
    patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isNotEmpty();
}
#method_after
@Test
public void pushCertificate() throws Exception {
    String pushCert = "certificate version 0.1\n" + "pusher This is not a real push cert\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: GnuPG v1\n" + "\n" + "Nor is this a real signature.\n" + "-----END PGP SIGNATURE-----\n";
    // ps2 with push cert
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    RevCommit commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit, pushCert);
    update.commit();
    ChangeNotes notes = newNotes(c);
    String note = readNote(notes, commit);
    if (!testJson()) {
        assertThat(note).isEqualTo(pushCert);
    }
    Map<PatchSet.Id, PatchSet> patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isEmpty();
    // comment on ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetId(psId2);
    Timestamp ts = TimeUtil.nowTs();
    update.putComment(newPublishedComment(psId2, "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, ts, "Comment", (short) 1, commit.name()));
    update.commit();
    notes = newNotes(c);
    patchSets = notes.getPatchSets();
    assertThat(patchSets.get(psId1).getPushCertificate()).isNull();
    assertThat(patchSets.get(psId2).getPushCertificate()).isEqualTo(pushCert);
    assertThat(notes.getComments()).isNotEmpty();
    if (!testJson()) {
        assertThat(readNote(notes, commit)).isEqualTo(pushCert + "Revision: " + commit.name() + "\n" + "Patch-set: 2\n" + "File: a.txt\n" + "\n" + "1:2-3:4\n" + ChangeNoteUtil.formatTime(serverIdent, ts) + "\n" + "Author: Change Owner <1@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 7\n" + "Comment\n" + "\n");
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatSide1() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    Timestamp time3 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range3 = new CommentRange(3, 0, 4, 1);
    PatchLineComment comment3 = newPublishedComment(psId, "file2", uuid3, range3, range3.getEndLine(), otherUser, null, time3, message3, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment3);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "File: file2\n" + "\n" + "3:0-4:1\n" + ChangeNoteUtil.formatTime(serverIdent, time3) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
    }
}
#method_after
@Test
public void patchLineCommentNotesFormatSide1() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    Timestamp time3 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range3 = new CommentRange(3, 0, 4, 1);
    PatchLineComment comment3 = newPublishedComment(psId, "file2", uuid3, range3, range3.getEndLine(), otherUser, null, time3, message3, (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment3);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "File: file2\n" + "\n" + "3:0-4:1\n" + ChangeNoteUtil.formatTime(serverIdent, time3) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatSide0() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String message1 = "comment 1";
    String message2 = "comment 2";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n");
    }
}
#method_after
@Test
public void patchLineCommentNotesFormatSide0() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String message1 = "comment 1";
    String message2 = "comment 2";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    Timestamp time2 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment1 = newPublishedComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment1);
    update.commit();
    update = newUpdate(c, otherUser);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    PatchLineComment comment2 = newPublishedComment(psId, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time2, message2, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment2);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + ChangeNoteUtil.formatTime(serverIdent, time1) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + ChangeNoteUtil.formatTime(serverIdent, time2) + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n");
        }
    }
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatMultiplePatchSetsSameRevId() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Timestamp time = TimeUtil.nowTs();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    PatchSet.Id psId1 = c.currentPatchSetId();
    PatchSet.Id psId2 = new PatchSet.Id(c.getId(), psId1.get() + 1);
    PatchLineComment comment1 = newPublishedComment(psId1, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time, message1, (short) 0, revId.get());
    PatchLineComment comment2 = newPublishedComment(psId1, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time, message2, (short) 0, revId.get());
    PatchLineComment comment3 = newPublishedComment(psId2, "file1", uuid3, range1, range1.getEndLine(), otherUser, null, time, message3, (short) 0, revId.get());
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId2);
    update.putComment(comment3);
    update.putComment(comment2);
    update.putComment(comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "Base-for-patch-set: 2\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment1, revId, comment2, revId, comment3));
}
#method_after
@Test
public void patchLineCommentNotesFormatMultiplePatchSetsSameRevId() throws Exception {
    Change c = newChange();
    String uuid1 = "uuid1";
    String uuid2 = "uuid2";
    String uuid3 = "uuid3";
    String message1 = "comment 1";
    String message2 = "comment 2";
    String message3 = "comment 3";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    CommentRange range2 = new CommentRange(2, 1, 3, 1);
    Timestamp time = TimeUtil.nowTs();
    RevId revId = new RevId("abcd1234abcd1234abcd1234abcd1234abcd1234");
    PatchSet.Id psId1 = c.currentPatchSetId();
    PatchSet.Id psId2 = new PatchSet.Id(c.getId(), psId1.get() + 1);
    PatchLineComment comment1 = newPublishedComment(psId1, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time, message1, (short) 0, revId.get());
    PatchLineComment comment2 = newPublishedComment(psId1, "file1", uuid2, range2, range2.getEndLine(), otherUser, null, time, message2, (short) 0, revId.get());
    PatchLineComment comment3 = newPublishedComment(psId2, "file1", uuid3, range1, range1.getEndLine(), otherUser, null, time, message3, (short) 0, revId.get());
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setPatchSetId(psId2);
    update.putComment(comment3);
    update.putComment(comment2);
    update.putComment(comment1);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Base-for-patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid1\n" + "Bytes: 9\n" + "comment 1\n" + "\n" + "2:1-3:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid2\n" + "Bytes: 9\n" + "comment 2\n" + "\n" + "Base-for-patch-set: 2\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Other Account <2@gerrit>\n" + "UUID: uuid3\n" + "Bytes: 9\n" + "comment 3\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(revId, comment1, revId, comment2, revId, comment3));
}
#end_block

#method_before
@Test
public void patchLineCommentNotesFormatWeirdUser() throws Exception {
    Account account = new Account(new Account.Id(3), TimeUtil.nowTs());
    account.setFullName("Weird\n\u0002<User>\n");
    account.setPreferredEmail(" we\r\nird@ex>ample<.com");
    accountCache.put(account);
    IdentifiedUser user = userFactory.create(account.getId());
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, user);
    String uuid = "uuid";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment = newPublishedComment(psId, "file1", uuid, range, range.getEndLine(), user, null, time, "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Weird\u0002User <3@gerrit>\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(comment.getRevId(), comment));
}
#method_after
@Test
public void patchLineCommentNotesFormatWeirdUser() throws Exception {
    Account account = new Account(new Account.Id(3), TimeUtil.nowTs());
    account.setFullName("Weird\n\u0002<User>\n");
    account.setPreferredEmail(" we\r\nird@ex>ample<.com");
    accountCache.put(account);
    IdentifiedUser user = userFactory.create(account.getId());
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, user);
    String uuid = "uuid";
    CommentRange range = new CommentRange(1, 1, 2, 1);
    Timestamp time = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    PatchLineComment comment = newPublishedComment(psId, "file1", uuid, range, range.getEndLine(), user, null, time, "comment", (short) 1, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update.setPatchSetId(psId);
    update.putComment(comment);
    update.commit();
    ChangeNotes notes = newNotes(c);
    try (RevWalk walk = new RevWalk(repo)) {
        ArrayList<Note> notesInTree = Lists.newArrayList(notes.revisionNoteMap.noteMap.iterator());
        Note note = Iterables.getOnlyElement(notesInTree);
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        String noteString = new String(bytes, UTF_8);
        String timeStr = ChangeNoteUtil.formatTime(serverIdent, time);
        if (!testJson()) {
            assertThat(noteString).isEqualTo("Revision: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Patch-set: 1\n" + "File: file1\n" + "\n" + "1:1-2:1\n" + timeStr + "\n" + "Author: Weird\u0002User <3@gerrit>\n" + "UUID: uuid\n" + "Bytes: 7\n" + "comment\n" + "\n");
        }
    }
    assertThat(notes.getComments()).isEqualTo(ImmutableMultimap.of(comment.getRevId(), comment));
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus() != Change.Status.MERGED) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
    }
    out.submittable = Submit.submittable(cd);
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (includeSubmittable) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private Paths getPaths() {
    if (paths == null) {
        paths = new Paths();
    }
    return paths;
}
#method_after
@Provides
@Singleton
private Paths getPaths() {
    if (paths == null) {
        paths = new Paths(options);
    }
    return paths;
}
#end_block

#method_before
@Override
protected void configureServlets() {
    serveRegex("^/Documentation/(.+)$").with(named(DOC_SERVLET));
    serve("/static/*").with(SiteStaticDirectoryServlet.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE, Path.class, Resource.class).maximumWeight(1 << 20).weigher(ResourceServlet.Weigher.class);
        }
    });
    install(new CoreStaticModule());
    if (options.enablePolyGWT()) {
        filter("/*").through(PolyGWTFilter.class);
        install(new GwtUiModule());
        install(new PolyGerritUiModule(true));
    } else if (options.enablePolyGerrit()) {
        install(new PolyGerritUiModule(false));
    } else if (options.enableDefaultUi()) {
        install(new GwtUiModule());
    }
}
#method_after
@Override
protected void configureServlets() {
    serveRegex("^/Documentation/(.+)$").with(named(DOC_SERVLET));
    serve("/static/*").with(SiteStaticDirectoryServlet.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE, Path.class, Resource.class).maximumWeight(1 << 20).weigher(ResourceServlet.Weigher.class);
        }
    });
    if (!options.headless()) {
        install(new CoreStaticModule());
    }
    if (options.enablePolyGerrit()) {
        install(new PolyGerritModule());
    }
    if (options.enableGwtUi()) {
        install(new GwtUiModule());
    }
}
#end_block

#method_before
@Provides
@Singleton
@Named(ROBOTS_TXT_SERVLET)
HttpServlet getRobotsTxtServlet(@GerritServerConfig Config cfg, SitePaths sitePaths, @Named(CACHE) Cache<Path, Resource> cache) {
    Path configPath = sitePaths.resolve(cfg.getString("httpd", null, "robotsFile"));
    if (configPath != null) {
        if (exists(configPath) && isReadable(configPath)) {
            return new SingleFileServlet(cache, configPath, true);
        } else {
            log.warn("Cannot read httpd.robotsFile, using default");
        }
    }
    Paths p = getPaths();
    if (p.warFs != null) {
        return new SingleFileServlet(cache, p.warFs.getPath("/robots.txt"), false);
    } else {
        return new SingleFileServlet(cache, webappSourcePath("robots.txt"), true);
    }
}
#method_after
@Provides
@Singleton
@Named(ROBOTS_TXT_SERVLET)
HttpServlet getRobotsTxtServlet(@GerritServerConfig Config cfg, SitePaths sitePaths, @Named(CACHE) Cache<Path, Resource> cache) {
    Path configPath = sitePaths.resolve(cfg.getString("httpd", null, "robotsFile"));
    if (configPath != null) {
        if (exists(configPath) && isReadable(configPath)) {
            return new SingleFileServlet(cache, configPath, true);
        }
        log.warn("Cannot read httpd.robotsFile, using default");
    }
    Paths p = getPaths();
    if (p.warFs != null) {
        return new SingleFileServlet(cache, p.warFs.getPath("/robots.txt"), false);
    }
    return new SingleFileServlet(cache, webappSourcePath("robots.txt"), true);
}
#end_block

#method_before
@Provides
@Singleton
@Named(FAVICON_SERVLET)
HttpServlet getFaviconServlet(@Named(CACHE) Cache<Path, Resource> cache) {
    Paths p = getPaths();
    if (p.warFs != null) {
        return new SingleFileServlet(cache, p.warFs.getPath("/favicon.ico"), false);
    } else {
        return new SingleFileServlet(cache, webappSourcePath("favicon.ico"), true);
    }
}
#method_after
@Provides
@Singleton
@Named(FAVICON_SERVLET)
HttpServlet getFaviconServlet(@Named(CACHE) Cache<Path, Resource> cache) {
    Paths p = getPaths();
    if (p.warFs != null) {
        return new SingleFileServlet(cache, p.warFs.getPath("/favicon.ico"), false);
    }
    return new SingleFileServlet(cache, webappSourcePath("favicon.ico"), true);
}
#end_block

#method_before
@Provides
@Singleton
@Named(GWT_UI_SERVLET)
HttpServlet getGwtUiServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    Paths p = getPaths();
    if (p.warFs != null) {
        return new WarGwtUiServlet(cache, p.warFs);
    } else {
        return new DirectoryGwtUiServlet(cache, p.unpackedWar, p.isDev());
    }
}
#method_after
@Provides
@Singleton
@Named(GWT_UI_SERVLET)
HttpServlet getGwtUiServlet(@Named(CACHE) Cache<Path, Resource> cache) throws IOException {
    Paths p = getPaths();
    if (p.warFs != null) {
        return new WarGwtUiServlet(cache, p.warFs);
    }
    return new DirectoryGwtUiServlet(cache, p.unpackedWar, p.isDev());
}
#end_block

#method_before
private File getLauncherLoadedFrom() {
    File war;
    try {
        war = GerritLauncher.getDistributionArchive();
    } catch (IOException e) {
        if ((e instanceof FileNotFoundException) && GerritLauncher.NOT_ARCHIVED.equals(e.getMessage())) {
            return null;
        } else {
            ProvisionException pe = new ProvisionException("Error reading gerrit.war");
            pe.initCause(e);
            throw pe;
        }
    }
    return war;
}
#method_after
private File getLauncherLoadedFrom() {
    File war;
    try {
        war = GerritLauncher.getDistributionArchive();
    } catch (IOException e) {
        if ((e instanceof FileNotFoundException) && GerritLauncher.NOT_ARCHIVED.equals(e.getMessage())) {
            return null;
        }
        ProvisionException pe = new ProvisionException("Error reading gerrit.war");
        pe.initCause(e);
        throw pe;
    }
    return war;
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    if (options.enableDefaultUi() || options.enablePolyGWT()) {
        filter("/").through(XsrfCookieFilter.class);
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
    }
    serve("/cat/*").with(CatServlet.class);
    if (authConfig.getAuthType() != AuthType.OAUTH && authConfig.getAuthType() != AuthType.OPENID) {
        serve("/logout").with(HttpLogoutServlet.class);
        serve("/signout").with(HttpLogoutServlet.class);
    }
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?tools/(.*)$").with(ToolServlet.class);
    serveRegex("^/(?:a/)?access/(.*)$").with(AccessRestApiServlet.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?config/(.*)$").with(ConfigRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    filter("/Documentation/").through(QueryDocumentationFilter.class);
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    if (options.enableGwtUi()) {
        filter("/").through(XsrfCookieFilter.class);
        filter("/accounts/self/detail").through(XsrfCookieFilter.class);
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
        // Forward PolyGerrit URLs to their respective GWT equivalents.
        serveRegex("^/(c|q|x|admin|dashboard|settings)/(.*)").with(gerritUrl());
    }
    serve("/cat/*").with(CatServlet.class);
    if (authConfig.getAuthType() != AuthType.OAUTH && authConfig.getAuthType() != AuthType.OPENID) {
        serve("/logout").with(HttpLogoutServlet.class);
        serve("/signout").with(HttpLogoutServlet.class);
    }
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?tools/(.*)$").with(ToolServlet.class);
    // Bind servlets for REST root collections.
    // The '/plugins/' root collection is already handled by HttpPluginServlet
    // which is bound in HttpPluginModule. We cannot bind it here again although
    // this means that plugins can't add REST views on PLUGIN_KIND.
    serveRegex("^/(?:a/)?access/(.*)$").with(AccessRestApiServlet.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?config/(.*)$").with(ConfigRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    filter("/Documentation/").through(QueryDocumentationFilter.class);
}
#end_block

#method_before
@Override
protected Path getResourcePath(String pathInfo) throws IOException {
    if (bowerComponents == null) {
        throw new IOException("No polymer components found: " + zip + ". Run `buck build //polygerrit-ui:polygerrit_components`?");
    }
    // Why we need to remove here bower_components suffix?
    if (pathInfo.startsWith("bower_components")) {
        int offset = "bower_components".length() + 1;
        pathInfo = pathInfo.substring(offset, pathInfo.length());
    }
    return bowerComponents.resolve(pathInfo);
}
#method_after
@Override
protected Path getResourcePath(String pathInfo) throws IOException {
    if (bowerComponents == null) {
        throw new IOException("No polymer components found: " + zip + ". Run `buck build //polygerrit-ui:polygerrit_components`?");
    }
    return bowerComponents.resolve(pathInfo);
}
#end_block

