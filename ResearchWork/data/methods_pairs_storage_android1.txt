140
#method_before
public void setDnsConfigurationForNetwork(int netId, Collection<InetAddress> servers, String domains, boolean isDefaultNetwork) {
    updateParametersSettings();
    updatePrivateDnsSettings();
    final String[] serverStrs = NetworkUtils.makeStrings(servers);
    final String[] domainStrs = (domains == null) ? new String[0] : domains.split(" ");
    final int[] params = { mSampleValidity, mSuccessThreshold, mMinSamples, mMaxSamples };
    final boolean useTls = shouldUseTls(mPrivateDnsMode);
    // TODO: Populate tlsHostname once it's decided how the hostname's IP
    // addresses will be resolved:
    // 
    // [1] network-provided DNS servers are included here with the
    // hostname and netd will use the network-provided servers to
    // resolve the hostname and fix up its internal structures, or
    // 
    // [2] network-provided DNS servers are included here without the
    // hostname, the ConnectivityService layer resolves the given
    // hostname, and then reconfigures netd with this information.
    // 
    // In practice, there will always be a need for ConnectivityService or
    // the captive portal app to use the network-provided services to make
    // some queries. This argues in favor of [1], in concert with another
    // mechanism, perhaps setting a high bit in the netid, to indicate
    // via existing DNS APIs which set of servers (network-provided or
    // non-network-provided private DNS) should be queried.
    final String tlsHostname = "";
    try {
        mNMS.setDnsConfigurationForNetwork(netId, serverStrs, domainStrs, params, useTls, tlsHostname);
    } catch (Exception e) {
        Slog.e(TAG, "Error setting DNS configuration: " + e);
    }
    // the privacy protections of things like DNS-over-TLS.
    if (isDefaultNetwork)
        setDefaultDnsSystemProperties(servers);
    flushVmDnsCache();
}
#method_after
public void setDnsConfigurationForNetwork(int netId, Collection<InetAddress> servers, String domains, boolean isDefaultNetwork) {
    updateParametersSettings();
    updatePrivateDnsSettings();
    final String[] serverStrs = NetworkUtils.makeStrings(servers);
    final String[] domainStrs = (domains == null) ? new String[0] : domains.split(" ");
    final int[] params = { mSampleValidity, mSuccessThreshold, mMinSamples, mMaxSamples };
    final boolean useTls = shouldUseTls(mPrivateDnsMode);
    // TODO: Populate tlsHostname once it's decided how the hostname's IP
    // addresses will be resolved:
    // 
    // [1] network-provided DNS servers are included here with the
    // hostname and netd will use the network-provided servers to
    // resolve the hostname and fix up its internal structures, or
    // 
    // [2] network-provided DNS servers are included here without the
    // hostname, the ConnectivityService layer resolves the given
    // hostname, and then reconfigures netd with this information.
    // 
    // In practice, there will always be a need for ConnectivityService or
    // the captive portal app to use the network-provided services to make
    // some queries. This argues in favor of [1], in concert with another
    // mechanism, perhaps setting a high bit in the netid, to indicate
    // via existing DNS APIs which set of servers (network-provided or
    // non-network-provided private DNS) should be queried.
    final String tlsHostname = "";
    try {
        mNMS.setDnsConfigurationForNetwork(netId, serverStrs, domainStrs, params, useTls, tlsHostname);
    } catch (Exception e) {
        Slog.e(TAG, "Error setting DNS configuration: " + e);
        return;
    }
    // the privacy protections of things like DNS-over-TLS.
    if (isDefaultNetwork)
        setDefaultDnsSystemProperties(servers);
    flushVmDnsCache();
}
#end_block

#method_before
@Override
public boolean setDataSaverModeEnabled(boolean enable) {
    if (DBG)
        Log.d(TAG, "setDataSaverMode: " + enable);
    synchronized (mQuotaLock) {
        if (mDataSaverMode == enable) {
            Log.w(TAG, "setDataSaverMode(): already " + mDataSaverMode);
            return true;
        }
        Trace.traceBegin(Trace.TRACE_TAG_NETWORK, "bandwidthEnableDataSaver");
        try {
            final boolean changed = mNetdService.bandwidthEnableDataSaver(enable);
            if (changed) {
                mDataSaverMode = enable;
            } else {
                Log.w(TAG, "setDataSaverMode(" + enable + "): netd command silently failed");
            }
            return changed;
        } catch (RemoteException e) {
            Log.w(TAG, "setDataSaverMode(" + enable + "): netd command failed", e);
            return false;
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_NETWORK);
        }
    }
}
#method_after
@Override
public boolean setDataSaverModeEnabled(boolean enable) {
    mContext.enforceCallingOrSelfPermission(NETWORK_SETTINGS, TAG);
    if (DBG)
        Log.d(TAG, "setDataSaverMode: " + enable);
    synchronized (mQuotaLock) {
        if (mDataSaverMode == enable) {
            Log.w(TAG, "setDataSaverMode(): already " + mDataSaverMode);
            return true;
        }
        Trace.traceBegin(Trace.TRACE_TAG_NETWORK, "bandwidthEnableDataSaver");
        try {
            final boolean changed = mNetdService.bandwidthEnableDataSaver(enable);
            if (changed) {
                mDataSaverMode = enable;
            } else {
                Log.w(TAG, "setDataSaverMode(" + enable + "): netd command silently failed");
            }
            return changed;
        } catch (RemoteException e) {
            Log.w(TAG, "setDataSaverMode(" + enable + "): netd command failed", e);
            return false;
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_NETWORK);
        }
    }
}
#end_block

#method_before
@Override
public boolean setDataSaverModeEnabled(boolean enable) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    if (DBG)
        Log.d(TAG, "setDataSaverMode: " + enable);
    synchronized (mQuotaLock) {
        if (mDataSaverMode == enable) {
            Log.w(TAG, "setDataSaverMode(): already " + mDataSaverMode);
            return true;
        }
        Trace.traceBegin(Trace.TRACE_TAG_NETWORK, "bandwidthEnableDataSaver");
        try {
            final boolean changed = mNetdService.bandwidthEnableDataSaver(enable);
            if (changed) {
                mDataSaverMode = enable;
            } else {
                Log.w(TAG, "setDataSaverMode(" + enable + "): netd command silently failed");
            }
            return changed;
        } catch (RemoteException e) {
            Log.w(TAG, "setDataSaverMode(" + enable + "): netd command failed", e);
            return false;
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_NETWORK);
        }
    }
}
#method_after
@Override
public boolean setDataSaverModeEnabled(boolean enable) {
    mContext.enforceCallingOrSelfPermission(NETWORK_SETTINGS, TAG);
    if (DBG)
        Log.d(TAG, "setDataSaverMode: " + enable);
    synchronized (mQuotaLock) {
        if (mDataSaverMode == enable) {
            Log.w(TAG, "setDataSaverMode(): already " + mDataSaverMode);
            return true;
        }
        Trace.traceBegin(Trace.TRACE_TAG_NETWORK, "bandwidthEnableDataSaver");
        try {
            final boolean changed = mNetdService.bandwidthEnableDataSaver(enable);
            if (changed) {
                mDataSaverMode = enable;
            } else {
                Log.w(TAG, "setDataSaverMode(" + enable + "): netd command silently failed");
            }
            return changed;
        } catch (RemoteException e) {
            Log.w(TAG, "setDataSaverMode(" + enable + "): netd command failed", e);
            return false;
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_NETWORK);
        }
    }
}
#end_block

#method_before
public static InterfaceParams getByName(String name) {
    if (name == null)
        return null;
    try {
        final NetworkInterface netif = NetworkInterface.getByName(name);
        if (netif != null) {
            final MacAddress macAddr = netif.isLoopback() ? null : MacAddress.fromBytes(netif.getHardwareAddress());
            return new InterfaceParams(name, netif.getIndex(), macAddr, netif.getMTU());
        }
    } catch (IllegalArgumentException | SocketException e) {
    }
    return null;
}
#method_after
public static InterfaceParams getByName(String name) {
    final NetworkInterface netif = getNetworkInterfaceByName(name);
    if (netif == null)
        return null;
    // Not all interfaces have MAC addresses, e.g. rmnet_data0.
    final MacAddress macAddr = getMacAddress(netif);
    try {
        return new InterfaceParams(name, netif.getIndex(), macAddr, netif.getMTU());
    } catch (IllegalArgumentException | SocketException e) {
        return null;
    }
}
#end_block

#method_before
public void startProvisioning(ProvisioningConfiguration req) {
    if (!req.isValid()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_INVALID_PROVISIONING);
        return;
    }
    mInterfaceParams = InterfaceParams.getByName(mInterfaceName);
    if (mInterfaceParams == null) {
        logError("Failed to find InterfaceParams for " + mInterfaceName);
    // TODO: return;
    }
    mCallback.setNeighborDiscoveryOffload(true);
    sendMessage(CMD_START, new ProvisioningConfiguration(req));
}
#method_after
public void startProvisioning(ProvisioningConfiguration req) {
    if (!req.isValid()) {
        doImmediateProvisioningFailure(IpManagerEvent.ERROR_INVALID_PROVISIONING);
        return;
    }
    mInterfaceParams = InterfaceParams.getByName(mInterfaceName);
    if (mInterfaceParams == null) {
        logError("Failed to find InterfaceParams for " + mInterfaceName);
    // TODO: call doImmediateProvisioningFailure() with an error code
    // indicating something like "interface not ready".
    }
    mCallback.setNeighborDiscoveryOffload(true);
    sendMessage(CMD_START, new ProvisioningConfiguration(req));
}
#end_block

#method_before
@Override
protected String getLogRecString(Message msg) {
    final String logLine = String.format("%s/%d %d %d %s [%s]", mInterfaceName, mInterfaceParams == null ? -1 : mInterfaceParams.index, msg.arg1, msg.arg2, Objects.toString(msg.obj), mMsgStateLogger);
    final String richerLogLine = getWhatToString(msg.what) + " " + logLine;
    mLog.log(richerLogLine);
    if (DBG) {
        Log.d(mTag, richerLogLine);
    }
    mMsgStateLogger.reset();
    return logLine;
}
#method_after
@Override
protected String getLogRecString(Message msg) {
    final String logLine = String.format("%s/%d %d %d %s [%s]", mInterfaceName, (mInterfaceParams == null) ? -1 : mInterfaceParams.index, msg.arg1, msg.arg2, Objects.toString(msg.obj), mMsgStateLogger);
    final String richerLogLine = getWhatToString(msg.what) + " " + logLine;
    mLog.log(richerLogLine);
    if (DBG) {
        Log.d(mTag, richerLogLine);
    }
    mMsgStateLogger.reset();
    return logLine;
}
#end_block

#method_before
@Override
public void enter() {
    stopAllIP();
    resetLinkProperties();
    mCallback.onLinkPropertiesChange(new LinkProperties(mLinkProperties));
    if (mStartTimeMillis > 0) {
        recordMetric(IpManagerEvent.COMPLETE_LIFECYCLE);
        mStartTimeMillis = 0;
    }
}
#method_after
@Override
public void enter() {
    stopAllIP();
    resetLinkProperties();
    if (mStartTimeMillis > 0) {
        recordMetric(IpManagerEvent.COMPLETE_LIFECYCLE);
        mStartTimeMillis = 0;
    }
}
#end_block

#method_before
@Test
public void testNullInterfaceReturnsNull() {
    assertTrue(null == InterfaceParams.getByName(null));
}
#method_after
@Test
public void testNullInterfaceReturnsNull() {
    assertNull(InterfaceParams.getByName(null));
}
#end_block

#method_before
@Test
public void testNonExistentInterfaceReturnsNull() {
    assertTrue(null == InterfaceParams.getByName("doesnotexist0"));
}
#method_after
@Test
public void testNonExistentInterfaceReturnsNull() {
    assertNull(InterfaceParams.getByName("doesnotexist0"));
}
#end_block

#method_before
@Test
public void testLoopback() {
    final InterfaceParams ifParams = InterfaceParams.getByName("lo");
    assertTrue(ifParams != null);
    assertEquals("lo", ifParams.name);
    assertTrue(ifParams.index > 0);
    assertTrue(ifParams.macAddr != null);
    assertTrue(ifParams.defaultMtu >= NetworkConstants.ETHER_MTU);
}
#method_after
@Test
public void testLoopback() {
    final InterfaceParams ifParams = InterfaceParams.getByName("lo");
    assertNotNull(ifParams);
    assertEquals("lo", ifParams.name);
    assertTrue(ifParams.index > 0);
    assertNotNull(ifParams.macAddr);
    assertTrue(ifParams.defaultMtu >= NetworkConstants.ETHER_MTU);
}
#end_block

#method_before
boolean isConnected() {
    return (msgType != NetlinkConstants.RTM_DELNEIGH) && StructNdMsg.isNudStateConnected(nudState);
}
#method_after
boolean isConnected() {
    return (msgType != RTM_DELNEIGH) && StructNdMsg.isNudStateConnected(nudState);
}
#end_block

#method_before
boolean isValid() {
    return (msgType != NetlinkConstants.RTM_DELNEIGH) && StructNdMsg.isNudStateValid(nudState);
}
#method_after
boolean isValid() {
    return (msgType != RTM_DELNEIGH) && StructNdMsg.isNudStateValid(nudState);
}
#end_block

#method_before
@Override
public String toString() {
    final StringJoiner j = new StringJoiner(",", "NeighborEvent{", "}");
    return j.add("@" + elapsedMs).add(NetlinkConstants.stringForNlMsgType(msgType)).add("if=" + ifindex).add(ip.getHostAddress()).add(StructNdMsg.stringForNudState(nudState)).add("[" + macAddr + "]").toString();
}
#method_after
@Override
public String toString() {
    final StringJoiner j = new StringJoiner(",", "NeighborEvent{", "}");
    return j.add("@" + elapsedMs).add(stringForNlMsgType(msgType)).add("if=" + ifindex).add(ip.getHostAddress()).add(StructNdMsg.stringForNudState(nudState)).add("[" + macAddr + "]").toString();
}
#end_block

#method_before
private void parseNetlinkMessageBuffer(ByteBuffer byteBuffer, long whenMs) {
    while (byteBuffer.remaining() > 0) {
        final int position = byteBuffer.position();
        final NetlinkMessage nlMsg = NetlinkMessage.parse(byteBuffer);
        if (nlMsg == null || nlMsg.getHeader() == null) {
            byteBuffer.position(position);
            mLog.e("unparsable netlink msg: " + NetlinkConstants.hexify(byteBuffer));
            break;
        }
        final int srcPortId = nlMsg.getHeader().nlmsg_pid;
        if (srcPortId != 0) {
            mLog.e("non-kernel source portId: " + BitUtils.uint32(srcPortId));
            break;
        }
        if (nlMsg instanceof NetlinkErrorMessage) {
            mLog.e("netlink error: " + nlMsg);
            continue;
        } else if (!(nlMsg instanceof RtNetlinkNeighborMessage)) {
            mLog.i("non-rtnetlink neighbor msg: " + nlMsg);
            continue;
        }
        evaluateRtNetlinkNeighborMessage((RtNetlinkNeighborMessage) nlMsg, whenMs);
    }
}
#method_after
private void parseNetlinkMessageBuffer(ByteBuffer byteBuffer, long whenMs) {
    while (byteBuffer.remaining() > 0) {
        final int position = byteBuffer.position();
        final NetlinkMessage nlMsg = NetlinkMessage.parse(byteBuffer);
        if (nlMsg == null || nlMsg.getHeader() == null) {
            byteBuffer.position(position);
            mLog.e("unparsable netlink msg: " + hexify(byteBuffer));
            break;
        }
        final int srcPortId = nlMsg.getHeader().nlmsg_pid;
        if (srcPortId != 0) {
            mLog.e("non-kernel source portId: " + BitUtils.uint32(srcPortId));
            break;
        }
        if (nlMsg instanceof NetlinkErrorMessage) {
            mLog.e("netlink error: " + nlMsg);
            continue;
        } else if (!(nlMsg instanceof RtNetlinkNeighborMessage)) {
            mLog.i("non-rtnetlink neighbor msg: " + nlMsg);
            continue;
        }
        evaluateRtNetlinkNeighborMessage((RtNetlinkNeighborMessage) nlMsg, whenMs);
    }
}
#end_block

#method_before
private void evaluateRtNetlinkNeighborMessage(RtNetlinkNeighborMessage neighMsg, long whenMs) {
    final short msgType = neighMsg.getHeader().nlmsg_type;
    final StructNdMsg ndMsg = neighMsg.getNdHeader();
    if (ndMsg == null) {
        mLog.e("RtNetlinkNeighborMessage without ND message header!");
        return;
    }
    final int ifindex = ndMsg.ndm_ifindex;
    final InetAddress destination = neighMsg.getDestination();
    final short nudState = (msgType == NetlinkConstants.RTM_DELNEIGH) ? StructNdMsg.NUD_NONE : ndMsg.ndm_state;
    final NeighborEvent event = new NeighborEvent(whenMs, msgType, ifindex, destination, nudState, getMacAddress(neighMsg.getLinkLayerAddress()));
    if (VDBG) {
        Log.d(TAG, neighMsg.toString());
    }
    if (DBG) {
        Log.d(TAG, event.toString());
    }
    mConsumer.accept(event);
}
#method_after
private void evaluateRtNetlinkNeighborMessage(RtNetlinkNeighborMessage neighMsg, long whenMs) {
    final short msgType = neighMsg.getHeader().nlmsg_type;
    final StructNdMsg ndMsg = neighMsg.getNdHeader();
    if (ndMsg == null) {
        mLog.e("RtNetlinkNeighborMessage without ND message header!");
        return;
    }
    final int ifindex = ndMsg.ndm_ifindex;
    final InetAddress destination = neighMsg.getDestination();
    final short nudState = (msgType == RTM_DELNEIGH) ? StructNdMsg.NUD_NONE : ndMsg.ndm_state;
    final NeighborEvent event = new NeighborEvent(whenMs, msgType, ifindex, destination, nudState, getMacAddress(neighMsg.getLinkLayerAddress()));
    if (VDBG) {
        Log.d(TAG, neighMsg.toString());
    }
    if (DBG) {
        Log.d(TAG, event.toString());
    }
    mConsumer.accept(event);
}
#end_block

#method_before
private static MacAddress getMacAddress(byte[] linkLayerAddress) {
    if (linkLayerAddress != null) {
        try {
            return MacAddress.fromBytes(linkLayerAddress);
        } catch (IllegalArgumentException e) {
        }
    }
    return null;
}
#method_after
private static MacAddress getMacAddress(byte[] linkLayerAddress) {
    if (linkLayerAddress != null) {
        try {
            return MacAddress.fromBytes(linkLayerAddress);
        } catch (IllegalArgumentException e) {
            Log.e(TAG, "Failed to parse link-layer address: " + hexify(linkLayerAddress));
        }
    }
    return null;
}
#end_block

#method_before
public void test_odirect() throws Exception {
    File testFile = createTempFile("test_odirect", "");
    try {
        FileDescriptor fd = Libcore.os.open(testFile.toString(), O_WRONLY | O_DIRECT, S_IRUSR | S_IWUSR);
        assertNotNull(fd);
        assertTrue(fd.valid());
        int flags = Libcore.os.fcntlVoid(fd, F_GETFL);
        assertTrue(0 != (flags & O_DIRECT));
        Libcore.os.close(fd);
    } catch (ErrnoException e) {
        fail();
    } finally {
        testFile.delete();
    }
}
#method_after
public void test_odirect() throws Exception {
    File testFile = createTempFile("test_odirect", "");
    try {
        FileDescriptor fd = Libcore.os.open(testFile.toString(), O_WRONLY | O_DIRECT, S_IRUSR | S_IWUSR);
        assertNotNull(fd);
        assertTrue(fd.valid());
        int flags = Libcore.os.fcntlVoid(fd, F_GETFL);
        assertTrue("Expected file flags to include " + O_DIRECT + ", actual value: " + flags, 0 != (flags & O_DIRECT));
        Libcore.os.close(fd);
    } finally {
        testFile.delete();
    }
}
#end_block

#method_before
@SystemApi
public void updateConfigForPhoneId(int phoneId, String simState) {
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "Error updating config for phoneId=" + phoneId + " ICarrierConfigLoader is null");
            return;
        }
        loader.updateConfigForPhoneId(phoneId, simState);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error updating config for phoneId=" + phoneId + ": " + ex.toString());
    }
}
#method_after
@SystemApi
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void updateConfigForPhoneId(int phoneId, String simState) {
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "Error updating config for phoneId=" + phoneId + " ICarrierConfigLoader is null");
            return;
        }
        loader.updateConfigForPhoneId(phoneId, simState);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error updating config for phoneId=" + phoneId + ": " + ex.toString());
    }
}
#end_block

#method_before
@NonNull
@SystemApi
public static PersistableBundle getDefaultConfig() {
    return new PersistableBundle(sDefaults);
}
#method_after
@NonNull
@SystemApi
@SuppressLint("Doclava125")
public static PersistableBundle getDefaultConfig() {
    return new PersistableBundle(sDefaults);
}
#end_block

#method_before
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
    if (SystemProperty.environment.value() == SystemProperty.Environment.Value.Production) {
        // do something that's production-only
        response.setStatus(HttpServletResponse.SC_NOT_ACCEPTABLE);
        return;
    }
    UserService userService = UserServiceFactory.getUserService();
    User currentUser = userService.getCurrentUser();
    String pathInfo = request.getPathInfo();
    String[] pathParts = pathInfo.split("/");
    if (pathParts.length > 1) {
        // Read the json output
        Reader postJsonReader = new InputStreamReader(request.getInputStream());
        Gson gson = new GsonBuilder().create();
        String testType = pathParts[1];
        if (testType.equalsIgnoreCase("report")) {
            TestReportDataObject trdObj = gson.fromJson(postJsonReader, TestReportDataObject.class);
            logger.log(Level.INFO, "trdObj => " + trdObj);
            trdObj.testList.forEach(t -> {
                t.testRunList.forEach(tr -> {
                    TestEntity testEntity = new TestEntity(tr.testName);
                    Key testRunKey = KeyFactory.createKey(testEntity.key, TestRunEntity.KIND, tr.startTimestamp);
                    tr.coverageList.forEach(trc -> {
                        CoverageEntity coverageEntity = new CoverageEntity(testRunKey, trc.group, trc.coveredLineCount, trc.totalLineCount, trc.filePath, trc.projectName, trc.projectVersion, trc.lineCoverage);
                        datastore.put(coverageEntity.toEntity());
                    });
                    tr.profilingList.forEach(trp -> {
                        ProfilingPointRunEntity profilingEntity = new ProfilingPointRunEntity(testRunKey, trp.name, trp.type, trp.regressionMode, trp.labels, trp.values, trp.xLabel, trp.yLabel, trp.options);
                        datastore.put(profilingEntity.toEntity());
                    });
                    TestCaseRunEntity testCaseEntity = new TestCaseRunEntity();
                    tr.testCaseRunList.forEach(trtcr -> {
                        for (int idx = 0; idx < trtcr.testCaseNames.size(); idx++) {
                            testCaseEntity.addTestCase(trtcr.testCaseNames.get(idx), trtcr.results.get(idx));
                        }
                    });
                    datastore.put(testCaseEntity.toEntity());
                    tr.deviceInfoList.forEach(trdi -> {
                        DeviceInfoEntity deviceInfoEntity = new DeviceInfoEntity(testRunKey, trdi.branch, trdi.product, trdi.buildFlavor, trdi.buildId, trdi.abiBitness, trdi.abiName);
                        ;
                        datastore.put(deviceInfoEntity.toEntity());
                    });
                    tr.buildTargetList.forEach(trbt -> {
                        BuildTargetEntity buildTargetEntity = new BuildTargetEntity(trbt.targetName);
                        datastore.put(buildTargetEntity.toEntity());
                    });
                    tr.branchList.forEach(trb -> {
                        BranchEntity branchEntity = new BranchEntity(trb.branchName);
                        datastore.put(branchEntity.toEntity());
                    });
                    TestRunEntity testRunEntity = new TestRunEntity(testEntity.key, TestRunType.fromNumber(tr.type), tr.startTimestamp, tr.endTimestamp, tr.testBuildId, tr.hostName, tr.passCount, tr.failCount, tr.testCaseIds, tr.links, tr.coveredLineCount, tr.totalLineCount);
                    datastore.put(testRunEntity.toEntity());
                    Entity test = testEntity.toEntity();
                    Transaction txn = datastore.beginTransaction();
                    try {
                        // Check if test already exists in the datastore
                        try {
                            Entity oldTest = datastore.get(testEntity.key);
                            TestEntity oldTestEntity = TestEntity.fromEntity(oldTest);
                            if (oldTestEntity == null || !oldTestEntity.equals(testEntity)) {
                                datastore.put(test);
                            }
                        } catch (EntityNotFoundException e) {
                            datastore.put(test);
                        }
                        txn.commit();
                    } catch (ConcurrentModificationException | DatastoreFailureException | DatastoreTimeoutException e) {
                        logger.log(Level.WARNING, "Retrying test run insert: " + test.getKey());
                    } finally {
                        if (txn.isActive()) {
                            logger.log(Level.WARNING, "Transaction rollback forced for run: " + testRunEntity.key);
                            txn.rollback();
                        }
                    }
                });
            });
        } else {
            TestPlanReportDataObject tprdObj = gson.fromJson(postJsonReader, TestPlanReportDataObject.class);
        }
    } else {
        logger.log(Level.WARNING, "URL path parameter is omitted!");
    }
    response.setStatus(HttpServletResponse.SC_OK);
}
#method_after
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
    if (SystemProperty.environment.value() == SystemProperty.Environment.Value.Production) {
        response.setStatus(HttpServletResponse.SC_NOT_ACCEPTABLE);
        return;
    }
    UserService userService = UserServiceFactory.getUserService();
    User currentUser = userService.getCurrentUser();
    String pathInfo = request.getPathInfo();
    String[] pathParts = pathInfo.split("/");
    if (pathParts.length > 1) {
        // Read the json output
        Reader postJsonReader = new InputStreamReader(request.getInputStream());
        Gson gson = new GsonBuilder().create();
        String testType = pathParts[1];
        if (testType.equalsIgnoreCase("report")) {
            TestReportDataObject trdObj = gson.fromJson(postJsonReader, TestReportDataObject.class);
            logger.log(Level.INFO, "trdObj => " + trdObj);
            trdObj.testList.forEach(test -> {
                test.testRunList.forEach(testRun -> {
                    TestEntity testEntity = new TestEntity(testRun.testName);
                    Key testRunKey = KeyFactory.createKey(testEntity.key, TestRunEntity.KIND, testRun.startTimestamp);
                    List<TestCaseReference> failingTestCases = new ArrayList<>();
                    for (int idx = 0; idx < testRun.failingTestcaseIds.size(); idx++) {
                        failingTestCases.add(new TestCaseReference(testRun.failingTestcaseIds.get(idx), testRun.failingTestcaseOffsets.get(idx)));
                    }
                    TestStatusEntity testStatusEntity = new TestStatusEntity(testRun.testName, testRun.startTimestamp, (int) testRun.passCount, failingTestCases.size(), failingTestCases);
                    datastore.put(testStatusEntity.toEntity());
                    testRun.coverageList.forEach(testRunCoverage -> {
                        CoverageEntity coverageEntity = new CoverageEntity(testRunKey, testRunCoverage.group, testRunCoverage.coveredLineCount, testRunCoverage.totalLineCount, testRunCoverage.filePath, testRunCoverage.projectName, testRunCoverage.projectVersion, testRunCoverage.lineCoverage);
                        datastore.put(coverageEntity.toEntity());
                    });
                    testRun.profilingList.forEach(testRunProfile -> {
                        ProfilingPointRunEntity profilingEntity = new ProfilingPointRunEntity(testRunKey, testRunProfile.name, testRunProfile.type, testRunProfile.regressionMode, testRunProfile.labels, testRunProfile.values, testRunProfile.xLabel, testRunProfile.yLabel, testRunProfile.options);
                        datastore.put(profilingEntity.toEntity());
                    });
                    TestCaseRunEntity testCaseEntity = new TestCaseRunEntity();
                    testRun.testCaseRunList.forEach(testCaseRun -> {
                        for (int idx = 0; idx < testCaseRun.testCaseNames.size(); idx++) {
                            testCaseEntity.addTestCase(testCaseRun.testCaseNames.get(idx), testCaseRun.results.get(idx));
                        }
                    });
                    datastore.put(testCaseEntity.toEntity());
                    testRun.deviceInfoList.forEach(deviceInfo -> {
                        DeviceInfoEntity deviceInfoEntity = new DeviceInfoEntity(testRunKey, deviceInfo.branch, deviceInfo.product, deviceInfo.buildFlavor, deviceInfo.buildId, deviceInfo.abiBitness, deviceInfo.abiName);
                        ;
                        datastore.put(deviceInfoEntity.toEntity());
                    });
                    testRun.buildTargetList.forEach(buildTarget -> {
                        BuildTargetEntity buildTargetEntity = new BuildTargetEntity(buildTarget.targetName);
                        datastore.put(buildTargetEntity.toEntity());
                    });
                    testRun.branchList.forEach(branch -> {
                        BranchEntity branchEntity = new BranchEntity(branch.branchName);
                        datastore.put(branchEntity.toEntity());
                    });
                    TestRunEntity testRunEntity = new TestRunEntity(testEntity.key, TestRunType.fromNumber(testRun.type), testRun.startTimestamp, testRun.endTimestamp, testRun.testBuildId, testRun.hostName, testRun.passCount, testRun.failCount, testRun.testCaseIds, testRun.links, testRun.coveredLineCount, testRun.totalLineCount);
                    datastore.put(testRunEntity.toEntity());
                    Entity newTestEntity = testEntity.toEntity();
                    Transaction txn = datastore.beginTransaction();
                    try {
                        // Check if test already exists in the datastore
                        try {
                            Entity oldTest = datastore.get(testEntity.key);
                            TestEntity oldTestEntity = TestEntity.fromEntity(oldTest);
                            if (oldTestEntity == null || !oldTestEntity.equals(testEntity)) {
                                datastore.put(newTestEntity);
                            }
                        } catch (EntityNotFoundException e) {
                            datastore.put(newTestEntity);
                        }
                        txn.commit();
                    } catch (ConcurrentModificationException | DatastoreFailureException | DatastoreTimeoutException e) {
                        logger.log(Level.WARNING, "Retrying test run insert: " + newTestEntity.getKey());
                    } finally {
                        if (txn.isActive()) {
                            logger.log(Level.WARNING, "Transaction rollback forced for run: " + testRunEntity.key);
                            txn.rollback();
                        }
                    }
                });
            });
        } else {
            TestPlanReportDataObject tprdObj = gson.fromJson(postJsonReader, TestPlanReportDataObject.class);
        }
    } else {
        logger.log(Level.WARNING, "URL path parameter is omitted!");
    }
    response.setStatus(HttpServletResponse.SC_OK);
}
#end_block

#method_before
@Before
public void setUp() {
    mDevice = UiDevice.getInstance(getInstrumentation());
    wm = WindowManagerGlobal.getWindowManagerService();
}
#method_after
@Before
public void setUp() {
    mDevice = UiDevice.getInstance(getInstrumentation());
}
#end_block

#method_before
@Test
public void testNavigationBarDivider() throws Exception {
    // No navigation bar, just return
    if (!wm.hasNavigationBar()) {
        return;
    }
    // Wait until the activity is fully visible
    mDevice.waitForIdle();
    final int dividerColor = getInstrumentation().getContext().getColor(R.color.navigationBarDividerColor);
    final Bitmap bitmap = takeNavigationBarScreenshot(mActivityRule.getActivity());
    int[] pixels = new int[bitmap.getHeight() * bitmap.getWidth()];
    bitmap.getPixels(pixels, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());
    for (int col = 0; col < bitmap.getWidth(); col++) {
        if (dividerColor != pixels[col]) {
            dumpBitmap(bitmap);
            fail("Invalid color exptected=" + dividerColor + " actual=" + pixels[col]);
        }
    }
}
#method_after
@Test
public void testNavigationBarDivider() throws Exception {
    if (!hasVirtualNavigationBar()) {
        // No virtual navigation bar, so no effect.
        return;
    }
    // Wait until the activity is fully visible
    mDevice.waitForIdle();
    final int dividerColor = getInstrumentation().getContext().getColor(R.color.navigationBarDividerColor);
    final Bitmap bitmap = takeNavigationBarScreenshot(mActivityRule.getActivity());
    int[] pixels = new int[bitmap.getHeight() * bitmap.getWidth()];
    bitmap.getPixels(pixels, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());
    for (int col = 0; col < bitmap.getWidth(); col++) {
        if (dividerColor != pixels[col]) {
            dumpBitmap(bitmap);
            fail("Invalid color exptected=" + dividerColor + " actual=" + pixels[col]);
        }
    }
}
#end_block

#method_before
private android.hardware.radio.V1_1.RadioAccessSpecifier convertRadioAccessSpecifierToRadioHAL(RadioAccessSpecifier ras) {
    android.hardware.radio.V1_1.RadioAccessSpecifier rasInHalFormat = new android.hardware.radio.V1_1.RadioAccessSpecifier();
    rasInHalFormat.radioAccessNetwork = ras.getRadioAccessNetwork();
    List<Integer> bands = null;
    switch(ras.getRadioAccessNetwork()) {
        case RadioAccessNetwork.GERAN:
            bands = rasInHalFormat.geranBands;
            break;
        case RadioAccessNetwork.UTRAN:
            bands = rasInHalFormat.utranBands;
            break;
        case RadioAccessNetwork.EUTRAN:
            bands = rasInHalFormat.eutranBands;
            break;
        default:
            Log.wtf(RILJ_LOG_TAG, "radioAccessNetwork " + ras.getRadioAccessNetwork() + " not supported!");
            return null;
    }
    if (ras.getBands() != null) {
        for (int band : ras.getBands()) {
            bands.add(band);
        }
    }
    if (ras.getChannels() != null) {
        for (int channel : ras.getChannels()) {
            rasInHalFormat.channels.add(channel);
        }
    }
    return rasInHalFormat;
}
#method_after
private android.hardware.radio.V1_1.RadioAccessSpecifier convertRadioAccessSpecifierToRadioHAL(RadioAccessSpecifier ras) {
    android.hardware.radio.V1_1.RadioAccessSpecifier rasInHalFormat = new android.hardware.radio.V1_1.RadioAccessSpecifier();
    rasInHalFormat.radioAccessNetwork = ras.getRadioAccessNetwork();
    List<Integer> bands = null;
    switch(ras.getRadioAccessNetwork()) {
        case AccessNetworkType.GERAN:
            bands = rasInHalFormat.geranBands;
            break;
        case AccessNetworkType.UTRAN:
            bands = rasInHalFormat.utranBands;
            break;
        case AccessNetworkType.EUTRAN:
            bands = rasInHalFormat.eutranBands;
            break;
        default:
            Log.wtf(RILJ_LOG_TAG, "radioAccessNetwork " + ras.getRadioAccessNetwork() + " not supported!");
            return null;
    }
    if (ras.getBands() != null) {
        for (int band : ras.getBands()) {
            bands.add(band);
        }
    }
    if (ras.getChannels() != null) {
        for (int channel : ras.getChannels()) {
            rasInHalFormat.channels.add(channel);
        }
    }
    return rasInHalFormat;
}
#end_block

#method_before
@Test
@SmallTest
public void testParcel() {
    int ranGsm = RadioAccessNetwork.GERAN;
    int[] gsmBands = { GeranBand.BAND_T380, GeranBand.BAND_T410 };
    int[] gsmChannels = { 1, 2, 3, 4 };
    RadioAccessSpecifier gsm = new RadioAccessSpecifier(ranGsm, gsmBands, gsmChannels);
    int ranLte = RadioAccessNetwork.EUTRAN;
    int[] lteBands = { EutranBand.BAND_10, EutranBand.BAND_11 };
    int[] lteChannels = { 5, 6, 7, 8 };
    RadioAccessSpecifier lte = new RadioAccessSpecifier(ranLte, lteBands, lteChannels);
    RadioAccessSpecifier[] ras = { gsm, lte };
    int searchPeriodicity = 70;
    int maxSearchTime = 200;
    boolean incrementalResults = true;
    int incrementalResultsPeriodicity = 7;
    ArrayList<String> mccmncs = new ArrayList<String>();
    mccmncs.add("310480");
    mccmncs.add("21002");
    NetworkScanRequest nsq = new NetworkScanRequest(NetworkScanRequest.SCAN_TYPE_ONE_SHOT, ras, searchPeriodicity, maxSearchTime, incrementalResults, incrementalResultsPeriodicity, mccmncs);
    Parcel p = Parcel.obtain();
    nsq.writeToParcel(p, 0);
    p.setDataPosition(0);
    NetworkScanRequest newNsq = NetworkScanRequest.CREATOR.createFromParcel(p);
    assertEquals(nsq, newNsq);
}
#method_after
@Test
@SmallTest
public void testParcel() {
    int ranGsm = AccessNetworkType.GERAN;
    int[] gsmBands = { GeranBand.BAND_T380, GeranBand.BAND_T410 };
    int[] gsmChannels = { 1, 2, 3, 4 };
    RadioAccessSpecifier gsm = new RadioAccessSpecifier(ranGsm, gsmBands, gsmChannels);
    int ranLte = AccessNetworkType.EUTRAN;
    int[] lteBands = { EutranBand.BAND_10, EutranBand.BAND_11 };
    int[] lteChannels = { 5, 6, 7, 8 };
    RadioAccessSpecifier lte = new RadioAccessSpecifier(ranLte, lteBands, lteChannels);
    RadioAccessSpecifier[] ras = { gsm, lte };
    int searchPeriodicity = 70;
    int maxSearchTime = 200;
    boolean incrementalResults = true;
    int incrementalResultsPeriodicity = 7;
    ArrayList<String> mccmncs = new ArrayList<String>();
    mccmncs.add("310480");
    mccmncs.add("21002");
    NetworkScanRequest nsq = new NetworkScanRequest(NetworkScanRequest.SCAN_TYPE_ONE_SHOT, ras, searchPeriodicity, maxSearchTime, incrementalResults, incrementalResultsPeriodicity, mccmncs);
    Parcel p = Parcel.obtain();
    nsq.writeToParcel(p, 0);
    p.setDataPosition(0);
    NetworkScanRequest newNsq = NetworkScanRequest.CREATOR.createFromParcel(p);
    assertEquals(nsq, newNsq);
}
#end_block

#method_before
@Test
@SmallTest
public void testParcel() {
    int ranGsm = RadioAccessNetwork.GERAN;
    int[] gsmBands = { GeranBand.BAND_T380, GeranBand.BAND_T410 };
    int[] gsmChannels = { 1, 2, 3, 4 };
    RadioAccessSpecifier ras = new RadioAccessSpecifier(ranGsm, gsmBands, gsmChannels);
    Parcel p = Parcel.obtain();
    ras.writeToParcel(p, 0);
    p.setDataPosition(0);
    RadioAccessSpecifier newRas = RadioAccessSpecifier.CREATOR.createFromParcel(p);
    assertEquals(ras, newRas);
}
#method_after
@Test
@SmallTest
public void testParcel() {
    int ranGsm = AccessNetworkType.GERAN;
    int[] gsmBands = { GeranBand.BAND_T380, GeranBand.BAND_T410 };
    int[] gsmChannels = { 1, 2, 3, 4 };
    RadioAccessSpecifier ras = new RadioAccessSpecifier(ranGsm, gsmBands, gsmChannels);
    Parcel p = Parcel.obtain();
    ras.writeToParcel(p, 0);
    p.setDataPosition(0);
    RadioAccessSpecifier newRas = RadioAccessSpecifier.CREATOR.createFromParcel(p);
    assertEquals(ras, newRas);
}
#end_block

#method_before
@Test
public void everUtc_true() throws Exception {
    CountryZonesFile.Country validCountryGb = createValidCountryGb();
    String tzLookupXml = generateTzLookupXml(validCountryGb, createValidZoneTabEntriesGb());
    // Check gb's entry contains everutc="true".
    assertContains(tzLookupXml, "everutc=\"y\"");
}
#method_after
@Test
public void everUtc_true() throws Exception {
    CountryZonesFile.Country validCountryGb = createValidCountryGb();
    String tzLookupXml = generateTzLookupXml(validCountryGb, createValidZoneTabEntriesGb());
    // Check gb's entry contains everutc="y".
    assertContains(tzLookupXml, "everutc=\"y\"");
}
#end_block

#method_before
@Test
public void everUtc_false() throws Exception {
    CountryZonesFile.Country validCountryFr = createValidCountryFr();
    String tzLookupXml = generateTzLookupXml(validCountryFr, createValidZoneTabEntriesFr());
    // Check fr's entry contains everutc="false".
    assertContains(tzLookupXml, "everutc=\"n\"");
}
#method_after
@Test
public void everUtc_false() throws Exception {
    CountryZonesFile.Country validCountryFr = createValidCountryFr();
    String tzLookupXml = generateTzLookupXml(validCountryFr, createValidZoneTabEntriesFr());
    // Check fr's entry contains everutc="n".
    assertContains(tzLookupXml, "everutc=\"n\"");
}
#end_block

#method_before
private static long getSampleOffsetTimeMillisForData(String inputIanaVersion) {
    // Uses <year>/07/02 12:00:00 UTC, where year is taken from the IANA version + 1.
    // This is fairly arbitrary, but reflects the fact that we want a point in the future
    // WRT to the data, and once a year has been picked then half-way through seems about right.
    Calendar calendar = getYearStartForData(inputIanaVersion);
    calendar.set(calendar.get(Calendar.YEAR), Calendar.JULY, 2, 12, 0, 0);
    return calendar.getTimeInMillis();
}
#method_after
private static long getSampleOffsetTimeMillisForData(String inputIanaVersion) {
    // Uses <year>/07/02 12:00:00 UTC, where year is taken from the IANA version + 1.
    // This is fairly arbitrary, but reflects the fact that we want a point in the future
    // WRT to the data, and once a year has been picked then half-way through seems about right.
    Calendar calendar = getYearStartForData(inputIanaVersion);
    calendar.set(calendar.get(Calendar.YEAR) + 1, Calendar.JULY, 2, 12, 0, 0);
    return calendar.getTimeInMillis();
}
#end_block

#method_before
private static Calendar getYearStartForData(String inputIanaVersion) {
    String yearString = inputIanaVersion.substring(0, inputIanaVersion.length() - 1);
    int year = Integer.parseInt(yearString) + 1;
    Calendar calendar = new GregorianCalendar(TimeZone.GMT_ZONE);
    calendar.clear();
    calendar.set(year, Calendar.JANUARY, 1, 0, 0, 0);
    return calendar;
}
#method_after
private static Calendar getYearStartForData(String inputIanaVersion) {
    String yearString = inputIanaVersion.substring(0, inputIanaVersion.length() - 1);
    int year = Integer.parseInt(yearString);
    Calendar calendar = new GregorianCalendar(TimeZone.GMT_ZONE);
    calendar.clear();
    calendar.set(year, Calendar.JANUARY, 1, 0, 0, 0);
    return calendar;
}
#end_block

#method_before
public boolean connect(BluetoothDevice device) {
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
#method_after
@SystemApi
@RequiresPermission(android.Manifest.permission.BLUETOOTH_ADMIN)
public boolean connect(BluetoothDevice device) {
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
#end_block

#method_before
public boolean disconnect(BluetoothDevice device) {
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
#method_after
@SystemApi
@RequiresPermission(android.Manifest.permission.BLUETOOTH_ADMIN)
public boolean disconnect(BluetoothDevice device) {
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
#end_block

#method_before
public boolean setPriority(BluetoothDevice device, int priority) {
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
#method_after
@SystemApi
@RequiresPermission(android.Manifest.permission.BLUETOOTH_ADMIN)
public boolean setPriority(BluetoothDevice device, int priority) {
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
#end_block

#method_before
@Override
public void onHandoverRequested(Call call, PhoneAccountHandle handoverTo, int videoState, Bundle extras) {
    requestHandover(call, handoverTo, videoState, extras);
}
#method_after
@Override
public void onHandoverRequested(Call call, PhoneAccountHandle handoverTo, int videoState, Bundle extras, boolean isLegacy) {
    if (isLegacy) {
        requestHandoverViaEvents(call, handoverTo, videoState, extras);
    } else {
        requestHandover(call, handoverTo, videoState, extras);
    }
}
#end_block

#method_before
boolean hasOnlyDisconnectedCalls() {
    if (mCalls.size() == 0) {
        return false;
    }
    for (Call call : mCalls) {
        if (!call.isDisconnected()) {
            return false;
        }
    }
    return true;
}
#method_after
@VisibleForTesting
public boolean hasOnlyDisconnectedCalls() {
    if (mCalls.size() == 0) {
        return false;
    }
    for (Call call : mCalls) {
        if (!call.isDisconnected()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void disconnectSelfManagedCalls() {
    // Disconnect all self-managed calls to make priority for emergency call.
    // Use Call.disconnect() to command the ConnectionService to disconnect the calls.
    // CallsManager.markCallAsDisconnected doesn't actually tell the ConnectionService to
    // disconnect.
    mCalls.stream().filter(c -> c.isSelfManaged()).forEach(c -> c.disconnect());
}
#method_after
private void disconnectSelfManagedCalls() {
    // Disconnect all self-managed calls to make priority for emergency call.
    // Use Call.disconnect() to command the ConnectionService to disconnect the calls.
    // CallsManager.markCallAsDisconnected doesn't actually tell the ConnectionService to
    // disconnect.
    mCalls.stream().filter(c -> c.isSelfManaged()).forEach(c -> c.disconnect());
    // When disconnecting all self-managed calls, switch audio routing back to the baseline
    // route.  This ensures if, for example, the self-managed ConnectionService was routed to
    // speakerphone that we'll switch back to earpiece for the managed call which necessitated
    // disconnecting the self-managed calls.
    mCallAudioManager.switchBaseline();
}
#end_block

#method_before
private void requestHandover(Call handoverFromCall, PhoneAccountHandle handoverToHandle, int videoState, Bundle initiatingExtras) {
    boolean isHandoverFromSupported = isHandoverFromPhoneAccountSupported(handoverFromCall.getTargetPhoneAccount());
    boolean isHandoverToSupported = isHandoverToPhoneAccountSupported(handoverToHandle);
    if (!isHandoverFromSupported || !isHandoverToSupported || hasEmergencyCall()) {
        handoverFromCall.sendCallEvent(android.telecom.Call.EVENT_HANDOVER_FAILED, null);
        return;
    }
    Log.addEvent(handoverFromCall, LogUtils.Events.HANDOVER_REQUEST, handoverToHandle);
    Bundle extras = new Bundle();
    extras.putBoolean(TelecomManager.EXTRA_IS_HANDOVER, true);
    extras.putParcelable(TelecomManager.EXTRA_HANDOVER_FROM_PHONE_ACCOUNT, handoverFromCall.getTargetPhoneAccount());
    extras.putInt(TelecomManager.EXTRA_START_CALL_WITH_VIDEO_STATE, videoState);
    if (initiatingExtras != null) {
        extras.putAll(initiatingExtras);
    }
    extras.putParcelable(TelecomManager.EXTRA_CALL_AUDIO_STATE, mCallAudioManager.getCallAudioState());
    Call handoverToCall = startOutgoingCall(handoverFromCall.getHandle(), handoverToHandle, extras, getCurrentUserHandle(), null);
    Log.addEvent(handoverFromCall, LogUtils.Events.START_HANDOVER, "handOverFrom=%s, handOverTo=%s", handoverFromCall.getId(), handoverToCall.getId());
    handoverFromCall.setHandoverDestinationCall(handoverToCall);
    handoverFromCall.setHandoverState(HandoverState.HANDOVER_FROM_STARTED);
    handoverToCall.setHandoverState(HandoverState.HANDOVER_TO_STARTED);
    handoverToCall.setHandoverSourceCall(handoverFromCall);
    handoverToCall.setNewOutgoingCallIntentBroadcastIsDone();
    placeOutgoingCall(handoverToCall, handoverToCall.getHandle(), null, /* gatewayInfo */
    false, /* startwithSpeaker */
    videoState);
}
#method_after
private void requestHandover(Call handoverFromCall, PhoneAccountHandle handoverToHandle, int videoState, Bundle extras) {
    // Send an error back if there are any ongoing emergency calls.
    if (hasEmergencyCall()) {
        handoverFromCall.onHandoverFailed(android.telecom.Call.Callback.HANDOVER_FAILURE_ONGOING_EMERG_CALL);
        return;
    }
    // If source and destination phone accounts don't support handover, send an error back.
    boolean isHandoverFromSupported = isHandoverFromPhoneAccountSupported(handoverFromCall.getTargetPhoneAccount());
    boolean isHandoverToSupported = isHandoverToPhoneAccountSupported(handoverToHandle);
    if (!isHandoverFromSupported || !isHandoverToSupported) {
        handoverFromCall.onHandoverFailed(android.telecom.Call.Callback.HANDOVER_FAILURE_DEST_NOT_SUPPORTED);
        return;
    }
    Log.addEvent(handoverFromCall, LogUtils.Events.HANDOVER_REQUEST, handoverToHandle);
    // Create a new instance of Call
    PhoneAccount account = mPhoneAccountRegistrar.getPhoneAccount(handoverToHandle, getCurrentUserHandle());
    boolean isSelfManaged = account != null && account.isSelfManaged();
    Call call = new Call(getNextCallId(), mContext, this, mLock, mConnectionServiceRepository, mContactsAsyncHelper, mCallerInfoAsyncQueryFactory, mPhoneNumberUtilsAdapter, handoverFromCall.getHandle(), null, null, null, Call.CALL_DIRECTION_OUTGOING, false, false, mClockProxy);
    call.initAnalytics();
    // Set self-managed and voipAudioMode if destination is self-managed CS
    call.setIsSelfManaged(isSelfManaged);
    if (isSelfManaged) {
        call.setIsVoipAudioMode(true);
    }
    call.setInitiatingUser(getCurrentUserHandle());
    // supported.
    if (VideoProfile.isVideo(videoState) && account != null && !account.hasCapabilities(PhoneAccount.CAPABILITY_VIDEO_CALLING)) {
        call.setVideoState(VideoProfile.STATE_AUDIO_ONLY);
    } else {
        call.setVideoState(videoState);
    }
    // Set target phone account to destAcct.
    call.setTargetPhoneAccount(handoverToHandle);
    if (account != null && account.getExtras() != null && account.getExtras().getBoolean(PhoneAccount.EXTRA_ALWAYS_USE_VOIP_AUDIO_MODE)) {
        Log.d(this, "requestHandover: defaulting to voip mode for call %s", call.getId());
        call.setIsVoipAudioMode(true);
    }
    // Set call state to connecting
    call.setState(CallState.CONNECTING, handoverToHandle == null ? "no-handle" : handoverToHandle.toString());
    setIntentExtrasAndStartTime(call, extras);
    // Add call to call tracker
    if (!mCalls.contains(call)) {
        addCall(call);
    }
    Log.addEvent(handoverFromCall, LogUtils.Events.START_HANDOVER, "handOverFrom=%s, handOverTo=%s", handoverFromCall.getId(), call.getId());
    handoverFromCall.setHandoverDestinationCall(call);
    handoverFromCall.setHandoverState(HandoverState.HANDOVER_FROM_STARTED);
    call.setHandoverState(HandoverState.HANDOVER_TO_STARTED);
    call.setHandoverSourceCall(handoverFromCall);
    call.setNewOutgoingCallIntentBroadcastIsDone();
    // Auto-enable speakerphone if the originating intent specified to do so, if the call
    // is a video call, of if using speaker when docked
    final boolean useSpeakerWhenDocked = mContext.getResources().getBoolean(R.bool.use_speaker_when_docked);
    final boolean useSpeakerForDock = isSpeakerphoneEnabledForDock();
    final boolean useSpeakerForVideoCall = isSpeakerphoneAutoEnabledForVideoCalls(videoState);
    call.setStartWithSpeakerphoneOn(false || useSpeakerForVideoCall || (useSpeakerWhenDocked && useSpeakerForDock));
    call.setVideoState(videoState);
    final boolean isOutgoingCallPermitted = isOutgoingCallPermitted(call, call.getTargetPhoneAccount());
    // If the account has been set, proceed to place the outgoing call.
    if (call.isSelfManaged() && !isOutgoingCallPermitted) {
        notifyCreateConnectionFailed(call.getTargetPhoneAccount(), call);
    } else if (!call.isSelfManaged() && hasSelfManagedCalls() && !call.isEmergencyCall()) {
        markCallDisconnectedDueToSelfManagedCall(call);
    } else {
        if (call.isEmergencyCall()) {
            // Disconnect all self-managed calls to make priority for emergency call.
            disconnectSelfManagedCalls();
        }
        call.startCreateConnection(mPhoneAccountRegistrar);
    }
}
#end_block

#method_before
public void acceptHandover(Uri srcAddr, int videoState, PhoneAccountHandle destAcct) {
// TODO:
}
#method_after
public void acceptHandover(Uri srcAddr, int videoState, PhoneAccountHandle destAcct) {
    final String handleScheme = srcAddr.getSchemeSpecificPart();
    Call fromCall = mCalls.stream().filter((c) -> mPhoneNumberUtilsAdapter.isSamePhoneNumber(c.getHandle().getSchemeSpecificPart(), handleScheme)).findFirst().orElse(null);
    Call call = new Call(getNextCallId(), mContext, this, mLock, mConnectionServiceRepository, mContactsAsyncHelper, mCallerInfoAsyncQueryFactory, mPhoneNumberUtilsAdapter, srcAddr, null, /* gatewayInfo */
    null, /* connectionManagerPhoneAccount */
    destAcct, Call.CALL_DIRECTION_INCOMING, /* callDirection */
    false, /* forceAttachToExistingConnection */
    false, /* isConference */
    mClockProxy);
    if (fromCall == null || isHandoverInProgress() || !isHandoverFromPhoneAccountSupported(fromCall.getTargetPhoneAccount()) || !isHandoverToPhoneAccountSupported(destAcct) || hasEmergencyCall()) {
        Log.w(this, "acceptHandover: Handover not supported");
        notifyHandoverFailed(call, android.telecom.Call.Callback.HANDOVER_FAILURE_DEST_NOT_SUPPORTED);
        return;
    }
    PhoneAccount phoneAccount = mPhoneAccountRegistrar.getPhoneAccountUnchecked(destAcct);
    if (phoneAccount == null) {
        Log.w(this, "acceptHandover: Handover not supported. phoneAccount = null");
        notifyHandoverFailed(call, android.telecom.Call.Callback.HANDOVER_FAILURE_DEST_NOT_SUPPORTED);
        return;
    }
    call.setIsSelfManaged(phoneAccount.isSelfManaged());
    if (call.isSelfManaged() || (phoneAccount.getExtras() != null && phoneAccount.getExtras().getBoolean(PhoneAccount.EXTRA_ALWAYS_USE_VOIP_AUDIO_MODE))) {
        call.setIsVoipAudioMode(true);
    }
    if (!phoneAccount.hasCapabilities(PhoneAccount.CAPABILITY_VIDEO_CALLING)) {
        call.setVideoState(VideoProfile.STATE_AUDIO_ONLY);
    } else {
        call.setVideoState(videoState);
    }
    call.initAnalytics();
    call.addListener(this);
    fromCall.setHandoverDestinationCall(call);
    call.setHandoverSourceCall(fromCall);
    call.setHandoverState(HandoverState.HANDOVER_TO_STARTED);
    fromCall.setHandoverState(HandoverState.HANDOVER_FROM_STARTED);
    if (isSpeakerEnabledForVideoCalls() && VideoProfile.isVideo(videoState)) {
        // Ensure when the call goes active that it will go to speakerphone if the
        // handover to call is a video call.
        call.setStartWithSpeakerphoneOn(true);
    }
    call.startCreateConnection(mPhoneAccountRegistrar);
}
#end_block

#method_before
public void handleMessage(Message msg) {
    AsyncResult ar;
    if (mDestroyed.get()) {
        Rlog.e(LOG_TAG, "Received message " + msg + "[" + msg.what + "] while being destroyed. Ignoring.");
        return;
    }
    loge("IsimUiccRecords: handleMessage " + msg + "[" + msg.what + "] ");
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_ISIM_REFRESH:
                broadcastRefresh();
                break;
            case EVENT_ISIM_AUTHENTICATE_DONE:
                ar = (AsyncResult) msg.obj;
                log("EVENT_ISIM_AUTHENTICATE_DONE");
                if (ar.exception != null) {
                    log("Exception ISIM AKA: " + ar.exception);
                } else {
                    try {
                        auth_rsp = (String) ar.result;
                        log("ISIM AKA: auth_rsp = " + auth_rsp);
                    } catch (Exception e) {
                        log("Failed to parse ISIM AKA contents: " + e);
                    }
                }
                synchronized (mLock) {
                    mLock.notifyAll();
                }
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        Rlog.w(LOG_TAG, "Exception parsing SIM record", exc);
    }
}
#method_after
public void handleMessage(Message msg) {
    AsyncResult ar;
    if (mDestroyed.get()) {
        Rlog.e(LOG_TAG, "Received message " + msg + "[" + msg.what + "] while being destroyed. Ignoring.");
        return;
    }
    loge("IsimUiccRecords: handleMessage " + msg + "[" + msg.what + "] ");
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_REFRESH:
                broadcastRefresh();
                super.handleMessage(msg);
                break;
            case EVENT_ISIM_AUTHENTICATE_DONE:
                ar = (AsyncResult) msg.obj;
                log("EVENT_ISIM_AUTHENTICATE_DONE");
                if (ar.exception != null) {
                    log("Exception ISIM AKA: " + ar.exception);
                } else {
                    try {
                        auth_rsp = (String) ar.result;
                        log("ISIM AKA: auth_rsp = " + auth_rsp);
                    } catch (Exception e) {
                        log("Failed to parse ISIM AKA contents: " + e);
                    }
                }
                synchronized (mLock) {
                    mLock.notifyAll();
                }
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        Rlog.w(LOG_TAG, "Exception parsing SIM record", exc);
    }
}
#end_block

#method_before
protected void resetRecords() {
    // recordsRequested is set to false indicating that the SIM
    // read requests made so far are not valid. This is set to
    // true only when fresh set of read requests are made.
    mIsimImpi = null;
    mIsimDomain = null;
    mIsimImpu = null;
    mIsimIst = null;
    mIsimPcscf = null;
    auth_rsp = null;
    mRecordsRequested = false;
}
#method_after
protected void resetRecords() {
    // recordsRequested is set to false indicating that the SIM
    // read requests made so far are not valid. This is set to
    // true only when fresh set of read requests are made.
    mIsimImpi = null;
    mIsimDomain = null;
    mIsimImpu = null;
    mIsimIst = null;
    mIsimPcscf = null;
    auth_rsp = null;
    mRecordsRequested = false;
    mLockedRecordsRequested = false;
}
#end_block

#method_before
@Override
protected void onRecordLoaded() {
    // One record loaded successfully or failed, In either case
    // we need to update the recordsToLoad count
    mRecordsToLoad -= 1;
    if (DBG)
        log("onRecordLoaded " + mRecordsToLoad + " requested: " + mRecordsRequested);
    if (mRecordsToLoad == 0 && mRecordsRequested == true) {
        onAllRecordsLoaded();
    } else if (mRecordsToLoad < 0) {
        loge("recordsToLoad <0, programmer error suspected");
        mRecordsToLoad = 0;
    }
}
#method_after
@Override
protected void onRecordLoaded() {
    // One record loaded successfully or failed, In either case
    // we need to update the recordsToLoad count
    mRecordsToLoad -= 1;
    if (DBG)
        log("onRecordLoaded " + mRecordsToLoad + " requested: " + mRecordsRequested);
    if (getRecordsLoaded()) {
        onAllRecordsLoaded();
    } else if (getLockedRecordsLoaded()) {
        onLockedAllRecordsLoaded();
    } else if (mRecordsToLoad < 0) {
        loge("recordsToLoad <0, programmer error suspected");
        mRecordsToLoad = 0;
    }
}
#end_block

#method_before
@Override
public int getDisplayRule(String plmn) {
    // Not applicable to Isim
    return 0;
}
#method_after
@Override
public int getDisplayRule(ServiceState serviceState) {
    // Not applicable to Isim
    return 0;
}
#end_block

#method_before
public UiccCard getUiccCard(int phoneId) {
    synchronized (mLock) {
        if (isValidCardIndex(phoneId)) {
            return mUiccCards[phoneId];
        }
        return null;
    }
}
#method_after
public UiccCard getUiccCard(int phoneId) {
    synchronized (mLock) {
        return getUiccCardForPhone(phoneId);
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    synchronized (mLock) {
        Integer index = getCiIndex(msg);
        if (index < 0 || index >= mCis.length) {
            Rlog.e(LOG_TAG, "Invalid index : " + index + " received with event " + msg.what);
            return;
        }
        AsyncResult ar = (AsyncResult) msg.obj;
        switch(msg.what) {
            case EVENT_ICC_STATUS_CHANGED:
                if (DBG)
                    log("Received EVENT_ICC_STATUS_CHANGED, calling getIccCardStatus");
                mCis[index].getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE, index));
                break;
            case EVENT_GET_ICC_STATUS_DONE:
                if (DBG)
                    log("Received EVENT_GET_ICC_STATUS_DONE");
                onGetIccCardStatusDone(ar, index);
                break;
            case EVENT_RADIO_UNAVAILABLE:
                if (DBG)
                    log("EVENT_RADIO_UNAVAILABLE, dispose card");
                if (mUiccCards[index] != null) {
                    mUiccCards[index].dispose();
                }
                mUiccCards[index] = null;
                mIccChangedRegistrants.notifyRegistrants(new AsyncResult(null, index, null));
                break;
            case EVENT_SIM_REFRESH:
                if (DBG)
                    log("Received EVENT_SIM_REFRESH");
                onSimRefresh(ar, index);
                break;
            default:
                Rlog.e(LOG_TAG, " Unknown Event " + msg.what);
                break;
        }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    synchronized (mLock) {
        Integer phoneId = getCiIndex(msg);
        if (phoneId < 0 || phoneId >= mCis.length) {
            Rlog.e(LOG_TAG, "Invalid phoneId : " + phoneId + " received with event " + msg.what);
            return;
        }
        AsyncResult ar = (AsyncResult) msg.obj;
        switch(msg.what) {
            case EVENT_ICC_STATUS_CHANGED:
            case EVENT_ICC_OR_SLOT_STATUS_CHANGED:
                if (DBG)
                    log("Received EVENT_ICC_STATUS_CHANGED, calling getIccCardStatus");
                mCis[phoneId].getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE, phoneId));
                break;
            case EVENT_GET_ICC_STATUS_DONE:
                if (DBG)
                    log("Received EVENT_GET_ICC_STATUS_DONE");
                onGetIccCardStatusDone(ar, phoneId);
                break;
            case EVENT_RADIO_UNAVAILABLE:
                if (DBG)
                    log("EVENT_RADIO_UNAVAILABLE, dispose card");
                mUiccSlots[getSlotIdFromPhoneId(phoneId)].onRadioStateUnavailable();
                mIccChangedRegistrants.notifyRegistrants(new AsyncResult(null, phoneId, null));
                break;
            case EVENT_SIM_REFRESH:
                if (DBG)
                    log("Received EVENT_SIM_REFRESH");
                onSimRefresh(ar, phoneId);
                break;
            default:
                Rlog.e(LOG_TAG, " Unknown Event " + msg.what);
                break;
        }
    }
}
#end_block

#method_before
public UiccCardApplication getUiccCardApplication(int phoneId, int family) {
    synchronized (mLock) {
        if (isValidCardIndex(phoneId)) {
            UiccCard c = mUiccCards[phoneId];
            if (c != null) {
                return mUiccCards[phoneId].getApplication(family);
            }
        }
        return null;
    }
}
#method_after
public UiccCardApplication getUiccCardApplication(int phoneId, int family) {
    synchronized (mLock) {
        UiccCard uiccCard = getUiccCardForPhone(phoneId);
        if (uiccCard != null) {
            return uiccCard.getApplication(family);
        }
        return null;
    }
}
#end_block

#method_before
private synchronized void onGetIccCardStatusDone(AsyncResult ar, Integer index) {
    if (ar.exception != null) {
        Rlog.e(LOG_TAG, "Error getting ICC status. " + "RIL_REQUEST_GET_ICC_STATUS should " + "never return an error", ar.exception);
        return;
    }
    if (!isValidCardIndex(index)) {
        Rlog.e(LOG_TAG, "onGetIccCardStatusDone: invalid index : " + index);
        return;
    }
    IccCardStatus status = (IccCardStatus) ar.result;
    if (mUiccCards[index] == null) {
        // Create new card
        mUiccCards[index] = new UiccCard(mContext, mCis[index], status, index);
    } else {
        // Update already existing card
        mUiccCards[index].update(mContext, mCis[index], status);
    }
    if (DBG)
        log("Notifying IccChangedRegistrants");
    mIccChangedRegistrants.notifyRegistrants(new AsyncResult(null, index, null));
}
#method_after
private synchronized void onGetIccCardStatusDone(AsyncResult ar, Integer index) {
    if (ar.exception != null) {
        Rlog.e(LOG_TAG, "Error getting ICC status. " + "RIL_REQUEST_GET_ICC_STATUS should " + "never return an error", ar.exception);
        return;
    }
    if (!isValidCardIndex(index)) {
        Rlog.e(LOG_TAG, "onGetIccCardStatusDone: invalid index : " + index);
        return;
    }
    IccCardStatus status = (IccCardStatus) ar.result;
    mUiccSlots[getSlotIdFromPhoneId(index)].update(mContext, mCis[index], status, index);
    if (DBG)
        log("Notifying IccChangedRegistrants");
    mIccChangedRegistrants.notifyRegistrants(new AsyncResult(null, index, null));
}
#end_block

#method_before
private void onSimRefresh(AsyncResult ar, Integer index) {
    if (ar.exception != null) {
        Rlog.e(LOG_TAG, "Sim REFRESH with exception: " + ar.exception);
        return;
    }
    if (!isValidCardIndex(index)) {
        Rlog.e(LOG_TAG, "onSimRefresh: invalid index : " + index);
        return;
    }
    IccRefreshResponse resp = (IccRefreshResponse) ar.result;
    Rlog.d(LOG_TAG, "onSimRefresh: " + resp);
    if (resp == null) {
        Rlog.e(LOG_TAG, "onSimRefresh: received without input");
        return;
    }
    if (mUiccCards[index] == null) {
        Rlog.e(LOG_TAG, "onSimRefresh: refresh on null card : " + index);
        return;
    }
    Rlog.d(LOG_TAG, "Handling refresh: " + resp);
    boolean changed = false;
    switch(resp.refreshResult) {
        case IccRefreshResponse.REFRESH_RESULT_RESET:
        case IccRefreshResponse.REFRESH_RESULT_INIT:
            // Reset the required apps when we know about the refresh so that
            // anyone interested does not get stale state.
            changed = mUiccCards[index].resetAppWithAid(resp.aid);
            break;
        default:
            return;
    }
    if (changed && resp.refreshResult == IccRefreshResponse.REFRESH_RESULT_RESET) {
        boolean requirePowerOffOnSimRefreshReset = mContext.getResources().getBoolean(com.android.internal.R.bool.config_requireRadioPowerOffOnSimRefreshReset);
        if (requirePowerOffOnSimRefreshReset) {
            mCis[index].setRadioPower(false, null);
        }
    }
    // The card status could have changed. Get the latest state.
    mCis[index].getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE));
    mIccChangedRegistrants.notifyRegistrants(new AsyncResult(null, index, null));
}
#method_after
private void onSimRefresh(AsyncResult ar, Integer index) {
    if (ar.exception != null) {
        Rlog.e(LOG_TAG, "Sim REFRESH with exception: " + ar.exception);
        return;
    }
    if (!isValidCardIndex(index)) {
        Rlog.e(LOG_TAG, "onSimRefresh: invalid index : " + index);
        return;
    }
    IccRefreshResponse resp = (IccRefreshResponse) ar.result;
    Rlog.d(LOG_TAG, "onSimRefresh: " + resp);
    if (resp == null) {
        Rlog.e(LOG_TAG, "onSimRefresh: received without input");
        return;
    }
    UiccCard uiccCard = getUiccCardForPhone(index);
    if (uiccCard == null) {
        Rlog.e(LOG_TAG, "onSimRefresh: refresh on null card : " + index);
        return;
    }
    Rlog.d(LOG_TAG, "Handling refresh: " + resp);
    boolean changed = false;
    switch(resp.refreshResult) {
        case IccRefreshResponse.REFRESH_RESULT_RESET:
        case IccRefreshResponse.REFRESH_RESULT_INIT:
            // Reset the required apps when we know about the refresh so that
            // anyone interested does not get stale state.
            changed = uiccCard.resetAppWithAid(resp.aid);
            break;
        default:
            return;
    }
    if (changed && resp.refreshResult == IccRefreshResponse.REFRESH_RESULT_RESET) {
        boolean requirePowerOffOnSimRefreshReset = mContext.getResources().getBoolean(com.android.internal.R.bool.config_requireRadioPowerOffOnSimRefreshReset);
        if (requirePowerOffOnSimRefreshReset) {
            mCis[index].setRadioPower(false, null);
        }
    }
    // The card status could have changed. Get the latest state.
    mCis[index].getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE, index));
}
#end_block

#method_before
private boolean isValidCardIndex(int index) {
    return (index >= 0 && index < mUiccCards.length);
}
#method_after
private boolean isValidCardIndex(int index) {
    return (index >= 0 && index < TelephonyManager.getDefault().getPhoneCount());
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("UiccController: " + this);
    pw.println(" mContext=" + mContext);
    pw.println(" mInstance=" + mInstance);
    pw.println(" mIccChangedRegistrants: size=" + mIccChangedRegistrants.size());
    for (int i = 0; i < mIccChangedRegistrants.size(); i++) {
        pw.println("  mIccChangedRegistrants[" + i + "]=" + ((Registrant) mIccChangedRegistrants.get(i)).getHandler());
    }
    pw.println();
    pw.flush();
    pw.println(" mUiccCards: size=" + mUiccCards.length);
    for (int i = 0; i < mUiccCards.length; i++) {
        if (mUiccCards[i] == null) {
            pw.println("  mUiccCards[" + i + "]=null");
        } else {
            pw.println("  mUiccCards[" + i + "]=" + mUiccCards[i]);
            mUiccCards[i].dump(fd, pw, args);
        }
    }
    pw.println("mCardLogs: ");
    for (int i = 0; i < mCardLogs.size(); ++i) {
        pw.println("  " + mCardLogs.get(i));
    }
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("UiccController: " + this);
    pw.println(" mContext=" + mContext);
    pw.println(" mInstance=" + mInstance);
    pw.println(" mIccChangedRegistrants: size=" + mIccChangedRegistrants.size());
    for (int i = 0; i < mIccChangedRegistrants.size(); i++) {
        pw.println("  mIccChangedRegistrants[" + i + "]=" + ((Registrant) mIccChangedRegistrants.get(i)).getHandler());
    }
    pw.println();
    pw.flush();
    pw.println(" mUiccSlots: size=" + mUiccSlots.length);
    for (int i = 0; i < mUiccSlots.length; i++) {
        if (mUiccSlots[i] == null) {
            pw.println("  mUiccSlots[" + i + "]=null");
        } else {
            pw.println("  mUiccSlots[" + i + "]=" + mUiccSlots[i]);
            mUiccSlots[i].dump(fd, pw, args);
        }
    }
    pw.println("mCardLogs: ");
    for (int i = 0; i < mCardLogs.size(); ++i) {
        pw.println("  " + mCardLogs.get(i));
    }
}
#end_block

#method_before
@Override
public String toString() {
    String iccIdToPrint = SubscriptionInfo.givePrintableIccid(mFullIccId);
    return "mDestroyed=" + mDestroyed + " mContext=" + mContext + " mCi=" + mCi + " mFh=" + mFh + " mParentApp=" + mParentApp + " recordsLoadedRegistrants=" + mRecordsLoadedRegistrants + " mImsiReadyRegistrants=" + mImsiReadyRegistrants + " mRecordsEventsRegistrants=" + mRecordsEventsRegistrants + " mNewSmsRegistrants=" + mNewSmsRegistrants + " mNetworkSelectionModeAutomaticRegistrants=" + mNetworkSelectionModeAutomaticRegistrants + " recordsToLoad=" + mRecordsToLoad + " adnCache=" + mAdnCache + " recordsRequested=" + mRecordsRequested + " iccid=" + iccIdToPrint + " msisdnTag=" + mMsisdnTag + " voiceMailNum=" + Rlog.pii(VDBG, mVoiceMailNum) + " voiceMailTag=" + mVoiceMailTag + " voiceMailNum=" + Rlog.pii(VDBG, mNewVoiceMailNum) + " newVoiceMailTag=" + mNewVoiceMailTag + " isVoiceMailFixed=" + mIsVoiceMailFixed + " mImsi=" + ((mImsi != null) ? mImsi.substring(0, 6) + Rlog.pii(VDBG, mImsi.substring(6)) : "null") + " mncLength=" + mMncLength + " mailboxIndex=" + mMailboxIndex + " spn=" + mSpn;
}
#method_after
@Override
public String toString() {
    String iccIdToPrint = SubscriptionInfo.givePrintableIccid(mFullIccId);
    return "mDestroyed=" + mDestroyed + " mContext=" + mContext + " mCi=" + mCi + " mFh=" + mFh + " mParentApp=" + mParentApp + " recordsToLoad=" + mRecordsToLoad + " adnCache=" + mAdnCache + " recordsRequested=" + mRecordsRequested + " lockedRecordsRequested=" + mLockedRecordsRequested + " iccid=" + iccIdToPrint + " msisdnTag=" + mMsisdnTag + " voiceMailNum=" + Rlog.pii(VDBG, mVoiceMailNum) + " voiceMailTag=" + mVoiceMailTag + " voiceMailNum=" + Rlog.pii(VDBG, mNewVoiceMailNum) + " newVoiceMailTag=" + mNewVoiceMailTag + " isVoiceMailFixed=" + mIsVoiceMailFixed + " mImsi=" + ((mImsi != null) ? mImsi.substring(0, 6) + Rlog.pii(VDBG, mImsi.substring(6)) : "null") + (mCarrierTestOverride.isInTestMode() ? " mFakeImsi=" + mFakeImsi : "") + " mncLength=" + mMncLength + " mailboxIndex=" + mMailboxIndex + " spn=" + mSpn + (mCarrierTestOverride.isInTestMode() ? " mFakeSpn=" + mFakeSpn : "");
}
#end_block

#method_before
public void registerForRecordsLoaded(Handler h, int what, Object obj) {
    if (mDestroyed.get()) {
        return;
    }
    Registrant r = new Registrant(h, what, obj);
    mRecordsLoadedRegistrants.add(r);
    if (mRecordsToLoad == 0 && mRecordsRequested == true) {
        r.notifyRegistrant(new AsyncResult(null, null, null));
    }
}
#method_after
public void registerForRecordsLoaded(Handler h, int what, Object obj) {
    if (mDestroyed.get()) {
        return;
    }
    Registrant r = new Registrant(h, what, obj);
    mRecordsLoadedRegistrants.add(r);
    if (getRecordsLoaded()) {
        r.notifyRegistrant(new AsyncResult(null, null, null));
    }
}
#end_block

#method_before
public void registerForImsiReady(Handler h, int what, Object obj) {
    if (mDestroyed.get()) {
        return;
    }
    Registrant r = new Registrant(h, what, obj);
    mImsiReadyRegistrants.add(r);
    if (mImsi != null) {
        r.notifyRegistrant(new AsyncResult(null, null, null));
    }
}
#method_after
public void registerForImsiReady(Handler h, int what, Object obj) {
    if (mDestroyed.get()) {
        return;
    }
    Registrant r = new Registrant(h, what, obj);
    mImsiReadyRegistrants.add(r);
    if (getIMSI() != null) {
        r.notifyRegistrant(new AsyncResult(null, null, null));
    }
}
#end_block

#method_before
public String getIMSI() {
    return null;
}
#method_after
public String getIMSI() {
    if (mCarrierTestOverride.isInTestMode() && mFakeImsi != null) {
        return mFakeImsi;
    } else {
        return mImsi;
    }
}
#end_block

#method_before
public String getGid1() {
    return null;
}
#method_after
public String getGid1() {
    if (mCarrierTestOverride.isInTestMode() && mFakeGid1 != null) {
        return mFakeGid1;
    } else {
        return mGid1;
    }
}
#end_block

#method_before
public String getGid2() {
    return null;
}
#method_after
public String getGid2() {
    if (mCarrierTestOverride.isInTestMode() && mFakeGid2 != null) {
        return mFakeGid2;
    } else {
        return mGid2;
    }
}
#end_block

#method_before
public String getServiceProviderName() {
    String providerName = mSpn;
    // Check for null pointers, mParentApp can be null after dispose,
    // which did occur after removing a SIM.
    UiccCardApplication parentApp = mParentApp;
    if (parentApp != null) {
        UiccCard card = parentApp.getUiccCard();
        if (card != null) {
            String brandOverride = card.getOperatorBrandOverride();
            if (brandOverride != null) {
                log("getServiceProviderName: override, providerName=" + providerName);
                providerName = brandOverride;
            } else {
                log("getServiceProviderName: no brandOverride, providerName=" + providerName);
            }
        } else {
            log("getServiceProviderName: card is null, providerName=" + providerName);
        }
    } else {
        log("getServiceProviderName: mParentApp is null, providerName=" + providerName);
    }
    return providerName;
}
#method_after
public String getServiceProviderName() {
    if (mCarrierTestOverride.isInTestMode() && mFakeSpn != null) {
        return mFakeSpn;
    }
    String providerName = mSpn;
    // Check for null pointers, mParentApp can be null after dispose,
    // which did occur after removing a SIM.
    UiccCardApplication parentApp = mParentApp;
    if (parentApp != null) {
        UiccCard card = parentApp.getUiccCard();
        if (card != null) {
            String brandOverride = card.getOperatorBrandOverride();
            if (brandOverride != null) {
                log("getServiceProviderName: override, providerName=" + providerName);
                providerName = brandOverride;
            } else {
                log("getServiceProviderName: no brandOverride, providerName=" + providerName);
            }
        } else {
            log("getServiceProviderName: card is null, providerName=" + providerName);
        }
    } else {
        log("getServiceProviderName: mParentApp is null, providerName=" + providerName);
    }
    return providerName;
}
#end_block

#method_before
protected void setServiceProviderName(String spn) {
    mSpn = spn;
}
#method_after
protected void setServiceProviderName(String spn) {
    if (!TextUtils.equals(mSpn, spn)) {
        mSpnUpdatedRegistrants.notifyRegistrants();
        mSpn = spn;
    }
}
#end_block

#method_before
public boolean getRecordsLoaded() {
    if (mRecordsToLoad == 0 && mRecordsRequested == true) {
        return true;
    } else {
        return false;
    }
}
#method_after
public boolean getRecordsLoaded() {
    return mRecordsToLoad == 0 && mRecordsRequested;
}
#end_block

#method_before
protected void handleRefresh(IccRefreshResponse refreshResponse) {
    if (refreshResponse == null) {
        if (DBG)
            log("handleRefresh received without input");
        return;
    }
    if (refreshResponse.aid != null && !refreshResponse.aid.equals(mParentApp.getAid())) {
        // This is for different app. Ignore.
        return;
    }
    switch(refreshResponse.refreshResult) {
        case IccRefreshResponse.REFRESH_RESULT_FILE_UPDATE:
            if (DBG)
                log("handleRefresh with SIM_FILE_UPDATED");
            handleFileUpdate(refreshResponse.efId);
            break;
        default:
            // unknown refresh operation
            if (DBG)
                log("handleRefresh with unknown operation");
            break;
    }
}
#method_after
protected void handleRefresh(IccRefreshResponse refreshResponse) {
    if (refreshResponse == null) {
        if (DBG)
            log("handleRefresh received without input");
        return;
    }
    if (!TextUtils.isEmpty(refreshResponse.aid) && !refreshResponse.aid.equals(mParentApp.getAid())) {
        // This is for different app. Ignore.
        return;
    }
    switch(refreshResponse.refreshResult) {
        case IccRefreshResponse.REFRESH_RESULT_FILE_UPDATE:
            if (DBG)
                log("handleRefresh with SIM_FILE_UPDATED");
            handleFileUpdate(refreshResponse.efId);
            break;
        default:
            // unknown refresh operation
            if (DBG)
                log("handleRefresh with unknown operation");
            break;
    }
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("IccRecords: " + this);
    pw.println(" mDestroyed=" + mDestroyed);
    pw.println(" mCi=" + mCi);
    pw.println(" mFh=" + mFh);
    pw.println(" mParentApp=" + mParentApp);
    pw.println(" recordsLoadedRegistrants: size=" + mRecordsLoadedRegistrants.size());
    for (int i = 0; i < mRecordsLoadedRegistrants.size(); i++) {
        pw.println("  recordsLoadedRegistrants[" + i + "]=" + ((Registrant) mRecordsLoadedRegistrants.get(i)).getHandler());
    }
    pw.println(" mImsiReadyRegistrants: size=" + mImsiReadyRegistrants.size());
    for (int i = 0; i < mImsiReadyRegistrants.size(); i++) {
        pw.println("  mImsiReadyRegistrants[" + i + "]=" + ((Registrant) mImsiReadyRegistrants.get(i)).getHandler());
    }
    pw.println(" mRecordsEventsRegistrants: size=" + mRecordsEventsRegistrants.size());
    for (int i = 0; i < mRecordsEventsRegistrants.size(); i++) {
        pw.println("  mRecordsEventsRegistrants[" + i + "]=" + ((Registrant) mRecordsEventsRegistrants.get(i)).getHandler());
    }
    pw.println(" mNewSmsRegistrants: size=" + mNewSmsRegistrants.size());
    for (int i = 0; i < mNewSmsRegistrants.size(); i++) {
        pw.println("  mNewSmsRegistrants[" + i + "]=" + ((Registrant) mNewSmsRegistrants.get(i)).getHandler());
    }
    pw.println(" mNetworkSelectionModeAutomaticRegistrants: size=" + mNetworkSelectionModeAutomaticRegistrants.size());
    for (int i = 0; i < mNetworkSelectionModeAutomaticRegistrants.size(); i++) {
        pw.println("  mNetworkSelectionModeAutomaticRegistrants[" + i + "]=" + ((Registrant) mNetworkSelectionModeAutomaticRegistrants.get(i)).getHandler());
    }
    pw.println(" mRecordsRequested=" + mRecordsRequested);
    pw.println(" mRecordsToLoad=" + mRecordsToLoad);
    pw.println(" mRdnCache=" + mAdnCache);
    String iccIdToPrint = SubscriptionInfo.givePrintableIccid(mFullIccId);
    pw.println(" iccid=" + iccIdToPrint);
    pw.println(" mMsisdn=" + Rlog.pii(VDBG, mMsisdn));
    pw.println(" mMsisdnTag=" + mMsisdnTag);
    pw.println(" mVoiceMailNum=" + Rlog.pii(VDBG, mVoiceMailNum));
    pw.println(" mVoiceMailTag=" + mVoiceMailTag);
    pw.println(" mNewVoiceMailNum=" + Rlog.pii(VDBG, mNewVoiceMailNum));
    pw.println(" mNewVoiceMailTag=" + mNewVoiceMailTag);
    pw.println(" mIsVoiceMailFixed=" + mIsVoiceMailFixed);
    pw.println(" mImsi=" + ((mImsi != null) ? mImsi.substring(0, 6) + Rlog.pii(VDBG, mImsi.substring(6)) : "null"));
    pw.println(" mMncLength=" + mMncLength);
    pw.println(" mMailboxIndex=" + mMailboxIndex);
    pw.println(" mSpn=" + mSpn);
    pw.flush();
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("IccRecords: " + this);
    pw.println(" mDestroyed=" + mDestroyed);
    pw.println(" mCi=" + mCi);
    pw.println(" mFh=" + mFh);
    pw.println(" mParentApp=" + mParentApp);
    pw.println(" recordsLoadedRegistrants: size=" + mRecordsLoadedRegistrants.size());
    for (int i = 0; i < mRecordsLoadedRegistrants.size(); i++) {
        pw.println("  recordsLoadedRegistrants[" + i + "]=" + ((Registrant) mRecordsLoadedRegistrants.get(i)).getHandler());
    }
    pw.println(" mLockedRecordsLoadedRegistrants: size=" + mLockedRecordsLoadedRegistrants.size());
    for (int i = 0; i < mLockedRecordsLoadedRegistrants.size(); i++) {
        pw.println("  mLockedRecordsLoadedRegistrants[" + i + "]=" + ((Registrant) mLockedRecordsLoadedRegistrants.get(i)).getHandler());
    }
    pw.println(" mImsiReadyRegistrants: size=" + mImsiReadyRegistrants.size());
    for (int i = 0; i < mImsiReadyRegistrants.size(); i++) {
        pw.println("  mImsiReadyRegistrants[" + i + "]=" + ((Registrant) mImsiReadyRegistrants.get(i)).getHandler());
    }
    pw.println(" mRecordsEventsRegistrants: size=" + mRecordsEventsRegistrants.size());
    for (int i = 0; i < mRecordsEventsRegistrants.size(); i++) {
        pw.println("  mRecordsEventsRegistrants[" + i + "]=" + ((Registrant) mRecordsEventsRegistrants.get(i)).getHandler());
    }
    pw.println(" mNewSmsRegistrants: size=" + mNewSmsRegistrants.size());
    for (int i = 0; i < mNewSmsRegistrants.size(); i++) {
        pw.println("  mNewSmsRegistrants[" + i + "]=" + ((Registrant) mNewSmsRegistrants.get(i)).getHandler());
    }
    pw.println(" mNetworkSelectionModeAutomaticRegistrants: size=" + mNetworkSelectionModeAutomaticRegistrants.size());
    for (int i = 0; i < mNetworkSelectionModeAutomaticRegistrants.size(); i++) {
        pw.println("  mNetworkSelectionModeAutomaticRegistrants[" + i + "]=" + ((Registrant) mNetworkSelectionModeAutomaticRegistrants.get(i)).getHandler());
    }
    pw.println(" mRecordsRequested=" + mRecordsRequested);
    pw.println(" mLockedRecordsRequested=" + mLockedRecordsRequested);
    pw.println(" mRecordsToLoad=" + mRecordsToLoad);
    pw.println(" mRdnCache=" + mAdnCache);
    String iccIdToPrint = SubscriptionInfo.givePrintableIccid(mFullIccId);
    pw.println(" iccid=" + iccIdToPrint);
    pw.println(" mMsisdn=" + Rlog.pii(VDBG, mMsisdn));
    pw.println(" mMsisdnTag=" + mMsisdnTag);
    pw.println(" mVoiceMailNum=" + Rlog.pii(VDBG, mVoiceMailNum));
    pw.println(" mVoiceMailTag=" + mVoiceMailTag);
    pw.println(" mNewVoiceMailNum=" + Rlog.pii(VDBG, mNewVoiceMailNum));
    pw.println(" mNewVoiceMailTag=" + mNewVoiceMailTag);
    pw.println(" mIsVoiceMailFixed=" + mIsVoiceMailFixed);
    pw.println(" mImsi=" + ((mImsi != null) ? mImsi.substring(0, 6) + Rlog.pii(VDBG, mImsi.substring(6)) : "null"));
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeImsi=" + mFakeImsi);
    }
    pw.println(" mMncLength=" + mMncLength);
    pw.println(" mMailboxIndex=" + mMailboxIndex);
    pw.println(" mSpn=" + mSpn);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeSpn=" + mFakeSpn);
    }
    pw.flush();
}
#end_block

#method_before
@Override
public void onLooperPrepared() {
    mIccRecords = new SIMRecords(mUiccCardApplication3gpp, mContext, mMockCI);
    setReady(true);
}
#method_after
@Override
public void onLooperPrepared() {
    mIccRecords = new SIMRecords(mUiccCardApplication3gpp, mContext, mSimulatedCommands);
    setReady(true);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    super.setUp(this.getClass().getSimpleName());
    mMockCI = mock(CommandsInterface.class);
    new IccRecordsTestHandler(TAG).start();
    waitUntilReady();
}
#method_after
@Before
public void setUp() throws Exception {
    super.setUp(this.getClass().getSimpleName());
    new IccRecordsTestHandler(TAG).start();
    waitUntilReady();
}
#end_block

#method_before
@After
public void tearDown() throws Exception {
    super.tearDown();
    mIccRecords.dispose();
}
#method_after
@After
public void tearDown() throws Exception {
    super.tearDown();
}
#end_block

#method_before
@Test
public void testDisposeCallsUnregisterForIccRefresh() {
    // verify called below when IccRecords object is created
    verify(mMockCI).registerForIccRefresh(any(IccRecords.class), eq(IccRecords.EVENT_REFRESH), isNull());
    mIccRecords.dispose();
    // verify called within dispose
    verify(mMockCI).unregisterForIccRefresh(any(IccRecords.class));
}
#method_after
@Test
public void testDisposeCallsUnregisterForIccRefresh() {
    // verify called below when IccRecords object is created
    verify(mSimulatedCommandsVerifier).registerForIccRefresh(eq(mIccRecords), eq(IccRecords.EVENT_REFRESH), isNull());
    mIccRecords.dispose();
    // verify called within dispose
    verify(mSimulatedCommandsVerifier).unregisterForIccRefresh(eq(mIccRecords));
}
#end_block

#method_before
@Override
public void onLooperPrepared() {
    mIsimUiccRecords = new IsimUiccRecords(mUiccCardApplication3gpp, mContext, mMockCI);
    setReady(true);
}
#method_after
@Override
public void onLooperPrepared() {
    mIsimUiccRecords = new IsimUiccRecords(mUiccCardApplication3gpp, mContext, mSimulatedCommands);
    setReady(true);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    super.setUp(this.getClass().getSimpleName());
    mMockCI = mock(CommandsInterface.class);
    new IsimUiccRecordsTestHandler(TAG).start();
    waitUntilReady();
}
#method_after
@Before
public void setUp() throws Exception {
    super.setUp(this.getClass().getSimpleName());
    new IsimUiccRecordsTestHandler(TAG).start();
    waitUntilReady();
}
#end_block

#method_before
@Test
public void testBroadcastRefresh() {
    Message msg = new Message();
    msg.what = (Integer) getStaticField(IsimUiccRecords.class, mIsimUiccRecords, "EVENT_ISIM_REFRESH");
    mIsimUiccRecords.handleMessage(msg);
    ArgumentCaptor<Intent> intentCapture = ArgumentCaptor.forClass(Intent.class);
    verify(mContext).sendBroadcast(intentCapture.capture());
    assertEquals(((Intent) intentCapture.getValue()).getAction(), IsimUiccRecords.INTENT_ISIM_REFRESH);
}
#method_after
@Test
public void testBroadcastRefresh() {
    Message msg = new Message();
    msg.what = IccRecords.EVENT_REFRESH;
    msg.obj = new AsyncResult(null, null, null);
    mIsimUiccRecords.handleMessage(msg);
    ArgumentCaptor<Intent> intentCapture = ArgumentCaptor.forClass(Intent.class);
    verify(mContext).sendBroadcast(intentCapture.capture());
    assertEquals(((Intent) intentCapture.getValue()).getAction(), IsimUiccRecords.INTENT_ISIM_REFRESH);
}
#end_block

#method_before
@Override
public String toString() {
    return "SimRecords: " + super.toString() + " mVmConfig" + mVmConfig + " mSpnOverride=" + "mSpnOverride" + " callForwardingEnabled=" + mCallForwardingStatus + " spnState=" + mSpnState + " mCphsInfo=" + mCphsInfo + " mCspPlmnEnabled=" + mCspPlmnEnabled + " efMWIS=" + mEfMWIS + " efCPHS_MWI=" + mEfCPHS_MWI + " mEfCff=" + mEfCff + " mEfCfis=" + mEfCfis + " getOperatorNumeric=" + getOperatorNumeric();
}
#method_after
@Override
public String toString() {
    return "SimRecords: " + super.toString() + " mVmConfig" + mVmConfig + " callForwardingEnabled=" + mCallForwardingStatus + " spnState=" + mSpnState + " mCphsInfo=" + mCphsInfo + " mCspPlmnEnabled=" + mCspPlmnEnabled + " efMWIS=" + mEfMWIS + " efCPHS_MWI=" + mEfCPHS_MWI + " mEfCff=" + mEfCff + " mEfCfis=" + mEfCfis + " getOperatorNumeric=" + getOperatorNumeric();
}
#end_block

#method_before
@Override
public void dispose() {
    if (DBG)
        log("Disposing SIMRecords this=" + this);
    // Unregister for all events
    mCi.unSetOnSmsOnSim(this);
    mParentApp.unregisterForReady(this);
    mParentApp.unregisterForLocked(this);
    resetRecords();
    super.dispose();
}
#method_after
@Override
public void dispose() {
    if (DBG)
        log("Disposing SIMRecords this=" + this);
    // Unregister for all events
    mCi.unSetOnSmsOnSim(this);
    mParentApp.unregisterForReady(this);
    mParentApp.unregisterForLocked(this);
    mContext.unregisterReceiver(mReceiver);
    resetRecords();
    super.dispose();
}
#end_block

#method_before
protected void resetRecords() {
    mImsi = null;
    mMsisdn = null;
    mVoiceMailNum = null;
    mMncLength = UNINITIALIZED;
    log("setting0 mMncLength" + mMncLength);
    mIccId = null;
    mFullIccId = null;
    // -1 means no EF_SPN found; treat accordingly.
    mSpnDisplayCondition = -1;
    mEfMWIS = null;
    mEfCPHS_MWI = null;
    mSpdiNetworks = null;
    mPnnHomeName = null;
    mGid1 = null;
    mGid2 = null;
    mPlmnActRecords = null;
    mOplmnActRecords = null;
    mHplmnActRecords = null;
    mFplmns = null;
    mEhplmns = null;
    mAdnCache.reset();
    log("SIMRecords: onRadioOffOrNotAvailable set 'gsm.sim.operator.numeric' to operator=null");
    log("update icc_operator_numeric=" + null);
    mTelephonyManager.setSimOperatorNumericForPhone(mParentApp.getPhoneId(), "");
    mTelephonyManager.setSimOperatorNameForPhone(mParentApp.getPhoneId(), "");
    mTelephonyManager.setSimCountryIsoForPhone(mParentApp.getPhoneId(), "");
    // recordsRequested is set to false indicating that the SIM
    // read requests made so far are not valid. This is set to
    // true only when fresh set of read requests are made.
    mRecordsRequested = false;
}
#method_after
protected void resetRecords() {
    mImsi = null;
    mMsisdn = null;
    mVoiceMailNum = null;
    mMncLength = UNINITIALIZED;
    log("setting0 mMncLength" + mMncLength);
    mIccId = null;
    mFullIccId = null;
    // -1 means no EF_SPN found; treat accordingly.
    mSpnDisplayCondition = -1;
    mEfMWIS = null;
    mEfCPHS_MWI = null;
    mSpdiNetworks = null;
    mPnnHomeName = null;
    mGid1 = null;
    mGid2 = null;
    mPlmnActRecords = null;
    mOplmnActRecords = null;
    mHplmnActRecords = null;
    mFplmns = null;
    mEhplmns = null;
    mAdnCache.reset();
    log("SIMRecords: onRadioOffOrNotAvailable set 'gsm.sim.operator.numeric' to operator=null");
    log("update icc_operator_numeric=" + null);
    mTelephonyManager.setSimOperatorNumericForPhone(mParentApp.getPhoneId(), "");
    mTelephonyManager.setSimOperatorNameForPhone(mParentApp.getPhoneId(), "");
    mTelephonyManager.setSimCountryIsoForPhone(mParentApp.getPhoneId(), "");
    // recordsRequested is set to false indicating that the SIM
    // read requests made so far are not valid. This is set to
    // true only when fresh set of read requests are made.
    mRecordsRequested = false;
    mLockedRecordsRequested = false;
}
#end_block

#method_before
@Override
public String getMsisdnNumber() {
    return mMsisdn;
}
#method_after
// ***** Public Methods
@Override
public String getMsisdnNumber() {
    return mMsisdn;
}
#end_block

#method_before
private boolean validEfCfis(byte[] data) {
    if (data != null) {
        if (data[0] < 1 || data[0] > 4) {
            // The MSP (Multiple Subscriber Profile) byte should be between
            // 1 and 4 according to ETSI TS 131 102 v11.3.0 section 4.2.64.
            logw("MSP byte: " + data[0] + " is not between 1 and 4", null);
        }
        return true;
    }
    return false;
}
#method_after
private boolean validEfCfis(byte[] data) {
    if (data != null) {
        if (data[0] < 1 || data[0] > 4) {
            // The MSP (Multiple Subscriber Profile) byte should be between
            // 1 and 4 according to ETSI TS 131 102 v11.3.0 section 4.2.64.
            logw("MSP byte: " + data[0] + " is not between 1 and 4", null);
        }
        // empty EF_CFIS should be considered as call forward disabled
        for (byte b : data) {
            if (b != (byte) 0xFF) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void setVoiceCallForwardingFlag(int line, boolean enable, String dialNumber) {
    // only line 1 is supported
    if (line != 1)
        return;
    mCallForwardingStatus = enable ? CALL_FORWARDING_STATUS_ENABLED : CALL_FORWARDING_STATUS_DISABLED;
    mRecordsEventsRegistrants.notifyResult(EVENT_CFI);
    try {
        if (validEfCfis(mEfCfis)) {
            // lsb is of byte f1 is voice status
            if (enable) {
                mEfCfis[1] |= 1;
            } else {
                mEfCfis[1] &= 0xfe;
            }
            log("setVoiceCallForwardingFlag: enable=" + enable + " mEfCfis=" + IccUtils.bytesToHexString(mEfCfis));
            // Spec reference for EF_CFIS contents, TS 51.011 section 10.3.46.
            if (enable && !TextUtils.isEmpty(dialNumber)) {
                logv("EF_CFIS: updating cf number, " + Rlog.pii(LOG_TAG, dialNumber));
                byte[] bcdNumber = PhoneNumberUtils.numberToCalledPartyBCD(dialNumber);
                System.arraycopy(bcdNumber, 0, mEfCfis, CFIS_TON_NPI_OFFSET, bcdNumber.length);
                mEfCfis[CFIS_BCD_NUMBER_LENGTH_OFFSET] = (byte) (bcdNumber.length);
                mEfCfis[CFIS_ADN_CAPABILITY_ID_OFFSET] = (byte) 0xFF;
                mEfCfis[CFIS_ADN_EXTENSION_ID_OFFSET] = (byte) 0xFF;
            }
            mFh.updateEFLinearFixed(EF_CFIS, 1, mEfCfis, null, obtainMessage(EVENT_UPDATE_DONE, EF_CFIS));
        } else {
            log("setVoiceCallForwardingFlag: ignoring enable=" + enable + " invalid mEfCfis=" + IccUtils.bytesToHexString(mEfCfis));
        }
        if (mEfCff != null) {
            if (enable) {
                mEfCff[0] = (byte) ((mEfCff[0] & CFF_LINE1_RESET) | CFF_UNCONDITIONAL_ACTIVE);
            } else {
                mEfCff[0] = (byte) ((mEfCff[0] & CFF_LINE1_RESET) | CFF_UNCONDITIONAL_DEACTIVE);
            }
            mFh.updateEFTransparent(EF_CFF_CPHS, mEfCff, obtainMessage(EVENT_UPDATE_DONE, EF_CFF_CPHS));
        }
    } catch (ArrayIndexOutOfBoundsException ex) {
        logw("Error saving call forwarding flag to SIM. " + "Probably malformed SIM record", ex);
    }
}
#method_after
@Override
public void setVoiceCallForwardingFlag(int line, boolean enable, String dialNumber) {
    // only line 1 is supported
    if (line != 1)
        return;
    mCallForwardingStatus = enable ? CALL_FORWARDING_STATUS_ENABLED : CALL_FORWARDING_STATUS_DISABLED;
    mRecordsEventsRegistrants.notifyResult(EVENT_CFI);
    try {
        if (validEfCfis(mEfCfis)) {
            // lsb is of byte f1 is voice status
            if (enable) {
                mEfCfis[1] |= 1;
            } else {
                mEfCfis[1] &= 0xfe;
            }
            log("setVoiceCallForwardingFlag: enable=" + enable + " mEfCfis=" + IccUtils.bytesToHexString(mEfCfis));
            // Spec reference for EF_CFIS contents, TS 51.011 section 10.3.46.
            if (enable && !TextUtils.isEmpty(dialNumber)) {
                logv("EF_CFIS: updating cf number, " + Rlog.pii(LOG_TAG, dialNumber));
                byte[] bcdNumber = PhoneNumberUtils.numberToCalledPartyBCD(dialNumber, PhoneNumberUtils.BCD_EXTENDED_TYPE_EF_ADN);
                System.arraycopy(bcdNumber, 0, mEfCfis, CFIS_TON_NPI_OFFSET, bcdNumber.length);
                mEfCfis[CFIS_BCD_NUMBER_LENGTH_OFFSET] = (byte) (bcdNumber.length);
                mEfCfis[CFIS_ADN_CAPABILITY_ID_OFFSET] = (byte) 0xFF;
                mEfCfis[CFIS_ADN_EXTENSION_ID_OFFSET] = (byte) 0xFF;
            }
            mFh.updateEFLinearFixed(EF_CFIS, 1, mEfCfis, null, obtainMessage(EVENT_UPDATE_DONE, EF_CFIS));
        } else {
            log("setVoiceCallForwardingFlag: ignoring enable=" + enable + " invalid mEfCfis=" + IccUtils.bytesToHexString(mEfCfis));
        }
        if (mEfCff != null) {
            if (enable) {
                mEfCff[0] = (byte) ((mEfCff[0] & CFF_LINE1_RESET) | CFF_UNCONDITIONAL_ACTIVE);
            } else {
                mEfCff[0] = (byte) ((mEfCff[0] & CFF_LINE1_RESET) | CFF_UNCONDITIONAL_DEACTIVE);
            }
            mFh.updateEFTransparent(EF_CFF_CPHS, mEfCff, obtainMessage(EVENT_UPDATE_DONE, EF_CFF_CPHS));
        }
    } catch (ArrayIndexOutOfBoundsException ex) {
        logw("Error saving call forwarding flag to SIM. " + "Probably malformed SIM record", ex);
    }
}
#end_block

#method_before
@Override
public String getOperatorNumeric() {
    if (mImsi == null) {
        log("getOperatorNumeric: IMSI == null");
        return null;
    }
    if (mMncLength == UNINITIALIZED || mMncLength == UNKNOWN) {
        log("getSIMOperatorNumeric: bad mncLength");
        return null;
    }
    // length of mcc = 3 (TS 23.003 Section 2.2)
    return mImsi.substring(0, 3 + mMncLength);
}
#method_after
@Override
public String getOperatorNumeric() {
    String imsi = getIMSI();
    if (imsi == null) {
        log("getOperatorNumeric: IMSI == null");
        return null;
    }
    if (mMncLength == UNINITIALIZED || mMncLength == UNKNOWN) {
        log("getSIMOperatorNumeric: bad mncLength");
        return null;
    }
    // length of mcc = 3 (TS 23.003 Section 2.2)
    if (imsi.length() >= 3 + mMncLength) {
        return imsi.substring(0, 3 + mMncLength);
    } else {
        return null;
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    AdnRecord adn;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] " + " while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_APP_LOCKED:
                onLocked();
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                log("IMSI: mMncLength=" + mMncLength);
                log("IMSI: " + mImsi.substring(0, 6) + Rlog.pii(LOG_TAG, mImsi.substring(6)));
                if (((mMncLength == UNKNOWN) || (mMncLength == 2)) && ((mImsi != null) && (mImsi.length() >= 6))) {
                    String mccmncCode = mImsi.substring(0, 6);
                    for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                        if (mccmnc.equals(mccmncCode)) {
                            mMncLength = 3;
                            log("IMSI: setting1 mMncLength=" + mMncLength);
                            break;
                        }
                    }
                }
                if (mMncLength == UNKNOWN) {
                    // guess using the mcc
                    try {
                        int mcc = Integer.parseInt(mImsi.substring(0, 3));
                        mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                        log("setting2 mMncLength=" + mMncLength);
                    } catch (NumberFormatException e) {
                        mMncLength = UNKNOWN;
                        loge("Corrupt IMSI! setting3 mMncLength=" + mMncLength);
                    }
                }
                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED) {
                    log("update mccmnc=" + mImsi.substring(0, 3 + mMncLength));
                    // finally have both the imsi and the mncLength and
                    // can parse the imsi properly
                    MccTable.updateMccMncConfiguration(mContext, mImsi.substring(0, 3 + mMncLength), false);
                }
                mImsiReadyRegistrants.notifyRegistrants();
                break;
            case EVENT_GET_MBI_DONE:
                boolean isValidMbdn;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                isValidMbdn = false;
                if (ar.exception == null) {
                    // Refer TS 51.011 Section 10.3.44 for content details
                    log("EF_MBI: " + IccUtils.bytesToHexString(data));
                    // Voice mail record number stored first
                    mMailboxIndex = data[0] & 0xff;
                    // check if dailing numbe id valid
                    if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
                        log("Got valid mailbox number for MBDN");
                        isValidMbdn = true;
                    }
                }
                // one more record to load
                mRecordsToLoad += 1;
                if (isValidMbdn) {
                    // Note: MBDN was not included in NUM_OF_SIM_RECORDS_LOADED
                    new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6, mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
                } else {
                    // If this EF not present, try mailbox as in CPHS standard
                    // CPHS (CPHS4_2.WW6) is a european standard.
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                }
                break;
            case EVENT_GET_CPHS_MAILBOX_DONE:
            case EVENT_GET_MBDN_DONE:
                // Resetting the voice mail number and voice mail tag to null
                // as these should be updated from the data read from EF_MBDN.
                // If they are not reset, incase of invalid data/exception these
                // variables are retaining their previous values and are
                // causing invalid voice mailbox info display to user.
                mVoiceMailNum = null;
                mVoiceMailTag = null;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF" + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? "[MAILBOX]" : "[MBDN]"));
                    if (msg.what == EVENT_GET_MBDN_DONE) {
                        // load CPHS on fail...
                        // FIXME right now, only load line1's CPHS voice mail entry
                        mRecordsToLoad += 1;
                        new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    }
                    break;
                }
                adn = (AdnRecord) ar.result;
                log("VM: " + adn + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? " EF[MAILBOX]" : " EF[MBDN]"));
                if (adn.isEmpty() && msg.what == EVENT_GET_MBDN_DONE) {
                    // Bug #645770 fall back to CPHS
                    // FIXME should use SST to decide
                    // FIXME right now, only load line1's CPHS voice mail entry
                    mRecordsToLoad += 1;
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    break;
                }
                mVoiceMailNum = adn.getNumber();
                mVoiceMailTag = adn.getAlphaTag();
                break;
            case EVENT_GET_MSISDN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF[MSISDN]");
                    break;
                }
                adn = (AdnRecord) ar.result;
                mMsisdn = adn.getNumber();
                mMsisdnTag = adn.getAlphaTag();
                log("MSISDN: " + /*mMsisdn*/
                Rlog.pii(LOG_TAG, mMsisdn));
                break;
            case EVENT_SET_MSISDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mMsisdn = mNewMsisdn;
                    mMsisdnTag = mNewMsisdnTag;
                    log("Success to update EF[MSISDN]");
                }
                if (ar.userObj != null) {
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_MWIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_MWIS : " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG)
                        log("EVENT_GET_MWIS_DONE exception = " + ar.exception);
                    break;
                }
                if ((data[0] & 0xff) == 0xff) {
                    if (DBG)
                        log("SIMRecords: Uninitialized record MWIS");
                    break;
                }
                mEfMWIS = data;
                break;
            case EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_CPHS_MWI: " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG) {
                        log("EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE exception = " + ar.exception);
                    }
                    break;
                }
                mEfCPHS_MWI = data;
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                mFullIccId = IccUtils.bchToString(data, 0, data.length);
                log("iccid: " + SubscriptionInfo.givePrintableIccid(mFullIccId));
                break;
            case EVENT_GET_AD_DONE:
                try {
                    isRecordLoadResponse = true;
                    ar = (AsyncResult) msg.obj;
                    data = (byte[]) ar.result;
                    if (ar.exception != null) {
                        break;
                    }
                    log("EF_AD: " + IccUtils.bytesToHexString(data));
                    if (data.length < 3) {
                        log("Corrupt AD data on SIM");
                        break;
                    }
                    if (data.length == 3) {
                        log("MNC length not present in EF_AD");
                        break;
                    }
                    mMncLength = data[3] & 0xf;
                    log("setting4 mMncLength=" + mMncLength);
                    if (mMncLength == 0xf) {
                        mMncLength = UNKNOWN;
                        log("setting5 mMncLength=" + mMncLength);
                    } else if (mMncLength != 2 && mMncLength != 3) {
                        mMncLength = UNINITIALIZED;
                        log("setting5 mMncLength=" + mMncLength);
                    }
                } finally {
                    if (((mMncLength == UNINITIALIZED) || (mMncLength == UNKNOWN) || (mMncLength == 2)) && ((mImsi != null) && (mImsi.length() >= 6))) {
                        String mccmncCode = mImsi.substring(0, 6);
                        log("mccmncCode=" + mccmncCode);
                        for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                            if (mccmnc.equals(mccmncCode)) {
                                mMncLength = 3;
                                log("setting6 mMncLength=" + mMncLength);
                                break;
                            }
                        }
                    }
                    if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
                        if (mImsi != null) {
                            try {
                                int mcc = Integer.parseInt(mImsi.substring(0, 3));
                                mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                                log("setting7 mMncLength=" + mMncLength);
                            } catch (NumberFormatException e) {
                                mMncLength = UNKNOWN;
                                loge("Corrupt IMSI! setting8 mMncLength=" + mMncLength);
                            }
                        } else {
                            // Indicate we got this info, but it didn't contain the length.
                            mMncLength = UNKNOWN;
                            log("MNC length not present in EF_AD setting9 " + "mMncLength=" + mMncLength);
                        }
                    }
                    if (mImsi != null && mMncLength != UNKNOWN) {
                        // finally have both imsi and the length of the mnc and can parse
                        // the imsi properly
                        log("update mccmnc=" + mImsi.substring(0, 3 + mMncLength));
                        MccTable.updateMccMncConfiguration(mContext, mImsi.substring(0, 3 + mMncLength), false);
                    }
                }
                break;
            case EVENT_GET_SPN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                getSpnFsm(false, ar);
                break;
            case EVENT_GET_CFF_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCff = null;
                } else {
                    log("EF_CFF_CPHS: " + IccUtils.bytesToHexString(data));
                    mEfCff = data;
                }
                break;
            case EVENT_GET_SPDI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                parseEfSpdi(data);
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    logw("update failed. ", ar.exception);
                }
                break;
            case EVENT_GET_PNN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                SimTlv tlv = new SimTlv(data, 0, data.length);
                for (; tlv.isValidObject(); tlv.nextObject()) {
                    if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
                        mPnnHomeName = IccUtils.networkNameToString(tlv.getData(), 0, tlv.getData().length);
                        break;
                    }
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                handleSmses((ArrayList<byte[]>) ar.result);
                break;
            case EVENT_MARK_SMS_READ_DONE:
                Rlog.i("ENF", "marked read: sms " + msg.arg1);
                break;
            case EVENT_SMS_ON_SIM:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                Integer index = (Integer) ar.result;
                if (ar.exception != null || index == null) {
                    loge("Error on SMS_ON_SIM with exp " + ar.exception + " index " + index);
                } else {
                    log("READ EF_SMS RECORD index=" + index);
                    mFh.loadEFLinearFixed(EF_SMS, index, obtainMessage(EVENT_GET_SMS_DONE));
                }
                break;
            case EVENT_GET_SMS_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    handleSms((byte[]) ar.result);
                } else {
                    loge("Error on GET_SMS with exp " + ar.exception);
                }
                break;
            case EVENT_GET_SST_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mUsimServiceTable = new UsimServiceTable(data);
                if (DBG)
                    log("SST: " + mUsimServiceTable);
                break;
            case EVENT_GET_INFO_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                mCphsInfo = (byte[]) ar.result;
                if (DBG)
                    log("iCPHS: " + IccUtils.bytesToHexString(mCphsInfo));
                break;
            case EVENT_SET_MBDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("EVENT_SET_MBDN_DONE ex:" + ar.exception);
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                }
                if (isCphsMailboxEnabled()) {
                    adn = new AdnRecord(mVoiceMailTag, mVoiceMailNum);
                    Message onCphsCompleted = (Message) ar.userObj;
                    /* write to cphs mailbox whenever it is available but
                        * we only need notify caller once if both updating are
                        * successful.
                        *
                        * so if set_mbdn successful, notify caller here and set
                        * onCphsCompleted to null
                        */
                    if (ar.exception == null && ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = null;
                        ((Message) ar.userObj).sendToTarget();
                        if (DBG)
                            log("Callback with MBDN successful.");
                        onCphsCompleted = null;
                    }
                    new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null, obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onCphsCompleted));
                } else {
                    if (ar.userObj != null) {
                        CarrierConfigManager configLoader = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
                        if (ar.exception != null && configLoader != null && configLoader.getConfig().getBoolean(CarrierConfigManager.KEY_EDITABLE_VOICEMAIL_NUMBER_BOOL)) {
                            // GsmCdmaPhone will store vm number on device
                            // when IccVmNotSupportedException occurred
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = new IccVmNotSupportedException("Update SIM voice mailbox error");
                        } else {
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                        }
                        ((Message) ar.userObj).sendToTarget();
                    }
                }
                break;
            case EVENT_SET_CPHS_MAILBOX_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                } else {
                    if (DBG)
                        log("Set CPHS MailBox with exception: " + ar.exception);
                }
                if (ar.userObj != null) {
                    if (DBG)
                        log("Callback with CPHS MB successful.");
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_CFIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCfis = null;
                } else {
                    log("EF_CFIS: " + IccUtils.bytesToHexString(data));
                    mEfCfis = data;
                }
                break;
            case EVENT_GET_CSP_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception in fetching EF_CSP data " + ar.exception);
                    break;
                }
                data = (byte[]) ar.result;
                log("EF_CSP: " + IccUtils.bytesToHexString(data));
                handleEfCspData(data);
                break;
            case EVENT_GET_GID1_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID1 " + ar.exception);
                    mGid1 = null;
                    break;
                }
                mGid1 = IccUtils.bytesToHexString(data);
                log("GID1: " + mGid1);
                break;
            case EVENT_GET_GID2_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID2 " + ar.exception);
                    mGid2 = null;
                    break;
                }
                mGid2 = IccUtils.bytesToHexString(data);
                log("GID2: " + mGid2);
                break;
            case EVENT_GET_PLMN_W_ACT_DONE:
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting User PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mPlmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("PlmnActRecords=" + Arrays.toString(mPlmnActRecords));
                }
                break;
            case EVENT_GET_OPLMN_W_ACT_DONE:
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Operator PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mOplmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("OplmnActRecord[]=" + Arrays.toString(mOplmnActRecords));
                }
                break;
            case EVENT_GET_HPLMN_W_ACT_DONE:
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Home PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mHplmnActRecords = PlmnActRecord.getRecords(data);
                    log("HplmnActRecord[]=" + Arrays.toString(mHplmnActRecords));
                }
                break;
            case EVENT_GET_EHPLMN_DONE:
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Equivalent Home PLMNs: " + ar.exception);
                    break;
                } else {
                    mEhplmns = parseBcdPlmnList(data, "Equivalent Home");
                }
                break;
            case EVENT_GET_FPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Forbidden PLMNs: " + ar.exception);
                    break;
                } else {
                    mFplmns = parseBcdPlmnList(data, "Forbidden");
                }
                if (msg.arg1 == HANDLER_ACTION_SEND_RESPONSE) {
                    if (VDBG)
                        logv("getForbiddenPlmns(): send async response");
                    isRecordLoadResponse = false;
                    Message response = retrievePendingResponseMessage(msg.arg2);
                    if (response != null) {
                        AsyncResult.forMessage(response, Arrays.copyOf(mFplmns, mFplmns.length), null);
                        response.sendToTarget();
                    } else {
                        loge("Failed to retrieve a response message for FPLMN");
                        break;
                    }
                }
                break;
            case EVENT_CARRIER_CONFIG_CHANGED:
                handleCarrierNameOverride();
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        logw("Exception parsing SIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    AdnRecord adn;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] " + " while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_APP_LOCKED:
                onLocked();
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                log("IMSI: mMncLength=" + mMncLength);
                if (mImsi != null && mImsi.length() >= 6) {
                    log("IMSI: " + mImsi.substring(0, 6) + Rlog.pii(LOG_TAG, mImsi.substring(6)));
                }
                String imsi = getIMSI();
                if (((mMncLength == UNKNOWN) || (mMncLength == 2)) && ((imsi != null) && (imsi.length() >= 6))) {
                    String mccmncCode = imsi.substring(0, 6);
                    for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                        if (mccmnc.equals(mccmncCode)) {
                            mMncLength = 3;
                            log("IMSI: setting1 mMncLength=" + mMncLength);
                            break;
                        }
                    }
                }
                if (mMncLength == UNKNOWN) {
                    // guess using the mcc
                    try {
                        int mcc = Integer.parseInt(imsi.substring(0, 3));
                        mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                        log("setting2 mMncLength=" + mMncLength);
                    } catch (NumberFormatException e) {
                        mMncLength = UNKNOWN;
                        loge("Corrupt IMSI! setting3 mMncLength=" + mMncLength);
                    }
                }
                if (mMncLength != UNKNOWN && mMncLength != UNINITIALIZED && imsi.length() >= 3 + mMncLength) {
                    log("update mccmnc=" + imsi.substring(0, 3 + mMncLength));
                    // finally have both the imsi and the mncLength and
                    // can parse the imsi properly
                    MccTable.updateMccMncConfiguration(mContext, imsi.substring(0, 3 + mMncLength), false);
                }
                mImsiReadyRegistrants.notifyRegistrants();
                break;
            case EVENT_GET_MBI_DONE:
                boolean isValidMbdn;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                isValidMbdn = false;
                if (ar.exception == null) {
                    // Refer TS 51.011 Section 10.3.44 for content details
                    log("EF_MBI: " + IccUtils.bytesToHexString(data));
                    // Voice mail record number stored first
                    mMailboxIndex = data[0] & 0xff;
                    // check if dailing numbe id valid
                    if (mMailboxIndex != 0 && mMailboxIndex != 0xff) {
                        log("Got valid mailbox number for MBDN");
                        isValidMbdn = true;
                    }
                }
                // one more record to load
                mRecordsToLoad += 1;
                if (isValidMbdn) {
                    // Note: MBDN was not included in NUM_OF_SIM_RECORDS_LOADED
                    new AdnRecordLoader(mFh).loadFromEF(EF_MBDN, EF_EXT6, mMailboxIndex, obtainMessage(EVENT_GET_MBDN_DONE));
                } else {
                    // If this EF not present, try mailbox as in CPHS standard
                    // CPHS (CPHS4_2.WW6) is a european standard.
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                }
                break;
            case EVENT_GET_CPHS_MAILBOX_DONE:
            case EVENT_GET_MBDN_DONE:
                // Resetting the voice mail number and voice mail tag to null
                // as these should be updated from the data read from EF_MBDN.
                // If they are not reset, incase of invalid data/exception these
                // variables are retaining their previous values and are
                // causing invalid voice mailbox info display to user.
                mVoiceMailNum = null;
                mVoiceMailTag = null;
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF" + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? "[MAILBOX]" : "[MBDN]"));
                    if (msg.what == EVENT_GET_MBDN_DONE) {
                        // load CPHS on fail...
                        // FIXME right now, only load line1's CPHS voice mail entry
                        mRecordsToLoad += 1;
                        new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    }
                    break;
                }
                adn = (AdnRecord) ar.result;
                log("VM: " + adn + ((msg.what == EVENT_GET_CPHS_MAILBOX_DONE) ? " EF[MAILBOX]" : " EF[MBDN]"));
                if (adn.isEmpty() && msg.what == EVENT_GET_MBDN_DONE) {
                    // Bug #645770 fall back to CPHS
                    // FIXME should use SST to decide
                    // FIXME right now, only load line1's CPHS voice mail entry
                    mRecordsToLoad += 1;
                    new AdnRecordLoader(mFh).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1, 1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                    break;
                }
                mVoiceMailNum = adn.getNumber();
                mVoiceMailTag = adn.getAlphaTag();
                break;
            case EVENT_GET_MSISDN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("Invalid or missing EF[MSISDN]");
                    break;
                }
                adn = (AdnRecord) ar.result;
                mMsisdn = adn.getNumber();
                mMsisdnTag = adn.getAlphaTag();
                log("MSISDN: " + /*mMsisdn*/
                Rlog.pii(LOG_TAG, mMsisdn));
                break;
            case EVENT_SET_MSISDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mMsisdn = mNewMsisdn;
                    mMsisdnTag = mNewMsisdnTag;
                    log("Success to update EF[MSISDN]");
                }
                if (ar.userObj != null) {
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_MWIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_MWIS : " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG)
                        log("EVENT_GET_MWIS_DONE exception = " + ar.exception);
                    break;
                }
                if ((data[0] & 0xff) == 0xff) {
                    if (DBG)
                        log("SIMRecords: Uninitialized record MWIS");
                    break;
                }
                mEfMWIS = data;
                break;
            case EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (DBG)
                    log("EF_CPHS_MWI: " + IccUtils.bytesToHexString(data));
                if (ar.exception != null) {
                    if (DBG) {
                        log("EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE exception = " + ar.exception);
                    }
                    break;
                }
                mEfCPHS_MWI = data;
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                mFullIccId = IccUtils.bchToString(data, 0, data.length);
                log("iccid: " + SubscriptionInfo.givePrintableIccid(mFullIccId));
                break;
            case EVENT_GET_AD_DONE:
                try {
                    isRecordLoadResponse = true;
                    if (mCarrierTestOverride.isInTestMode() && getIMSI() != null) {
                        imsi = getIMSI();
                        try {
                            int mcc = Integer.parseInt(imsi.substring(0, 3));
                            mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                            log("[TestMode] mMncLength=" + mMncLength);
                        } catch (NumberFormatException e) {
                            mMncLength = UNKNOWN;
                            loge("[TestMode] Corrupt IMSI! mMncLength=" + mMncLength);
                        }
                    } else {
                        ar = (AsyncResult) msg.obj;
                        data = (byte[]) ar.result;
                        if (ar.exception != null) {
                            break;
                        }
                        log("EF_AD: " + IccUtils.bytesToHexString(data));
                        if (data.length < 3) {
                            log("Corrupt AD data on SIM");
                            break;
                        }
                        if (data.length == 3) {
                            log("MNC length not present in EF_AD");
                            break;
                        }
                        mMncLength = data[3] & 0xf;
                        log("setting4 mMncLength=" + mMncLength);
                    }
                    if (mMncLength == 0xf) {
                        mMncLength = UNKNOWN;
                        log("setting5 mMncLength=" + mMncLength);
                    } else if (mMncLength != 2 && mMncLength != 3) {
                        mMncLength = UNINITIALIZED;
                        log("setting5 mMncLength=" + mMncLength);
                    }
                } finally {
                    // IMSI could be a value reading from Sim or a fake IMSI if in the test mode
                    imsi = getIMSI();
                    if (((mMncLength == UNINITIALIZED) || (mMncLength == UNKNOWN) || (mMncLength == 2)) && ((imsi != null) && (imsi.length() >= 6))) {
                        String mccmncCode = imsi.substring(0, 6);
                        log("mccmncCode=" + mccmncCode);
                        for (String mccmnc : MCCMNC_CODES_HAVING_3DIGITS_MNC) {
                            if (mccmnc.equals(mccmncCode)) {
                                mMncLength = 3;
                                log("setting6 mMncLength=" + mMncLength);
                                break;
                            }
                        }
                    }
                    if (mMncLength == UNKNOWN || mMncLength == UNINITIALIZED) {
                        if (imsi != null) {
                            try {
                                int mcc = Integer.parseInt(imsi.substring(0, 3));
                                mMncLength = MccTable.smallestDigitsMccForMnc(mcc);
                                log("setting7 mMncLength=" + mMncLength);
                            } catch (NumberFormatException e) {
                                mMncLength = UNKNOWN;
                                loge("Corrupt IMSI! setting8 mMncLength=" + mMncLength);
                            }
                        } else {
                            // Indicate we got this info, but it didn't contain the length.
                            mMncLength = UNKNOWN;
                            log("MNC length not present in EF_AD setting9 " + "mMncLength=" + mMncLength);
                        }
                    }
                    if (imsi != null && mMncLength != UNKNOWN && imsi.length() >= 3 + mMncLength) {
                        // finally have both imsi and the length of the mnc and can parse
                        // the imsi properly
                        log("update mccmnc=" + imsi.substring(0, 3 + mMncLength));
                        MccTable.updateMccMncConfiguration(mContext, imsi.substring(0, 3 + mMncLength), false);
                    }
                }
                break;
            case EVENT_GET_SPN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                getSpnFsm(false, ar);
                break;
            case EVENT_GET_CFF_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCff = null;
                } else {
                    log("EF_CFF_CPHS: " + IccUtils.bytesToHexString(data));
                    mEfCff = data;
                }
                break;
            case EVENT_GET_SPDI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                parseEfSpdi(data);
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    logw("update failed. ", ar.exception);
                }
                break;
            case EVENT_GET_PNN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                SimTlv tlv = new SimTlv(data, 0, data.length);
                for (; tlv.isValidObject(); tlv.nextObject()) {
                    if (tlv.getTag() == TAG_FULL_NETWORK_NAME) {
                        mPnnHomeName = IccUtils.networkNameToString(tlv.getData(), 0, tlv.getData().length);
                        log("PNN: " + mPnnHomeName);
                        break;
                    }
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                handleSmses((ArrayList<byte[]>) ar.result);
                break;
            case EVENT_MARK_SMS_READ_DONE:
                Rlog.i("ENF", "marked read: sms " + msg.arg1);
                break;
            case EVENT_SMS_ON_SIM:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                Integer index = (Integer) ar.result;
                if (ar.exception != null || index == null) {
                    loge("Error on SMS_ON_SIM with exp " + ar.exception + " index " + index);
                } else {
                    log("READ EF_SMS RECORD index=" + index);
                    mFh.loadEFLinearFixed(EF_SMS, index, obtainMessage(EVENT_GET_SMS_DONE));
                }
                break;
            case EVENT_GET_SMS_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    handleSms((byte[]) ar.result);
                } else {
                    loge("Error on GET_SMS with exp " + ar.exception);
                }
                break;
            case EVENT_GET_SST_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mUsimServiceTable = new UsimServiceTable(data);
                if (DBG)
                    log("SST: " + mUsimServiceTable);
                break;
            case EVENT_GET_INFO_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                mCphsInfo = (byte[]) ar.result;
                if (DBG)
                    log("iCPHS: " + IccUtils.bytesToHexString(mCphsInfo));
                break;
            case EVENT_SET_MBDN_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (DBG)
                    log("EVENT_SET_MBDN_DONE ex:" + ar.exception);
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                }
                if (isCphsMailboxEnabled()) {
                    adn = new AdnRecord(mVoiceMailTag, mVoiceMailNum);
                    Message onCphsCompleted = (Message) ar.userObj;
                    /* write to cphs mailbox whenever it is available but
                        * we only need notify caller once if both updating are
                        * successful.
                        *
                        * so if set_mbdn successful, notify caller here and set
                        * onCphsCompleted to null
                        */
                    if (ar.exception == null && ar.userObj != null) {
                        AsyncResult.forMessage(((Message) ar.userObj)).exception = null;
                        ((Message) ar.userObj).sendToTarget();
                        if (DBG)
                            log("Callback with MBDN successful.");
                        onCphsCompleted = null;
                    }
                    new AdnRecordLoader(mFh).updateEF(adn, EF_MAILBOX_CPHS, EF_EXT1, 1, null, obtainMessage(EVENT_SET_CPHS_MAILBOX_DONE, onCphsCompleted));
                } else {
                    if (ar.userObj != null) {
                        CarrierConfigManager configLoader = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
                        if (ar.exception != null && configLoader != null && configLoader.getConfig().getBoolean(CarrierConfigManager.KEY_EDITABLE_VOICEMAIL_NUMBER_BOOL)) {
                            // GsmCdmaPhone will store vm number on device
                            // when IccVmNotSupportedException occurred
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = new IccVmNotSupportedException("Update SIM voice mailbox error");
                        } else {
                            AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                        }
                        ((Message) ar.userObj).sendToTarget();
                    }
                }
                break;
            case EVENT_SET_CPHS_MAILBOX_DONE:
                isRecordLoadResponse = false;
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    mVoiceMailNum = mNewVoiceMailNum;
                    mVoiceMailTag = mNewVoiceMailTag;
                } else {
                    if (DBG)
                        log("Set CPHS MailBox with exception: " + ar.exception);
                }
                if (ar.userObj != null) {
                    if (DBG)
                        log("Callback with CPHS MB successful.");
                    AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                    ((Message) ar.userObj).sendToTarget();
                }
                break;
            case EVENT_GET_CFIS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    mEfCfis = null;
                } else {
                    log("EF_CFIS: " + IccUtils.bytesToHexString(data));
                    mEfCfis = data;
                }
                break;
            case EVENT_GET_CSP_CPHS_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception in fetching EF_CSP data " + ar.exception);
                    break;
                }
                data = (byte[]) ar.result;
                log("EF_CSP: " + IccUtils.bytesToHexString(data));
                handleEfCspData(data);
                break;
            case EVENT_GET_GID1_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID1 " + ar.exception);
                    mGid1 = null;
                    break;
                }
                mGid1 = IccUtils.bytesToHexString(data);
                log("GID1: " + mGid1);
                break;
            case EVENT_GET_GID2_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    loge("Exception in get GID2 " + ar.exception);
                    mGid2 = null;
                    break;
                }
                mGid2 = IccUtils.bytesToHexString(data);
                log("GID2: " + mGid2);
                break;
            case EVENT_GET_PLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting User PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mPlmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("PlmnActRecords=" + Arrays.toString(mPlmnActRecords));
                }
                break;
            case EVENT_GET_OPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Operator PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mOplmnActRecords = PlmnActRecord.getRecords(data);
                    if (VDBG)
                        log("OplmnActRecord[]=" + Arrays.toString(mOplmnActRecords));
                }
                break;
            case EVENT_GET_HPLMN_W_ACT_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Home PLMN with Access Tech Records: " + ar.exception);
                    break;
                } else {
                    log("Received a PlmnActRecord, raw=" + IccUtils.bytesToHexString(data));
                    mHplmnActRecords = PlmnActRecord.getRecords(data);
                    log("HplmnActRecord[]=" + Arrays.toString(mHplmnActRecords));
                }
                break;
            case EVENT_GET_EHPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Equivalent Home PLMNs: " + ar.exception);
                    break;
                } else {
                    mEhplmns = parseBcdPlmnList(data, "Equivalent Home");
                }
                break;
            case EVENT_GET_FPLMN_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null || data == null) {
                    loge("Failed getting Forbidden PLMNs: " + ar.exception);
                    break;
                } else {
                    mFplmns = parseBcdPlmnList(data, "Forbidden");
                }
                if (msg.arg1 == HANDLER_ACTION_SEND_RESPONSE) {
                    if (VDBG)
                        logv("getForbiddenPlmns(): send async response");
                    isRecordLoadResponse = false;
                    Message response = retrievePendingResponseMessage(msg.arg2);
                    if (response != null) {
                        AsyncResult.forMessage(response, Arrays.copyOf(mFplmns, mFplmns.length), null);
                        response.sendToTarget();
                    } else {
                        loge("Failed to retrieve a response message for FPLMN");
                        break;
                    }
                }
                break;
            case EVENT_CARRIER_CONFIG_CHANGED:
                handleCarrierNameOverride();
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        logw("Exception parsing SIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#end_block

#method_before
@Override
protected void onRecordLoaded() {
    // One record loaded successfully or failed, In either case
    // we need to update the recordsToLoad count
    mRecordsToLoad -= 1;
    if (DBG)
        log("onRecordLoaded " + mRecordsToLoad + " requested: " + mRecordsRequested);
    if (mRecordsToLoad == 0 && mRecordsRequested == true) {
        onAllRecordsLoaded();
    } else if (mRecordsToLoad < 0) {
        loge("recordsToLoad <0, programmer error suspected");
        mRecordsToLoad = 0;
    }
}
#method_after
@Override
protected void onRecordLoaded() {
    // One record loaded successfully or failed, In either case
    // we need to update the recordsToLoad count
    mRecordsToLoad -= 1;
    if (DBG)
        log("onRecordLoaded " + mRecordsToLoad + " requested: " + mRecordsRequested);
    if (getRecordsLoaded()) {
        onAllRecordsLoaded();
    } else if (getLockedRecordsLoaded()) {
        onLockedAllRecordsLoaded();
    } else if (mRecordsToLoad < 0) {
        loge("recordsToLoad <0, programmer error suspected");
        mRecordsToLoad = 0;
    }
}
#end_block

#method_before
@Override
protected void onAllRecordsLoaded() {
    if (DBG)
        log("record load complete");
    Resources resource = Resources.getSystem();
    if (resource.getBoolean(com.android.internal.R.bool.config_use_sim_language_file)) {
        setSimLanguage(mEfLi, mEfPl);
    } else {
        if (DBG)
            log("Not using EF LI/EF PL");
    }
    setVoiceCallForwardingFlagFromSimRecords();
    if (mParentApp.getState() == AppState.APPSTATE_PIN || mParentApp.getState() == AppState.APPSTATE_PUK) {
        // reset recordsRequested, since sim is not loaded really
        mRecordsRequested = false;
        // lock state, only update language
        return;
    }
    // Some fields require more than one SIM record to set
    String operator = getOperatorNumeric();
    if (!TextUtils.isEmpty(operator)) {
        log("onAllRecordsLoaded set 'gsm.sim.operator.numeric' to operator='" + operator + "'");
        log("update icc_operator_numeric=" + operator);
        mTelephonyManager.setSimOperatorNumericForPhone(mParentApp.getPhoneId(), operator);
        final SubscriptionController subController = SubscriptionController.getInstance();
        subController.setMccMnc(operator, subController.getDefaultSubId());
    } else {
        log("onAllRecordsLoaded empty 'gsm.sim.operator.numeric' skipping");
    }
    if (!TextUtils.isEmpty(mImsi)) {
        log("onAllRecordsLoaded set mcc imsi" + (VDBG ? ("=" + mImsi) : ""));
        mTelephonyManager.setSimCountryIsoForPhone(mParentApp.getPhoneId(), MccTable.countryCodeForMcc(Integer.parseInt(mImsi.substring(0, 3))));
    } else {
        log("onAllRecordsLoaded empty imsi skipping setting mcc");
    }
    setVoiceMailByCountry(operator);
    mRecordsLoadedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
}
#method_after
@Override
protected void onAllRecordsLoaded() {
    if (DBG)
        log("record load complete");
    setSimLanguageFromEF();
    setVoiceCallForwardingFlagFromSimRecords();
    // Some fields require more than one SIM record to set
    String operator = getOperatorNumeric();
    if (!TextUtils.isEmpty(operator)) {
        log("onAllRecordsLoaded set 'gsm.sim.operator.numeric' to operator='" + operator + "'");
        mTelephonyManager.setSimOperatorNumericForPhone(mParentApp.getPhoneId(), operator);
    } else {
        log("onAllRecordsLoaded empty 'gsm.sim.operator.numeric' skipping");
    }
    String imsi = getIMSI();
    if (!TextUtils.isEmpty(imsi) && imsi.length() >= 3) {
        log("onAllRecordsLoaded set mcc imsi" + (VDBG ? ("=" + imsi) : ""));
        mTelephonyManager.setSimCountryIsoForPhone(mParentApp.getPhoneId(), MccTable.countryCodeForMcc(Integer.parseInt(imsi.substring(0, 3))));
    } else {
        log("onAllRecordsLoaded empty imsi skipping setting mcc");
    }
    setVoiceMailByCountry(operator);
    mRecordsLoadedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
}
#end_block

#method_before
// ***** Private methods
private void handleCarrierNameOverride() {
    CarrierConfigManager configLoader = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configLoader != null && configLoader.getConfig().getBoolean(CarrierConfigManager.KEY_CARRIER_NAME_OVERRIDE_BOOL)) {
        String carrierName = configLoader.getConfig().getString(CarrierConfigManager.KEY_CARRIER_NAME_STRING);
        setServiceProviderName(carrierName);
        mTelephonyManager.setSimOperatorNameForPhone(mParentApp.getPhoneId(), carrierName);
    } else {
        setSpnFromConfig(getOperatorNumeric());
    }
}
#method_after
// ***** Private methods
private void handleCarrierNameOverride() {
    final int phoneId = mParentApp.getPhoneId();
    SubscriptionController subCon = SubscriptionController.getInstance();
    final int subId = subCon.getSubIdUsingPhoneId(phoneId);
    if (subId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
        loge("subId not valid for Phone " + phoneId);
        return;
    }
    CarrierConfigManager configLoader = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configLoader == null) {
        loge("Failed to load a Carrier Config");
        return;
    }
    PersistableBundle config = configLoader.getConfigForSubId(subId);
    boolean preferCcName = config.getBoolean(CarrierConfigManager.KEY_CARRIER_NAME_OVERRIDE_BOOL, false);
    String ccName = config.getString(CarrierConfigManager.KEY_CARRIER_NAME_STRING);
    // a name in carrier config, use the carrier config name as a backup.
    if (preferCcName || (TextUtils.isEmpty(getServiceProviderName()) && !TextUtils.isEmpty(ccName))) {
        setServiceProviderName(ccName);
        mTelephonyManager.setSimOperatorNameForPhone(phoneId, ccName);
    }
    updateCarrierNameForSubscription(subCon, subId);
}
#end_block

#method_before
private void onLocked() {
    if (DBG)
        log("only fetch EF_LI and EF_PL in lock state");
    loadEfLiAndEfPl();
}
#method_after
private void onLocked() {
    if (DBG)
        log("only fetch EF_LI, EF_PL and EF_ICCID in locked state");
    mLockedRecordsRequested = true;
    loadEfLiAndEfPl();
    mFh.loadEFTransparent(EF_ICCID, obtainMessage(EVENT_GET_ICCID_DONE));
    mRecordsToLoad++;
}
#end_block

#method_before
private void loadEfLiAndEfPl() {
    if (mParentApp.getType() == AppType.APPTYPE_USIM) {
        mRecordsRequested = true;
        mFh.loadEFTransparent(EF_LI, obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfUsimLiLoaded()));
        mRecordsToLoad++;
        mFh.loadEFTransparent(EF_PL, obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfPlLoaded()));
        mRecordsToLoad++;
    }
}
#method_after
private void loadEfLiAndEfPl() {
    if (mParentApp.getType() == AppType.APPTYPE_USIM) {
        mFh.loadEFTransparent(EF_LI, obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfUsimLiLoaded()));
        mRecordsToLoad++;
        mFh.loadEFTransparent(EF_PL, obtainMessage(EVENT_GET_ICC_RECORD_DONE, new EfPlLoaded()));
        mRecordsToLoad++;
    }
}
#end_block

#method_before
protected void fetchSimRecords() {
    mRecordsRequested = true;
    if (DBG)
        log("fetchSimRecords " + mRecordsToLoad);
    mCi.getIMSIForApp(mParentApp.getAid(), obtainMessage(EVENT_GET_IMSI_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_ICCID, obtainMessage(EVENT_GET_ICCID_DONE));
    mRecordsToLoad++;
    // FIXME should examine EF[MSISDN]'s capability configuration
    // to determine which is the voice/data/fax line
    new AdnRecordLoader(mFh).loadFromEF(EF_MSISDN, getExtFromEf(EF_MSISDN), 1, obtainMessage(EVENT_GET_MSISDN_DONE));
    mRecordsToLoad++;
    // Record number is subscriber profile
    mFh.loadEFLinearFixed(EF_MBI, 1, obtainMessage(EVENT_GET_MBI_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_AD, obtainMessage(EVENT_GET_AD_DONE));
    mRecordsToLoad++;
    // Record number is subscriber profile
    mFh.loadEFLinearFixed(EF_MWIS, 1, obtainMessage(EVENT_GET_MWIS_DONE));
    mRecordsToLoad++;
    // Also load CPHS-style voice mail indicator, which stores
    // the same info as EF[MWIS]. If both exist, both are updated
    // but the EF[MWIS] data is preferred
    // Please note this must be loaded after EF[MWIS]
    mFh.loadEFTransparent(EF_VOICE_MAIL_INDICATOR_CPHS, obtainMessage(EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE));
    mRecordsToLoad++;
    // Same goes for Call Forward Status indicator: fetch both
    // EF[CFIS] and CPHS-EF, with EF[CFIS] preferred.
    loadCallForwardingRecords();
    getSpnFsm(true, null);
    mFh.loadEFTransparent(EF_SPDI, obtainMessage(EVENT_GET_SPDI_DONE));
    mRecordsToLoad++;
    mFh.loadEFLinearFixed(EF_PNN, 1, obtainMessage(EVENT_GET_PNN_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_SST, obtainMessage(EVENT_GET_SST_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_INFO_CPHS, obtainMessage(EVENT_GET_INFO_CPHS_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_CSP_CPHS, obtainMessage(EVENT_GET_CSP_CPHS_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_GID1, obtainMessage(EVENT_GET_GID1_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_GID2, obtainMessage(EVENT_GET_GID2_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_PLMN_W_ACT, obtainMessage(EVENT_GET_PLMN_W_ACT_DONE));
    mFh.loadEFTransparent(EF_OPLMN_W_ACT, obtainMessage(EVENT_GET_OPLMN_W_ACT_DONE));
    mFh.loadEFTransparent(EF_HPLMN_W_ACT, obtainMessage(EVENT_GET_HPLMN_W_ACT_DONE));
    mFh.loadEFTransparent(EF_EHPLMN, obtainMessage(EVENT_GET_EHPLMN_DONE));
    mFh.loadEFTransparent(EF_FPLMN, obtainMessage(EVENT_GET_FPLMN_DONE, HANDLER_ACTION_NONE, -1));
    mRecordsToLoad++;
    loadEfLiAndEfPl();
    // XXX should seek instead of examining them all
    if (false) {
        // XXX
        mFh.loadEFLinearFixedAll(EF_SMS, obtainMessage(EVENT_GET_ALL_SMS_DONE));
        mRecordsToLoad++;
    }
    if (CRASH_RIL) {
        String sms = "0107912160130310f20404d0110041007030208054832b0120" + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" + "ffffffffffffffffffffffffffffff";
        byte[] ba = IccUtils.hexStringToBytes(sms);
        mFh.updateEFLinearFixed(EF_SMS, 1, ba, null, obtainMessage(EVENT_MARK_SMS_READ_DONE, 1));
    }
    if (DBG)
        log("fetchSimRecords " + mRecordsToLoad + " requested: " + mRecordsRequested);
}
#method_after
protected void fetchSimRecords() {
    mRecordsRequested = true;
    if (DBG)
        log("fetchSimRecords " + mRecordsToLoad);
    mCi.getIMSIForApp(mParentApp.getAid(), obtainMessage(EVENT_GET_IMSI_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_ICCID, obtainMessage(EVENT_GET_ICCID_DONE));
    mRecordsToLoad++;
    // FIXME should examine EF[MSISDN]'s capability configuration
    // to determine which is the voice/data/fax line
    new AdnRecordLoader(mFh).loadFromEF(EF_MSISDN, getExtFromEf(EF_MSISDN), 1, obtainMessage(EVENT_GET_MSISDN_DONE));
    mRecordsToLoad++;
    // Record number is subscriber profile
    mFh.loadEFLinearFixed(EF_MBI, 1, obtainMessage(EVENT_GET_MBI_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_AD, obtainMessage(EVENT_GET_AD_DONE));
    mRecordsToLoad++;
    // Record number is subscriber profile
    mFh.loadEFLinearFixed(EF_MWIS, 1, obtainMessage(EVENT_GET_MWIS_DONE));
    mRecordsToLoad++;
    // Also load CPHS-style voice mail indicator, which stores
    // the same info as EF[MWIS]. If both exist, both are updated
    // but the EF[MWIS] data is preferred
    // Please note this must be loaded after EF[MWIS]
    mFh.loadEFTransparent(EF_VOICE_MAIL_INDICATOR_CPHS, obtainMessage(EVENT_GET_VOICE_MAIL_INDICATOR_CPHS_DONE));
    mRecordsToLoad++;
    // Same goes for Call Forward Status indicator: fetch both
    // EF[CFIS] and CPHS-EF, with EF[CFIS] preferred.
    loadCallForwardingRecords();
    getSpnFsm(true, null);
    mFh.loadEFTransparent(EF_SPDI, obtainMessage(EVENT_GET_SPDI_DONE));
    mRecordsToLoad++;
    mFh.loadEFLinearFixed(EF_PNN, 1, obtainMessage(EVENT_GET_PNN_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_SST, obtainMessage(EVENT_GET_SST_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_INFO_CPHS, obtainMessage(EVENT_GET_INFO_CPHS_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_CSP_CPHS, obtainMessage(EVENT_GET_CSP_CPHS_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_GID1, obtainMessage(EVENT_GET_GID1_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_GID2, obtainMessage(EVENT_GET_GID2_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_PLMN_W_ACT, obtainMessage(EVENT_GET_PLMN_W_ACT_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_OPLMN_W_ACT, obtainMessage(EVENT_GET_OPLMN_W_ACT_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_HPLMN_W_ACT, obtainMessage(EVENT_GET_HPLMN_W_ACT_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_EHPLMN, obtainMessage(EVENT_GET_EHPLMN_DONE));
    mRecordsToLoad++;
    mFh.loadEFTransparent(EF_FPLMN, obtainMessage(EVENT_GET_FPLMN_DONE, HANDLER_ACTION_NONE, -1));
    mRecordsToLoad++;
    loadEfLiAndEfPl();
    // XXX should seek instead of examining them all
    if (false) {
        // XXX
        mFh.loadEFLinearFixedAll(EF_SMS, obtainMessage(EVENT_GET_ALL_SMS_DONE));
        mRecordsToLoad++;
    }
    if (CRASH_RIL) {
        String sms = "0107912160130310f20404d0110041007030208054832b0120" + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" + "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" + "ffffffffffffffffffffffffffffff";
        byte[] ba = IccUtils.hexStringToBytes(sms);
        mFh.updateEFLinearFixed(EF_SMS, 1, ba, null, obtainMessage(EVENT_MARK_SMS_READ_DONE, 1));
    }
    if (DBG)
        log("fetchSimRecords " + mRecordsToLoad + " requested: " + mRecordsRequested);
}
#end_block

#method_before
@Override
public int getDisplayRule(String plmn) {
    int rule;
    if (mParentApp != null && mParentApp.getUiccCard() != null && mParentApp.getUiccCard().getOperatorBrandOverride() != null) {
        // If the operator has been overridden, treat it as the SPN file on the SIM did not exist.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (TextUtils.isEmpty(getServiceProviderName()) || mSpnDisplayCondition == -1) {
        // No EF_SPN content was found on the SIM, or not yet loaded.  Just show ONS.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (isOnMatchingPlmn(plmn)) {
        rule = SPN_RULE_SHOW_SPN;
        if ((mSpnDisplayCondition & 0x01) == 0x01) {
            // ONS required when registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_PLMN;
        }
    } else {
        rule = SPN_RULE_SHOW_PLMN;
        if ((mSpnDisplayCondition & 0x02) == 0x00) {
            // SPN required if not registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_SPN;
        }
    }
    return rule;
}
#method_after
@Override
public int getDisplayRule(ServiceState serviceState) {
    int rule;
    if (mParentApp != null && mParentApp.getUiccCard() != null && mParentApp.getUiccCard().getOperatorBrandOverride() != null) {
        // If the operator has been overridden, treat it as the SPN file on the SIM did not exist.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (TextUtils.isEmpty(getServiceProviderName()) || mSpnDisplayCondition == -1) {
        // No EF_SPN content was found on the SIM, or not yet loaded.  Just show ONS.
        rule = SPN_RULE_SHOW_PLMN;
    } else if (useRoamingFromServiceState() ? !serviceState.getRoaming() : isOnMatchingPlmn(serviceState.getOperatorNumeric())) {
        rule = SPN_RULE_SHOW_SPN;
        if ((mSpnDisplayCondition & 0x01) == 0x01) {
            // ONS required when registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_PLMN;
        }
    } else {
        rule = SPN_RULE_SHOW_PLMN;
        if ((mSpnDisplayCondition & 0x02) == 0x00) {
            // SPN required if not registered to HPLMN or PLMN in EF_SPDI
            rule |= SPN_RULE_SHOW_SPN;
        }
    }
    return rule;
}
#end_block

#method_before
private void parseEfSpdi(byte[] data) {
    SimTlv tlv = new SimTlv(data, 0, data.length);
    byte[] plmnEntries = null;
    for (; tlv.isValidObject(); tlv.nextObject()) {
        // Skip SPDI tag, if existant
        if (tlv.getTag() == TAG_SPDI) {
            tlv = new SimTlv(tlv.getData(), 0, tlv.getData().length);
        }
        // There should only be one TAG_SPDI_PLMN_LIST
        if (tlv.getTag() == TAG_SPDI_PLMN_LIST) {
            plmnEntries = tlv.getData();
            break;
        }
    }
    if (plmnEntries == null) {
        return;
    }
    mSpdiNetworks = new ArrayList<String>(plmnEntries.length / 3);
    for (int i = 0; i + 2 < plmnEntries.length; i += 3) {
        String plmnCode;
        plmnCode = IccUtils.bcdToString(plmnEntries, i, 3);
        // Valid operator codes are 5 or 6 digits
        if (plmnCode.length() >= 5) {
            log("EF_SPDI network: " + plmnCode);
            mSpdiNetworks.add(plmnCode);
        }
    }
}
#method_after
private void parseEfSpdi(byte[] data) {
    SimTlv tlv = new SimTlv(data, 0, data.length);
    byte[] plmnEntries = null;
    for (; tlv.isValidObject(); tlv.nextObject()) {
        // Skip SPDI tag, if existant
        if (tlv.getTag() == TAG_SPDI) {
            tlv = new SimTlv(tlv.getData(), 0, tlv.getData().length);
        }
        // There should only be one TAG_SPDI_PLMN_LIST
        if (tlv.getTag() == TAG_SPDI_PLMN_LIST) {
            plmnEntries = tlv.getData();
            break;
        }
    }
    if (plmnEntries == null) {
        return;
    }
    mSpdiNetworks = new ArrayList<String>(plmnEntries.length / 3);
    for (int i = 0; i + 2 < plmnEntries.length; i += 3) {
        String plmnCode;
        plmnCode = IccUtils.bcdPlmnToString(plmnEntries, i);
        // Valid operator codes are 5 or 6 digits
        if (plmnCode != null && plmnCode.length() >= 5) {
            log("EF_SPDI network: " + plmnCode);
            mSpdiNetworks.add(plmnCode);
        }
    }
}
#end_block

#method_before
private String[] parseBcdPlmnList(byte[] data, String description) {
    final int packedBcdPlmnLenBytes = 3;
    log("Received " + description + " PLMNs, raw=" + IccUtils.bytesToHexString(data));
    if (data.length == 0 || (data.length % packedBcdPlmnLenBytes) != 0) {
        loge("Received invalid " + description + " PLMN list");
        return null;
    }
    int numPlmns = data.length / packedBcdPlmnLenBytes;
    String[] ret = new String[numPlmns];
    for (int i = 0; i < numPlmns; i++) {
        ret[i] = IccUtils.bcdPlmnToString(data, i * packedBcdPlmnLenBytes);
    }
    if (VDBG)
        logv(description + " PLMNs: " + Arrays.toString(ret));
    return ret;
}
#method_after
private String[] parseBcdPlmnList(byte[] data, String description) {
    final int packedBcdPlmnLenBytes = 3;
    log("Received " + description + " PLMNs, raw=" + IccUtils.bytesToHexString(data));
    if (data.length == 0 || (data.length % packedBcdPlmnLenBytes) != 0) {
        loge("Received invalid " + description + " PLMN list");
        return null;
    }
    int numPlmns = data.length / packedBcdPlmnLenBytes;
    int numValidPlmns = 0;
    String[] parsed = new String[numPlmns];
    for (int i = 0; i < numPlmns; i++) {
        parsed[numValidPlmns] = IccUtils.bcdPlmnToString(data, i * packedBcdPlmnLenBytes);
        // we count the valid (non empty) records and only increment if valid
        if (!TextUtils.isEmpty(parsed[numValidPlmns]))
            numValidPlmns++;
    }
    String[] ret = Arrays.copyOf(parsed, numValidPlmns);
    if (VDBG)
        logv(description + " PLMNs: " + Arrays.toString(ret));
    return ret;
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("SIMRecords: " + this);
    pw.println(" extends:");
    super.dump(fd, pw, args);
    pw.println(" mVmConfig=" + mVmConfig);
    pw.println(" mSpnOverride=" + mSpnOverride);
    pw.println(" mCallForwardingStatus=" + mCallForwardingStatus);
    pw.println(" mSpnState=" + mSpnState);
    pw.println(" mCphsInfo=" + mCphsInfo);
    pw.println(" mCspPlmnEnabled=" + mCspPlmnEnabled);
    pw.println(" mEfMWIS[]=" + Arrays.toString(mEfMWIS));
    pw.println(" mEfCPHS_MWI[]=" + Arrays.toString(mEfCPHS_MWI));
    pw.println(" mEfCff[]=" + Arrays.toString(mEfCff));
    pw.println(" mEfCfis[]=" + Arrays.toString(mEfCfis));
    pw.println(" mSpnDisplayCondition=" + mSpnDisplayCondition);
    pw.println(" mSpdiNetworks[]=" + mSpdiNetworks);
    pw.println(" mPnnHomeName=" + mPnnHomeName);
    pw.println(" mUsimServiceTable=" + mUsimServiceTable);
    pw.println(" mGid1=" + mGid1);
    pw.println(" mGid2=" + mGid2);
    pw.println(" mPlmnActRecords[]=" + Arrays.toString(mPlmnActRecords));
    pw.println(" mOplmnActRecords[]=" + Arrays.toString(mOplmnActRecords));
    pw.println(" mHplmnActRecords[]=" + Arrays.toString(mHplmnActRecords));
    pw.println(" mFplmns[]=" + Arrays.toString(mFplmns));
    pw.println(" mEhplmns[]=" + Arrays.toString(mEhplmns));
    pw.flush();
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("SIMRecords: " + this);
    pw.println(" extends:");
    super.dump(fd, pw, args);
    pw.println(" mVmConfig=" + mVmConfig);
    pw.println(" mCallForwardingStatus=" + mCallForwardingStatus);
    pw.println(" mSpnState=" + mSpnState);
    pw.println(" mCphsInfo=" + mCphsInfo);
    pw.println(" mCspPlmnEnabled=" + mCspPlmnEnabled);
    pw.println(" mEfMWIS[]=" + Arrays.toString(mEfMWIS));
    pw.println(" mEfCPHS_MWI[]=" + Arrays.toString(mEfCPHS_MWI));
    pw.println(" mEfCff[]=" + Arrays.toString(mEfCff));
    pw.println(" mEfCfis[]=" + Arrays.toString(mEfCfis));
    pw.println(" mSpnDisplayCondition=" + mSpnDisplayCondition);
    pw.println(" mSpdiNetworks[]=" + mSpdiNetworks);
    pw.println(" mPnnHomeName=" + mPnnHomeName);
    pw.println(" mUsimServiceTable=" + mUsimServiceTable);
    pw.println(" mGid1=" + mGid1);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeGid1=" + mFakeGid1);
    }
    pw.println(" mGid2=" + mGid2);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakeGid2=" + mFakeGid2);
    }
    pw.println(" mPnnHomeName=" + mPnnHomeName);
    if (mCarrierTestOverride.isInTestMode()) {
        pw.println(" mFakePnnHomeName=" + mFakePnnHomeName);
    }
    pw.println(" mPlmnActRecords[]=" + Arrays.toString(mPlmnActRecords));
    pw.println(" mOplmnActRecords[]=" + Arrays.toString(mOplmnActRecords));
    pw.println(" mHplmnActRecords[]=" + Arrays.toString(mHplmnActRecords));
    pw.println(" mFplmns[]=" + Arrays.toString(mFplmns));
    pw.println(" mEhplmns[]=" + Arrays.toString(mEhplmns));
    pw.flush();
}
#end_block

#method_before
protected void resetRecords() {
    mMncLength = UNINITIALIZED;
    log("setting0 mMncLength" + mMncLength);
    mIccId = null;
    mFullIccId = null;
    mAdnCache.reset();
    // Don't clean up PROPERTY_ICC_OPERATOR_ISO_COUNTRY and
    // PROPERTY_ICC_OPERATOR_NUMERIC here. Since not all CDMA
    // devices have RUIM, these properties should keep the original
    // values, e.g. build time settings, when there is no RUIM but
    // set new values when RUIM is available and loaded.
    // recordsRequested is set to false indicating that the SIM
    // read requests made so far are not valid. This is set to
    // true only when fresh set of read requests are made.
    mRecordsRequested = false;
}
#method_after
protected void resetRecords() {
    mMncLength = UNINITIALIZED;
    log("setting0 mMncLength" + mMncLength);
    mIccId = null;
    mFullIccId = null;
    mAdnCache.reset();
    // Don't clean up PROPERTY_ICC_OPERATOR_ISO_COUNTRY and
    // PROPERTY_ICC_OPERATOR_NUMERIC here. Since not all CDMA
    // devices have RUIM, these properties should keep the original
    // values, e.g. build time settings, when there is no RUIM but
    // set new values when RUIM is available and loaded.
    // recordsRequested is set to false indicating that the SIM
    // read requests made so far are not valid. This is set to
    // true only when fresh set of read requests are made.
    mRecordsRequested = false;
    mLockedRecordsRequested = false;
}
#end_block

#method_before
public String getRUIMOperatorNumeric() {
    if (mImsi == null) {
        return null;
    }
    if (mMncLength != UNINITIALIZED && mMncLength != UNKNOWN) {
        // length of mcc = 3 (3GPP2 C.S0005 - Section 2.3)
        return mImsi.substring(0, 3 + mMncLength);
    }
    // Guess the MNC length based on the MCC if we don't
    // have a valid value in ef[ad]
    int mcc = Integer.parseInt(mImsi.substring(0, 3));
    return mImsi.substring(0, 3 + MccTable.smallestDigitsMccForMnc(mcc));
}
#method_after
public String getRUIMOperatorNumeric() {
    String imsi = getIMSI();
    if (imsi == null) {
        return null;
    }
    if (mMncLength != UNINITIALIZED && mMncLength != UNKNOWN) {
        // length of mcc = 3 (3GPP2 C.S0005 - Section 2.3)
        return imsi.substring(0, 3 + mMncLength);
    }
    // Guess the MNC length based on the MCC if we don't
    // have a valid value in ef[ad]
    int mcc = Integer.parseInt(imsi.substring(0, 3));
    return imsi.substring(0, 3 + MccTable.smallestDigitsMccForMnc(mcc));
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_GET_DEVICE_IDENTITY_DONE:
                log("Event EVENT_GET_DEVICE_IDENTITY_DONE Received");
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                // FIXME: CSIM IMSI may not contain the MNC.
                if (false) {
                    log("IMSI: " + mImsi.substring(0, 6) + "xxxxxxxxx");
                    String operatorNumeric = getRUIMOperatorNumeric();
                    if (operatorNumeric != null) {
                        if (operatorNumeric.length() <= 6) {
                            log("update mccmnc=" + operatorNumeric);
                            MccTable.updateMccMncConfiguration(mContext, operatorNumeric, false);
                        }
                    }
                } else {
                    String operatorNumeric = getRUIMOperatorNumeric();
                    log("NO update mccmnc=" + operatorNumeric);
                }
                break;
            case EVENT_GET_CDMA_SUBSCRIPTION_DONE:
                ar = (AsyncResult) msg.obj;
                String[] localTemp = (String[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mMyMobileNumber = localTemp[0];
                mMin2Min1 = localTemp[3];
                mPrlVersion = localTemp[4];
                log("MDN: " + mMyMobileNumber + " MIN: " + mMin2Min1);
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                mFullIccId = IccUtils.bchToString(data, 0, data.length);
                log("iccid: " + SubscriptionInfo.givePrintableIccid(mFullIccId));
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    Rlog.i(LOG_TAG, "RuimRecords update failed", ar.exception);
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
            case EVENT_MARK_SMS_READ_DONE:
            case EVENT_SMS_ON_RUIM:
            case EVENT_GET_SMS_DONE:
                Rlog.w(LOG_TAG, "Event not supported: " + msg.what);
                break;
            // TODO: probably EF_CST should be read instead
            case EVENT_GET_SST_DONE:
                log("Event EVENT_GET_SST_DONE Received");
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        Rlog.w(LOG_TAG, "Exception parsing RUIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    byte[] data;
    boolean isRecordLoadResponse = false;
    if (mDestroyed.get()) {
        loge("Received message " + msg + "[" + msg.what + "] while being destroyed. Ignoring.");
        return;
    }
    try {
        switch(msg.what) {
            case EVENT_APP_READY:
                onReady();
                break;
            case EVENT_APP_LOCKED:
                onLocked();
                break;
            case EVENT_GET_DEVICE_IDENTITY_DONE:
                log("Event EVENT_GET_DEVICE_IDENTITY_DONE Received");
                break;
            /* IO events */
            case EVENT_GET_IMSI_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    loge("Exception querying IMSI, Exception:" + ar.exception);
                    break;
                }
                mImsi = (String) ar.result;
                // than 15 (and usually 15).
                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
                    loge("invalid IMSI " + mImsi);
                    mImsi = null;
                }
                // FIXME: CSIM IMSI may not contain the MNC.
                if (false) {
                    log("IMSI: " + mImsi.substring(0, 6) + "xxxxxxxxx");
                    String operatorNumeric = getRUIMOperatorNumeric();
                    if (operatorNumeric != null) {
                        if (operatorNumeric.length() <= 6) {
                            log("update mccmnc=" + operatorNumeric);
                            MccTable.updateMccMncConfiguration(mContext, operatorNumeric, false);
                        }
                    }
                } else {
                    String operatorNumeric = getRUIMOperatorNumeric();
                    log("NO update mccmnc=" + operatorNumeric);
                }
                break;
            case EVENT_GET_CDMA_SUBSCRIPTION_DONE:
                ar = (AsyncResult) msg.obj;
                String[] localTemp = (String[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mMyMobileNumber = localTemp[0];
                mMin2Min1 = localTemp[3];
                mPrlVersion = localTemp[4];
                log("MDN: " + mMyMobileNumber + " MIN: " + mMin2Min1);
                break;
            case EVENT_GET_ICCID_DONE:
                isRecordLoadResponse = true;
                ar = (AsyncResult) msg.obj;
                data = (byte[]) ar.result;
                if (ar.exception != null) {
                    break;
                }
                mIccId = IccUtils.bcdToString(data, 0, data.length);
                mFullIccId = IccUtils.bchToString(data, 0, data.length);
                log("iccid: " + SubscriptionInfo.givePrintableIccid(mFullIccId));
                break;
            case EVENT_UPDATE_DONE:
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    Rlog.i(LOG_TAG, "RuimRecords update failed", ar.exception);
                }
                break;
            case EVENT_GET_ALL_SMS_DONE:
            case EVENT_MARK_SMS_READ_DONE:
            case EVENT_SMS_ON_RUIM:
            case EVENT_GET_SMS_DONE:
                Rlog.w(LOG_TAG, "Event not supported: " + msg.what);
                break;
            // TODO: probably EF_CST should be read instead
            case EVENT_GET_SST_DONE:
                log("Event EVENT_GET_SST_DONE Received");
                break;
            default:
                // IccRecords handles generic record load responses
                super.handleMessage(msg);
        }
    } catch (RuntimeException exc) {
        // I don't want these exceptions to be fatal
        Rlog.w(LOG_TAG, "Exception parsing RUIM record", exc);
    } finally {
        // Count up record load responses even if they are fails
        if (isRecordLoadResponse) {
            onRecordLoaded();
        }
    }
}
#end_block

#method_before
@Override
protected void onRecordLoaded() {
    // One record loaded successfully or failed, In either case
    // we need to update the recordsToLoad count
    mRecordsToLoad -= 1;
    if (DBG)
        log("onRecordLoaded " + mRecordsToLoad + " requested: " + mRecordsRequested);
    if (mRecordsToLoad == 0 && mRecordsRequested == true) {
        onAllRecordsLoaded();
    } else if (mRecordsToLoad < 0) {
        loge("recordsToLoad <0, programmer error suspected");
        mRecordsToLoad = 0;
    }
}
#method_after
@Override
protected void onRecordLoaded() {
    // One record loaded successfully or failed, In either case
    // we need to update the recordsToLoad count
    mRecordsToLoad -= 1;
    if (DBG)
        log("onRecordLoaded " + mRecordsToLoad + " requested: " + mRecordsRequested);
    if (getRecordsLoaded()) {
        onAllRecordsLoaded();
    } else if (getLockedRecordsLoaded()) {
        onLockedAllRecordsLoaded();
    } else if (mRecordsToLoad < 0) {
        loge("recordsToLoad <0, programmer error suspected");
        mRecordsToLoad = 0;
    }
}
#end_block

#method_before
@Override
protected void onAllRecordsLoaded() {
    if (DBG)
        log("record load complete");
    // FIXME: CSIM IMSI may not contain the MNC.
    if (false) {
        String operator = getRUIMOperatorNumeric();
        if (!TextUtils.isEmpty(operator)) {
            log("onAllRecordsLoaded set 'gsm.sim.operator.numeric' to operator='" + operator + "'");
            log("update icc_operator_numeric=" + operator);
            mTelephonyManager.setSimOperatorNumericForPhone(mParentApp.getPhoneId(), operator);
        } else {
            log("onAllRecordsLoaded empty 'gsm.sim.operator.numeric' skipping");
        }
        if (!TextUtils.isEmpty(mImsi)) {
            log("onAllRecordsLoaded set mcc imsi=" + (VDBG ? ("=" + mImsi) : ""));
            mTelephonyManager.setSimCountryIsoForPhone(mParentApp.getPhoneId(), MccTable.countryCodeForMcc(Integer.parseInt(mImsi.substring(0, 3))));
        } else {
            log("onAllRecordsLoaded empty imsi skipping setting mcc");
        }
    }
    Resources resource = Resources.getSystem();
    if (resource.getBoolean(com.android.internal.R.bool.config_use_sim_language_file)) {
        setSimLanguage(mEFli, mEFpl);
    }
    mRecordsLoadedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
    // TODO: The below is hacky since the SubscriptionController may not be ready at this time.
    if (!TextUtils.isEmpty(mMdn)) {
        int phoneId = mParentApp.getUiccCard().getPhoneId();
        int[] subIds = SubscriptionController.getInstance().getSubId(phoneId);
        if (subIds != null) {
            SubscriptionManager.from(mContext).setDisplayNumber(mMdn, subIds[0]);
        } else {
            log("Cannot call setDisplayNumber: invalid subId");
        }
    }
}
#method_after
@Override
protected void onAllRecordsLoaded() {
    if (DBG)
        log("record load complete");
    // FIXME: CSIM IMSI may not contain the MNC.
    if (false) {
        String operator = getRUIMOperatorNumeric();
        if (!TextUtils.isEmpty(operator)) {
            log("onAllRecordsLoaded set 'gsm.sim.operator.numeric' to operator='" + operator + "'");
            log("update icc_operator_numeric=" + operator);
            mTelephonyManager.setSimOperatorNumericForPhone(mParentApp.getPhoneId(), operator);
        } else {
            log("onAllRecordsLoaded empty 'gsm.sim.operator.numeric' skipping");
        }
        String imsi = getIMSI();
        if (!TextUtils.isEmpty(imsi)) {
            log("onAllRecordsLoaded set mcc imsi=" + (VDBG ? ("=" + imsi) : ""));
            mTelephonyManager.setSimCountryIsoForPhone(mParentApp.getPhoneId(), MccTable.countryCodeForMcc(Integer.parseInt(imsi.substring(0, 3))));
        } else {
            log("onAllRecordsLoaded empty imsi skipping setting mcc");
        }
    }
    Resources resource = Resources.getSystem();
    if (resource.getBoolean(com.android.internal.R.bool.config_use_sim_language_file)) {
        setSimLanguage(mEFli, mEFpl);
    }
    mRecordsLoadedRegistrants.notifyRegistrants(new AsyncResult(null, null, null));
    // TODO: The below is hacky since the SubscriptionController may not be ready at this time.
    if (!TextUtils.isEmpty(mMdn)) {
        int phoneId = mParentApp.getUiccCard().getPhoneId();
        int subId = SubscriptionController.getInstance().getSubIdUsingPhoneId(phoneId);
        if (SubscriptionManager.isValidSubscriptionId(subId)) {
            SubscriptionManager.from(mContext).setDisplayNumber(mMdn, subId);
        } else {
            log("Cannot call setDisplayNumber: invalid subId");
        }
    }
}
#end_block

#method_before
@Override
public int getDisplayRule(String plmn) {
    // TODO together with spn
    return 0;
}
#method_after
@Override
public int getDisplayRule(ServiceState serviceState) {
    // TODO together with spn
    return 0;
}
#end_block

#method_before
public static Pair<String, Long> getPrimaryStoragePathAndSize() {
    return Pair.create(null, FileUtils.roundStorageSize(Environment.getDataDirectory().getTotalSpace()));
}
#method_after
public static Pair<String, Long> getPrimaryStoragePathAndSize() {
    return Pair.create(null, FileUtils.roundStorageSize(Environment.getDataDirectory().getTotalSpace() + Environment.getRootDirectory().getTotalSpace()));
}
#end_block

#method_before
@Override
public void setLogicalToPhysicalSlotMapping(int[] physicalSlots, Message result) {
}
#method_after
@Override
public void setLogicalToPhysicalSlotMapping(int[] physicalSlots, Message result) {
    unimplemented(result);
}
#end_block

#method_before
@Override
public void setupDataCall(int radioTechnology, DataProfile dataProfile, boolean isRoaming, boolean allowRoaming, Message result) {
    SimulatedCommandsVerifier.getInstance().setupDataCall(radioTechnology, dataProfile, isRoaming, allowRoaming, result);
    if (mDcResponse == null) {
        mDcResponse = new DataCallResponse(0, -1, 1, 2, "IP", "rmnet_data7", "12.34.56.78", "98.76.54.32", "11.22.33.44", "", 1440);
    }
    if (mDcSuccess) {
        resultSuccess(result, mDcResponse);
    } else {
        resultFail(result, mDcResponse, new RuntimeException("Setup data call failed!"));
    }
}
#method_after
@Override
public void setupDataCall(int radioTechnology, DataProfile dataProfile, boolean isRoaming, boolean allowRoaming, Message result) {
    SimulatedCommandsVerifier.getInstance().setupDataCall(radioTechnology, dataProfile, isRoaming, allowRoaming, result);
    if (mDcResponse == null) {
        try {
            mDcResponse = new DataCallResponse(0, -1, 1, 2, "IP", "rmnet_data7", Arrays.asList(new InterfaceAddress("12.34.56.78", 0)), Arrays.asList(NetworkUtils.numericToInetAddress("98.76.54.32")), Arrays.asList(NetworkUtils.numericToInetAddress("11.22.33.44")), null, 1440);
        } catch (Exception e) {
        }
    }
    if (mDcSuccess) {
        resultSuccess(result, mDcResponse);
    } else {
        resultFail(result, mDcResponse, new RuntimeException("Setup data call failed!"));
    }
}
#end_block

#method_before
public void setCardState(int state) {
    switch(state) {
        case 0:
            cardState = CardState.CARDSTATE_ABSENT;
            break;
        case 1:
            cardState = CardState.CARDSTATE_PRESENT;
            break;
        case 2:
            cardState = CardState.CARDSTATE_ERROR;
            break;
        case 3:
            cardState = CardState.CARDSTATE_RESTRICTED;
            break;
        default:
            throw new RuntimeException("Unrecognized RIL_CardState: " + state);
    }
}
#method_after
public void setCardState(int state) {
    switch(state) {
        case 0:
            cardState = IccCardStatus.CardState.CARDSTATE_ABSENT;
            break;
        case 1:
            cardState = IccCardStatus.CardState.CARDSTATE_PRESENT;
            break;
        case 2:
            cardState = IccCardStatus.CardState.CARDSTATE_ERROR;
            break;
        case 3:
            cardState = IccCardStatus.CardState.CARDSTATE_RESTRICTED;
            break;
        default:
            throw new RuntimeException("Unrecognized RIL_CardState: " + state);
    }
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("IccSlotStatus {").append(cardState).append(",").append(slotState).append(",").append("logicalSlotIndex=").append(logicalSlotIndex);
    if (iccid != null) {
        for (String id : iccid) {
            sb.append(id).append(",");
        }
    }
    sb.append("}");
    return sb.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("IccSlotStatus {").append(cardState).append(",").append(slotState).append(",").append("logicalSlotIndex=").append(logicalSlotIndex).append(",").append("atr=").append(atr).append(",iccid=").append(SubscriptionInfo.givePrintableIccid(iccid));
    sb.append("}");
    return sb.toString();
}
#end_block

#method_before
@Override
public void setLogicalToPhysicalSlotMapping(int[] physicalSlots, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        android.hardware.radio.V1_2.IRadio radioProxy12 = android.hardware.radio.V1_2.IRadio.castFrom(radioProxy);
        if (radioProxy12 == null) {
            if (result != null) {
                AsyncResult.forMessage(result, null, CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
                result.sendToTarget();
            }
        } else {
            android.hardware.radio.V1_2.LogicalToPhysicalSlotMapping mapping = new android.hardware.radio.V1_2.LogicalToPhysicalSlotMapping();
            mapping.numSlots = (byte) physicalSlots.length;
            for (int slot : physicalSlots) {
                mapping.pysicalSlots.add((byte) slot);
            }
            RILRequest rr = obtainRequest(RIL_REQUEST_SET_LOGICAL_TO_PHYSICAL_SLOT_MAPPING, result, mRILDefaultWorkSource);
            if (RILJ_LOGD) {
                riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
            }
            try {
                radioProxy12.setLogicalToPhysicalSlotMapping(rr.mSerial, mapping);
            } catch (RemoteException | RuntimeException e) {
                handleRadioProxyExceptionForRR(rr, "setLogicalToPhysicalSlotMapping", e);
            }
        }
    }
}
#method_after
@Override
public void setLogicalToPhysicalSlotMapping(int[] physicalSlots, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        android.hardware.radio.V1_2.IRadio radioProxy12 = android.hardware.radio.V1_2.IRadio.castFrom(radioProxy);
        if (radioProxy12 == null) {
            if (result != null) {
                AsyncResult.forMessage(result, null, CommandException.fromRilErrno(REQUEST_NOT_SUPPORTED));
                result.sendToTarget();
            }
        } else {
            ArrayList<Integer> mapping = new ArrayList<>();
            for (int slot : physicalSlots) {
                mapping.add(new Integer(slot));
            }
            RILRequest rr = obtainRequest(RIL_REQUEST_SET_LOGICAL_TO_PHYSICAL_SLOT_MAPPING, result, mRILDefaultWorkSource);
            if (RILJ_LOGD) {
                riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
            }
            try {
                radioProxy12.setSimSlotsMapping(rr.mSerial, mapping);
            } catch (RemoteException | RuntimeException e) {
                handleRadioProxyExceptionForRR(rr, "setLogicalToPhysicalSlotMapping", e);
            }
        }
    }
}
#end_block

#method_before
private static DataProfileInfo convertToHalDataProfile(DataProfile dp) {
    DataProfileInfo dpi = new DataProfileInfo();
    dpi.profileId = dp.profileId;
    dpi.apn = dp.apn;
    dpi.protocol = dp.protocol;
    dpi.roamingProtocol = dp.roamingProtocol;
    dpi.authType = dp.authType;
    dpi.user = dp.user;
    dpi.password = dp.password;
    dpi.type = dp.type;
    dpi.maxConnsTime = dp.maxConnsTime;
    dpi.maxConns = dp.maxConns;
    dpi.waitTime = dp.waitTime;
    dpi.enabled = dp.enabled;
    dpi.supportedApnTypesBitmap = dp.supportedApnTypesBitmap;
    dpi.bearerBitmap = dp.bearerBitmap;
    dpi.mtu = dp.mtu;
    dpi.mvnoType = convertToHalMvnoType(dp.mvnoType);
    dpi.mvnoMatchData = dp.mvnoMatchData;
    return dpi;
}
#method_after
private static DataProfileInfo convertToHalDataProfile(DataProfile dp) {
    DataProfileInfo dpi = new DataProfileInfo();
    dpi.profileId = dp.getProfileId();
    dpi.apn = dp.getApn();
    dpi.protocol = dp.getProtocol();
    dpi.roamingProtocol = dp.getRoamingProtocol();
    dpi.authType = dp.getAuthType();
    dpi.user = dp.getUserName();
    dpi.password = dp.getPassword();
    dpi.type = dp.getType();
    dpi.maxConnsTime = dp.getMaxConnsTime();
    dpi.maxConns = dp.getMaxConns();
    dpi.waitTime = dp.getWaitTime();
    dpi.enabled = dp.isEnabled();
    dpi.supportedApnTypesBitmap = dp.getSupportedApnTypesBitmap();
    dpi.bearerBitmap = dp.getBearerBitmap();
    dpi.mtu = dp.getMtu();
    dpi.mvnoType = convertToHalMvnoType(dp.getMvnoType());
    dpi.mvnoMatchData = dp.getMvnoMatchData();
    return dpi;
}
#end_block

#method_before
static DataCallResponse convertDataCallResult(SetupDataCallResult dcResult) {
    return new DataCallResponse(dcResult.status, dcResult.suggestedRetryTime, dcResult.cid, dcResult.active, dcResult.type, dcResult.ifname, dcResult.addresses, dcResult.dnses, dcResult.gateways, dcResult.pcscf, dcResult.mtu);
}
#method_after
static DataCallResponse convertDataCallResult(SetupDataCallResult dcResult) {
    // Process address
    String[] addresses = null;
    if (!TextUtils.isEmpty(dcResult.addresses)) {
        addresses = dcResult.addresses.split(" ");
    }
    List<InterfaceAddress> iaList = new ArrayList<>();
    if (addresses != null) {
        for (String address : addresses) {
            address = address.trim();
            if (address.isEmpty())
                continue;
            String[] ap = address.split("/");
            int addrPrefixLen = 0;
            if (ap.length == 2) {
                addrPrefixLen = Integer.parseInt(ap[1]);
            }
            try {
                InterfaceAddress ia = new InterfaceAddress(ap[0], addrPrefixLen);
                iaList.add(ia);
            } catch (UnknownHostException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown host exception: " + e);
            }
        }
    }
    // Process dns
    String[] dnses = null;
    if (!TextUtils.isEmpty(dcResult.dnses)) {
        dnses = dcResult.dnses.split(" ");
    }
    List<InetAddress> dnsList = new ArrayList<>();
    if (dnses != null) {
        for (String dns : dnses) {
            dns = dns.trim();
            InetAddress ia;
            try {
                ia = NetworkUtils.numericToInetAddress(dns);
                dnsList.add(ia);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown dns: " + dns + ", exception = " + e);
            }
        }
    }
    // Process gateway
    String[] gateways = null;
    if (!TextUtils.isEmpty(dcResult.gateways)) {
        gateways = dcResult.gateways.split(" ");
    }
    List<InetAddress> gatewayList = new ArrayList<>();
    if (gateways != null) {
        for (String gateway : gateways) {
            gateway = gateway.trim();
            InetAddress ia;
            try {
                ia = NetworkUtils.numericToInetAddress(gateway);
                gatewayList.add(ia);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown gateway: " + gateway + ", exception = " + e);
            }
        }
    }
    return new DataCallResponse(dcResult.status, dcResult.suggestedRetryTime, dcResult.cid, dcResult.active, dcResult.type, dcResult.ifname, iaList, dnsList, gatewayList, new ArrayList<>(Arrays.asList(dcResult.pcscf.trim().split("\\s*,\\s*"))), dcResult.mtu);
}
#end_block

#method_before
@Override
public void setupDataCall(int radioTechnology, DataProfile dataProfile, boolean isRoaming, boolean allowRoaming, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SETUP_DATA_CALL, result, mRILDefaultWorkSource);
        // Convert to HAL data profile
        DataProfileInfo dpi = convertToHalDataProfile(dataProfile);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ",radioTechnology=" + radioTechnology + ",isRoaming=" + isRoaming + ",allowRoaming=" + allowRoaming + "," + dataProfile);
        }
        try {
            radioProxy.setupDataCall(rr.mSerial, radioTechnology, dpi, dataProfile.modemCognitive, allowRoaming, isRoaming);
            mMetrics.writeRilSetupDataCall(mPhoneId, rr.mSerial, radioTechnology, dpi.profileId, dpi.apn, dpi.authType, dpi.protocol);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setupDataCall", e);
        }
    }
}
#method_after
@Override
public void setupDataCall(int radioTechnology, DataProfile dataProfile, boolean isRoaming, boolean allowRoaming, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SETUP_DATA_CALL, result, mRILDefaultWorkSource);
        // Convert to HAL data profile
        DataProfileInfo dpi = convertToHalDataProfile(dataProfile);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ",radioTechnology=" + radioTechnology + ",isRoaming=" + isRoaming + ",allowRoaming=" + allowRoaming + "," + dataProfile);
        }
        try {
            radioProxy.setupDataCall(rr.mSerial, radioTechnology, dpi, dataProfile.isModemCognitive(), allowRoaming, isRoaming);
            mMetrics.writeRilSetupDataCall(mPhoneId, rr.mSerial, radioTechnology, dpi.profileId, dpi.apn, dpi.authType, dpi.protocol);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setupDataCall", e);
        }
    }
}
#end_block

#method_before
@Override
public void setInitialAttachApn(DataProfile dataProfile, boolean isRoaming, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_INITIAL_ATTACH_APN, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + dataProfile);
        }
        try {
            radioProxy.setInitialAttachApn(rr.mSerial, convertToHalDataProfile(dataProfile), dataProfile.modemCognitive, isRoaming);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setInitialAttachApn", e);
        }
    }
}
#method_after
@Override
public void setInitialAttachApn(DataProfile dataProfile, boolean isRoaming, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_INITIAL_ATTACH_APN, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + dataProfile);
        }
        try {
            radioProxy.setInitialAttachApn(rr.mSerial, convertToHalDataProfile(dataProfile), dataProfile.isModemCognitive(), isRoaming);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setInitialAttachApn", e);
        }
    }
}
#end_block

#method_before
static String requestToString(int request) {
    switch(request) {
        case RIL_REQUEST_GET_SIM_STATUS:
            return "GET_SIM_STATUS";
        case RIL_REQUEST_ENTER_SIM_PIN:
            return "ENTER_SIM_PIN";
        case RIL_REQUEST_ENTER_SIM_PUK:
            return "ENTER_SIM_PUK";
        case RIL_REQUEST_ENTER_SIM_PIN2:
            return "ENTER_SIM_PIN2";
        case RIL_REQUEST_ENTER_SIM_PUK2:
            return "ENTER_SIM_PUK2";
        case RIL_REQUEST_CHANGE_SIM_PIN:
            return "CHANGE_SIM_PIN";
        case RIL_REQUEST_CHANGE_SIM_PIN2:
            return "CHANGE_SIM_PIN2";
        case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION:
            return "ENTER_NETWORK_DEPERSONALIZATION";
        case RIL_REQUEST_GET_CURRENT_CALLS:
            return "GET_CURRENT_CALLS";
        case RIL_REQUEST_DIAL:
            return "DIAL";
        case RIL_REQUEST_GET_IMSI:
            return "GET_IMSI";
        case RIL_REQUEST_HANGUP:
            return "HANGUP";
        case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND:
            return "HANGUP_WAITING_OR_BACKGROUND";
        case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
            return "HANGUP_FOREGROUND_RESUME_BACKGROUND";
        case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
            return "REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE";
        case RIL_REQUEST_CONFERENCE:
            return "CONFERENCE";
        case RIL_REQUEST_UDUB:
            return "UDUB";
        case RIL_REQUEST_LAST_CALL_FAIL_CAUSE:
            return "LAST_CALL_FAIL_CAUSE";
        case RIL_REQUEST_SIGNAL_STRENGTH:
            return "SIGNAL_STRENGTH";
        case RIL_REQUEST_VOICE_REGISTRATION_STATE:
            return "VOICE_REGISTRATION_STATE";
        case RIL_REQUEST_DATA_REGISTRATION_STATE:
            return "DATA_REGISTRATION_STATE";
        case RIL_REQUEST_OPERATOR:
            return "OPERATOR";
        case RIL_REQUEST_RADIO_POWER:
            return "RADIO_POWER";
        case RIL_REQUEST_DTMF:
            return "DTMF";
        case RIL_REQUEST_SEND_SMS:
            return "SEND_SMS";
        case RIL_REQUEST_SEND_SMS_EXPECT_MORE:
            return "SEND_SMS_EXPECT_MORE";
        case RIL_REQUEST_SETUP_DATA_CALL:
            return "SETUP_DATA_CALL";
        case RIL_REQUEST_SIM_IO:
            return "SIM_IO";
        case RIL_REQUEST_SEND_USSD:
            return "SEND_USSD";
        case RIL_REQUEST_CANCEL_USSD:
            return "CANCEL_USSD";
        case RIL_REQUEST_GET_CLIR:
            return "GET_CLIR";
        case RIL_REQUEST_SET_CLIR:
            return "SET_CLIR";
        case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS:
            return "QUERY_CALL_FORWARD_STATUS";
        case RIL_REQUEST_SET_CALL_FORWARD:
            return "SET_CALL_FORWARD";
        case RIL_REQUEST_QUERY_CALL_WAITING:
            return "QUERY_CALL_WAITING";
        case RIL_REQUEST_SET_CALL_WAITING:
            return "SET_CALL_WAITING";
        case RIL_REQUEST_SMS_ACKNOWLEDGE:
            return "SMS_ACKNOWLEDGE";
        case RIL_REQUEST_GET_IMEI:
            return "GET_IMEI";
        case RIL_REQUEST_GET_IMEISV:
            return "GET_IMEISV";
        case RIL_REQUEST_ANSWER:
            return "ANSWER";
        case RIL_REQUEST_DEACTIVATE_DATA_CALL:
            return "DEACTIVATE_DATA_CALL";
        case RIL_REQUEST_QUERY_FACILITY_LOCK:
            return "QUERY_FACILITY_LOCK";
        case RIL_REQUEST_SET_FACILITY_LOCK:
            return "SET_FACILITY_LOCK";
        case RIL_REQUEST_CHANGE_BARRING_PASSWORD:
            return "CHANGE_BARRING_PASSWORD";
        case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE:
            return "QUERY_NETWORK_SELECTION_MODE";
        case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
            return "SET_NETWORK_SELECTION_AUTOMATIC";
        case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL:
            return "SET_NETWORK_SELECTION_MANUAL";
        case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS:
            return "QUERY_AVAILABLE_NETWORKS ";
        case RIL_REQUEST_DTMF_START:
            return "DTMF_START";
        case RIL_REQUEST_DTMF_STOP:
            return "DTMF_STOP";
        case RIL_REQUEST_BASEBAND_VERSION:
            return "BASEBAND_VERSION";
        case RIL_REQUEST_SEPARATE_CONNECTION:
            return "SEPARATE_CONNECTION";
        case RIL_REQUEST_SET_MUTE:
            return "SET_MUTE";
        case RIL_REQUEST_GET_MUTE:
            return "GET_MUTE";
        case RIL_REQUEST_QUERY_CLIP:
            return "QUERY_CLIP";
        case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE:
            return "LAST_DATA_CALL_FAIL_CAUSE";
        case RIL_REQUEST_DATA_CALL_LIST:
            return "DATA_CALL_LIST";
        case RIL_REQUEST_RESET_RADIO:
            return "RESET_RADIO";
        case RIL_REQUEST_SCREEN_STATE:
            return "SCREEN_STATE";
        case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION:
            return "SET_SUPP_SVC_NOTIFICATION";
        case RIL_REQUEST_WRITE_SMS_TO_SIM:
            return "WRITE_SMS_TO_SIM";
        case RIL_REQUEST_DELETE_SMS_ON_SIM:
            return "DELETE_SMS_ON_SIM";
        case RIL_REQUEST_SET_BAND_MODE:
            return "SET_BAND_MODE";
        case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE:
            return "QUERY_AVAILABLE_BAND_MODE";
        case RIL_REQUEST_STK_GET_PROFILE:
            return "REQUEST_STK_GET_PROFILE";
        case RIL_REQUEST_STK_SET_PROFILE:
            return "REQUEST_STK_SET_PROFILE";
        case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND:
            return "REQUEST_STK_SEND_ENVELOPE_COMMAND";
        case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE:
            return "REQUEST_STK_SEND_TERMINAL_RESPONSE";
        case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM:
            return "REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM";
        case RIL_REQUEST_EXPLICIT_CALL_TRANSFER:
            return "REQUEST_EXPLICIT_CALL_TRANSFER";
        case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
            return "REQUEST_SET_PREFERRED_NETWORK_TYPE";
        case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE:
            return "REQUEST_GET_PREFERRED_NETWORK_TYPE";
        case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS:
            return "REQUEST_GET_NEIGHBORING_CELL_IDS";
        case RIL_REQUEST_SET_LOCATION_UPDATES:
            return "REQUEST_SET_LOCATION_UPDATES";
        case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE:
            return "RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE";
        case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:
            return "RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE";
        case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:
            return "RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE";
        case RIL_REQUEST_SET_TTY_MODE:
            return "RIL_REQUEST_SET_TTY_MODE";
        case RIL_REQUEST_QUERY_TTY_MODE:
            return "RIL_REQUEST_QUERY_TTY_MODE";
        case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE:
            return "RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE";
        case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE:
            return "RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE";
        case RIL_REQUEST_CDMA_FLASH:
            return "RIL_REQUEST_CDMA_FLASH";
        case RIL_REQUEST_CDMA_BURST_DTMF:
            return "RIL_REQUEST_CDMA_BURST_DTMF";
        case RIL_REQUEST_CDMA_SEND_SMS:
            return "RIL_REQUEST_CDMA_SEND_SMS";
        case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE:
            return "RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE";
        case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG:
            return "RIL_REQUEST_GSM_GET_BROADCAST_CONFIG";
        case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG:
            return "RIL_REQUEST_GSM_SET_BROADCAST_CONFIG";
        case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG:
            return "RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG";
        case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG:
            return "RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG";
        case RIL_REQUEST_GSM_BROADCAST_ACTIVATION:
            return "RIL_REQUEST_GSM_BROADCAST_ACTIVATION";
        case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY:
            return "RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY";
        case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION:
            return "RIL_REQUEST_CDMA_BROADCAST_ACTIVATION";
        case RIL_REQUEST_CDMA_SUBSCRIPTION:
            return "RIL_REQUEST_CDMA_SUBSCRIPTION";
        case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM:
            return "RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM";
        case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM:
            return "RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM";
        case RIL_REQUEST_DEVICE_IDENTITY:
            return "RIL_REQUEST_DEVICE_IDENTITY";
        case RIL_REQUEST_GET_SMSC_ADDRESS:
            return "RIL_REQUEST_GET_SMSC_ADDRESS";
        case RIL_REQUEST_SET_SMSC_ADDRESS:
            return "RIL_REQUEST_SET_SMSC_ADDRESS";
        case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE:
            return "REQUEST_EXIT_EMERGENCY_CALLBACK_MODE";
        case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS:
            return "RIL_REQUEST_REPORT_SMS_MEMORY_STATUS";
        case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING:
            return "RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING";
        case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE:
            return "RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE";
        case RIL_REQUEST_ISIM_AUTHENTICATION:
            return "RIL_REQUEST_ISIM_AUTHENTICATION";
        case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU:
            return "RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU";
        case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS:
            return "RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS";
        case RIL_REQUEST_VOICE_RADIO_TECH:
            return "RIL_REQUEST_VOICE_RADIO_TECH";
        case RIL_REQUEST_GET_CELL_INFO_LIST:
            return "RIL_REQUEST_GET_CELL_INFO_LIST";
        case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE:
            return "RIL_REQUEST_SET_CELL_INFO_LIST_RATE";
        case RIL_REQUEST_SET_INITIAL_ATTACH_APN:
            return "RIL_REQUEST_SET_INITIAL_ATTACH_APN";
        case RIL_REQUEST_SET_DATA_PROFILE:
            return "RIL_REQUEST_SET_DATA_PROFILE";
        case RIL_REQUEST_IMS_REGISTRATION_STATE:
            return "RIL_REQUEST_IMS_REGISTRATION_STATE";
        case RIL_REQUEST_IMS_SEND_SMS:
            return "RIL_REQUEST_IMS_SEND_SMS";
        case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC:
            return "RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC";
        case RIL_REQUEST_SIM_OPEN_CHANNEL:
            return "RIL_REQUEST_SIM_OPEN_CHANNEL";
        case RIL_REQUEST_SIM_CLOSE_CHANNEL:
            return "RIL_REQUEST_SIM_CLOSE_CHANNEL";
        case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
            return "RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL";
        case RIL_REQUEST_NV_READ_ITEM:
            return "RIL_REQUEST_NV_READ_ITEM";
        case RIL_REQUEST_NV_WRITE_ITEM:
            return "RIL_REQUEST_NV_WRITE_ITEM";
        case RIL_REQUEST_NV_WRITE_CDMA_PRL:
            return "RIL_REQUEST_NV_WRITE_CDMA_PRL";
        case RIL_REQUEST_NV_RESET_CONFIG:
            return "RIL_REQUEST_NV_RESET_CONFIG";
        case RIL_REQUEST_SET_UICC_SUBSCRIPTION:
            return "RIL_REQUEST_SET_UICC_SUBSCRIPTION";
        case RIL_REQUEST_ALLOW_DATA:
            return "RIL_REQUEST_ALLOW_DATA";
        case RIL_REQUEST_GET_HARDWARE_CONFIG:
            return "GET_HARDWARE_CONFIG";
        case RIL_REQUEST_SIM_AUTHENTICATION:
            return "RIL_REQUEST_SIM_AUTHENTICATION";
        case RIL_REQUEST_SHUTDOWN:
            return "RIL_REQUEST_SHUTDOWN";
        case RIL_REQUEST_SET_RADIO_CAPABILITY:
            return "RIL_REQUEST_SET_RADIO_CAPABILITY";
        case RIL_REQUEST_GET_RADIO_CAPABILITY:
            return "RIL_REQUEST_GET_RADIO_CAPABILITY";
        case RIL_REQUEST_START_LCE:
            return "RIL_REQUEST_START_LCE";
        case RIL_REQUEST_STOP_LCE:
            return "RIL_REQUEST_STOP_LCE";
        case RIL_REQUEST_PULL_LCEDATA:
            return "RIL_REQUEST_PULL_LCEDATA";
        case RIL_REQUEST_GET_ACTIVITY_INFO:
            return "RIL_REQUEST_GET_ACTIVITY_INFO";
        case RIL_REQUEST_SET_ALLOWED_CARRIERS:
            return "RIL_REQUEST_SET_ALLOWED_CARRIERS";
        case RIL_REQUEST_GET_ALLOWED_CARRIERS:
            return "RIL_REQUEST_GET_ALLOWED_CARRIERS";
        case RIL_REQUEST_SET_SIM_CARD_POWER:
            return "RIL_REQUEST_SET_SIM_CARD_POWER";
        case RIL_REQUEST_SEND_DEVICE_STATE:
            return "RIL_REQUEST_SEND_DEVICE_STATE";
        case RIL_REQUEST_SET_UNSOLICITED_RESPONSE_FILTER:
            return "RIL_REQUEST_SET_UNSOLICITED_RESPONSE_FILTER";
        case RIL_RESPONSE_ACKNOWLEDGEMENT:
            return "RIL_RESPONSE_ACKNOWLEDGEMENT";
        case RIL_REQUEST_SET_CARRIER_INFO_IMSI_ENCRYPTION:
            return "RIL_REQUEST_SET_CARRIER_INFO_IMSI_ENCRYPTION";
        case RIL_REQUEST_START_NETWORK_SCAN:
            return "RIL_REQUEST_START_NETWORK_SCAN";
        case RIL_REQUEST_STOP_NETWORK_SCAN:
            return "RIL_REQUEST_STOP_NETWORK_SCAN";
        case RIL_REQUEST_GET_SLOT_STATUS:
            return "GET_SLOT_STATUS";
        case RIL_REQUEST_SET_LOGICAL_TO_PHYSICAL_SLOT_MAPPING:
            return "SET_LOGICAL_TO_PHYSICAL_SLOT_MAPPING";
        default:
            return "<unknown request>";
    }
}
#method_after
static String requestToString(int request) {
    switch(request) {
        case RIL_REQUEST_GET_SIM_STATUS:
            return "GET_SIM_STATUS";
        case RIL_REQUEST_ENTER_SIM_PIN:
            return "ENTER_SIM_PIN";
        case RIL_REQUEST_ENTER_SIM_PUK:
            return "ENTER_SIM_PUK";
        case RIL_REQUEST_ENTER_SIM_PIN2:
            return "ENTER_SIM_PIN2";
        case RIL_REQUEST_ENTER_SIM_PUK2:
            return "ENTER_SIM_PUK2";
        case RIL_REQUEST_CHANGE_SIM_PIN:
            return "CHANGE_SIM_PIN";
        case RIL_REQUEST_CHANGE_SIM_PIN2:
            return "CHANGE_SIM_PIN2";
        case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION:
            return "ENTER_NETWORK_DEPERSONALIZATION";
        case RIL_REQUEST_GET_CURRENT_CALLS:
            return "GET_CURRENT_CALLS";
        case RIL_REQUEST_DIAL:
            return "DIAL";
        case RIL_REQUEST_GET_IMSI:
            return "GET_IMSI";
        case RIL_REQUEST_HANGUP:
            return "HANGUP";
        case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND:
            return "HANGUP_WAITING_OR_BACKGROUND";
        case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
            return "HANGUP_FOREGROUND_RESUME_BACKGROUND";
        case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
            return "REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE";
        case RIL_REQUEST_CONFERENCE:
            return "CONFERENCE";
        case RIL_REQUEST_UDUB:
            return "UDUB";
        case RIL_REQUEST_LAST_CALL_FAIL_CAUSE:
            return "LAST_CALL_FAIL_CAUSE";
        case RIL_REQUEST_SIGNAL_STRENGTH:
            return "SIGNAL_STRENGTH";
        case RIL_REQUEST_VOICE_REGISTRATION_STATE:
            return "VOICE_REGISTRATION_STATE";
        case RIL_REQUEST_DATA_REGISTRATION_STATE:
            return "DATA_REGISTRATION_STATE";
        case RIL_REQUEST_OPERATOR:
            return "OPERATOR";
        case RIL_REQUEST_RADIO_POWER:
            return "RADIO_POWER";
        case RIL_REQUEST_DTMF:
            return "DTMF";
        case RIL_REQUEST_SEND_SMS:
            return "SEND_SMS";
        case RIL_REQUEST_SEND_SMS_EXPECT_MORE:
            return "SEND_SMS_EXPECT_MORE";
        case RIL_REQUEST_SETUP_DATA_CALL:
            return "SETUP_DATA_CALL";
        case RIL_REQUEST_SIM_IO:
            return "SIM_IO";
        case RIL_REQUEST_SEND_USSD:
            return "SEND_USSD";
        case RIL_REQUEST_CANCEL_USSD:
            return "CANCEL_USSD";
        case RIL_REQUEST_GET_CLIR:
            return "GET_CLIR";
        case RIL_REQUEST_SET_CLIR:
            return "SET_CLIR";
        case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS:
            return "QUERY_CALL_FORWARD_STATUS";
        case RIL_REQUEST_SET_CALL_FORWARD:
            return "SET_CALL_FORWARD";
        case RIL_REQUEST_QUERY_CALL_WAITING:
            return "QUERY_CALL_WAITING";
        case RIL_REQUEST_SET_CALL_WAITING:
            return "SET_CALL_WAITING";
        case RIL_REQUEST_SMS_ACKNOWLEDGE:
            return "SMS_ACKNOWLEDGE";
        case RIL_REQUEST_GET_IMEI:
            return "GET_IMEI";
        case RIL_REQUEST_GET_IMEISV:
            return "GET_IMEISV";
        case RIL_REQUEST_ANSWER:
            return "ANSWER";
        case RIL_REQUEST_DEACTIVATE_DATA_CALL:
            return "DEACTIVATE_DATA_CALL";
        case RIL_REQUEST_QUERY_FACILITY_LOCK:
            return "QUERY_FACILITY_LOCK";
        case RIL_REQUEST_SET_FACILITY_LOCK:
            return "SET_FACILITY_LOCK";
        case RIL_REQUEST_CHANGE_BARRING_PASSWORD:
            return "CHANGE_BARRING_PASSWORD";
        case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE:
            return "QUERY_NETWORK_SELECTION_MODE";
        case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
            return "SET_NETWORK_SELECTION_AUTOMATIC";
        case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL:
            return "SET_NETWORK_SELECTION_MANUAL";
        case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS:
            return "QUERY_AVAILABLE_NETWORKS ";
        case RIL_REQUEST_DTMF_START:
            return "DTMF_START";
        case RIL_REQUEST_DTMF_STOP:
            return "DTMF_STOP";
        case RIL_REQUEST_BASEBAND_VERSION:
            return "BASEBAND_VERSION";
        case RIL_REQUEST_SEPARATE_CONNECTION:
            return "SEPARATE_CONNECTION";
        case RIL_REQUEST_SET_MUTE:
            return "SET_MUTE";
        case RIL_REQUEST_GET_MUTE:
            return "GET_MUTE";
        case RIL_REQUEST_QUERY_CLIP:
            return "QUERY_CLIP";
        case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE:
            return "LAST_DATA_CALL_FAIL_CAUSE";
        case RIL_REQUEST_DATA_CALL_LIST:
            return "DATA_CALL_LIST";
        case RIL_REQUEST_RESET_RADIO:
            return "RESET_RADIO";
        case RIL_REQUEST_SCREEN_STATE:
            return "SCREEN_STATE";
        case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION:
            return "SET_SUPP_SVC_NOTIFICATION";
        case RIL_REQUEST_WRITE_SMS_TO_SIM:
            return "WRITE_SMS_TO_SIM";
        case RIL_REQUEST_DELETE_SMS_ON_SIM:
            return "DELETE_SMS_ON_SIM";
        case RIL_REQUEST_SET_BAND_MODE:
            return "SET_BAND_MODE";
        case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE:
            return "QUERY_AVAILABLE_BAND_MODE";
        case RIL_REQUEST_STK_GET_PROFILE:
            return "REQUEST_STK_GET_PROFILE";
        case RIL_REQUEST_STK_SET_PROFILE:
            return "REQUEST_STK_SET_PROFILE";
        case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND:
            return "REQUEST_STK_SEND_ENVELOPE_COMMAND";
        case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE:
            return "REQUEST_STK_SEND_TERMINAL_RESPONSE";
        case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM:
            return "REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM";
        case RIL_REQUEST_EXPLICIT_CALL_TRANSFER:
            return "REQUEST_EXPLICIT_CALL_TRANSFER";
        case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
            return "REQUEST_SET_PREFERRED_NETWORK_TYPE";
        case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE:
            return "REQUEST_GET_PREFERRED_NETWORK_TYPE";
        case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS:
            return "REQUEST_GET_NEIGHBORING_CELL_IDS";
        case RIL_REQUEST_SET_LOCATION_UPDATES:
            return "REQUEST_SET_LOCATION_UPDATES";
        case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE:
            return "RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE";
        case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:
            return "RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE";
        case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:
            return "RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE";
        case RIL_REQUEST_SET_TTY_MODE:
            return "RIL_REQUEST_SET_TTY_MODE";
        case RIL_REQUEST_QUERY_TTY_MODE:
            return "RIL_REQUEST_QUERY_TTY_MODE";
        case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE:
            return "RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE";
        case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE:
            return "RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE";
        case RIL_REQUEST_CDMA_FLASH:
            return "RIL_REQUEST_CDMA_FLASH";
        case RIL_REQUEST_CDMA_BURST_DTMF:
            return "RIL_REQUEST_CDMA_BURST_DTMF";
        case RIL_REQUEST_CDMA_SEND_SMS:
            return "RIL_REQUEST_CDMA_SEND_SMS";
        case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE:
            return "RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE";
        case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG:
            return "RIL_REQUEST_GSM_GET_BROADCAST_CONFIG";
        case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG:
            return "RIL_REQUEST_GSM_SET_BROADCAST_CONFIG";
        case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG:
            return "RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG";
        case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG:
            return "RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG";
        case RIL_REQUEST_GSM_BROADCAST_ACTIVATION:
            return "RIL_REQUEST_GSM_BROADCAST_ACTIVATION";
        case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY:
            return "RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY";
        case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION:
            return "RIL_REQUEST_CDMA_BROADCAST_ACTIVATION";
        case RIL_REQUEST_CDMA_SUBSCRIPTION:
            return "RIL_REQUEST_CDMA_SUBSCRIPTION";
        case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM:
            return "RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM";
        case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM:
            return "RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM";
        case RIL_REQUEST_DEVICE_IDENTITY:
            return "RIL_REQUEST_DEVICE_IDENTITY";
        case RIL_REQUEST_GET_SMSC_ADDRESS:
            return "RIL_REQUEST_GET_SMSC_ADDRESS";
        case RIL_REQUEST_SET_SMSC_ADDRESS:
            return "RIL_REQUEST_SET_SMSC_ADDRESS";
        case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE:
            return "REQUEST_EXIT_EMERGENCY_CALLBACK_MODE";
        case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS:
            return "RIL_REQUEST_REPORT_SMS_MEMORY_STATUS";
        case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING:
            return "RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING";
        case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE:
            return "RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE";
        case RIL_REQUEST_ISIM_AUTHENTICATION:
            return "RIL_REQUEST_ISIM_AUTHENTICATION";
        case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU:
            return "RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU";
        case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS:
            return "RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS";
        case RIL_REQUEST_VOICE_RADIO_TECH:
            return "RIL_REQUEST_VOICE_RADIO_TECH";
        case RIL_REQUEST_GET_CELL_INFO_LIST:
            return "RIL_REQUEST_GET_CELL_INFO_LIST";
        case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE:
            return "RIL_REQUEST_SET_CELL_INFO_LIST_RATE";
        case RIL_REQUEST_SET_INITIAL_ATTACH_APN:
            return "RIL_REQUEST_SET_INITIAL_ATTACH_APN";
        case RIL_REQUEST_SET_DATA_PROFILE:
            return "RIL_REQUEST_SET_DATA_PROFILE";
        case RIL_REQUEST_IMS_REGISTRATION_STATE:
            return "RIL_REQUEST_IMS_REGISTRATION_STATE";
        case RIL_REQUEST_IMS_SEND_SMS:
            return "RIL_REQUEST_IMS_SEND_SMS";
        case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC:
            return "RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC";
        case RIL_REQUEST_SIM_OPEN_CHANNEL:
            return "RIL_REQUEST_SIM_OPEN_CHANNEL";
        case RIL_REQUEST_SIM_CLOSE_CHANNEL:
            return "RIL_REQUEST_SIM_CLOSE_CHANNEL";
        case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
            return "RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL";
        case RIL_REQUEST_NV_READ_ITEM:
            return "RIL_REQUEST_NV_READ_ITEM";
        case RIL_REQUEST_NV_WRITE_ITEM:
            return "RIL_REQUEST_NV_WRITE_ITEM";
        case RIL_REQUEST_NV_WRITE_CDMA_PRL:
            return "RIL_REQUEST_NV_WRITE_CDMA_PRL";
        case RIL_REQUEST_NV_RESET_CONFIG:
            return "RIL_REQUEST_NV_RESET_CONFIG";
        case RIL_REQUEST_SET_UICC_SUBSCRIPTION:
            return "RIL_REQUEST_SET_UICC_SUBSCRIPTION";
        case RIL_REQUEST_ALLOW_DATA:
            return "RIL_REQUEST_ALLOW_DATA";
        case RIL_REQUEST_GET_HARDWARE_CONFIG:
            return "GET_HARDWARE_CONFIG";
        case RIL_REQUEST_SIM_AUTHENTICATION:
            return "RIL_REQUEST_SIM_AUTHENTICATION";
        case RIL_REQUEST_SHUTDOWN:
            return "RIL_REQUEST_SHUTDOWN";
        case RIL_REQUEST_SET_RADIO_CAPABILITY:
            return "RIL_REQUEST_SET_RADIO_CAPABILITY";
        case RIL_REQUEST_GET_RADIO_CAPABILITY:
            return "RIL_REQUEST_GET_RADIO_CAPABILITY";
        case RIL_REQUEST_START_LCE:
            return "RIL_REQUEST_START_LCE";
        case RIL_REQUEST_STOP_LCE:
            return "RIL_REQUEST_STOP_LCE";
        case RIL_REQUEST_PULL_LCEDATA:
            return "RIL_REQUEST_PULL_LCEDATA";
        case RIL_REQUEST_GET_ACTIVITY_INFO:
            return "RIL_REQUEST_GET_ACTIVITY_INFO";
        case RIL_REQUEST_SET_ALLOWED_CARRIERS:
            return "RIL_REQUEST_SET_ALLOWED_CARRIERS";
        case RIL_REQUEST_GET_ALLOWED_CARRIERS:
            return "RIL_REQUEST_GET_ALLOWED_CARRIERS";
        case RIL_REQUEST_SET_SIM_CARD_POWER:
            return "RIL_REQUEST_SET_SIM_CARD_POWER";
        case RIL_REQUEST_SEND_DEVICE_STATE:
            return "RIL_REQUEST_SEND_DEVICE_STATE";
        case RIL_REQUEST_SET_UNSOLICITED_RESPONSE_FILTER:
            return "RIL_REQUEST_SET_UNSOLICITED_RESPONSE_FILTER";
        case RIL_RESPONSE_ACKNOWLEDGEMENT:
            return "RIL_RESPONSE_ACKNOWLEDGEMENT";
        case RIL_REQUEST_SET_CARRIER_INFO_IMSI_ENCRYPTION:
            return "RIL_REQUEST_SET_CARRIER_INFO_IMSI_ENCRYPTION";
        case RIL_REQUEST_START_NETWORK_SCAN:
            return "RIL_REQUEST_START_NETWORK_SCAN";
        case RIL_REQUEST_STOP_NETWORK_SCAN:
            return "RIL_REQUEST_STOP_NETWORK_SCAN";
        case RIL_REQUEST_GET_SLOT_STATUS:
            return "RIL_REQUEST_GET_SLOT_STATUS";
        case RIL_REQUEST_SET_LOGICAL_TO_PHYSICAL_SLOT_MAPPING:
            return "RIL_REQUEST_SET_LOGICAL_TO_PHYSICAL_SLOT_MAPPING";
        default:
            return "<unknown request>";
    }
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("RIL: " + this);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mWakeLockTimeout=" + mWakeLockTimeout);
    synchronized (mRequestList) {
        synchronized (mWakeLock) {
            pw.println(" mWakeLockCount=" + mWakeLockCount);
        }
        int count = mRequestList.size();
        pw.println(" mRequestList count=" + count);
        for (int i = 0; i < count; i++) {
            RILRequest rr = mRequestList.valueAt(i);
            pw.println("  [" + rr.mSerial + "] " + requestToString(rr.mRequest));
        }
    }
    pw.println(" mLastNITZTimeInfo=" + Arrays.toString(mLastNITZTimeInfo));
    pw.println(" mTestingEmergencyCall=" + mTestingEmergencyCall.get());
    mClientWakelockTracker.dumpClientRequestTracker();
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("RIL: " + this);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mWakeLockTimeout=" + mWakeLockTimeout);
    synchronized (mRequestList) {
        synchronized (mWakeLock) {
            pw.println(" mWakeLockCount=" + mWakeLockCount);
        }
        int count = mRequestList.size();
        pw.println(" mRequestList count=" + count);
        for (int i = 0; i < count; i++) {
            RILRequest rr = mRequestList.valueAt(i);
            pw.println("  [" + rr.mSerial + "] " + requestToString(rr.mRequest));
        }
    }
    pw.println(" mLastNITZTimeInfo=" + Arrays.toString(mLastNITZTimeInfo));
    pw.println(" mTestingEmergencyCall=" + mTestingEmergencyCall.get());
    mClientWakelockTracker.dumpClientRequestTracker(pw);
}
#end_block

#method_before
@VisibleForTesting
public static ArrayList<IccSlotStatus> convertHalSlotsStatus(android.hardware.radio.V1_2.SlotsStatus slotsStatus) {
    ArrayList<IccSlotStatus> iccSlotStatus = new ArrayList<IccSlotStatus>(slotsStatus.numSlots);
    for (int i = 0; i < slotsStatus.numSlots; i++) {
        IccSlotStatus iss = new IccSlotStatus();
        android.hardware.radio.V1_2.SlotStatus slotStatus = slotsStatus.slotStatus.get(i);
        iss.setCardState(slotStatus.cardState);
        iss.setSlotState(slotStatus.slotState);
        iss.logicalSlotIndex = slotStatus.logicalSlot;
        iss.iccid = new String[slotStatus.iccidLen];
        for (int j = 0; j < slotStatus.iccidLen; j++) {
            iss.iccid[j] = slotStatus.iccid.get(j);
        }
        iccSlotStatus.add(iss);
    }
    return iccSlotStatus;
}
#method_after
@VisibleForTesting
public static ArrayList<IccSlotStatus> convertHalSlotsStatus(ArrayList<android.hardware.radio.V1_2.SimSlotStatus> slotsStatus) {
    ArrayList<IccSlotStatus> iccSlotStatus = new ArrayList<IccSlotStatus>(slotsStatus.size());
    for (android.hardware.radio.V1_2.SimSlotStatus slotStatus : slotsStatus) {
        IccSlotStatus iss = new IccSlotStatus();
        iss.setCardState(slotStatus.cardState);
        iss.setSlotState(slotStatus.slotState);
        iss.logicalSlotIndex = slotStatus.logicalSlotId;
        iss.atr = slotStatus.atr;
        iss.iccid = slotStatus.iccid;
        iccSlotStatus.add(iss);
    }
    return iccSlotStatus;
}
#end_block

#method_before
private void responseIccCardStatus_1_2(RadioResponseInfo responseInfo, android.hardware.radio.V1_2.CardStatus cardStatus) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        IccCardStatus iccCardStatus = convertHalCardStatus(cardStatus.base);
        iccCardStatus.physicalSlotIndex = cardStatus.physicalSlotIndex;
        iccCardStatus.atr = cardStatus.atr;
        mRil.riljLog("responseIccCardStatus: from HIDL: " + iccCardStatus);
        if (responseInfo.error == RadioError.NONE) {
            sendMessageResponse(rr.mResult, iccCardStatus);
        }
        mRil.processResponseDone(rr, responseInfo, iccCardStatus);
    }
}
#method_after
private void responseIccCardStatus_1_2(RadioResponseInfo responseInfo, android.hardware.radio.V1_2.CardStatus cardStatus) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        IccCardStatus iccCardStatus = convertHalCardStatus(cardStatus.base);
        iccCardStatus.physicalSlotIndex = cardStatus.physicalSlotId;
        iccCardStatus.atr = cardStatus.atr;
        iccCardStatus.iccid = cardStatus.iccid;
        mRil.riljLog("responseIccCardStatus: from HIDL: " + iccCardStatus);
        if (responseInfo.error == RadioError.NONE) {
            sendMessageResponse(rr.mResult, iccCardStatus);
        }
        mRil.processResponseDone(rr, responseInfo, iccCardStatus);
    }
}
#end_block

#method_before
private void responseIccSlotStatus(RadioResponseInfo responseInfo, SlotsStatus slotsStatus) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        ArrayList<IccSlotStatus> iccSlotStatus = RIL.convertHalSlotsStatus(slotsStatus);
        mRil.riljLog("responseIccSlotStatus: from HIDL: " + iccSlotStatus);
        if (responseInfo.error == RadioError.NONE) {
            sendMessageResponse(rr.mResult, iccSlotStatus);
        }
        mRil.processResponseDone(rr, responseInfo, iccSlotStatus);
    }
}
#method_after
private void responseIccSlotStatus(RadioResponseInfo responseInfo, ArrayList<SimSlotStatus> slotsStatus) {
    RILRequest rr = mRil.processResponse(responseInfo);
    if (rr != null) {
        ArrayList<IccSlotStatus> iccSlotStatus = RIL.convertHalSlotsStatus(slotsStatus);
        mRil.riljLog("responseIccSlotStatus: from HIDL: " + iccSlotStatus);
        if (responseInfo.error == RadioError.NONE) {
            sendMessageResponse(rr.mResult, iccSlotStatus);
        }
        mRil.processResponseDone(rr, responseInfo, iccSlotStatus);
    }
}
#end_block

#method_before
@Override
public String toString() {
    IccCardApplicationStatus app;
    StringBuilder sb = new StringBuilder();
    sb.append("IccCardState {").append(mCardState).append(",").append(mUniversalPinState).append(",num_apps=").append(mApplications.length);
    sb.append(",gsm_id=").append(mGsmUmtsSubscriptionAppIndex);
    if (mApplications != null && mGsmUmtsSubscriptionAppIndex >= 0 && mGsmUmtsSubscriptionAppIndex < mApplications.length) {
        app = mApplications[mGsmUmtsSubscriptionAppIndex];
        sb.append(app == null ? "null" : app);
    }
    sb.append(",cdma_id=").append(mCdmaSubscriptionAppIndex);
    if (mApplications != null && mCdmaSubscriptionAppIndex >= 0 && mCdmaSubscriptionAppIndex < mApplications.length) {
        app = mApplications[mCdmaSubscriptionAppIndex];
        sb.append(app == null ? "null" : app);
    }
    sb.append(",ims_id=").append(mImsSubscriptionAppIndex);
    if (mApplications != null && mImsSubscriptionAppIndex >= 0 && mImsSubscriptionAppIndex < mApplications.length) {
        app = mApplications[mImsSubscriptionAppIndex];
        sb.append(app == null ? "null" : app);
    }
    sb.append(",physical_slot_id=").append(physicalSlotIndex).append(",atr=").append(atr);
    sb.append("}");
    return sb.toString();
}
#method_after
@Override
public String toString() {
    IccCardApplicationStatus app;
    StringBuilder sb = new StringBuilder();
    sb.append("IccCardState {").append(mCardState).append(",").append(mUniversalPinState).append(",num_apps=").append(mApplications.length);
    sb.append(",gsm_id=").append(mGsmUmtsSubscriptionAppIndex);
    if (mApplications != null && mGsmUmtsSubscriptionAppIndex >= 0 && mGsmUmtsSubscriptionAppIndex < mApplications.length) {
        app = mApplications[mGsmUmtsSubscriptionAppIndex];
        sb.append(app == null ? "null" : app);
    }
    sb.append(",cdma_id=").append(mCdmaSubscriptionAppIndex);
    if (mApplications != null && mCdmaSubscriptionAppIndex >= 0 && mCdmaSubscriptionAppIndex < mApplications.length) {
        app = mApplications[mCdmaSubscriptionAppIndex];
        sb.append(app == null ? "null" : app);
    }
    sb.append(",ims_id=").append(mImsSubscriptionAppIndex);
    if (mApplications != null && mImsSubscriptionAppIndex >= 0 && mImsSubscriptionAppIndex < mApplications.length) {
        app = mApplications[mImsSubscriptionAppIndex];
        sb.append(app == null ? "null" : app);
    }
    sb.append(",physical_slot_id=").append(physicalSlotIndex).append(",atr=").append(atr);
    sb.append(",iccid=").append(SubscriptionInfo.givePrintableIccid(iccid));
    sb.append("}");
    return sb.toString();
}
#end_block

#method_before
@Override
public void doGetHandler(HttpServletRequest request, HttpServletResponse response) throws IOException {
    UserService userService = UserServiceFactory.getUserService();
    User currentUser = userService.getCurrentUser();
    RequestDispatcher dispatcher = null;
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    HttpSession session = request.getSession(true);
    PageType referTo = PageType.TREE;
    if (session.getAttribute("treeDefault") != null) {
        boolean treeDefault = (boolean) session.getAttribute("treeDefault");
        if (!treeDefault) {
            referTo = PageType.TABLE;
        }
    }
    List<TestDisplay> displayedTests = new ArrayList<>();
    List<String> allTestNames = new ArrayList<>();
    List<Key> unprocessedTestKeys = new ArrayList<>();
    // map from table key to TestDisplay
    Map<Key, TestDisplay> testMap = new HashMap<>();
    Map<String, String> subscriptionMap = new HashMap<>();
    boolean showAll = request.getParameter("showAll") != null;
    String error = null;
    Query query = new Query(TestEntity.KIND).setKeysOnly();
    for (Entity test : datastore.prepare(query).asIterable()) {
        allTestNames.add(test.getKey().getName());
    }
    List<Key> favoriteKeyList = new ArrayList<Key>();
    Filter userFilter = new FilterPredicate(UserFavoriteEntity.USER, FilterOperator.EQUAL, currentUser);
    Query filterQuery = new Query(UserFavoriteEntity.KIND).setFilter(userFilter);
    Iterable<Entity> favoriteIter = datastore.prepare(filterQuery).asIterable();
    favoriteIter.forEach(fe -> {
        Key testKey = UserFavoriteEntity.fromEntity(fe).testKey;
        favoriteKeyList.add(testKey);
        subscriptionMap.put(testKey.getName(), KeyFactory.keyToString(fe.getKey()));
    });
    query = new Query(TestStatusEntity.KIND).addProjection(new PropertyProjection(TestStatusEntity.PASS_COUNT, Long.class)).addProjection(new PropertyProjection(TestStatusEntity.FAIL_COUNT, Long.class));
    for (Entity status : datastore.prepare(query).asIterable()) {
        TestStatusEntity statusEntity = TestStatusEntity.fromEntity(status);
        if (statusEntity == null)
            continue;
        Key testKey = KeyFactory.createKey(TestEntity.KIND, statusEntity.testName);
        boolean isFavorite = favoriteKeyList.contains(testKey);
        TestDisplay display = new TestDisplay(testKey, -1, -1, false, isFavorite);
        if (unprocessedTestKeys.contains(testKey)) {
        // Process tests without statuses
        // This is default value so do not need to do anything here
        } else {
            display = new TestDisplay(testKey, statusEntity.passCount, statusEntity.failCount, false, isFavorite);
        }
        testMap.put(testKey, display);
    }
    if (testMap.size() == 0) {
        error = NO_TESTS_ERROR;
    }
    if (showAll) {
        for (Key testKey : testMap.keySet()) {
            displayedTests.add(testMap.get(testKey));
        }
    } else {
        if (testMap.size() > 0) {
            for (Entity favoriteEntity : favoriteIter) {
                UserFavoriteEntity favorite = UserFavoriteEntity.fromEntity(favoriteEntity);
                Key testKey = favorite.testKey;
                if (!testMap.containsKey(testKey)) {
                    continue;
                }
                TestDisplay display = testMap.get(testKey);
                display.setMuteNotifications(favorite.muteNotifications);
                displayedTests.add(display);
            }
        }
    }
    displayedTests.sort(Comparator.naturalOrder());
    response.setStatus(HttpServletResponse.SC_OK);
    request.setAttribute("allTestsJson", new Gson().toJson(allTestNames));
    request.setAttribute("subscriptionMapJson", new Gson().toJson(subscriptionMap));
    request.setAttribute("testNames", displayedTests);
    request.setAttribute("showAll", showAll);
    request.setAttribute("error", error);
    request.setAttribute("resultsUrl", referTo.defaultUrl);
    dispatcher = request.getRequestDispatcher(DASHBOARD_MAIN_JSP);
    try {
        dispatcher.forward(request, response);
    } catch (ServletException e) {
        logger.log(Level.SEVERE, "Servlet Excpetion caught : ", e);
    }
}
#method_after
@Override
public void doGetHandler(HttpServletRequest request, HttpServletResponse response) throws IOException {
    UserService userService = UserServiceFactory.getUserService();
    User currentUser = userService.getCurrentUser();
    RequestDispatcher dispatcher = null;
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    HttpSession session = request.getSession(true);
    PageType referTo = PageType.TREE;
    if (session.getAttribute("treeDefault") != null) {
        boolean treeDefault = (boolean) session.getAttribute("treeDefault");
        if (!treeDefault) {
            referTo = PageType.TABLE;
        }
    }
    List<TestDisplay> displayedTests = new ArrayList<>();
    List<String> allTestNames = new ArrayList<>();
    List<Key> unprocessedTestKeys = new ArrayList<>();
    // map from table key to TestDisplay
    Map<Key, TestDisplay> testMap = new HashMap<>();
    Map<String, String> subscriptionMap = new HashMap<>();
    boolean showAll = request.getParameter("showAll") != null;
    String error = null;
    Query query = new Query(TestEntity.KIND).setKeysOnly();
    for (Entity test : datastore.prepare(query).asIterable()) {
        allTestNames.add(test.getKey().getName());
    }
    List<Key> favoriteKeyList = new ArrayList<Key>();
    Filter userFilter = new FilterPredicate(UserFavoriteEntity.USER, FilterOperator.EQUAL, currentUser);
    Query filterQuery = new Query(UserFavoriteEntity.KIND).setFilter(userFilter);
    Iterable<Entity> favoriteIter = datastore.prepare(filterQuery).asIterable();
    favoriteIter.forEach(fe -> {
        Key testKey = UserFavoriteEntity.fromEntity(fe).testKey;
        favoriteKeyList.add(testKey);
        subscriptionMap.put(testKey.getName(), KeyFactory.keyToString(fe.getKey()));
    });
    query = new Query(TestStatusEntity.KIND).addProjection(new PropertyProjection(TestStatusEntity.PASS_COUNT, Long.class)).addProjection(new PropertyProjection(TestStatusEntity.FAIL_COUNT, Long.class));
    for (Entity status : datastore.prepare(query).asIterable()) {
        TestStatusEntity statusEntity = TestStatusEntity.fromEntity(status);
        if (statusEntity == null)
            continue;
        Key testKey = KeyFactory.createKey(TestEntity.KIND, statusEntity.testName);
        boolean isFavorite = favoriteKeyList.contains(testKey);
        TestDisplay display = new TestDisplay(testKey, -1, -1, false, isFavorite);
        if (!unprocessedTestKeys.contains(testKey)) {
            display = new TestDisplay(testKey, statusEntity.passCount, statusEntity.failCount, false, isFavorite);
        }
        testMap.put(testKey, display);
    }
    if (testMap.size() == 0) {
        error = NO_TESTS_ERROR;
    }
    if (showAll) {
        for (Key testKey : testMap.keySet()) {
            displayedTests.add(testMap.get(testKey));
        }
    } else {
        if (testMap.size() > 0) {
            for (Entity favoriteEntity : favoriteIter) {
                UserFavoriteEntity favorite = UserFavoriteEntity.fromEntity(favoriteEntity);
                Key testKey = favorite.testKey;
                if (!testMap.containsKey(testKey)) {
                    continue;
                }
                TestDisplay display = testMap.get(testKey);
                display.setMuteNotifications(favorite.muteNotifications);
                displayedTests.add(display);
            }
        }
    }
    displayedTests.sort(Comparator.naturalOrder());
    response.setStatus(HttpServletResponse.SC_OK);
    request.setAttribute("allTestsJson", new Gson().toJson(allTestNames));
    request.setAttribute("subscriptionMapJson", new Gson().toJson(subscriptionMap));
    request.setAttribute("testNames", displayedTests);
    request.setAttribute("showAll", showAll);
    request.setAttribute("error", error);
    request.setAttribute("resultsUrl", referTo.defaultUrl);
    dispatcher = request.getRequestDispatcher(DASHBOARD_MAIN_JSP);
    try {
        dispatcher.forward(request, response);
    } catch (ServletException e) {
        logger.log(Level.SEVERE, "Servlet Excpetion caught : ", e);
    }
}
#end_block

#method_before
public void onError(int error) {
}
#method_after
public void onError(@NetworkScan.ScanErrorCode int error) {
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(radioAccessNetwork);
    dest.writeIntArray(bands);
    dest.writeIntArray(channels);
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(mRadioAccessNetwork);
    dest.writeIntArray(mBands);
    dest.writeIntArray(mChannels);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    RadioAccessSpecifier ras;
    try {
        ras = (RadioAccessSpecifier) o;
    } catch (ClassCastException ex) {
        return false;
    }
    if (o == null) {
        return false;
    }
    return (radioAccessNetwork == ras.radioAccessNetwork && Arrays.equals(bands, ras.bands) && Arrays.equals(channels, ras.channels));
}
#method_after
@Override
public boolean equals(Object o) {
    RadioAccessSpecifier ras;
    try {
        ras = (RadioAccessSpecifier) o;
    } catch (ClassCastException ex) {
        return false;
    }
    if (o == null) {
        return false;
    }
    return (mRadioAccessNetwork == ras.mRadioAccessNetwork && Arrays.equals(mBands, ras.mBands) && Arrays.equals(mChannels, ras.mChannels));
}
#end_block

#method_before
@Override
public int hashCode() {
    return ((radioAccessNetwork * 31) + (Arrays.hashCode(bands) * 37) + (Arrays.hashCode(channels)) * 39);
}
#method_after
@Override
public int hashCode() {
    return ((mRadioAccessNetwork * 31) + (Arrays.hashCode(mBands) * 37) + (Arrays.hashCode(mChannels)) * 39);
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(scanType);
    dest.writeParcelableArray(specifiers, flags);
    dest.writeInt(searchPeriodicity);
    dest.writeInt(maxSearchTime);
    dest.writeBoolean(incrementalResults);
    dest.writeInt(incrementalResultsPeriodicity);
    dest.writeStringList(mccMncs);
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(mScanType);
    dest.writeParcelableArray(mSpecifiers, flags);
    dest.writeInt(mSearchPeriodicity);
    dest.writeInt(mMaxSearchTime);
    dest.writeBoolean(mIncrementalResults);
    dest.writeInt(mIncrementalResultsPeriodicity);
    dest.writeStringList(mMccMncs);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    NetworkScanRequest nsr;
    try {
        nsr = (NetworkScanRequest) o;
    } catch (ClassCastException ex) {
        return false;
    }
    if (o == null) {
        return false;
    }
    return (scanType == nsr.scanType && Arrays.equals(specifiers, nsr.specifiers) && searchPeriodicity == nsr.searchPeriodicity && maxSearchTime == nsr.maxSearchTime && incrementalResults == nsr.incrementalResults && incrementalResultsPeriodicity == nsr.incrementalResultsPeriodicity && (((mccMncs != null) && mccMncs.equals(nsr.mccMncs))));
}
#method_after
@Override
public boolean equals(Object o) {
    NetworkScanRequest nsr;
    try {
        nsr = (NetworkScanRequest) o;
    } catch (ClassCastException ex) {
        return false;
    }
    if (o == null) {
        return false;
    }
    return (mScanType == nsr.mScanType && Arrays.equals(mSpecifiers, nsr.mSpecifiers) && mSearchPeriodicity == nsr.mSearchPeriodicity && mMaxSearchTime == nsr.mMaxSearchTime && mIncrementalResults == nsr.mIncrementalResults && mIncrementalResultsPeriodicity == nsr.mIncrementalResultsPeriodicity && (((mMccMncs != null) && mMccMncs.equals(nsr.mMccMncs))));
}
#end_block

#method_before
@Override
public int hashCode() {
    return ((scanType * 31) + (Arrays.hashCode(specifiers)) * 37 + (searchPeriodicity * 41) + (maxSearchTime * 43) + ((incrementalResults == true ? 1 : 0) * 47) + (incrementalResultsPeriodicity * 53) + (mccMncs.hashCode() * 59));
}
#method_after
@Override
public int hashCode() {
    return ((mScanType * 31) + (Arrays.hashCode(mSpecifiers)) * 37 + (mSearchPeriodicity * 41) + (mMaxSearchTime * 43) + ((mIncrementalResults == true ? 1 : 0) * 47) + (mIncrementalResultsPeriodicity * 53) + (mMccMncs.hashCode() * 59));
}
#end_block

#method_before
public ImsiEncryptionInfo getCarrierInfoForImsiEncryption(int keyType) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        int subId = getSubId(SubscriptionManager.getDefaultDataSubscriptionId());
        if (keyType != KEY_TYPE_EPDDG && keyType != KEY_TYPE_WLAN) {
            throw new IllegalArgumentException("Invalid key type");
        }
        return info.getCarrierInfoForImsiEncryption(subId, keyType, mContext.getOpPackageName());
    } catch (RemoteException ex) {
        Rlog.e(TAG, "getCarrierInfoForImsiEncryption RemoteException", ex);
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        Rlog.e(TAG, "getCarrierInfoForImsiEncryption NullPointerException", ex);
        return null;
    }
}
#method_after
public ImsiEncryptionInfo getCarrierInfoForImsiEncryption(int keyType) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null) {
            throw new RuntimeException("IMSI error: Subscriber Info is null");
        }
        int subId = getSubId(SubscriptionManager.getDefaultDataSubscriptionId());
        if (keyType != KEY_TYPE_EPDG && keyType != KEY_TYPE_WLAN) {
            throw new IllegalArgumentException("IMSI error: Invalid key type");
        }
        ImsiEncryptionInfo imsiEncryptionInfo = info.getCarrierInfoForImsiEncryption(subId, keyType, mContext.getOpPackageName());
        if (imsiEncryptionInfo == null && isImsiEncryptionRequired(subId, keyType)) {
            Rlog.e(TAG, "IMSI error: key is required but not found");
            throw new RuntimeException("IMSI error: key is required but not found");
        }
        return imsiEncryptionInfo;
    } catch (RemoteException ex) {
        Rlog.e(TAG, "getCarrierInfoForImsiEncryption RemoteException" + ex);
        throw new RuntimeException("IMSI error: Remote Exception");
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        Rlog.e(TAG, "getCarrierInfoForImsiEncryption NullPointerException" + ex);
        throw new RuntimeException("IMSI error: Null Pointer exception");
    }
}
#end_block

#method_before
public void setNetworkSelectionModeAutomatic(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            telephony.setNetworkSelectionModeAutomatic(subId);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeAutomatic RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeAutomatic NPE", ex);
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setNetworkSelectionModeAutomatic() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            telephony.setNetworkSelectionModeAutomatic(getSubId());
        }
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeAutomatic RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeAutomatic NPE", ex);
    }
}
#end_block

#method_before
public NetworkScan requestNetworkScan(NetworkScanRequest request, TelephonyScanManager.NetworkScanCallback callback) {
    synchronized (this) {
        if (mTelephonyScanManager == null) {
            mTelephonyScanManager = new TelephonyScanManager();
        }
    }
    return mTelephonyScanManager.requestNetworkScan(getSubId(), request, callback);
}
#method_after
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public NetworkScan requestNetworkScan(NetworkScanRequest request, TelephonyScanManager.NetworkScanCallback callback) {
    synchronized (this) {
        if (mTelephonyScanManager == null) {
            mTelephonyScanManager = new TelephonyScanManager();
        }
    }
    return mTelephonyScanManager.requestNetworkScan(getSubId(), request, callback);
}
#end_block

#method_before
public boolean setNetworkSelectionModeManual(int subId, String operatorNumeric, boolean persistSelection) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.setNetworkSelectionModeManual(subId, operatorNumeric, persistSelection);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual NPE", ex);
    }
    return false;
}
#method_after
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public boolean setNetworkSelectionModeManual(String operatorNumeric, boolean persistSelection) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.setNetworkSelectionModeManual(getSubId(), operatorNumeric, persistSelection);
        }
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual NPE", ex);
    }
    return false;
}
#end_block

#method_before
public boolean setPreferredNetworkType(int subId, int networkType) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.setPreferredNetworkType(subId, networkType);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setPreferredNetworkType RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setPreferredNetworkType NPE", ex);
    }
    return false;
}
#method_after
public boolean setPreferredNetworkType(int subId, int networkType) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.setPreferredNetworkType(subId, networkType);
        }
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setPreferredNetworkType RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setPreferredNetworkType NPE", ex);
    }
    return false;
}
#end_block

#method_before
private void closeService() {
    if (VERBOSE) {
        Log.v(TAG, "Pbap Service closeService");
    }
    BluetoothPbapUtils.savePbapParams(this, BluetoothPbapUtils.sPrimaryVersionCounter, BluetoothPbapUtils.sSecondaryVersionCounter, BluetoothPbapUtils.sDbIdentifier.get(), BluetoothPbapUtils.contactsLastUpdated, BluetoothPbapUtils.totalFields, BluetoothPbapUtils.totalSvcFields, BluetoothPbapUtils.totalContacts);
    if (mWakeLock != null) {
        mWakeLock.release();
        mWakeLock = null;
    }
    clearServerSocket();
    if (mSessionStatusHandler != null) {
        mSessionStatusHandler.removeCallbacksAndMessages(null);
    }
    mRemoteDevice = null;
}
#method_after
private void closeService() {
    if (VERBOSE) {
        Log.v(TAG, "Pbap Service closeService");
    }
    BluetoothPbapUtils.savePbapParams(this, BluetoothPbapUtils.sPrimaryVersionCounter, BluetoothPbapUtils.sSecondaryVersionCounter, BluetoothPbapUtils.sDbIdentifier.get(), BluetoothPbapUtils.contactsLastUpdated, BluetoothPbapUtils.totalFields, BluetoothPbapUtils.totalSvcFields, BluetoothPbapUtils.totalContacts);
    // exit initSocket early
    mInterrupted = true;
    if (mWakeLock != null) {
        mWakeLock.release();
        mWakeLock = null;
    }
    cleanUpServerSocket();
    if (mSessionStatusHandler != null) {
        mSessionStatusHandler.removeCallbacksAndMessages(null);
    }
    mRemoteDevice = null;
}
#end_block

#method_before
private void cleanUpSdpRecord() {
    if (mSdpHandle < 0) {
        Log.w(TAG, "cleanUpSdpRecord, SDP record never created");
        return;
    }
    int sdpHandle = mSdpHandle;
    mSdpHandle = -1;
    SdpManager sdpManager = SdpManager.getDefaultManager();
    Log.d(TAG, "cleanUpSdpRecord, mSdpHandle=" + sdpHandle);
    if (sdpManager == null || !sdpManager.removeSdpRecord(sdpHandle)) {
        Log.e(TAG, "cleanUpSdpRecord, removeSdpRecord failed, sdpHandle=" + sdpHandle);
    }
}
#method_after
private void cleanUpSdpRecord() {
    if (mSdpHandle < 0) {
        Log.w(TAG, "cleanUpSdpRecord, SDP record never created");
        return;
    }
    int sdpHandle = mSdpHandle;
    mSdpHandle = -1;
    SdpManager sdpManager = SdpManager.getDefaultManager();
    if (DEBUG) {
        Log.d(TAG, "cleanUpSdpRecord, mSdpHandle=" + sdpHandle);
    }
    if (sdpManager == null) {
        Log.e(TAG, "sdpManager is null");
    } else if (!sdpManager.removeSdpRecord(sdpHandle)) {
        Log.w(TAG, "cleanUpSdpRecord, removeSdpRecord failed, sdpHandle=" + sdpHandle);
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    if (VERBOSE) {
        Log.v(TAG, "Handler(): got msg=" + msg.what);
    }
    switch(msg.what) {
        case START_LISTENER:
            mServerSockets = ObexServerSockets.create(BluetoothPbapService.this);
            createSdpRecord();
            // fetch Pbap Params to check if significant change has happened to Database
            BluetoothPbapUtils.fetchPbapParams(mContext);
            break;
        case USER_TIMEOUT:
            Intent intent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_CANCEL);
            intent.setPackage(getString(R.string.pairing_ui_package));
            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mRemoteDevice);
            intent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE, BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS);
            sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
            mIsWaitingAuthorization = false;
            stopObexServerSession();
            break;
        case AUTH_TIMEOUT:
            Intent i = new Intent(USER_CONFIRM_TIMEOUT_ACTION);
            sendBroadcast(i);
            removePbapNotification(NOTIFICATION_ID_AUTH);
            notifyAuthCancelled();
            break;
        case MSG_SERVERSESSION_CLOSE:
            stopObexServerSession();
            break;
        case MSG_SESSION_ESTABLISHED:
            break;
        case MSG_OBEX_AUTH_CHALL:
            createPbapNotification(AUTH_CHALL_ACTION);
            mSessionStatusHandler.sendMessageDelayed(mSessionStatusHandler.obtainMessage(AUTH_TIMEOUT), USER_CONFIRM_TIMEOUT_VALUE);
            break;
        case MSG_ACQUIRE_WAKE_LOCK:
            if (mWakeLock == null) {
                PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
                mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "StartingObexPbapTransaction");
                mWakeLock.setReferenceCounted(false);
                mWakeLock.acquire();
                Log.w(TAG, "Acquire Wake Lock");
            }
            mSessionStatusHandler.removeMessages(MSG_RELEASE_WAKE_LOCK);
            mSessionStatusHandler.sendMessageDelayed(mSessionStatusHandler.obtainMessage(MSG_RELEASE_WAKE_LOCK), RELEASE_WAKE_LOCK_DELAY);
            break;
        case MSG_RELEASE_WAKE_LOCK:
            if (mWakeLock != null) {
                mWakeLock.release();
                mWakeLock = null;
                Log.w(TAG, "Release Wake Lock");
            }
            break;
        case SHUTDOWN:
            closeService();
            break;
        case LOAD_CONTACTS:
            loadAllContacts();
            break;
        case CHECK_SECONDARY_VERSION_COUNTER:
            updateSecondaryVersion();
            break;
        case ROLLOVER_COUNTERS:
            BluetoothPbapUtils.rolloverCounters();
            break;
        default:
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    if (VERBOSE) {
        Log.v(TAG, "Handler(): got msg=" + msg.what);
    }
    switch(msg.what) {
        case START_LISTENER:
            startSocketListeners();
            break;
        case USER_TIMEOUT:
            Intent intent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_CANCEL);
            intent.setPackage(getString(R.string.pairing_ui_package));
            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mRemoteDevice);
            intent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE, BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS);
            sendBroadcast(intent, BLUETOOTH_ADMIN_PERM);
            mIsWaitingAuthorization = false;
            stopObexServerSession();
            break;
        case AUTH_TIMEOUT:
            Intent i = new Intent(USER_CONFIRM_TIMEOUT_ACTION);
            sendBroadcast(i);
            removePbapNotification(NOTIFICATION_ID_AUTH);
            notifyAuthCancelled();
            break;
        case MSG_SERVERSESSION_CLOSE:
            stopObexServerSession();
            break;
        case MSG_OBEX_AUTH_CHALL:
            createPbapNotification(AUTH_CHALL_ACTION);
            mSessionStatusHandler.sendMessageDelayed(mSessionStatusHandler.obtainMessage(AUTH_TIMEOUT), USER_CONFIRM_TIMEOUT_VALUE);
            break;
        case MSG_ACQUIRE_WAKE_LOCK:
            if (mWakeLock == null) {
                PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
                mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "StartingObexPbapTransaction");
                mWakeLock.setReferenceCounted(false);
                mWakeLock.acquire();
                Log.w(TAG, "Acquire Wake Lock");
            }
            mSessionStatusHandler.removeMessages(MSG_RELEASE_WAKE_LOCK);
            mSessionStatusHandler.sendMessageDelayed(mSessionStatusHandler.obtainMessage(MSG_RELEASE_WAKE_LOCK), RELEASE_WAKE_LOCK_DELAY);
            break;
        case MSG_RELEASE_WAKE_LOCK:
            if (mWakeLock != null) {
                mWakeLock.release();
                mWakeLock = null;
                Log.w(TAG, "Release Wake Lock");
            }
            break;
        case SHUTDOWN:
            closeService();
            break;
        case LOAD_CONTACTS:
            loadAllContacts();
            break;
        case CHECK_SECONDARY_VERSION_COUNTER:
            updateSecondaryVersion();
            break;
        case ROLLOVER_COUNTERS:
            BluetoothPbapUtils.rolloverCounters();
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
protected boolean start() {
    Log.v(TAG, "start()");
    mState = BluetoothProfile.STATE_DISCONNECTED;
    mContext = this;
    mSessionStatusHandler = new PbapHandler();
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY);
    filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
    filter.addAction(AUTH_RESPONSE_ACTION);
    filter.addAction(AUTH_CANCELLED_ACTION);
    BluetoothPbapConfig.init(this);
    registerReceiver(mPbapReceiver, filter);
    try {
        mContactChangeObserver = new BluetoothPbapContentObserver();
        getContentResolver().registerContentObserver(DevicePolicyUtils.getEnterprisePhoneUri(this), false, mContactChangeObserver);
    } catch (SQLiteException e) {
        Log.e(TAG, "SQLite exception: " + e);
    } catch (IllegalStateException e) {
        Log.e(TAG, "Illegal state exception, content observer is already registered");
    }
    mSessionStatusHandler.sendMessage(mSessionStatusHandler.obtainMessage(START_LISTENER));
    return true;
}
#method_after
@Override
protected boolean start() {
    Log.v(TAG, "start()");
    mState = BluetoothProfile.STATE_DISCONNECTED;
    mContext = this;
    mSessionStatusHandler = new PbapHandler();
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY);
    filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
    filter.addAction(AUTH_RESPONSE_ACTION);
    filter.addAction(AUTH_CANCELLED_ACTION);
    mInterrupted = false;
    BluetoothPbapConfig.init(this);
    mSessionStatusHandler.sendMessage(mSessionStatusHandler.obtainMessage(START_LISTENER));
    registerReceiver(mPbapReceiver, filter);
    try {
        mContactChangeObserver = new BluetoothPbapContentObserver();
        getContentResolver().registerContentObserver(DevicePolicyUtils.getEnterprisePhoneUri(this), false, mContactChangeObserver);
    } catch (SQLiteException e) {
        Log.e(TAG, "SQLite exception: " + e);
    } catch (IllegalStateException e) {
        Log.e(TAG, "Illegal state exception, content observer is already registered");
    }
    return true;
}
#end_block

#method_before
private synchronized void startSocketListeners() {
    if (VERBOSE) {
        Log.v(TAG, "startsocketListener");
    }
    if (mServerSockets != null) {
        mServerSockets.prepareForNewConnect();
    }
}
#method_after
private synchronized void startSocketListeners() {
    if (DEBUG) {
        Log.d(TAG, "startsocketListener");
    }
    if (mServerSession != null) {
        if (DEBUG) {
            Log.d(TAG, "mServerSession exists - shutting it down...");
        }
        mServerSession.close();
        mServerSession = null;
    }
    closeConnectionSocket();
    if (mServerSockets != null) {
        mServerSockets.prepareForNewConnect();
    } else {
        mServerSockets = ObexServerSockets.create(this);
        if (mServerSockets == null) {
            // TODO: Handle - was not handled before
            Log.e(TAG, "Failed to start the listeners");
            return;
        }
        if (mSdpHandle >= 0) {
            Log.e(TAG, "SDP handle was not cleaned up, mSdpHandle=" + mSdpHandle);
            return;
        }
        mSdpHandle = SdpManager.getDefaultManager().createPbapPseRecord("OBEX Phonebook Access Server", mServerSockets.getRfcommChannel(), mServerSockets.getL2capPsm(), SDP_PBAP_SERVER_VERSION, SDP_PBAP_SUPPORTED_REPOSITORIES, SDP_PBAP_SUPPORTED_FEATURES);
        // fetch Pbap Params to check if significant change has happened to Database
        BluetoothPbapUtils.fetchPbapParams(mContext);
        if (DEBUG) {
            Log.d(TAG, "PBAP server with handle:" + mSdpHandle);
        }
    }
}
#end_block

#method_before
@Override
public boolean onConnect(BluetoothDevice remoteDevice, BluetoothSocket socket) {
    mRemoteDevice = remoteDevice;
    if (DEBUG) {
        Log.d(TAG, "onConnect(): mRemoteDevice=" + mRemoteDevice + " socket=" + socket);
    }
    if (mRemoteDevice == null || socket == null) {
        return false;
    }
    mConnSocket = socket;
    sRemoteDeviceName = mRemoteDevice.getName();
    // In case getRemoteName failed and return null
    if (TextUtils.isEmpty(sRemoteDeviceName)) {
        sRemoteDeviceName = getString(R.string.defaultname);
    }
    int permission = mRemoteDevice.getPhonebookAccessPermission();
    if (DEBUG) {
        Log.d(TAG, "getPhonebookAccessPermission() = " + permission);
    }
    if (permission == BluetoothDevice.ACCESS_ALLOWED) {
        try {
            startObexServerSession();
        } catch (IOException ex) {
            Log.e(TAG, "Caught exception starting obex server session" + ex.toString());
        }
        if (!BluetoothPbapUtils.contactsLoaded) {
            mSessionStatusHandler.sendMessage(mSessionStatusHandler.obtainMessage(LOAD_CONTACTS));
        }
    } else if (permission == BluetoothDevice.ACCESS_REJECTED) {
        if (DEBUG) {
            Log.d(TAG, "incoming connection rejected from: " + sRemoteDeviceName + " automatically as already rejected device");
        }
        return false;
    } else {
        // permission == BluetoothDevice.ACCESS_UNKNOWN
        // Send an Intent to Settings app to ask user preference.
        Intent intent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_REQUEST);
        intent.setClassName(ACCESS_AUTHORITY_PACKAGE, ACCESS_AUTHORITY_CLASS);
        intent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE, BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS);
        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mRemoteDevice);
        intent.putExtra(BluetoothDevice.EXTRA_PACKAGE_NAME, getPackageName());
        mIsWaitingAuthorization = true;
        sendOrderedBroadcast(intent, BLUETOOTH_ADMIN_PERM);
        if (VERBOSE) {
            Log.v(TAG, "waiting for authorization for connection from: " + sRemoteDeviceName);
        }
        /* In case car kit time out and try to use HFP for phonebook
             * access, while UI still there waiting for user to confirm */
        mSessionStatusHandler.sendMessageDelayed(mSessionStatusHandler.obtainMessage(USER_TIMEOUT), USER_CONFIRM_TIMEOUT_VALUE);
    /* We will continue the process when we receive
             * BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY from Settings app. */
    }
    return true;
}
#method_after
@Override
public boolean onConnect(BluetoothDevice remoteDevice, BluetoothSocket socket) {
    mRemoteDevice = remoteDevice;
    if (DEBUG) {
        Log.d(TAG, "onConnect(): mRemoteDevice=" + mRemoteDevice + " socket=" + socket);
    }
    if (mRemoteDevice == null || socket == null) {
        Log.e(TAG, "onConnect(): Unexpected null. mRemoteDevice=" + mRemoteDevice + " socket=" + socket);
        return false;
    }
    mConnSocket = socket;
    sRemoteDeviceName = mRemoteDevice.getName();
    // In case getRemoteName failed and return null
    if (TextUtils.isEmpty(sRemoteDeviceName)) {
        sRemoteDeviceName = getString(R.string.defaultname);
    }
    int permission = mRemoteDevice.getPhonebookAccessPermission();
    if (DEBUG) {
        Log.d(TAG, "getPhonebookAccessPermission() = " + permission);
    }
    if (permission == BluetoothDevice.ACCESS_ALLOWED) {
        try {
            startObexServerSession();
        } catch (IOException ex) {
            Log.e(TAG, "Caught exception starting obex server session" + ex.toString());
        }
        if (!BluetoothPbapUtils.contactsLoaded) {
            mSessionStatusHandler.sendMessage(mSessionStatusHandler.obtainMessage(LOAD_CONTACTS));
        }
    } else if (permission == BluetoothDevice.ACCESS_REJECTED) {
        if (DEBUG) {
            Log.d(TAG, "incoming connection rejected from: " + sRemoteDeviceName + " automatically as already rejected device");
        }
        return false;
    } else {
        // permission == BluetoothDevice.ACCESS_UNKNOWN
        // Send an Intent to Settings app to ask user preference.
        Intent intent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_REQUEST);
        intent.setClassName(ACCESS_AUTHORITY_PACKAGE, ACCESS_AUTHORITY_CLASS);
        intent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE, BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS);
        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mRemoteDevice);
        intent.putExtra(BluetoothDevice.EXTRA_PACKAGE_NAME, getPackageName());
        mIsWaitingAuthorization = true;
        sendOrderedBroadcast(intent, BLUETOOTH_ADMIN_PERM);
        if (VERBOSE) {
            Log.v(TAG, "waiting for authorization for connection from: " + sRemoteDeviceName);
        }
        /* In case car kit time out and try to use HFP for phonebook
             * access, while UI still there waiting for user to confirm */
        mSessionStatusHandler.sendMessageDelayed(mSessionStatusHandler.obtainMessage(USER_TIMEOUT), USER_CONFIRM_TIMEOUT_VALUE);
    /* We will continue the process when we receive
             * BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY from Settings app. */
    }
    return true;
}
#end_block

#method_before
@Override
public synchronized void onAcceptFailed() {
    Log.e(TAG, "PBAP server socket accept thread failed. Restarting the server socket");
    if (mWakeLock != null) {
        mWakeLock.release();
        mWakeLock = null;
    }
    clearServerSocket();
    if (mSessionStatusHandler != null) {
        mSessionStatusHandler.removeCallbacksAndMessages(null);
    }
    mSessionStatusHandler.sendMessage(mSessionStatusHandler.obtainMessage(START_LISTENER));
}
#method_after
@Override
public synchronized void onAcceptFailed() {
    Log.w(TAG, "PBAP server socket accept thread failed. Restarting the server socket");
    if (mWakeLock != null) {
        mWakeLock.release();
        mWakeLock = null;
    }
    cleanUpServerSocket();
    if (mSessionStatusHandler != null) {
        mSessionStatusHandler.removeCallbacksAndMessages(null);
    }
    if (!mInterrupted) {
        startSocketListeners();
    }
}
#end_block

#method_before
@SystemApi
@RequiresPermission(android.Manifest.permission.UPDATE_DEVICE_STATS)
public static void clearThreadStatsUid() {
    NetworkManagementSocketTagger.setThreadSocketStatsUid(-1);
}
#method_after
@SystemApi
@SuppressLint("Doclava125")
public static void clearThreadStatsUid() {
    NetworkManagementSocketTagger.setThreadSocketStatsUid(-1);
}
#end_block

#method_before
public void systemReady() {
    mSystemReady = true;
    if (!isBandwidthControlEnabled()) {
        Slog.w(TAG, "bandwidth controls disabled, unable to track stats");
        return;
    }
    // create data recorders along with historical rotators
    mDevRecorder = buildRecorder(PREFIX_DEV, mSettings.getDevConfig(), false);
    mXtRecorder = buildRecorder(PREFIX_XT, mSettings.getXtConfig(), false);
    mUidRecorder = buildRecorder(PREFIX_UID, mSettings.getUidConfig(), false);
    mUidTagRecorder = buildRecorder(PREFIX_UID_TAG, mSettings.getUidTagConfig(), true);
    updatePersistThresholds();
    synchronized (mStatsLock) {
        // upgrade any legacy stats, migrating them to rotated files
        maybeUpgradeLegacyStatsLocked();
        // read historical network stats from disk, since policy service
        // might need them right away.
        mXtStatsCached = mXtRecorder.getOrLoadCompleteLocked();
        // bootstrap initial stats to prevent double-counting later
        bootstrapStatsLocked();
    }
    // watch for tethering changes
    final IntentFilter tetherFilter = new IntentFilter(ACTION_TETHER_STATE_CHANGED);
    mContext.registerReceiver(mTetherReceiver, tetherFilter, null, mHandler);
    // listen for periodic polling events
    final IntentFilter pollFilter = new IntentFilter(ACTION_NETWORK_STATS_POLL);
    mContext.registerReceiver(mPollReceiver, pollFilter, READ_NETWORK_USAGE_HISTORY, mHandler);
    // listen for uid removal to clean stats
    final IntentFilter removedFilter = new IntentFilter(ACTION_UID_REMOVED);
    mContext.registerReceiver(mRemovedReceiver, removedFilter, null, mHandler);
    // listen for user changes to clean stats
    final IntentFilter userFilter = new IntentFilter(ACTION_USER_REMOVED);
    mContext.registerReceiver(mUserReceiver, userFilter, null, mHandler);
    // persist stats during clean shutdown
    final IntentFilter shutdownFilter = new IntentFilter(ACTION_SHUTDOWN);
    mContext.registerReceiver(mShutdownReceiver, shutdownFilter);
    try {
        mNetworkManager.registerObserver(mAlertObserver);
    } catch (RemoteException e) {
    // ignored; service lives in system_server
    }
    registerPollAlarmLocked();
    registerGlobalAlert();
}
#method_after
public void systemReady() {
    mSystemReady = true;
    if (!isBandwidthControlEnabled()) {
        Slog.w(TAG, "bandwidth controls disabled, unable to track stats");
        return;
    }
    synchronized (mStatsLock) {
        // create data recorders along with historical rotators
        mDevRecorder = buildRecorder(PREFIX_DEV, mSettings.getDevConfig(), false);
        mXtRecorder = buildRecorder(PREFIX_XT, mSettings.getXtConfig(), false);
        mUidRecorder = buildRecorder(PREFIX_UID, mSettings.getUidConfig(), false);
        mUidTagRecorder = buildRecorder(PREFIX_UID_TAG, mSettings.getUidTagConfig(), true);
        updatePersistThresholdsLocked();
        // upgrade any legacy stats, migrating them to rotated files
        maybeUpgradeLegacyStatsLocked();
        // read historical network stats from disk, since policy service
        // might need them right away.
        mXtStatsCached = mXtRecorder.getOrLoadCompleteLocked();
        // bootstrap initial stats to prevent double-counting later
        bootstrapStatsLocked();
    }
    // watch for tethering changes
    final IntentFilter tetherFilter = new IntentFilter(ACTION_TETHER_STATE_CHANGED);
    mContext.registerReceiver(mTetherReceiver, tetherFilter, null, mHandler);
    // listen for periodic polling events
    final IntentFilter pollFilter = new IntentFilter(ACTION_NETWORK_STATS_POLL);
    mContext.registerReceiver(mPollReceiver, pollFilter, READ_NETWORK_USAGE_HISTORY, mHandler);
    // listen for uid removal to clean stats
    final IntentFilter removedFilter = new IntentFilter(ACTION_UID_REMOVED);
    mContext.registerReceiver(mRemovedReceiver, removedFilter, null, mHandler);
    // listen for user changes to clean stats
    final IntentFilter userFilter = new IntentFilter(ACTION_USER_REMOVED);
    mContext.registerReceiver(mUserReceiver, userFilter, null, mHandler);
    // persist stats during clean shutdown
    final IntentFilter shutdownFilter = new IntentFilter(ACTION_SHUTDOWN);
    mContext.registerReceiver(mShutdownReceiver, shutdownFilter);
    try {
        mNetworkManager.registerObserver(mAlertObserver);
    } catch (RemoteException e) {
    // ignored; service lives in system_server
    }
    registerPollAlarmLocked();
    registerGlobalAlert();
}
#end_block

#method_before
@Override
public INetworkStatsSession openSession() {
    return createSession(null, /* poll on create */
    false);
}
#method_after
@Override
public INetworkStatsSession openSession() {
    // through the public API
    return openSessionInternal(NetworkStatsManager.FLAG_AUGMENT_WITH_SUBSCRIPTION_PLAN, null);
}
#end_block

#method_before
@Override
public INetworkStatsSession openSessionForUsageStats(final String callingPackage) {
    return createSession(callingPackage, /* poll on create */
    true);
}
#method_after
@Override
public INetworkStatsSession openSessionForUsageStats(int flags, String callingPackage) {
    return openSessionInternal(flags, callingPackage);
}
#end_block

#method_before
private NetworkStats internalGetSummaryForNetwork(NetworkTemplate template, long start, long end, @NetworkStatsAccess.Level int accessLevel) {
    // splice DEV and XT together.
    return mXtStatsCached.getSummary(template, start, end, accessLevel);
}
#method_after
private NetworkStats internalGetSummaryForNetwork(NetworkTemplate template, int flags, long start, long end, @NetworkStatsAccess.Level int accessLevel, int callingUid) {
    // We've been using pure XT stats long enough that we no longer need to
    // splice DEV and XT together.
    final NetworkStatsHistory history = internalGetHistoryForNetwork(template, flags, FIELD_ALL, accessLevel, callingUid);
    final long now = System.currentTimeMillis();
    final NetworkStatsHistory.Entry entry = history.getValues(start, end, now, null);
    final NetworkStats stats = new NetworkStats(end - start, 1);
    stats.addValues(new NetworkStats.Entry(IFACE_ALL, UID_ALL, SET_ALL, TAG_NONE, METERED_ALL, ROAMING_ALL, entry.rxBytes, entry.rxPackets, entry.txBytes, entry.txPackets, entry.operations));
    return stats;
}
#end_block

#method_before
private NetworkStatsHistory internalGetHistoryForNetwork(NetworkTemplate template, int fields, @NetworkStatsAccess.Level int accessLevel) {
    // splice DEV and XT together.
    return mXtStatsCached.getHistory(template, UID_ALL, SET_ALL, TAG_NONE, fields, accessLevel);
}
#method_after
private NetworkStatsHistory internalGetHistoryForNetwork(NetworkTemplate template, int flags, int fields, @NetworkStatsAccess.Level int accessLevel, int callingUid) {
    // We've been using pure XT stats long enough that we no longer need to
    // splice DEV and XT together.
    final SubscriptionPlan augmentPlan = resolveSubscriptionPlan(template, flags);
    synchronized (mStatsLock) {
        return mXtStatsCached.getHistory(template, augmentPlan, UID_ALL, SET_ALL, TAG_NONE, fields, Long.MIN_VALUE, Long.MAX_VALUE, accessLevel, callingUid);
    }
}
#end_block

#method_before
@Override
public long getNetworkTotalBytes(NetworkTemplate template, long start, long end) {
    // Special case - since this is for internal use only, don't worry about a full access level
    // check and just require the signature/privileged permission.
    mContext.enforceCallingOrSelfPermission(READ_NETWORK_USAGE_HISTORY, TAG);
    assertBandwidthControlEnabled();
    return internalGetSummaryForNetwork(template, start, end, NetworkStatsAccess.Level.DEVICE).getTotalBytes();
}
#method_after
@Override
public long getNetworkTotalBytes(NetworkTemplate template, long start, long end) {
    // Special case - since this is for internal use only, don't worry about
    // a full access level check and just require the signature/privileged
    // permission.
    mContext.enforceCallingOrSelfPermission(READ_NETWORK_USAGE_HISTORY, TAG);
    assertBandwidthControlEnabled();
    // through the public API
    return internalGetSummaryForNetwork(template, NetworkStatsManager.FLAG_AUGMENT_WITH_SUBSCRIPTION_PLAN, start, end, NetworkStatsAccess.Level.DEVICE, Binder.getCallingUid()).getTotalBytes();
}
#end_block

#method_before
@Override
public void incrementOperationCount(int uid, int tag, int operationCount) {
    if (Binder.getCallingUid() != uid) {
        mContext.enforceCallingOrSelfPermission(MODIFY_NETWORK_ACCOUNTING, TAG);
    }
    if (operationCount < 0) {
        throw new IllegalArgumentException("operation count can only be incremented");
    }
    if (tag == TAG_NONE) {
        throw new IllegalArgumentException("operation count must have specific tag");
    }
    synchronized (mStatsLock) {
        final int set = mActiveUidCounterSet.get(uid, SET_DEFAULT);
        mUidOperations.combineValues(mActiveIface, uid, set, tag, 0L, 0L, 0L, 0L, operationCount);
        mUidOperations.combineValues(mActiveIface, uid, set, TAG_NONE, 0L, 0L, 0L, 0L, operationCount);
    }
}
#method_after
@Override
public void incrementOperationCount(int uid, int tag, int operationCount) {
    if (Binder.getCallingUid() != uid) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.UPDATE_DEVICE_STATS, TAG);
    }
    if (operationCount < 0) {
        throw new IllegalArgumentException("operation count can only be incremented");
    }
    if (tag == TAG_NONE) {
        throw new IllegalArgumentException("operation count must have specific tag");
    }
    synchronized (mStatsLock) {
        final int set = mActiveUidCounterSet.get(uid, SET_DEFAULT);
        mUidOperations.combineValues(mActiveIface, uid, set, tag, 0L, 0L, 0L, 0L, operationCount);
        mUidOperations.combineValues(mActiveIface, uid, set, TAG_NONE, 0L, 0L, 0L, 0L, operationCount);
    }
}
#end_block

#method_before
@Override
public void setUidForeground(int uid, boolean uidForeground) {
    mContext.enforceCallingOrSelfPermission(MODIFY_NETWORK_ACCOUNTING, TAG);
    synchronized (mStatsLock) {
        final int set = uidForeground ? SET_FOREGROUND : SET_DEFAULT;
        final int oldSet = mActiveUidCounterSet.get(uid, SET_DEFAULT);
        if (oldSet != set) {
            mActiveUidCounterSet.put(uid, set);
            setKernelCounterSet(uid, set);
        }
    }
}
#method_after
@Override
public void setUidForeground(int uid, boolean uidForeground) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    synchronized (mStatsLock) {
        final int set = uidForeground ? SET_FOREGROUND : SET_DEFAULT;
        final int oldSet = mActiveUidCounterSet.get(uid, SET_DEFAULT);
        if (oldSet != set) {
            mActiveUidCounterSet.put(uid, set);
            setKernelCounterSet(uid, set);
        }
    }
}
#end_block

#method_before
@Override
public void advisePersistThreshold(long thresholdBytes) {
    mContext.enforceCallingOrSelfPermission(MODIFY_NETWORK_ACCOUNTING, TAG);
    assertBandwidthControlEnabled();
    // clamp threshold into safe range
    mPersistThreshold = MathUtils.constrain(thresholdBytes, 128 * KB_IN_BYTES, 2 * MB_IN_BYTES);
    if (LOGV) {
        Slog.v(TAG, "advisePersistThreshold() given " + thresholdBytes + ", clamped to " + mPersistThreshold);
    }
    // update and persist if beyond new thresholds
    final long currentTime = mTime.hasCache() ? mTime.currentTimeMillis() : System.currentTimeMillis();
    synchronized (mStatsLock) {
        if (!mSystemReady)
            return;
        updatePersistThresholds();
        mDevRecorder.maybePersistLocked(currentTime);
        mXtRecorder.maybePersistLocked(currentTime);
        mUidRecorder.maybePersistLocked(currentTime);
        mUidTagRecorder.maybePersistLocked(currentTime);
    }
    // re-arm global alert
    registerGlobalAlert();
}
#method_after
@Override
public void advisePersistThreshold(long thresholdBytes) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    assertBandwidthControlEnabled();
    // clamp threshold into safe range
    mPersistThreshold = MathUtils.constrain(thresholdBytes, 128 * KB_IN_BYTES, 2 * MB_IN_BYTES);
    if (LOGV) {
        Slog.v(TAG, "advisePersistThreshold() given " + thresholdBytes + ", clamped to " + mPersistThreshold);
    }
    // update and persist if beyond new thresholds
    final long currentTime = mTime.hasCache() ? mTime.currentTimeMillis() : System.currentTimeMillis();
    synchronized (mStatsLock) {
        if (!mSystemReady)
            return;
        updatePersistThresholdsLocked();
        mDevRecorder.maybePersistLocked(currentTime);
        mXtRecorder.maybePersistLocked(currentTime);
        mUidRecorder.maybePersistLocked(currentTime);
        mUidTagRecorder.maybePersistLocked(currentTime);
    }
    // re-arm global alert
    registerGlobalAlert();
}
#end_block

#method_before
@Override
public long getUidStats(int uid, int type) {
    Slog.w(TAG, "calling native method from Stats Service");
    return nativeGetUidStat(uid, type);
}
#method_after
@Override
public long getUidStats(int uid, int type) {
    return nativeGetUidStat(uid, type);
}
#end_block

#method_before
@Override
public long getIfaceStats(String iface, int type) {
    Slog.w(TAG, "calling native method from Stats Service");
    return nativeGetIfaceStat(iface, type);
}
#method_after
@Override
public long getIfaceStats(String iface, int type) {
    return nativeGetIfaceStat(iface, type);
}
#end_block

#method_before
@Override
public long getTotalStats(int type) {
    Slog.w(TAG, "calling native method from Stats Service");
    return nativeGetTotalStat(type);
}
#method_after
@Override
public long getTotalStats(int type) {
    return nativeGetTotalStat(type);
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter rawWriter, String[] args) {
    if (!DumpUtils.checkDumpPermission(mContext, TAG, rawWriter))
        return;
    long duration = DateUtils.DAY_IN_MILLIS;
    final HashSet<String> argSet = new HashSet<String>();
    for (String arg : args) {
        argSet.add(arg);
        if (arg.startsWith("--duration=")) {
            try {
                duration = Long.parseLong(arg.substring(11));
            } catch (NumberFormatException ignored) {
            }
        }
    }
    // usage: dumpsys netstats --full --uid --tag --poll --checkin
    final boolean poll = argSet.contains("--poll") || argSet.contains("poll");
    final boolean checkin = argSet.contains("--checkin");
    final boolean fullHistory = argSet.contains("--full") || argSet.contains("full");
    final boolean includeUid = argSet.contains("--uid") || argSet.contains("detail");
    final boolean includeTag = argSet.contains("--tag") || argSet.contains("detail");
    final IndentingPrintWriter pw = new IndentingPrintWriter(rawWriter, "  ");
    synchronized (mStatsLock) {
        if (args.length > 0 && "--proto".equals(args[0])) {
            // In this case ignore all other arguments.
            dumpProto(fd);
            return;
        }
        if (poll) {
            performPollLocked(FLAG_PERSIST_ALL | FLAG_PERSIST_FORCE);
            pw.println("Forced poll");
            return;
        }
        if (checkin) {
            final long end = System.currentTimeMillis();
            final long start = end - duration;
            pw.print("v1,");
            pw.print(start / SECOND_IN_MILLIS);
            pw.print(',');
            pw.print(end / SECOND_IN_MILLIS);
            pw.println();
            pw.println("xt");
            mXtRecorder.dumpCheckin(rawWriter, start, end);
            if (includeUid) {
                pw.println("uid");
                mUidRecorder.dumpCheckin(rawWriter, start, end);
            }
            if (includeTag) {
                pw.println("tag");
                mUidTagRecorder.dumpCheckin(rawWriter, start, end);
            }
            return;
        }
        pw.println("Active interfaces:");
        pw.increaseIndent();
        for (int i = 0; i < mActiveIfaces.size(); i++) {
            pw.printPair("iface", mActiveIfaces.keyAt(i));
            pw.printPair("ident", mActiveIfaces.valueAt(i));
            pw.println();
        }
        pw.decreaseIndent();
        pw.println("Active UID interfaces:");
        pw.increaseIndent();
        for (int i = 0; i < mActiveUidIfaces.size(); i++) {
            pw.printPair("iface", mActiveUidIfaces.keyAt(i));
            pw.printPair("ident", mActiveUidIfaces.valueAt(i));
            pw.println();
        }
        pw.decreaseIndent();
        pw.println("Dev stats:");
        pw.increaseIndent();
        mDevRecorder.dumpLocked(pw, fullHistory);
        pw.decreaseIndent();
        pw.println("Xt stats:");
        pw.increaseIndent();
        mXtRecorder.dumpLocked(pw, fullHistory);
        pw.decreaseIndent();
        if (includeUid) {
            pw.println("UID stats:");
            pw.increaseIndent();
            mUidRecorder.dumpLocked(pw, fullHistory);
            pw.decreaseIndent();
        }
        if (includeTag) {
            pw.println("UID tag stats:");
            pw.increaseIndent();
            mUidTagRecorder.dumpLocked(pw, fullHistory);
            pw.decreaseIndent();
        }
    }
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter rawWriter, String[] args) {
    if (!DumpUtils.checkDumpPermission(mContext, TAG, rawWriter))
        return;
    long duration = DateUtils.DAY_IN_MILLIS;
    final HashSet<String> argSet = new HashSet<String>();
    for (String arg : args) {
        argSet.add(arg);
        if (arg.startsWith("--duration=")) {
            try {
                duration = Long.parseLong(arg.substring(11));
            } catch (NumberFormatException ignored) {
            }
        }
    }
    // usage: dumpsys netstats --full --uid --tag --poll --checkin
    final boolean poll = argSet.contains("--poll") || argSet.contains("poll");
    final boolean checkin = argSet.contains("--checkin");
    final boolean fullHistory = argSet.contains("--full") || argSet.contains("full");
    final boolean includeUid = argSet.contains("--uid") || argSet.contains("detail");
    final boolean includeTag = argSet.contains("--tag") || argSet.contains("detail");
    final IndentingPrintWriter pw = new IndentingPrintWriter(rawWriter, "  ");
    synchronized (mStatsLock) {
        if (args.length > 0 && "--proto".equals(args[0])) {
            // In this case ignore all other arguments.
            dumpProtoLocked(fd);
            return;
        }
        if (poll) {
            performPollLocked(FLAG_PERSIST_ALL | FLAG_PERSIST_FORCE);
            pw.println("Forced poll");
            return;
        }
        if (checkin) {
            final long end = System.currentTimeMillis();
            final long start = end - duration;
            pw.print("v1,");
            pw.print(start / SECOND_IN_MILLIS);
            pw.print(',');
            pw.print(end / SECOND_IN_MILLIS);
            pw.println();
            pw.println("xt");
            mXtRecorder.dumpCheckin(rawWriter, start, end);
            if (includeUid) {
                pw.println("uid");
                mUidRecorder.dumpCheckin(rawWriter, start, end);
            }
            if (includeTag) {
                pw.println("tag");
                mUidTagRecorder.dumpCheckin(rawWriter, start, end);
            }
            return;
        }
        pw.println("Active interfaces:");
        pw.increaseIndent();
        for (int i = 0; i < mActiveIfaces.size(); i++) {
            pw.printPair("iface", mActiveIfaces.keyAt(i));
            pw.printPair("ident", mActiveIfaces.valueAt(i));
            pw.println();
        }
        pw.decreaseIndent();
        pw.println("Active UID interfaces:");
        pw.increaseIndent();
        for (int i = 0; i < mActiveUidIfaces.size(); i++) {
            pw.printPair("iface", mActiveUidIfaces.keyAt(i));
            pw.printPair("ident", mActiveUidIfaces.valueAt(i));
            pw.println();
        }
        pw.decreaseIndent();
        pw.println("Dev stats:");
        pw.increaseIndent();
        mDevRecorder.dumpLocked(pw, fullHistory);
        pw.decreaseIndent();
        pw.println("Xt stats:");
        pw.increaseIndent();
        mXtRecorder.dumpLocked(pw, fullHistory);
        pw.decreaseIndent();
        if (includeUid) {
            pw.println("UID stats:");
            pw.increaseIndent();
            mUidRecorder.dumpLocked(pw, fullHistory);
            pw.decreaseIndent();
        }
        if (includeTag) {
            pw.println("UID tag stats:");
            pw.increaseIndent();
            mUidTagRecorder.dumpLocked(pw, fullHistory);
            pw.decreaseIndent();
        }
    }
}
#end_block

