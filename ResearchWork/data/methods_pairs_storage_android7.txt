278
#method_before
public static void createAllMedia(Context context) {
    createMediaMetadataCompat("Jazz_In_Paris", "Jazz in Paris", "Media Right Productions", "Jazz & Blues", "Jazz", 103, TimeUnit.SECONDS, "jazz_in_paris.mp3", R.drawable.album_jazz_blues, "album_jazz_blues", context);
    createMediaMetadataCompat("The_Coldest_Shoulder", "The Coldest Shoulder", "The 126ers", "Youtube Audio Library Rock 2", "Rock", 160, TimeUnit.SECONDS, "the_coldest_shoulder.mp3", R.drawable.album_youtube_audio_library_rock_2, "album_youtube_audio_library_rock_2", context);
}
#method_after
public static void createAllMedia(Context context) {
    createMediaMetadataCompat(context, "Jazz_In_Paris", "Jazz in Paris", "Media Right Productions", "Jazz & Blues", "Jazz", 103, TimeUnit.SECONDS, "jazz_in_paris.mp3", R.drawable.album_jazz_blues, "album_jazz_blues");
    createMediaMetadataCompat(context, "The_Coldest_Shoulder", "The Coldest Shoulder", "The 126ers", "Youtube Audio Library Rock 2", "Rock", 160, TimeUnit.SECONDS, "the_coldest_shoulder.mp3", R.drawable.album_youtube_audio_library_rock_2, "album_youtube_audio_library_rock_2");
}
#end_block

#method_before
private static void createMediaMetadataCompat(String mediaId, String title, String artist, String album, String genre, long duration, TimeUnit durationUnit, String musicFilename, int albumArtResId, String albumArtResName, Context ctx) {
    music.put(mediaId, new MediaMetadataCompat.Builder().putString(MediaMetadataCompat.METADATA_KEY_MEDIA_ID, mediaId).putString(MediaMetadataCompat.METADATA_KEY_MEDIA_URI, mediaId).putString(MediaMetadataCompat.METADATA_KEY_ALBUM, album).putString(MediaMetadataCompat.METADATA_KEY_ARTIST, artist).putLong(MediaMetadataCompat.METADATA_KEY_DURATION, TimeUnit.MILLISECONDS.convert(duration, durationUnit)).putString(MediaMetadataCompat.METADATA_KEY_GENRE, genre).putString(MediaMetadataCompat.METADATA_KEY_ALBUM_ART_URI, getAlbumArtUri(albumArtResName)).putString(MediaMetadataCompat.METADATA_KEY_DISPLAY_ICON_URI, getAlbumArtUri(albumArtResName)).putString(MediaMetadataCompat.METADATA_KEY_TITLE, title).putBitmap(MediaMetadataCompat.METADATA_KEY_ALBUM_ART, BitmapFactory.decodeResource(ctx.getResources(), albumArtResId)).build());
    albumRes.put(mediaId, albumArtResId);
    musicFileName.put(mediaId, musicFilename);
}
#method_after
private static void createMediaMetadataCompat(Context context, String mediaId, String title, String artist, String album, String genre, long duration, TimeUnit durationUnit, String musicFilename, int albumArtResId, String albumArtResName) {
    music.put(mediaId, new MediaMetadataCompat.Builder().putString(MediaMetadataCompat.METADATA_KEY_MEDIA_ID, mediaId).putString(MediaMetadataCompat.METADATA_KEY_MEDIA_URI, mediaId).putString(MediaMetadataCompat.METADATA_KEY_ALBUM, album).putString(MediaMetadataCompat.METADATA_KEY_ARTIST, artist).putLong(MediaMetadataCompat.METADATA_KEY_DURATION, TimeUnit.MILLISECONDS.convert(duration, durationUnit)).putString(MediaMetadataCompat.METADATA_KEY_GENRE, genre).putString(MediaMetadataCompat.METADATA_KEY_ALBUM_ART_URI, getAlbumArtUri(albumArtResName)).putString(MediaMetadataCompat.METADATA_KEY_DISPLAY_ICON_URI, getAlbumArtUri(albumArtResName)).putString(MediaMetadataCompat.METADATA_KEY_TITLE, title).putBitmap(MediaMetadataCompat.METADATA_KEY_ALBUM_ART, BitmapFactory.decodeResource(context.getResources(), albumArtResId)).build());
    albumRes.put(mediaId, albumArtResId);
    musicFileName.put(mediaId, musicFilename);
}
#end_block

#method_before
@Override
public void onLoadItem(String itemId, @NonNull Result<MediaBrowserCompat.MediaItem> result) {
    for (MediaBrowserCompat.MediaItem item : MusicLibrary.getMediaItems()) {
        if (item.getDescription().getMediaId().equals(itemId)) {
            result.sendResult(item);
        }
    }
}
#method_after
@Override
public void onLoadItem(String itemId, @NonNull Result<MediaBrowserCompat.MediaItem> result) {
    for (MediaBrowserCompat.MediaItem item : MusicLibrary.getMediaItems()) {
        if (item.getDescription().getMediaId().equals(itemId)) {
            result.sendResult(item);
            return;
        }
    }
    result.sendResult(null);
}
#end_block

#method_before
@Override
public void onSearch(@NonNull String query, Bundle extras, @NonNull Result<List<MediaBrowserCompat.MediaItem>> result) {
    List<MediaBrowserCompat.MediaItem> searchResults = new ArrayList<>();
    for (MediaBrowserCompat.MediaItem item : MusicLibrary.getMediaItems()) {
        final MediaDescriptionCompat description = item.getDescription();
        final String mediaTitle = description.getTitle().toString().toLowerCase();
        final String mediaArtist = description.getSubtitle().toString().toLowerCase();
        query = query.toLowerCase();
        if (mediaTitle.contains(query) || mediaArtist.contains(query)) {
            searchResults.add(item);
        }
    }
    result.sendResult(searchResults);
}
#method_after
@Override
public void onSearch(@NonNull String query, Bundle extras, @NonNull Result<List<MediaBrowserCompat.MediaItem>> result) {
    final List<MediaBrowserCompat.MediaItem> searchResults = new ArrayList<>();
    for (MediaBrowserCompat.MediaItem item : MusicLibrary.getMediaItems()) {
        final MediaDescriptionCompat description = item.getDescription();
        final String mediaTitle = description.getTitle().toString().toLowerCase();
        final String mediaArtist = description.getSubtitle().toString().toLowerCase();
        query = query.toLowerCase();
        if (mediaTitle.contains(query) || mediaArtist.contains(query)) {
            searchResults.add(item);
        }
    }
    result.sendResult(searchResults);
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.mr_cast_dialog);
    mCloseButton = findViewById(R.id.mr_cast_close_button);
    mCloseButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    mStopCastingButton = findViewById(R.id.mr_cast_stop_button);
    mStopCastingButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mRoute.isSelected()) {
                mRouter.unselect(MediaRouter.UNSELECT_REASON_STOPPED);
            }
            dismiss();
        }
    });
    mAdapter = new RecyclerAdapter();
    mRecyclerView = findViewById(R.id.mr_cast_list);
    mRecyclerView.setAdapter(mAdapter);
    mRecyclerView.setLayoutManager(new LinearLayoutManager(mContext));
    mVolumeChangeListener = new VolumeChangeListener();
    mVolumeSliderColor = MediaRouterThemeHelper.getControllerColor(mContext, 0);
    mRouteItemViewMap = new HashMap<>();
    mMetadataLayout = findViewById(R.id.mr_cast_meta);
    mArtView = findViewById(R.id.mr_cast_meta_art);
    mTitleView = findViewById(R.id.mr_cast_meta_title);
    mSubtitleView = findViewById(R.id.mr_cast_meta_subtitle);
    Resources res = mContext.getResources();
    mTitlePlaceholder = res.getString(R.string.mr_cast_dialog_title_view_placeholder);
    mCreated = true;
    updateLayout();
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.mr_cast_dialog);
    mCloseButton = findViewById(R.id.mr_cast_close_button);
    mCloseButton.setColorFilter(COLOR_WHITE_ON_DARK_BACKGROUND);
    mCloseButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    mStopCastingButton = findViewById(R.id.mr_cast_stop_button);
    mStopCastingButton.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mStopCastingButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mRoute.isSelected()) {
                mRouter.unselect(MediaRouter.UNSELECT_REASON_STOPPED);
            }
            dismiss();
        }
    });
    mAdapter = new RecyclerAdapter();
    mRecyclerView = findViewById(R.id.mr_cast_list);
    mRecyclerView.setAdapter(mAdapter);
    mRecyclerView.setLayoutManager(new LinearLayoutManager(mContext));
    mVolumeChangeListener = new VolumeChangeListener();
    mVolumeSliderColor = MediaRouterThemeHelper.getControllerColor(mContext, 0);
    mViewHolderMap = new HashMap<>();
    mMetadataLayout = findViewById(R.id.mr_cast_meta);
    mArtView = findViewById(R.id.mr_cast_meta_art);
    mTitleView = findViewById(R.id.mr_cast_meta_title);
    mTitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mSubtitleView = findViewById(R.id.mr_cast_meta_subtitle);
    mSubtitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    Resources res = mContext.getResources();
    mTitlePlaceholder = res.getString(R.string.mr_cast_dialog_title_view_placeholder);
    mCreated = true;
    updateLayout();
}
#end_block

#method_before
@Nullable
MediaRouteVolumeSlider getVolumeSlider(MediaRouter.RouteInfo route) {
    View itemView = mRouteItemViewMap.get(route);
    if (itemView == null) {
        return null;
    }
    MediaRouteVolumeSlider volumeSlider = itemView.findViewById(R.id.mr_cast_volume_slider);
    return volumeSlider;
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
@Nullable
MediaRouteVolumeSlider getVolumeSlider(@NonNull MediaRouter.RouteInfo route) {
    MediaRouteVolumeSliderHolder volumeSliderHolder = mViewHolderMap.get(route.getId());
    return (volumeSliderHolder == null) ? null : volumeSliderHolder.getVolumeSlider();
}
#end_block

#method_before
void update() {
    if (mRouteForTouchedVolumeSlider != null) {
        mHasPendingUpdate = true;
        return;
    }
    mHasPendingUpdate = false;
    if (!mRoute.isSelected() || mRoute.isDefaultOrBluetooth()) {
        Log.i("jiwon", "dismiss");
        dismiss();
        return;
    }
    if (!mCreated) {
        return;
    }
    if (mArtIconIsLoaded) {
        if (isBitmapRecycled(mArtIconLoadedBitmap)) {
            mArtView.setVisibility(View.GONE);
            Log.w(TAG, "Can't set artwork image with recycled bitmap: " + mArtIconLoadedBitmap);
        } else {
            mArtView.setVisibility(View.VISIBLE);
            mArtView.setImageBitmap(mArtIconLoadedBitmap);
            mArtView.setBackgroundColor(mArtIconBackgroundColor);
            mMetadataLayout.setBackgroundDrawable(new BitmapDrawable(mArtIconLoadedBitmap));
        }
        clearLoadedBitmap();
    } else {
        // Update metadata layout
        mArtView.setVisibility(View.GONE);
    }
    MediaRouteVolumeSlider groupVolumeSlider = getVolumeSlider(mRoute);
    if (groupVolumeSlider != null) {
        groupVolumeSlider.setMax(mRoute.getVolumeMax());
        groupVolumeSlider.setProgress(mRoute.getVolume());
    }
    updateMetadataLayout();
}
#method_after
void update() {
    if (mRouteForTouchedVolumeSlider != null) {
        mHasPendingUpdate = true;
        return;
    }
    mHasPendingUpdate = false;
    if (!mRoute.isSelected() || mRoute.isDefaultOrBluetooth()) {
        dismiss();
        return;
    }
    if (!mCreated) {
        return;
    }
    if (mArtIconIsLoaded) {
        if (isBitmapRecycled(mArtIconLoadedBitmap)) {
            mArtView.setVisibility(View.GONE);
            Log.w(TAG, "Can't set artwork image with recycled bitmap: " + mArtIconLoadedBitmap);
        } else {
            mArtView.setVisibility(View.VISIBLE);
            mArtView.setImageBitmap(mArtIconLoadedBitmap);
            mArtView.setBackgroundColor(mArtIconBackgroundColor);
            mMetadataLayout.setBackgroundDrawable(new BitmapDrawable(mArtIconLoadedBitmap));
        }
        clearLoadedBitmap();
    } else {
        // Update metadata layout
        mArtView.setVisibility(View.GONE);
    }
    updateMetadataLayout();
}
#end_block

#method_before
@Override
public void onStartTrackingTouch(SeekBar seekBar) {
    if (mRouteForTouchedVolumeSlider != null) {
        MediaRouteVolumeSlider volumeSlider = getVolumeSlider(mRoute);
        if (volumeSlider != null) {
            volumeSlider.removeCallbacks(mStopTrackingTouch);
        }
    }
    mRouteForTouchedVolumeSlider = (MediaRouter.RouteInfo) seekBar.getTag();
}
#method_after
@Override
public void onStartTrackingTouch(SeekBar seekBar) {
    if (mRouteForTouchedVolumeSlider != null) {
        mHandler.removeCallbacks(mStopTrackingTouch);
    }
    mRouteForTouchedVolumeSlider = (MediaRouter.RouteInfo) seekBar.getTag();
}
#end_block

#method_before
@Override
public void onStopTrackingTouch(SeekBar seekBar) {
    // Defer resetting mVolumeSliderTouched to allow the media route provider
    // a little time to settle into its new state and publish the final
    // volume update.
    MediaRouteVolumeSlider volumeSlider = getVolumeSlider(mRoute);
    if (volumeSlider != null) {
        volumeSlider.postDelayed(mStopTrackingTouch, VOLUME_UPDATE_DELAY_MS);
    }
}
#method_after
@Override
public void onStopTrackingTouch(SeekBar seekBar) {
    mHandler.postDelayed(mStopTrackingTouch, VOLUME_UPDATE_DELAY_MS);
}
#end_block

#method_before
@Override
public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
    int viewType = getItemViewType(position);
    Item item = getItem(position);
    switch(viewType) {
        case ITEM_TYPE_GROUP_VOLUME:
            ((GroupVolumeViewHolder) holder).bindGroupVolumeViewHolder(item);
            break;
        case ITEM_TYPE_HEADER:
            ((HeaderViewHolder) holder).bindHeaderViewHolder(item);
            break;
        case ITEM_TYPE_ROUTE:
            ((RouteViewHolder) holder).bindRouteViewHolder(item);
            break;
        case ITEM_TYPE_GROUP:
            ((GroupViewHolder) holder).bindGroupViewHolder(item);
            break;
        default:
            Log.w(TAG, "Cannot bind item to ViewHolder because of wrong view type");
    }
}
#method_after
@Override
public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
    int viewType = getItemViewType(position);
    Item item = getItem(position);
    switch(viewType) {
        case ITEM_TYPE_GROUP_VOLUME:
            {
                MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
                mViewHolderMap.put(route.getId(), (MediaRouteVolumeSliderHolder) holder);
                ((GroupVolumeViewHolder) holder).bindGroupVolumeViewHolder(item);
                break;
            }
        case ITEM_TYPE_HEADER:
            {
                ((HeaderViewHolder) holder).bindHeaderViewHolder(item);
                break;
            }
        case ITEM_TYPE_ROUTE:
            {
                MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
                mViewHolderMap.put(route.getId(), (MediaRouteVolumeSliderHolder) holder);
                ((RouteViewHolder) holder).bindRouteViewHolder(item);
                break;
            }
        case ITEM_TYPE_GROUP:
            {
                ((GroupViewHolder) holder).bindGroupViewHolder(item);
                break;
            }
        default:
            {
                Log.w(TAG, "Cannot bind item to ViewHolder because of wrong view type");
                break;
            }
    }
}
#end_block

#method_before
public void bindGroupVolumeViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    mTextView.setText(route.getName().toUpperCase());
    mGroupVolumeSlider.setTag(route);
    mGroupVolumeSlider.setColor(mVolumeSliderColor);
    mGroupVolumeSlider.setProgress(mRoute.getVolume());
    mGroupVolumeSlider.setOnSeekBarChangeListener(mVolumeChangeListener);
    // Remove entry with same value, since entry with same value but different key can
    // cause wrong update of the itemView.
    mRouteItemViewMap.values().remove(mItemView);
    mRouteItemViewMap.put(route, mItemView);
}
#method_after
public void bindGroupVolumeViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    mTextView.setText(route.getName().toUpperCase());
    mGroupVolumeSlider.setTag(route);
    mGroupVolumeSlider.setColor(mVolumeSliderColor);
    mGroupVolumeSlider.setMax(route.getVolumeMax());
    mGroupVolumeSlider.setProgress(route.getVolume());
    mGroupVolumeSlider.setOnSeekBarChangeListener(mVolumeChangeListener);
}
#end_block

#method_before
public void bindRouteViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    boolean selected = isSelectedRoute(route);
    mImageView.setImageDrawable(getIconDrawable(route));
    mTextView.setText(route.getName());
    mVolumeSlider.setTag(route);
    mVolumeSlider.setColor(mVolumeSliderColor);
    mVolumeSlider.setProgress(route.getVolume());
    mVolumeSlider.setOnSeekBarChangeListener(mVolumeChangeListener);
    mVolumeSliderLayout.setVisibility(selected ? View.VISIBLE : View.GONE);
    mCheckBox.setOnClickListener(mCheckBoxClickListener);
    // TODO(b/111624415): Make CheckBox works for both selected and unselected routes.
    if (selected) {
        mCheckBox.setChecked(true);
        mCheckBox.setEnabled(true);
    } else {
        mCheckBox.setEnabled(false);
    }
    // Remove entry with same value, since entry with same value but different key can
    // cause wrong update of the itemView.
    mRouteItemViewMap.values().remove(mItemView);
    mRouteItemViewMap.put(route, mItemView);
}
#method_after
public void bindRouteViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    String routeId = route.getId();
    boolean selected = isSelectedRoute(route);
    mImageView.setImageDrawable(getIconDrawable(route));
    mTextView.setText(route.getName());
    mVolumeSlider.setTag(route);
    mVolumeSlider.setColor(mVolumeSliderColor);
    mVolumeSlider.setMax(route.getVolumeMax());
    mVolumeSlider.setProgress(route.getVolume());
    mVolumeSlider.setOnSeekBarChangeListener(mVolumeChangeListener);
    mVolumeSliderLayout.setVisibility(selected ? View.VISIBLE : View.GONE);
    mCheckBox.setOnClickListener(mCheckBoxClickListener);
    // TODO(b/111624415): Make CheckBox works for both selected and unselected routes.
    if (selected) {
        mCheckBox.setChecked(true);
        mCheckBox.setEnabled(true);
    } else {
        mCheckBox.setEnabled(false);
    }
}
#end_block

#method_before
@Override
public void onRouteVolumeChanged(MediaRouter router, MediaRouter.RouteInfo route) {
    MediaRouteVolumeSlider volumeSlider = getVolumeSlider(route);
    if (volumeSlider != null && mRouteForTouchedVolumeSlider != route) {
        int volume = route.getVolume();
        volumeSlider.setProgress(volume);
    }
}
#method_after
@Override
public void onRouteVolumeChanged(MediaRouter router, MediaRouter.RouteInfo route) {
    MediaRouteVolumeSlider volumeSlider = getVolumeSlider(route);
    int volume = route.getVolume();
    if (DEBUG) {
        Log.d(TAG, "onRouteVolumeChanged(), route.getVolume:" + volume);
    }
    if (volumeSlider != null && mRouteForTouchedVolumeSlider != route) {
        volumeSlider.setProgress(volume);
    }
}
#end_block

#method_before
@Nullable
public Locale getFirstMatch(String[] supportedLocales) {
    return mImpl.getFirstMatch(supportedLocales);
}
#method_after
@Nullable
public Locale getFirstMatch(@NonNull String[] supportedLocales) {
    return mImpl.getFirstMatch(supportedLocales);
}
#end_block

#method_before
@Override
public boolean equals(Object other) {
    return mImpl.equals(other);
}
#method_after
@Override
public boolean equals(Object other) {
    return other instanceof LocaleListCompat && mImpl.equals(((LocaleListCompat) other).mImpl);
}
#end_block

#method_before
@Override
public Locale getFirstMatch(String[] supportedLocales) {
    return computeFirstMatch(Arrays.asList(supportedLocales), false);
}
#method_after
@Override
public Locale getFirstMatch(@NonNull String[] supportedLocales) {
    return computeFirstMatch(Arrays.asList(supportedLocales), false);
}
#end_block

#method_before
@Override
public boolean equals(Object other) {
    return mLocaleList.equals(((LocaleListCompat) other).unwrap());
}
#method_after
@Override
public boolean equals(Object other) {
    return mLocaleList.equals(((LocaleListInterface) other).getLocaleList());
}
#end_block

#method_before
@Nullable
@Override
public Locale getFirstMatch(String[] supportedLocales) {
    if (mLocaleList != null) {
        return mLocaleList.getFirstMatch(supportedLocales);
    }
    return null;
}
#method_after
@Nullable
@Override
public Locale getFirstMatch(@NonNull String[] supportedLocales) {
    if (mLocaleList != null) {
        return mLocaleList.getFirstMatch(supportedLocales);
    }
    return null;
}
#end_block

#method_before
@Override
public Slice onBindSlice(Uri sliceUri) {
    switch(sliceUri.getPath()) {
        case "/set_flag":
            SliceTest.sFlag = true;
            break;
        case "/subslice":
            Builder b = new Builder(sliceUri);
            return b.addSubSlice(new Slice.Builder(b).build(), "subslice").build();
        case "/text":
            return new Slice.Builder(sliceUri).addText("Expected text", "text").build();
        case "/prohibited_span":
            {
                SpannableStringBuilder spannableStringBuilder = new SpannableStringBuilder();
                spannableStringBuilder.append("Expected text");
                spannableStringBuilder.setSpan(new AbsoluteSizeSpan(1000), 0, spannableStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
                return new Slice.Builder(sliceUri).addText(new SpannedString(spannableStringBuilder), "text").build();
            }
        case "/icon":
            return new Slice.Builder(sliceUri).addIcon(IconCompat.createWithResource(getContext(), R.drawable.size_48x48), "icon").build();
        case "/icon_null":
            return new Slice.Builder(sliceUri).addIcon(null, "icon").build();
        case "/icon_invalid":
            return new Slice.Builder(sliceUri).addIcon(IconCompat.createWithResource(getContext(), 0), "icon").build();
        case "/action":
            Builder builder = new Builder(sliceUri);
            Slice subSlice = new Slice.Builder(builder).build();
            PendingIntent broadcast = PendingIntent.getBroadcast(getContext(), 0, new Intent(getContext().getPackageName() + ".action"), 0);
            return builder.addAction(broadcast, subSlice, "action").build();
        case "/int":
            return new Slice.Builder(sliceUri).addInt(0xff121212, "int").build();
        case "/timestamp":
            return new Slice.Builder(sliceUri).addTimestamp(43, "timestamp").build();
        case "/hints":
            return new Slice.Builder(sliceUri).addHints(HINT_LIST).addText("Text", null, HINT_TITLE).addIcon(IconCompat.createWithResource(getContext(), R.drawable.size_48x48), null, HINT_NO_TINT, HINT_LARGE).build();
    }
    return new Slice.Builder(sliceUri).build();
}
#method_after
@Override
public Slice onBindSlice(Uri sliceUri) {
    switch(sliceUri.getPath()) {
        case "/set_flag":
            SliceTest.sFlag = true;
            break;
        case "/subslice":
            Builder b = new Builder(sliceUri);
            return b.addSubSlice(new Slice.Builder(b).build(), "subslice").build();
        case "/text":
            return new Slice.Builder(sliceUri).addText("Expected text", "text").build();
        case "/prohibited_span":
            SpannableStringBuilder spannableStringBuilder = new SpannableStringBuilder();
            spannableStringBuilder.append("Expected text");
            spannableStringBuilder.setSpan(new AbsoluteSizeSpan(1000), 0, spannableStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
            return new Slice.Builder(sliceUri).addText(new SpannedString(spannableStringBuilder), "text").build();
        case "/icon":
            return new Slice.Builder(sliceUri).addIcon(IconCompat.createWithResource(getContext(), R.drawable.size_48x48), "icon").build();
        case "/icon_null":
            return new Slice.Builder(sliceUri).addIcon(null, "icon").build();
        case "/icon_invalid":
            return new Slice.Builder(sliceUri).addIcon(IconCompat.createWithResource(getContext(), 0), "icon").build();
        case "/action":
            Builder builder = new Builder(sliceUri);
            Slice subSlice = new Slice.Builder(builder).build();
            PendingIntent broadcast = PendingIntent.getBroadcast(getContext(), 0, new Intent(getContext().getPackageName() + ".action"), 0);
            return builder.addAction(broadcast, subSlice, "action").build();
        case "/int":
            return new Slice.Builder(sliceUri).addInt(0xff121212, "int").build();
        case "/timestamp":
            return new Slice.Builder(sliceUri).addTimestamp(43, "timestamp").build();
        case "/hints":
            return new Slice.Builder(sliceUri).addHints(HINT_LIST).addText("Text", null, HINT_TITLE).addIcon(IconCompat.createWithResource(getContext(), R.drawable.size_48x48), null, HINT_NO_TINT, HINT_LARGE).build();
    }
    return new Slice.Builder(sliceUri).build();
}
#end_block

#method_before
@Override
public void run() {
    if (mWorkContinuation.hasCycles()) {
        throw new IllegalStateException(String.format("WorkContinuation has cycles (%s)", mWorkContinuation));
    }
    boolean needsScheduling = addToDatabase();
    if (needsScheduling) {
        // Enable RescheduleReceiver, only when there are Worker's that need scheduling.
        final Context context = mWorkContinuation.getWorkManagerImpl().getApplicationContext();
        WorkManagerTaskExecutor.getInstance().postToMainThread(new Runnable() {

            @Override
            public void run() {
                PackageManagerHelper.setComponentEnabled(context, RescheduleReceiver.class, true);
            }
        });
        scheduleWorkInBackground();
    }
}
#method_after
@Override
public void run() {
    if (mWorkContinuation.hasCycles()) {
        throw new IllegalStateException(String.format("WorkContinuation has cycles (%s)", mWorkContinuation));
    }
    boolean needsScheduling = addToDatabase();
    if (needsScheduling) {
        // Enable RescheduleReceiver, only when there are Worker's that need scheduling.
        final Context context = mWorkContinuation.getWorkManagerImpl().getApplicationContext();
        PackageManagerHelper.setComponentEnabled(context, RescheduleReceiver.class, true);
        scheduleWorkInBackground();
    }
}
#end_block

#method_before
private static boolean enqueueWorkWithPrerequisites(WorkManagerImpl workManagerImpl, @NonNull List<? extends WorkRequest> workList, String[] prerequisiteIds, String name, ExistingWorkPolicy existingWorkPolicy) {
    long currentTimeMillis = System.currentTimeMillis();
    WorkDatabase workDatabase = workManagerImpl.getWorkDatabase();
    boolean hasPrerequisite = (prerequisiteIds != null && prerequisiteIds.length > 0);
    boolean hasCompletedAllPrerequisites = true;
    boolean hasFailedPrerequisites = false;
    boolean hasCancelledPrerequisites = false;
    if (hasPrerequisite) {
        // chain of work could have been wiped out already.
        for (String id : prerequisiteIds) {
            WorkSpec prerequisiteWorkSpec = workDatabase.workSpecDao().getWorkSpec(id);
            if (prerequisiteWorkSpec == null) {
                Logger.error(TAG, String.format("Prerequisite %s doesn't exist; not enqueuing", id));
                return false;
            }
            State prerequisiteState = prerequisiteWorkSpec.state;
            hasCompletedAllPrerequisites &= (prerequisiteState == SUCCEEDED);
            if (prerequisiteState == FAILED) {
                hasFailedPrerequisites = true;
            } else if (prerequisiteState == CANCELLED) {
                hasCancelledPrerequisites = true;
            }
        }
    }
    boolean isNamed = !TextUtils.isEmpty(name);
    // We only apply existing work policies for unique tag sequences that are the beginning of
    // chains.
    boolean shouldApplyExistingWorkPolicy = isNamed && !hasPrerequisite;
    if (shouldApplyExistingWorkPolicy) {
        // Get everything with the unique tag.
        List<WorkSpec.IdAndState> existingWorkSpecIdAndStates = workDatabase.workSpecDao().getWorkSpecIdAndStatesForName(name);
        if (!existingWorkSpecIdAndStates.isEmpty()) {
            // If appending, these are the new prerequisites.
            if (existingWorkPolicy == APPEND) {
                DependencyDao dependencyDao = workDatabase.dependencyDao();
                List<String> newPrerequisiteIds = new ArrayList<>();
                for (WorkSpec.IdAndState idAndState : existingWorkSpecIdAndStates) {
                    if (!dependencyDao.hasDependents(idAndState.id)) {
                        hasCompletedAllPrerequisites &= (idAndState.state == SUCCEEDED);
                        if (idAndState.state == FAILED) {
                            hasFailedPrerequisites = true;
                        } else if (idAndState.state == CANCELLED) {
                            hasCancelledPrerequisites = true;
                        }
                        newPrerequisiteIds.add(idAndState.id);
                    }
                }
                prerequisiteIds = newPrerequisiteIds.toArray(prerequisiteIds);
                hasPrerequisite = (prerequisiteIds.length > 0);
            } else {
                // enqueued or running.
                if (existingWorkPolicy == KEEP) {
                    for (WorkSpec.IdAndState idAndState : existingWorkSpecIdAndStates) {
                        if (idAndState.state == ENQUEUED || idAndState.state == RUNNING) {
                            return false;
                        }
                    }
                }
                // Cancel all of these workers.
                CancelWorkRunnable.forName(name, workManagerImpl).run();
                // And delete all the database records.
                WorkSpecDao workSpecDao = workDatabase.workSpecDao();
                for (WorkSpec.IdAndState idAndState : existingWorkSpecIdAndStates) {
                    workSpecDao.delete(idAndState.id);
                }
            }
        }
    }
    boolean needsScheduling = false;
    for (WorkRequest work : workList) {
        WorkSpec workSpec = work.getWorkSpec();
        if (hasPrerequisite && !hasCompletedAllPrerequisites) {
            if (hasFailedPrerequisites) {
                workSpec.state = FAILED;
            } else if (hasCancelledPrerequisites) {
                workSpec.state = CANCELLED;
            } else {
                workSpec.state = BLOCKED;
            }
        } else {
            // Set scheduled times only for work without prerequisites. Dependent work
            // will set their scheduled times when they are unblocked.
            workSpec.periodStartTime = currentTimeMillis;
        }
        if (Build.VERSION.SDK_INT >= 23 && Build.VERSION.SDK_INT <= 25) {
            tryDelegateConstrainedWorkSpec(workSpec);
        }
        // If we have one WorkSpec with an enqueued state, then we need to schedule.
        if (workSpec.state == ENQUEUED) {
            needsScheduling = true;
        }
        workDatabase.workSpecDao().insertWorkSpec(workSpec);
        if (hasPrerequisite) {
            for (String prerequisiteId : prerequisiteIds) {
                Dependency dep = new Dependency(work.getStringId(), prerequisiteId);
                workDatabase.dependencyDao().insertDependency(dep);
            }
        }
        for (String tag : work.getTags()) {
            workDatabase.workTagDao().insert(new WorkTag(tag, work.getStringId()));
        }
        if (isNamed) {
            workDatabase.workNameDao().insert(new WorkName(name, work.getStringId()));
        }
    }
    return needsScheduling;
}
#method_after
private static boolean enqueueWorkWithPrerequisites(WorkManagerImpl workManagerImpl, @NonNull List<? extends WorkRequest> workList, String[] prerequisiteIds, String name, ExistingWorkPolicy existingWorkPolicy) {
    boolean needsScheduling = false;
    long currentTimeMillis = System.currentTimeMillis();
    WorkDatabase workDatabase = workManagerImpl.getWorkDatabase();
    boolean hasPrerequisite = (prerequisiteIds != null && prerequisiteIds.length > 0);
    boolean hasCompletedAllPrerequisites = true;
    boolean hasFailedPrerequisites = false;
    boolean hasCancelledPrerequisites = false;
    if (hasPrerequisite) {
        // chain of work could have been wiped out already.
        for (String id : prerequisiteIds) {
            WorkSpec prerequisiteWorkSpec = workDatabase.workSpecDao().getWorkSpec(id);
            if (prerequisiteWorkSpec == null) {
                Logger.error(TAG, String.format("Prerequisite %s doesn't exist; not enqueuing", id));
                return false;
            }
            State prerequisiteState = prerequisiteWorkSpec.state;
            hasCompletedAllPrerequisites &= (prerequisiteState == SUCCEEDED);
            if (prerequisiteState == FAILED) {
                hasFailedPrerequisites = true;
            } else if (prerequisiteState == CANCELLED) {
                hasCancelledPrerequisites = true;
            }
        }
    }
    boolean isNamed = !TextUtils.isEmpty(name);
    // We only apply existing work policies for unique tag sequences that are the beginning of
    // chains.
    boolean shouldApplyExistingWorkPolicy = isNamed && !hasPrerequisite;
    if (shouldApplyExistingWorkPolicy) {
        // Get everything with the unique tag.
        List<WorkSpec.IdAndState> existingWorkSpecIdAndStates = workDatabase.workSpecDao().getWorkSpecIdAndStatesForName(name);
        if (!existingWorkSpecIdAndStates.isEmpty()) {
            // If appending, these are the new prerequisites.
            if (existingWorkPolicy == APPEND) {
                DependencyDao dependencyDao = workDatabase.dependencyDao();
                List<String> newPrerequisiteIds = new ArrayList<>();
                for (WorkSpec.IdAndState idAndState : existingWorkSpecIdAndStates) {
                    if (!dependencyDao.hasDependents(idAndState.id)) {
                        hasCompletedAllPrerequisites &= (idAndState.state == SUCCEEDED);
                        if (idAndState.state == FAILED) {
                            hasFailedPrerequisites = true;
                        } else if (idAndState.state == CANCELLED) {
                            hasCancelledPrerequisites = true;
                        }
                        newPrerequisiteIds.add(idAndState.id);
                    }
                }
                prerequisiteIds = newPrerequisiteIds.toArray(prerequisiteIds);
                hasPrerequisite = (prerequisiteIds.length > 0);
            } else {
                // enqueued or running.
                if (existingWorkPolicy == KEEP) {
                    for (WorkSpec.IdAndState idAndState : existingWorkSpecIdAndStates) {
                        if (idAndState.state == ENQUEUED || idAndState.state == RUNNING) {
                            return false;
                        }
                    }
                }
                // Cancel all of these workers.
                // Don't allow rescheduling in CancelWorkRunnable because it will happen inside
                // the current transasction.  We want it to happen separately to avoid race
                // conditions (see ag/4502245, which tries to avoid work trying to run before
                // it's actually been committed to the database).
                CancelWorkRunnable.forName(name, workManagerImpl, false).run();
                // Because we cancelled some work but didn't allow rescheduling inside
                // CancelWorkRunnable, we need to make sure we do schedule work at the end of
                // this runnable.
                needsScheduling = true;
                // And delete all the database records.
                WorkSpecDao workSpecDao = workDatabase.workSpecDao();
                for (WorkSpec.IdAndState idAndState : existingWorkSpecIdAndStates) {
                    workSpecDao.delete(idAndState.id);
                }
            }
        }
    }
    for (WorkRequest work : workList) {
        WorkSpec workSpec = work.getWorkSpec();
        if (hasPrerequisite && !hasCompletedAllPrerequisites) {
            if (hasFailedPrerequisites) {
                workSpec.state = FAILED;
            } else if (hasCancelledPrerequisites) {
                workSpec.state = CANCELLED;
            } else {
                workSpec.state = BLOCKED;
            }
        } else {
            // Set scheduled times only for work without prerequisites. Dependent work
            // will set their scheduled times when they are unblocked.
            workSpec.periodStartTime = currentTimeMillis;
        }
        if (Build.VERSION.SDK_INT >= 23 && Build.VERSION.SDK_INT <= 25) {
            tryDelegateConstrainedWorkSpec(workSpec);
        }
        // If we have one WorkSpec with an enqueued state, then we need to schedule.
        if (workSpec.state == ENQUEUED) {
            needsScheduling = true;
        }
        workDatabase.workSpecDao().insertWorkSpec(workSpec);
        if (hasPrerequisite) {
            for (String prerequisiteId : prerequisiteIds) {
                Dependency dep = new Dependency(work.getStringId(), prerequisiteId);
                workDatabase.dependencyDao().insertDependency(dep);
            }
        }
        for (String tag : work.getTags()) {
            workDatabase.workTagDao().insert(new WorkTag(tag, work.getStringId()));
        }
        if (isNamed) {
            workDatabase.workNameDao().insert(new WorkName(name, work.getStringId()));
        }
    }
    return needsScheduling;
}
#end_block

#method_before
private void notifyListener(final boolean isSuccessful, final boolean needsReschedule) {
    if (mListener == null) {
        return;
    }
    try {
        // Check to see if there is more work to be done. If there is no more work, then
        // disable RescheduleReceiver. Using a transaction here, as there could be more than
        // one thread looking at the list of eligible WorkSpecs.
        mWorkDatabase.beginTransaction();
        List<String> unfinishedWork = mWorkDatabase.workSpecDao().getAllUnfinishedWork();
        final boolean noMoreWork = unfinishedWork == null || unfinishedWork.isEmpty();
        WorkManagerTaskExecutor.getInstance().postToMainThread(new Runnable() {

            @Override
            public void run() {
                if (noMoreWork) {
                    PackageManagerHelper.setComponentEnabled(mAppContext, RescheduleReceiver.class, false);
                }
                mListener.onExecuted(mWorkSpecId, isSuccessful, needsReschedule);
            }
        });
        mWorkDatabase.setTransactionSuccessful();
    } finally {
        mWorkDatabase.endTransaction();
    }
}
#method_after
private void notifyListener(final boolean isSuccessful, final boolean needsReschedule) {
    if (mListener == null) {
        return;
    }
    try {
        // IMPORTANT: We are using a transaction here as to ensure that we have some guarantees
        // about the state of the world before we disable RescheduleReceiver.
        // Check to see if there is more work to be done. If there is no more work, then
        // disable RescheduleReceiver. Using a transaction here, as there could be more than
        // one thread looking at the list of eligible WorkSpecs.
        mWorkDatabase.beginTransaction();
        List<String> unfinishedWork = mWorkDatabase.workSpecDao().getAllUnfinishedWork();
        boolean noMoreWork = unfinishedWork == null || unfinishedWork.isEmpty();
        if (noMoreWork) {
            PackageManagerHelper.setComponentEnabled(mAppContext, RescheduleReceiver.class, false);
        }
        WorkManagerTaskExecutor.getInstance().postToMainThread(new Runnable() {

            @Override
            public void run() {
                mListener.onExecuted(mWorkSpecId, isSuccessful, needsReschedule);
            }
        });
        mWorkDatabase.setTransactionSuccessful();
    } finally {
        mWorkDatabase.endTransaction();
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public <T> T get(String path, Type responseType) throws IOException {
    HttpRequestFactory requestFactory = getHttpRequestFactory(getCredentialsIfPresent());
    GenericUrl url = new GenericUrl(URI.create(API_URL + "/" + path));
    try {
        HttpRequest httpRequest = requestFactory.buildGetRequest(url);
        HttpResponse response = httpRequest.execute();
        return (T) response.parseAs(responseType);
    } catch (IOException e) {
        throw new IOException("Error running get API operation " + path, e);
    }
}
#method_after
@SuppressWarnings("unchecked")
public <T> T get(String path, Type responseType) throws IOException {
    HttpRequestFactory requestFactory = getHttpRequestFactory();
    GenericUrl url = new GenericUrl(URI.create(API_URL + "/" + path));
    try {
        HttpRequest httpRequest = requestFactory.buildGetRequest(url);
        HttpResponse response = httpRequest.execute();
        return (T) response.parseAs(responseType);
    } catch (IOException e) {
        throw new IOException("Error running get API operation " + path, e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public <T> T post(String path, Object request, Type responseType) throws IOException {
    HttpRequestFactory requestFactory = getHttpRequestFactory(getCredentialsIfPresent());
    GenericUrl url = new GenericUrl(URI.create(API_URL + "/" + path));
    HttpContent httpContent = new ByteArrayContent("application/json", new Gson().toJson(request).getBytes(Charsets.UTF_8));
    try {
        HttpRequest httpRequest = requestFactory.buildPostRequest(url, httpContent);
        HttpResponse response = httpRequest.execute();
        return (T) response.parseAs(responseType);
    } catch (IOException e) {
        throw new IOException("Error running post API operation " + path, e);
    }
}
#method_after
@SuppressWarnings("unchecked")
public <T> T post(String path, Object request, Type responseType) throws IOException {
    HttpRequestFactory requestFactory = getHttpRequestFactory();
    GenericUrl url = new GenericUrl(URI.create(API_URL + "/" + path));
    HttpContent httpContent = new ByteArrayContent("application/json", new Gson().toJson(request).getBytes(Charsets.UTF_8));
    try {
        HttpRequest httpRequest = requestFactory.buildPostRequest(url, httpContent);
        HttpResponse response = httpRequest.execute();
        return (T) response.parseAs(responseType);
    } catch (IOException e) {
        throw new IOException("Error running post API operation " + path, e);
    }
}
#end_block

#method_before
public String postFile(String path, String fileType, String testFilePath) throws IOException {
    HttpRequestFactory requestFactory = getHttpRequestFactory(getCredentialsIfPresent());
    FileContent fileContent = new FileContent(fileType, new File(testFilePath));
    GenericUrl url = new GenericUrl(URI.create(API_URL + "/" + path));
    HttpRequest request = requestFactory.buildPostRequest(url, fileContent);
    return request.execute().parseAsString();
}
#method_after
public String postFile(String path, String fileType, String testFilePath) throws IOException {
    HttpRequestFactory requestFactory = getHttpRequestFactory();
    FileContent fileContent = new FileContent(fileType, new File(testFilePath));
    GenericUrl url = new GenericUrl(URI.create(API_URL + "/" + path));
    HttpRequest request = requestFactory.buildPostRequest(url, fileContent);
    return request.execute().parseAsString();
}
#end_block

#method_before
public String postMultiFiles(String path, Map<String, String> testFileMap) throws IOException {
    HttpRequestFactory requestFactory = getHttpRequestFactory(getCredentialsIfPresent());
    MultipartContent multipartContent = new MultipartContent();
    for (Map.Entry<String, String> entry : testFileMap.entrySet()) {
        FileContent fileContent = new FileContent(entry.getKey(), new File(entry.getValue()));
        Part part = new Part(fileContent);
        part.setHeaders(new HttpHeaders().set("Content-Disposition", String.format("form-data; name=\"content\"; filename=\"%s\"", entry.getValue())));
        multipartContent.addPart(part);
    }
    GenericUrl url = new GenericUrl(URI.create(API_URL + "/" + path));
    HttpRequest request = requestFactory.buildPostRequest(url, multipartContent);
    return request.execute().parseAsString();
}
#method_after
public String postMultiFiles(String path, Map<String, String> testFileMap) throws IOException {
    HttpRequestFactory requestFactory = getHttpRequestFactory();
    MultipartContent multipartContent = new MultipartContent();
    for (Map.Entry<String, String> entry : testFileMap.entrySet()) {
        FileContent fileContent = new FileContent(entry.getKey(), new File(entry.getValue()));
        Part part = new Part(fileContent);
        part.setHeaders(new HttpHeaders().set("Content-Disposition", String.format("form-data; name=\"content\"; filename=\"%s\"", entry.getValue())));
        multipartContent.addPart(part);
    }
    GenericUrl url = new GenericUrl(URI.create(API_URL + "/" + path));
    HttpRequest request = requestFactory.buildPostRequest(url, multipartContent);
    return request.execute().parseAsString();
}
#end_block

#method_before
private HttpRequestFactory getHttpRequestFactory(@Nullable UserPassword userPassword) {
    return httpTransport.createRequestFactory(request -> {
        request.setConnectTimeout((int) Duration.ofMinutes(1).toMillis());
        request.setReadTimeout((int) Duration.ofMinutes(1).toMillis());
        HttpHeaders httpHeaders = new HttpHeaders();
        if (userPassword != null) {
            httpHeaders.setBasicAuthentication(userPassword.getUsername(), userPassword.getPassword_BeCareful());
        }
        request.setHeaders(httpHeaders);
        request.setParser(new JacksonFactory().createJsonObjectParser());
    });
}
#method_after
protected HttpRequestFactory getHttpRequestFactory() {
    return httpTransport.createRequestFactory(request -> {
        request.setConnectTimeout((int) Duration.ofMinutes(1).toMillis());
        request.setReadTimeout((int) Duration.ofMinutes(1).toMillis());
        HttpHeaders httpHeaders = new HttpHeaders();
        request.setHeaders(httpHeaders);
        request.setParser(new JacksonFactory().createJsonObjectParser());
    });
}
#end_block

#method_before
private String GetToken() {
    String keyFilePath;
    try {
        keyFilePath = mConfigReader.GetVendorConfigVariable("service_key_json_path");
    } catch (NoSuchElementException e) {
        return null;
    }
    JsonFactory jsonFactory = JacksonFactory.getDefaultInstance();
    Credential credential = null;
    try {
        List<String> listStrings = new LinkedList<String>();
        listStrings.add(PLUS_ME);
        credential = GoogleCredential.fromStream(new FileInputStream(keyFilePath)).createScoped(listStrings);
        credential.refreshToken();
        return credential.getAccessToken();
    } catch (FileNotFoundException e) {
        CLog.e(String.format("Service key file %s doesn't exist.", keyFilePath));
    } catch (IOException e) {
        CLog.e(String.format("Can't read the service key file, %s", keyFilePath));
    }
    return null;
}
#method_after
private String GetToken() {
    String keyFilePath;
    try {
        keyFilePath = mConfigReader.GetVendorConfigVariable("service_key_json_path");
    } catch (NoSuchElementException e) {
        return null;
    }
    JsonFactory jsonFactory = JacksonFactory.getDefaultInstance();
    Credential credential = null;
    try {
        List<String> listStrings = new LinkedList<>();
        listStrings.add(PLUS_ME);
        credential = GoogleCredential.fromStream(new FileInputStream(keyFilePath)).createScoped(listStrings);
        credential.refreshToken();
        return credential.getAccessToken();
    } catch (FileNotFoundException e) {
        CLog.e(String.format("Service key file %s doesn't exist.", keyFilePath));
    } catch (IOException e) {
        CLog.e(String.format("Can't read the service key file, %s", keyFilePath));
    }
    return null;
}
#end_block

#method_before
public void Upload(DashboardPostMessage message) {
    String dashboardCurlCommand = mConfigReader.GetVendorConfigVariable("dashboard_use_curl_command");
    message.setAccessToken(GetToken());
    try {
        String messageFilePath = WriteToTempFile(Base64.getEncoder().encodeToString(message.toByteArray()).getBytes());
        if (dashboardCurlCommand.equals("true")) {
            CurlUpload(messageFilePath);
        } else {
            Upload(messageFilePath);
        }
    } catch (IOException e) {
        CLog.e("Couldn't write a proto message to a temp file.");
    }
}
#method_after
public void Upload(DashboardPostMessage message) {
    String dashboardCurlCommand = mConfigReader.GetVendorConfigVariable("dashboard_use_curl_command");
    Optional<String> dashboardCurlCommandOpt = Optional.of(dashboardCurlCommand);
    Boolean curlCommandCheck = Boolean.parseBoolean(dashboardCurlCommandOpt.orElse("false"));
    message.setAccessToken(GetToken());
    String messageFilePath = "";
    try {
        messageFilePath = WriteToTempFile(Base64.getEncoder().encodeToString(message.toByteArray()).getBytes());
    } catch (IOException e) {
        CLog.e("Couldn't write a proto message to a temp file.");
    }
    if (Strings.isNullOrEmpty(messageFilePath)) {
        CLog.e("Couldn't get the MessageFilePath.");
    } else {
        if (curlCommandCheck) {
            CurlUpload(messageFilePath);
        } else {
            Upload(messageFilePath);
        }
    }
}
#end_block

#method_before
public void Upload(String messageFilePath) {
    try {
        vtsDashboardApiTransport.postFile("/api/datastore", "application/octet-stream", messageFilePath);
    } catch (IOException e) {
        CLog.e("Error occurred on uploading dashboard message file." + e.getLocalizedMessage());
    }
}
#method_after
public Boolean Upload(String messageFilePath) {
    try {
        String response = vtsDashboardApiTransport.postFile("/api/datastore", "application/octet-stream", messageFilePath);
        CLog.d(String.format("Upload Result : %s", response));
        return true;
    } catch (IOException e) {
        CLog.e("Error occurred on uploading dashboard message file!");
        CLog.e(e.getLocalizedMessage());
        return false;
    }
}
#end_block

#method_before
public void CurlUpload(String messageFilePath) {
    try {
        String commandTemplate = mConfigReader.GetVendorConfigVariable("dashboard_post_command");
        commandTemplate = commandTemplate.replace("{path}", messageFilePath);
        // removes ', while keeping any substrings quoted by "".
        commandTemplate = commandTemplate.replace("'", "");
        CLog.d(String.format("Upload command: %s", commandTemplate));
        List<String> commandList = new ArrayList<String>();
        Matcher matcher = Pattern.compile("([^\"]\\S*|\".+?\")\\s*").matcher(commandTemplate);
        while (matcher.find()) {
            commandList.add(matcher.group(1));
        }
        CommandResult c = mRunUtil.runTimedCmd(BASE_TIMEOUT_MSECS * 3, (String[]) commandList.toArray(new String[commandList.size()]));
        if (c == null || c.getStatus() != CommandStatus.SUCCESS) {
            CLog.e("Uploading the test plan execution result to GAE DB faiied.");
            CLog.e("Stdout: %s", c.getStdout());
            CLog.e("Stderr: %s", c.getStderr());
        }
        FileUtil.deleteFile(new File(messageFilePath));
    } catch (NoSuchElementException e) {
        CLog.e("dashboard_post_command unspecified in vendor config.");
    }
}
#method_after
@Deprecated
public void CurlUpload(String messageFilePath) {
    try {
        String commandTemplate = mConfigReader.GetVendorConfigVariable("dashboard_post_command");
        commandTemplate = commandTemplate.replace("{path}", messageFilePath);
        // removes ', while keeping any substrings quoted by "".
        commandTemplate = commandTemplate.replace("'", "");
        CLog.d(String.format("Upload command: %s", commandTemplate));
        List<String> commandList = new ArrayList<String>();
        Matcher matcher = Pattern.compile("([^\"]\\S*|\".+?\")\\s*").matcher(commandTemplate);
        while (matcher.find()) {
            commandList.add(matcher.group(1));
        }
        CommandResult c = mRunUtil.runTimedCmd(BASE_TIMEOUT_MSECS * 3, (String[]) commandList.toArray(new String[commandList.size()]));
        if (c == null || c.getStatus() != CommandStatus.SUCCESS) {
            CLog.e("Uploading the test plan execution result to GAE DB faiied.");
            CLog.e("Stdout: %s", c.getStdout());
            CLog.e("Stderr: %s", c.getStderr());
        }
        FileUtil.deleteFile(new File(messageFilePath));
    } catch (NoSuchElementException e) {
        CLog.e("dashboard_post_command unspecified in vendor config.");
    }
}
#end_block

#method_before
private int readBytes() throws IOException {
    bb.compact();
    try {
        if (ch != null) {
            // Read from the channel
            // Android-changed: Use ChannelInputStream.read to make sure we throw
            // IllegalBlockingModeException for non-blocking channels.
            // int n = ch.read(bb);
            int n = sun.nio.ch.ChannelInputStream.read(ch, bb, true);
            if (n < 0)
                return n;
        } else {
            // Read from the input stream, and then update the buffer
            int lim = bb.limit();
            int pos = bb.position();
            assert (pos <= lim);
            int rem = (pos <= lim ? lim - pos : 0);
            assert rem > 0;
            int n = in.read(bb.array(), bb.arrayOffset() + pos, rem);
            if (n < 0)
                return n;
            if (n == 0)
                throw new IOException("Underlying input stream returned zero bytes");
            assert (n <= rem) : "n = " + n + ", rem = " + rem;
            bb.position(pos + n);
        }
    } finally {
        // Flip even when an IOException is thrown,
        // otherwise the stream will stutter
        bb.flip();
    }
    int rem = bb.remaining();
    assert (rem != 0) : rem;
    return rem;
}
#method_after
private int readBytes() throws IOException {
    bb.compact();
    try {
        if (ch != null) {
            // Read from the channel
            // Android-changed: Use ChannelInputStream.read which throws on non-blocking channels.
            // Other implementations of ReadableByteChannel.read do not, and Channels.newReader
            // is documented to throw on non-blocking.
            // int n = ch.read(bb);
            int n = sun.nio.ch.ChannelInputStream.read(ch, bb, true);
            if (n < 0)
                return n;
        } else {
            // Read from the input stream, and then update the buffer
            int lim = bb.limit();
            int pos = bb.position();
            assert (pos <= lim);
            int rem = (pos <= lim ? lim - pos : 0);
            assert rem > 0;
            int n = in.read(bb.array(), bb.arrayOffset() + pos, rem);
            if (n < 0)
                return n;
            if (n == 0)
                throw new IOException("Underlying input stream returned zero bytes");
            assert (n <= rem) : "n = " + n + ", rem = " + rem;
            bb.position(pos + n);
        }
    } finally {
        // Flip even when an IOException is thrown,
        // otherwise the stream will stutter
        bb.flip();
    }
    int rem = bb.remaining();
    assert (rem != 0) : rem;
    return rem;
}
#end_block

#method_before
int implRead(char[] cbuf, int off, int end) throws IOException {
    // to deal with it here.
    assert (end - off > 1);
    CharBuffer cb = CharBuffer.wrap(cbuf, off, end - off);
    if (cb.position() != 0)
        // Ensure that cb[0] == cbuf[off]
        cb = cb.slice();
    // BEGIN Android-added: Flush the CharsetDecoder correctly.
    if (needsFlush) {
        CoderResult cr = decoder.flush(cb);
        if (cr.isOverflow()) {
            // We've overflowed, we'll have to come back round and ask for more data.
            return cb.position();
        }
        // By definition, we're at the end of the stream here.
        if (cr.isUnderflow()) {
            if (cb.position() == 0) {
                return -1;
            }
            return cb.position();
        }
        cr.throwException();
    // Unreachable.
    }
    // END Android-added: Flush the CharsetDecoder properly.
    boolean eof = false;
    for (; ; ) {
        CoderResult cr = decoder.decode(bb, cb, eof);
        if (cr.isUnderflow()) {
            if (eof)
                break;
            if (!cb.hasRemaining())
                break;
            if ((cb.position() > 0) && !inReady())
                // Block at most once
                break;
            int n = readBytes();
            if (n < 0) {
                eof = true;
            // Android-removed: Flush the CharsetDecoder correctly.
            // We want to go 'round the loop one more time with "eof = true".
            // We also don't want to reset the decoder here because we might potentially need
            // to flush it later.
            // if ((cb.position() == 0) && (!bb.hasRemaining()))
            // break;
            // decoder.reset();
            }
            continue;
        }
        if (cr.isOverflow()) {
            assert cb.position() > 0;
            break;
        }
        cr.throwException();
    }
    if (eof) {
        // BEGIN Android-changed: Flush the CharsetDecoder correctly.
        // ## Need to flush decoder
        // decoder.reset();
        CoderResult cr = decoder.flush(cb);
        if (cr.isOverflow()) {
            needsFlush = true;
            return cb.position();
        }
        decoder.reset();
        if (!cr.isUnderflow()) {
            cr.throwException();
        }
    // END Android-changed: Flush the CharsetDecoder correctly.
    }
    if (cb.position() == 0) {
        if (eof)
            return -1;
        assert false;
    }
    return cb.position();
}
#method_after
int implRead(char[] cbuf, int off, int end) throws IOException {
    // to deal with it here.
    assert (end - off > 1);
    CharBuffer cb = CharBuffer.wrap(cbuf, off, end - off);
    if (cb.position() != 0)
        // Ensure that cb[0] == cbuf[off]
        cb = cb.slice();
    // BEGIN Android-added: Flush the CharsetDecoder correctly.
    if (needsFlush) {
        CoderResult cr = decoder.flush(cb);
        if (cr.isOverflow()) {
            // We've overflowed, we'll have to come back round and ask for more data.
            return cb.position();
        }
        // By definition, we're at the end of the stream here.
        if (cr.isUnderflow()) {
            if (cb.position() == 0) {
                return -1;
            }
            return cb.position();
        }
        cr.throwException();
    // Unreachable.
    }
    // END Android-added: Flush the CharsetDecoder properly.
    boolean eof = false;
    for (; ; ) {
        CoderResult cr = decoder.decode(bb, cb, eof);
        if (cr.isUnderflow()) {
            if (eof)
                break;
            if (!cb.hasRemaining())
                break;
            if ((cb.position() > 0) && !inReady())
                // Block at most once
                break;
            int n = readBytes();
            if (n < 0) {
                eof = true;
            // Android-removed: Flush the CharsetDecoder correctly.
            // We want to go 'round the loop one more time with "eof = true".
            // We also don't want to reset the decoder here because we might potentially need
            // to flush it later.
            // if ((cb.position() == 0) && (!bb.hasRemaining()))
            // break;
            // decoder.reset();
            }
            continue;
        }
        if (cr.isOverflow()) {
            assert cb.position() > 0;
            break;
        }
        cr.throwException();
    }
    if (eof) {
        // BEGIN Android-changed: Flush the CharsetDecoder correctly.
        // // ## Need to flush decoder
        // decoder.reset();
        CoderResult cr = decoder.flush(cb);
        if (cr.isOverflow()) {
            needsFlush = true;
            return cb.position();
        }
        decoder.reset();
        if (!cr.isUnderflow()) {
            cr.throwException();
        }
    // END Android-changed: Flush the CharsetDecoder correctly.
    }
    if (cb.position() == 0) {
        if (eof)
            return -1;
        assert false;
    }
    return cb.position();
}
#end_block

#method_before
public CryptoObject getCryptoObject() {
    return mCryptoObject;
}
#method_after
@Nullable
public CryptoObject getCryptoObject() {
    return mCryptoObject;
}
#end_block

#method_before
public void onAuthenticationError(int errorCode, CharSequence errString) {
}
#method_after
public void onAuthenticationError(@BiometricError int errorCode, @NonNull CharSequence errString) {
}
#end_block

#method_before
public void onAuthenticationSucceeded(AuthenticationResult result) {
}
#method_after
public void onAuthenticationSucceeded(@NonNull AuthenticationResult result) {
}
#end_block

#method_before
public Builder setTitle(@NonNull CharSequence title) {
    mBundle.putCharSequence(KEY_TITLE, title);
    return this;
}
#method_after
@NonNull
public Builder setTitle(@NonNull CharSequence title) {
    mBundle.putCharSequence(KEY_TITLE, title);
    return this;
}
#end_block

#method_before
public Builder setSubtitle(@NonNull CharSequence subtitle) {
    mBundle.putCharSequence(KEY_SUBTITLE, subtitle);
    return this;
}
#method_after
@NonNull
public Builder setSubtitle(@Nullable CharSequence subtitle) {
    mBundle.putCharSequence(KEY_SUBTITLE, subtitle);
    return this;
}
#end_block

#method_before
public Builder setDescription(@NonNull CharSequence description) {
    mBundle.putCharSequence(KEY_DESCRIPTION, description);
    return this;
}
#method_after
@NonNull
public Builder setDescription(@Nullable CharSequence description) {
    mBundle.putCharSequence(KEY_DESCRIPTION, description);
    return this;
}
#end_block

#method_before
public Builder setNegativeButtonText(@NonNull CharSequence text) {
    mBundle.putCharSequence(KEY_NEGATIVE_TEXT, text);
    return this;
}
#method_after
@NonNull
public Builder setNegativeButtonText(@NonNull CharSequence text) {
    mBundle.putCharSequence(KEY_NEGATIVE_TEXT, text);
    return this;
}
#end_block

#method_before
public PromptInfo build() {
    final CharSequence title = mBundle.getCharSequence(KEY_TITLE);
    final CharSequence negative = mBundle.getCharSequence(KEY_NEGATIVE_TEXT);
    if (TextUtils.isEmpty(title)) {
        throw new IllegalArgumentException("Title must be set and non-empty");
    } else if (TextUtils.isEmpty(negative)) {
        throw new IllegalArgumentException("Negative button text must be set and " + "non-empty");
    }
    return new PromptInfo(mBundle);
}
#method_after
@NonNull
public PromptInfo build() {
    final CharSequence title = mBundle.getCharSequence(KEY_TITLE);
    final CharSequence negative = mBundle.getCharSequence(KEY_NEGATIVE_TEXT);
    if (TextUtils.isEmpty(title)) {
        throw new IllegalArgumentException("Title must be set and non-empty");
    } else if (TextUtils.isEmpty(negative)) {
        throw new IllegalArgumentException("Negative button text must be set and " + "non-empty");
    }
    return new PromptInfo(mBundle);
}
#end_block

#method_before
public CharSequence getTitle() {
    return mBundle.getCharSequence(KEY_TITLE);
}
#method_after
@NonNull
public CharSequence getTitle() {
    return mBundle.getCharSequence(KEY_TITLE);
}
#end_block

#method_before
public CharSequence getSubtitle() {
    return mBundle.getCharSequence(KEY_SUBTITLE);
}
#method_after
@Nullable
public CharSequence getSubtitle() {
    return mBundle.getCharSequence(KEY_SUBTITLE);
}
#end_block

#method_before
public CharSequence getDescription() {
    return mBundle.getCharSequence(KEY_DESCRIPTION);
}
#method_after
@Nullable
public CharSequence getDescription() {
    return mBundle.getCharSequence(KEY_DESCRIPTION);
}
#end_block

#method_before
public CharSequence getNegativeButtonText() {
    return mBundle.getCharSequence(KEY_NEGATIVE_TEXT);
}
#method_after
@NonNull
public CharSequence getNegativeButtonText() {
    return mBundle.getCharSequence(KEY_NEGATIVE_TEXT);
}
#end_block

#method_before
@NonNull
public CommandButton build() {
    return new CommandButton(mCommand, mIconResId, mDisplayName, mExtras, mEnabled);
}
#method_after
@Override
@NonNull
public MediaSession2 build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = new MainHandlerExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new SessionCallback() {
        };
    }
    return new MediaSession2(mContext, mId, mPlayer, mPlaylistAgent, mSessionActivity, mCallbackExecutor, mCallback);
}
#end_block

#method_before
@Test
public void getSystemServiceName() {
    assertEquals(ACCESSIBILITY_SERVICE, ContextCompat.getSystemServiceName(mContext, AccessibilityService.class));
    assertEquals(ACCOUNT_SERVICE, ContextCompat.getSystemServiceName(mContext, AccountManager.class));
    assertEquals(ACTIVITY_SERVICE, ContextCompat.getSystemServiceName(mContext, ActivityManager.class));
    assertEquals(ALARM_SERVICE, ContextCompat.getSystemServiceName(mContext, AlarmManager.class));
    assertEquals(AUDIO_SERVICE, ContextCompat.getSystemServiceName(mContext, AudioManager.class));
    assertEquals(CLIPBOARD_SERVICE, ContextCompat.getSystemServiceName(mContext, ClipboardManager.class));
    assertEquals(CONNECTIVITY_SERVICE, ContextCompat.getSystemServiceName(mContext, ConnectivityManager.class));
    assertEquals(DEVICE_POLICY_SERVICE, ContextCompat.getSystemServiceName(mContext, DevicePolicyManager.class));
    assertEquals(DOWNLOAD_SERVICE, ContextCompat.getSystemServiceName(mContext, DownloadManager.class));
    assertEquals(DROPBOX_SERVICE, ContextCompat.getSystemServiceName(mContext, DropBoxManager.class));
    assertEquals(INPUT_METHOD_SERVICE, ContextCompat.getSystemServiceName(mContext, InputMethodManager.class));
    assertEquals(KEYGUARD_SERVICE, ContextCompat.getSystemServiceName(mContext, KeyguardManager.class));
    assertEquals(LAYOUT_INFLATER_SERVICE, ContextCompat.getSystemServiceName(mContext, LayoutInflater.class));
    assertEquals(LOCATION_SERVICE, ContextCompat.getSystemServiceName(mContext, LocationManager.class));
    assertEquals(NFC_SERVICE, ContextCompat.getSystemServiceName(mContext, NfcManager.class));
    assertEquals(NOTIFICATION_SERVICE, ContextCompat.getSystemServiceName(mContext, NotificationManager.class));
    assertEquals(POWER_SERVICE, ContextCompat.getSystemServiceName(mContext, PowerManager.class));
    assertEquals(SEARCH_SERVICE, ContextCompat.getSystemServiceName(mContext, SearchManager.class));
    assertEquals(SENSOR_SERVICE, ContextCompat.getSystemServiceName(mContext, SensorManager.class));
    assertEquals(STORAGE_SERVICE, ContextCompat.getSystemServiceName(mContext, StorageManager.class));
    assertEquals(TELEPHONY_SERVICE, ContextCompat.getSystemServiceName(mContext, TelephonyManager.class));
    assertEquals(TEXT_SERVICES_MANAGER_SERVICE, ContextCompat.getSystemServiceName(mContext, TextServicesManager.class));
    assertEquals(UI_MODE_SERVICE, ContextCompat.getSystemServiceName(mContext, UiModeManager.class));
    assertEquals(USB_SERVICE, ContextCompat.getSystemServiceName(mContext, UsbManager.class));
    assertEquals(VIBRATOR_SERVICE, ContextCompat.getSystemServiceName(mContext, Vibrator.class));
    assertEquals(WALLPAPER_SERVICE, ContextCompat.getSystemServiceName(mContext, WallpaperManager.class));
    assertEquals(WIFI_P2P_SERVICE, ContextCompat.getSystemServiceName(mContext, WifiP2pManager.class));
    assertEquals(WIFI_SERVICE, ContextCompat.getSystemServiceName(mContext, WifiManager.class));
    assertEquals(WINDOW_SERVICE, ContextCompat.getSystemServiceName(mContext, WindowManager.class));
}
#method_after
@Test
public void getSystemServiceName() {
    assertEquals(ACCESSIBILITY_SERVICE, ContextCompat.getSystemServiceName(mContext, AccessibilityManager.class));
    assertEquals(ACCOUNT_SERVICE, ContextCompat.getSystemServiceName(mContext, AccountManager.class));
    assertEquals(ACTIVITY_SERVICE, ContextCompat.getSystemServiceName(mContext, ActivityManager.class));
    assertEquals(ALARM_SERVICE, ContextCompat.getSystemServiceName(mContext, AlarmManager.class));
    assertEquals(AUDIO_SERVICE, ContextCompat.getSystemServiceName(mContext, AudioManager.class));
    assertEquals(CLIPBOARD_SERVICE, ContextCompat.getSystemServiceName(mContext, ClipboardManager.class));
    assertEquals(CONNECTIVITY_SERVICE, ContextCompat.getSystemServiceName(mContext, ConnectivityManager.class));
    assertEquals(DEVICE_POLICY_SERVICE, ContextCompat.getSystemServiceName(mContext, DevicePolicyManager.class));
    assertEquals(DOWNLOAD_SERVICE, ContextCompat.getSystemServiceName(mContext, DownloadManager.class));
    assertEquals(DROPBOX_SERVICE, ContextCompat.getSystemServiceName(mContext, DropBoxManager.class));
    assertEquals(INPUT_METHOD_SERVICE, ContextCompat.getSystemServiceName(mContext, InputMethodManager.class));
    assertEquals(KEYGUARD_SERVICE, ContextCompat.getSystemServiceName(mContext, KeyguardManager.class));
    assertEquals(LAYOUT_INFLATER_SERVICE, ContextCompat.getSystemServiceName(mContext, LayoutInflater.class));
    assertEquals(LOCATION_SERVICE, ContextCompat.getSystemServiceName(mContext, LocationManager.class));
    assertEquals(NFC_SERVICE, ContextCompat.getSystemServiceName(mContext, NfcManager.class));
    assertEquals(NOTIFICATION_SERVICE, ContextCompat.getSystemServiceName(mContext, NotificationManager.class));
    assertEquals(POWER_SERVICE, ContextCompat.getSystemServiceName(mContext, PowerManager.class));
    assertEquals(SEARCH_SERVICE, ContextCompat.getSystemServiceName(mContext, SearchManager.class));
    assertEquals(SENSOR_SERVICE, ContextCompat.getSystemServiceName(mContext, SensorManager.class));
    assertEquals(STORAGE_SERVICE, ContextCompat.getSystemServiceName(mContext, StorageManager.class));
    assertEquals(TELEPHONY_SERVICE, ContextCompat.getSystemServiceName(mContext, TelephonyManager.class));
    assertEquals(TEXT_SERVICES_MANAGER_SERVICE, ContextCompat.getSystemServiceName(mContext, TextServicesManager.class));
    assertEquals(UI_MODE_SERVICE, ContextCompat.getSystemServiceName(mContext, UiModeManager.class));
    assertEquals(USB_SERVICE, ContextCompat.getSystemServiceName(mContext, UsbManager.class));
    assertEquals(VIBRATOR_SERVICE, ContextCompat.getSystemServiceName(mContext, Vibrator.class));
    assertEquals(WALLPAPER_SERVICE, ContextCompat.getSystemServiceName(mContext, WallpaperManager.class));
    assertEquals(WIFI_P2P_SERVICE, ContextCompat.getSystemServiceName(mContext, WifiP2pManager.class));
    assertEquals(WIFI_SERVICE, ContextCompat.getSystemServiceName(mContext, WifiManager.class));
    assertEquals(WINDOW_SERVICE, ContextCompat.getSystemServiceName(mContext, WindowManager.class));
}
#end_block

#method_before
// //////////////////////////////////////////////
// //    MediaControllerCompat Methods       ////
// //////////////////////////////////////////////
public void addQueueItem(MediaDescriptionCompat description) {
    try {
        mBinder.addQueueItem(mControllerId, createBundleWithParcelable(description));
    } catch (RemoteException ex) {
        Log.e(TAG, "Failed to call addQueueItem()");
    }
}
#method_after
// //////////////////////////////////////////////////////////////////////////////
// MediaControllerCompat methods
// //////////////////////////////////////////////////////////////////////////////
public void addQueueItem(MediaDescriptionCompat description) {
    try {
        mBinder.addQueueItem(mControllerId, createBundleWithParcelable(description));
    } catch (RemoteException ex) {
        Log.e(TAG, "Failed to call addQueueItem()");
    }
}
#end_block

#method_before
// ////////////////////////////////
// //    Non-public methods    ////
// ////////////////////////////////
private boolean connect() {
    final Intent intent = new Intent(ACTION_MEDIA_CONTROLLER_COMPAT);
    intent.setComponent(REMOTE_MEDIA_CONTROLLER_COMPAT_SERVICE);
    boolean bound = false;
    try {
        bound = mContext.bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);
    } catch (Exception ex) {
        Log.e(TAG, "Failed to bind to the RemoteMediaControllerCompatService.");
    }
    if (bound) {
        try {
            mCountDownLatch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
        } catch (InterruptedException ex) {
            Log.e(TAG, "InterruptedException while waiting for onServiceConnected.", ex);
        }
    }
    return mBinder != null;
}
#method_after
// //////////////////////////////////////////////////////////////////////////////
// Non-public methods
// //////////////////////////////////////////////////////////////////////////////
private boolean connect() {
    final Intent intent = new Intent(ACTION_MEDIA_CONTROLLER_COMPAT);
    intent.setComponent(REMOTE_MEDIA_CONTROLLER_COMPAT_SERVICE);
    boolean bound = false;
    try {
        bound = mContext.bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE);
    } catch (Exception ex) {
        Log.e(TAG, "Failed to bind to the RemoteMediaControllerCompatService.");
    }
    if (bound) {
        try {
            mCountDownLatch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS);
        } catch (InterruptedException ex) {
            Log.e(TAG, "InterruptedException while waiting for onServiceConnected.", ex);
        }
    }
    return mBinder != null;
}
#end_block

#method_before
/**
 * {@link MediaControllerCompat} methods.
 */
@Override
public void addQueueItem(String controllerId, Bundle descriptionBundle) throws RemoteException {
    MediaControllerCompat controller = mMediaControllerCompatMap.get(controllerId);
    MediaDescriptionCompat desc = (MediaDescriptionCompat) getParcelable(descriptionBundle);
    controller.addQueueItem(desc);
}
#method_after
// //////////////////////////////////////////////////////////////////////////////
// MediaControllerCompat methods
// //////////////////////////////////////////////////////////////////////////////
@Override
public void addQueueItem(String controllerId, Bundle descriptionBundle) throws RemoteException {
    MediaControllerCompat controller = mMediaControllerCompatMap.get(controllerId);
    MediaDescriptionCompat desc = (MediaDescriptionCompat) getParcelable(descriptionBundle);
    controller.addQueueItem(desc);
}
#end_block

#method_before
/**
 * {@link MediaControllerCompat.TransportControls} methods.
 */
@Override
public void prepare(String controllerId) throws RemoteException {
    MediaControllerCompat controller = mMediaControllerCompatMap.get(controllerId);
    controller.getTransportControls().prepare();
}
#method_after
// //////////////////////////////////////////////////////////////////////////////
// MediaControllerCompat.TransportControls methods
// //////////////////////////////////////////////////////////////////////////////
@Override
public void prepare(String controllerId) throws RemoteException {
    MediaControllerCompat controller = mMediaControllerCompatMap.get(controllerId);
    controller.getTransportControls().prepare();
}
#end_block

#method_before
@VisibleForTesting
public boolean isCdmaSupported() {
    return mIsCdmaSupported;
}
#method_after
public boolean isCdmaSupported() {
    return mIsCdmaSupported;
}
#end_block

#method_before
@CddTest(requirement = "[7.5/C-1-1],[7.5.1/C-1-1],[7.5.2/C-1-1],[7.5.3/C-1-1]")
public void testCameraManagerGetDeviceIdList() throws Exception {
    // Test: that the getCameraIdList method runs without exceptions.
    String[] ids = mCameraManager.getCameraIdList();
    if (VERBOSE)
        Log.v(TAG, "CameraManager ids: " + Arrays.toString(ids));
    /**
     * Test: that if there is at least one reported id, then the system must have
     * the FEATURE_CAMERA_ANY feature.
     */
    assertTrue("System camera feature and camera id list don't match", ids.length == 0 || mPackageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY));
    /**
     * Test: that if the device has front or rear facing cameras, then there
     * must be matched system features.
     */
    for (int i = 0; i < ids.length; i++) {
        CameraCharacteristics props = mCameraManager.getCameraCharacteristics(ids[i]);
        assertNotNull("Can't get camera characteristics for camera " + ids[i], props);
        Integer lensFacing = props.get(CameraCharacteristics.LENS_FACING);
        assertNotNull("Can't get lens facing info", lensFacing);
        if (lensFacing == CameraCharacteristics.LENS_FACING_FRONT) {
            assertTrue("System doesn't have front camera feature", mPackageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA_FRONT));
        } else if (lensFacing == CameraCharacteristics.LENS_FACING_BACK) {
            assertTrue("System doesn't have back camera feature", mPackageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA));
        } else if (lensFacing == CameraCharacteristics.LENS_FACING_EXTERNAL) {
            assertTrue("System doesn't have external camera feature", mPackageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA_EXTERNAL));
        } else {
            fail("Unknown camera lens facing " + lensFacing.toString());
        }
    }
    /**
     * Test: that if there is one camera device, then the system must have some
     * specific features.
     */
    assertTrue("Missing system feature: FEATURE_CAMERA_ANY", ids.length == 0 || mPackageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY));
    assertTrue("Missing system feature: FEATURE_CAMERA, FEATURE_CAMERA_FRONT or FEATURE_CAMERA_EXTERNAL", ids.length == 0 || mPackageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA_FRONT) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA_EXTERNAL));
}
#method_after
public void testCameraManagerGetDeviceIdList() throws Exception {
    // Test: that the getCameraIdList method runs without exceptions.
    String[] ids = mCameraManager.getCameraIdList();
    if (VERBOSE)
        Log.v(TAG, "CameraManager ids: " + Arrays.toString(ids));
    /**
     * Test: that if there is at least one reported id, then the system must have
     * the FEATURE_CAMERA_ANY feature.
     */
    assertTrue("System camera feature and camera id list don't match", ids.length == 0 || mPackageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY));
    /**
     * Test: that if the device has front or rear facing cameras, then there
     * must be matched system features.
     */
    for (int i = 0; i < ids.length; i++) {
        CameraCharacteristics props = mCameraManager.getCameraCharacteristics(ids[i]);
        assertNotNull("Can't get camera characteristics for camera " + ids[i], props);
        Integer lensFacing = props.get(CameraCharacteristics.LENS_FACING);
        assertNotNull("Can't get lens facing info", lensFacing);
        if (lensFacing == CameraCharacteristics.LENS_FACING_FRONT) {
            assertTrue("System doesn't have front camera feature", mPackageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA_FRONT));
        } else if (lensFacing == CameraCharacteristics.LENS_FACING_BACK) {
            assertTrue("System doesn't have back camera feature", mPackageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA));
        } else if (lensFacing == CameraCharacteristics.LENS_FACING_EXTERNAL) {
            assertTrue("System doesn't have external camera feature", mPackageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA_EXTERNAL));
        } else {
            fail("Unknown camera lens facing " + lensFacing.toString());
        }
    }
    /**
     * Test: that if there is one camera device, then the system must have some
     * specific features.
     */
    assertTrue("Missing system feature: FEATURE_CAMERA_ANY", ids.length == 0 || mPackageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY));
    assertTrue("Missing system feature: FEATURE_CAMERA, FEATURE_CAMERA_FRONT or FEATURE_CAMERA_EXTERNAL", ids.length == 0 || mPackageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA_FRONT) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA_EXTERNAL));
}
#end_block

#method_before
@CddTest(requirement = "[7.5.4/C-0-1,C-0-2,C-0-3,C-0-6,7.5.1/C-2-1")
private void assertParameters(Parameters parameters) {
    // Parameters constants
    final int PICTURE_FORMAT = ImageFormat.JPEG;
    final int PREVIEW_FORMAT = ImageFormat.NV21;
    // Before setting Parameters
    final int origPictureFormat = parameters.getPictureFormat();
    final int origPictureWidth = parameters.getPictureSize().width;
    final int origPictureHeight = parameters.getPictureSize().height;
    final int origPreviewFormat = parameters.getPreviewFormat();
    final int origPreviewWidth = parameters.getPreviewSize().width;
    final int origPreviewHeight = parameters.getPreviewSize().height;
    final int origPreviewFrameRate = parameters.getPreviewFrameRate();
    assertTrue(origPictureWidth > 0);
    assertTrue(origPictureHeight > 0);
    assertTrue(origPreviewWidth > 0);
    assertTrue(origPreviewHeight > 0);
    assertTrue(origPreviewFrameRate > 0);
    // The default preview format must be yuv420 (NV21).
    assertEquals(ImageFormat.NV21, origPreviewFormat);
    // The default picture format must be Jpeg.
    assertEquals(ImageFormat.JPEG, origPictureFormat);
    // If camera supports flash, the default flash mode must be off.
    String flashMode = parameters.getFlashMode();
    assertTrue(flashMode == null || flashMode.equals(parameters.FLASH_MODE_OFF));
    String wb = parameters.getWhiteBalance();
    assertTrue(wb == null || wb.equals(parameters.WHITE_BALANCE_AUTO));
    String effect = parameters.getColorEffect();
    assertTrue(effect == null || effect.equals(parameters.EFFECT_NONE));
    // Some parameters must be supported.
    List<Size> previewSizes = parameters.getSupportedPreviewSizes();
    List<Size> pictureSizes = parameters.getSupportedPictureSizes();
    List<Integer> previewFormats = parameters.getSupportedPreviewFormats();
    List<Integer> pictureFormats = parameters.getSupportedPictureFormats();
    List<Integer> frameRates = parameters.getSupportedPreviewFrameRates();
    List<String> focusModes = parameters.getSupportedFocusModes();
    String focusMode = parameters.getFocusMode();
    float focalLength = parameters.getFocalLength();
    float horizontalViewAngle = parameters.getHorizontalViewAngle();
    float verticalViewAngle = parameters.getVerticalViewAngle();
    int jpegQuality = parameters.getJpegQuality();
    int jpegThumnailQuality = parameters.getJpegThumbnailQuality();
    assertTrue(previewSizes != null && previewSizes.size() != 0);
    assertTrue(pictureSizes != null && pictureSizes.size() != 0);
    assertTrue(previewFormats != null && previewFormats.size() >= 2);
    assertTrue(previewFormats.contains(ImageFormat.NV21));
    assertTrue(previewFormats.contains(ImageFormat.YV12));
    assertTrue(pictureFormats != null && pictureFormats.size() != 0);
    assertTrue(frameRates != null && frameRates.size() != 0);
    assertTrue(focusModes != null && focusModes.size() != 0);
    assertNotNull(focusMode);
    // The default focus mode must be auto if it exists.
    if (focusModes.contains(Parameters.FOCUS_MODE_AUTO)) {
        assertEquals(Parameters.FOCUS_MODE_AUTO, focusMode);
    }
    assertTrue(focalLength > 0);
    assertTrue(horizontalViewAngle > 0 && horizontalViewAngle <= 360);
    assertTrue(verticalViewAngle > 0 && verticalViewAngle <= 360);
    Size previewSize = previewSizes.get(0);
    Size pictureSize = pictureSizes.get(0);
    assertTrue(jpegQuality >= 1 && jpegQuality <= 100);
    assertTrue(jpegThumnailQuality >= 1 && jpegThumnailQuality <= 100);
    // be non null.
    if (parameters.getWhiteBalance() != null) {
        assertNotNull(parameters.getSupportedWhiteBalance());
    }
    if (parameters.getSupportedWhiteBalance() != null) {
        assertNotNull(parameters.getWhiteBalance());
    }
    if (parameters.getColorEffect() != null) {
        assertNotNull(parameters.getSupportedColorEffects());
    }
    if (parameters.getSupportedColorEffects() != null) {
        assertNotNull(parameters.getColorEffect());
    }
    if (parameters.getAntibanding() != null) {
        assertNotNull(parameters.getSupportedAntibanding());
    }
    if (parameters.getSupportedAntibanding() != null) {
        assertNotNull(parameters.getAntibanding());
    }
    if (parameters.getSceneMode() != null) {
        assertNotNull(parameters.getSupportedSceneModes());
    }
    if (parameters.getSupportedSceneModes() != null) {
        assertNotNull(parameters.getSceneMode());
    }
    if (parameters.getFlashMode() != null) {
        assertNotNull(parameters.getSupportedFlashModes());
    }
    if (parameters.getSupportedFlashModes() != null) {
        assertNotNull(parameters.getFlashMode());
    }
    // Check if the sizes value contain invalid characters.
    assertNoLetters(parameters.get("preview-size-values"), "preview-size-values");
    assertNoLetters(parameters.get("picture-size-values"), "picture-size-values");
    assertNoLetters(parameters.get("jpeg-thumbnail-size-values"), "jpeg-thumbnail-size-values");
    // Set the parameters.
    parameters.setPictureFormat(PICTURE_FORMAT);
    assertEquals(PICTURE_FORMAT, parameters.getPictureFormat());
    parameters.setPictureSize(pictureSize.width, pictureSize.height);
    assertEquals(pictureSize.width, parameters.getPictureSize().width);
    assertEquals(pictureSize.height, parameters.getPictureSize().height);
    parameters.setPreviewFormat(PREVIEW_FORMAT);
    assertEquals(PREVIEW_FORMAT, parameters.getPreviewFormat());
    parameters.setPreviewFrameRate(frameRates.get(0));
    assertEquals(frameRates.get(0).intValue(), parameters.getPreviewFrameRate());
    parameters.setPreviewSize(previewSize.width, previewSize.height);
    assertEquals(previewSize.width, parameters.getPreviewSize().width);
    assertEquals(previewSize.height, parameters.getPreviewSize().height);
    mCamera.setParameters(parameters);
    Parameters paramActual = mCamera.getParameters();
    assertTrue(isValidPixelFormat(paramActual.getPictureFormat()));
    assertEquals(pictureSize.width, paramActual.getPictureSize().width);
    assertEquals(pictureSize.height, paramActual.getPictureSize().height);
    assertTrue(isValidPixelFormat(paramActual.getPreviewFormat()));
    assertEquals(previewSize.width, paramActual.getPreviewSize().width);
    assertEquals(previewSize.height, paramActual.getPreviewSize().height);
    assertTrue(paramActual.getPreviewFrameRate() > 0);
    checkExposureCompensation(parameters);
    checkPreferredPreviewSizeForVideo(parameters);
}
#method_after
@CddTest(requirement = "[7.5.4/C-0-1,C-0-2,C-0-3,C-0-6")
private void assertParameters(Parameters parameters) {
    // Parameters constants
    final int PICTURE_FORMAT = ImageFormat.JPEG;
    final int PREVIEW_FORMAT = ImageFormat.NV21;
    // Before setting Parameters
    final int origPictureFormat = parameters.getPictureFormat();
    final int origPictureWidth = parameters.getPictureSize().width;
    final int origPictureHeight = parameters.getPictureSize().height;
    final int origPreviewFormat = parameters.getPreviewFormat();
    final int origPreviewWidth = parameters.getPreviewSize().width;
    final int origPreviewHeight = parameters.getPreviewSize().height;
    final int origPreviewFrameRate = parameters.getPreviewFrameRate();
    assertTrue(origPictureWidth > 0);
    assertTrue(origPictureHeight > 0);
    assertTrue(origPreviewWidth > 0);
    assertTrue(origPreviewHeight > 0);
    assertTrue(origPreviewFrameRate > 0);
    // The default preview format must be yuv420 (NV21).
    assertEquals(ImageFormat.NV21, origPreviewFormat);
    // The default picture format must be Jpeg.
    assertEquals(ImageFormat.JPEG, origPictureFormat);
    // If camera supports flash, the default flash mode must be off.
    String flashMode = parameters.getFlashMode();
    assertTrue(flashMode == null || flashMode.equals(parameters.FLASH_MODE_OFF));
    String wb = parameters.getWhiteBalance();
    assertTrue(wb == null || wb.equals(parameters.WHITE_BALANCE_AUTO));
    String effect = parameters.getColorEffect();
    assertTrue(effect == null || effect.equals(parameters.EFFECT_NONE));
    // Some parameters must be supported.
    List<Size> previewSizes = parameters.getSupportedPreviewSizes();
    List<Size> pictureSizes = parameters.getSupportedPictureSizes();
    List<Integer> previewFormats = parameters.getSupportedPreviewFormats();
    List<Integer> pictureFormats = parameters.getSupportedPictureFormats();
    List<Integer> frameRates = parameters.getSupportedPreviewFrameRates();
    List<String> focusModes = parameters.getSupportedFocusModes();
    String focusMode = parameters.getFocusMode();
    float focalLength = parameters.getFocalLength();
    float horizontalViewAngle = parameters.getHorizontalViewAngle();
    float verticalViewAngle = parameters.getVerticalViewAngle();
    int jpegQuality = parameters.getJpegQuality();
    int jpegThumnailQuality = parameters.getJpegThumbnailQuality();
    assertTrue(previewSizes != null && previewSizes.size() != 0);
    assertTrue(pictureSizes != null && pictureSizes.size() != 0);
    assertTrue(previewFormats != null && previewFormats.size() >= 2);
    assertTrue(previewFormats.contains(ImageFormat.NV21));
    assertTrue(previewFormats.contains(ImageFormat.YV12));
    assertTrue(pictureFormats != null && pictureFormats.size() != 0);
    assertTrue(frameRates != null && frameRates.size() != 0);
    assertTrue(focusModes != null && focusModes.size() != 0);
    assertNotNull(focusMode);
    // The default focus mode must be auto if it exists.
    if (focusModes.contains(Parameters.FOCUS_MODE_AUTO)) {
        assertEquals(Parameters.FOCUS_MODE_AUTO, focusMode);
    }
    assertTrue(focalLength > 0);
    assertTrue(horizontalViewAngle > 0 && horizontalViewAngle <= 360);
    assertTrue(verticalViewAngle > 0 && verticalViewAngle <= 360);
    Size previewSize = previewSizes.get(0);
    Size pictureSize = pictureSizes.get(0);
    assertTrue(jpegQuality >= 1 && jpegQuality <= 100);
    assertTrue(jpegThumnailQuality >= 1 && jpegThumnailQuality <= 100);
    // be non null.
    if (parameters.getWhiteBalance() != null) {
        assertNotNull(parameters.getSupportedWhiteBalance());
    }
    if (parameters.getSupportedWhiteBalance() != null) {
        assertNotNull(parameters.getWhiteBalance());
    }
    if (parameters.getColorEffect() != null) {
        assertNotNull(parameters.getSupportedColorEffects());
    }
    if (parameters.getSupportedColorEffects() != null) {
        assertNotNull(parameters.getColorEffect());
    }
    if (parameters.getAntibanding() != null) {
        assertNotNull(parameters.getSupportedAntibanding());
    }
    if (parameters.getSupportedAntibanding() != null) {
        assertNotNull(parameters.getAntibanding());
    }
    if (parameters.getSceneMode() != null) {
        assertNotNull(parameters.getSupportedSceneModes());
    }
    if (parameters.getSupportedSceneModes() != null) {
        assertNotNull(parameters.getSceneMode());
    }
    if (parameters.getFlashMode() != null) {
        assertNotNull(parameters.getSupportedFlashModes());
    }
    if (parameters.getSupportedFlashModes() != null) {
        assertNotNull(parameters.getFlashMode());
    }
    // Check if the sizes value contain invalid characters.
    assertNoLetters(parameters.get("preview-size-values"), "preview-size-values");
    assertNoLetters(parameters.get("picture-size-values"), "picture-size-values");
    assertNoLetters(parameters.get("jpeg-thumbnail-size-values"), "jpeg-thumbnail-size-values");
    // Set the parameters.
    parameters.setPictureFormat(PICTURE_FORMAT);
    assertEquals(PICTURE_FORMAT, parameters.getPictureFormat());
    parameters.setPictureSize(pictureSize.width, pictureSize.height);
    assertEquals(pictureSize.width, parameters.getPictureSize().width);
    assertEquals(pictureSize.height, parameters.getPictureSize().height);
    parameters.setPreviewFormat(PREVIEW_FORMAT);
    assertEquals(PREVIEW_FORMAT, parameters.getPreviewFormat());
    parameters.setPreviewFrameRate(frameRates.get(0));
    assertEquals(frameRates.get(0).intValue(), parameters.getPreviewFrameRate());
    parameters.setPreviewSize(previewSize.width, previewSize.height);
    assertEquals(previewSize.width, parameters.getPreviewSize().width);
    assertEquals(previewSize.height, parameters.getPreviewSize().height);
    mCamera.setParameters(parameters);
    Parameters paramActual = mCamera.getParameters();
    assertTrue(isValidPixelFormat(paramActual.getPictureFormat()));
    assertEquals(pictureSize.width, paramActual.getPictureSize().width);
    assertEquals(pictureSize.height, paramActual.getPictureSize().height);
    assertTrue(isValidPixelFormat(paramActual.getPreviewFormat()));
    assertEquals(previewSize.width, paramActual.getPreviewSize().width);
    assertEquals(previewSize.height, paramActual.getPreviewSize().height);
    assertTrue(paramActual.getPreviewFrameRate() > 0);
    checkExposureCompensation(parameters);
    checkPreferredPreviewSizeForVideo(parameters);
}
#end_block

#method_before
private long count() {
    return mMaxIterations * REPEAT_COUNT;
}
#method_after
private long count() {
    return mMaxIterations;
}
#end_block

#method_before
public static int acquireRawFd(FileDescriptor fd) {
    int rawFd = fd.getInt$();
    long previousOwner = fd.getOwner$();
    fd.setOwner$(0);
    Libcore.os.exchangeFdOwner(fd, previousOwner, 0);
    fd.setInt$(-1);
    return rawFd;
}
#method_after
public static int acquireRawFd(@NonNull FileDescriptor fd) {
    Objects.requireNonNull(fd);
    FileDescriptor copy = fd.release$();
    // Get the numeric Unix file descriptor. -1 means it is invalid; for example if
    // {@link FileDescriptor#release$()} has already been called on the FileDescriptor.
    int rawFd = copy.getInt$();
    long previousOwnerId = copy.getOwnerId$();
    if (rawFd != -1 && previousOwnerId != FileDescriptor.NO_OWNER) {
        // Clear the file descriptor's owner ID, aborting if the previous value isn't as expected.
        Libcore.os.android_fdsan_exchange_owner_tag(copy, previousOwnerId, FileDescriptor.NO_OWNER);
    }
    return rawFd;
}
#end_block

#method_before
public static void setFdOwner(FileDescriptor fd, Object owner) {
    if (fd != null) {
        long previousOwner = fd.getOwner$();
        if (previousOwner != 0) {
            throw new RuntimeException("attempted to take ownership of already-owned FileDescriptor");
        }
        fd.setOwner$(owner);
        Libcore.os.exchangeFdOwner(fd, previousOwner, fd.getOwner$());
    }
}
#method_after
public static void setFdOwner(@NonNull FileDescriptor fd, @NonNull Object owner) {
    Objects.requireNonNull(fd);
    Objects.requireNonNull(owner);
    long previousOwnerId = fd.getOwnerId$();
    if (previousOwnerId != FileDescriptor.NO_OWNER) {
        throw new IllegalStateException("Attempted to take ownership of already-owned " + "FileDescriptor");
    }
    // ownerId is not required to be unique but should be stable and should attempt to avoid
    // collision with identifiers generated both here and in native code (which are simply the
    // address of the owning object). identityHashCode(Object) meets these requirements.
    int ownerId = System.identityHashCode(owner);
    fd.setOwnerId$(ownerId);
    // Set the file descriptor's owner ID, aborting if the previous value isn't as expected.
    Libcore.os.android_fdsan_exchange_owner_tag(fd, previousOwnerId, ownerId);
}
#end_block

#method_before
public static void closeAndSignalBlockedThreads(FileDescriptor fd) throws IOException {
    if (fd == null || !fd.valid()) {
        return;
    }
    FileDescriptor oldFd = new FileDescriptor();
    oldFd.setInt$(fd.getInt$());
    oldFd.setOwner$(fd.getOwner$());
    fd.setInt$(-1);
    fd.setOwner$(0);
    AsynchronousCloseMonitor.signalBlockedThreads(oldFd);
    try {
        Libcore.os.close(oldFd);
    } catch (ErrnoException errnoException) {
        throw errnoException.rethrowAsIOException();
    }
}
#method_after
public static void closeAndSignalBlockedThreads(FileDescriptor fd) throws IOException {
    if (fd == null || !fd.valid()) {
        return;
    }
    // fd is invalid after we call release.
    FileDescriptor oldFd = fd.release$();
    AsynchronousCloseMonitor.signalBlockedThreads(oldFd);
    try {
        Libcore.os.close(oldFd);
    } catch (ErrnoException errnoException) {
        throw errnoException.rethrowAsIOException();
    }
}
#end_block

#method_before
public static boolean isConnected(FileDescriptor fd, InetAddress inetAddress, int port, int timeoutMs, int remainingTimeoutMs) throws IOException {
    ErrnoException cause;
    try {
        StructPollfd[] pollFds = new StructPollfd[] { new StructPollfd() };
        pollFds[0].fd = fd;
        pollFds[0].events = (short) POLLOUT;
        int rc = Libcore.os.poll(pollFds, remainingTimeoutMs);
        if (rc == 0) {
            // Timeout.
            return false;
        }
        int connectError = Libcore.os.getsockoptInt(fd, SOL_SOCKET, SO_ERROR);
        if (connectError == 0) {
            // Success!
            return true;
        }
        // The connect(2) failed.
        throw new ErrnoException("isConnected", connectError);
    } catch (ErrnoException errnoException) {
        if (!fd.valid()) {
            throw new SocketException("Socket closed");
        }
        cause = errnoException;
    }
    String detail = createMessageForException(fd, inetAddress, port, timeoutMs, cause);
    if (cause.errno == ETIMEDOUT) {
        throw new SocketTimeoutException(detail, cause);
    }
    throw new ConnectException(detail, cause);
}
#method_after
public static boolean isConnected(FileDescriptor fd, InetAddress inetAddress, int port, int timeoutMs, int remainingTimeoutMs) throws IOException {
    ErrnoException cause;
    try {
        StructPollfd[] pollFds = new StructPollfd[] { new StructPollfd() };
        pollFds[0].fd = fd;
        pollFds[0].events = (short) POLLOUT;
        int rc = Libcore.os.poll(pollFds, remainingTimeoutMs);
        if (rc == 0) {
            // Timeout.
            return false;
        }
        int connectError = Libcore.os.getsockoptInt(fd, SOL_SOCKET, SO_ERROR);
        if (connectError == 0) {
            // Success!
            return true;
        }
        // The connect(2) failed.
        throw new ErrnoException("isConnected", connectError);
    } catch (ErrnoException errnoException) {
        if (!fd.valid()) {
            throw new SocketException("Socket closed");
        }
        cause = errnoException;
    }
    String detail = createMessageForException(fd, inetAddress, port, timeoutMs, cause);
    if (cause.errno == ETIMEDOUT) {
        SocketTimeoutException e = new SocketTimeoutException(detail);
        e.initCause(cause);
        throw e;
    }
    throw new ConnectException(detail, cause);
}
#end_block

#method_before
private static int maybeThrowAfterRecvfrom(boolean isRead, boolean isConnected, ErrnoException errnoException) throws SocketException, SocketTimeoutException {
    if (isRead) {
        if (errnoException.errno == EAGAIN) {
            return 0;
        } else {
            throw errnoException.rethrowAsSocketException();
        }
    } else {
        if (isConnected && errnoException.errno == ECONNREFUSED) {
            throw new PortUnreachableException("ICMP Port Unreachable", errnoException);
        } else if (errnoException.errno == EAGAIN) {
            throw new SocketTimeoutException(errnoException);
        } else {
            throw errnoException.rethrowAsSocketException();
        }
    }
}
#method_after
private static int maybeThrowAfterRecvfrom(boolean isRead, boolean isConnected, ErrnoException errnoException) throws SocketException, SocketTimeoutException {
    if (isRead) {
        if (errnoException.errno == EAGAIN) {
            return 0;
        } else {
            throw errnoException.rethrowAsSocketException();
        }
    } else {
        if (isConnected && errnoException.errno == ECONNREFUSED) {
            throw new PortUnreachableException("ICMP Port Unreachable", errnoException);
        } else if (errnoException.errno == EAGAIN) {
            SocketTimeoutException e = new SocketTimeoutException();
            e.initCause(errnoException);
            throw e;
        } else {
            throw errnoException.rethrowAsSocketException();
        }
    }
}
#end_block

#method_before
// Android-removed: initIDs not used to allow compile-time intialization
/* This routine initializes JNI field offsets for the class */
// private static native void initIDs();
/**
 * Returns the int descriptor. It's highly unlikely you should be calling this. Please discuss
 * your needs with a libcore maintainer before using this method.
 * @hide internal use only
 */
public final int getInt$() {
    return descriptor;
}
#method_after
// Android-removed: initIDs not used to allow compile-time intialization
/* This routine initializes JNI field offsets for the class */
// private static native void initIDs();
// Android-added: Needed for framework to access descriptor value
public final int getInt$() {
    return descriptor;
}
#end_block

#method_before
/**
 * Sets the int descriptor. It's highly unlikely you should be calling this. Please discuss
 * your needs with a libcore maintainer before using this method.
 * @hide internal use only
 */
public final void setInt$(int fd) {
    this.descriptor = fd;
}
#method_after
// Android-added: Needed for framework to access descriptor value
public final void setInt$(int fd) {
    this.descriptor = fd;
}
#end_block

#method_before
/**
 * @hide internal use only
 */
public boolean isSocket$() {
    return isSocket(descriptor);
}
#method_after
// END Android-added: Methods to enable ownership enforcement of Unix file descriptors.
/**
 * @hide internal use only
 */
public boolean isSocket$() {
    return isSocket(descriptor);
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case CARRIER_EVENT_VOICE_REGISTRATION:
        case CARRIER_EVENT_DATA_REGISTRATION:
        case CARRIER_EVENT_VOICE_DEREGISTRATION:
        case CARRIER_EVENT_DATA_DEREGISTRATION:
        case CARRIER_EVENT_IMS_CAPABILITIES_CHANGED:
            handleConfigChanges();
            break;
        case NOTIFICATION_EMERGENCY_NETWORK:
        case NOTIFICATION_PREF_NETWORK:
            Rlog.d(LOG_TAG, "sending notification after delay: " + msg.what);
            NotificationType notificationType = mNotificationTypeMap.get(msg.what);
            if (notificationType != null) {
                sendNotification(notificationType);
            }
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case CARRIER_EVENT_VOICE_REGISTRATION:
        case CARRIER_EVENT_DATA_REGISTRATION:
        case CARRIER_EVENT_VOICE_DEREGISTRATION:
        case CARRIER_EVENT_DATA_DEREGISTRATION:
            handleConfigChanges();
            break;
        case CARRIER_EVENT_IMS_CAPABILITIES_CHANGED:
            handleImsCapabilitiesChanged();
            break;
        case NOTIFICATION_EMERGENCY_NETWORK:
        case NOTIFICATION_PREF_NETWORK:
            Rlog.d(LOG_TAG, "sending notification after delay: " + msg.what);
            NotificationType notificationType = mNotificationTypeMap.get(msg.what);
            if (notificationType != null) {
                sendNotification(notificationType);
            }
            break;
    }
}
#end_block

#method_before
public List<URI> getURIs() {
    List<URI> uris = new ArrayList<URI>();
    lock.lock();
    try {
        // BEGIN Android-changed: App compat. Return URI with no cookies. http://b/65538736
        /*
            Iterator<URI> it = uriIndex.keySet().iterator();
            while (it.hasNext()) {
                URI uri = it.next();
                List<HttpCookie> cookies = uriIndex.get(uri);
                if (cookies == null || cookies.size() == 0) {
                    // no cookies list or an empty list associated with
                    // this uri entry, delete it
                    it.remove();
                }
            }
            */
        // END Android-changed: App compat. Return URI with no cookies. http://b/65538736
        List<URI> result = new ArrayList<URI>(uriIndex.keySet());
        result.remove(null);
        return Collections.unmodifiableList(result);
    } finally {
        uris.addAll(uriIndex.keySet());
        lock.unlock();
    }
// BEGIN Android-changed: App compat. Return URI with no cookies. http://b/65538736
// return uris;
// END Android-changed: App compat. Return URI with no cookies. http://b/65538736
}
#method_after
public List<URI> getURIs() {
    // BEGIN Android-changed: App compat. Return URI with no cookies. http://b/65538736
    /*
        List<URI> uris = new ArrayList<URI>();

        lock.lock();
        try {
            Iterator<URI> it = uriIndex.keySet().iterator();
            while (it.hasNext()) {
                URI uri = it.next();
                List<HttpCookie> cookies = uriIndex.get(uri);
                if (cookies == null || cookies.size() == 0) {
                    // no cookies list or an empty list associated with
                    // this uri entry, delete it
                    it.remove();
                }
            }
        } finally {
            uris.addAll(uriIndex.keySet());
            lock.unlock();
        }

        return uris;
         */
    lock.lock();
    try {
        List<URI> result = new ArrayList<URI>(uriIndex.keySet());
        result.remove(null);
        return Collections.unmodifiableList(result);
    } finally {
        lock.unlock();
    }
// END Android-changed: App compat. Return URI with no cookies. http://b/65538736
}
#end_block

#method_before
/**
 * Returns {@code true} iff this JAR file has a manifest with the
 * Class-Path attribute
 * @hide
 */
// Android-changed: Make hasClassPathAttribute() @hide public, for internal use.
public boolean hasClassPathAttribute() throws IOException {
    checkForSpecialAttributes();
    return hasClassPathAttribute;
}
#method_after
/**
 * Returns {@code true} iff this JAR file has a manifest with the
 * Class-Path attribute
 * @hide
 */
// Android-changed: Make hasClassPathAttribute() @hide public, for internal use.
// Used by URLClassPath.JarLoader.
public boolean hasClassPathAttribute() throws IOException {
    checkForSpecialAttributes();
    return hasClassPathAttribute;
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Log.i(TAG, "Starting!");
    try {
        init();
        ITestService service = getService();
        checkPrimitiveRepeat(service);
        checkArrayReversal(service);
        checkBinderExchange(service);
        checkListReversal(service);
        checkSimpleParcelables(service);
        checkPersistableBundles(service);
        checkFileDescriptorPassing(service);
        checkServiceSpecificExceptions(service);
        checkUtf8Strings(service);
        new NullableTests(service, mLog).runTests();
        int a = service.foo(100);
        Log.d(TAG, "returned a is " + a);
        mLog.log(mSuccessSentinel);
    } catch (TestFailException e) {
        mLog.log(mFailureSentinel);
        throw new RuntimeException(e);
    } catch (RemoteException e) {
    } finally {
        if (mLog != null) {
            mLog.close();
        }
    }
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Log.i(TAG, "Starting!");
    try {
        init();
        ITestService service = getService();
        checkPrimitiveRepeat(service);
        checkArrayReversal(service);
        checkBinderExchange(service);
        checkListReversal(service);
        checkSimpleParcelables(service);
        checkPersistableBundles(service);
        checkFileDescriptorPassing(service);
        checkServiceSpecificExceptions(service);
        checkUtf8Strings(service);
        checkStructuredParcelable(service);
        new NullableTests(service, mLog).runTests();
        checkDefaultImpl(service);
        mLog.log(mSuccessSentinel);
    } catch (TestFailException e) {
        mLog.log(mFailureSentinel);
        throw new RuntimeException(e);
    } finally {
        if (mLog != null) {
            mLog.close();
        }
    }
}
#end_block

#method_before
// 
// 
// Device Info
// 
// 
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getDeviceSoftwareVersion() {
    return getDeviceSoftwareVersion(getSlotIndex());
}
#method_after
// 
// 
// Device Info
// 
// 
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getDeviceSoftwareVersion() {
    return getDeviceSoftwareVersion(getSlotIndex());
}
#end_block

#method_before
@Deprecated
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getDeviceId() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return null;
        return telephony.getDeviceId(mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#method_after
@Deprecated
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getDeviceId() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return null;
        return telephony.getDeviceId(mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#end_block

#method_before
@Deprecated
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getDeviceId(int slotIndex) {
    // FIXME this assumes phoneId == slotIndex
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getDeviceIdForPhone(slotIndex, mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#method_after
@Deprecated
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getDeviceId(int slotIndex) {
    // FIXME this assumes phoneId == slotIndex
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getDeviceIdForPhone(slotIndex, mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getImei() {
    return getImei(getSlotIndex());
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getImei() {
    return getImei(getSlotIndex());
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getImei(int slotIndex) {
    ITelephony telephony = getITelephony();
    if (telephony == null)
        return null;
    try {
        return telephony.getImeiForSlot(slotIndex, getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getImei(int slotIndex) {
    ITelephony telephony = getITelephony();
    if (telephony == null)
        return null;
    try {
        return telephony.getImeiForSlot(slotIndex, getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getMeid() {
    return getMeid(getSlotIndex());
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getMeid() {
    return getMeid(getSlotIndex());
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getMeid(int slotIndex) {
    ITelephony telephony = getITelephony();
    if (telephony == null)
        return null;
    try {
        return telephony.getMeidForSlot(slotIndex, getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getMeid(int slotIndex) {
    ITelephony telephony = getITelephony();
    if (telephony == null)
        return null;
    try {
        return telephony.getMeidForSlot(slotIndex, getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        return null;
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getNai() {
    return getNaiBySubscriberId(getSubId());
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getNai() {
    return getNaiBySubscriberId(getSubId());
}
#end_block

#method_before
@WorkerThread
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public PersistableBundle getCarrierConfig() {
    CarrierConfigManager carrierConfigManager = mContext.getSystemService(CarrierConfigManager.class);
    return carrierConfigManager.getConfigForSubId(getSubId());
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@WorkerThread
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public PersistableBundle getCarrierConfig() {
    CarrierConfigManager carrierConfigManager = mContext.getSystemService(CarrierConfigManager.class);
    return carrierConfigManager.getConfigForSubId(getSubId());
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public int getDataNetworkType() {
    return getDataNetworkType(getSubId(SubscriptionManager.getDefaultDataSubscriptionId()));
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public int getDataNetworkType() {
    return getDataNetworkType(getSubId(SubscriptionManager.getDefaultDataSubscriptionId()));
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public int getVoiceNetworkType() {
    return getVoiceNetworkType(getSubId());
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public int getVoiceNetworkType() {
    return getVoiceNetworkType(getSubId());
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getSimSerialNumber() {
    return getSimSerialNumber(getSubId());
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getSimSerialNumber() {
    return getSimSerialNumber(getSubId());
}
#end_block

#method_before
// 
// 
// Subscriber Info
// 
// 
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getSubscriberId() {
    return getSubscriberId(getSubId());
}
#method_after
// 
// 
// Subscriber Info
// 
// 
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getSubscriberId() {
    return getSubscriberId(getSubId());
}
#end_block

#method_before
public ImsiEncryptionInfo getCarrierInfoForImsiEncryption(int keyType) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null) {
            throw new RuntimeException("IMSI error: Subscriber Info is null");
        }
        int subId = getSubId(SubscriptionManager.getDefaultDataSubscriptionId());
        if (keyType != KEY_TYPE_EPDG && keyType != KEY_TYPE_WLAN) {
            throw new IllegalArgumentException("IMSI error: Invalid key type");
        }
        ImsiEncryptionInfo imsiEncryptionInfo = info.getCarrierInfoForImsiEncryption(subId, keyType, mContext.getOpPackageName());
        if (imsiEncryptionInfo == null && isImsiEncryptionRequired(subId, keyType)) {
            Rlog.e(TAG, "IMSI error: key is required but not found");
            throw new RuntimeException("IMSI error: key is required but not found");
        }
        return imsiEncryptionInfo;
    } catch (RemoteException ex) {
        Rlog.e(TAG, "getCarrierInfoForImsiEncryption RemoteException" + ex);
        throw new RuntimeException("IMSI error: Remote Exception");
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        Rlog.e(TAG, "getCarrierInfoForImsiEncryption NullPointerException" + ex);
        throw new RuntimeException("IMSI error: Null Pointer exception");
    }
}
#method_after
public ImsiEncryptionInfo getCarrierInfoForImsiEncryption(int keyType) {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null) {
            Rlog.e(TAG, "IMSI error: Subscriber Info is null");
            return null;
        }
        int subId = getSubId(SubscriptionManager.getDefaultDataSubscriptionId());
        if (keyType != KEY_TYPE_EPDG && keyType != KEY_TYPE_WLAN) {
            throw new IllegalArgumentException("IMSI error: Invalid key type");
        }
        ImsiEncryptionInfo imsiEncryptionInfo = info.getCarrierInfoForImsiEncryption(subId, keyType, mContext.getOpPackageName());
        if (imsiEncryptionInfo == null && isImsiEncryptionRequired(subId, keyType)) {
            Rlog.e(TAG, "IMSI error: key is required but not found");
            throw new IllegalArgumentException("IMSI error: key is required but not found");
        }
        return imsiEncryptionInfo;
    } catch (RemoteException ex) {
        Rlog.e(TAG, "getCarrierInfoForImsiEncryption RemoteException" + ex);
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        Rlog.e(TAG, "getCarrierInfoForImsiEncryption NullPointerException" + ex);
    }
    return null;
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getGroupIdLevel1() {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getGroupIdLevel1(mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getGroupIdLevel1() {
    try {
        IPhoneSubInfo info = getSubscriberInfo();
        if (info == null)
            return null;
        return info.getGroupIdLevel1ForSubscriber(getSubId(), mContext.getOpPackageName());
    } catch (RemoteException ex) {
        return null;
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        return null;
    }
}
#end_block

#method_before
@RequiresPermission(anyOf = { android.Manifest.permission.READ_PHONE_STATE, android.Manifest.permission.READ_SMS, android.Manifest.permission.READ_PHONE_NUMBERS })
public String getLine1Number() {
    return getLine1Number(getSubId());
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges or default SMS app
@SuppressAutoDoc
@RequiresPermission(anyOf = { android.Manifest.permission.READ_PHONE_STATE, android.Manifest.permission.READ_SMS, android.Manifest.permission.READ_PHONE_NUMBERS })
public String getLine1Number() {
    return getLine1Number(getSubId());
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getVoiceMailNumber() {
    return getVoiceMailNumber(getSubId());
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getVoiceMailNumber() {
    return getVoiceMailNumber(getSubId());
}
#end_block

#method_before
@Nullable
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getVisualVoicemailPackageName() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.getVisualVoicemailPackageName(mContext.getOpPackageName(), getSubId());
        }
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return null;
}
#method_after
@Nullable
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getVisualVoicemailPackageName() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.getVisualVoicemailPackageName(mContext.getOpPackageName(), getSubId());
        }
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return null;
}
#end_block

#method_before
public void setVoiceActivationState(int subId, int activationState) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            telephony.setVoiceActivationState(subId, activationState);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
}
#method_after
@SystemApi
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setVoiceActivationState(@SimActivationState int activationState) {
    setVoiceActivationState(getSubId(), activationState);
}
#end_block

#method_before
public void setVoiceActivationState(int subId, int activationState) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            telephony.setVoiceActivationState(subId, activationState);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setVoiceActivationState(int subId, @SimActivationState int activationState) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            telephony.setVoiceActivationState(subId, activationState);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
}
#end_block

#method_before
public void setDataActivationState(int subId, int activationState) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            telephony.setDataActivationState(subId, activationState);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
}
#method_after
@SystemApi
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setDataActivationState(@SimActivationState int activationState) {
    setDataActivationState(getSubId(), activationState);
}
#end_block

#method_before
public void setDataActivationState(int subId, int activationState) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            telephony.setDataActivationState(subId, activationState);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setDataActivationState(int subId, @SimActivationState int activationState) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            telephony.setDataActivationState(subId, activationState);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public int getVoiceActivationState(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.getVoiceActivationState(subId, getOpPackageName());
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return SIM_ACTIVATION_STATE_UNKNOWN;
}
#method_after
@SystemApi
@RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
@SimActivationState
public int getVoiceActivationState() {
    return getVoiceActivationState(getSubId());
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public int getVoiceActivationState(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.getVoiceActivationState(subId, getOpPackageName());
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return SIM_ACTIVATION_STATE_UNKNOWN;
}
#method_after
@RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
@SimActivationState
public int getVoiceActivationState(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.getVoiceActivationState(subId, getOpPackageName());
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return SIM_ACTIVATION_STATE_UNKNOWN;
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public int getDataActivationState(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.getDataActivationState(subId, getOpPackageName());
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return SIM_ACTIVATION_STATE_UNKNOWN;
}
#method_after
@SystemApi
@RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
@SimActivationState
public int getDataActivationState() {
    return getDataActivationState(getSubId());
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public int getDataActivationState(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.getDataActivationState(subId, getOpPackageName());
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return SIM_ACTIVATION_STATE_UNKNOWN;
}
#method_after
@RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
@SimActivationState
public int getDataActivationState(int subId) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.getDataActivationState(subId, getOpPackageName());
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return SIM_ACTIVATION_STATE_UNKNOWN;
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getVoiceMailAlphaTag() {
    return getVoiceMailAlphaTag(getSubId());
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String getVoiceMailAlphaTag() {
    return getVoiceMailAlphaTag(getSubId());
}
#end_block

#method_before
public void sendDialerSpecialCode(String inputCode) {
    try {
        final ITelephony telephony = getITelephony();
        telephony.sendDialerSpecialCode(mContext.getOpPackageName(), inputCode);
    } catch (RemoteException ex) {
        // This could happen if binder process crashes.
        ex.rethrowFromSystemServer();
    } catch (NullPointerException ex) {
        // This could happen before phone restarts due to crashing
        throw new IllegalStateException("Telephony service unavailable");
    }
}
#method_after
public void sendDialerSpecialCode(String inputCode) {
    try {
        final ITelephony telephony = getITelephony();
        if (telephony == null) {
            if (!isSystemProcess()) {
                throw new RuntimeException("Telephony service unavailable");
            }
            return;
        }
        telephony.sendDialerSpecialCode(mContext.getOpPackageName(), inputCode);
    } catch (RemoteException ex) {
        // This could happen if binder process crashes.
        if (!isSystemProcess()) {
            ex.rethrowAsRuntimeException();
        }
    }
}
#end_block

#method_before
public int getCallState() {
    try {
        ITelecomService telecom = getTelecomService();
        if (telecom != null) {
            return telecom.getCallState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelecomService#getCallState", e);
    }
    return CALL_STATE_IDLE;
}
#method_after
@CallState
public int getCallState() {
    try {
        ITelecomService telecom = getTelecomService();
        if (telecom != null) {
            return telecom.getCallState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelecomService#getCallState", e);
    }
    return CALL_STATE_IDLE;
}
#end_block

#method_before
public int getCallState(int subId) {
    int phoneId = SubscriptionManager.getPhoneId(subId);
    return getCallStateForSlot(phoneId);
}
#method_after
@CallState
public int getCallState(int subId) {
    int phoneId = SubscriptionManager.getPhoneId(subId);
    return getCallStateForSlot(phoneId);
}
#end_block

#method_before
public int getCallStateForSlot(int slotIndex) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return CALL_STATE_IDLE;
        return telephony.getCallStateForSlot(slotIndex);
    } catch (RemoteException ex) {
        // the phone process is restarting.
        return CALL_STATE_IDLE;
    } catch (NullPointerException ex) {
        // the phone process is restarting.
        return CALL_STATE_IDLE;
    }
}
#method_after
@CallState
public int getCallStateForSlot(int slotIndex) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return CALL_STATE_IDLE;
        return telephony.getCallStateForSlot(slotIndex);
    } catch (RemoteException ex) {
        // the phone process is restarting.
        return CALL_STATE_IDLE;
    } catch (NullPointerException ex) {
        // the phone process is restarting.
        return CALL_STATE_IDLE;
    }
}
#end_block

#method_before
public static boolean putIntAtIndex(android.content.ContentResolver cr, String name, int index, int value) {
    String data = "";
    String[] valArray = null;
    String v = android.provider.Settings.Global.getString(cr, name);
    if (index == Integer.MAX_VALUE) {
        throw new RuntimeException("putIntAtIndex index == MAX_VALUE index=" + index);
    }
    if (index < 0) {
        throw new RuntimeException("putIntAtIndex index < 0 index=" + index);
    }
    if (v != null) {
        valArray = v.split(",");
    }
    // Copy the elements from valArray till index
    for (int i = 0; i < index; i++) {
        String str = "";
        if ((valArray != null) && (i < valArray.length)) {
            str = valArray[i];
        }
        data = data + str + ",";
    }
    data = data + value;
    // Copy the remaining elements from valArray if any.
    if (valArray != null) {
        for (int i = index + 1; i < valArray.length; i++) {
            data = data + "," + valArray[i];
        }
    }
    return android.provider.Settings.Global.putString(cr, name, data);
}
#method_after
public static boolean putIntAtIndex(android.content.ContentResolver cr, String name, int index, int value) {
    String data = "";
    String[] valArray = null;
    String v = android.provider.Settings.Global.getString(cr, name);
    if (index == Integer.MAX_VALUE) {
        throw new IllegalArgumentException("putIntAtIndex index == MAX_VALUE index=" + index);
    }
    if (index < 0) {
        throw new IllegalArgumentException("putIntAtIndex index < 0 index=" + index);
    }
    if (v != null) {
        valArray = v.split(",");
    }
    // Copy the elements from valArray till index
    for (int i = 0; i < index; i++) {
        String str = "";
        if ((valArray != null) && (i < valArray.length)) {
            str = valArray[i];
        }
        data = data + str + ",";
    }
    data = data + value;
    // Copy the remaining elements from valArray if any.
    if (valArray != null) {
        for (int i = index + 1; i < valArray.length; i++) {
            data = data + "," + valArray[i];
        }
    }
    return android.provider.Settings.Global.putString(cr, name, data);
}
#end_block

#method_before
public String getIccAuthentication(int appType, int authType, String data) {
    return getIccAuthentication(getSubId(), appType, authType, data);
}
#method_after
/**
 * Returns the response of authentication for the default subscription.
 * Returns null if the authentication hasn't been successful
 *
 * <p>Requires Permission: READ_PRIVILEGED_PHONE_STATE or that the calling
 * app has carrier privileges (see {@link #hasCarrierPrivileges}).
 *
 * @param appType the icc application type, like {@link #APPTYPE_USIM}
 * @param authType the authentication type, {@link #AUTHTYPE_EAP_AKA} or
 * {@link #AUTHTYPE_EAP_SIM}
 * @param data authentication challenge data, base64 encoded.
 * See 3GPP TS 31.102 7.1.2 for more details.
 * @return the response of authentication. This value will be null in the following cases:
 *   Authentication error, incorrect MAC
 *   Authentication error, security context not supported
 *   Key freshness failure
 *   Authentication error, no memory space available
 *   Authentication error, no memory space available in EFMUK
 */
// TODO(b/73660190): This should probably require MODIFY_PHONE_STATE, not
// READ_PRIVILEGED_PHONE_STATE. It certainly shouldn't reference the permission in Javadoc since
public String getIccAuthentication(int appType, int authType, String data) {
    return getIccAuthentication(getSubId(), appType, authType, data);
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String[] getForbiddenPlmns() {
    return getForbiddenPlmns(getSubId(), APPTYPE_USIM);
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public String[] getForbiddenPlmns() {
    return getForbiddenPlmns(getSubId(), APPTYPE_USIM);
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setNetworkSelectionModeAutomatic() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            telephony.setNetworkSelectionModeAutomatic(getSubId());
        }
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeAutomatic RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeAutomatic NPE", ex);
    }
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setNetworkSelectionModeAutomatic() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            telephony.setNetworkSelectionModeAutomatic(getSubId());
        }
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeAutomatic RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeAutomatic NPE", ex);
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public NetworkScan requestNetworkScan(NetworkScanRequest request, Executor executor, TelephonyScanManager.NetworkScanCallback callback) {
    synchronized (this) {
        if (mTelephonyScanManager == null) {
            mTelephonyScanManager = new TelephonyScanManager();
        }
    }
    return mTelephonyScanManager.requestNetworkScan(getSubId(), request, executor, callback);
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public NetworkScan requestNetworkScan(NetworkScanRequest request, Executor executor, TelephonyScanManager.NetworkScanCallback callback) {
    synchronized (this) {
        if (mTelephonyScanManager == null) {
            mTelephonyScanManager = new TelephonyScanManager();
        }
    }
    return mTelephonyScanManager.requestNetworkScan(getSubId(), request, executor, callback);
}
#end_block

#method_before
@Deprecated
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public NetworkScan requestNetworkScan(NetworkScanRequest request, TelephonyScanManager.NetworkScanCallback callback) {
    return requestNetworkScan(request, AsyncTask.THREAD_POOL_EXECUTOR, callback);
}
#method_after
@Deprecated
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public NetworkScan requestNetworkScan(NetworkScanRequest request, TelephonyScanManager.NetworkScanCallback callback) {
    return requestNetworkScan(request, AsyncTask.SERIAL_EXECUTOR, callback);
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public boolean setNetworkSelectionModeManual(String operatorNumeric, boolean persistSelection) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.setNetworkSelectionModeManual(getSubId(), operatorNumeric, persistSelection);
        }
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual NPE", ex);
    }
    return false;
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public boolean setNetworkSelectionModeManual(String operatorNumeric, boolean persistSelection) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            return telephony.setNetworkSelectionModeManual(getSubId(), operatorNumeric, persistSelection);
        }
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setNetworkSelectionModeManual NPE", ex);
    }
    return false;
}
#end_block

#method_before
@Deprecated
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setDataEnabled(boolean enable) {
    setUserMobileDataEnabled(enable);
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setDataEnabled(boolean enable) {
    setDataEnabled(getSubId(SubscriptionManager.getDefaultDataSubscriptionId()), enable);
}
#end_block

#method_before
@SystemApi
@Deprecated
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setDataEnabled(int subId, boolean enable) {
    setUserMobileDataEnabled(subId, enable);
}
#method_after
@SystemApi
@Deprecated
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setDataEnabled(int subId, boolean enable) {
    try {
        Log.d(TAG, "setDataEnabled: enabled=" + enable);
        ITelephony telephony = getITelephony();
        if (telephony != null)
            telephony.setUserDataEnabled(subId, enable);
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#setUserDataEnabled", e);
    }
}
#end_block

#method_before
@SystemApi
@Deprecated
public boolean getDataEnabled() {
    return isUserMobileDataEnabled();
}
#method_after
@SystemApi
@Deprecated
public boolean getDataEnabled() {
    return isDataEnabled();
}
#end_block

#method_before
@Deprecated
public boolean isDataEnabled() {
    return isUserMobileDataEnabled();
}
#method_after
public boolean isDataEnabled() {
    return getDataEnabled(getSubId(SubscriptionManager.getDefaultDataSubscriptionId()));
}
#end_block

#method_before
@Deprecated
@SystemApi
public boolean getDataEnabled(int subId) {
    return isUserMobileDataEnabled(subId);
}
#method_after
@Deprecated
@SystemApi
public boolean getDataEnabled(int subId) {
    boolean retVal = false;
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            retVal = telephony.isUserDataEnabled(subId);
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#isUserDataEnabled", e);
    } catch (NullPointerException e) {
    }
    return retVal;
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public ServiceState getServiceState() {
    return getServiceStateForSubscriber(getSubId());
}
#method_after
// Blocked by b/72967236 - no support for carrier privileges
@SuppressAutoDoc
@RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
public ServiceState getServiceState() {
    return getServiceStateForSubscriber(getSubId());
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setRadioIndicationUpdateMode(@IndicationFilters int filters, @IndicationUpdateMode int updateMode) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            telephony.setRadioIndicationUpdateMode(getSubId(), filters, updateMode);
        }
    } catch (RemoteException ex) {
        // This could happen if binder process crashes.
        ex.rethrowAsRuntimeException();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public void setRadioIndicationUpdateMode(@IndicationFilters int filters, @IndicationUpdateMode int updateMode) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null) {
            telephony.setRadioIndicationUpdateMode(getSubId(), filters, updateMode);
        }
    } catch (RemoteException ex) {
        // This could happen if binder process crashes.
        if (!isSystemProcess()) {
            ex.rethrowAsRuntimeException();
        }
    }
}
#end_block

#method_before
@Test
public void testDatasetAuthResponseWhileAutofilledAppIsLifecycled() throws Exception {
    // Set service.
    enableService();
    try {
        runShellCommand("wm size 1080x1920");
        runShellCommand("wm density 420");
        // Start activity that is autofilled in a separate process so it can be killed
        Intent outOfProcessAcvitityStartIntent = new Intent(getContext(), OutOfProcessLoginActivity.class);
        getContext().startActivity(outOfProcessAcvitityStartIntent);
        // Set expectations.
        final Bundle extras = new Bundle();
        extras.putString("numbers", "4815162342");
        // Create the authentication intent (launching a full screen activity)
        IntentSender authentication = PendingIntent.getActivity(getContext(), 0, new Intent(getContext(), ManualAuthenticationActivity.class), 0).getIntentSender();
        // Prepare the authenticated response
        ManualAuthenticationActivity.setResponse(new CannedFillResponse.Builder().addDataset(new CannedFillResponse.CannedDataset.Builder().setField(ID_USERNAME, AutofillValue.forText("autofilled username")).setPresentation(createPresentation("dataset")).build()).setRequiredSavableIds(SAVE_DATA_TYPE_PASSWORD, ID_USERNAME, ID_PASSWORD).setExtras(extras).build());
        CannedFillResponse response = new CannedFillResponse.Builder().setAuthentication(authentication, ID_USERNAME, ID_PASSWORD).setPresentation(createPresentation("authenticate")).build();
        sReplier.addResponse(response);
        // Trigger autofill on username
        sUiBot.selectById(USERNAME_FULL_ID);
        // Wait for fill request to be processed
        sReplier.getNextFillRequest();
        // Wait until authentication is shown
        sUiBot.assertDatasets("authenticate");
        // Change orientation which triggers a destroy -> create in the app as the activity
        // cannot deal with such situations
        sUiBot.setScreenOrientation(LANDSCAPE);
        // Delete stopped marker
        getStoppedMarker(getContext()).delete();
        // Authenticate
        sUiBot.selectDataset("authenticate");
        // Kill activity that is in the background
        killOfProcessLoginActivityProcess();
        // Change orientation which triggers a destroy -> create in the app as the activity
        // cannot deal with such situations
        sUiBot.setScreenOrientation(PORTRAIT);
        // Approve authentication
        sUiBot.selectById(BUTTON_FULL_ID);
        // Wait for dataset to be shown
        sUiBot.assertDatasets("dataset");
        // Change orientation which triggers a destroy -> create in the app as the activity
        // cannot deal with such situations
        sUiBot.setScreenOrientation(LANDSCAPE);
        // Select dataset
        sUiBot.selectDataset("dataset");
        // Check the results.
        eventually(() -> assertThat(sUiBot.getTextById(USERNAME_FULL_ID)).isEqualTo("autofilled username"));
        // Set password
        sUiBot.setTextById(PASSWORD_FULL_ID, "new password");
        // Login
        sUiBot.selectById(LOGIN_FULL_ID);
        // Wait for save UI to be shown
        sUiBot.assertShownById("android:id/autofill_save_yes");
        // Change orientation to make sure save UI can handle this
        sUiBot.setScreenOrientation(PORTRAIT);
        // Tap "Save".
        sUiBot.selectById("android:id/autofill_save_yes");
        // Get save request
        InstrumentedAutoFillService.SaveRequest saveRequest = sReplier.getNextSaveRequest();
        assertWithMessage("onSave() not called").that(saveRequest).isNotNull();
        // Make sure data is correctly saved
        final AssistStructure.ViewNode username = findNodeByResourceId(saveRequest.structure, ID_USERNAME);
        assertTextAndValue(username, "autofilled username");
        final AssistStructure.ViewNode password = findNodeByResourceId(saveRequest.structure, ID_PASSWORD);
        assertTextAndValue(password, "new password");
        // Make sure extras were passed back on onSave()
        assertThat(saveRequest.data).isNotNull();
        final String extraValue = saveRequest.data.getString("numbers");
        assertWithMessage("extras not passed on save").that(extraValue).isEqualTo("4815162342");
        eventually(() -> assertNoDanglingSessions());
    } finally {
        runShellCommand("wm density reset");
        runShellCommand("wm size reset");
    }
}
#method_after
@Test
public void testDatasetAuthResponseWhileAutofilledAppIsLifecycled() throws Exception {
    // Set service.
    enableService();
    sUiBot.setScreenResolution();
    try {
        // Start activity that is autofilled in a separate process so it can be killed
        Intent outOfProcessAcvitityStartIntent = new Intent(getContext(), OutOfProcessLoginActivity.class);
        getContext().startActivity(outOfProcessAcvitityStartIntent);
        // Set expectations.
        final Bundle extras = new Bundle();
        extras.putString("numbers", "4815162342");
        // Create the authentication intent (launching a full screen activity)
        IntentSender authentication = PendingIntent.getActivity(getContext(), 0, new Intent(getContext(), ManualAuthenticationActivity.class), 0).getIntentSender();
        // Prepare the authenticated response
        ManualAuthenticationActivity.setResponse(new CannedFillResponse.Builder().addDataset(new CannedFillResponse.CannedDataset.Builder().setField(ID_USERNAME, AutofillValue.forText("autofilled username")).setPresentation(createPresentation("dataset")).build()).setRequiredSavableIds(SAVE_DATA_TYPE_PASSWORD, ID_USERNAME, ID_PASSWORD).setExtras(extras).build());
        CannedFillResponse response = new CannedFillResponse.Builder().setAuthentication(authentication, ID_USERNAME, ID_PASSWORD).setPresentation(createPresentation("authenticate")).build();
        sReplier.addResponse(response);
        // Trigger autofill on username
        sUiBot.selectById(USERNAME_FULL_ID);
        // Wait for fill request to be processed
        sReplier.getNextFillRequest();
        // Wait until authentication is shown
        sUiBot.assertDatasets("authenticate");
        // Change orientation which triggers a destroy -> create in the app as the activity
        // cannot deal with such situations
        sUiBot.setScreenOrientation(LANDSCAPE);
        // Delete stopped marker
        getStoppedMarker(getContext()).delete();
        // Authenticate
        sUiBot.selectDataset("authenticate");
        // Kill activity that is in the background
        killOfProcessLoginActivityProcess();
        // Change orientation which triggers a destroy -> create in the app as the activity
        // cannot deal with such situations
        sUiBot.setScreenOrientation(PORTRAIT);
        // Approve authentication
        sUiBot.selectById(BUTTON_FULL_ID);
        // Wait for dataset to be shown
        sUiBot.assertDatasets("dataset");
        // Change orientation which triggers a destroy -> create in the app as the activity
        // cannot deal with such situations
        sUiBot.setScreenOrientation(LANDSCAPE);
        // Select dataset
        sUiBot.selectDataset("dataset");
        // Check the results.
        eventually(() -> assertThat(sUiBot.getTextById(USERNAME_FULL_ID)).isEqualTo("autofilled username"));
        // Set password
        sUiBot.setTextById(PASSWORD_FULL_ID, "new password");
        // Login
        sUiBot.selectById(LOGIN_FULL_ID);
        // Wait for save UI to be shown
        sUiBot.assertShownById("android:id/autofill_save_yes");
        // Change orientation to make sure save UI can handle this
        sUiBot.setScreenOrientation(PORTRAIT);
        // Tap "Save".
        sUiBot.selectById("android:id/autofill_save_yes");
        // Get save request
        InstrumentedAutoFillService.SaveRequest saveRequest = sReplier.getNextSaveRequest();
        assertWithMessage("onSave() not called").that(saveRequest).isNotNull();
        // Make sure data is correctly saved
        final AssistStructure.ViewNode username = findNodeByResourceId(saveRequest.structure, ID_USERNAME);
        assertTextAndValue(username, "autofilled username");
        final AssistStructure.ViewNode password = findNodeByResourceId(saveRequest.structure, ID_PASSWORD);
        assertTextAndValue(password, "new password");
        // Make sure extras were passed back on onSave()
        assertThat(saveRequest.data).isNotNull();
        final String extraValue = saveRequest.data.getString("numbers");
        assertWithMessage("extras not passed on save").that(extraValue).isEqualTo("4815162342");
        eventually(() -> assertNoDanglingSessions());
    } finally {
        sUiBot.resetScreenResolution();
    }
}
#end_block

#method_before
public static void setResponseCache(OkUrlFactory okUrlFactory, ResponseCache responseCache) {
    OkHttpClient client = okUrlFactory.client();
    if (responseCache instanceof OkCacheContainer) {
        // Avoid adding layers of wrappers. Rather than wrap the ResponseCache in yet another layer to
        // make the ResponseCache look like an InternalCache, we can unwrap the Cache instead.
        // This means that Cache stats will be correctly updated.
        OkCacheContainer okCacheContainer = (OkCacheContainer) responseCache;
        client.setCache(okCacheContainer.getCache());
    // BEGIN Android-added: Recognize internalapi.ShimCacheContainer.
    } else if (responseCache instanceof ShimCacheContainer) {
        // Avoid adding layers of wrappers. Rather than wrap the ResponseCache in yet another layer to
        // make the ResponseCache look like an InternalCache, we can unwrap the Cache instead.
        // This means that Cache stats will be correctly updated.
        ShimCacheContainer cacheContainer = (ShimCacheContainer) responseCache;
        ShimCacheContainer.ShimCache shimCache = cacheContainer.getShimCache();
        client.setCache(shimCache.getCache());
    // END Android-added: Recognize internalapi.ShimCacheContainer.
    } else {
        client.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);
    }
}
#method_after
public static void setResponseCache(OkUrlFactory okUrlFactory, ResponseCache responseCache) {
    OkHttpClient client = okUrlFactory.client();
    if (responseCache instanceof OkCacheContainer) {
        // Avoid adding layers of wrappers. Rather than wrap the ResponseCache in yet another layer to
        // make the ResponseCache look like an InternalCache, we can unwrap the Cache instead.
        // This means that Cache stats will be correctly updated.
        OkCacheContainer okCacheContainer = (OkCacheContainer) responseCache;
        client.setCache(okCacheContainer.getCache());
    // BEGIN Android-added: Recognize internalapi.HasCacheHolder.
    } else if (responseCache instanceof HasCacheHolder) {
        // Avoid adding layers of wrappers. Rather than wrap the ResponseCache in yet another layer to
        // make the ResponseCache look like an InternalCache using CacheAdapter, we can unwrap the
        // held Cache instead. This means that Cache stats will be correctly updated by OkHttp.
        HasCacheHolder hasCacheHolder = (HasCacheHolder) responseCache;
        CacheHolder cacheHolder = hasCacheHolder.getCacheHolder();
        client.setCache(cacheHolder.getCache());
    // END Android-added: Recognize internalapi.HasCacheHolder.
    } else {
        client.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);
    }
}
#end_block

#method_before
public void computeDominators(Node root) {
    long id = 0;
    // The set of nodes xS such that xS.revisit != null.
    // Use a Queue instead of a Set because performance will be better. We
    // avoid adding nodes already on the queue by checking
    // xS == null before adding the node to the queue.
    Queue<NodeS> revisit = new ArrayDeque<NodeS>();
    // Set up the root node specially.
    NodeS rootS = new NodeS();
    rootS.node = root;
    rootS.id = id++;
    rootS.depth = 0;
    graph.setDominatorsComputationState(root, rootS);
    Deque<Link> dfs = new ArrayDeque<Link>();
    dfs.push(new Link(rootS));
    for (Node child : graph.getReferencesForDominators(root)) {
        dfs.push(new Link(rootS, child));
    }
    // workBound is an upper bound on the amount of work required in the
    // second phase of dominators computation, used solely for the purposes of
    // tracking progress.
    long workBound = 0;
    // 1. Do a depth first search of the nodes, label them with ids and come
    // up with initial candidate dominators for them.
    progress.start("Initializing dominators", numNodes);
    while (!dfs.isEmpty()) {
        Link link = dfs.pop();
        if (link.dst == null) {
            // This is the marker link indicating we have now visited all
            // nodes reachable from link.srcS.
            link.srcS.maxReachableId = id - 1;
            progress.advance();
        } else {
            NodeS dstS = (NodeS) graph.getDominatorsComputationState((Node) link.dst);
            if (dstS == null) {
                // We are seeing the destination node for the first time.
                // The candidate dominator is the source node.
                dstS = new NodeS();
                graph.setDominatorsComputationState((Node) link.dst, dstS);
                dstS.node = link.dst;
                dstS.id = id++;
                dstS.inRefIds.add(link.srcS.id);
                dstS.domS = link.srcS;
                dstS.domS.dominated.add(dstS);
                dstS.oldDomS = link.srcS;
                dstS.depth = link.srcS.depth + 1;
                dfs.push(new Link(dstS));
                for (Node child : graph.getReferencesForDominators((Node) link.dst)) {
                    dfs.push(new Link(dstS, child));
                }
            } else {
                // on the new potential dominator.
                if (dstS.inRefIds.size == 1) {
                    workBound += dstS.oldDomS.depth;
                }
                long seenid = dstS.inRefIds.last();
                dstS.inRefIds.add(link.srcS.id);
                // Go up the dominator chain until we reach a node we haven't already
                // seen with a path to dstS.
                NodeS xS = link.srcS;
                while (xS.id > seenid) {
                    xS = xS.domS;
                }
                // The new dominator for dstS must have an id less than the node we
                // just reached. Pull the dominator for dstS up its dominator
                // chain until we find a suitable new dominator for dstS.
                long domid = xS.id;
                if (dstS.domS.id > domid) {
                    // Mark the node as needing to be revisited.
                    if (dstS.domS == dstS.oldDomS) {
                        if (dstS.oldDomS.revisit == null) {
                            dstS.oldDomS.revisit = new NodeSet();
                            revisit.add(dstS.oldDomS);
                        }
                        dstS.oldDomS.revisit.add(dstS);
                    }
                    // Update the node's candidate dominator.
                    dstS.domS.dominated.remove(dstS);
                    do {
                        dstS.domS = dstS.domS.domS;
                    } while (dstS.domS.id > domid);
                    dstS.domS.dominated.add(dstS);
                }
            }
        }
    }
    progress.done();
    // 2. Continue revisiting nodes until every node satisfies the requirement
    // that domS.id == oldDomS.id.
    progress.start("Resolving dominators", workBound);
    while (!revisit.isEmpty()) {
        NodeS oldDomS = revisit.poll();
        assert oldDomS.revisit != null;
        NodeSet nodes = oldDomS.revisit;
        oldDomS.revisit = null;
        // which can have an id smaller than nodeS as xS.domS does.
        for (int i = 0; i < oldDomS.dominated.size; ++i) {
            NodeS xS = oldDomS.dominated.nodes[i];
            for (int j = 0; j < nodes.size; ++j) {
                NodeS nodeS = nodes.nodes[j];
                assert nodeS.oldDomS == oldDomS;
                if (isReachableAscending(nodeS, xS)) {
                    // Update the dominator for xS.
                    if (xS.domS == xS.oldDomS) {
                        if (xS.oldDomS.revisit == null) {
                            xS.oldDomS.revisit = new NodeSet();
                            revisit.add(xS.oldDomS);
                        }
                        xS.oldDomS.revisit.add(xS);
                    }
                    oldDomS.dominated.remove(i--);
                    xS.domS = nodeS.domS;
                    xS.domS.dominated.add(xS);
                    break;
                }
            }
        }
        // preserving the oldDomS invariant.
        for (int i = 0; i < nodes.size; ++i) {
            NodeS nodeS = nodes.nodes[i];
            nodeS.oldDomS = oldDomS.oldDomS;
            if (nodeS.oldDomS != nodeS.domS) {
                if (nodeS.oldDomS.revisit == null) {
                    nodeS.oldDomS.revisit = new NodeSet();
                    revisit.add(nodeS.oldDomS);
                }
                nodeS.oldDomS.revisit.add(nodeS);
            }
        }
        progress.advance((oldDomS.depth - oldDomS.oldDomS.depth) * nodes.size);
    }
    progress.done();
    // user of the results by doing one last traversal of the nodes.
    assert revisit.isEmpty();
    revisit.add(rootS);
    while (!revisit.isEmpty()) {
        NodeS nodeS = revisit.poll();
        assert nodeS.domS == nodeS.oldDomS;
        assert nodeS.revisit == null;
        graph.setDominatorsComputationState((Node) nodeS.node, null);
        for (int i = 0; i < nodeS.dominated.size; ++i) {
            NodeS xS = nodeS.dominated.nodes[i];
            graph.setDominator((Node) xS.node, (Node) nodeS.node);
            revisit.add(xS);
        }
    }
}
#method_after
public void computeDominators(Node root) {
    long id = 0;
    // The set of nodes xS such that xS.revisit != null.
    // Use a Queue instead of a Set because performance will be better. We
    // avoid adding nodes already on the queue by checking
    // xS == null before adding the node to the queue.
    Queue<NodeS> revisit = new ArrayDeque<NodeS>();
    // Set up the root node specially.
    NodeS rootS = new NodeS();
    rootS.node = root;
    rootS.id = id++;
    rootS.depth = 0;
    graph.setDominatorsComputationState(root, rootS);
    Deque<Link<Node>> dfs = new ArrayDeque<Link<Node>>();
    dfs.push(new Link(rootS));
    for (Node child : graph.getReferencesForDominators(root)) {
        dfs.push(new Link(rootS, child));
    }
    // workBound is an upper bound on the amount of work required in the
    // second phase of dominators computation, used solely for the purposes of
    // tracking progress.
    long workBound = 0;
    // 1. Do a depth first search of the nodes, label them with ids and come
    // up with initial candidate dominators for them.
    progress.start("Initializing dominators", numNodes);
    while (!dfs.isEmpty()) {
        Link<Node> link = dfs.pop();
        if (link.dst == null) {
            // This is the marker link indicating we have now visited all
            // nodes reachable from link.srcS.
            link.srcS.maxReachableId = id - 1;
            progress.advance();
        } else {
            NodeS dstS = (NodeS) graph.getDominatorsComputationState(link.dst);
            if (dstS == null) {
                // We are seeing the destination node for the first time.
                // The candidate dominator is the source node.
                dstS = new NodeS();
                graph.setDominatorsComputationState(link.dst, dstS);
                dstS.node = link.dst;
                dstS.id = id++;
                dstS.inRefIds.add(link.srcS.id);
                dstS.domS = link.srcS;
                dstS.domS.dominated.add(dstS);
                dstS.oldDomS = link.srcS;
                dstS.depth = link.srcS.depth + 1;
                dfs.push(new Link<>(dstS));
                for (Node child : graph.getReferencesForDominators(link.dst)) {
                    dfs.push(new Link<>(dstS, child));
                }
            } else {
                // on the new potential dominator.
                if (dstS.inRefIds.size == 1) {
                    workBound += dstS.oldDomS.depth;
                }
                long seenid = dstS.inRefIds.last();
                dstS.inRefIds.add(link.srcS.id);
                // Go up the dominator chain until we reach a node we haven't already
                // seen with a path to dstS.
                NodeS xS = link.srcS;
                while (xS.id > seenid) {
                    xS = xS.domS;
                }
                // The new dominator for dstS must have an id less than the node we
                // just reached. Pull the dominator for dstS up its dominator
                // chain until we find a suitable new dominator for dstS.
                long domid = xS.id;
                if (dstS.domS.id > domid) {
                    // Mark the node as needing to be revisited.
                    if (dstS.domS == dstS.oldDomS) {
                        if (dstS.oldDomS.revisit == null) {
                            dstS.oldDomS.revisit = new NodeSet();
                            revisit.add(dstS.oldDomS);
                        }
                        dstS.oldDomS.revisit.add(dstS);
                    }
                    // Update the node's candidate dominator.
                    dstS.domS.dominated.remove(dstS);
                    do {
                        dstS.domS = dstS.domS.domS;
                    } while (dstS.domS.id > domid);
                    dstS.domS.dominated.add(dstS);
                }
            }
        }
    }
    progress.done();
    // 2. Continue revisiting nodes until every node satisfies the requirement
    // that domS.id == oldDomS.id.
    progress.start("Resolving dominators", workBound);
    while (!revisit.isEmpty()) {
        NodeS oldDomS = revisit.poll();
        assert oldDomS.revisit != null;
        NodeSet nodes = oldDomS.revisit;
        oldDomS.revisit = null;
        // which can have an id smaller than nodeS as xS.domS does.
        for (int i = 0; i < oldDomS.dominated.size; ++i) {
            NodeS xS = oldDomS.dominated.nodes[i];
            for (int j = 0; j < nodes.size; ++j) {
                NodeS nodeS = nodes.nodes[j];
                assert nodeS.oldDomS == oldDomS;
                if (isReachableAscending(nodeS, xS)) {
                    // Update the dominator for xS.
                    if (xS.domS == xS.oldDomS) {
                        if (xS.oldDomS.revisit == null) {
                            xS.oldDomS.revisit = new NodeSet();
                            revisit.add(xS.oldDomS);
                        }
                        xS.oldDomS.revisit.add(xS);
                    }
                    oldDomS.dominated.remove(i--);
                    xS.domS = nodeS.domS;
                    xS.domS.dominated.add(xS);
                    break;
                }
            }
        }
        // preserving the oldDomS invariant.
        for (int i = 0; i < nodes.size; ++i) {
            NodeS nodeS = nodes.nodes[i];
            nodeS.oldDomS = oldDomS.oldDomS;
            if (nodeS.oldDomS != nodeS.domS) {
                if (nodeS.oldDomS.revisit == null) {
                    nodeS.oldDomS.revisit = new NodeSet();
                    revisit.add(nodeS.oldDomS);
                }
                nodeS.oldDomS.revisit.add(nodeS);
            }
        }
        progress.advance((oldDomS.depth - oldDomS.oldDomS.depth) * nodes.size);
    }
    progress.done();
    // user of the results by doing one last traversal of the nodes.
    assert revisit.isEmpty();
    revisit.add(rootS);
    while (!revisit.isEmpty()) {
        NodeS nodeS = revisit.poll();
        assert nodeS.domS == nodeS.oldDomS;
        assert nodeS.revisit == null;
        graph.setDominatorsComputationState((Node) nodeS.node, null);
        for (int i = 0; i < nodeS.dominated.size; ++i) {
            NodeS xS = nodeS.dominated.nodes[i];
            graph.setDominator((Node) xS.node, (Node) nodeS.node);
            revisit.add(xS);
        }
    }
}
#end_block

#method_before
public void heyItsMe(IBazCallback cb) {
    Log.d(TAG, "SERVER: heyItsMe");
}
#method_after
public void heyItsMe(IBazCallback cb) throws RemoteException {
    mCalled = true;
    cb.heyItsMe(null);
}
#end_block

#method_before
public void hey() {
    Log.d(TAG, "SERVER: hey");
}
#method_after
public void hey() {
    mCalled = true;
}
#end_block

#method_before
private void client() throws RemoteException {
    ExpectDeepEq(null, null);
    ExpectDeepNe(null, new String());
    ExpectDeepNe(new String(), null);
    ExpectDeepEq(new String(), new String());
    ExpectDeepEq("hey", "hey");
    ExpectDeepEq(new int[] { 1, 2 }, new int[] { 1, 2 });
    ExpectDeepNe(new int[] { 1, 2 }, new int[] { 1, 3 });
    ExpectDeepNe(new int[] { 1, 2 }, new int[] { 1, 2, 3 });
    ExpectDeepEq(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 4 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 5 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2, 3 }, { 4, 5, 6 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 4, 5 } });
    ExpectDeepEq(new Integer[] { 1, 2 }, new Integer[] { 1, 2 });
    ExpectDeepNe(new Integer[] { 1, 2 }, new Integer[] { 1, 3 });
    ExpectDeepNe(new Integer[] { 1, 2 }, new Integer[] { 1, 2, 3 });
    ExpectDeepEq(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 4 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 5 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2, 3 }, { 4, 5, 6 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 4, 5 } });
    ExpectDeepEq(new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(1, 2)));
    ExpectDeepNe(new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(1, 2, 3)));
    ExpectDeepEq(new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })), new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })));
    ExpectDeepNe(new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })), new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 5 })));
    ExpectDeepEq(new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })), new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })));
    ExpectDeepNe(new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })), new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 5 })));
    ExpectDeepEq(new ArrayList[] { new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(3, 4)) }, new ArrayList[] { new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(3, 4)) });
    {
        // Test proper exceptions are thrown
        try {
            IBase proxy = IBase.getService("this-doesn't-exist");
            // this should never run
            ExpectTrue(false);
        } catch (Exception e) {
            ExpectTrue(e instanceof NoSuchElementException);
        }
    }
    {
        // Test access through base interface binder.
        IBase baseProxy = IBase.getService("baz");
        baseProxy.someBaseMethod();
        IBaz bazProxy = IBaz.castFrom(baseProxy);
        ExpectTrue(bazProxy != null);
        // IQuux is completely unrelated to IBase/IBaz, so the following
        // should fail, i.e. return null.
        IQuux quuxProxy = IQuux.castFrom(baseProxy);
        ExpectTrue(quuxProxy == null);
    }
    {
        // Test waiting API
        IBase baseProxyA = IBaz.getService("baz", true);
        ExpectTrue(baseProxyA != null);
        IBase baseProxyB = IBaz.getService("baz", false);
        ExpectTrue(baseProxyB != null);
    }
    IBaz proxy = IBaz.getService("baz");
    proxy.ping();
    proxy.someBaseMethod();
    {
        Expect(proxy.interfaceDescriptor(), IBaz.kInterfaceName);
    }
    {
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        IBase.Foo result = proxy.someOtherBaseMethod(foo);
        ExpectTrue(result.equals(foo));
    }
    {
        IBase.Foo[] inputArray = new IBase.Foo[2];
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputArray[0] = foo;
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputArray[1] = foo;
        IBase.Foo[] expectedOutputArray = new IBase.Foo[2];
        expectedOutputArray[0] = inputArray[1];
        expectedOutputArray[1] = inputArray[0];
        IBase.Foo[] outputArray = proxy.someMethodWithFooArrays(inputArray);
        ExpectTrue(java.util.Objects.deepEquals(outputArray, expectedOutputArray));
    }
    {
        ArrayList<IBase.Foo> inputVec = new ArrayList<IBase.Foo>();
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputVec.add(foo);
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputVec.add(foo);
        ArrayList<IBase.Foo> expectedOutputVec = new ArrayList<IBase.Foo>();
        expectedOutputVec.add(inputVec.get(1));
        expectedOutputVec.add(inputVec.get(0));
        ArrayList<IBase.Foo> outputVec = proxy.someMethodWithFooVectors(inputVec);
        ExpectTrue(java.util.Objects.deepEquals(outputVec, expectedOutputVec));
    }
    {
        IBase.VectorOfArray in = new IBase.VectorOfArray();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.addresses.add(mac);
        }
        IBase.VectorOfArray expectedOut = new IBase.VectorOfArray();
        int n = in.addresses.size();
        for (int i = 0; i < n; ++i) {
            expectedOut.addresses.add(in.addresses.get(n - 1 - i));
        }
        IBase.VectorOfArray out = proxy.someMethodWithVectorOfArray(in);
        ExpectTrue(out.equals(expectedOut));
    }
    {
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.add(mac);
        }
        ArrayList<byte[]> expectedOut = new ArrayList<byte[]>();
        int n = in.size();
        for (int i = 0; i < n; ++i) {
            expectedOut.add(in.get(n - 1 - i));
        }
        ArrayList<byte[]> out = proxy.someMethodTakingAVectorOfArray(in);
        ExpectTrue(out.size() == expectedOut.size());
        for (int i = 0; i < n; ++i) {
            ExpectTrue(java.util.Objects.deepEquals(out.get(i), expectedOut.get(i)));
        }
    }
    {
        IBase.StringMatrix5x3 in = new IBase.StringMatrix5x3();
        IBase.StringMatrix3x5 expectedOut = new IBase.StringMatrix3x5();
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in.s[i][j] = numberToEnglish(3 * i + j + 1);
                expectedOut.s[j][i] = in.s[i][j];
            }
        }
        IBase.StringMatrix3x5 out = proxy.transpose(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        ExpectTrue(out.equals(expectedOut));
    }
    {
        String[][] in = new String[5][3];
        String[][] expectedOut = new String[3][5];
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in[i][j] = numberToEnglish(3 * i + j + 1);
                expectedOut[j][i] = in[i][j];
            }
        }
        String[][] out = proxy.transpose2(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        ExpectTrue(java.util.Arrays.deepEquals(out, expectedOut));
    }
    ExpectTrue(proxy.someBoolMethod(true) == false);
    {
        boolean[] someBoolArray = new boolean[3];
        someBoolArray[0] = true;
        someBoolArray[1] = false;
        someBoolArray[2] = true;
        boolean[] resultArray = proxy.someBoolArrayMethod(someBoolArray);
        ExpectTrue(resultArray[0] == false);
        ExpectTrue(resultArray[1] == true);
        ExpectTrue(resultArray[2] == false);
        ArrayList<Boolean> someBoolVec = new ArrayList<Boolean>();
        someBoolVec.add(true);
        someBoolVec.add(false);
        someBoolVec.add(true);
        ArrayList<Boolean> resultVec = proxy.someBoolVectorMethod(someBoolVec);
        ExpectTrue(resultVec.get(0) == false);
        ExpectTrue(resultVec.get(1) == true);
        ExpectTrue(resultVec.get(2) == false);
    }
    proxy.doThis(1.0f);
    ExpectTrue(proxy.doThatAndReturnSomething(1) == 666);
    ExpectTrue(proxy.doQuiteABit(1, 2L, 3.0f, 4.0) == 666.5);
    {
        int[] paramArray = new int[15];
        int[] expectedOutArray = new int[32];
        ArrayList<Integer> paramVec = new ArrayList<Integer>();
        ArrayList<Integer> expectedOutVec = new ArrayList<Integer>();
        for (int i = 0; i < paramArray.length; ++i) {
            paramArray[i] = i;
            paramVec.add(i);
            expectedOutArray[i] = 2 * i;
            expectedOutArray[15 + i] = i;
            expectedOutVec.add(2 * i);
        }
        expectedOutArray[30] = 1;
        expectedOutArray[31] = 2;
        int[] outArray = proxy.doSomethingElse(paramArray);
        ExpectTrue(java.util.Objects.deepEquals(outArray, expectedOutArray));
        ArrayList<Integer> outVec = proxy.mapThisVector(paramVec);
        java.util.Objects.equals(outVec, expectedOutVec);
    }
    Expect(proxy.doStuffAndReturnAString(), "Hello, world!");
    BazCallback cb = new BazCallback();
    ExpectTrue(!cb.wasCalled());
    proxy.callMe(cb);
    ExpectTrue(cb.wasCalled());
    ExpectTrue(proxy.useAnEnum(IBaz.SomeEnum.goober) == -64);
    {
        String[] stringArray = new String[3];
        stringArray[0] = "one";
        stringArray[1] = "two";
        stringArray[2] = "three";
        String[] expectedOutArray = new String[2];
        expectedOutArray[0] = "Hello";
        expectedOutArray[1] = "World";
        String[] outArray = proxy.haveSomeStrings(stringArray);
        ExpectTrue(java.util.Arrays.deepEquals(outArray, expectedOutArray));
        ArrayList<String> stringVec = new ArrayList<String>();
        stringVec.add("one");
        stringVec.add("two");
        stringVec.add("three");
        ArrayList<String> expectedOutVec = new ArrayList<String>();
        expectedOutVec.add("Hello");
        expectedOutVec.add("World");
        ExpectTrue(expectedOutVec.equals(proxy.haveAStringVec(stringVec)));
    }
    proxy.returnABunchOfStrings(new IBaz.returnABunchOfStringsCallback() {

        @Override
        public void onValues(String a, String b, String c) {
            Expect(a, "Eins");
            Expect(b, "Zwei");
            Expect(c, "Drei");
        }
    });
    proxy.returnABunchOfStrings((a, b, c) -> Expect(a + b + c, "EinsZweiDrei"));
    proxy.callMeLater(new BazCallback());
    System.gc();
    proxy.iAmFreeNow();
    {
        IBaz.T t1 = new IBaz.T();
        IBaz.T t2 = new IBaz.T();
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 3; j++) {
                t1.matrix5x3[i][j] = t2.matrix5x3[i][j] = (i + 1) * (j + 1);
            }
        }
        ExpectTrue(t1.equals(t2));
        ExpectTrue(t1.hashCode() == t2.hashCode());
        t2.matrix5x3[4][2] = -60;
        ExpectTrue(!t1.equals(t2));
    }
    ArrayList<NestedStruct> structs = proxy.getNestedStructs();
    ExpectTrue(structs.size() == 5);
    ExpectTrue(structs.get(1).matrices.size() == 6);
    {
        IBaz.Everything e = new IBaz.Everything();
        Expect(e.toString(), "{.number = 0, .anotherNumber = 0, .s = , " + ".vs = [], .multidimArray = [[null, null], [null, null]], " + ".sArray = [null, null, null], .anotherStruct = {.first = , .last = }, .bf = }");
        e.s = "string!";
        e.number = 127;
        e.anotherNumber = 100;
        e.vs.addAll(Arrays.asList("One", "Two", "Three"));
        for (int i = 0; i < e.multidimArray.length; i++) for (int j = 0; j < e.multidimArray[i].length; j++) e.multidimArray[i][j] = Integer.toString(i) + Integer.toString(j);
        e.bf = IBaz.BitField.VALL;
        e.anotherStruct.first = "James";
        e.anotherStruct.last = "Bond";
        Expect(e.toString(), "{.number = 127, .anotherNumber = 100, .s = string!, " + ".vs = [One, Two, Three], .multidimArray = [[00, 01], [10, 11]], " + ".sArray = [null, null, null], .anotherStruct = {.first = James, .last = Bond}, " + ".bf = V0 | V1 | V2 | V3 | VALL}");
        Expect(IBaz.BitField.toString(IBaz.BitField.VALL), "VALL");
        Expect(IBaz.BitField.toString((byte) (IBaz.BitField.V0 | IBaz.BitField.V2)), "0x5");
        Expect(IBaz.BitField.dumpBitfield(IBaz.BitField.VALL), "V0 | V1 | V2 | V3 | VALL");
        Expect(IBaz.BitField.dumpBitfield((byte) (IBaz.BitField.V1 | IBaz.BitField.V3 | 0xF0)), "V1 | V3 | 0xf0");
        Expect(proxy.toString(), IBaz.kInterfaceName + "@Proxy");
    }
    {
        // Ensure that native parcel is cleared even if the corresponding
        // Java object isn't GC'd.
        ArrayList<Integer> data4K = new ArrayList<>(1024);
        for (int i = 0; i < 1024; i++) {
            data4K.add(i);
        }
        for (int i = 0; i < 1024; i++) {
            // kernel binder buffer, and will fail.
            try {
                proxy.mapThisVector(data4K);
            } catch (RemoteException ex) {
                throw new RuntimeException("Failed at call #" + Integer.toString(i), ex);
            }
        }
    }
    {
        // TestArrays
        IBase.LotsOfPrimitiveArrays in = new IBase.LotsOfPrimitiveArrays();
        for (int i = 0; i < 128; ++i) {
            in.byte1[i] = (byte) i;
            in.boolean1[i] = (i & 4) != 0;
            in.double1[i] = i;
        }
        int m = 0;
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 128; ++j, ++m) {
                in.byte2[i][j] = (byte) m;
                in.boolean2[i][j] = (m & 4) != 0;
                in.double2[i][j] = m;
            }
        }
        m = 0;
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 16; ++j) {
                for (int k = 0; k < 128; ++k, ++m) {
                    in.byte3[i][j][k] = (byte) m;
                    in.boolean3[i][j][k] = (m & 4) != 0;
                    in.double3[i][j][k] = m;
                }
            }
        }
        IBase.LotsOfPrimitiveArrays out = proxy.testArrays(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testByteVecs
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            byte[] elem = new byte[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = (byte) k;
            }
            in.add(elem);
        }
        ArrayList<byte[]> out = proxy.testByteVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testBooleanVecs
        ArrayList<boolean[]> in = new ArrayList<boolean[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            boolean[] elem = new boolean[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = (k & 4) != 0;
            }
            in.add(elem);
        }
        ArrayList<boolean[]> out = proxy.testBooleanVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testDoubleVecs
        ArrayList<double[]> in = new ArrayList<double[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            double[] elem = new double[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = k;
            }
            in.add(elem);
        }
        ArrayList<double[]> out = proxy.testDoubleVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testProxyEquals
        // TODO(b/68727931): test passthrough services as well.
        IBase proxy1 = IBase.getService("baz");
        IBase proxy2 = IBase.getService("baz");
        IBaz proxy3 = IBaz.getService("baz");
        IBazCallback callback1 = new BazCallback();
        IBazCallback callback2 = new BazCallback();
        IServiceManager manager = IServiceManager.getService();
        // test hwbinder proxies
        // same proxy class
        ExpectEqual(proxy1, proxy2);
        // different proxy class
        ExpectEqual(proxy1, proxy3);
        // negative tests
        ExpectNotEqual(proxy1, null);
        // proxy != stub
        ExpectNotEqual(proxy1, callback1);
        ExpectNotEqual(proxy1, manager);
        // HidlSupport.interfacesEqual use overridden .equals for stubs
        ExpectEqual(callback1, callback1);
        ExpectEqual(callback1, callback2);
        callback1.hey();
        ExpectNotEqual(callback1, callback2);
        callback2.hey();
        ExpectEqual(callback1, callback2);
        // test hash for proxies
        java.util.HashSet<IBase> set = new java.util.HashSet<>();
        set.add(proxy1);
        // hash is stable
        ExpectTrue(set.contains(proxy1));
        ExpectTrue(set.contains(proxy2));
        ExpectFalse(set.contains(manager));
    }
    {
        IBaz baz = IBaz.getService("baz");
        ExpectTrue(baz != null);
        IBaz.StructWithInterface swi = new IBaz.StructWithInterface();
        swi.dummy = baz;
        swi.number = 12345678;
        IBaz.StructWithInterface swi_back = baz.haveSomeStructWithInterface(swi);
        ExpectTrue(swi_back != null);
        ExpectTrue(swi_back.dummy != null);
        ExpectTrue(HidlSupport.interfacesEqual(baz, swi_back.dummy));
        ExpectTrue(swi_back.number == 12345678);
    }
    // --- DEATH RECIPIENT TESTING ---
    // This must always be done last, since it will kill the native server process
    HidlDeathRecipient recipient1 = new HidlDeathRecipient();
    HidlDeathRecipient recipient2 = new HidlDeathRecipient();
    final int cookie1 = 0x1481;
    final int cookie2 = 0x1482;
    ExpectTrue(proxy.linkToDeath(recipient1, cookie1));
    ExpectTrue(proxy.linkToDeath(recipient2, cookie2));
    ExpectTrue(proxy.unlinkToDeath(recipient2));
    try {
        proxy.dieNow();
    } catch (RemoteException e) {
    // Expected
    }
    ExpectTrue(recipient1.waitUntilServiceDied(2000));
    ExpectTrue(!recipient2.waitUntilServiceDied(2000));
    ExpectTrue(recipient1.cookieMatches(cookie1));
    Log.d(TAG, "OK, exiting");
}
#method_after
private void client() throws RemoteException {
    ExpectDeepEq(null, null);
    ExpectDeepNe(null, new String());
    ExpectDeepNe(new String(), null);
    ExpectDeepEq(new String(), new String());
    ExpectDeepEq("hey", "hey");
    ExpectDeepEq(new int[] { 1, 2 }, new int[] { 1, 2 });
    ExpectDeepNe(new int[] { 1, 2 }, new int[] { 1, 3 });
    ExpectDeepNe(new int[] { 1, 2 }, new int[] { 1, 2, 3 });
    ExpectDeepEq(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 4 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 5 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2, 3 }, { 4, 5, 6 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 4, 5 } });
    ExpectDeepEq(new Integer[] { 1, 2 }, new Integer[] { 1, 2 });
    ExpectDeepNe(new Integer[] { 1, 2 }, new Integer[] { 1, 3 });
    ExpectDeepNe(new Integer[] { 1, 2 }, new Integer[] { 1, 2, 3 });
    ExpectDeepEq(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 4 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 5 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2, 3 }, { 4, 5, 6 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 4, 5 } });
    ExpectDeepEq(new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(1, 2)));
    ExpectDeepNe(new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(1, 2, 3)));
    ExpectDeepEq(new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })), new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })));
    ExpectDeepNe(new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })), new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 5 })));
    ExpectDeepEq(new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })), new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })));
    ExpectDeepNe(new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })), new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 5 })));
    ExpectDeepEq(new ArrayList[] { new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(3, 4)) }, new ArrayList[] { new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(3, 4)) });
    {
        // Test proper exceptions are thrown
        try {
            IBase proxy = IBase.getService("this-doesn't-exist");
            // this should never run
            ExpectTrue(false);
        } catch (Exception e) {
            ExpectTrue(e instanceof NoSuchElementException);
        }
    }
    {
        // Test access through base interface binder.
        IBase baseProxy = IBase.getService();
        baseProxy.someBaseMethod();
        IBaz bazProxy = IBaz.castFrom(baseProxy);
        ExpectTrue(bazProxy != null);
        // IQuux is completely unrelated to IBase/IBaz, so the following
        // should fail, i.e. return null.
        IQuux quuxProxy = IQuux.castFrom(baseProxy);
        ExpectTrue(quuxProxy == null);
    }
    {
        // Test waiting API
        IBase baseProxyA = IBaz.getService(true);
        ExpectTrue(baseProxyA != null);
        IBase baseProxyB = IBaz.getService(false);
        ExpectTrue(baseProxyB != null);
    }
    IBaz proxy = IBaz.getService();
    proxy.ping();
    proxy.someBaseMethod();
    {
        Expect(proxy.interfaceDescriptor(), IBaz.kInterfaceName);
    }
    {
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        IBase.Foo result = proxy.someOtherBaseMethod(foo);
        ExpectTrue(result.equals(foo));
    }
    {
        IBase.Foo[] inputArray = new IBase.Foo[2];
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputArray[0] = foo;
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputArray[1] = foo;
        IBase.Foo[] expectedOutputArray = new IBase.Foo[2];
        expectedOutputArray[0] = inputArray[1];
        expectedOutputArray[1] = inputArray[0];
        IBase.Foo[] outputArray = proxy.someMethodWithFooArrays(inputArray);
        ExpectTrue(java.util.Objects.deepEquals(outputArray, expectedOutputArray));
    }
    {
        ArrayList<IBase.Foo> inputVec = new ArrayList<IBase.Foo>();
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputVec.add(foo);
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputVec.add(foo);
        ArrayList<IBase.Foo> expectedOutputVec = new ArrayList<IBase.Foo>();
        expectedOutputVec.add(inputVec.get(1));
        expectedOutputVec.add(inputVec.get(0));
        ArrayList<IBase.Foo> outputVec = proxy.someMethodWithFooVectors(inputVec);
        ExpectTrue(java.util.Objects.deepEquals(outputVec, expectedOutputVec));
    }
    {
        IBase.VectorOfArray in = new IBase.VectorOfArray();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.addresses.add(mac);
        }
        IBase.VectorOfArray expectedOut = new IBase.VectorOfArray();
        int n = in.addresses.size();
        for (int i = 0; i < n; ++i) {
            expectedOut.addresses.add(in.addresses.get(n - 1 - i));
        }
        IBase.VectorOfArray out = proxy.someMethodWithVectorOfArray(in);
        ExpectTrue(out.equals(expectedOut));
    }
    {
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.add(mac);
        }
        ArrayList<byte[]> expectedOut = new ArrayList<byte[]>();
        int n = in.size();
        for (int i = 0; i < n; ++i) {
            expectedOut.add(in.get(n - 1 - i));
        }
        ArrayList<byte[]> out = proxy.someMethodTakingAVectorOfArray(in);
        ExpectTrue(out.size() == expectedOut.size());
        for (int i = 0; i < n; ++i) {
            ExpectTrue(java.util.Objects.deepEquals(out.get(i), expectedOut.get(i)));
        }
    }
    {
        IBase.StringMatrix5x3 in = new IBase.StringMatrix5x3();
        IBase.StringMatrix3x5 expectedOut = new IBase.StringMatrix3x5();
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in.s[i][j] = numberToEnglish(3 * i + j + 1);
                expectedOut.s[j][i] = in.s[i][j];
            }
        }
        IBase.StringMatrix3x5 out = proxy.transpose(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        ExpectTrue(out.equals(expectedOut));
    }
    {
        String[][] in = new String[5][3];
        String[][] expectedOut = new String[3][5];
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in[i][j] = numberToEnglish(3 * i + j + 1);
                expectedOut[j][i] = in[i][j];
            }
        }
        String[][] out = proxy.transpose2(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        ExpectTrue(java.util.Arrays.deepEquals(out, expectedOut));
    }
    ExpectTrue(proxy.someBoolMethod(true) == false);
    {
        boolean[] someBoolArray = new boolean[3];
        someBoolArray[0] = true;
        someBoolArray[1] = false;
        someBoolArray[2] = true;
        boolean[] resultArray = proxy.someBoolArrayMethod(someBoolArray);
        ExpectTrue(resultArray[0] == false);
        ExpectTrue(resultArray[1] == true);
        ExpectTrue(resultArray[2] == false);
        ArrayList<Boolean> someBoolVec = new ArrayList<Boolean>();
        someBoolVec.add(true);
        someBoolVec.add(false);
        someBoolVec.add(true);
        ArrayList<Boolean> resultVec = proxy.someBoolVectorMethod(someBoolVec);
        ExpectTrue(resultVec.get(0) == false);
        ExpectTrue(resultVec.get(1) == true);
        ExpectTrue(resultVec.get(2) == false);
    }
    proxy.doThis(1.0f);
    ExpectTrue(proxy.doThatAndReturnSomething(1) == 666);
    ExpectTrue(proxy.doQuiteABit(1, 2L, 3.0f, 4.0) == 666.5);
    {
        int[] paramArray = new int[15];
        int[] expectedOutArray = new int[32];
        ArrayList<Integer> paramVec = new ArrayList<Integer>();
        ArrayList<Integer> expectedOutVec = new ArrayList<Integer>();
        for (int i = 0; i < paramArray.length; ++i) {
            paramArray[i] = i;
            paramVec.add(i);
            expectedOutArray[i] = 2 * i;
            expectedOutArray[15 + i] = i;
            expectedOutVec.add(2 * i);
        }
        expectedOutArray[30] = 1;
        expectedOutArray[31] = 2;
        int[] outArray = proxy.doSomethingElse(paramArray);
        ExpectTrue(java.util.Objects.deepEquals(outArray, expectedOutArray));
        ArrayList<Integer> outVec = proxy.mapThisVector(paramVec);
        java.util.Objects.equals(outVec, expectedOutVec);
    }
    Expect(proxy.doStuffAndReturnAString(), "Hello, world!");
    BazCallback cb = new BazCallback();
    ExpectTrue(!cb.wasCalled());
    proxy.callMe(cb);
    ExpectTrue(cb.wasCalled());
    ExpectTrue(proxy.useAnEnum(IBaz.SomeEnum.goober) == -64);
    {
        String[] stringArray = new String[3];
        stringArray[0] = "one";
        stringArray[1] = "two";
        stringArray[2] = "three";
        String[] expectedOutArray = new String[2];
        expectedOutArray[0] = "Hello";
        expectedOutArray[1] = "World";
        String[] outArray = proxy.haveSomeStrings(stringArray);
        ExpectTrue(java.util.Arrays.deepEquals(outArray, expectedOutArray));
        ArrayList<String> stringVec = new ArrayList<String>();
        stringVec.add("one");
        stringVec.add("two");
        stringVec.add("three");
        ArrayList<String> expectedOutVec = new ArrayList<String>();
        expectedOutVec.add("Hello");
        expectedOutVec.add("World");
        ExpectTrue(expectedOutVec.equals(proxy.haveAStringVec(stringVec)));
    }
    proxy.returnABunchOfStrings(new IBaz.returnABunchOfStringsCallback() {

        @Override
        public void onValues(String a, String b, String c) {
            Expect(a, "Eins");
            Expect(b, "Zwei");
            Expect(c, "Drei");
        }
    });
    proxy.returnABunchOfStrings((a, b, c) -> Expect(a + b + c, "EinsZweiDrei"));
    proxy.callMeLater(new BazCallback());
    System.gc();
    proxy.iAmFreeNow();
    {
        IBaz.T t1 = new IBaz.T();
        IBaz.T t2 = new IBaz.T();
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 3; j++) {
                t1.matrix5x3[i][j] = t2.matrix5x3[i][j] = (i + 1) * (j + 1);
            }
        }
        ExpectTrue(t1.equals(t2));
        ExpectTrue(t1.hashCode() == t2.hashCode());
        t2.matrix5x3[4][2] = -60;
        ExpectTrue(!t1.equals(t2));
    }
    ArrayList<NestedStruct> structs = proxy.getNestedStructs();
    ExpectTrue(structs.size() == 5);
    ExpectTrue(structs.get(1).matrices.size() == 6);
    {
        IBaz.Everything e = new IBaz.Everything();
        Expect(e.toString(), "{.number = 0, .anotherNumber = 0, .s = , " + ".vs = [], .multidimArray = [[null, null], [null, null]], " + ".sArray = [null, null, null], .anotherStruct = {.first = , .last = }, .bf = }");
        e.s = "string!";
        e.number = 127;
        e.anotherNumber = 100;
        e.vs.addAll(Arrays.asList("One", "Two", "Three"));
        for (int i = 0; i < e.multidimArray.length; i++) for (int j = 0; j < e.multidimArray[i].length; j++) e.multidimArray[i][j] = Integer.toString(i) + Integer.toString(j);
        e.bf = IBaz.BitField.VALL;
        e.anotherStruct.first = "James";
        e.anotherStruct.last = "Bond";
        Expect(e.toString(), "{.number = 127, .anotherNumber = 100, .s = string!, " + ".vs = [One, Two, Three], .multidimArray = [[00, 01], [10, 11]], " + ".sArray = [null, null, null], .anotherStruct = {.first = James, .last = Bond}, " + ".bf = V0 | V1 | V2 | V3 | VALL}");
        Expect(IBaz.BitField.toString(IBaz.BitField.VALL), "VALL");
        Expect(IBaz.BitField.toString((byte) (IBaz.BitField.V0 | IBaz.BitField.V2)), "0x5");
        Expect(IBaz.BitField.dumpBitfield(IBaz.BitField.VALL), "V0 | V1 | V2 | V3 | VALL");
        Expect(IBaz.BitField.dumpBitfield((byte) (IBaz.BitField.V1 | IBaz.BitField.V3 | 0xF0)), "V1 | V3 | 0xf0");
        Expect(proxy.toString(), IBaz.kInterfaceName + "@Proxy");
    }
    {
        // Ensure that native parcel is cleared even if the corresponding
        // Java object isn't GC'd.
        ArrayList<Integer> data4K = new ArrayList<>(1024);
        for (int i = 0; i < 1024; i++) {
            data4K.add(i);
        }
        for (int i = 0; i < 1024; i++) {
            // kernel binder buffer, and will fail.
            try {
                proxy.mapThisVector(data4K);
            } catch (RemoteException ex) {
                throw new RuntimeException("Failed at call #" + Integer.toString(i), ex);
            }
        }
    }
    {
        // TestArrays
        IBase.LotsOfPrimitiveArrays in = new IBase.LotsOfPrimitiveArrays();
        for (int i = 0; i < 128; ++i) {
            in.byte1[i] = (byte) i;
            in.boolean1[i] = (i & 4) != 0;
            in.double1[i] = i;
        }
        int m = 0;
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 128; ++j, ++m) {
                in.byte2[i][j] = (byte) m;
                in.boolean2[i][j] = (m & 4) != 0;
                in.double2[i][j] = m;
            }
        }
        m = 0;
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 16; ++j) {
                for (int k = 0; k < 128; ++k, ++m) {
                    in.byte3[i][j][k] = (byte) m;
                    in.boolean3[i][j][k] = (m & 4) != 0;
                    in.double3[i][j][k] = m;
                }
            }
        }
        IBase.LotsOfPrimitiveArrays out = proxy.testArrays(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testByteVecs
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            byte[] elem = new byte[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = (byte) k;
            }
            in.add(elem);
        }
        ArrayList<byte[]> out = proxy.testByteVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testBooleanVecs
        ArrayList<boolean[]> in = new ArrayList<boolean[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            boolean[] elem = new boolean[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = (k & 4) != 0;
            }
            in.add(elem);
        }
        ArrayList<boolean[]> out = proxy.testBooleanVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testDoubleVecs
        ArrayList<double[]> in = new ArrayList<double[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            double[] elem = new double[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = k;
            }
            in.add(elem);
        }
        ArrayList<double[]> out = proxy.testDoubleVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testProxyEquals
        // TODO(b/68727931): test passthrough services as well.
        IBase proxy1 = IBase.getService();
        IBase proxy2 = IBase.getService();
        IBaz proxy3 = IBaz.getService();
        IBazCallback callback1 = new BazCallback();
        IBazCallback callback2 = new BazCallback();
        IServiceManager manager = IServiceManager.getService();
        // test hwbinder proxies
        // same proxy class
        ExpectEqual(proxy1, proxy2);
        // different proxy class
        ExpectEqual(proxy1, proxy3);
        // negative tests
        ExpectNotEqual(proxy1, null);
        // proxy != stub
        ExpectNotEqual(proxy1, callback1);
        ExpectNotEqual(proxy1, manager);
        // HidlSupport.interfacesEqual use overridden .equals for stubs
        ExpectEqual(callback1, callback1);
        ExpectEqual(callback1, callback2);
        callback1.hey();
        ExpectNotEqual(callback1, callback2);
        callback2.hey();
        ExpectEqual(callback1, callback2);
        // test hash for proxies
        java.util.HashSet<IBase> set = new java.util.HashSet<>();
        set.add(proxy1);
        // hash is stable
        ExpectTrue(set.contains(proxy1));
        ExpectTrue(set.contains(proxy2));
        ExpectFalse(set.contains(manager));
    }
    {
        IBaz baz = IBaz.getService();
        ExpectTrue(baz != null);
        IBaz.StructWithInterface swi = new IBaz.StructWithInterface();
        swi.dummy = baz;
        swi.number = 12345678;
        IBaz.StructWithInterface swi_back = baz.haveSomeStructWithInterface(swi);
        ExpectTrue(swi_back != null);
        ExpectTrue(swi_back.dummy != null);
        ExpectTrue(HidlSupport.interfacesEqual(baz, swi_back.dummy));
        ExpectTrue(swi_back.number == 12345678);
    }
    runClientSafeUnionTests();
    // --- DEATH RECIPIENT TESTING ---
    // This must always be done last, since it will kill the native server process
    HidlDeathRecipient recipient1 = new HidlDeathRecipient();
    HidlDeathRecipient recipient2 = new HidlDeathRecipient();
    final int cookie1 = 0x1481;
    final int cookie2 = 0x1482;
    ExpectTrue(proxy.linkToDeath(recipient1, cookie1));
    ExpectTrue(proxy.linkToDeath(recipient2, cookie2));
    ExpectTrue(proxy.unlinkToDeath(recipient2));
    try {
        proxy.dieNow();
    } catch (RemoteException e) {
    // Expected
    }
    ExpectTrue(recipient1.waitUntilServiceDied(2000));
    ExpectTrue(!recipient2.waitUntilServiceDied(2000));
    ExpectTrue(recipient1.cookieMatches(cookie1));
    Log.d(TAG, "OK, exiting");
}
#end_block

#method_before
private void server() throws RemoteException {
    HwBinder.configureRpcThreadpool(1, true);
    Baz baz = new Baz();
    baz.registerAsService("baz");
    SafeUnion safeunionInterface = new SafeUnion();
    safeunionInterface.registerAsService("safeunion");
    OtherInterface otherInterface = new OtherInterface();
    otherInterface.registerAsService("otherinterface");
    HwBinder.joinRpcThreadpool();
}
#method_after
private void server() throws RemoteException {
    HwBinder.configureRpcThreadpool(1, true);
    Baz baz = new Baz();
    baz.registerAsService("default");
    SafeUnion safeunionInterface = new SafeUnion();
    safeunionInterface.registerAsService("default");
    OtherInterface otherInterface = new OtherInterface();
    otherInterface.registerAsService("default");
    HwBinder.joinRpcThreadpool();
}
#end_block

#method_before
public void test_end() throws Exception {
    // test method of java.util.zip.inflater.end()
    byte[] byteArray = { 5, 2, 3, 7, 8 };
    int r = 0;
    Inflater inflate = new Inflater();
    inflate.setInput(byteArray);
    inflate.end();
    // This does not fail even though end() has been called.
    inflate.setInput(byteArray);
    try {
        inflate.reset();
    } catch (NullPointerException expected) {
        checkInflaterClosed(expected);
    }
    Inflater i = new Inflater();
    i.end();
    // check for exception
    i.end();
}
#method_after
public void test_end() throws Exception {
    // test method of java.util.zip.inflater.end()
    byte[] byteArray = { 5, 2, 3, 7, 8 };
    int r = 0;
    Inflater inflate = new Inflater();
    inflate.setInput(byteArray);
    inflate.end();
    try {
        inflate.reset();
    } catch (NullPointerException expected) {
    // Expected
    }
    Inflater i = new Inflater();
    i.end();
    // check for exception
    i.end();
}
#end_block

#method_before
public void test_inflate$BII() {
    // test method of java.util.zip.inflater.inflate(byte,int,int)
    byte[] byteArray = { 1, 3, 4, 7, 8, 'e', 'r', 't', 'y', '5' };
    byte[] outPutInf = new byte[100];
    int y = 0;
    Inflater inflate = new Inflater();
    try {
        while (!(inflate.finished())) {
            if (inflate.needsInput()) {
                assertEquals(0, inflate.inflate(outPutInf, 0, 1));
                inflate.setInput(outPutBuff1);
            }
            y += inflate.inflate(outPutInf, y, outPutInf.length - y);
        }
    } catch (DataFormatException e) {
        fail("Invalid input to be decompressed");
    }
    for (int i = 0; i < byteArray.length; i++) {
        assertEquals("Final decompressed data does not equal the original data", byteArray[i], outPutInf[i]);
    }
    assertEquals("final decompressed data contained more bytes than original - inflateB", 0, outPutInf[byteArray.length]);
    // test boundary checks
    inflate.reset();
    int r = 0;
    int offSet = 0;
    int lengthError = 101;
    try {
        if (inflate.needsInput()) {
            inflate.setInput(outPutBuff1);
        }
        inflate.inflate(outPutInf, offSet, lengthError);
    } catch (DataFormatException e) {
        fail("Invalid input to be decompressed");
    } catch (ArrayIndexOutOfBoundsException e) {
        r = 1;
    }
    assertEquals("out of bounds error did not get caught", 1, r);
    try {
        assertEquals(0, inflate.inflate(outPutInf, offSet, 0));
    } catch (DataFormatException e) {
        fail("Invalid input to be decompressed");
    }
    inflate.end();
    try {
        inflate.inflate(outPutInf, offSet, 1);
        fail("NullPointerException expected");
    } catch (DataFormatException e) {
        fail("Invalid input to be decompressed");
    } catch (NullPointerException expected) {
        checkInflaterClosed(expected);
    }
}
#method_after
public void test_inflate$BII() {
    // test method of java.util.zip.inflater.inflate(byte,int,int)
    byte[] byteArray = { 1, 3, 4, 7, 8, 'e', 'r', 't', 'y', '5' };
    byte[] outPutInf = new byte[100];
    int y = 0;
    Inflater inflate = new Inflater();
    try {
        while (!(inflate.finished())) {
            if (inflate.needsInput()) {
                assertEquals(0, inflate.inflate(outPutInf, 0, 1));
                inflate.setInput(outPutBuff1);
            }
            y += inflate.inflate(outPutInf, y, outPutInf.length - y);
        }
    } catch (DataFormatException e) {
        fail("Invalid input to be decompressed");
    }
    for (int i = 0; i < byteArray.length; i++) {
        assertEquals("Final decompressed data does not equal the original data", byteArray[i], outPutInf[i]);
    }
    assertEquals("final decompressed data contained more bytes than original - inflateB", 0, outPutInf[byteArray.length]);
    // test boundary checks
    inflate.reset();
    int r = 0;
    int offSet = 0;
    int lengthError = 101;
    try {
        if (inflate.needsInput()) {
            inflate.setInput(outPutBuff1);
        }
        inflate.inflate(outPutInf, offSet, lengthError);
    } catch (DataFormatException e) {
        fail("Invalid input to be decompressed");
    } catch (ArrayIndexOutOfBoundsException e) {
        r = 1;
    }
    assertEquals("out of bounds error did not get caught", 1, r);
    try {
        assertEquals(0, inflate.inflate(outPutInf, offSet, 0));
    } catch (DataFormatException e) {
        fail("Invalid input to be decompressed");
    }
    inflate.end();
    try {
        inflate.inflate(outPutInf, offSet, 1);
        fail("NullPointerException expected");
    } catch (DataFormatException e) {
        fail("Invalid input to be decompressed");
    } catch (NullPointerException expected) {
    // Expected
    }
}
#end_block

#method_before
public void testSetDictionary$B() throws Exception {
    int i = 0;
    String inputString = "blah string contains blahblahblahblah and blah";
    String dictionary1 = "blah";
    String dictionary2 = "1234";
    byte[] outputNo = new byte[100];
    byte[] output1 = new byte[100];
    byte[] output2 = new byte[100];
    Deflater defDictNo = new Deflater(9);
    Deflater defDict1 = new Deflater(9);
    Deflater defDict2 = new Deflater(9);
    defDict1.setDictionary(dictionary1.getBytes());
    defDict2.setDictionary(dictionary2.getBytes());
    defDictNo.setInput(inputString.getBytes());
    defDict1.setInput(inputString.getBytes());
    defDict2.setInput(inputString.getBytes());
    defDictNo.finish();
    defDict1.finish();
    defDict2.finish();
    int dataLenNo = defDictNo.deflate(outputNo);
    int dataLen1 = defDict1.deflate(output1);
    int dataLen2 = defDict2.deflate(output2);
    defDictNo.end();
    defDict1.end();
    defDict2.end();
    boolean passNo1 = false;
    boolean passNo2 = false;
    boolean pass12 = false;
    for (i = 0; i < (dataLenNo < dataLen1 ? dataLenNo : dataLen1); i++) {
        if (outputNo[i] != output1[i]) {
            passNo1 = true;
            break;
        }
    }
    for (i = 0; i < (dataLenNo < dataLen1 ? dataLenNo : dataLen2); i++) {
        if (outputNo[i] != output2[i]) {
            passNo2 = true;
            break;
        }
    }
    for (i = 0; i < (dataLen1 < dataLen2 ? dataLen1 : dataLen2); i++) {
        if (output1[i] != output2[i]) {
            pass12 = true;
            break;
        }
    }
    assertTrue("Compressed data the same for stream with dictionary and without it.", passNo1);
    assertTrue("Compressed data the same for stream with dictionary and without it.", passNo2);
    assertTrue("Compressed data the same for stream with different dictionaries.", pass12);
    Inflater inflNo = new Inflater();
    Inflater infl1 = new Inflater();
    Inflater infl2 = new Inflater();
    byte[] result = new byte[100];
    int decLen;
    inflNo.setInput(outputNo, 0, dataLenNo);
    decLen = inflNo.inflate(result);
    assertFalse(inflNo.needsDictionary());
    inflNo.end();
    assertEquals(inputString, new String(result, 0, decLen));
    infl1.setInput(output1, 0, dataLen1);
    decLen = infl1.inflate(result);
    assertTrue(infl1.needsDictionary());
    infl1.setDictionary(dictionary1.getBytes());
    decLen = infl1.inflate(result);
    infl1.end();
    assertEquals(inputString, new String(result, 0, decLen));
    infl2.setInput(output2, 0, dataLen2);
    decLen = infl2.inflate(result);
    assertTrue(infl2.needsDictionary());
    infl2.setDictionary(dictionary2.getBytes());
    decLen = infl2.inflate(result);
    infl2.end();
    assertEquals(inputString, new String(result, 0, decLen));
    inflNo = new Inflater();
    infl1 = new Inflater();
    inflNo.setInput(outputNo, 0, dataLenNo);
    try {
        infl1.setDictionary(dictionary1.getBytes());
        fail("IllegalArgumentException expected.");
    } catch (IllegalArgumentException ee) {
    // expected.
    }
    inflNo.end();
    infl1.setInput(output1, 0, dataLen1);
    decLen = infl1.inflate(result);
    assertTrue(infl1.needsDictionary());
    try {
        infl1.setDictionary(dictionary2.getBytes());
        fail("IllegalArgumentException expected.");
    } catch (IllegalArgumentException ee) {
    // expected.
    }
    infl1.end();
    try {
        infl1.setDictionary(dictionary2.getBytes());
        fail("NullPointerException expected");
    } catch (NullPointerException expected) {
        checkInflaterClosed(expected);
    }
}
#method_after
public void testSetDictionary$B() throws Exception {
    int i = 0;
    String inputString = "blah string contains blahblahblahblah and blah";
    String dictionary1 = "blah";
    String dictionary2 = "1234";
    byte[] outputNo = new byte[100];
    byte[] output1 = new byte[100];
    byte[] output2 = new byte[100];
    Deflater defDictNo = new Deflater(9);
    Deflater defDict1 = new Deflater(9);
    Deflater defDict2 = new Deflater(9);
    defDict1.setDictionary(dictionary1.getBytes());
    defDict2.setDictionary(dictionary2.getBytes());
    defDictNo.setInput(inputString.getBytes());
    defDict1.setInput(inputString.getBytes());
    defDict2.setInput(inputString.getBytes());
    defDictNo.finish();
    defDict1.finish();
    defDict2.finish();
    int dataLenNo = defDictNo.deflate(outputNo);
    int dataLen1 = defDict1.deflate(output1);
    int dataLen2 = defDict2.deflate(output2);
    defDictNo.end();
    defDict1.end();
    defDict2.end();
    boolean passNo1 = false;
    boolean passNo2 = false;
    boolean pass12 = false;
    for (i = 0; i < (dataLenNo < dataLen1 ? dataLenNo : dataLen1); i++) {
        if (outputNo[i] != output1[i]) {
            passNo1 = true;
            break;
        }
    }
    for (i = 0; i < (dataLenNo < dataLen1 ? dataLenNo : dataLen2); i++) {
        if (outputNo[i] != output2[i]) {
            passNo2 = true;
            break;
        }
    }
    for (i = 0; i < (dataLen1 < dataLen2 ? dataLen1 : dataLen2); i++) {
        if (output1[i] != output2[i]) {
            pass12 = true;
            break;
        }
    }
    assertTrue("Compressed data the same for stream with dictionary and without it.", passNo1);
    assertTrue("Compressed data the same for stream with dictionary and without it.", passNo2);
    assertTrue("Compressed data the same for stream with different dictionaries.", pass12);
    Inflater inflNo = new Inflater();
    Inflater infl1 = new Inflater();
    Inflater infl2 = new Inflater();
    byte[] result = new byte[100];
    int decLen;
    inflNo.setInput(outputNo, 0, dataLenNo);
    decLen = inflNo.inflate(result);
    assertFalse(inflNo.needsDictionary());
    inflNo.end();
    assertEquals(inputString, new String(result, 0, decLen));
    infl1.setInput(output1, 0, dataLen1);
    decLen = infl1.inflate(result);
    assertTrue(infl1.needsDictionary());
    infl1.setDictionary(dictionary1.getBytes());
    decLen = infl1.inflate(result);
    infl1.end();
    assertEquals(inputString, new String(result, 0, decLen));
    infl2.setInput(output2, 0, dataLen2);
    decLen = infl2.inflate(result);
    assertTrue(infl2.needsDictionary());
    infl2.setDictionary(dictionary2.getBytes());
    decLen = infl2.inflate(result);
    infl2.end();
    assertEquals(inputString, new String(result, 0, decLen));
    inflNo = new Inflater();
    infl1 = new Inflater();
    inflNo.setInput(outputNo, 0, dataLenNo);
    try {
        infl1.setDictionary(dictionary1.getBytes());
        fail("IllegalArgumentException expected.");
    } catch (IllegalArgumentException ee) {
    // expected.
    }
    inflNo.end();
    infl1.setInput(output1, 0, dataLen1);
    decLen = infl1.inflate(result);
    assertTrue(infl1.needsDictionary());
    try {
        infl1.setDictionary(dictionary2.getBytes());
        fail("IllegalArgumentException expected.");
    } catch (IllegalArgumentException ee) {
    // expected.
    }
    infl1.end();
    try {
        infl1.setDictionary(dictionary2.getBytes());
        fail("NullPointerException expected");
    } catch (NullPointerException expected) {
    // Expected
    }
}
#end_block

#method_before
public void testExceptions() throws Exception {
    byte[] byteArray = { 5, 2, 3, 7, 8 };
    int r = 0;
    Inflater inflate = new Inflater();
    inflate.setInput(byteArray);
    inflate.end();
    try {
        inflate.getAdler();
        fail("NullPointerException expected");
    } catch (NullPointerException expected) {
        checkInflaterClosed(expected);
    }
    try {
        inflate.getBytesRead();
        fail("NullPointerException expected");
    } catch (NullPointerException expected) {
        checkInflaterClosed(expected);
    }
    try {
        inflate.getBytesWritten();
        fail("NullPointerException expected");
    } catch (NullPointerException expected) {
        checkInflaterClosed(expected);
    }
    try {
        inflate.getTotalIn();
        fail("NullPointerException expected");
    } catch (NullPointerException expected) {
        checkInflaterClosed(expected);
    }
    try {
        inflate.getTotalOut();
        fail("NullPointerException expected");
    } catch (NullPointerException expected) {
        checkInflaterClosed(expected);
    }
}
#method_after
public void testExceptions() throws Exception {
    byte[] byteArray = { 5, 2, 3, 7, 8 };
    int r = 0;
    Inflater inflate = new Inflater();
    inflate.setInput(byteArray);
    inflate.end();
    try {
        inflate.getAdler();
        fail("NullPointerException expected");
    } catch (NullPointerException expected) {
    // Expected
    }
    try {
        inflate.getBytesRead();
        fail("NullPointerException expected");
    } catch (NullPointerException expected) {
    // Expected
    }
    try {
        inflate.getBytesWritten();
        fail("NullPointerException expected");
    } catch (NullPointerException expected) {
    // Expected
    }
    try {
        inflate.getTotalIn();
        fail("NullPointerException expected");
    } catch (NullPointerException expected) {
    // Expected
    }
    try {
        inflate.getTotalOut();
        fail("NullPointerException expected");
    } catch (NullPointerException expected) {
    // Expected
    }
}
#end_block

#method_before
public void testInflaterInputStreamWithExternalInflater_3ArgConstructor() throws Exception {
    InputStream base = new ByteArrayInputStream(new byte[] { 'h', 'i' });
    Inflater inf = new Inflater();
    InflaterInputStream iis = new InflaterInputStream(base, inf, 512);
    iis.close();
    try {
        inf.reset();
        fail();
    } catch (NullPointerException expected) {
        // Expected because the inflater should've been closed when the stream was.
        checkInflaterClosed(expected);
    }
}
#method_after
public void testInflaterInputStreamWithExternalInflater_3ArgConstructor() throws Exception {
    InputStream base = new ByteArrayInputStream(new byte[] { 'h', 'i' });
    Inflater inf = new Inflater();
    InflaterInputStream iis = new InflaterInputStream(base, inf, 512);
    iis.close();
    try {
        inf.reset();
        fail();
    } catch (NullPointerException expected) {
    // Expected because the inflater should've been closed when the stream was.
    }
}
#end_block

#method_before
public void testInflaterInputStreamWithExternalInflater_2ArgConstructor() throws Exception {
    InputStream base = new ByteArrayInputStream(new byte[] { 'h', 'i' });
    Inflater inf = new Inflater();
    InflaterInputStream iis = new InflaterInputStream(base, inf);
    iis.close();
    try {
        inf.reset();
        fail();
    } catch (NullPointerException expected) {
        // Expected because the inflater should've been closed when the stream was.
        checkInflaterClosed(expected);
    }
}
#method_after
public void testInflaterInputStreamWithExternalInflater_2ArgConstructor() throws Exception {
    InputStream base = new ByteArrayInputStream(new byte[] { 'h', 'i' });
    Inflater inf = new Inflater();
    InflaterInputStream iis = new InflaterInputStream(base, inf);
    iis.close();
    try {
        inf.reset();
        fail();
    } catch (NullPointerException expected) {
    // Expected because the inflater should've been closed when the stream was.
    }
}
#end_block

#method_before
// ART outputs class names such as:
// "java.lang.Class", "java.lang.Class[]", "byte", "byte[]"
// RI outputs class names such as:
// "java/lang/Class", '[Ljava/lang/Class;", N/A, "[B"
// 
// This function converts all class names to match the ART format, which is
private static String normalizeClassName(String name) throws HprofFormatException {
    int array = 0;
    while (name.startsWith("[")) {
        array++;
        name = name.substring(1);
    }
    if (array > 0) {
        // class name as a type signature.
        switch(name.charAt(0)) {
            case 'Z':
                name = "boolean";
                break;
            case 'B':
                name = "byte";
                break;
            case 'C':
                name = "char";
                break;
            case 'S':
                name = "short";
                break;
            case 'I':
                name = "int";
                break;
            case 'J':
                name = "long";
                break;
            case 'F':
                name = "float";
                break;
            case 'D':
                name = "double";
                break;
            case 'L':
                name = name.substring(1, name.length() - 1);
                break;
            default:
                throw new HprofFormatException("Invalid type signature in class name: " + name);
        }
    }
    name = name.replace('/', '.');
    for (int i = 0; i < array; ++i) {
        name += "[]";
    }
    return name;
}
#method_after
// ART outputs class names such as:
// "java.lang.Class", "java.lang.Class[]", "byte", "byte[]"
// RI outputs class names such as:
// "java/lang/Class", '[Ljava/lang/Class;", N/A, "[B"
// 
// This function converts all class names to match the ART format, which is
private static String normalizeClassName(String name) throws HprofFormatException {
    int numDimensions = 0;
    while (name.startsWith("[")) {
        numDimensions++;
        name = name.substring(1);
    }
    if (numDimensions > 0) {
        // class name as a type signature.
        switch(name.charAt(0)) {
            case 'Z':
                name = "boolean";
                break;
            case 'B':
                name = "byte";
                break;
            case 'C':
                name = "char";
                break;
            case 'S':
                name = "short";
                break;
            case 'I':
                name = "int";
                break;
            case 'J':
                name = "long";
                break;
            case 'F':
                name = "float";
                break;
            case 'D':
                name = "double";
                break;
            case 'L':
                name = name.substring(1, name.length() - 1);
                break;
            default:
                throw new HprofFormatException("Invalid type signature in class name: " + name);
        }
    }
    name = name.replace('/', '.');
    for (int i = 0; i < numDimensions; ++i) {
        name += "[]";
    }
    return name;
}
#end_block

#method_before
public InputStream getInputStream(ZipEntry entry) throws IOException {
    if (entry == null) {
        throw new NullPointerException("entry");
    }
    long jzentry = 0;
    ZipFileInputStream in = null;
    synchronized (this) {
        ensureOpen();
        if (!zc.isUTF8() && (entry.flag & EFS) != 0) {
            // Android-changed: addSlash set to true, android is fine with "/" at the end
            jzentry = getEntry(jzfile, zc.getBytesUTF8(entry.name), true);
        } else {
            // Android-changed: addSlash set to true, android is fine with "/" at the end
            jzentry = getEntry(jzfile, zc.getBytes(entry.name), true);
        }
        if (jzentry == 0) {
            return null;
        }
        in = new ZipFileInputStream(jzentry);
        switch(getEntryMethod(jzentry)) {
            case STORED:
                synchronized (streams) {
                    streams.put(in, null);
                }
                return in;
            case DEFLATED:
                // MORE: Compute good size for inflater stream:
                // Inflater likes a bit of slack
                long size = getEntrySize(jzentry) + 2;
                // if (size > 65536) size = 8192;
                if (size > 65536)
                    size = 65536;
                if (size <= 0)
                    size = 4096;
                Inflater inf = getInflater();
                InputStream is = new ZipFileInflaterInputStream(in, inf, (int) size);
                synchronized (streams) {
                    streams.put(is, inf);
                }
                return is;
            default:
                throw new ZipException("invalid compression method");
        }
    }
}
#method_after
public InputStream getInputStream(ZipEntry entry) throws IOException {
    if (entry == null) {
        throw new NullPointerException("entry");
    }
    long jzentry = 0;
    ZipFileInputStream in = null;
    synchronized (this) {
        ensureOpen();
        if (!zc.isUTF8() && (entry.flag & EFS) != 0) {
            // Android-changed: Find entry by name, falling back to name/ if cannot be found.
            // Needed for ClassPathURLStreamHandler handling of URLs without trailing slashes.
            // This was added as part of the work to move StrictJarFile from libcore to
            // framework, see http://b/111293098 for more details.
            // It should be possible to revert this after upgrading to OpenJDK 8u144 or above.
            // jzentry = getEntry(jzfile, zc.getBytesUTF8(entry.name), false);
            jzentry = getEntry(jzfile, zc.getBytesUTF8(entry.name), true);
        } else {
            // Android-changed: Find entry by name, falling back to name/ if cannot be found.
            // jzentry = getEntry(jzfile, zc.getBytes(entry.name), false);
            jzentry = getEntry(jzfile, zc.getBytes(entry.name), true);
        }
        if (jzentry == 0) {
            return null;
        }
        in = new ZipFileInputStream(jzentry);
        switch(getEntryMethod(jzentry)) {
            case STORED:
                synchronized (streams) {
                    streams.put(in, null);
                }
                return in;
            case DEFLATED:
                // MORE: Compute good size for inflater stream:
                // Inflater likes a bit of slack
                long size = getEntrySize(jzentry) + 2;
                // if (size > 65536) size = 8192;
                if (size > 65536)
                    size = 65536;
                if (size <= 0)
                    size = 4096;
                Inflater inf = getInflater();
                InputStream is = new ZipFileInflaterInputStream(in, inf, (int) size);
                synchronized (streams) {
                    streams.put(is, inf);
                }
                return is;
            default:
                throw new ZipException("invalid compression method");
        }
    }
}
#end_block

#method_before
protected void finalize() throws IOException {
    // until the monitor is released.
    if (guard != null) {
        guard.warnIfOpen();
    }
    // Synchronizes on "this".
    // END Android-added: CloseGuard support
    close();
}
#method_after
protected void finalize() throws IOException {
    // Android-added: CloseGuard support
    if (guard != null) {
        guard.warnIfOpen();
    }
    close();
}
#end_block

#method_before
public int read(byte[] b, int off, int len) throws IOException {
    // Android-added: Always throw an exception when reading from closed zipfile.
    // Required by the JavaDoc for InputStream.read(byte[], int, int). Upstream version
    // 8u121-b13 is not compliant but that bug has been fixed in upstream version 9+181
    // as part of a major change to switch to a pure Java implementation.
    // See JDK-8145260 and JDK-8142508.
    ensureOpenOrZipException();
    synchronized (ZipFile.this) {
        long rem = this.rem;
        long pos = this.pos;
        if (rem == 0) {
            return -1;
        }
        if (len <= 0) {
            return 0;
        }
        if (len > rem) {
            len = (int) rem;
        }
        // Android-removed: Always throw an exception when reading from closed zipfile.
        // Moved to the start of the method.
        // ensureOpenOrZipException();
        len = ZipFile.read(ZipFile.this.jzfile, jzentry, pos, b, off, len);
        if (len > 0) {
            this.pos = (pos + len);
            this.rem = (rem - len);
        }
    }
    if (rem == 0) {
        close();
    }
    return len;
}
#method_after
public int read(byte[] b, int off, int len) throws IOException {
    // Android-added: Always throw an exception when reading from closed zipfile.
    // Required by the JavaDoc for InputStream.read(byte[], int, int). Upstream version
    // 8u121-b13 is not compliant but that bug has been fixed in upstream version 9+181
    // as part of a major change to switch to a pure Java implementation.
    // See https://bugs.openjdk.java.net/browse/JDK-8145260 and
    // https://bugs.openjdk.java.net/browse/JDK-8142508.
    ensureOpenOrZipException();
    synchronized (ZipFile.this) {
        long rem = this.rem;
        long pos = this.pos;
        if (rem == 0) {
            return -1;
        }
        if (len <= 0) {
            return 0;
        }
        if (len > rem) {
            len = (int) rem;
        }
        // Android-removed: Always throw an exception when reading from closed zipfile.
        // Moved to the start of the method.
        // ensureOpenOrZipException();
        len = ZipFile.read(ZipFile.this.jzfile, jzentry, pos, b, off, len);
        if (len > 0) {
            this.pos = (pos + len);
            this.rem = (rem - len);
        }
    }
    if (rem == 0) {
        close();
    }
    return len;
}
#end_block

#method_before
// BEGIN Android-added: Provide access to underlying file descriptor for testing.
// See b/111148957 for background information.
/**
 * @hide
 */
public int getFileDescriptor() {
    return getFileDescriptor(jzfile);
}
#method_after
// BEGIN Android-added: Provide access to underlying file descriptor for testing.
// See http://b/111148957 for background information.
/**
 * @hide
 */
public int getFileDescriptor() {
    return getFileDescriptor(jzfile);
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    MainThreadRequest request;
    Message onCompleted;
    AsyncResult ar;
    UiccCard uiccCard;
    IccAPDUArgument iccArgument;
    switch(msg.what) {
        case CMD_HANDLE_USSD_REQUEST:
            {
                request = (MainThreadRequest) msg.obj;
                final Phone phone = getPhoneFromRequest(request);
                Pair<String, ResultReceiver> ussdObject = (Pair) request.argument;
                String ussdRequest = ussdObject.first;
                ResultReceiver wrappedCallback = ussdObject.second;
                if (!isUssdApiAllowed(request.subId)) {
                    // Carrier does not support use of this API, return failure.
                    Rlog.w(LOG_TAG, "handleUssdRequest: carrier does not support USSD apis.");
                    UssdResponse response = new UssdResponse(ussdRequest, null);
                    Bundle returnData = new Bundle();
                    returnData.putParcelable(TelephonyManager.USSD_RESPONSE, response);
                    wrappedCallback.send(TelephonyManager.USSD_RETURN_FAILURE, returnData);
                    request.result = true;
                    synchronized (request) {
                        request.notifyAll();
                    }
                    return;
                }
                try {
                    request.result = phone != null ? phone.handleUssdRequest(ussdRequest, wrappedCallback) : false;
                } catch (CallStateException cse) {
                    request.result = false;
                }
                // Wake up the requesting thread
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            }
        case CMD_HANDLE_PIN_MMI:
            {
                request = (MainThreadRequest) msg.obj;
                final Phone phone = getPhoneFromRequest(request);
                request.result = phone != null ? getPhoneFromRequest(request).handlePinMmi((String) request.argument) : false;
                // Wake up the requesting thread
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            }
        case CMD_HANDLE_NEIGHBORING_CELL:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NEIGHBORING_CELL_DONE, request);
            mPhone.getNeighboringCids(onCompleted, (WorkSource) request.argument);
            break;
        case EVENT_NEIGHBORING_CELL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                // create an empty list to notify the waiting thread
                request.result = new ArrayList<NeighboringCellInfo>(0);
            }
            // Wake up the requesting thread
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_ANSWER_RINGING_CALL:
            request = (MainThreadRequest) msg.obj;
            int answer_subId = request.subId;
            answerRingingCallInternal(answer_subId);
            break;
        case CMD_END_CALL:
            request = (MainThreadRequest) msg.obj;
            int end_subId = request.subId;
            final boolean hungUp;
            Phone phone = getPhone(end_subId);
            if (phone == null) {
                if (DBG)
                    log("CMD_END_CALL: no phone for id: " + end_subId);
                break;
            }
            int phoneType = phone.getPhoneType();
            if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                // CDMA: If the user presses the Power button we treat it as
                // ending the complete call session
                hungUp = PhoneUtils.hangupRingingAndActive(getPhone(end_subId));
            } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                // GSM: End the call as per the Phone state
                hungUp = PhoneUtils.hangup(mCM);
            } else {
                throw new IllegalStateException("Unexpected phone type: " + phoneType);
            }
            if (DBG)
                log("CMD_END_CALL: " + (hungUp ? "hung up!" : "no call to hang up"));
            request.result = hungUp;
            // Wake up the requesting thread
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_TRANSMIT_APDU_LOGICAL_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            iccArgument = (IccAPDUArgument) request.argument;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccTransmitApduLogicalChannel: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_TRANSMIT_APDU_LOGICAL_CHANNEL_DONE, request);
                uiccCard.iccTransmitApduLogicalChannel(iccArgument.channel, iccArgument.cla, iccArgument.command, iccArgument.p1, iccArgument.p2, iccArgument.p3, iccArgument.data, onCompleted);
            }
            break;
        case EVENT_TRANSMIT_APDU_LOGICAL_CHANNEL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                if (ar.result == null) {
                    loge("iccTransmitApduLogicalChannel: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("iccTransmitApduLogicalChannel: CommandException: " + ar.exception);
                } else {
                    loge("iccTransmitApduLogicalChannel: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_TRANSMIT_APDU_BASIC_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            iccArgument = (IccAPDUArgument) request.argument;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccTransmitApduBasicChannel: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE, request);
                uiccCard.iccTransmitApduBasicChannel(iccArgument.cla, iccArgument.command, iccArgument.p1, iccArgument.p2, iccArgument.p3, iccArgument.data, onCompleted);
            }
            break;
        case EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                if (ar.result == null) {
                    loge("iccTransmitApduBasicChannel: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("iccTransmitApduBasicChannel: CommandException: " + ar.exception);
                } else {
                    loge("iccTransmitApduBasicChannel: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_EXCHANGE_SIM_IO:
            request = (MainThreadRequest) msg.obj;
            iccArgument = (IccAPDUArgument) request.argument;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccExchangeSimIO: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_EXCHANGE_SIM_IO_DONE, request);
                uiccCard.iccExchangeSimIO(iccArgument.cla, /* fileID */
                iccArgument.command, iccArgument.p1, iccArgument.p2, iccArgument.p3, iccArgument.data, onCompleted);
            }
            break;
        case EVENT_EXCHANGE_SIM_IO_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6f, 0, (byte[]) null);
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SEND_ENVELOPE:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("sendEnvelopeWithStatus: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_SEND_ENVELOPE_DONE, request);
                uiccCard.sendEnvelopeWithStatus((String) request.argument, onCompleted);
            }
            break;
        case EVENT_SEND_ENVELOPE_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                if (ar.result == null) {
                    loge("sendEnvelopeWithStatus: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("sendEnvelopeWithStatus: CommandException: " + ar.exception);
                } else {
                    loge("sendEnvelopeWithStatus: exception:" + ar.exception);
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_OPEN_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            Pair<String, Integer> openChannelArgs = (Pair<String, Integer>) request.argument;
            if (uiccCard == null) {
                loge("iccOpenLogicalChannel: No UICC");
                request.result = new IccOpenLogicalChannelResponse(-1, IccOpenLogicalChannelResponse.STATUS_MISSING_RESOURCE, null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_OPEN_CHANNEL_DONE, request);
                uiccCard.iccOpenLogicalChannel(openChannelArgs.first, openChannelArgs.second, onCompleted);
            }
            break;
        case EVENT_OPEN_CHANNEL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            IccOpenLogicalChannelResponse openChannelResp;
            if (ar.exception == null && ar.result != null) {
                int[] result = (int[]) ar.result;
                int channelId = result[0];
                byte[] selectResponse = null;
                if (result.length > 1) {
                    selectResponse = new byte[result.length - 1];
                    for (int i = 1; i < result.length; ++i) {
                        selectResponse[i - 1] = (byte) result[i];
                    }
                }
                openChannelResp = new IccOpenLogicalChannelResponse(channelId, IccOpenLogicalChannelResponse.STATUS_NO_ERROR, selectResponse);
            } else {
                if (ar.result == null) {
                    loge("iccOpenLogicalChannel: Empty response");
                }
                if (ar.exception != null) {
                    loge("iccOpenLogicalChannel: Exception: " + ar.exception);
                }
                int errorCode = IccOpenLogicalChannelResponse.STATUS_UNKNOWN_ERROR;
                if (ar.exception instanceof CommandException) {
                    CommandException.Error error = ((CommandException) (ar.exception)).getCommandError();
                    if (error == CommandException.Error.MISSING_RESOURCE) {
                        errorCode = IccOpenLogicalChannelResponse.STATUS_MISSING_RESOURCE;
                    } else if (error == CommandException.Error.NO_SUCH_ELEMENT) {
                        errorCode = IccOpenLogicalChannelResponse.STATUS_NO_SUCH_ELEMENT;
                    }
                }
                openChannelResp = new IccOpenLogicalChannelResponse(IccOpenLogicalChannelResponse.INVALID_CHANNEL, errorCode, null);
            }
            request.result = openChannelResp;
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_CLOSE_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccCloseLogicalChannel: No UICC");
                request.result = false;
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_CLOSE_CHANNEL_DONE, request);
                uiccCard.iccCloseLogicalChannel((Integer) request.argument, onCompleted);
            }
            break;
        case EVENT_CLOSE_CHANNEL_DONE:
            handleNullReturnEvent(msg, "iccCloseLogicalChannel");
            break;
        case CMD_NV_READ_ITEM:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_READ_ITEM_DONE, request);
            mPhone.nvReadItem((Integer) request.argument, onCompleted);
            break;
        case EVENT_NV_READ_ITEM_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                // String
                request.result = ar.result;
            } else {
                request.result = "";
                if (ar.result == null) {
                    loge("nvReadItem: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("nvReadItem: CommandException: " + ar.exception);
                } else {
                    loge("nvReadItem: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_NV_WRITE_ITEM:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_WRITE_ITEM_DONE, request);
            Pair<Integer, String> idValue = (Pair<Integer, String>) request.argument;
            mPhone.nvWriteItem(idValue.first, idValue.second, onCompleted);
            break;
        case EVENT_NV_WRITE_ITEM_DONE:
            handleNullReturnEvent(msg, "nvWriteItem");
            break;
        case CMD_NV_WRITE_CDMA_PRL:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_WRITE_CDMA_PRL_DONE, request);
            mPhone.nvWriteCdmaPrl((byte[]) request.argument, onCompleted);
            break;
        case EVENT_NV_WRITE_CDMA_PRL_DONE:
            handleNullReturnEvent(msg, "nvWriteCdmaPrl");
            break;
        case CMD_NV_RESET_CONFIG:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_RESET_CONFIG_DONE, request);
            mPhone.nvResetConfig((Integer) request.argument, onCompleted);
            break;
        case EVENT_NV_RESET_CONFIG_DONE:
            handleNullReturnEvent(msg, "nvResetConfig");
            break;
        case CMD_GET_PREFERRED_NETWORK_TYPE:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_GET_PREFERRED_NETWORK_TYPE_DONE, request);
            getPhoneFromRequest(request).getPreferredNetworkType(onCompleted);
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                // Integer
                request.result = ar.result;
            } else {
                request.result = null;
                if (ar.result == null) {
                    loge("getPreferredNetworkType: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("getPreferredNetworkType: CommandException: " + ar.exception);
                } else {
                    loge("getPreferredNetworkType: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_PREFERRED_NETWORK_TYPE:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE_DONE, request);
            int networkType = (Integer) request.argument;
            getPhoneFromRequest(request).setPreferredNetworkType(networkType, onCompleted);
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE_DONE:
            handleNullReturnEvent(msg, "setPreferredNetworkType");
            break;
        case CMD_SET_VOICEMAIL_NUMBER:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_VOICEMAIL_NUMBER_DONE, request);
            Pair<String, String> tagNum = (Pair<String, String>) request.argument;
            getPhoneFromRequest(request).setVoiceMailNumber(tagNum.first, tagNum.second, onCompleted);
            break;
        case EVENT_SET_VOICEMAIL_NUMBER_DONE:
            handleNullReturnEvent(msg, "setVoicemailNumber");
            break;
        case CMD_SET_NETWORK_SELECTION_MODE_AUTOMATIC:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_NETWORK_SELECTION_MODE_AUTOMATIC_DONE, request);
            getPhoneFromRequest(request).setNetworkSelectionModeAutomatic(onCompleted);
            break;
        case EVENT_SET_NETWORK_SELECTION_MODE_AUTOMATIC_DONE:
            handleNullReturnEvent(msg, "setNetworkSelectionModeAutomatic");
            break;
        case CMD_PERFORM_NETWORK_SCAN:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_PERFORM_NETWORK_SCAN_DONE, request);
            getPhoneFromRequest(request).getAvailableNetworks(onCompleted);
            break;
        case EVENT_PERFORM_NETWORK_SCAN_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            CellNetworkScanResult cellScanResult;
            if (ar.exception == null && ar.result != null) {
                cellScanResult = new CellNetworkScanResult(CellNetworkScanResult.STATUS_SUCCESS, (List<OperatorInfo>) ar.result);
            } else {
                if (ar.result == null) {
                    loge("getCellNetworkScanResults: Empty response");
                }
                if (ar.exception != null) {
                    loge("getCellNetworkScanResults: Exception: " + ar.exception);
                }
                int errorCode = CellNetworkScanResult.STATUS_UNKNOWN_ERROR;
                if (ar.exception instanceof CommandException) {
                    CommandException.Error error = ((CommandException) (ar.exception)).getCommandError();
                    if (error == CommandException.Error.RADIO_NOT_AVAILABLE) {
                        errorCode = CellNetworkScanResult.STATUS_RADIO_NOT_AVAILABLE;
                    } else if (error == CommandException.Error.GENERIC_FAILURE) {
                        errorCode = CellNetworkScanResult.STATUS_RADIO_GENERIC_FAILURE;
                    }
                }
                cellScanResult = new CellNetworkScanResult(errorCode, null);
            }
            request.result = cellScanResult;
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_NETWORK_SELECTION_MODE_MANUAL:
            request = (MainThreadRequest) msg.obj;
            ManualNetworkSelectionArgument selArg = (ManualNetworkSelectionArgument) request.argument;
            onCompleted = obtainMessage(EVENT_SET_NETWORK_SELECTION_MODE_MANUAL_DONE, request);
            getPhoneFromRequest(request).selectNetworkManually(selArg.operatorInfo, selArg.persistSelection, onCompleted);
            break;
        case EVENT_SET_NETWORK_SELECTION_MODE_MANUAL_DONE:
            handleNullReturnEvent(msg, "setNetworkSelectionModeManual");
            break;
        case CMD_GET_MODEM_ACTIVITY_INFO:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_GET_MODEM_ACTIVITY_INFO_DONE, request);
            mPhone.getModemActivityInfo(onCompleted);
            break;
        case EVENT_GET_MODEM_ACTIVITY_INFO_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("queryModemActivityInfo: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("queryModemActivityInfo: CommandException: " + ar.exception);
                } else {
                    loge("queryModemActivityInfo: Unknown exception");
                }
            }
            // Result cannot be null. Return ModemActivityInfo with all fields set to 0.
            if (request.result == null) {
                request.result = new ModemActivityInfo(0, 0, 0, null, 0, 0);
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_ALLOWED_CARRIERS:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_ALLOWED_CARRIERS_DONE, request);
            mPhone.setAllowedCarriers((List<CarrierIdentifier>) request.argument, onCompleted);
            break;
        case EVENT_SET_ALLOWED_CARRIERS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("setAllowedCarriers: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("setAllowedCarriers: CommandException: " + ar.exception);
                } else {
                    loge("setAllowedCarriers: Unknown exception");
                }
            }
            // Result cannot be null. Return -1 on error.
            if (request.result == null) {
                request.result = new int[] { -1 };
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_GET_ALLOWED_CARRIERS:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_GET_ALLOWED_CARRIERS_DONE, request);
            mPhone.getAllowedCarriers(onCompleted);
            break;
        case EVENT_GET_ALLOWED_CARRIERS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("getAllowedCarriers: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("getAllowedCarriers: CommandException: " + ar.exception);
                } else {
                    loge("getAllowedCarriers: Unknown exception");
                }
            }
            // Result cannot be null. Return empty list of CarrierIdentifier.
            if (request.result == null) {
                request.result = new ArrayList<CarrierIdentifier>(0);
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case EVENT_GET_FORBIDDEN_PLMNS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IllegalArgumentException("Failed to retrieve Forbidden Plmns");
                if (ar.result == null) {
                    loge("getForbiddenPlmns: Empty response");
                } else {
                    loge("getForbiddenPlmns: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_GET_FORBIDDEN_PLMNS:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("getForbiddenPlmns() UiccCard is null");
                request.result = new IllegalArgumentException("getForbiddenPlmns() UiccCard is null");
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            }
            Integer appType = (Integer) request.argument;
            UiccCardApplication uiccApp = uiccCard.getApplicationByType(appType);
            if (uiccApp == null) {
                loge("getForbiddenPlmns() no app with specified type -- " + appType);
                request.result = new IllegalArgumentException("Failed to get UICC App");
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            } else {
                if (DBG)
                    logv("getForbiddenPlmns() found app " + uiccApp.getAid() + " specified type -- " + appType);
            }
            onCompleted = obtainMessage(EVENT_GET_FORBIDDEN_PLMNS_DONE, request);
            ((SIMRecords) uiccApp.getIccRecords()).getForbiddenPlmns(onCompleted);
            break;
        case CMD_SWITCH_SLOTS:
            request = (MainThreadRequest) msg.obj;
            int[] physicalSlots = (int[]) request.argument;
            onCompleted = obtainMessage(EVENT_SWITCH_SLOTS_DONE, request);
            UiccController.getInstance().switchSlots(physicalSlots, onCompleted);
            break;
        case EVENT_SWITCH_SLOTS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            request.result = (ar.exception == null);
            synchronized (request) {
                request.notifyAll();
            }
            break;
        default:
            Log.w(LOG_TAG, "MainThreadHandler: unexpected message code: " + msg.what);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    MainThreadRequest request;
    Message onCompleted;
    AsyncResult ar;
    UiccCard uiccCard;
    IccAPDUArgument iccArgument;
    switch(msg.what) {
        case CMD_HANDLE_USSD_REQUEST:
            {
                request = (MainThreadRequest) msg.obj;
                final Phone phone = getPhoneFromRequest(request);
                Pair<String, ResultReceiver> ussdObject = (Pair) request.argument;
                String ussdRequest = ussdObject.first;
                ResultReceiver wrappedCallback = ussdObject.second;
                if (!isUssdApiAllowed(request.subId)) {
                    // Carrier does not support use of this API, return failure.
                    Rlog.w(LOG_TAG, "handleUssdRequest: carrier does not support USSD apis.");
                    UssdResponse response = new UssdResponse(ussdRequest, null);
                    Bundle returnData = new Bundle();
                    returnData.putParcelable(TelephonyManager.USSD_RESPONSE, response);
                    wrappedCallback.send(TelephonyManager.USSD_RETURN_FAILURE, returnData);
                    request.result = true;
                    synchronized (request) {
                        request.notifyAll();
                    }
                    return;
                }
                try {
                    request.result = phone != null ? phone.handleUssdRequest(ussdRequest, wrappedCallback) : false;
                } catch (CallStateException cse) {
                    request.result = false;
                }
                // Wake up the requesting thread
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            }
        case CMD_HANDLE_PIN_MMI:
            {
                request = (MainThreadRequest) msg.obj;
                final Phone phone = getPhoneFromRequest(request);
                request.result = phone != null ? getPhoneFromRequest(request).handlePinMmi((String) request.argument) : false;
                // Wake up the requesting thread
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            }
        case CMD_HANDLE_NEIGHBORING_CELL:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NEIGHBORING_CELL_DONE, request);
            mPhone.getNeighboringCids(onCompleted, (WorkSource) request.argument);
            break;
        case EVENT_NEIGHBORING_CELL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                // create an empty list to notify the waiting thread
                request.result = new ArrayList<NeighboringCellInfo>(0);
            }
            // Wake up the requesting thread
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_ANSWER_RINGING_CALL:
            request = (MainThreadRequest) msg.obj;
            int answer_subId = request.subId;
            answerRingingCallInternal(answer_subId);
            // dummy result for notifying the waiting thread
            request.result = "";
            // Wake up the requesting thread
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_END_CALL:
            request = (MainThreadRequest) msg.obj;
            int end_subId = request.subId;
            final boolean hungUp;
            Phone phone = getPhone(end_subId);
            if (phone == null) {
                if (DBG)
                    log("CMD_END_CALL: no phone for id: " + end_subId);
                break;
            }
            int phoneType = phone.getPhoneType();
            if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                // CDMA: If the user presses the Power button we treat it as
                // ending the complete call session
                hungUp = PhoneUtils.hangupRingingAndActive(getPhone(end_subId));
            } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                // GSM: End the call as per the Phone state
                hungUp = PhoneUtils.hangup(mCM);
            } else {
                throw new IllegalStateException("Unexpected phone type: " + phoneType);
            }
            if (DBG)
                log("CMD_END_CALL: " + (hungUp ? "hung up!" : "no call to hang up"));
            request.result = hungUp;
            // Wake up the requesting thread
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_TRANSMIT_APDU_LOGICAL_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            iccArgument = (IccAPDUArgument) request.argument;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccTransmitApduLogicalChannel: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_TRANSMIT_APDU_LOGICAL_CHANNEL_DONE, request);
                uiccCard.iccTransmitApduLogicalChannel(iccArgument.channel, iccArgument.cla, iccArgument.command, iccArgument.p1, iccArgument.p2, iccArgument.p3, iccArgument.data, onCompleted);
            }
            break;
        case EVENT_TRANSMIT_APDU_LOGICAL_CHANNEL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                if (ar.result == null) {
                    loge("iccTransmitApduLogicalChannel: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("iccTransmitApduLogicalChannel: CommandException: " + ar.exception);
                } else {
                    loge("iccTransmitApduLogicalChannel: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_TRANSMIT_APDU_BASIC_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            iccArgument = (IccAPDUArgument) request.argument;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccTransmitApduBasicChannel: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE, request);
                uiccCard.iccTransmitApduBasicChannel(iccArgument.cla, iccArgument.command, iccArgument.p1, iccArgument.p2, iccArgument.p3, iccArgument.data, onCompleted);
            }
            break;
        case EVENT_TRANSMIT_APDU_BASIC_CHANNEL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                if (ar.result == null) {
                    loge("iccTransmitApduBasicChannel: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("iccTransmitApduBasicChannel: CommandException: " + ar.exception);
                } else {
                    loge("iccTransmitApduBasicChannel: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_EXCHANGE_SIM_IO:
            request = (MainThreadRequest) msg.obj;
            iccArgument = (IccAPDUArgument) request.argument;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccExchangeSimIO: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_EXCHANGE_SIM_IO_DONE, request);
                uiccCard.iccExchangeSimIO(iccArgument.cla, /* fileID */
                iccArgument.command, iccArgument.p1, iccArgument.p2, iccArgument.p3, iccArgument.data, onCompleted);
            }
            break;
        case EVENT_EXCHANGE_SIM_IO_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6f, 0, (byte[]) null);
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SEND_ENVELOPE:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("sendEnvelopeWithStatus: No UICC");
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_SEND_ENVELOPE_DONE, request);
                uiccCard.sendEnvelopeWithStatus((String) request.argument, onCompleted);
            }
            break;
        case EVENT_SEND_ENVELOPE_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IccIoResult(0x6F, 0, (byte[]) null);
                if (ar.result == null) {
                    loge("sendEnvelopeWithStatus: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("sendEnvelopeWithStatus: CommandException: " + ar.exception);
                } else {
                    loge("sendEnvelopeWithStatus: exception:" + ar.exception);
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_OPEN_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            Pair<String, Integer> openChannelArgs = (Pair<String, Integer>) request.argument;
            if (uiccCard == null) {
                loge("iccOpenLogicalChannel: No UICC");
                request.result = new IccOpenLogicalChannelResponse(-1, IccOpenLogicalChannelResponse.STATUS_MISSING_RESOURCE, null);
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_OPEN_CHANNEL_DONE, request);
                uiccCard.iccOpenLogicalChannel(openChannelArgs.first, openChannelArgs.second, onCompleted);
            }
            break;
        case EVENT_OPEN_CHANNEL_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            IccOpenLogicalChannelResponse openChannelResp;
            if (ar.exception == null && ar.result != null) {
                int[] result = (int[]) ar.result;
                int channelId = result[0];
                byte[] selectResponse = null;
                if (result.length > 1) {
                    selectResponse = new byte[result.length - 1];
                    for (int i = 1; i < result.length; ++i) {
                        selectResponse[i - 1] = (byte) result[i];
                    }
                }
                openChannelResp = new IccOpenLogicalChannelResponse(channelId, IccOpenLogicalChannelResponse.STATUS_NO_ERROR, selectResponse);
            } else {
                if (ar.result == null) {
                    loge("iccOpenLogicalChannel: Empty response");
                }
                if (ar.exception != null) {
                    loge("iccOpenLogicalChannel: Exception: " + ar.exception);
                }
                int errorCode = IccOpenLogicalChannelResponse.STATUS_UNKNOWN_ERROR;
                if (ar.exception instanceof CommandException) {
                    CommandException.Error error = ((CommandException) (ar.exception)).getCommandError();
                    if (error == CommandException.Error.MISSING_RESOURCE) {
                        errorCode = IccOpenLogicalChannelResponse.STATUS_MISSING_RESOURCE;
                    } else if (error == CommandException.Error.NO_SUCH_ELEMENT) {
                        errorCode = IccOpenLogicalChannelResponse.STATUS_NO_SUCH_ELEMENT;
                    }
                }
                openChannelResp = new IccOpenLogicalChannelResponse(IccOpenLogicalChannelResponse.INVALID_CHANNEL, errorCode, null);
            }
            request.result = openChannelResp;
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_CLOSE_CHANNEL:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("iccCloseLogicalChannel: No UICC");
                request.result = false;
                synchronized (request) {
                    request.notifyAll();
                }
            } else {
                onCompleted = obtainMessage(EVENT_CLOSE_CHANNEL_DONE, request);
                uiccCard.iccCloseLogicalChannel((Integer) request.argument, onCompleted);
            }
            break;
        case EVENT_CLOSE_CHANNEL_DONE:
            handleNullReturnEvent(msg, "iccCloseLogicalChannel");
            break;
        case CMD_NV_READ_ITEM:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_READ_ITEM_DONE, request);
            mPhone.nvReadItem((Integer) request.argument, onCompleted);
            break;
        case EVENT_NV_READ_ITEM_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                // String
                request.result = ar.result;
            } else {
                request.result = "";
                if (ar.result == null) {
                    loge("nvReadItem: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("nvReadItem: CommandException: " + ar.exception);
                } else {
                    loge("nvReadItem: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_NV_WRITE_ITEM:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_WRITE_ITEM_DONE, request);
            Pair<Integer, String> idValue = (Pair<Integer, String>) request.argument;
            mPhone.nvWriteItem(idValue.first, idValue.second, onCompleted);
            break;
        case EVENT_NV_WRITE_ITEM_DONE:
            handleNullReturnEvent(msg, "nvWriteItem");
            break;
        case CMD_NV_WRITE_CDMA_PRL:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_WRITE_CDMA_PRL_DONE, request);
            mPhone.nvWriteCdmaPrl((byte[]) request.argument, onCompleted);
            break;
        case EVENT_NV_WRITE_CDMA_PRL_DONE:
            handleNullReturnEvent(msg, "nvWriteCdmaPrl");
            break;
        case CMD_NV_RESET_CONFIG:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_NV_RESET_CONFIG_DONE, request);
            mPhone.nvResetConfig((Integer) request.argument, onCompleted);
            break;
        case EVENT_NV_RESET_CONFIG_DONE:
            handleNullReturnEvent(msg, "nvResetConfig");
            break;
        case CMD_GET_PREFERRED_NETWORK_TYPE:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_GET_PREFERRED_NETWORK_TYPE_DONE, request);
            getPhoneFromRequest(request).getPreferredNetworkType(onCompleted);
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                // Integer
                request.result = ar.result;
            } else {
                request.result = null;
                if (ar.result == null) {
                    loge("getPreferredNetworkType: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("getPreferredNetworkType: CommandException: " + ar.exception);
                } else {
                    loge("getPreferredNetworkType: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_PREFERRED_NETWORK_TYPE:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE_DONE, request);
            int networkType = (Integer) request.argument;
            getPhoneFromRequest(request).setPreferredNetworkType(networkType, onCompleted);
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE_DONE:
            handleNullReturnEvent(msg, "setPreferredNetworkType");
            break;
        case CMD_INVOKE_OEM_RIL_REQUEST_RAW:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_INVOKE_OEM_RIL_REQUEST_RAW_DONE, request);
            mPhone.invokeOemRilRequestRaw((byte[]) request.argument, onCompleted);
            break;
        case EVENT_INVOKE_OEM_RIL_REQUEST_RAW_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            request.result = ar;
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_VOICEMAIL_NUMBER:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_VOICEMAIL_NUMBER_DONE, request);
            Pair<String, String> tagNum = (Pair<String, String>) request.argument;
            getPhoneFromRequest(request).setVoiceMailNumber(tagNum.first, tagNum.second, onCompleted);
            break;
        case EVENT_SET_VOICEMAIL_NUMBER_DONE:
            handleNullReturnEvent(msg, "setVoicemailNumber");
            break;
        case CMD_SET_NETWORK_SELECTION_MODE_AUTOMATIC:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_NETWORK_SELECTION_MODE_AUTOMATIC_DONE, request);
            getPhoneFromRequest(request).setNetworkSelectionModeAutomatic(onCompleted);
            break;
        case EVENT_SET_NETWORK_SELECTION_MODE_AUTOMATIC_DONE:
            handleNullReturnEvent(msg, "setNetworkSelectionModeAutomatic");
            break;
        case CMD_PERFORM_NETWORK_SCAN:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_PERFORM_NETWORK_SCAN_DONE, request);
            getPhoneFromRequest(request).getAvailableNetworks(onCompleted);
            break;
        case EVENT_PERFORM_NETWORK_SCAN_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            CellNetworkScanResult cellScanResult;
            if (ar.exception == null && ar.result != null) {
                cellScanResult = new CellNetworkScanResult(CellNetworkScanResult.STATUS_SUCCESS, (List<OperatorInfo>) ar.result);
            } else {
                if (ar.result == null) {
                    loge("getCellNetworkScanResults: Empty response");
                }
                if (ar.exception != null) {
                    loge("getCellNetworkScanResults: Exception: " + ar.exception);
                }
                int errorCode = CellNetworkScanResult.STATUS_UNKNOWN_ERROR;
                if (ar.exception instanceof CommandException) {
                    CommandException.Error error = ((CommandException) (ar.exception)).getCommandError();
                    if (error == CommandException.Error.RADIO_NOT_AVAILABLE) {
                        errorCode = CellNetworkScanResult.STATUS_RADIO_NOT_AVAILABLE;
                    } else if (error == CommandException.Error.GENERIC_FAILURE) {
                        errorCode = CellNetworkScanResult.STATUS_RADIO_GENERIC_FAILURE;
                    }
                }
                cellScanResult = new CellNetworkScanResult(errorCode, null);
            }
            request.result = cellScanResult;
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_NETWORK_SELECTION_MODE_MANUAL:
            request = (MainThreadRequest) msg.obj;
            ManualNetworkSelectionArgument selArg = (ManualNetworkSelectionArgument) request.argument;
            onCompleted = obtainMessage(EVENT_SET_NETWORK_SELECTION_MODE_MANUAL_DONE, request);
            getPhoneFromRequest(request).selectNetworkManually(selArg.operatorInfo, selArg.persistSelection, onCompleted);
            break;
        case EVENT_SET_NETWORK_SELECTION_MODE_MANUAL_DONE:
            handleNullReturnEvent(msg, "setNetworkSelectionModeManual");
            break;
        case CMD_GET_MODEM_ACTIVITY_INFO:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_GET_MODEM_ACTIVITY_INFO_DONE, request);
            mPhone.getModemActivityInfo(onCompleted);
            break;
        case EVENT_GET_MODEM_ACTIVITY_INFO_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("queryModemActivityInfo: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("queryModemActivityInfo: CommandException: " + ar.exception);
                } else {
                    loge("queryModemActivityInfo: Unknown exception");
                }
            }
            // Result cannot be null. Return ModemActivityInfo with all fields set to 0.
            if (request.result == null) {
                request.result = new ModemActivityInfo(0, 0, 0, null, 0, 0);
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_SET_ALLOWED_CARRIERS:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_SET_ALLOWED_CARRIERS_DONE, request);
            mPhone.setAllowedCarriers((List<CarrierIdentifier>) request.argument, onCompleted);
            break;
        case EVENT_SET_ALLOWED_CARRIERS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("setAllowedCarriers: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("setAllowedCarriers: CommandException: " + ar.exception);
                } else {
                    loge("setAllowedCarriers: Unknown exception");
                }
            }
            // Result cannot be null. Return -1 on error.
            if (request.result == null) {
                request.result = new int[] { -1 };
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_GET_ALLOWED_CARRIERS:
            request = (MainThreadRequest) msg.obj;
            onCompleted = obtainMessage(EVENT_GET_ALLOWED_CARRIERS_DONE, request);
            mPhone.getAllowedCarriers(onCompleted);
            break;
        case EVENT_GET_ALLOWED_CARRIERS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                if (ar.result == null) {
                    loge("getAllowedCarriers: Empty response");
                } else if (ar.exception instanceof CommandException) {
                    loge("getAllowedCarriers: CommandException: " + ar.exception);
                } else {
                    loge("getAllowedCarriers: Unknown exception");
                }
            }
            // Result cannot be null. Return empty list of CarrierIdentifier.
            if (request.result == null) {
                request.result = new ArrayList<CarrierIdentifier>(0);
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case EVENT_GET_FORBIDDEN_PLMNS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            if (ar.exception == null && ar.result != null) {
                request.result = ar.result;
            } else {
                request.result = new IllegalArgumentException("Failed to retrieve Forbidden Plmns");
                if (ar.result == null) {
                    loge("getForbiddenPlmns: Empty response");
                } else {
                    loge("getForbiddenPlmns: Unknown exception");
                }
            }
            synchronized (request) {
                request.notifyAll();
            }
            break;
        case CMD_GET_FORBIDDEN_PLMNS:
            request = (MainThreadRequest) msg.obj;
            uiccCard = getUiccCardFromRequest(request);
            if (uiccCard == null) {
                loge("getForbiddenPlmns() UiccCard is null");
                request.result = new IllegalArgumentException("getForbiddenPlmns() UiccCard is null");
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            }
            Integer appType = (Integer) request.argument;
            UiccCardApplication uiccApp = uiccCard.getApplicationByType(appType);
            if (uiccApp == null) {
                loge("getForbiddenPlmns() no app with specified type -- " + appType);
                request.result = new IllegalArgumentException("Failed to get UICC App");
                synchronized (request) {
                    request.notifyAll();
                }
                break;
            } else {
                if (DBG)
                    logv("getForbiddenPlmns() found app " + uiccApp.getAid() + " specified type -- " + appType);
            }
            onCompleted = obtainMessage(EVENT_GET_FORBIDDEN_PLMNS_DONE, request);
            ((SIMRecords) uiccApp.getIccRecords()).getForbiddenPlmns(onCompleted);
            break;
        case CMD_SWITCH_SLOTS:
            request = (MainThreadRequest) msg.obj;
            int[] physicalSlots = (int[]) request.argument;
            onCompleted = obtainMessage(EVENT_SWITCH_SLOTS_DONE, request);
            UiccController.getInstance().switchSlots(physicalSlots, onCompleted);
            break;
        case EVENT_SWITCH_SLOTS_DONE:
            ar = (AsyncResult) msg.obj;
            request = (MainThreadRequest) ar.userObj;
            request.result = (ar.exception == null);
            synchronized (request) {
                request.notifyAll();
            }
            break;
        default:
            Log.w(LOG_TAG, "MainThreadHandler: unexpected message code: " + msg.what);
            break;
    }
}
#end_block

#method_before
@Override
public boolean isOffhookForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "isOffhookForSubscriber")) {
        return false;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return (phone.getState() == PhoneConstants.State.OFFHOOK);
    } else {
        return false;
    }
}
#method_after
@Override
public boolean isOffhookForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "isOffhookForSubscriber")) {
        return false;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return (phone.getState() == PhoneConstants.State.OFFHOOK);
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
public boolean isRingingForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "isRingingForSubscriber")) {
        return false;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return (phone.getState() == PhoneConstants.State.RINGING);
    } else {
        return false;
    }
}
#method_after
@Override
public boolean isRingingForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "isRingingForSubscriber")) {
        return false;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return (phone.getState() == PhoneConstants.State.RINGING);
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
public boolean isIdleForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "isIdleForSubscriber")) {
        return false;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return (phone.getState() == PhoneConstants.State.IDLE);
    } else {
        return false;
    }
}
#method_after
@Override
public boolean isIdleForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "isIdleForSubscriber")) {
        return false;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return (phone.getState() == PhoneConstants.State.IDLE);
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
public boolean isRadioOnForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "isRadioOnForSubscriber")) {
        return false;
    }
    return isRadioOnForSubscriber(subId);
}
#method_after
@Override
public boolean isRadioOnForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "isRadioOnForSubscriber")) {
        return false;
    }
    return isRadioOnForSubscriber(subId);
}
#end_block

#method_before
@Override
public String getNetworkCountryIsoForPhone(int phoneId) {
    // Reporting the correct network country is ambiguous when IWLAN could conflict with
    // registered cell info, so return a NULL country instead.
    final long identity = Binder.clearCallingIdentity();
    try {
        final int subId = mSubscriptionController.getSubIdUsingPhoneId(phoneId);
        if (TelephonyManager.NETWORK_TYPE_IWLAN == getVoiceNetworkTypeForSubscriber(subId, mApp.getPackageName())) {
            return "";
        }
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
    return TelephonyManager.getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_OPERATOR_ISO_COUNTRY, "");
}
#method_after
@Override
public String getNetworkCountryIsoForPhone(int phoneId) {
    // Reporting the correct network country is ambiguous when IWLAN could conflict with
    // registered cell info, so return a NULL country instead.
    final long identity = Binder.clearCallingIdentity();
    try {
        final int subId = mSubscriptionController.getSubIdUsingPhoneId(phoneId);
        // is on IWLAN.
        if (TelephonyManager.NETWORK_TYPE_IWLAN == getVoiceNetworkTypeForSubscriber(subId, mApp.getPackageName())) {
            return "";
        }
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
    Phone phone = PhoneFactory.getPhone(phoneId);
    if (phone != null) {
        ServiceStateTracker sst = phone.getServiceStateTracker();
        if (sst != null) {
            LocaleTracker lt = sst.getLocaleTracker();
            if (lt != null) {
                return lt.getCurrentCountry();
            }
        }
    }
    return "";
}
#end_block

#method_before
@Override
public String getImeiForSlot(int slotIndex, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getImeiForSlot")) {
        return null;
    }
    Phone phone = PhoneFactory.getPhone(slotIndex);
    return phone == null ? null : phone.getImei();
}
#method_after
@Override
public String getImeiForSlot(int slotIndex, String callingPackage) {
    Phone phone = PhoneFactory.getPhone(slotIndex);
    if (phone == null) {
        return null;
    }
    int subId = phone.getSubId();
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "getImeiForSlot")) {
        return null;
    }
    return phone.getImei();
}
#end_block

#method_before
@Override
public String getMeidForSlot(int slotIndex, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getMeidForSlot")) {
        return null;
    }
    Phone phone = PhoneFactory.getPhone(slotIndex);
    return phone == null ? null : phone.getMeid();
}
#method_after
@Override
public String getMeidForSlot(int slotIndex, String callingPackage) {
    Phone phone = PhoneFactory.getPhone(slotIndex);
    if (phone == null) {
        return null;
    }
    int subId = phone.getSubId();
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "getMeidForSlot")) {
        return null;
    }
    return phone.getMeid();
}
#end_block

#method_before
@Override
public String getDeviceSoftwareVersionForSlot(int slotIndex, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getDeviceSoftwareVersionForSlot")) {
        return null;
    }
    Phone phone = PhoneFactory.getPhone(slotIndex);
    return phone == null ? null : phone.getDeviceSvn();
}
#method_after
@Override
public String getDeviceSoftwareVersionForSlot(int slotIndex, String callingPackage) {
    Phone phone = PhoneFactory.getPhone(slotIndex);
    if (phone == null) {
        return null;
    }
    int subId = phone.getSubId();
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "getDeviceSoftwareVersionForSlot")) {
        return null;
    }
    return phone.getDeviceSvn();
}
#end_block

#method_before
@Override
public int getCdmaEriIconIndexForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getCdmaEriIconIndexForSubscriber")) {
        return -1;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getCdmaEriIconIndex();
    } else {
        return -1;
    }
}
#method_after
@Override
public int getCdmaEriIconIndexForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "getCdmaEriIconIndexForSubscriber")) {
        return -1;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getCdmaEriIconIndex();
    } else {
        return -1;
    }
}
#end_block

#method_before
@Override
public int getCdmaEriIconModeForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getCdmaEriIconModeForSubscriber")) {
        return -1;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getCdmaEriIconMode();
    } else {
        return -1;
    }
}
#method_after
@Override
public int getCdmaEriIconModeForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "getCdmaEriIconModeForSubscriber")) {
        return -1;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getCdmaEriIconMode();
    } else {
        return -1;
    }
}
#end_block

#method_before
@Override
public String getCdmaEriTextForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getCdmaEriIconTextForSubscriber")) {
        return null;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getCdmaEriText();
    } else {
        return null;
    }
}
#method_after
@Override
public String getCdmaEriTextForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "getCdmaEriIconTextForSubscriber")) {
        return null;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getCdmaEriText();
    } else {
        return null;
    }
}
#end_block

#method_before
@Override
public String getVisualVoicemailPackageName(String callingPackage, int subId) {
    mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getVisualVoicemailPackageName")) {
        return null;
    }
    return RemoteVvmTaskManager.getRemotePackage(mPhone.getContext(), subId).getPackageName();
}
#method_after
@Override
public String getVisualVoicemailPackageName(String callingPackage, int subId) {
    mAppOps.checkPackage(Binder.getCallingUid(), callingPackage);
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "getVisualVoicemailPackageName")) {
        return null;
    }
    final long identity = Binder.clearCallingIdentity();
    try {
        return RemoteVvmTaskManager.getRemotePackage(mPhone.getContext(), subId).getPackageName();
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}
#end_block

#method_before
@Override
public int getVoiceActivationState(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getVoiceActivationStateForSubscriber")) {
        return TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getVoiceActivationState();
    } else {
        return TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN;
    }
}
#method_after
@Override
public int getVoiceActivationState(int subId, String callingPackage) {
    enforceReadPrivilegedPermission();
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getVoiceActivationState();
    } else {
        return TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN;
    }
}
#end_block

#method_before
@Override
public int getDataActivationState(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getDataActivationStateForSubscriber")) {
        return TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getDataActivationState();
    } else {
        return TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN;
    }
}
#method_after
@Override
public int getDataActivationState(int subId, String callingPackage) {
    enforceReadPrivilegedPermission();
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getDataActivationState();
    } else {
        return TelephonyManager.SIM_ACTIVATION_STATE_UNKNOWN;
    }
}
#end_block

#method_before
@Override
public int getNetworkTypeForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getNetworkTypeForSubscriber")) {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getServiceState().getDataNetworkType();
    } else {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
}
#method_after
@Override
public int getNetworkTypeForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "getNetworkTypeForSubscriber")) {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getServiceState().getDataNetworkType();
    } else {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
}
#end_block

#method_before
@Override
public int getDataNetworkTypeForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getDataNetworkTypeForSubscriber")) {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getServiceState().getDataNetworkType();
    } else {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
}
#method_after
@Override
public int getDataNetworkTypeForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "getDataNetworkTypeForSubscriber")) {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getServiceState().getDataNetworkType();
    } else {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
}
#end_block

#method_before
@Override
public int getVoiceNetworkTypeForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getDataNetworkTypeForSubscriber")) {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getServiceState().getVoiceNetworkType();
    } else {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
}
#method_after
@Override
public int getVoiceNetworkTypeForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "getDataNetworkTypeForSubscriber")) {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getServiceState().getVoiceNetworkType();
    } else {
        return TelephonyManager.NETWORK_TYPE_UNKNOWN;
    }
}
#end_block

#method_before
@Override
public int getLteOnCdmaModeForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getLteOnCdmaModeForSubscriber")) {
        return PhoneConstants.LTE_ON_CDMA_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone == null) {
        return PhoneConstants.LTE_ON_CDMA_UNKNOWN;
    } else {
        return phone.getLteOnCdmaMode();
    }
}
#method_after
@Override
public int getLteOnCdmaModeForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "getLteOnCdmaModeForSubscriber")) {
        return PhoneConstants.LTE_ON_CDMA_UNKNOWN;
    }
    final Phone phone = getPhone(subId);
    if (phone == null) {
        return PhoneConstants.LTE_ON_CDMA_UNKNOWN;
    } else {
        return phone.getLteOnCdmaMode();
    }
}
#end_block

#method_before
public String[] getForbiddenPlmns(int subId, int appType) {
    mApp.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PHONE_STATE, "Requires READ_PHONE_STATE");
    if (appType != TelephonyManager.APPTYPE_USIM && appType != TelephonyManager.APPTYPE_SIM) {
        loge("getForbiddenPlmnList(): App Type must be USIM or SIM");
        return null;
    }
    Object response = sendRequest(CMD_GET_FORBIDDEN_PLMNS, new Integer(appType), subId);
    if (response instanceof String[]) {
        return (String[]) response;
    }
    // Response is an Exception of some kind, which is signalled to the user as a NULL retval
    return null;
}
#method_after
public String[] getForbiddenPlmns(int subId, int appType) {
    // TODO(b/73884967): Migrate to TelephonyPermissions check.
    mApp.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PHONE_STATE, "Requires READ_PHONE_STATE");
    if (appType != TelephonyManager.APPTYPE_USIM && appType != TelephonyManager.APPTYPE_SIM) {
        loge("getForbiddenPlmnList(): App Type must be USIM or SIM");
        return null;
    }
    Object response = sendRequest(CMD_GET_FORBIDDEN_PLMNS, new Integer(appType), subId);
    if (response instanceof String[]) {
        return (String[]) response;
    }
    // Response is an Exception of some kind, which is signalled to the user as a NULL retval
    return null;
}
#end_block

#method_before
public String[] getPcscfAddress(String apnType, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getPcscfAddress")) {
        return new String[0];
    }
    return mPhone.getPcscfAddress(apnType);
}
#method_after
public String[] getPcscfAddress(String apnType, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, mPhone.getSubId(), callingPackage, "getPcscfAddress")) {
        return new String[0];
    }
    return mPhone.getPcscfAddress(apnType);
}
#end_block

#method_before
@Override
public int getCalculatedPreferredNetworkType(String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getCalculatedPreferredNetworkType")) {
        return RILConstants.PREFERRED_NETWORK_MODE;
    }
    // wink FIXME: need to get SubId from somewhere.
    return PhoneFactory.calculatePreferredNetworkType(mPhone.getContext(), 0);
}
#method_after
@Override
public int getCalculatedPreferredNetworkType(String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, mPhone.getSubId(), callingPackage, "getCalculatedPreferredNetworkType")) {
        return RILConstants.PREFERRED_NETWORK_MODE;
    }
    // wink FIXME: need to get SubId from somewhere.
    return PhoneFactory.calculatePreferredNetworkType(mPhone.getContext(), 0);
}
#end_block

#method_before
@Override
public String getLine1NumberForDisplay(int subId, String callingPackage) {
    // This is open to apps with WRITE_SMS.
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneNumber(mApp, callingPackage, "getLine1NumberForDisplay")) {
        if (DBG_MERGE)
            log("getLine1NumberForDisplay returning null due to permission");
        return null;
    }
    String iccId = getIccId(subId);
    if (iccId != null) {
        String numberPrefKey = PREF_CARRIERS_NUMBER_PREFIX + iccId;
        if (DBG_MERGE) {
            log("getLine1NumberForDisplay returning " + mTelephonySharedPreferences.getString(numberPrefKey, null));
        }
        return mTelephonySharedPreferences.getString(numberPrefKey, null);
    }
    if (DBG_MERGE)
        log("getLine1NumberForDisplay returning null as iccId is null");
    return null;
}
#method_after
@Override
public String getLine1NumberForDisplay(int subId, String callingPackage) {
    // This is open to apps with WRITE_SMS.
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneNumber(mApp, subId, callingPackage, "getLine1NumberForDisplay")) {
        if (DBG_MERGE)
            log("getLine1NumberForDisplay returning null due to permission");
        return null;
    }
    String iccId = getIccId(subId);
    if (iccId != null) {
        String numberPrefKey = PREF_CARRIERS_NUMBER_PREFIX + iccId;
        if (DBG_MERGE) {
            log("getLine1NumberForDisplay returning " + mTelephonySharedPreferences.getString(numberPrefKey, null));
        }
        return mTelephonySharedPreferences.getString(numberPrefKey, null);
    }
    if (DBG_MERGE)
        log("getLine1NumberForDisplay returning null as iccId is null");
    return null;
}
#end_block

#method_before
@Override
public String getLine1AlphaTagForDisplay(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getLine1AlphaTagForDisplay")) {
        return null;
    }
    String iccId = getIccId(subId);
    if (iccId != null) {
        String alphaTagPrefKey = PREF_CARRIERS_ALPHATAG_PREFIX + iccId;
        return mTelephonySharedPreferences.getString(alphaTagPrefKey, null);
    }
    return null;
}
#method_after
@Override
public String getLine1AlphaTagForDisplay(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "getLine1AlphaTagForDisplay")) {
        return null;
    }
    String iccId = getIccId(subId);
    if (iccId != null) {
        String alphaTagPrefKey = PREF_CARRIERS_ALPHATAG_PREFIX + iccId;
        return mTelephonySharedPreferences.getString(alphaTagPrefKey, null);
    }
    return null;
}
#end_block

#method_before
@Override
public String[] getMergedSubscriberIds(String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getMergedSubscriberIds")) {
        return null;
    }
    final Context context = mPhone.getContext();
    final TelephonyManager tele = TelephonyManager.from(context);
    final SubscriptionManager sub = SubscriptionManager.from(context);
    // Figure out what subscribers are currently active
    final ArraySet<String> activeSubscriberIds = new ArraySet<>();
    // Clear calling identity, when calling TelephonyManager, because callerUid must be
    // the process, where TelephonyManager was instantiated. Otherwise AppOps check will fail.
    final long identity = Binder.clearCallingIdentity();
    try {
        final int[] subIds = sub.getActiveSubscriptionIdList();
        for (int subId : subIds) {
            activeSubscriberIds.add(tele.getSubscriberId(subId));
        }
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
    // First pass, find a number override for an active subscriber
    String mergeNumber = null;
    final Map<String, ?> prefs = mTelephonySharedPreferences.getAll();
    for (String key : prefs.keySet()) {
        if (key.startsWith(PREF_CARRIERS_SUBSCRIBER_PREFIX)) {
            final String subscriberId = (String) prefs.get(key);
            if (activeSubscriberIds.contains(subscriberId)) {
                final String iccId = key.substring(PREF_CARRIERS_SUBSCRIBER_PREFIX.length());
                final String numberKey = PREF_CARRIERS_NUMBER_PREFIX + iccId;
                mergeNumber = (String) prefs.get(numberKey);
                if (DBG_MERGE) {
                    Slog.d(LOG_TAG, "Found line number " + mergeNumber + " for active subscriber " + subscriberId);
                }
                if (!TextUtils.isEmpty(mergeNumber)) {
                    break;
                }
            }
        }
    }
    // Shortcut when no active merged subscribers
    if (TextUtils.isEmpty(mergeNumber)) {
        return null;
    }
    // Second pass, find all subscribers under that line override
    final ArraySet<String> result = new ArraySet<>();
    for (String key : prefs.keySet()) {
        if (key.startsWith(PREF_CARRIERS_NUMBER_PREFIX)) {
            final String number = (String) prefs.get(key);
            if (mergeNumber.equals(number)) {
                final String iccId = key.substring(PREF_CARRIERS_NUMBER_PREFIX.length());
                final String subscriberKey = PREF_CARRIERS_SUBSCRIBER_PREFIX + iccId;
                final String subscriberId = (String) prefs.get(subscriberKey);
                if (!TextUtils.isEmpty(subscriberId)) {
                    result.add(subscriberId);
                }
            }
        }
    }
    final String[] resultArray = result.toArray(new String[result.size()]);
    Arrays.sort(resultArray);
    if (DBG_MERGE) {
        Slog.d(LOG_TAG, "Found subscribers " + Arrays.toString(resultArray) + " after merge");
    }
    return resultArray;
}
#method_after
@Override
public String[] getMergedSubscriberIds(String callingPackage) {
    // about carrier-privileged callers not having access.
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, SubscriptionManager.INVALID_SUBSCRIPTION_ID, callingPackage, "getMergedSubscriberIds")) {
        return null;
    }
    final Context context = mPhone.getContext();
    final TelephonyManager tele = TelephonyManager.from(context);
    final SubscriptionManager sub = SubscriptionManager.from(context);
    // Figure out what subscribers are currently active
    final ArraySet<String> activeSubscriberIds = new ArraySet<>();
    // Clear calling identity, when calling TelephonyManager, because callerUid must be
    // the process, where TelephonyManager was instantiated. Otherwise AppOps check will fail.
    final long identity = Binder.clearCallingIdentity();
    try {
        final int[] subIds = sub.getActiveSubscriptionIdList();
        for (int subId : subIds) {
            activeSubscriberIds.add(tele.getSubscriberId(subId));
        }
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
    // First pass, find a number override for an active subscriber
    String mergeNumber = null;
    final Map<String, ?> prefs = mTelephonySharedPreferences.getAll();
    for (String key : prefs.keySet()) {
        if (key.startsWith(PREF_CARRIERS_SUBSCRIBER_PREFIX)) {
            final String subscriberId = (String) prefs.get(key);
            if (activeSubscriberIds.contains(subscriberId)) {
                final String iccId = key.substring(PREF_CARRIERS_SUBSCRIBER_PREFIX.length());
                final String numberKey = PREF_CARRIERS_NUMBER_PREFIX + iccId;
                mergeNumber = (String) prefs.get(numberKey);
                if (DBG_MERGE) {
                    Slog.d(LOG_TAG, "Found line number " + mergeNumber + " for active subscriber " + subscriberId);
                }
                if (!TextUtils.isEmpty(mergeNumber)) {
                    break;
                }
            }
        }
    }
    // Shortcut when no active merged subscribers
    if (TextUtils.isEmpty(mergeNumber)) {
        return null;
    }
    // Second pass, find all subscribers under that line override
    final ArraySet<String> result = new ArraySet<>();
    for (String key : prefs.keySet()) {
        if (key.startsWith(PREF_CARRIERS_NUMBER_PREFIX)) {
            final String number = (String) prefs.get(key);
            if (mergeNumber.equals(number)) {
                final String iccId = key.substring(PREF_CARRIERS_NUMBER_PREFIX.length());
                final String subscriberKey = PREF_CARRIERS_SUBSCRIBER_PREFIX + iccId;
                final String subscriberId = (String) prefs.get(subscriberKey);
                if (!TextUtils.isEmpty(subscriberId)) {
                    result.add(subscriberId);
                }
            }
        }
    }
    final String[] resultArray = result.toArray(new String[result.size()]);
    Arrays.sort(resultArray);
    if (DBG_MERGE) {
        Slog.d(LOG_TAG, "Found subscribers " + Arrays.toString(resultArray) + " after merge");
    }
    return resultArray;
}
#end_block

#method_before
@Override
public int getRadioAccessFamily(int phoneId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getRadioAccessFamily")) {
        return RadioAccessFamily.RAF_UNKNOWN;
    }
    return ProxyController.getInstance().getRadioAccessFamily(phoneId);
}
#method_after
@Override
public int getRadioAccessFamily(int phoneId, String callingPackage) {
    Phone phone = PhoneFactory.getPhone(phoneId);
    if (phone == null) {
        return RadioAccessFamily.RAF_UNKNOWN;
    }
    int subId = phone.getSubId();
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "getRadioAccessFamily")) {
        return RadioAccessFamily.RAF_UNKNOWN;
    }
    return ProxyController.getInstance().getRadioAccessFamily(phoneId);
}
#end_block

#method_before
@Override
public boolean isVideoCallingEnabled(String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "isVideoCallingEnabled")) {
        return false;
    }
    // Check the user preference and the  system-level IMS setting. Even if the user has
    // enabled video calling, if IMS is disabled we aren't able to support video calling.
    // In the long run, we may instead need to check if there exists a connection service
    // which can support video calling.
    ImsManager imsManager = ImsManager.getInstance(mPhone.getContext(), mPhone.getPhoneId());
    return imsManager.isVtEnabledByPlatform() && imsManager.isEnhanced4gLteModeSettingEnabledByUser() && imsManager.isVtEnabledByUser();
}
#method_after
@Override
public boolean isVideoCallingEnabled(String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, mPhone.getSubId(), callingPackage, "isVideoCallingEnabled")) {
        return false;
    }
    // Check the user preference and the  system-level IMS setting. Even if the user has
    // enabled video calling, if IMS is disabled we aren't able to support video calling.
    // In the long run, we may instead need to check if there exists a connection service
    // which can support video calling.
    ImsManager imsManager = ImsManager.getInstance(mPhone.getContext(), mPhone.getPhoneId());
    return imsManager.isVtEnabledByPlatform() && imsManager.isEnhanced4gLteModeSettingEnabledByUser() && imsManager.isVtEnabledByUser();
}
#end_block

#method_before
@Override
public String getDeviceId(String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getDeviceId")) {
        return null;
    }
    final Phone phone = PhoneFactory.getPhone(0);
    if (phone != null) {
        return phone.getDeviceId();
    } else {
        return null;
    }
}
#method_after
@Override
public String getDeviceId(String callingPackage) {
    final Phone phone = PhoneFactory.getPhone(0);
    if (phone == null) {
        return null;
    }
    int subId = phone.getSubId();
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "getDeviceId")) {
        return null;
    }
    return phone.getDeviceId();
}
#end_block

#method_before
@Override
public ServiceState getServiceStateForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getServiceStateForSubscriber")) {
        return null;
    }
    final Phone phone = getPhone(subId);
    if (phone == null) {
        return null;
    }
    return phone.getServiceState();
}
#method_after
@Override
public ServiceState getServiceStateForSubscriber(int subId, String callingPackage) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "getServiceStateForSubscriber")) {
        return null;
    }
    final Phone phone = getPhone(subId);
    if (phone == null) {
        return null;
    }
    return phone.getServiceState();
}
#end_block

#method_before
@Override
public List<ClientRequestStats> getClientRequestStats(String callingPackage, int subId) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, callingPackage, "getClientRequestStats")) {
        return null;
    }
    Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getClientRequestStats();
    }
    return null;
}
#method_after
@Override
public List<ClientRequestStats> getClientRequestStats(String callingPackage, int subId) {
    if (!TelephonyPermissions.checkCallingOrSelfReadPhoneState(mApp, subId, callingPackage, "getClientRequestStats")) {
        return null;
    }
    Phone phone = getPhone(subId);
    if (phone != null) {
        return phone.getClientRequestStats();
    }
    return null;
}
#end_block

#method_before
@Override
public UiccSlotInfo[] getUiccSlotsInfo() {
    enforceReadPrivilegedPermission();
    UiccSlot[] slots = UiccController.getInstance().getUiccSlots();
    if (slots == null)
        return null;
    UiccSlotInfo[] infos = new UiccSlotInfo[slots.length];
    for (int i = 0; i < slots.length; i++) {
        UiccSlot slot = slots[i];
        String cardId = UiccController.getInstance().getUiccCard(i).getCardId();
        int cardState = 0;
        switch(slot.getCardState()) {
            case CARDSTATE_ABSENT:
                cardState = UiccSlotInfo.CARD_STATE_INFO_ABSENT;
                break;
            case CARDSTATE_PRESENT:
                cardState = UiccSlotInfo.CARD_STATE_INFO_PRESENT;
                break;
            case CARDSTATE_ERROR:
                cardState = UiccSlotInfo.CARD_STATE_INFO_ERROR;
                break;
            case CARDSTATE_RESTRICTED:
                cardState = UiccSlotInfo.CARD_STATE_INFO_RESTRICTED;
                break;
            default:
                break;
        }
        infos[i] = new UiccSlotInfo(slot.isActive(), slot.isEuicc(), cardId, cardState, slot.getPhoneId());
    }
    return infos;
}
#method_after
@Override
public UiccSlotInfo[] getUiccSlotsInfo() {
    enforceReadPrivilegedPermission();
    UiccSlot[] slots = UiccController.getInstance().getUiccSlots();
    if (slots == null)
        return null;
    UiccSlotInfo[] infos = new UiccSlotInfo[slots.length];
    for (int i = 0; i < slots.length; i++) {
        UiccSlot slot = slots[i];
        String cardId = UiccController.getInstance().getUiccCard(i).getCardId();
        int cardState = 0;
        switch(slot.getCardState()) {
            case CARDSTATE_ABSENT:
                cardState = UiccSlotInfo.CARD_STATE_INFO_ABSENT;
                break;
            case CARDSTATE_PRESENT:
                cardState = UiccSlotInfo.CARD_STATE_INFO_PRESENT;
                break;
            case CARDSTATE_ERROR:
                cardState = UiccSlotInfo.CARD_STATE_INFO_ERROR;
                break;
            case CARDSTATE_RESTRICTED:
                cardState = UiccSlotInfo.CARD_STATE_INFO_RESTRICTED;
                break;
            default:
                break;
        }
        infos[i] = new UiccSlotInfo(slot.isActive(), slot.isEuicc(), cardId, cardState, slot.getPhoneId(), slot.isExtendedApduSupported());
    }
    return infos;
}
#end_block

#method_before
/**
 * See <a href="http://man7.org/linux/man-pages/man3/getifaddrs.3.html">getifaddrs(3)</a>.
 */
public static StructIfaddrs[] getifaddrs() throws ErrnoException {
    return Libcore.os.getifaddrs();
}
#method_after
public static StructIfaddrs[] getifaddrs() throws ErrnoException {
    return Libcore.os.getifaddrs();
}
#end_block

#method_before
/**
 * See <a href="http://man7.org/linux/man-pages/man2/getpgid.2.html">getpgid(2)</a>.
 */
public static int getpgid(int pid) throws ErrnoException {
    return Libcore.os.getpgid(pid);
}
#method_after
public static int getpgid(int pid) throws ErrnoException {
    return Libcore.os.getpgid(pid);
}
#end_block

#method_before
/**
 * See <a href="http://man7.org/linux/man-pages/man3/realpath.3.html">realpath(3)</a>.
 */
public static String realpath(String path) throws ErrnoException {
    return Libcore.os.realpath(path);
}
#method_after
public static String realpath(String path) throws ErrnoException {
    return Libcore.os.realpath(path);
}
#end_block

#method_before
/**
 * See <a href="http://man7.org/linux/man-pages/man2/sendto.2.html">sendto(2)</a>.
 */
public static int sendto(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount, int flags, SocketAddress address) throws ErrnoException, SocketException {
    return Libcore.os.sendto(fd, bytes, byteOffset, byteCount, flags, address);
}
#method_after
public static int sendto(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount, int flags, SocketAddress address) throws ErrnoException, SocketException {
    return Libcore.os.sendto(fd, bytes, byteOffset, byteCount, flags, address);
}
#end_block

#method_before
/**
 * See <a href="http://man7.org/linux/man-pages/man2/setpgid.2.html">setpgid(2)</a>.
 */
public static void setpgid(int pid, int pgid) throws ErrnoException {
    Libcore.os.setpgid(pid, pgid);
}
#method_after
public static void setpgid(int pid, int pgid) throws ErrnoException {
    Libcore.os.setpgid(pid, pgid);
}
#end_block

#method_before
public void setComment(String comment) {
    // Android-added: Explicitly use UTF_8 instead of the default charset.
    if (comment != null && comment.getBytes(StandardCharsets.UTF_8).length > 0xffff) {
        throw new IllegalArgumentException(comment + " too long: " + comment.getBytes(StandardCharsets.UTF_8).length);
    }
    this.comment = comment;
}
#method_after
public void setComment(String comment) {
    // BEGIN Android-added: Explicitly use UTF_8 instead of the default charset.
    if (comment != null && comment.getBytes(StandardCharsets.UTF_8).length > 0xffff) {
        throw new IllegalArgumentException(comment + " too long: " + comment.getBytes(StandardCharsets.UTF_8).length);
    }
    // END Android-added: Explicitly use UTF_8 instead of the default charset.
    this.comment = comment;
}
#end_block

#method_before
// b/28901232
// Test for OPEN_DELETE throwing an exception when used in
public void testOpenDeleteOnExternalStorage() throws Exception {
    File file = new File("/storage/emulated/0/Download/foo.zip");
    try {
        ZipOutputStream test = new ZipOutputStream(new FileOutputStream(file));
        test.putNextEntry(new ZipEntry("somefile.txt"));
        test.write(1);
        test.close();
        ZipFile z = new ZipFile(file, ZipFile.OPEN_READ | ZipFile.OPEN_DELETE);
        z.close();
        assertFalse(file.exists());
    } finally {
        file.delete();
    }
}
#method_after
// b/28901232
// Test for OPEN_DELETE throwing an exception when used in
public void testOpenDeleteOnExternalStorage() throws Exception {
    File file = new File("/storage/emulated/0/Download/foo.zip");
    try {
        ZipOutputStream test = new ZipOutputStream(new FileOutputStream(file));
        test.putNextEntry(new ZipEntry("somefile.txt"));
        test.write(1);
        test.close();
        ZipFile z = new ZipFile(file, ZipFile.OPEN_READ | ZipFile.OPEN_DELETE);
        InputStream inputStream = z.getInputStream(z.getEntry("somefile.txt"));
        assertEquals(1, inputStream.read());
        inputStream.close();
        z.close();
        assertFalse(file.exists());
    } finally {
        file.delete();
    }
}
#end_block

#method_before
@Override
public boolean onTouch(View view, MotionEvent event) {
    Trace.beginSection("TouchLatencyView onTouch");
    int action = event.getActionMasked();
    if (action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_MOVE) {
        mTouching = true;
        invalidate();
    } else if (action == MotionEvent.ACTION_UP) {
        mTouching = false;
        invalidate();
        Trace.endSection();
        return true;
    } else {
        Trace.endSection();
        return true;
    }
    mTouchX = event.getX();
    mTouchY = event.getY();
    Trace.endSection();
    return true;
}
#method_after
@Override
public boolean onTouch(View view, MotionEvent event) {
    Trace.beginSection("TouchLatencyView onTouch");
    int action = event.getActionMasked();
    if (action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_MOVE) {
        mTouching = true;
        invalidate();
        mTouchX = event.getX();
        mTouchY = event.getY();
    } else if (action == MotionEvent.ACTION_UP) {
        mTouching = false;
        invalidate();
    }
    Trace.endSection();
    return true;
}
#end_block

#method_before
private void drawTouch(Canvas canvas) {
    Trace.beginSection("TouchLatencyView drawTouch");
    if (!mTouching) {
        Log.d(LOG_TAG, "Filling background");
        canvas.drawColor(BACKGROUND_COLOR);
        Trace.endSection();
        return;
    }
    float deltaX = (mTouchX - mLastDrawnX);
    float deltaY = (mTouchY - mLastDrawnY);
    float scaleFactor = (float) Math.sqrt(deltaX * deltaX + deltaY * deltaY) * 1.5f;
    mLastDrawnX = mTouchX;
    mLastDrawnY = mTouchY;
    canvas.drawColor(BACKGROUND_COLOR);
    canvas.drawCircle(mTouchX, mTouchY, INNER_RADIUS + 3 * scaleFactor, mRedPaint);
    canvas.drawCircle(mTouchX, mTouchY, INNER_RADIUS + 2 * scaleFactor, mYellowPaint);
    canvas.drawCircle(mTouchX, mTouchY, INNER_RADIUS + scaleFactor, mGreenPaint);
    canvas.drawCircle(mTouchX, mTouchY, INNER_RADIUS, mBluePaint);
    Trace.endSection();
}
#method_after
private void drawTouch(Canvas canvas) {
    Trace.beginSection("TouchLatencyView drawTouch");
    try {
        if (!mTouching) {
            Log.d(LOG_TAG, "Filling background");
            canvas.drawColor(BACKGROUND_COLOR);
            return;
        }
        float deltaX = (mTouchX - mLastDrawnX);
        float deltaY = (mTouchY - mLastDrawnY);
        float scaleFactor = (float) Math.sqrt(deltaX * deltaX + deltaY * deltaY) * 1.5f;
        mLastDrawnX = mTouchX;
        mLastDrawnY = mTouchY;
        canvas.drawColor(BACKGROUND_COLOR);
        canvas.drawCircle(mTouchX, mTouchY, INNER_RADIUS + 3 * scaleFactor, mRedPaint);
        canvas.drawCircle(mTouchX, mTouchY, INNER_RADIUS + 2 * scaleFactor, mYellowPaint);
        canvas.drawCircle(mTouchX, mTouchY, INNER_RADIUS + scaleFactor, mGreenPaint);
        canvas.drawCircle(mTouchX, mTouchY, INNER_RADIUS, mBluePaint);
    } finally {
        Trace.endSection();
    }
}
#end_block

#method_before
private void startListeningForCalls() throws ImsException {
    mImsServiceRetryCount = 0;
    mServiceId = mImsManager.open(ImsServiceClass.MMTEL, createIncomingCallPendingIntent(), mImsConnectionStateListener);
    mImsManager.setImsConfigListener(mImsConfigListener);
    // Get the ECBM interface and set IMSPhone's listener object for notifications
    getEcbmInterface().setEcbmStateListener(mPhone.getImsEcbmStateListener());
    if (mPhone.isInEcm()) {
        // Call exit ECBM which will invoke onECBMExited
        mPhone.exitEmergencyCallbackMode();
    }
    int mPreferredTtyMode = Settings.Secure.getInt(mPhone.getContext().getContentResolver(), Settings.Secure.PREFERRED_TTY_MODE, Phone.TTY_MODE_OFF);
    mImsManager.setUiTTYMode(mPhone.getContext(), mPreferredTtyMode, null);
    ImsMultiEndpoint multiEndpoint = getMultiEndpointInterface();
    if (multiEndpoint != null) {
        multiEndpoint.setExternalCallStateListener(mPhone.getExternalCallTracker().getExternalCallStateListener());
    }
    if (mCarrierConfigLoaded) {
        ImsManager.updateImsServiceConfig(mPhone.getContext(), mPhone.getPhoneId(), true);
    }
}
#method_after
private void startListeningForCalls() throws ImsException {
    log("startListeningForCalls");
    mImsManager.open(mMmTelFeatureListener);
    mImsManager.addRegistrationCallback(mImsRegistrationCallback);
    mImsManager.addCapabilitiesCallback(mImsCapabilityCallback);
    mImsManager.setConfigListener(mImsConfigListener);
    mImsManager.getConfigInterface().addConfigCallback(mConfigCallback);
    // Get the ECBM interface and set IMSPhone's listener object for notifications
    getEcbmInterface().setEcbmStateListener(mPhone.getImsEcbmStateListener());
    if (mPhone.isInEcm()) {
        // Call exit ECBM which will invoke onECBMExited
        mPhone.exitEmergencyCallbackMode();
    }
    int mPreferredTtyMode = Settings.Secure.getInt(mPhone.getContext().getContentResolver(), Settings.Secure.PREFERRED_TTY_MODE, Phone.TTY_MODE_OFF);
    mImsManager.setUiTTYMode(mPhone.getContext(), mPreferredTtyMode, null);
    ImsMultiEndpoint multiEndpoint = getMultiEndpointInterface();
    if (multiEndpoint != null) {
        multiEndpoint.setExternalCallStateListener(mPhone.getExternalCallTracker().getExternalCallStateListener());
    }
    // Set UT interface listener to receive UT indications.
    mUtInterface = getUtInterface();
    if (mUtInterface != null) {
        mUtInterface.registerForSuppServiceIndication(this, EVENT_SUPP_SERVICE_INDICATION, null);
    }
    if (mCarrierConfigLoaded) {
        mImsManager.updateImsServiceConfig(true);
    }
}
#end_block

#method_before
private void stopListeningForCalls() {
    try {
        resetImsCapabilities();
        // Only close on valid session.
        if (mImsManager != null && mServiceId > 0) {
            mImsManager.close(mServiceId);
            mServiceId = -1;
        }
    } catch (ImsException e) {
    // If the binder is unavailable, then the ImsService doesn't need to close.
    }
}
#method_after
private void stopListeningForCalls() {
    log("stopListeningForCalls");
    resetImsCapabilities();
    // Only close on valid session.
    if (mImsManager != null) {
        try {
            mImsManager.getConfigInterface().removeConfigCallback(mConfigCallback);
        } catch (ImsException e) {
            Log.w(LOG_TAG, "stopListeningForCalls: unable to remove config callback.");
        }
        mImsManager.close();
    }
}
#end_block

#method_before
public void dispose() {
    if (DBG)
        log("dispose");
    mRingingCall.dispose();
    mBackgroundCall.dispose();
    mForegroundCall.dispose();
    mHandoverCall.dispose();
    clearDisconnected();
    mPhone.getContext().unregisterReceiver(mReceiver);
    mPhone.getDefaultPhone().unregisterForDataEnabledChanged(this);
    removeMessages(EVENT_GET_IMS_SERVICE);
}
#method_after
public void dispose() {
    if (DBG)
        log("dispose");
    mRingingCall.dispose();
    mBackgroundCall.dispose();
    mForegroundCall.dispose();
    mHandoverCall.dispose();
    clearDisconnected();
    if (mUtInterface != null) {
        mUtInterface.unregisterForSuppServiceIndication(this);
    }
    mPhone.getContext().unregisterReceiver(mReceiver);
    mPhone.getDefaultPhone().unregisterForDataEnabledChanged(this);
    mImsManagerConnector.disconnect();
}
#end_block

#method_before
public Connection dial(String dialString, int videoState, Bundle intentExtras) throws CallStateException {
    int oirMode;
    if (mSharedPreferenceProxy != null && mPhone.getDefaultPhone() != null) {
        SharedPreferences sp = mSharedPreferenceProxy.getDefaultSharedPreferences(mPhone.getContext());
        oirMode = sp.getInt(Phone.CLIR_KEY + mPhone.getDefaultPhone().getPhoneId(), CommandsInterface.CLIR_DEFAULT);
    } else {
        loge("dial; could not get default CLIR mode.");
        oirMode = CommandsInterface.CLIR_DEFAULT;
    }
    return dial(dialString, oirMode, videoState, intentExtras);
}
#method_after
public Connection dial(String dialString, int videoState, Bundle intentExtras) throws CallStateException {
    ImsPhone.ImsDialArgs dialArgs = new ImsPhone.ImsDialArgs.Builder().setIntentExtras(intentExtras).setVideoState(videoState).setClirMode(getClirMode()).build();
    return dial(dialString, dialArgs);
}
#end_block

#method_before
synchronized Connection dial(String dialString, int clirMode, int videoState, Bundle intentExtras) throws CallStateException {
    boolean isPhoneInEcmMode = isPhoneInEcbMode();
    boolean isEmergencyNumber = PhoneNumberUtils.isEmergencyNumber(dialString);
    if (DBG)
        log("dial clirMode=" + clirMode);
    // note that this triggers call state changed notif
    clearDisconnected();
    if (mImsManager == null) {
        throw new CallStateException("service not available");
    }
    if (!canDial()) {
        throw new CallStateException("cannot dial in current state");
    }
    if (isPhoneInEcmMode && isEmergencyNumber) {
        handleEcmTimer(ImsPhone.CANCEL_ECM_TIMER);
    }
    // calls, dial as an audio-only call.
    if (isEmergencyNumber && VideoProfile.isVideo(videoState) && !mAllowEmergencyVideoCalls) {
        loge("dial: carrier does not support video emergency calls; downgrade to audio-only");
        videoState = VideoProfile.STATE_AUDIO_ONLY;
    }
    boolean holdBeforeDial = false;
    // there on hold
    if (mForegroundCall.getState() == ImsPhoneCall.State.ACTIVE) {
        if (mBackgroundCall.getState() != ImsPhoneCall.State.IDLE) {
            // we should have failed in !canDial() above before we get here
            throw new CallStateException("cannot dial in current state");
        }
        // foreground call is empty for the newly dialed connection
        holdBeforeDial = true;
        // Cache the video state for pending MO call.
        mPendingCallVideoState = videoState;
        mPendingIntentExtras = intentExtras;
        switchWaitingOrHoldingAndActive();
    }
    ImsPhoneCall.State fgState = ImsPhoneCall.State.IDLE;
    ImsPhoneCall.State bgState = ImsPhoneCall.State.IDLE;
    mClirMode = clirMode;
    synchronized (mSyncHold) {
        if (holdBeforeDial) {
            fgState = mForegroundCall.getState();
            bgState = mBackgroundCall.getState();
            // holding foreground call failed
            if (fgState == ImsPhoneCall.State.ACTIVE) {
                throw new CallStateException("cannot dial in current state");
            }
            // holding foreground call succeeded
            if (bgState == ImsPhoneCall.State.HOLDING) {
                holdBeforeDial = false;
            }
        }
        mPendingMO = new ImsPhoneConnection(mPhone, checkForTestEmergencyNumber(dialString), this, mForegroundCall, isEmergencyNumber);
        mPendingMO.setVideoState(videoState);
    }
    addConnection(mPendingMO);
    if (!holdBeforeDial) {
        if ((!isPhoneInEcmMode) || (isPhoneInEcmMode && isEmergencyNumber)) {
            dialInternal(mPendingMO, clirMode, videoState, intentExtras);
        } else {
            try {
                getEcbmInterface().exitEmergencyCallbackMode();
            } catch (ImsException e) {
                e.printStackTrace();
                throw new CallStateException("service not available");
            }
            mPhone.setOnEcbModeExitResponse(this, EVENT_EXIT_ECM_RESPONSE_CDMA, null);
            pendingCallClirMode = clirMode;
            mPendingCallVideoState = videoState;
            pendingCallInEcm = true;
        }
    }
    updatePhoneState();
    mPhone.notifyPreciseCallStateChanged();
    return mPendingMO;
}
#method_after
public synchronized Connection dial(String dialString, ImsPhone.ImsDialArgs dialArgs) throws CallStateException {
    boolean isPhoneInEcmMode = isPhoneInEcbMode();
    boolean isEmergencyNumber = mPhoneNumberUtilsProxy.isEmergencyNumber(dialString);
    if (!shouldNumberBePlacedOnIms(isEmergencyNumber, dialString)) {
        Rlog.i(LOG_TAG, "dial: shouldNumberBePlacedOnIms = false");
        throw new CallStateException(CS_FALLBACK);
    }
    int clirMode = dialArgs.clirMode;
    int videoState = dialArgs.videoState;
    if (DBG)
        log("dial clirMode=" + clirMode);
    if (isEmergencyNumber) {
        clirMode = CommandsInterface.CLIR_SUPPRESSION;
        if (DBG)
            log("dial emergency call, set clirModIe=" + clirMode);
    }
    // note that this triggers call state changed notif
    clearDisconnected();
    if (mImsManager == null) {
        throw new CallStateException("service not available");
    }
    if (!canDial()) {
        throw new CallStateException("cannot dial in current state");
    }
    if (isPhoneInEcmMode && isEmergencyNumber) {
        handleEcmTimer(ImsPhone.CANCEL_ECM_TIMER);
    }
    // calls, dial as an audio-only call.
    if (isEmergencyNumber && VideoProfile.isVideo(videoState) && !mAllowEmergencyVideoCalls) {
        loge("dial: carrier does not support video emergency calls; downgrade to audio-only");
        videoState = VideoProfile.STATE_AUDIO_ONLY;
    }
    boolean holdBeforeDial = false;
    // there on hold
    if (mForegroundCall.getState() == ImsPhoneCall.State.ACTIVE) {
        if (mBackgroundCall.getState() != ImsPhoneCall.State.IDLE) {
            // we should have failed in !canDial() above before we get here
            throw new CallStateException("cannot dial in current state");
        }
        // foreground call is empty for the newly dialed connection
        holdBeforeDial = true;
        // Cache the video state for pending MO call.
        mPendingCallVideoState = videoState;
        mPendingIntentExtras = dialArgs.intentExtras;
        switchWaitingOrHoldingAndActive();
    }
    ImsPhoneCall.State fgState = ImsPhoneCall.State.IDLE;
    ImsPhoneCall.State bgState = ImsPhoneCall.State.IDLE;
    mClirMode = clirMode;
    synchronized (mSyncHold) {
        if (holdBeforeDial) {
            fgState = mForegroundCall.getState();
            bgState = mBackgroundCall.getState();
            // holding foreground call failed
            if (fgState == ImsPhoneCall.State.ACTIVE) {
                throw new CallStateException("cannot dial in current state");
            }
            // holding foreground call succeeded
            if (bgState == ImsPhoneCall.State.HOLDING) {
                holdBeforeDial = false;
            }
        }
        mPendingMO = new ImsPhoneConnection(mPhone, checkForTestEmergencyNumber(dialString), this, mForegroundCall, isEmergencyNumber);
        mPendingMO.setVideoState(videoState);
        if (dialArgs.rttTextStream != null) {
            log("dial: setting RTT stream on mPendingMO");
            mPendingMO.setCurrentRttTextStream(dialArgs.rttTextStream);
        }
    }
    addConnection(mPendingMO);
    if (!holdBeforeDial) {
        if ((!isPhoneInEcmMode) || (isPhoneInEcmMode && isEmergencyNumber)) {
            dialInternal(mPendingMO, clirMode, videoState, dialArgs.intentExtras);
        } else {
            try {
                getEcbmInterface().exitEmergencyCallbackMode();
            } catch (ImsException e) {
                e.printStackTrace();
                throw new CallStateException("service not available");
            }
            mPhone.setOnEcbModeExitResponse(this, EVENT_EXIT_ECM_RESPONSE_CDMA, null);
            pendingCallClirMode = clirMode;
            mPendingCallVideoState = videoState;
            pendingCallInEcm = true;
        }
    }
    updatePhoneState();
    mPhone.notifyPreciseCallStateChanged();
    return mPendingMO;
}
#end_block

#method_before
boolean isImsServiceReady() {
    if (mImsManager == null) {
        return false;
    }
    return mImsManager.isServiceAvailable();
}
#method_after
boolean isImsServiceReady() {
    if (mImsManager == null) {
        return false;
    }
    return mImsManager.isServiceReady();
}
#end_block

#method_before
private void cacheCarrierConfiguration(int subId) {
    CarrierConfigManager carrierConfigManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (carrierConfigManager == null) {
        loge("cacheCarrierConfiguration: No carrier config service found.");
        return;
    }
    PersistableBundle carrierConfig = carrierConfigManager.getConfigForSubId(subId);
    if (carrierConfig == null) {
        loge("cacheCarrierConfiguration: Empty carrier config.");
        return;
    }
    mAllowEmergencyVideoCalls = carrierConfig.getBoolean(CarrierConfigManager.KEY_ALLOW_EMERGENCY_VIDEO_CALLS_BOOL);
    mTreatDowngradedVideoCallsAsVideoCalls = carrierConfig.getBoolean(CarrierConfigManager.KEY_TREAT_DOWNGRADED_VIDEO_CALLS_AS_VIDEO_CALLS_BOOL);
    mDropVideoCallWhenAnsweringAudioCall = carrierConfig.getBoolean(CarrierConfigManager.KEY_DROP_VIDEO_CALL_WHEN_ANSWERING_AUDIO_CALL_BOOL);
    mAllowAddCallDuringVideoCall = carrierConfig.getBoolean(CarrierConfigManager.KEY_ALLOW_ADD_CALL_DURING_VIDEO_CALL_BOOL);
    mNotifyVtHandoverToWifiFail = carrierConfig.getBoolean(CarrierConfigManager.KEY_NOTIFY_VT_HANDOVER_TO_WIFI_FAILURE_BOOL);
    mSupportDowngradeVtToAudio = carrierConfig.getBoolean(CarrierConfigManager.KEY_SUPPORT_DOWNGRADE_VT_TO_AUDIO_BOOL);
    mNotifyHandoverVideoFromWifiToLTE = carrierConfig.getBoolean(CarrierConfigManager.KEY_NOTIFY_HANDOVER_VIDEO_FROM_WIFI_TO_LTE_BOOL);
    mIgnoreDataEnabledChangedForVideoCalls = carrierConfig.getBoolean(CarrierConfigManager.KEY_IGNORE_DATA_ENABLED_CHANGED_FOR_VIDEO_CALLS);
    mIsViLteDataMetered = carrierConfig.getBoolean(CarrierConfigManager.KEY_VILTE_DATA_IS_METERED_BOOL);
    mSupportPauseVideo = carrierConfig.getBoolean(CarrierConfigManager.KEY_SUPPORT_PAUSE_IMS_VIDEO_CALLS_BOOL);
    String[] mappings = carrierConfig.getStringArray(CarrierConfigManager.KEY_IMS_REASONINFO_MAPPING_STRING_ARRAY);
    if (mappings != null && mappings.length > 0) {
        for (String mapping : mappings) {
            String[] values = mapping.split(Pattern.quote("|"));
            if (values.length != 3) {
                continue;
            }
            try {
                Integer fromCode;
                if (values[0].equals("*")) {
                    fromCode = null;
                } else {
                    fromCode = Integer.parseInt(values[0]);
                }
                String message = values[1];
                int toCode = Integer.parseInt(values[2]);
                addReasonCodeRemapping(fromCode, message, toCode);
                log("Loaded ImsReasonInfo mapping : fromCode = " + fromCode == null ? "any" : fromCode + " ; message = " + message + " ; toCode = " + toCode);
            } catch (NumberFormatException nfe) {
                loge("Invalid ImsReasonInfo mapping found: " + mapping);
            }
        }
    } else {
        log("No carrier ImsReasonInfo mappings defined.");
    }
}
#method_after
private void cacheCarrierConfiguration(int subId) {
    CarrierConfigManager carrierConfigManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (carrierConfigManager == null || !SubscriptionController.getInstance().isActiveSubId(subId)) {
        loge("cacheCarrierConfiguration: No carrier config service found" + " " + "or not active subId = " + subId);
        mCarrierConfigLoaded = false;
        return;
    }
    PersistableBundle carrierConfig = carrierConfigManager.getConfigForSubId(subId);
    if (carrierConfig == null) {
        loge("cacheCarrierConfiguration: Empty carrier config.");
        mCarrierConfigLoaded = false;
        return;
    }
    mCarrierConfigLoaded = true;
    mAllowEmergencyVideoCalls = carrierConfig.getBoolean(CarrierConfigManager.KEY_ALLOW_EMERGENCY_VIDEO_CALLS_BOOL);
    mTreatDowngradedVideoCallsAsVideoCalls = carrierConfig.getBoolean(CarrierConfigManager.KEY_TREAT_DOWNGRADED_VIDEO_CALLS_AS_VIDEO_CALLS_BOOL);
    mDropVideoCallWhenAnsweringAudioCall = carrierConfig.getBoolean(CarrierConfigManager.KEY_DROP_VIDEO_CALL_WHEN_ANSWERING_AUDIO_CALL_BOOL);
    mAllowAddCallDuringVideoCall = carrierConfig.getBoolean(CarrierConfigManager.KEY_ALLOW_ADD_CALL_DURING_VIDEO_CALL_BOOL);
    mNotifyVtHandoverToWifiFail = carrierConfig.getBoolean(CarrierConfigManager.KEY_NOTIFY_VT_HANDOVER_TO_WIFI_FAILURE_BOOL);
    mSupportDowngradeVtToAudio = carrierConfig.getBoolean(CarrierConfigManager.KEY_SUPPORT_DOWNGRADE_VT_TO_AUDIO_BOOL);
    mNotifyHandoverVideoFromWifiToLTE = carrierConfig.getBoolean(CarrierConfigManager.KEY_NOTIFY_HANDOVER_VIDEO_FROM_WIFI_TO_LTE_BOOL);
    mIgnoreDataEnabledChangedForVideoCalls = carrierConfig.getBoolean(CarrierConfigManager.KEY_IGNORE_DATA_ENABLED_CHANGED_FOR_VIDEO_CALLS);
    mIsViLteDataMetered = carrierConfig.getBoolean(CarrierConfigManager.KEY_VILTE_DATA_IS_METERED_BOOL);
    mSupportPauseVideo = carrierConfig.getBoolean(CarrierConfigManager.KEY_SUPPORT_PAUSE_IMS_VIDEO_CALLS_BOOL);
    mAlwaysPlayRemoteHoldTone = carrierConfig.getBoolean(CarrierConfigManager.KEY_ALWAYS_PLAY_REMOTE_HOLD_TONE_BOOL);
    String[] mappings = carrierConfig.getStringArray(CarrierConfigManager.KEY_IMS_REASONINFO_MAPPING_STRING_ARRAY);
    if (mappings != null && mappings.length > 0) {
        for (String mapping : mappings) {
            String[] values = mapping.split(Pattern.quote("|"));
            if (values.length != 3) {
                continue;
            }
            try {
                Integer fromCode;
                if (values[0].equals("*")) {
                    fromCode = null;
                } else {
                    fromCode = Integer.parseInt(values[0]);
                }
                String message = values[1];
                int toCode = Integer.parseInt(values[2]);
                addReasonCodeRemapping(fromCode, message, toCode);
                log("Loaded ImsReasonInfo mapping : fromCode = " + fromCode == null ? "any" : fromCode + " ; message = " + message + " ; toCode = " + toCode);
            } catch (NumberFormatException nfe) {
                loge("Invalid ImsReasonInfo mapping found: " + mapping);
            }
        }
    } else {
        log("No carrier ImsReasonInfo mappings defined.");
    }
}
#end_block

#method_before
private void dialInternal(ImsPhoneConnection conn, int clirMode, int videoState, Bundle intentExtras) {
    if (conn == null) {
        return;
    }
    if (conn.getAddress() == null || conn.getAddress().length() == 0 || conn.getAddress().indexOf(PhoneNumberUtils.WILD) >= 0) {
        // Phone number is invalid
        conn.setDisconnectCause(DisconnectCause.INVALID_NUMBER);
        sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
        return;
    }
    // Always unmute when initiating a new call
    setMute(false);
    int serviceType = PhoneNumberUtils.isEmergencyNumber(conn.getAddress()) ? ImsCallProfile.SERVICE_TYPE_EMERGENCY : ImsCallProfile.SERVICE_TYPE_NORMAL;
    int callType = ImsCallProfile.getCallTypeFromVideoState(videoState);
    // TODO(vt): Is this sufficient?  At what point do we know the video state of the call?
    conn.setVideoState(videoState);
    try {
        String[] callees = new String[] { conn.getAddress() };
        ImsCallProfile profile = mImsManager.createCallProfile(mServiceId, serviceType, callType);
        profile.setCallExtraInt(ImsCallProfile.EXTRA_OIR, clirMode);
        // ImsCallProfile key.
        if (intentExtras != null) {
            if (intentExtras.containsKey(android.telecom.TelecomManager.EXTRA_CALL_SUBJECT)) {
                intentExtras.putString(ImsCallProfile.EXTRA_DISPLAY_TEXT, cleanseInstantLetteringMessage(intentExtras.getString(android.telecom.TelecomManager.EXTRA_CALL_SUBJECT)));
            }
            if (intentExtras.containsKey(ImsCallProfile.EXTRA_IS_CALL_PULL)) {
                profile.mCallExtras.putBoolean(ImsCallProfile.EXTRA_IS_CALL_PULL, intentExtras.getBoolean(ImsCallProfile.EXTRA_IS_CALL_PULL));
                int dialogId = intentExtras.getInt(ImsExternalCallTracker.EXTRA_IMS_EXTERNAL_CALL_ID);
                conn.setIsPulledCall(true);
                conn.setPulledDialogId(dialogId);
            }
            // Pack the OEM-specific call extras.
            profile.mCallExtras.putBundle(ImsCallProfile.EXTRA_OEM_EXTRAS, intentExtras);
        // NOTE: Extras to be sent over the network are packed into the
        // intentExtras individually, with uniquely defined keys.
        // These key-value pairs are processed by IMS Service before
        // being sent to the lower layers/to the network.
        }
        ImsCall imsCall = mImsManager.makeCall(mServiceId, profile, callees, mImsCallListener);
        conn.setImsCall(imsCall);
        mMetrics.writeOnImsCallStart(mPhone.getPhoneId(), imsCall.getSession());
        setVideoCallProvider(conn, imsCall);
        conn.setAllowAddCallDuringVideoCall(mAllowAddCallDuringVideoCall);
    } catch (ImsException e) {
        loge("dialInternal : " + e);
        conn.setDisconnectCause(DisconnectCause.ERROR_UNSPECIFIED);
        sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
        retryGetImsService();
    } catch (RemoteException e) {
    }
}
#method_after
private void dialInternal(ImsPhoneConnection conn, int clirMode, int videoState, Bundle intentExtras) {
    if (conn == null) {
        return;
    }
    if (conn.getAddress() == null || conn.getAddress().length() == 0 || conn.getAddress().indexOf(PhoneNumberUtils.WILD) >= 0) {
        // Phone number is invalid
        conn.setDisconnectCause(DisconnectCause.INVALID_NUMBER);
        sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
        return;
    }
    // Always unmute when initiating a new call
    setMute(false);
    int serviceType = mPhoneNumberUtilsProxy.isEmergencyNumber(conn.getAddress()) ? ImsCallProfile.SERVICE_TYPE_EMERGENCY : ImsCallProfile.SERVICE_TYPE_NORMAL;
    int callType = ImsCallProfile.getCallTypeFromVideoState(videoState);
    // TODO(vt): Is this sufficient?  At what point do we know the video state of the call?
    conn.setVideoState(videoState);
    try {
        String[] callees = new String[] { conn.getAddress() };
        ImsCallProfile profile = mImsManager.createCallProfile(serviceType, callType);
        profile.setCallExtraInt(ImsCallProfile.EXTRA_OIR, clirMode);
        // ImsCallProfile key.
        if (intentExtras != null) {
            if (intentExtras.containsKey(android.telecom.TelecomManager.EXTRA_CALL_SUBJECT)) {
                intentExtras.putString(ImsCallProfile.EXTRA_DISPLAY_TEXT, cleanseInstantLetteringMessage(intentExtras.getString(android.telecom.TelecomManager.EXTRA_CALL_SUBJECT)));
            }
            if (conn.hasRttTextStream()) {
                profile.mMediaProfile.mRttMode = ImsStreamMediaProfile.RTT_MODE_FULL;
            }
            if (intentExtras.containsKey(ImsCallProfile.EXTRA_IS_CALL_PULL)) {
                profile.mCallExtras.putBoolean(ImsCallProfile.EXTRA_IS_CALL_PULL, intentExtras.getBoolean(ImsCallProfile.EXTRA_IS_CALL_PULL));
                int dialogId = intentExtras.getInt(ImsExternalCallTracker.EXTRA_IMS_EXTERNAL_CALL_ID);
                conn.setIsPulledCall(true);
                conn.setPulledDialogId(dialogId);
            }
            // Pack the OEM-specific call extras.
            profile.mCallExtras.putBundle(ImsCallProfile.EXTRA_OEM_EXTRAS, intentExtras);
        // NOTE: Extras to be sent over the network are packed into the
        // intentExtras individually, with uniquely defined keys.
        // These key-value pairs are processed by IMS Service before
        // being sent to the lower layers/to the network.
        }
        ImsCall imsCall = mImsManager.makeCall(profile, callees, mImsCallListener);
        conn.setImsCall(imsCall);
        mMetrics.writeOnImsCallStart(mPhone.getPhoneId(), imsCall.getSession());
        setVideoCallProvider(conn, imsCall);
        conn.setAllowAddCallDuringVideoCall(mAllowAddCallDuringVideoCall);
    } catch (ImsException e) {
        loge("dialInternal : " + e);
        conn.setDisconnectCause(DisconnectCause.ERROR_UNSPECIFIED);
        sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
        retryGetImsService();
    } catch (RemoteException e) {
    }
}
#end_block

#method_before
public void conference() {
    if (DBG)
        log("conference");
    ImsCall fgImsCall = mForegroundCall.getImsCall();
    if (fgImsCall == null) {
        log("conference no foreground ims call");
        return;
    }
    ImsCall bgImsCall = mBackgroundCall.getImsCall();
    if (bgImsCall == null) {
        log("conference no background ims call");
        return;
    }
    // Keep track of the connect time of the earliest call so that it can be set on the
    // {@code ImsConference} when it is created.
    long foregroundConnectTime = mForegroundCall.getEarliestConnectTime();
    long backgroundConnectTime = mBackgroundCall.getEarliestConnectTime();
    long conferenceConnectTime;
    if (foregroundConnectTime > 0 && backgroundConnectTime > 0) {
        conferenceConnectTime = Math.min(mForegroundCall.getEarliestConnectTime(), mBackgroundCall.getEarliestConnectTime());
        log("conference - using connect time = " + conferenceConnectTime);
    } else if (foregroundConnectTime > 0) {
        log("conference - bg call connect time is 0; using fg = " + foregroundConnectTime);
        conferenceConnectTime = foregroundConnectTime;
    } else {
        log("conference - fg call connect time is 0; using bg = " + backgroundConnectTime);
        conferenceConnectTime = backgroundConnectTime;
    }
    ImsPhoneConnection foregroundConnection = mForegroundCall.getFirstConnection();
    if (foregroundConnection != null) {
        foregroundConnection.setConferenceConnectTime(conferenceConnectTime);
        foregroundConnection.onConnectionEvent(android.telecom.Connection.EVENT_MERGE_START, null);
    }
    ImsPhoneConnection backgroundConnection = findConnection(bgImsCall);
    if (backgroundConnection != null) {
        backgroundConnection.onConnectionEvent(android.telecom.Connection.EVENT_MERGE_START, null);
    }
    try {
        fgImsCall.merge(bgImsCall);
    } catch (ImsException e) {
        log("conference " + e.getMessage());
    }
}
#method_after
public void conference() {
    ImsCall fgImsCall = mForegroundCall.getImsCall();
    if (fgImsCall == null) {
        log("conference no foreground ims call");
        return;
    }
    ImsCall bgImsCall = mBackgroundCall.getImsCall();
    if (bgImsCall == null) {
        log("conference no background ims call");
        return;
    }
    if (fgImsCall.isCallSessionMergePending()) {
        log("conference: skip; foreground call already in process of merging.");
        return;
    }
    if (bgImsCall.isCallSessionMergePending()) {
        log("conference: skip; background call already in process of merging.");
        return;
    }
    // Keep track of the connect time of the earliest call so that it can be set on the
    // {@code ImsConference} when it is created.
    long foregroundConnectTime = mForegroundCall.getEarliestConnectTime();
    long backgroundConnectTime = mBackgroundCall.getEarliestConnectTime();
    long conferenceConnectTime;
    if (foregroundConnectTime > 0 && backgroundConnectTime > 0) {
        conferenceConnectTime = Math.min(mForegroundCall.getEarliestConnectTime(), mBackgroundCall.getEarliestConnectTime());
        log("conference - using connect time = " + conferenceConnectTime);
    } else if (foregroundConnectTime > 0) {
        log("conference - bg call connect time is 0; using fg = " + foregroundConnectTime);
        conferenceConnectTime = foregroundConnectTime;
    } else {
        log("conference - fg call connect time is 0; using bg = " + backgroundConnectTime);
        conferenceConnectTime = backgroundConnectTime;
    }
    String foregroundId = "";
    ImsPhoneConnection foregroundConnection = mForegroundCall.getFirstConnection();
    if (foregroundConnection != null) {
        foregroundConnection.setConferenceConnectTime(conferenceConnectTime);
        foregroundConnection.handleMergeStart();
        foregroundId = foregroundConnection.getTelecomCallId();
    }
    String backgroundId = "";
    ImsPhoneConnection backgroundConnection = findConnection(bgImsCall);
    if (backgroundConnection != null) {
        backgroundConnection.handleMergeStart();
        backgroundId = backgroundConnection.getTelecomCallId();
    }
    log("conference: fgCallId=" + foregroundId + ", bgCallId=" + backgroundId);
    try {
        fgImsCall.merge(bgImsCall);
    } catch (ImsException e) {
        log("conference " + e.getMessage());
    }
}
#end_block

#method_before
public void sendUSSD(String ussdString, Message response) {
    if (DBG)
        log("sendUSSD");
    try {
        if (mUssdSession != null) {
            mUssdSession.sendUssd(ussdString);
            AsyncResult.forMessage(response, null, null);
            response.sendToTarget();
            return;
        }
        if (mImsManager == null) {
            mPhone.sendErrorResponse(response, getImsManagerIsNullException());
            return;
        }
        String[] callees = new String[] { ussdString };
        ImsCallProfile profile = mImsManager.createCallProfile(mServiceId, ImsCallProfile.SERVICE_TYPE_NORMAL, ImsCallProfile.CALL_TYPE_VOICE);
        profile.setCallExtraInt(ImsCallProfile.EXTRA_DIALSTRING, ImsCallProfile.DIALSTRING_USSD);
        mUssdSession = mImsManager.makeCall(mServiceId, profile, callees, mImsUssdListener);
    } catch (ImsException e) {
        loge("sendUSSD : " + e);
        mPhone.sendErrorResponse(response, e);
        retryGetImsService();
    }
}
#method_after
public void sendUSSD(String ussdString, Message response) {
    if (DBG)
        log("sendUSSD");
    try {
        if (mUssdSession != null) {
            mUssdSession.sendUssd(ussdString);
            AsyncResult.forMessage(response, null, null);
            response.sendToTarget();
            return;
        }
        if (mImsManager == null) {
            mPhone.sendErrorResponse(response, getImsManagerIsNullException());
            return;
        }
        String[] callees = new String[] { ussdString };
        ImsCallProfile profile = mImsManager.createCallProfile(ImsCallProfile.SERVICE_TYPE_NORMAL, ImsCallProfile.CALL_TYPE_VOICE);
        profile.setCallExtraInt(ImsCallProfile.EXTRA_DIALSTRING, ImsCallProfile.DIALSTRING_USSD);
        mUssdSession = mImsManager.makeCall(profile, callees, mImsUssdListener);
    } catch (ImsException e) {
        loge("sendUSSD : " + e);
        mPhone.sendErrorResponse(response, e);
        retryGetImsService();
    }
}
#end_block

#method_before
@VisibleForTesting
public int getDisconnectCauseFromReasonInfo(ImsReasonInfo reasonInfo, Call.State callState) {
    int cause = DisconnectCause.ERROR_UNSPECIFIED;
    int code = maybeRemapReasonCode(reasonInfo);
    switch(code) {
        case ImsReasonInfo.CODE_SIP_BAD_ADDRESS:
        case ImsReasonInfo.CODE_SIP_NOT_REACHABLE:
            return DisconnectCause.NUMBER_UNREACHABLE;
        case ImsReasonInfo.CODE_SIP_BUSY:
            return DisconnectCause.BUSY;
        case ImsReasonInfo.CODE_USER_TERMINATED:
            return DisconnectCause.LOCAL;
        case ImsReasonInfo.CODE_LOCAL_ENDED_BY_CONFERENCE_MERGE:
            return DisconnectCause.IMS_MERGED_SUCCESSFULLY;
        case ImsReasonInfo.CODE_LOCAL_CALL_DECLINE:
        case ImsReasonInfo.CODE_REMOTE_CALL_DECLINE:
            // another device using multiendpoint functionality), mark it as rejected.
            return DisconnectCause.INCOMING_REJECTED;
        case ImsReasonInfo.CODE_USER_TERMINATED_BY_REMOTE:
            return DisconnectCause.NORMAL;
        case ImsReasonInfo.CODE_SIP_FORBIDDEN:
            return DisconnectCause.SERVER_ERROR;
        case ImsReasonInfo.CODE_SIP_REDIRECTED:
        case ImsReasonInfo.CODE_SIP_BAD_REQUEST:
        case ImsReasonInfo.CODE_SIP_NOT_ACCEPTABLE:
        case ImsReasonInfo.CODE_SIP_USER_REJECTED:
        case ImsReasonInfo.CODE_SIP_GLOBAL_ERROR:
            return DisconnectCause.SERVER_ERROR;
        case ImsReasonInfo.CODE_SIP_SERVICE_UNAVAILABLE:
        case ImsReasonInfo.CODE_SIP_NOT_FOUND:
        case ImsReasonInfo.CODE_SIP_SERVER_ERROR:
            return DisconnectCause.SERVER_UNREACHABLE;
        case ImsReasonInfo.CODE_LOCAL_NETWORK_ROAMING:
        case ImsReasonInfo.CODE_LOCAL_NETWORK_IP_CHANGED:
        case ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN:
        case ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE:
        case ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED:
        case ImsReasonInfo.CODE_LOCAL_NETWORK_NO_LTE_COVERAGE:
        case ImsReasonInfo.CODE_LOCAL_NETWORK_NO_SERVICE:
        case ImsReasonInfo.CODE_LOCAL_CALL_VCC_ON_PROGRESSING:
            return DisconnectCause.OUT_OF_SERVICE;
        case ImsReasonInfo.CODE_SIP_REQUEST_TIMEOUT:
        case ImsReasonInfo.CODE_TIMEOUT_1XX_WAITING:
        case ImsReasonInfo.CODE_TIMEOUT_NO_ANSWER:
        case ImsReasonInfo.CODE_TIMEOUT_NO_ANSWER_CALL_UPDATE:
            return DisconnectCause.TIMED_OUT;
        case ImsReasonInfo.CODE_LOCAL_POWER_OFF:
            return DisconnectCause.POWER_OFF;
        case ImsReasonInfo.CODE_LOCAL_LOW_BATTERY:
        case ImsReasonInfo.CODE_LOW_BATTERY:
            {
                if (callState == Call.State.DIALING) {
                    return DisconnectCause.DIAL_LOW_BATTERY;
                } else {
                    return DisconnectCause.LOW_BATTERY;
                }
            }
        case ImsReasonInfo.CODE_FDN_BLOCKED:
            return DisconnectCause.FDN_BLOCKED;
        case ImsReasonInfo.CODE_IMEI_NOT_ACCEPTED:
            return DisconnectCause.IMEI_NOT_ACCEPTED;
        case ImsReasonInfo.CODE_ANSWERED_ELSEWHERE:
            return DisconnectCause.ANSWERED_ELSEWHERE;
        case ImsReasonInfo.CODE_CALL_END_CAUSE_CALL_PULL:
            return DisconnectCause.CALL_PULLED;
        case ImsReasonInfo.CODE_MAXIMUM_NUMBER_OF_CALLS_REACHED:
            return DisconnectCause.MAXIMUM_NUMBER_OF_CALLS_REACHED;
        case ImsReasonInfo.CODE_DATA_DISABLED:
            return DisconnectCause.DATA_DISABLED;
        case ImsReasonInfo.CODE_DATA_LIMIT_REACHED:
            return DisconnectCause.DATA_LIMIT_REACHED;
        case ImsReasonInfo.CODE_WIFI_LOST:
            return DisconnectCause.WIFI_LOST;
        case ImsReasonInfo.CODE_ACCESS_CLASS_BLOCKED:
            return DisconnectCause.IMS_ACCESS_BLOCKED;
        case ImsReasonInfo.CODE_EMERGENCY_TEMP_FAILURE:
            return DisconnectCause.EMERGENCY_TEMP_FAILURE;
        case ImsReasonInfo.CODE_EMERGENCY_PERM_FAILURE:
            return DisconnectCause.EMERGENCY_PERM_FAILURE;
        default:
    }
    return cause;
}
#method_after
@VisibleForTesting
public int getDisconnectCauseFromReasonInfo(ImsReasonInfo reasonInfo, Call.State callState) {
    int cause = DisconnectCause.ERROR_UNSPECIFIED;
    int code = maybeRemapReasonCode(reasonInfo);
    switch(code) {
        case ImsReasonInfo.CODE_SIP_ALTERNATE_EMERGENCY_CALL:
            return DisconnectCause.IMS_SIP_ALTERNATE_EMERGENCY_CALL;
        case ImsReasonInfo.CODE_SIP_BAD_ADDRESS:
        case ImsReasonInfo.CODE_SIP_NOT_REACHABLE:
            return DisconnectCause.NUMBER_UNREACHABLE;
        case ImsReasonInfo.CODE_SIP_BUSY:
            return DisconnectCause.BUSY;
        case ImsReasonInfo.CODE_USER_TERMINATED:
            return DisconnectCause.LOCAL;
        case ImsReasonInfo.CODE_LOCAL_ENDED_BY_CONFERENCE_MERGE:
            return DisconnectCause.IMS_MERGED_SUCCESSFULLY;
        case ImsReasonInfo.CODE_LOCAL_CALL_DECLINE:
        case ImsReasonInfo.CODE_REMOTE_CALL_DECLINE:
            // another device using multiendpoint functionality), mark it as rejected.
            return DisconnectCause.INCOMING_REJECTED;
        case ImsReasonInfo.CODE_USER_TERMINATED_BY_REMOTE:
            return DisconnectCause.NORMAL;
        case ImsReasonInfo.CODE_SIP_FORBIDDEN:
            return DisconnectCause.SERVER_ERROR;
        case ImsReasonInfo.CODE_SIP_REDIRECTED:
        case ImsReasonInfo.CODE_SIP_BAD_REQUEST:
        case ImsReasonInfo.CODE_SIP_NOT_ACCEPTABLE:
        case ImsReasonInfo.CODE_SIP_USER_REJECTED:
        case ImsReasonInfo.CODE_SIP_GLOBAL_ERROR:
            return DisconnectCause.SERVER_ERROR;
        case ImsReasonInfo.CODE_SIP_SERVICE_UNAVAILABLE:
        case ImsReasonInfo.CODE_SIP_NOT_FOUND:
        case ImsReasonInfo.CODE_SIP_SERVER_ERROR:
            return DisconnectCause.SERVER_UNREACHABLE;
        case ImsReasonInfo.CODE_LOCAL_NETWORK_ROAMING:
        case ImsReasonInfo.CODE_LOCAL_NETWORK_IP_CHANGED:
        case ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN:
        case ImsReasonInfo.CODE_LOCAL_SERVICE_UNAVAILABLE:
        case ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED:
        case ImsReasonInfo.CODE_LOCAL_NETWORK_NO_LTE_COVERAGE:
        case ImsReasonInfo.CODE_LOCAL_NETWORK_NO_SERVICE:
        case ImsReasonInfo.CODE_LOCAL_CALL_VCC_ON_PROGRESSING:
            return DisconnectCause.OUT_OF_SERVICE;
        case ImsReasonInfo.CODE_SIP_REQUEST_TIMEOUT:
        case ImsReasonInfo.CODE_TIMEOUT_1XX_WAITING:
        case ImsReasonInfo.CODE_TIMEOUT_NO_ANSWER:
        case ImsReasonInfo.CODE_TIMEOUT_NO_ANSWER_CALL_UPDATE:
            return DisconnectCause.TIMED_OUT;
        case ImsReasonInfo.CODE_LOCAL_POWER_OFF:
            return DisconnectCause.POWER_OFF;
        case ImsReasonInfo.CODE_LOCAL_LOW_BATTERY:
        case ImsReasonInfo.CODE_LOW_BATTERY:
            {
                if (callState == Call.State.DIALING) {
                    return DisconnectCause.DIAL_LOW_BATTERY;
                } else {
                    return DisconnectCause.LOW_BATTERY;
                }
            }
        case ImsReasonInfo.CODE_CALL_BARRED:
            return DisconnectCause.CALL_BARRED;
        case ImsReasonInfo.CODE_FDN_BLOCKED:
            return DisconnectCause.FDN_BLOCKED;
        case ImsReasonInfo.CODE_IMEI_NOT_ACCEPTED:
            return DisconnectCause.IMEI_NOT_ACCEPTED;
        case ImsReasonInfo.CODE_ANSWERED_ELSEWHERE:
            return DisconnectCause.ANSWERED_ELSEWHERE;
        case ImsReasonInfo.CODE_CALL_END_CAUSE_CALL_PULL:
            return DisconnectCause.CALL_PULLED;
        case ImsReasonInfo.CODE_MAXIMUM_NUMBER_OF_CALLS_REACHED:
            return DisconnectCause.MAXIMUM_NUMBER_OF_CALLS_REACHED;
        case ImsReasonInfo.CODE_DATA_DISABLED:
            return DisconnectCause.DATA_DISABLED;
        case ImsReasonInfo.CODE_DATA_LIMIT_REACHED:
            return DisconnectCause.DATA_LIMIT_REACHED;
        case ImsReasonInfo.CODE_WIFI_LOST:
            return DisconnectCause.WIFI_LOST;
        case ImsReasonInfo.CODE_ACCESS_CLASS_BLOCKED:
            return DisconnectCause.IMS_ACCESS_BLOCKED;
        case ImsReasonInfo.CODE_EMERGENCY_TEMP_FAILURE:
            return DisconnectCause.EMERGENCY_TEMP_FAILURE;
        case ImsReasonInfo.CODE_EMERGENCY_PERM_FAILURE:
            return DisconnectCause.EMERGENCY_PERM_FAILURE;
        case ImsReasonInfo.CODE_DIAL_MODIFIED_TO_USSD:
            return DisconnectCause.DIAL_MODIFIED_TO_USSD;
        case ImsReasonInfo.CODE_DIAL_MODIFIED_TO_SS:
            return DisconnectCause.DIAL_MODIFIED_TO_SS;
        case ImsReasonInfo.CODE_DIAL_MODIFIED_TO_DIAL:
            return DisconnectCause.DIAL_MODIFIED_TO_DIAL;
        case ImsReasonInfo.CODE_DIAL_MODIFIED_TO_DIAL_VIDEO:
            return DisconnectCause.DIAL_MODIFIED_TO_DIAL_VIDEO;
        case ImsReasonInfo.CODE_DIAL_VIDEO_MODIFIED_TO_DIAL:
            return DisconnectCause.DIAL_VIDEO_MODIFIED_TO_DIAL;
        case ImsReasonInfo.CODE_DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO:
            return DisconnectCause.DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO;
        case ImsReasonInfo.CODE_DIAL_VIDEO_MODIFIED_TO_SS:
            return DisconnectCause.DIAL_VIDEO_MODIFIED_TO_SS;
        case ImsReasonInfo.CODE_DIAL_VIDEO_MODIFIED_TO_USSD:
            return DisconnectCause.DIAL_VIDEO_MODIFIED_TO_USSD;
        case ImsReasonInfo.CODE_UNOBTAINABLE_NUMBER:
            return DisconnectCause.UNOBTAINABLE_NUMBER;
        default:
    }
    return cause;
}
#end_block

#method_before
private boolean isPhoneInEcbMode() {
    return mPhone.isInEcm();
}
#method_after
private boolean isPhoneInEcbMode() {
    return mPhone != null && mPhone.isInEcm();
}
#end_block

#method_before
// ****** Overridden from Handler
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    if (DBG)
        log("handleMessage what=" + msg.what);
    switch(msg.what) {
        case EVENT_HANGUP_PENDINGMO:
            if (mPendingMO != null) {
                mPendingMO.onDisconnect();
                removeConnection(mPendingMO);
                mPendingMO = null;
            }
            mPendingIntentExtras = null;
            updatePhoneState();
            mPhone.notifyPreciseCallStateChanged();
            break;
        case EVENT_RESUME_BACKGROUND:
            try {
                resumeWaitingOrHolding();
            } catch (CallStateException e) {
                if (Phone.DEBUG_PHONE) {
                    loge("handleMessage EVENT_RESUME_BACKGROUND exception=" + e);
                }
            }
            break;
        case EVENT_DIAL_PENDINGMO:
            dialInternal(mPendingMO, mClirMode, mPendingCallVideoState, mPendingIntentExtras);
            mPendingIntentExtras = null;
            break;
        case EVENT_EXIT_ECBM_BEFORE_PENDINGMO:
            if (mPendingMO != null) {
                // Send ECBM exit request
                try {
                    getEcbmInterface().exitEmergencyCallbackMode();
                    mPhone.setOnEcbModeExitResponse(this, EVENT_EXIT_ECM_RESPONSE_CDMA, null);
                    pendingCallClirMode = mClirMode;
                    pendingCallInEcm = true;
                } catch (ImsException e) {
                    e.printStackTrace();
                    mPendingMO.setDisconnectCause(DisconnectCause.ERROR_UNSPECIFIED);
                    sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
                }
            }
            break;
        case EVENT_EXIT_ECM_RESPONSE_CDMA:
            // no matter the result, we still do the same here
            if (pendingCallInEcm) {
                dialInternal(mPendingMO, pendingCallClirMode, mPendingCallVideoState, mPendingIntentExtras);
                mPendingIntentExtras = null;
                pendingCallInEcm = false;
            }
            mPhone.unsetOnEcbModeExitResponse(this);
            break;
        case EVENT_VT_DATA_USAGE_UPDATE:
            ar = (AsyncResult) msg.obj;
            ImsCall call = (ImsCall) ar.userObj;
            Long usage = (long) ar.result;
            log("VT data usage update. usage = " + usage + ", imsCall = " + call);
            if (usage > 0) {
                updateVtDataUsage(call, usage);
            }
            break;
        case EVENT_DATA_ENABLED_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.result instanceof Pair) {
                Pair<Boolean, Integer> p = (Pair<Boolean, Integer>) ar.result;
                onDataEnabledChanged(p.first, p.second);
            }
            break;
        case EVENT_GET_IMS_SERVICE:
            try {
                getImsService();
            } catch (ImsException e) {
                loge("getImsService: " + e);
                retryGetImsService();
            }
            break;
        case EVENT_CHECK_FOR_WIFI_HANDOVER:
            if (msg.obj instanceof ImsCall) {
                ImsCall imsCall = (ImsCall) msg.obj;
                if (!imsCall.isWifiCall()) {
                    // Call did not handover to wifi, notify of handover failure.
                    ImsPhoneConnection conn = findConnection(imsCall);
                    if (conn != null) {
                        conn.onHandoverToWifiFailed();
                    }
                }
            }
            break;
        case EVENT_ON_FEATURE_CAPABILITY_CHANGED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    int serviceClass = args.argi1;
                    int[] enabledFeatures = (int[]) args.arg1;
                    int[] disabledFeatures = (int[]) args.arg2;
                    handleFeatureCapabilityChanged(serviceClass, enabledFeatures, disabledFeatures);
                } finally {
                    args.recycle();
                }
                break;
            }
    }
}
#method_after
// ****** Overridden from Handler
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    if (DBG)
        log("handleMessage what=" + msg.what);
    switch(msg.what) {
        case EVENT_HANGUP_PENDINGMO:
            if (mPendingMO != null) {
                mPendingMO.onDisconnect();
                removeConnection(mPendingMO);
                mPendingMO = null;
            }
            mPendingIntentExtras = null;
            updatePhoneState();
            mPhone.notifyPreciseCallStateChanged();
            break;
        case EVENT_RESUME_BACKGROUND:
            try {
                resumeWaitingOrHolding();
            } catch (CallStateException e) {
                if (Phone.DEBUG_PHONE) {
                    loge("handleMessage EVENT_RESUME_BACKGROUND exception=" + e);
                }
            }
            break;
        case EVENT_DIAL_PENDINGMO:
            dialInternal(mPendingMO, mClirMode, mPendingCallVideoState, mPendingIntentExtras);
            mPendingIntentExtras = null;
            break;
        case EVENT_EXIT_ECBM_BEFORE_PENDINGMO:
            if (mPendingMO != null) {
                // Send ECBM exit request
                try {
                    getEcbmInterface().exitEmergencyCallbackMode();
                    mPhone.setOnEcbModeExitResponse(this, EVENT_EXIT_ECM_RESPONSE_CDMA, null);
                    pendingCallClirMode = mClirMode;
                    pendingCallInEcm = true;
                } catch (ImsException e) {
                    e.printStackTrace();
                    mPendingMO.setDisconnectCause(DisconnectCause.ERROR_UNSPECIFIED);
                    sendEmptyMessageDelayed(EVENT_HANGUP_PENDINGMO, TIMEOUT_HANGUP_PENDINGMO);
                }
            }
            break;
        case EVENT_EXIT_ECM_RESPONSE_CDMA:
            // no matter the result, we still do the same here
            if (pendingCallInEcm) {
                dialInternal(mPendingMO, pendingCallClirMode, mPendingCallVideoState, mPendingIntentExtras);
                mPendingIntentExtras = null;
                pendingCallInEcm = false;
            }
            mPhone.unsetOnEcbModeExitResponse(this);
            break;
        case EVENT_VT_DATA_USAGE_UPDATE:
            ar = (AsyncResult) msg.obj;
            ImsCall call = (ImsCall) ar.userObj;
            Long usage = (long) ar.result;
            log("VT data usage update. usage = " + usage + ", imsCall = " + call);
            if (usage > 0) {
                updateVtDataUsage(call, usage);
            }
            break;
        case EVENT_DATA_ENABLED_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.result instanceof Pair) {
                Pair<Boolean, Integer> p = (Pair<Boolean, Integer>) ar.result;
                onDataEnabledChanged(p.first, p.second);
            }
            break;
        case EVENT_CHECK_FOR_WIFI_HANDOVER:
            if (msg.obj instanceof ImsCall) {
                ImsCall imsCall = (ImsCall) msg.obj;
                if (!imsCall.isWifiCall()) {
                    // Call did not handover to wifi, notify of handover failure.
                    ImsPhoneConnection conn = findConnection(imsCall);
                    if (conn != null) {
                        conn.onHandoverToWifiFailed();
                    }
                }
            }
            break;
        case EVENT_ON_FEATURE_CAPABILITY_CHANGED:
            {
                SomeArgs args = (SomeArgs) msg.obj;
                try {
                    ImsFeature.Capabilities capabilities = (ImsFeature.Capabilities) args.arg1;
                    handleFeatureCapabilityChanged(capabilities);
                } finally {
                    args.recycle();
                }
                break;
            }
        case EVENT_SUPP_SERVICE_INDICATION:
            {
                ar = (AsyncResult) msg.obj;
                ImsPhoneMmiCode mmiCode = new ImsPhoneMmiCode(mPhone);
                try {
                    mmiCode.setIsSsInfo(true);
                    mmiCode.processImsSsData(ar);
                } catch (ImsException e) {
                    Rlog.e(LOG_TAG, "Exception in parsing SS Data: " + e);
                }
                break;
            }
    }
}
#end_block

#method_before
private void updateVtDataUsage(ImsCall call, long dataUsage) {
    long oldUsage = 0L;
    if (mVtDataUsageMap.containsKey(call.uniqueId)) {
        oldUsage = mVtDataUsageMap.get(call.uniqueId);
    }
    long delta = dataUsage - oldUsage;
    mVtDataUsageMap.put(call.uniqueId, dataUsage);
    log("updateVtDataUsage: call=" + call + ", delta=" + delta);
    long currentTime = SystemClock.elapsedRealtime();
    int isRoaming = mPhone.getServiceState().getDataRoaming() ? 1 : 0;
    // Create the snapshot of total video call data usage.
    NetworkStats vtDataUsageSnapshot = new NetworkStats(currentTime, 1);
    vtDataUsageSnapshot.combineAllValues(mVtDataUsageSnapshot);
    // Since the modem only reports the total vt data usage rather than rx/tx separately,
    // the only thing we can do here is splitting the usage into half rx and half tx.
    // Uid -1 indicates this is for the overall device data usage.
    vtDataUsageSnapshot.combineValues(new NetworkStats.Entry(NetworkStatsService.VT_INTERFACE, -1, NetworkStats.SET_FOREGROUND, NetworkStats.TAG_NONE, 1, isRoaming, delta / 2, 0, delta / 2, 0, 0));
    mVtDataUsageSnapshot = vtDataUsageSnapshot;
    // Create the snapshot of video call data usage per dialer. combineValues will create
    // a separate entry if uid is different from the previous snapshot.
    NetworkStats vtDataUsageUidSnapshot = new NetworkStats(currentTime, 1);
    vtDataUsageUidSnapshot.combineAllValues(mVtDataUsageUidSnapshot);
    // default dialer uid is really not available.
    if (mDefaultDialerUid.get() == NetworkStats.UID_ALL) {
        final TelecomManager telecomManager = (TelecomManager) mPhone.getContext().getSystemService(Context.TELECOM_SERVICE);
        mDefaultDialerUid.set(getPackageUid(mPhone.getContext(), telecomManager.getDefaultDialerPackage()));
    }
    // Since the modem only reports the total vt data usage rather than rx/tx separately,
    // the only thing we can do here is splitting the usage into half rx and half tx.
    vtDataUsageUidSnapshot.combineValues(new NetworkStats.Entry(NetworkStatsService.VT_INTERFACE, mDefaultDialerUid.get(), NetworkStats.SET_FOREGROUND, NetworkStats.TAG_NONE, 1, isRoaming, delta / 2, 0, delta / 2, 0, 0));
    mVtDataUsageUidSnapshot = vtDataUsageUidSnapshot;
}
#method_after
private void updateVtDataUsage(ImsCall call, long dataUsage) {
    long oldUsage = 0L;
    if (mVtDataUsageMap.containsKey(call.uniqueId)) {
        oldUsage = mVtDataUsageMap.get(call.uniqueId);
    }
    long delta = dataUsage - oldUsage;
    mVtDataUsageMap.put(call.uniqueId, dataUsage);
    log("updateVtDataUsage: call=" + call + ", delta=" + delta);
    long currentTime = SystemClock.elapsedRealtime();
    int isRoaming = mPhone.getServiceState().getDataRoaming() ? 1 : 0;
    // Create the snapshot of total video call data usage.
    NetworkStats vtDataUsageSnapshot = new NetworkStats(currentTime, 1);
    vtDataUsageSnapshot.combineAllValues(mVtDataUsageSnapshot);
    // Since the modem only reports the total vt data usage rather than rx/tx separately,
    // the only thing we can do here is splitting the usage into half rx and half tx.
    // Uid -1 indicates this is for the overall device data usage.
    vtDataUsageSnapshot.combineValues(new NetworkStats.Entry(NetworkStatsService.VT_INTERFACE, -1, NetworkStats.SET_FOREGROUND, NetworkStats.TAG_NONE, NetworkStats.METERED_YES, isRoaming, NetworkStats.DEFAULT_NETWORK_YES, delta / 2, 0, delta / 2, 0, 0));
    mVtDataUsageSnapshot = vtDataUsageSnapshot;
    // Create the snapshot of video call data usage per dialer. combineValues will create
    // a separate entry if uid is different from the previous snapshot.
    NetworkStats vtDataUsageUidSnapshot = new NetworkStats(currentTime, 1);
    vtDataUsageUidSnapshot.combineAllValues(mVtDataUsageUidSnapshot);
    // default dialer uid is really not available.
    if (mDefaultDialerUid.get() == NetworkStats.UID_ALL) {
        final TelecomManager telecomManager = (TelecomManager) mPhone.getContext().getSystemService(Context.TELECOM_SERVICE);
        mDefaultDialerUid.set(getPackageUid(mPhone.getContext(), telecomManager.getDefaultDialerPackage()));
    }
    // Since the modem only reports the total vt data usage rather than rx/tx separately,
    // the only thing we can do here is splitting the usage into half rx and half tx.
    vtDataUsageUidSnapshot.combineValues(new NetworkStats.Entry(NetworkStatsService.VT_INTERFACE, mDefaultDialerUid.get(), NetworkStats.SET_FOREGROUND, NetworkStats.TAG_NONE, NetworkStats.METERED_YES, isRoaming, NetworkStats.DEFAULT_NETWORK_YES, delta / 2, 0, delta / 2, 0, 0));
    mVtDataUsageUidSnapshot = vtDataUsageUidSnapshot;
}
#end_block

#method_before
@Override
protected void log(String msg) {
    Rlog.d(LOG_TAG, "[ImsPhoneCallTracker] " + msg);
}
#method_after
@Override
protected void log(String msg) {
    Rlog.d(LOG_TAG, "[" + mPhone.getPhoneId() + "] " + msg);
}
#end_block

#method_before
protected void loge(String msg) {
    Rlog.e(LOG_TAG, "[ImsPhoneCallTracker] " + msg);
}
#method_after
protected void loge(String msg) {
    Rlog.e(LOG_TAG, "[" + mPhone.getPhoneId() + "] " + msg);
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ImsPhoneCallTracker extends:");
    super.dump(fd, pw, args);
    pw.println(" mVoiceCallEndedRegistrants=" + mVoiceCallEndedRegistrants);
    pw.println(" mVoiceCallStartedRegistrants=" + mVoiceCallStartedRegistrants);
    pw.println(" mRingingCall=" + mRingingCall);
    pw.println(" mForegroundCall=" + mForegroundCall);
    pw.println(" mBackgroundCall=" + mBackgroundCall);
    pw.println(" mHandoverCall=" + mHandoverCall);
    pw.println(" mPendingMO=" + mPendingMO);
    // pw.println(" mHangupPendingMO=" + mHangupPendingMO);
    pw.println(" mPhone=" + mPhone);
    pw.println(" mDesiredMute=" + mDesiredMute);
    pw.println(" mState=" + mState);
    for (int i = 0; i < mImsFeatureEnabled.length; i++) {
        pw.println(" " + mImsFeatureStrings[i] + ": " + ((mImsFeatureEnabled[i]) ? "enabled" : "disabled"));
    }
    pw.println(" mDefaultDialerUid=" + mDefaultDialerUid.get());
    pw.println(" mVtDataUsageSnapshot=" + mVtDataUsageSnapshot);
    pw.println(" mVtDataUsageUidSnapshot=" + mVtDataUsageUidSnapshot);
    pw.flush();
    pw.println("++++++++++++++++++++++++++++++++");
    try {
        if (mImsManager != null) {
            mImsManager.dump(fd, pw, args);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    if (mConnections != null && mConnections.size() > 0) {
        pw.println("mConnections:");
        for (int i = 0; i < mConnections.size(); i++) {
            pw.println("  [" + i + "]: " + mConnections.get(i));
        }
    }
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ImsPhoneCallTracker extends:");
    super.dump(fd, pw, args);
    pw.println(" mVoiceCallEndedRegistrants=" + mVoiceCallEndedRegistrants);
    pw.println(" mVoiceCallStartedRegistrants=" + mVoiceCallStartedRegistrants);
    pw.println(" mRingingCall=" + mRingingCall);
    pw.println(" mForegroundCall=" + mForegroundCall);
    pw.println(" mBackgroundCall=" + mBackgroundCall);
    pw.println(" mHandoverCall=" + mHandoverCall);
    pw.println(" mPendingMO=" + mPendingMO);
    // pw.println(" mHangupPendingMO=" + mHangupPendingMO);
    pw.println(" mPhone=" + mPhone);
    pw.println(" mDesiredMute=" + mDesiredMute);
    pw.println(" mState=" + mState);
    pw.println(" mMmTelCapabilities=" + mMmTelCapabilities);
    pw.println(" mDefaultDialerUid=" + mDefaultDialerUid.get());
    pw.println(" mVtDataUsageSnapshot=" + mVtDataUsageSnapshot);
    pw.println(" mVtDataUsageUidSnapshot=" + mVtDataUsageUidSnapshot);
    pw.flush();
    pw.println("++++++++++++++++++++++++++++++++");
    try {
        if (mImsManager != null) {
            mImsManager.dump(fd, pw, args);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    if (mConnections != null && mConnections.size() > 0) {
        pw.println("mConnections:");
        for (int i = 0; i < mConnections.size(); i++) {
            pw.println("  [" + i + "]: " + mConnections.get(i));
        }
    }
}
#end_block

#method_before
ImsEcbm getEcbmInterface() throws ImsException {
    if (mImsManager == null) {
        throw getImsManagerIsNullException();
    }
    ImsEcbm ecbm = mImsManager.getEcbmInterface(mServiceId);
    return ecbm;
}
#method_after
ImsEcbm getEcbmInterface() throws ImsException {
    if (mImsManager == null) {
        throw getImsManagerIsNullException();
    }
    ImsEcbm ecbm = mImsManager.getEcbmInterface();
    return ecbm;
}
#end_block

#method_before
ImsMultiEndpoint getMultiEndpointInterface() throws ImsException {
    if (mImsManager == null) {
        throw getImsManagerIsNullException();
    }
    try {
        return mImsManager.getMultiEndpointInterface(mServiceId);
    } catch (ImsException e) {
        if (e.getCode() == ImsReasonInfo.CODE_MULTIENDPOINT_NOT_SUPPORTED) {
            return null;
        } else {
            throw e;
        }
    }
}
#method_after
ImsMultiEndpoint getMultiEndpointInterface() throws ImsException {
    if (mImsManager == null) {
        throw getImsManagerIsNullException();
    }
    try {
        return mImsManager.getMultiEndpointInterface();
    } catch (ImsException e) {
        if (e.getCode() == ImsReasonInfo.CODE_MULTIENDPOINT_NOT_SUPPORTED) {
            return null;
        } else {
            throw e;
        }
    }
}
#end_block

#method_before
public boolean isVolteEnabled() {
    return mImsFeatureEnabled[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE];
}
#method_after
public boolean isVolteEnabled() {
    boolean isRadioTechLte = getImsRegistrationTech() == ImsRegistrationImplBase.REGISTRATION_TECH_LTE;
    return isRadioTechLte && mMmTelCapabilities.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
}
#end_block

#method_before
public boolean isVowifiEnabled() {
    return mImsFeatureEnabled[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI];
}
#method_after
public boolean isVowifiEnabled() {
    boolean isRadioTechIwlan = getImsRegistrationTech() == ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN;
    return isRadioTechIwlan && mMmTelCapabilities.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE);
}
#end_block

#method_before
public boolean isVideoCallEnabled() {
    return (mImsFeatureEnabled[ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE] || mImsFeatureEnabled[ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_WIFI]);
}
#method_after
public boolean isVideoCallEnabled() {
    return mMmTelCapabilities.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VIDEO);
}
#end_block

#method_before
private void retryGetImsService() {
    // The binder connection is already up. Do not try to get it again.
    if (mImsManager.isServiceAvailable()) {
        return;
    }
    // Leave mImsManager as null, then CallStateException will be thrown when dialing
    mImsManager = null;
    // Exponential backoff during retry, limited to 32 seconds.
    loge("getImsService: Retrying getting ImsService...");
    removeMessages(EVENT_GET_IMS_SERVICE);
    sendEmptyMessageDelayed(EVENT_GET_IMS_SERVICE, mRetryTimeout.get());
}
#method_after
private void retryGetImsService() {
    // The binder connection is already up. Do not try to get it again.
    if (mImsManager.isServiceAvailable()) {
        return;
    }
    mImsManagerConnector.connect();
}
#end_block

#method_before
public boolean isUtEnabled() {
    return (mImsFeatureEnabled[ImsConfig.FeatureConstants.FEATURE_TYPE_UT_OVER_LTE] || mImsFeatureEnabled[ImsConfig.FeatureConstants.FEATURE_TYPE_UT_OVER_WIFI]);
}
#method_after
public boolean isUtEnabled() {
    return mMmTelCapabilities.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_UT);
}
#end_block

#method_before
private boolean shouldDisconnectActiveCallOnAnswer(ImsCall activeCall, ImsCall incomingCall) {
    if (activeCall == null || incomingCall == null) {
        return false;
    }
    if (!mDropVideoCallWhenAnsweringAudioCall) {
        return false;
    }
    boolean isActiveCallVideo = activeCall.isVideoCall() || (mTreatDowngradedVideoCallsAsVideoCalls && activeCall.wasVideoCall());
    boolean isActiveCallOnWifi = activeCall.isWifiCall();
    boolean isVoWifiEnabled = mImsManager.isWfcEnabledByPlatform(mPhone.getContext()) && mImsManager.isWfcEnabledByUser(mPhone.getContext());
    boolean isIncomingCallAudio = !incomingCall.isVideoCall();
    log("shouldDisconnectActiveCallOnAnswer : isActiveCallVideo=" + isActiveCallVideo + " isActiveCallOnWifi=" + isActiveCallOnWifi + " isIncomingCallAudio=" + isIncomingCallAudio + " isVowifiEnabled=" + isVoWifiEnabled);
    return isActiveCallVideo && isActiveCallOnWifi && isIncomingCallAudio && !isVoWifiEnabled;
}
#method_after
private boolean shouldDisconnectActiveCallOnAnswer(ImsCall activeCall, ImsCall incomingCall) {
    if (activeCall == null || incomingCall == null) {
        return false;
    }
    if (!mDropVideoCallWhenAnsweringAudioCall) {
        return false;
    }
    boolean isActiveCallVideo = activeCall.isVideoCall() || (mTreatDowngradedVideoCallsAsVideoCalls && activeCall.wasVideoCall());
    boolean isActiveCallOnWifi = activeCall.isWifiCall();
    boolean isVoWifiEnabled = mImsManager.isWfcEnabledByPlatform() && mImsManager.isWfcEnabledByUser();
    boolean isIncomingCallAudio = !incomingCall.isVideoCall();
    log("shouldDisconnectActiveCallOnAnswer : isActiveCallVideo=" + isActiveCallVideo + " isActiveCallOnWifi=" + isActiveCallOnWifi + " isIncomingCallAudio=" + isIncomingCallAudio + " isVowifiEnabled=" + isVoWifiEnabled);
    return isActiveCallVideo && isActiveCallOnWifi && isIncomingCallAudio && !isVoWifiEnabled;
}
#end_block

#method_before
private void onDataEnabledChanged(boolean enabled, int reason) {
    log("onDataEnabledChanged: enabled=" + enabled + ", reason=" + reason);
    ImsManager.getInstance(mPhone.getContext(), mPhone.getPhoneId()).setDataEnabled(enabled);
    mIsDataEnabled = enabled;
    if (!mIsViLteDataMetered) {
        log("Ignore data " + ((enabled) ? "enabled" : "disabled") + " - carrier policy " + "indicates that data is not metered for ViLTE calls.");
        return;
    }
    // if this is an LTE call.
    for (ImsPhoneConnection conn : mConnections) {
        conn.handleDataEnabledChange(enabled);
    }
    int reasonCode;
    if (reason == DataEnabledSettings.REASON_POLICY_DATA_ENABLED) {
        reasonCode = ImsReasonInfo.CODE_DATA_LIMIT_REACHED;
    } else if (reason == DataEnabledSettings.REASON_USER_DATA_ENABLED) {
        reasonCode = ImsReasonInfo.CODE_DATA_DISABLED;
    } else {
        // Unexpected code, default to data disabled.
        reasonCode = ImsReasonInfo.CODE_DATA_DISABLED;
    }
    // Potentially send connection events so the InCall UI knows that video calls are being
    // downgraded due to data being enabled/disabled.
    maybeNotifyDataDisabled(enabled, reasonCode);
    // Handle video state changes required as a result of data being enabled/disabled.
    handleDataEnabledChange(enabled, reasonCode);
    // the carrier config has loaded and will deregister IMS.
    if (!mShouldUpdateImsConfigOnDisconnect && reason != DataEnabledSettings.REASON_REGISTERED) {
        // This will call into updateVideoCallFeatureValue and eventually all clients will be
        // asynchronously notified that the availability of VT over LTE has changed.
        ImsManager.updateImsServiceConfig(mPhone.getContext(), mPhone.getPhoneId(), true);
    }
}
#method_after
private void onDataEnabledChanged(boolean enabled, int reason) {
    log("onDataEnabledChanged: enabled=" + enabled + ", reason=" + reason);
    mIsDataEnabled = enabled;
    if (!mIsViLteDataMetered) {
        log("Ignore data " + ((enabled) ? "enabled" : "disabled") + " - carrier policy " + "indicates that data is not metered for ViLTE calls.");
        return;
    }
    // if this is an LTE call.
    for (ImsPhoneConnection conn : mConnections) {
        conn.handleDataEnabledChange(enabled);
    }
    int reasonCode;
    if (reason == DataEnabledSettings.REASON_POLICY_DATA_ENABLED) {
        reasonCode = ImsReasonInfo.CODE_DATA_LIMIT_REACHED;
    } else if (reason == DataEnabledSettings.REASON_USER_DATA_ENABLED) {
        reasonCode = ImsReasonInfo.CODE_DATA_DISABLED;
    } else {
        // Unexpected code, default to data disabled.
        reasonCode = ImsReasonInfo.CODE_DATA_DISABLED;
    }
    // Potentially send connection events so the InCall UI knows that video calls are being
    // downgraded due to data being enabled/disabled.
    maybeNotifyDataDisabled(enabled, reasonCode);
    // Handle video state changes required as a result of data being enabled/disabled.
    handleDataEnabledChange(enabled, reasonCode);
    // the carrier config has loaded and will deregister IMS.
    if (!mShouldUpdateImsConfigOnDisconnect && reason != DataEnabledSettings.REASON_REGISTERED && mCarrierConfigLoaded) {
        // asynchronously notified that the availability of VT over LTE has changed.
        if (mImsManager != null) {
            mImsManager.updateImsServiceConfig(true);
        }
    }
}
#end_block

#method_before
private void resetImsCapabilities() {
    log("Resetting Capabilities...");
    for (int i = 0; i < mImsFeatureEnabled.length; i++) {
        mImsFeatureEnabled[i] = false;
    }
}
#method_after
private void resetImsCapabilities() {
    log("Resetting Capabilities...");
    mMmTelCapabilities = new MmTelFeature.MmTelCapabilities();
}
#end_block

#method_before
private void handleFeatureCapabilityChanged(int serviceClass, int[] enabledFeatures, int[] disabledFeatures) {
    if (serviceClass == ImsServiceClass.MMTEL) {
        boolean tmpIsVideoCallEnabled = isVideoCallEnabled();
        // Check enabledFeatures to determine capabilities. We ignore disabledFeatures.
        StringBuilder sb;
        if (DBG) {
            sb = new StringBuilder(120);
            sb.append("handleFeatureCapabilityChanged: ");
        }
        for (int i = ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE; i <= ImsConfig.FeatureConstants.FEATURE_TYPE_UT_OVER_WIFI && i < enabledFeatures.length; i++) {
            if (enabledFeatures[i] == i) {
                // If the feature is set to its own integer value it is enabled.
                if (DBG) {
                    sb.append(mImsFeatureStrings[i]);
                    sb.append(":true ");
                }
                mImsFeatureEnabled[i] = true;
            } else if (enabledFeatures[i] == ImsConfig.FeatureConstants.FEATURE_TYPE_UNKNOWN) {
                // FEATURE_TYPE_UNKNOWN indicates that a feature is disabled.
                if (DBG) {
                    sb.append(mImsFeatureStrings[i]);
                    sb.append(":false ");
                }
                mImsFeatureEnabled[i] = false;
            } else {
                // Feature has unknown state; it is not its own value or -1.
                if (DBG) {
                    loge("handleFeatureCapabilityChanged(" + i + ", " + mImsFeatureStrings[i] + "): unexpectedValue=" + enabledFeatures[i]);
                }
            }
        }
        boolean isVideoEnabled = isVideoCallEnabled();
        boolean isVideoEnabledStatechanged = tmpIsVideoCallEnabled != isVideoEnabled;
        if (DBG) {
            sb.append(" isVideoEnabledStateChanged=");
            sb.append(isVideoEnabledStatechanged);
        }
        if (isVideoEnabledStatechanged) {
            log("handleFeatureCapabilityChanged - notifyForVideoCapabilityChanged=" + isVideoEnabled);
            mPhone.notifyForVideoCapabilityChanged(isVideoEnabled);
        }
        if (DBG) {
            log(sb.toString());
        }
        if (DBG)
            log("handleFeatureCapabilityChanged: isVolteEnabled=" + isVolteEnabled() + ", isVideoCallEnabled=" + isVideoCallEnabled() + ", isVowifiEnabled=" + isVowifiEnabled() + ", isUtEnabled=" + isUtEnabled());
        mPhone.onFeatureCapabilityChanged();
        mMetrics.writeOnImsCapabilities(mPhone.getPhoneId(), mImsFeatureEnabled);
    }
}
#method_after
private void handleFeatureCapabilityChanged(ImsFeature.Capabilities capabilities) {
    boolean tmpIsVideoCallEnabled = isVideoCallEnabled();
    // Check enabledFeatures to determine capabilities. We ignore disabledFeatures.
    StringBuilder sb;
    if (DBG) {
        sb = new StringBuilder(120);
        sb.append("handleFeatureCapabilityChanged: ");
    }
    sb.append(capabilities);
    mMmTelCapabilities = new MmTelFeature.MmTelCapabilities(capabilities);
    boolean isVideoEnabled = isVideoCallEnabled();
    boolean isVideoEnabledStatechanged = tmpIsVideoCallEnabled != isVideoEnabled;
    if (DBG) {
        sb.append(" isVideoEnabledStateChanged=");
        sb.append(isVideoEnabledStatechanged);
    }
    if (isVideoEnabledStatechanged) {
        log("handleFeatureCapabilityChanged - notifyForVideoCapabilityChanged=" + isVideoEnabled);
        mPhone.notifyForVideoCapabilityChanged(isVideoEnabled);
    }
    if (DBG)
        log(sb.toString());
    if (DBG) {
        log("handleFeatureCapabilityChanged: isVolteEnabled=" + isVolteEnabled() + ", isVideoCallEnabled=" + isVideoCallEnabled() + ", isVowifiEnabled=" + isVowifiEnabled() + ", isUtEnabled=" + isUtEnabled());
    }
    mPhone.onFeatureCapabilityChanged();
    mMetrics.writeOnImsCapabilities(mPhone.getPhoneId(), getImsRegistrationTech(), mMmTelCapabilities);
}
#end_block

#method_before
public boolean isEmergencySmsSupport(String destAddr) {
    PersistableBundle b;
    boolean eSmsCarrierSupport = false;
    if (!PhoneNumberUtils.isLocalEmergencyNumber(mContext, destAddr)) {
        Rlog.e(TAG, "Emergency Sms is not supported for: " + destAddr);
        return false;
    }
    CarrierConfigManager configManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager == null) {
        Rlog.e(TAG, "configManager is null");
        return false;
    }
    b = configManager.getConfigForSubId(getSubId());
    if (b == null) {
        Rlog.e(TAG, "PersistableBundle is null");
        return false;
    }
    eSmsCarrierSupport = b.getBoolean(CarrierConfigManager.KEY_EMERGENCY_SMS_SUPPORT_BOOL);
    boolean lteOrLimitedLte = isEmergencySmsPossible();
    Rlog.i(TAG, "isEmergencySmsSupport emergencySmsCarrierSupport: " + eSmsCarrierSupport + " destAddr: " + destAddr + " mIsImsServiceUp: " + mIsImsServiceUp + " lteOrLimitedLte: " + lteOrLimitedLte);
    return eSmsCarrierSupport && mIsImsServiceUp && lteOrLimitedLte;
}
#method_after
public boolean isEmergencySmsSupport(String destAddr) {
    PersistableBundle b;
    boolean eSmsCarrierSupport = false;
    if (!PhoneNumberUtils.isLocalEmergencyNumber(mContext, mPhone.getSubId(), destAddr)) {
        Rlog.e(TAG, "Emergency Sms is not supported for: " + destAddr);
        return false;
    }
    CarrierConfigManager configManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager == null) {
        Rlog.e(TAG, "configManager is null");
        return false;
    }
    b = configManager.getConfigForSubId(getSubId());
    if (b == null) {
        Rlog.e(TAG, "PersistableBundle is null");
        return false;
    }
    eSmsCarrierSupport = b.getBoolean(CarrierConfigManager.KEY_SUPPORT_EMERGENCY_SMS_OVER_IMS_BOOL);
    boolean lteOrLimitedLte = isEmergencySmsPossible();
    Rlog.i(TAG, "isEmergencySmsSupport emergencySmsCarrierSupport: " + eSmsCarrierSupport + " destAddr: " + destAddr + " mIsImsServiceUp: " + mIsImsServiceUp + " lteOrLimitedLte: " + lteOrLimitedLte);
    return eSmsCarrierSupport && mIsImsServiceUp && lteOrLimitedLte;
}
#end_block

#method_before
// Verify that NativeAllocations and their referents are freed before we run
private void testNativeAllocation(TestConfig config) {
    if (isNativeBridgedABI()) {
        System.logI("Skipping test for native bridged ABI");
        return;
    }
    Runtime.getRuntime().gc();
    long max = Runtime.getRuntime().maxMemory();
    long total = Runtime.getRuntime().totalMemory();
    int size = 1024 * 1024;
    int expectedMaxNumAllocations = (int) (max - total) / size;
    int numSavedAllocations = expectedMaxNumAllocations / 2;
    Allocation[] saved = new Allocation[numSavedAllocations];
    final int nativeSize = size / 2;
    int javaSize = size / 2;
    NativeAllocationRegistry registry = new NativeAllocationRegistry(classLoader, getNativeFinalizer(), nativeSize);
    // references to should easily fit.
    for (int i = 0; i < expectedMaxNumAllocations * 10; i++) {
        if (!config.shareRegistry) {
            registry = new NativeAllocationRegistry(classLoader, getNativeFinalizer(), nativeSize);
        }
        final Allocation alloc = new Allocation();
        alloc.javaAllocation = new byte[javaSize];
        if (config.useAllocator) {
            NativeAllocationRegistry.Allocator allocator = new NativeAllocationRegistry.Allocator() {

                public long allocate() {
                    alloc.nativeAllocation = doNativeAllocation(nativeSize);
                    return alloc.nativeAllocation;
                }
            };
            registry.registerNativeAllocation(alloc, allocator);
        } else {
            alloc.nativeAllocation = doNativeAllocation(nativeSize);
            registry.registerNativeAllocation(alloc, alloc.nativeAllocation);
        }
        saved[i % numSavedAllocations] = alloc;
    }
    // Verify most of the allocations have been freed.
    long nativeBytes = getNumNativeBytesAllocated();
    assertTrue("Excessive native bytes still allocated (" + nativeBytes + ")" + " given max memory of (" + max + ")", nativeBytes < 2 * max);
}
#method_after
// Verify that NativeAllocations and their referents are freed before we run
private void testNativeAllocation(TestConfig config) {
    if (isNativeBridgedABI()) {
        // 1. This test is intended to test platform internals, not public API.
        // 2. The test would fail under native bridge as a side effect of how the tests work:
        // - The tests run using the app architecture instead of the platform architecture
        // - That scenario will never happen in practice due to (1)
        // 3. This leaves a hole in testing for the case of native bridge, due to limitations
        // in the testing infrastructure from (2).
        System.logI("Skipping test for native bridged ABI");
        return;
    }
    Runtime.getRuntime().gc();
    long max = Runtime.getRuntime().maxMemory();
    long total = Runtime.getRuntime().totalMemory();
    int size = 1024 * 1024;
    int expectedMaxNumAllocations = (int) (max - total) / size;
    int numSavedAllocations = expectedMaxNumAllocations / 2;
    Allocation[] saved = new Allocation[numSavedAllocations];
    final int nativeSize = size / 2;
    int javaSize = size / 2;
    NativeAllocationRegistry registry = new NativeAllocationRegistry(classLoader, getNativeFinalizer(), nativeSize);
    // references to should easily fit.
    for (int i = 0; i < expectedMaxNumAllocations * 10; i++) {
        if (!config.shareRegistry) {
            registry = new NativeAllocationRegistry(classLoader, getNativeFinalizer(), nativeSize);
        }
        final Allocation alloc = new Allocation();
        alloc.javaAllocation = new byte[javaSize];
        if (config.useAllocator) {
            NativeAllocationRegistry.Allocator allocator = new NativeAllocationRegistry.Allocator() {

                public long allocate() {
                    alloc.nativeAllocation = doNativeAllocation(nativeSize);
                    return alloc.nativeAllocation;
                }
            };
            registry.registerNativeAllocation(alloc, allocator);
        } else {
            alloc.nativeAllocation = doNativeAllocation(nativeSize);
            registry.registerNativeAllocation(alloc, alloc.nativeAllocation);
        }
        saved[i % numSavedAllocations] = alloc;
    }
    // Verify most of the allocations have been freed.
    long nativeBytes = getNumNativeBytesAllocated();
    assertTrue("Excessive native bytes still allocated (" + nativeBytes + ")" + " given max memory of (" + max + ")", nativeBytes < 2 * max);
}
#end_block

#method_before
public void testEarlyFree() {
    if (isNativeBridgedABI()) {
        System.logI("Skipping test for native bridged ABI");
        return;
    }
    long size = 1234;
    NativeAllocationRegistry registry = new NativeAllocationRegistry(classLoader, getNativeFinalizer(), size);
    long nativePtr = doNativeAllocation(size);
    Object referent = new Object();
    Runnable cleaner = registry.registerNativeAllocation(referent, nativePtr);
    long numBytesAllocatedBeforeClean = getNumNativeBytesAllocated();
    // Running the cleaner should cause the native finalizer to run.
    cleaner.run();
    long numBytesAllocatedAfterClean = getNumNativeBytesAllocated();
    assertEquals(numBytesAllocatedBeforeClean - size, numBytesAllocatedAfterClean);
    // Running the cleaner again should have no effect.
    cleaner.run();
    assertEquals(numBytesAllocatedAfterClean, getNumNativeBytesAllocated());
    // There shouldn't be any problems when the referent object is GC'd.
    referent = null;
    Runtime.getRuntime().gc();
}
#method_after
public void testEarlyFree() {
    if (isNativeBridgedABI()) {
        // See the explanation in testNativeAllocation.
        System.logI("Skipping test for native bridged ABI");
        return;
    }
    long size = 1234;
    NativeAllocationRegistry registry = new NativeAllocationRegistry(classLoader, getNativeFinalizer(), size);
    long nativePtr = doNativeAllocation(size);
    Object referent = new Object();
    Runnable cleaner = registry.registerNativeAllocation(referent, nativePtr);
    long numBytesAllocatedBeforeClean = getNumNativeBytesAllocated();
    // Running the cleaner should cause the native finalizer to run.
    cleaner.run();
    long numBytesAllocatedAfterClean = getNumNativeBytesAllocated();
    assertEquals(numBytesAllocatedBeforeClean - size, numBytesAllocatedAfterClean);
    // Running the cleaner again should have no effect.
    cleaner.run();
    assertEquals(numBytesAllocatedAfterClean, getNumNativeBytesAllocated());
    // There shouldn't be any problems when the referent object is GC'd.
    referent = null;
    Runtime.getRuntime().gc();
}
#end_block

#method_before
@Override
public boolean updateMessageOnIccEfForSubscriber(int subId, String callingPackage, int index, int status, byte[] pdu) throws android.os.RemoteException {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        return iccSmsIntMgr.updateMessageOnIccEf(callingPackage, index, status, pdu);
    } else {
        Rlog.e(LOG_TAG, "updateMessageOnIccEfForSubscriber iccSmsIntMgr is null" + " for Subscription: " + subId);
        return false;
    }
}
#method_after
@Override
public boolean updateMessageOnIccEfForSubscriber(int subId, String callingPackage, int index, int status, byte[] pdu) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        return iccSmsIntMgr.updateMessageOnIccEf(callingPackage, index, status, pdu);
    } else {
        Rlog.e(LOG_TAG, "updateMessageOnIccEfForSubscriber iccSmsIntMgr is null" + " for Subscription: " + subId);
        return false;
    }
}
#end_block

#method_before
@Override
public boolean copyMessageToIccEfForSubscriber(int subId, String callingPackage, int status, byte[] pdu, byte[] smsc) throws android.os.RemoteException {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        return iccSmsIntMgr.copyMessageToIccEf(callingPackage, status, pdu, smsc);
    } else {
        Rlog.e(LOG_TAG, "copyMessageToIccEfForSubscriber iccSmsIntMgr is null" + " for Subscription: " + subId);
        return false;
    }
}
#method_after
@Override
public boolean copyMessageToIccEfForSubscriber(int subId, String callingPackage, int status, byte[] pdu, byte[] smsc) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        return iccSmsIntMgr.copyMessageToIccEf(callingPackage, status, pdu, smsc);
    } else {
        Rlog.e(LOG_TAG, "copyMessageToIccEfForSubscriber iccSmsIntMgr is null" + " for Subscription: " + subId);
        return false;
    }
}
#end_block

#method_before
@Override
public List<SmsRawData> getAllMessagesFromIccEfForSubscriber(int subId, String callingPackage) throws android.os.RemoteException {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        return iccSmsIntMgr.getAllMessagesFromIccEf(callingPackage);
    } else {
        Rlog.e(LOG_TAG, "getAllMessagesFromIccEfForSubscriber iccSmsIntMgr is" + " null for Subscription: " + subId);
        return null;
    }
}
#method_after
@Override
public List<SmsRawData> getAllMessagesFromIccEfForSubscriber(int subId, String callingPackage) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        return iccSmsIntMgr.getAllMessagesFromIccEf(callingPackage);
    } else {
        Rlog.e(LOG_TAG, "getAllMessagesFromIccEfForSubscriber iccSmsIntMgr is" + " null for Subscription: " + subId);
        return null;
    }
}
#end_block

#method_before
@Override
public void sendDataForSubscriber(int subId, String callingPackage, String destAddr, String scAddr, int destPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) throws android.os.RemoteException {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.sendData(callingPackage, destAddr, scAddr, destPort, data, sentIntent, deliveryIntent);
    } else {
        Rlog.e(LOG_TAG, "sendDataForSubscriber iccSmsIntMgr is null for" + " Subscription: " + subId);
        // TODO: Use a more specific error code to replace RESULT_ERROR_GENERIC_FAILURE.
        sendErrorInPendingIntent(sentIntent, SmsManager.RESULT_ERROR_GENERIC_FAILURE);
    }
}
#method_after
@Override
public void sendDataForSubscriber(int subId, String callingPackage, String destAddr, String scAddr, int destPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.sendData(callingPackage, destAddr, scAddr, destPort, data, sentIntent, deliveryIntent);
    } else {
        Rlog.e(LOG_TAG, "sendDataForSubscriber iccSmsIntMgr is null for" + " Subscription: " + subId);
        // TODO: Use a more specific error code to replace RESULT_ERROR_GENERIC_FAILURE.
        sendErrorInPendingIntent(sentIntent, SmsManager.RESULT_ERROR_GENERIC_FAILURE);
    }
}
#end_block

#method_before
public void sendText(String callingPackage, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent) throws android.os.RemoteException {
    sendTextForSubscriber(getPreferredSmsSubscription(), callingPackage, destAddr, scAddr, text, sentIntent, deliveryIntent, true);
}
#method_after
public void sendText(String callingPackage, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent) {
    sendTextForSubscriber(getPreferredSmsSubscription(), callingPackage, destAddr, scAddr, text, sentIntent, deliveryIntent, true);
}
#end_block

#method_before
@Override
public void sendTextForSubscriber(int subId, String callingPackage, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessageForNonDefaultSmsApp) throws android.os.RemoteException {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.sendText(callingPackage, destAddr, scAddr, text, sentIntent, deliveryIntent, persistMessageForNonDefaultSmsApp);
    } else {
        Rlog.e(LOG_TAG, "sendTextForSubscriber iccSmsIntMgr is null for" + " Subscription: " + subId);
        sendErrorInPendingIntent(sentIntent, SmsManager.RESULT_ERROR_GENERIC_FAILURE);
    }
}
#method_after
@Override
public void sendTextForSubscriber(int subId, String callingPackage, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessageForNonDefaultSmsApp) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.sendText(callingPackage, destAddr, scAddr, text, sentIntent, deliveryIntent, persistMessageForNonDefaultSmsApp);
    } else {
        Rlog.e(LOG_TAG, "sendTextForSubscriber iccSmsIntMgr is null for" + " Subscription: " + subId);
        sendErrorInPendingIntent(sentIntent, SmsManager.RESULT_ERROR_GENERIC_FAILURE);
    }
}
#end_block

#method_before
@Override
public void sendTextForSubscriberWithOptions(int subId, String callingPackage, String destAddr, String scAddr, String parts, PendingIntent sentIntents, PendingIntent deliveryIntents, boolean persistMessage, int priority, boolean expectMore, int validityPeriod) throws android.os.RemoteException {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.sendTextWithOptions(callingPackage, destAddr, scAddr, parts, sentIntents, deliveryIntents, persistMessage, priority, expectMore, validityPeriod);
    } else {
        Rlog.e(LOG_TAG, "sendTextWithOptions iccSmsIntMgr is null for" + " Subscription: " + subId);
    }
}
#method_after
@Override
public void sendTextForSubscriberWithOptions(int subId, String callingPackage, String destAddr, String scAddr, String parts, PendingIntent sentIntents, PendingIntent deliveryIntents, boolean persistMessage, int priority, boolean expectMore, int validityPeriod) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.sendTextWithOptions(callingPackage, destAddr, scAddr, parts, sentIntents, deliveryIntents, persistMessage, priority, expectMore, validityPeriod);
    } else {
        Rlog.e(LOG_TAG, "sendTextWithOptions iccSmsIntMgr is null for" + " Subscription: " + subId);
    }
}
#end_block

#method_before
public void sendMultipartText(String callingPackage, String destAddr, String scAddr, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents) throws android.os.RemoteException {
    sendMultipartTextForSubscriber(getPreferredSmsSubscription(), callingPackage, destAddr, scAddr, parts, sentIntents, deliveryIntents, true);
}
#method_after
public void sendMultipartText(String callingPackage, String destAddr, String scAddr, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents) {
    sendMultipartTextForSubscriber(getPreferredSmsSubscription(), callingPackage, destAddr, scAddr, parts, sentIntents, deliveryIntents, true);
}
#end_block

#method_before
@Override
public void sendMultipartTextForSubscriber(int subId, String callingPackage, String destAddr, String scAddr, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessageForNonDefaultSmsApp) throws android.os.RemoteException {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.sendMultipartText(callingPackage, destAddr, scAddr, parts, sentIntents, deliveryIntents, persistMessageForNonDefaultSmsApp);
    } else {
        Rlog.e(LOG_TAG, "sendMultipartTextForSubscriber iccSmsIntMgr is null for" + " Subscription: " + subId);
        sendErrorInPendingIntents(sentIntents, SmsManager.RESULT_ERROR_GENERIC_FAILURE);
    }
}
#method_after
@Override
public void sendMultipartTextForSubscriber(int subId, String callingPackage, String destAddr, String scAddr, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessageForNonDefaultSmsApp) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.sendMultipartText(callingPackage, destAddr, scAddr, parts, sentIntents, deliveryIntents, persistMessageForNonDefaultSmsApp);
    } else {
        Rlog.e(LOG_TAG, "sendMultipartTextForSubscriber iccSmsIntMgr is null for" + " Subscription: " + subId);
        sendErrorInPendingIntents(sentIntents, SmsManager.RESULT_ERROR_GENERIC_FAILURE);
    }
}
#end_block

#method_before
@Override
public void sendMultipartTextForSubscriberWithOptions(int subId, String callingPackage, String destAddr, String scAddr, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessage, int priority, boolean expectMore, int validityPeriod) throws android.os.RemoteException {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.sendMultipartTextWithOptions(callingPackage, destAddr, scAddr, parts, sentIntents, deliveryIntents, persistMessage, priority, expectMore, validityPeriod);
    } else {
        Rlog.e(LOG_TAG, "sendMultipartTextWithOptions iccSmsIntMgr is null for" + " Subscription: " + subId);
    }
}
#method_after
@Override
public void sendMultipartTextForSubscriberWithOptions(int subId, String callingPackage, String destAddr, String scAddr, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessage, int priority, boolean expectMore, int validityPeriod) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.sendMultipartTextWithOptions(callingPackage, destAddr, scAddr, parts, sentIntents, deliveryIntents, persistMessage, priority, expectMore, validityPeriod);
    } else {
        Rlog.e(LOG_TAG, "sendMultipartTextWithOptions iccSmsIntMgr is null for" + " Subscription: " + subId);
    }
}
#end_block

#method_before
@Override
public boolean enableCellBroadcastForSubscriber(int subId, int messageIdentifier, int ranType) throws android.os.RemoteException {
    return enableCellBroadcastRangeForSubscriber(subId, messageIdentifier, messageIdentifier, ranType);
}
#method_after
@Override
public boolean enableCellBroadcastForSubscriber(int subId, int messageIdentifier, int ranType) {
    return enableCellBroadcastRangeForSubscriber(subId, messageIdentifier, messageIdentifier, ranType);
}
#end_block

#method_before
@Override
public boolean enableCellBroadcastRangeForSubscriber(int subId, int startMessageId, int endMessageId, int ranType) throws android.os.RemoteException {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        return iccSmsIntMgr.enableCellBroadcastRange(startMessageId, endMessageId, ranType);
    } else {
        Rlog.e(LOG_TAG, "enableCellBroadcastRangeForSubscriber iccSmsIntMgr is null for" + " Subscription: " + subId);
    }
    return false;
}
#method_after
@Override
public boolean enableCellBroadcastRangeForSubscriber(int subId, int startMessageId, int endMessageId, int ranType) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        return iccSmsIntMgr.enableCellBroadcastRange(startMessageId, endMessageId, ranType);
    } else {
        Rlog.e(LOG_TAG, "enableCellBroadcastRangeForSubscriber iccSmsIntMgr is null for" + " Subscription: " + subId);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean disableCellBroadcastForSubscriber(int subId, int messageIdentifier, int ranType) throws android.os.RemoteException {
    return disableCellBroadcastRangeForSubscriber(subId, messageIdentifier, messageIdentifier, ranType);
}
#method_after
@Override
public boolean disableCellBroadcastForSubscriber(int subId, int messageIdentifier, int ranType) {
    return disableCellBroadcastRangeForSubscriber(subId, messageIdentifier, messageIdentifier, ranType);
}
#end_block

#method_before
@Override
public boolean disableCellBroadcastRangeForSubscriber(int subId, int startMessageId, int endMessageId, int ranType) throws android.os.RemoteException {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        return iccSmsIntMgr.disableCellBroadcastRange(startMessageId, endMessageId, ranType);
    } else {
        Rlog.e(LOG_TAG, "disableCellBroadcastRangeForSubscriber iccSmsIntMgr is null for" + " Subscription:" + subId);
    }
    return false;
}
#method_after
@Override
public boolean disableCellBroadcastRangeForSubscriber(int subId, int startMessageId, int endMessageId, int ranType) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        return iccSmsIntMgr.disableCellBroadcastRange(startMessageId, endMessageId, ranType);
    } else {
        Rlog.e(LOG_TAG, "disableCellBroadcastRangeForSubscriber iccSmsIntMgr is null for" + " Subscription:" + subId);
    }
    return false;
}
#end_block

#method_before
@Override
public int getPremiumSmsPermission(String packageName) throws android.os.RemoteException {
    return getPremiumSmsPermissionForSubscriber(getPreferredSmsSubscription(), packageName);
}
#method_after
@Override
public int getPremiumSmsPermission(String packageName) {
    return getPremiumSmsPermissionForSubscriber(getPreferredSmsSubscription(), packageName);
}
#end_block

#method_before
@Override
public int getPremiumSmsPermissionForSubscriber(int subId, String packageName) throws android.os.RemoteException {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        return iccSmsIntMgr.getPremiumSmsPermission(packageName);
    } else {
        Rlog.e(LOG_TAG, "getPremiumSmsPermissionForSubscriber iccSmsIntMgr is null");
    }
    // TODO Rakesh
    return 0;
}
#method_after
@Override
public int getPremiumSmsPermissionForSubscriber(int subId, String packageName) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        return iccSmsIntMgr.getPremiumSmsPermission(packageName);
    } else {
        Rlog.e(LOG_TAG, "getPremiumSmsPermissionForSubscriber iccSmsIntMgr is null");
    }
    // TODO Rakesh
    return 0;
}
#end_block

#method_before
@Override
public void setPremiumSmsPermission(String packageName, int permission) throws android.os.RemoteException {
    setPremiumSmsPermissionForSubscriber(getPreferredSmsSubscription(), packageName, permission);
}
#method_after
@Override
public void setPremiumSmsPermission(String packageName, int permission) {
    setPremiumSmsPermissionForSubscriber(getPreferredSmsSubscription(), packageName, permission);
}
#end_block

#method_before
@Override
public void setPremiumSmsPermissionForSubscriber(int subId, String packageName, int permission) throws android.os.RemoteException {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.setPremiumSmsPermission(packageName, permission);
    } else {
        Rlog.e(LOG_TAG, "setPremiumSmsPermissionForSubscriber iccSmsIntMgr is null");
    }
}
#method_after
@Override
public void setPremiumSmsPermissionForSubscriber(int subId, String packageName, int permission) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.setPremiumSmsPermission(packageName, permission);
    } else {
        Rlog.e(LOG_TAG, "setPremiumSmsPermissionForSubscriber iccSmsIntMgr is null");
    }
}
#end_block

#method_before
@Override
public boolean isImsSmsSupportedForSubscriber(int subId) throws android.os.RemoteException {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        return iccSmsIntMgr.isImsSmsSupported();
    } else {
        Rlog.e(LOG_TAG, "isImsSmsSupportedForSubscriber iccSmsIntMgr is null");
    }
    return false;
}
#method_after
@Override
public boolean isImsSmsSupportedForSubscriber(int subId) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        return iccSmsIntMgr.isImsSmsSupported();
    } else {
        Rlog.e(LOG_TAG, "isImsSmsSupportedForSubscriber iccSmsIntMgr is null");
    }
    return false;
}
#end_block

#method_before
@Override
public boolean isSmsSimPickActivityNeeded(int subId) throws android.os.RemoteException {
    final Context context = ActivityThread.currentApplication().getApplicationContext();
    TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
    List<SubscriptionInfo> subInfoList;
    final long identity = Binder.clearCallingIdentity();
    try {
        subInfoList = SubscriptionManager.from(context).getActiveSubscriptionInfoList();
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
    if (subInfoList != null) {
        final int subInfoLength = subInfoList.size();
        for (int i = 0; i < subInfoLength; ++i) {
            final SubscriptionInfo sir = subInfoList.get(i);
            if (sir != null && sir.getSubscriptionId() == subId) {
                // The subscription id is valid, sms sim pick activity not needed
                return false;
            }
        }
        // If reached here and multiple SIMs and subs present, sms sim pick activity is needed
        if (subInfoLength > 0 && telephonyManager.getSimCount() > 1) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean isSmsSimPickActivityNeeded(int subId) {
    final Context context = ActivityThread.currentApplication().getApplicationContext();
    TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
    List<SubscriptionInfo> subInfoList;
    final long identity = Binder.clearCallingIdentity();
    try {
        subInfoList = SubscriptionManager.from(context).getActiveSubscriptionInfoList();
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
    if (subInfoList != null) {
        final int subInfoLength = subInfoList.size();
        for (int i = 0; i < subInfoLength; ++i) {
            final SubscriptionInfo sir = subInfoList.get(i);
            if (sir != null && sir.getSubscriptionId() == subId) {
                // The subscription id is valid, sms sim pick activity not needed
                return false;
            }
        }
        // If reached here and multiple SIMs and subs present, sms sim pick activity is needed
        if (subInfoLength > 0 && telephonyManager.getSimCount() > 1) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public String getImsSmsFormatForSubscriber(int subId) throws android.os.RemoteException {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        return iccSmsIntMgr.getImsSmsFormat();
    } else {
        Rlog.e(LOG_TAG, "getImsSmsFormatForSubscriber iccSmsIntMgr is null");
    }
    return null;
}
#method_after
@Override
public String getImsSmsFormatForSubscriber(int subId) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        return iccSmsIntMgr.getImsSmsFormat();
    } else {
        Rlog.e(LOG_TAG, "getImsSmsFormatForSubscriber iccSmsIntMgr is null");
    }
    return null;
}
#end_block

#method_before
@Override
public void injectSmsPduForSubscriber(int subId, byte[] pdu, String format, PendingIntent receivedIntent) throws android.os.RemoteException {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.injectSmsPdu(pdu, format, receivedIntent);
    } else {
        Rlog.e(LOG_TAG, "injectSmsPduForSubscriber iccSmsIntMgr is null");
        // RESULT_SMS_GENERIC_ERROR is documented for injectSmsPdu
        sendErrorInPendingIntent(receivedIntent, Intents.RESULT_SMS_GENERIC_ERROR);
    }
}
#method_after
@Override
public void injectSmsPduForSubscriber(int subId, byte[] pdu, String format, PendingIntent receivedIntent) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.injectSmsPdu(pdu, format, receivedIntent);
    } else {
        Rlog.e(LOG_TAG, "injectSmsPduForSubscriber iccSmsIntMgr is null");
        // RESULT_SMS_GENERIC_ERROR is documented for injectSmsPdu
        sendErrorInPendingIntent(receivedIntent, Intents.RESULT_SMS_GENERIC_ERROR);
    }
}
#end_block

#method_before
@Override
public int getPreferredSmsSubscription() throws android.os.RemoteException {
    return SubscriptionController.getInstance().getDefaultSmsSubId();
}
#method_after
@Override
public int getPreferredSmsSubscription() {
    return SubscriptionController.getInstance().getDefaultSmsSubId();
}
#end_block

#method_before
@Override
public boolean isSMSPromptEnabled() throws android.os.RemoteException {
    return PhoneFactory.isSMSPromptEnabled();
}
#method_after
@Override
public boolean isSMSPromptEnabled() {
    return PhoneFactory.isSMSPromptEnabled();
}
#end_block

#method_before
@Override
public void sendStoredText(int subId, String callingPkg, Uri messageUri, String scAddress, PendingIntent sentIntent, PendingIntent deliveryIntent) throws RemoteException {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.sendStoredText(callingPkg, messageUri, scAddress, sentIntent, deliveryIntent);
    } else {
        Rlog.e(LOG_TAG, "sendStoredText iccSmsIntMgr is null for subscription: " + subId);
        sendErrorInPendingIntent(sentIntent, SmsManager.RESULT_ERROR_GENERIC_FAILURE);
    }
}
#method_after
@Override
public void sendStoredText(int subId, String callingPkg, Uri messageUri, String scAddress, PendingIntent sentIntent, PendingIntent deliveryIntent) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.sendStoredText(callingPkg, messageUri, scAddress, sentIntent, deliveryIntent);
    } else {
        Rlog.e(LOG_TAG, "sendStoredText iccSmsIntMgr is null for subscription: " + subId);
        sendErrorInPendingIntent(sentIntent, SmsManager.RESULT_ERROR_GENERIC_FAILURE);
    }
}
#end_block

#method_before
@Override
public void sendStoredMultipartText(int subId, String callingPkg, Uri messageUri, String scAddress, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents) throws RemoteException {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.sendStoredMultipartText(callingPkg, messageUri, scAddress, sentIntents, deliveryIntents);
    } else {
        Rlog.e(LOG_TAG, "sendStoredMultipartText iccSmsIntMgr is null for subscription: " + subId);
        sendErrorInPendingIntents(sentIntents, SmsManager.RESULT_ERROR_GENERIC_FAILURE);
    }
}
#method_after
@Override
public void sendStoredMultipartText(int subId, String callingPkg, Uri messageUri, String scAddress, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents) {
    IccSmsInterfaceManager iccSmsIntMgr = getIccSmsInterfaceManager(subId);
    if (iccSmsIntMgr != null) {
        iccSmsIntMgr.sendStoredMultipartText(callingPkg, messageUri, scAddress, sentIntents, deliveryIntents);
    } else {
        Rlog.e(LOG_TAG, "sendStoredMultipartText iccSmsIntMgr is null for subscription: " + subId);
        sendErrorInPendingIntents(sentIntents, SmsManager.RESULT_ERROR_GENERIC_FAILURE);
    }
}
#end_block

#method_before
@Override
public String createAppSpecificSmsToken(int subId, String callingPkg, PendingIntent intent) throws android.os.RemoteException {
    return getPhone(subId).getAppSmsManager().createAppSpecificSmsToken(callingPkg, intent);
}
#method_after
@Override
public String createAppSpecificSmsToken(int subId, String callingPkg, PendingIntent intent) {
    return getPhone(subId).getAppSmsManager().createAppSpecificSmsToken(callingPkg, intent);
}
#end_block

#method_before
@Override
public List<SmsRawData> getAllMessagesFromIccEfForSubscriber(int subId, String callingPkg) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public List<SmsRawData> getAllMessagesFromIccEfForSubscriber(int subId, String callingPkg) {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public boolean updateMessageOnIccEfForSubscriber(int subId, String callingPkg, int messageIndex, int newStatus, byte[] pdu) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public boolean updateMessageOnIccEfForSubscriber(int subId, String callingPkg, int messageIndex, int newStatus, byte[] pdu) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public boolean copyMessageToIccEfForSubscriber(int subId, String callingPkg, int status, byte[] pdu, byte[] smsc) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public boolean copyMessageToIccEfForSubscriber(int subId, String callingPkg, int status, byte[] pdu, byte[] smsc) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public void sendDataForSubscriber(int subId, String callingPkg, String destAddr, String scAddr, int destPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public void sendDataForSubscriber(int subId, String callingPkg, String destAddr, String scAddr, int destPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public void sendDataForSubscriberWithSelfPermissions(int subId, String callingPkg, String destAddr, String scAddr, int destPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public void sendDataForSubscriberWithSelfPermissions(int subId, String callingPkg, String destAddr, String scAddr, int destPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public void sendTextForSubscriber(int subId, String callingPkg, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessageForNonDefaultSmsApp) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public void sendTextForSubscriber(int subId, String callingPkg, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessageForNonDefaultSmsApp) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public void sendTextForSubscriberWithSelfPermissions(int subId, String callingPkg, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessage) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public void sendTextForSubscriberWithSelfPermissions(int subId, String callingPkg, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessage) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public void sendTextForSubscriberWithOptions(int subId, String callingPkg, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessageForNonDefaultSmsApp, int priority, boolean expectMore, int validityPeriod) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public void sendTextForSubscriberWithOptions(int subId, String callingPkg, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessageForNonDefaultSmsApp, int priority, boolean expectMore, int validityPeriod) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public void injectSmsPduForSubscriber(int subId, byte[] pdu, String format, PendingIntent receivedIntent) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public void injectSmsPduForSubscriber(int subId, byte[] pdu, String format, PendingIntent receivedIntent) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public void sendMultipartTextForSubscriber(int subId, String callingPkg, String destinationAddress, String scAddress, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessageForNonDefaultSmsApp) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public void sendMultipartTextForSubscriber(int subId, String callingPkg, String destinationAddress, String scAddress, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessageForNonDefaultSmsApp) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public void sendMultipartTextForSubscriberWithOptions(int subId, String callingPkg, String destinationAddress, String scAddress, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessageForNonDefaultSmsApp, int priority, boolean expectMore, int validityPeriod) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public void sendMultipartTextForSubscriberWithOptions(int subId, String callingPkg, String destinationAddress, String scAddress, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessageForNonDefaultSmsApp, int priority, boolean expectMore, int validityPeriod) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public boolean enableCellBroadcastForSubscriber(int subId, int messageIdentifier, int ranType) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public boolean enableCellBroadcastForSubscriber(int subId, int messageIdentifier, int ranType) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public boolean disableCellBroadcastForSubscriber(int subId, int messageIdentifier, int ranType) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public boolean disableCellBroadcastForSubscriber(int subId, int messageIdentifier, int ranType) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public boolean enableCellBroadcastRangeForSubscriber(int subId, int startMessageId, int endMessageId, int ranType) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public boolean enableCellBroadcastRangeForSubscriber(int subId, int startMessageId, int endMessageId, int ranType) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public boolean disableCellBroadcastRangeForSubscriber(int subId, int startMessageId, int endMessageId, int ranType) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public boolean disableCellBroadcastRangeForSubscriber(int subId, int startMessageId, int endMessageId, int ranType) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public int getPremiumSmsPermission(String packageName) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public int getPremiumSmsPermission(String packageName) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public int getPremiumSmsPermissionForSubscriber(int subId, String packageName) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public int getPremiumSmsPermissionForSubscriber(int subId, String packageName) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public void setPremiumSmsPermission(String packageName, int permission) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public void setPremiumSmsPermission(String packageName, int permission) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public void setPremiumSmsPermissionForSubscriber(int subId, String packageName, int permission) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public void setPremiumSmsPermissionForSubscriber(int subId, String packageName, int permission) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public boolean isImsSmsSupportedForSubscriber(int subId) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public boolean isImsSmsSupportedForSubscriber(int subId) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public boolean isSmsSimPickActivityNeeded(int subId) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public boolean isSmsSimPickActivityNeeded(int subId) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public int getPreferredSmsSubscription() throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public int getPreferredSmsSubscription() throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public String getImsSmsFormatForSubscriber(int subId) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public String getImsSmsFormatForSubscriber(int subId) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public boolean isSMSPromptEnabled() throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public boolean isSMSPromptEnabled() throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public void sendStoredText(int subId, String callingPkg, Uri messageUri, String scAddress, PendingIntent sentIntent, PendingIntent deliveryIntent) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public void sendStoredText(int subId, String callingPkg, Uri messageUri, String scAddress, PendingIntent sentIntent, PendingIntent deliveryIntent) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public void sendStoredMultipartText(int subId, String callingPkg, Uri messageUri, String scAddress, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public void sendStoredMultipartText(int subId, String callingPkg, Uri messageUri, String scAddress, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public String createAppSpecificSmsToken(int subId, String callingPkg, PendingIntent intent) throws android.os.RemoteException {
    throw new RemoteException();
}
#method_after
@Override
public String createAppSpecificSmsToken(int subId, String callingPkg, PendingIntent intent) throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
public String[] split(CharSequence input, int limit) {
    // BEGIN Android-added: fastSplit() to speed up simple cases.
    String[] fast = fastSplit(pattern, input.toString(), limit);
    if (fast != null) {
        return fast;
    }
    // END Android-added: fastSplit() to speed up simple cases.
    int index = 0;
    boolean matchLimited = limit > 0;
    ArrayList<String> matchList = new ArrayList<>();
    Matcher m = matcher(input);
    // Add segments before each match found
    while (m.find()) {
        if (!matchLimited || matchList.size() < limit - 1) {
            if (index == 0 && index == m.start() && m.start() == m.end()) {
                // at the beginning of the input char sequence.
                continue;
            }
            String match = input.subSequence(index, m.start()).toString();
            matchList.add(match);
            index = m.end();
        } else if (matchList.size() == limit - 1) {
            // last one
            String match = input.subSequence(index, input.length()).toString();
            matchList.add(match);
            index = m.end();
        }
    }
    // If no match was found, return this
    if (index == 0)
        return new String[] { input.toString() };
    // Add remaining segment
    if (!matchLimited || matchList.size() < limit)
        matchList.add(input.subSequence(index, input.length()).toString());
    // Construct result
    int resultSize = matchList.size();
    if (limit == 0)
        while (resultSize > 0 && matchList.get(resultSize - 1).equals("")) resultSize--;
    String[] result = new String[resultSize];
    return matchList.subList(0, resultSize).toArray(result);
}
#method_after
// Android-change: Adopt split() behavior change only for apps targeting API > 28.
// http://b/109659282#comment7
public String[] split(CharSequence input, int limit) {
    // BEGIN Android-added: fastSplit() to speed up simple cases.
    String[] fast = fastSplit(pattern, input.toString(), limit);
    if (fast != null) {
        return fast;
    }
    // END Android-added: fastSplit() to speed up simple cases.
    int index = 0;
    boolean matchLimited = limit > 0;
    ArrayList<String> matchList = new ArrayList<>();
    Matcher m = matcher(input);
    // Add segments before each match found
    while (m.find()) {
        if (!matchLimited || matchList.size() < limit - 1) {
            if (index == 0 && index == m.start() && m.start() == m.end()) {
                // no empty leading substring included for zero-width match
                // at the beginning of the input char sequence.
                // BEGIN Android-changed: split() compat behavior for apps targeting <= 28.
                // continue;
                int targetSdkVersion = VMRuntime.getRuntime().getTargetSdkVersion();
                if (targetSdkVersion > 28) {
                    continue;
                }
            // END Android-changed: split() compat behavior for apps targeting <= 28.
            }
            String match = input.subSequence(index, m.start()).toString();
            matchList.add(match);
            index = m.end();
        } else if (matchList.size() == limit - 1) {
            // last one
            String match = input.subSequence(index, input.length()).toString();
            matchList.add(match);
            index = m.end();
        }
    }
    // If no match was found, return this
    if (index == 0)
        return new String[] { input.toString() };
    // Add remaining segment
    if (!matchLimited || matchList.size() < limit)
        matchList.add(input.subSequence(index, input.length()).toString());
    // Construct result
    int resultSize = matchList.size();
    if (limit == 0)
        while (resultSize > 0 && matchList.get(resultSize - 1).equals("")) resultSize--;
    String[] result = new String[resultSize];
    return matchList.subList(0, resultSize).toArray(result);
}
#end_block

#method_before
public List<DefaultApkSignerEngine.SignerConfig> sortSignerConfigs(List<DefaultApkSignerEngine.SignerConfig> signerConfigs) {
    if (signerConfigs == null) {
        throw new NullPointerException("signerConfigs == null");
    }
    // not the most elegant sort, but we expect signerConfigs to be quite small (1 or 2 signers
    // in most cases) and likely already sorted, so not worth the overhead of doing anything
    // fancier
    List<DefaultApkSignerEngine.SignerConfig> sortedSignerConfigs = new ArrayList<>(signerConfigs.size());
    for (int i = 0; i < mSigningLineage.size(); i++) {
        for (int j = 0; j < signerConfigs.size(); j++) {
            DefaultApkSignerEngine.SignerConfig config = signerConfigs.get(j);
            if (mSigningLineage.get(i).signingCert.equals(config.getCertificates().get(0))) {
                sortedSignerConfigs.add(config);
                break;
            }
        }
    }
    if (sortedSignerConfigs.size() != signerConfigs.size()) {
        throw new IllegalArgumentException("SignerConfigs supplied which are not present in the" + " SigningCertificateLineage");
    }
    return sortedSignerConfigs;
}
#method_after
public List<DefaultApkSignerEngine.SignerConfig> sortSignerConfigs(List<DefaultApkSignerEngine.SignerConfig> signerConfigs) {
    if (signerConfigs == null) {
        throw new NullPointerException("signerConfigs == null");
    }
    // not the most elegant sort, but we expect signerConfigs to be quite small (1 or 2 signers
    // in most cases) and likely already sorted, so not worth the overhead of doing anything
    // fancier
    List<DefaultApkSignerEngine.SignerConfig> sortedSignerConfigs = new ArrayList<>(signerConfigs.size());
    for (int i = 0; i < mSigningLineage.size(); i++) {
        for (int j = 0; j < signerConfigs.size(); j++) {
            DefaultApkSignerEngine.SignerConfig config = signerConfigs.get(j);
            try {
                if (Arrays.equals(mSigningLineage.get(i).signingCert.getEncoded(), config.getCertificates().get(0).getEncoded())) {
                    sortedSignerConfigs.add(config);
                    break;
                }
            } catch (CertificateEncodingException e) {
                throw new RuntimeException("Failed to encode the provided signing certificates", e);
            }
        }
    }
    if (sortedSignerConfigs.size() != signerConfigs.size()) {
        throw new IllegalArgumentException("SignerConfigs supplied which are not present in the" + " SigningCertificateLineage");
    }
    return sortedSignerConfigs;
}
#end_block

#method_before
// TODO add API to query if given signing certificate is in set of signing certificates
private static int calculateDefaultFlags() {
    return PAST_CERT_INSTALLED_DATA | PAST_CERT_PERMISSION | PAST_CERT_SHARED_USER_ID | PAST_CERT_AUTH;
}
#method_after
private static int calculateDefaultFlags() {
    return PAST_CERT_INSTALLED_DATA | PAST_CERT_PERMISSION | PAST_CERT_SHARED_USER_ID | PAST_CERT_AUTH;
}
#end_block

#method_before
public SigningCertificateLineage getSubLineage(X509Certificate x509Certificate) {
    if (x509Certificate == null) {
        throw new NullPointerException("x509Certificate == null");
    }
    for (int i = 0; i < mSigningLineage.size(); i++) {
        if (mSigningLineage.get(i).signingCert.equals(x509Certificate)) {
            return new SigningCertificateLineage(mMinSdkVersion, new ArrayList<>(mSigningLineage.subList(0, i + 1)));
        }
    }
    // looks like we didn't find the cert,
    throw new IllegalArgumentException("Certificate not found in SigningCertificateLineage");
}
#method_after
public SigningCertificateLineage getSubLineage(X509Certificate x509Certificate) {
    if (x509Certificate == null) {
        throw new NullPointerException("x509Certificate == null");
    }
    try {
        byte[] encodedCert = x509Certificate.getEncoded();
        for (int i = 0; i < mSigningLineage.size(); i++) {
            if (Arrays.equals(mSigningLineage.get(i).signingCert.getEncoded(), encodedCert)) {
                return new SigningCertificateLineage(mMinSdkVersion, new ArrayList<>(mSigningLineage.subList(0, i + 1)));
            }
        }
    } catch (CertificateEncodingException e) {
        throw new RuntimeException("Failed to encode the provided signing certificate", e);
    }
    // looks like we didn't find the cert,
    throw new IllegalArgumentException("Certificate not found in SigningCertificateLineage");
}
#end_block

#method_before
public SigningCertificateLineage build() throws CertificateEncodingException, InvalidKeyException, NoSuchAlgorithmException, SignatureException {
    if (mMinSdkVersion < AndroidSdkVersion.P) {
        mMinSdkVersion = AndroidSdkVersion.P;
    }
    if (mOriginalCapabilities == null) {
        mOriginalCapabilities = new SignerCapabilities.Builder().build();
    }
    if (mNewCapabilities == null) {
        mNewCapabilities = new SignerCapabilities.Builder().build();
    }
    return createSigningLineage(mMinSdkVersion, mOriginalSignerConfig, mOriginalCapabilities, mNewSignerConfig, mNewCapabilities);
}
#method_after
public SignerCapabilities build() {
    return new SignerCapabilities(mFlags, mCallerConfiguredFlags);
}
#end_block

#method_before
public SigningCertificateLineage build() throws CertificateEncodingException, InvalidKeyException, NoSuchAlgorithmException, SignatureException {
    if (mMinSdkVersion < AndroidSdkVersion.P) {
        mMinSdkVersion = AndroidSdkVersion.P;
    }
    if (mOriginalCapabilities == null) {
        mOriginalCapabilities = new SignerCapabilities.Builder().build();
    }
    if (mNewCapabilities == null) {
        mNewCapabilities = new SignerCapabilities.Builder().build();
    }
    return createSigningLineage(mMinSdkVersion, mOriginalSignerConfig, mOriginalCapabilities, mNewSignerConfig, mNewCapabilities);
}
#method_after
public SignerConfig build() {
    return new SignerConfig(mPrivateKey, mCertificate);
}
#end_block

#method_before
public static void lineage(String[] params) throws Exception {
    if (params.length == 0) {
        printUsage(HELP_PAGE_LINEAGE);
        return;
    }
    boolean verbose = false;
    boolean printCerts = false;
    boolean lineageUpdated = false;
    File outputKeyLineage = null;
    String optionName;
    OptionsParser optionsParser = new OptionsParser(params);
    SigningCertificateLineage lineage = null;
    List<SignerParams> signers = new ArrayList<>(1);
    while ((optionName = optionsParser.nextOption()) != null) {
        if (("help".equals(optionName)) || ("h".equals(optionName))) {
            printUsage(HELP_PAGE_LINEAGE);
            return;
        } else if ("in".equals(optionName)) {
            File inputKeyLineage = new File(optionsParser.getRequiredValue("Input file name"));
            lineage = SigningCertificateLineage.readFromFile(inputKeyLineage);
        } else if ("out".equals(optionName)) {
            outputKeyLineage = new File(optionsParser.getRequiredValue("Output file name"));
        } else if ("signer".equals(optionName)) {
            SignerParams signerParams = processSignerParams(optionsParser);
            signers.add(signerParams);
        } else if (("v".equals(optionName)) || ("verbose".equals(optionName))) {
            verbose = optionsParser.getOptionalBooleanValue(true);
        } else if ("print-certs".equals(optionName)) {
            printCerts = optionsParser.getOptionalBooleanValue(true);
        } else {
            throw new ParameterException("Unsupported option: " + optionsParser.getOptionOriginalForm() + ". See --help for supported options.");
        }
    }
    if (lineage == null) {
        throw new ParameterException("Input lineage file parameter not present");
    }
    try (PasswordRetriever passwordRetriever = new PasswordRetriever()) {
        for (int i = 0; i < signers.size(); i++) {
            SignerParams signerParams = signers.get(i);
            signerParams.name = "signer #" + (i + 1);
            loadPrivateKeyAndCerts(signerParams, passwordRetriever);
            SigningCertificateLineage.SignerConfig signerConfig = new SigningCertificateLineage.SignerConfig.Builder(signerParams.privateKey, signerParams.certs.get(0)).build();
            try {
                // since only the caller specified capabilities will be updated a direct
                // comparison between the original capabilities of the signer and the
                // signerCapabilitiesBuilder object with potential default values is not
                // possible. Instead the capabilities should be updated first, then the new
                // capabilities can be compared against the original to determine if the
                // lineage has been updated and needs to be written out to a file.
                SignerCapabilities origCapabilities = lineage.getSignerCapabilities(signerConfig);
                lineage.updateSignerCapabilities(signerConfig, signerParams.signerCapabilitiesBuilder.build());
                SignerCapabilities newCapabilities = lineage.getSignerCapabilities(signerConfig);
                if (origCapabilities.equals(newCapabilities)) {
                    if (verbose) {
                        System.out.println("The provided signer capabilities for " + signerParams.name + " match this signer's current capabilities.");
                    }
                } else {
                    lineageUpdated = true;
                    if (verbose) {
                        System.out.println("Updated signer capabilities for " + signerParams.name + ".");
                    }
                }
            } catch (IllegalArgumentException e) {
                throw new ParameterException("The signer " + signerParams.name + " was not found in the specified lineage.");
            }
        }
    }
    if (printCerts) {
        List<X509Certificate> signingCerts = lineage.getCertificatesInLineage();
        for (int i = 0; i < signingCerts.size(); i++) {
            X509Certificate signerCert = signingCerts.get(i);
            SignerCapabilities signerCapabilities = lineage.getSignerCapabilities(signerCert);
            printCertificate(signerCert, "Signer #" + (i + 1) + " in lineage", verbose);
            signerCapabilities.printCapabilities();
        }
    }
    if (lineageUpdated) {
        if (outputKeyLineage != null) {
            lineage.writeToFile(outputKeyLineage);
            if (verbose) {
                System.out.println("Updated lineage saved to " + outputKeyLineage + ".");
            }
        } else {
            throw new ParameterException("The lineage was modified but an output file for the lineage was not " + "specified");
        }
    }
}
#method_after
public static void lineage(String[] params) throws Exception {
    if (params.length == 0) {
        printUsage(HELP_PAGE_LINEAGE);
        return;
    }
    boolean verbose = false;
    boolean printCerts = false;
    boolean lineageUpdated = false;
    File outputKeyLineage = null;
    String optionName;
    OptionsParser optionsParser = new OptionsParser(params);
    SigningCertificateLineage lineage = null;
    List<SignerParams> signers = new ArrayList<>(1);
    while ((optionName = optionsParser.nextOption()) != null) {
        if (("help".equals(optionName)) || ("h".equals(optionName))) {
            printUsage(HELP_PAGE_LINEAGE);
            return;
        } else if ("in".equals(optionName)) {
            File inputKeyLineage = new File(optionsParser.getRequiredValue("Input file name"));
            lineage = SigningCertificateLineage.readFromFile(inputKeyLineage);
        } else if ("out".equals(optionName)) {
            outputKeyLineage = new File(optionsParser.getRequiredValue("Output file name"));
        } else if ("signer".equals(optionName)) {
            SignerParams signerParams = processSignerParams(optionsParser);
            signers.add(signerParams);
        } else if (("v".equals(optionName)) || ("verbose".equals(optionName))) {
            verbose = optionsParser.getOptionalBooleanValue(true);
        } else if ("print-certs".equals(optionName)) {
            printCerts = optionsParser.getOptionalBooleanValue(true);
        } else {
            throw new ParameterException("Unsupported option: " + optionsParser.getOptionOriginalForm() + ". See --help for supported options.");
        }
    }
    if (lineage == null) {
        throw new ParameterException("Input lineage file parameter not present");
    }
    try (PasswordRetriever passwordRetriever = new PasswordRetriever()) {
        for (int i = 0; i < signers.size(); i++) {
            SignerParams signerParams = signers.get(i);
            signerParams.name = "signer #" + (i + 1);
            loadPrivateKeyAndCerts(signerParams, passwordRetriever);
            SigningCertificateLineage.SignerConfig signerConfig = new SigningCertificateLineage.SignerConfig.Builder(signerParams.privateKey, signerParams.certs.get(0)).build();
            try {
                // since only the caller specified capabilities will be updated a direct
                // comparison between the original capabilities of the signer and the
                // signerCapabilitiesBuilder object with potential default values is not
                // possible. Instead the capabilities should be updated first, then the new
                // capabilities can be compared against the original to determine if the
                // lineage has been updated and needs to be written out to a file.
                SignerCapabilities origCapabilities = lineage.getSignerCapabilities(signerConfig);
                lineage.updateSignerCapabilities(signerConfig, signerParams.signerCapabilitiesBuilder.build());
                SignerCapabilities newCapabilities = lineage.getSignerCapabilities(signerConfig);
                if (origCapabilities.equals(newCapabilities)) {
                    if (verbose) {
                        System.out.println("The provided signer capabilities for " + signerParams.name + " are unchanged.");
                    }
                } else {
                    lineageUpdated = true;
                    if (verbose) {
                        System.out.println("Updated signer capabilities for " + signerParams.name + ".");
                    }
                }
            } catch (IllegalArgumentException e) {
                throw new ParameterException("The signer " + signerParams.name + " was not found in the specified lineage.");
            }
        }
    }
    if (printCerts) {
        List<X509Certificate> signingCerts = lineage.getCertificatesInLineage();
        for (int i = 0; i < signingCerts.size(); i++) {
            X509Certificate signerCert = signingCerts.get(i);
            SignerCapabilities signerCapabilities = lineage.getSignerCapabilities(signerCert);
            printCertificate(signerCert, "Signer #" + (i + 1) + " in lineage", verbose);
            printCapabilities(signerCapabilities);
        }
    }
    if (lineageUpdated) {
        if (outputKeyLineage != null) {
            lineage.writeToFile(outputKeyLineage);
            if (verbose) {
                System.out.println("Updated lineage saved to " + outputKeyLineage + ".");
            }
        } else {
            throw new ParameterException("The lineage was modified but an output file for the lineage was not " + "specified");
        }
    }
}
#end_block

#method_before
private void loadPrivateKeyAndCertsFromKeyStore(PasswordRetriever passwordRetriever) throws Exception {
    if (keystoreFile == null) {
        throw new ParameterException("KeyStore (--ks) must be specified");
    }
    // 1. Obtain a KeyStore implementation
    String ksType = (keystoreType != null) ? keystoreType : KeyStore.getDefaultType();
    KeyStore ks;
    if (keystoreProviderName != null) {
        // Use a named Provider (assumes the provider is already installed)
        ks = KeyStore.getInstance(ksType, keystoreProviderName);
    } else if (keystoreProviderClass != null) {
        // Use a new Provider instance (does not require the provider to be installed)
        Class<?> ksProviderClass = Class.forName(keystoreProviderClass);
        if (!Provider.class.isAssignableFrom(ksProviderClass)) {
            throw new ParameterException("Keystore Provider class " + keystoreProviderClass + " not subclass of " + Provider.class.getName());
        }
        Provider ksProvider;
        if (keystoreProviderArg != null) {
            // Single-arg Provider constructor
            ksProvider = (Provider) ksProviderClass.getConstructor(String.class).newInstance(keystoreProviderArg);
        } else {
            // No-arg Provider constructor
            ksProvider = (Provider) ksProviderClass.getConstructor().newInstance();
        }
        ks = KeyStore.getInstance(ksType, ksProvider);
    } else {
        // Use the highest-priority Provider which offers the requested KeyStore type
        ks = KeyStore.getInstance(ksType);
    }
    // 2. Load the KeyStore
    List<char[]> keystorePasswords;
    Charset[] additionalPasswordEncodings;
    {
        String keystorePasswordSpec = (this.keystorePasswordSpec != null) ? this.keystorePasswordSpec : PasswordRetriever.SPEC_STDIN;
        additionalPasswordEncodings = (passwordCharset != null) ? new Charset[] { passwordCharset } : new Charset[0];
        keystorePasswords = passwordRetriever.getPasswords(keystorePasswordSpec, "Keystore password for " + name, additionalPasswordEncodings);
        loadKeyStoreFromFile(ks, "NONE".equals(keystoreFile) ? null : keystoreFile, keystorePasswords);
    }
    // 3. Load the PrivateKey and cert chain from KeyStore
    String keyAlias = null;
    PrivateKey key = null;
    try {
        if (keystoreKeyAlias == null) {
            // Private key entry alias not specified. Find the key entry contained in this
            // KeyStore. If the KeyStore contains multiple key entries, return an error.
            Enumeration<String> aliases = ks.aliases();
            if (aliases != null) {
                while (aliases.hasMoreElements()) {
                    String entryAlias = aliases.nextElement();
                    if (ks.isKeyEntry(entryAlias)) {
                        keyAlias = entryAlias;
                        if (keystoreKeyAlias != null) {
                            throw new ParameterException(keystoreFile + " contains multiple key entries" + ". --ks-key-alias option must be used to specify" + " which entry to use.");
                        }
                        keystoreKeyAlias = keyAlias;
                    }
                }
            }
            if (keystoreKeyAlias == null) {
                throw new ParameterException(keystoreFile + " does not contain key entries");
            }
        }
        // Private key entry alias known. Load that entry's private key.
        keyAlias = keystoreKeyAlias;
        if (!ks.isKeyEntry(keyAlias)) {
            throw new ParameterException(keystoreFile + " entry \"" + keyAlias + "\" does not contain a key");
        }
        Key entryKey;
        if (keyPasswordSpec != null) {
            // Key password spec is explicitly specified. Use this spec to obtain the
            // password and then load the key using that password.
            List<char[]> keyPasswords = passwordRetriever.getPasswords(keyPasswordSpec, "Key \"" + keyAlias + "\" password for " + name, additionalPasswordEncodings);
            entryKey = getKeyStoreKey(ks, keyAlias, keyPasswords);
        } else {
            // password.
            try {
                entryKey = getKeyStoreKey(ks, keyAlias, keystorePasswords);
            } catch (UnrecoverableKeyException expected) {
                List<char[]> keyPasswords = passwordRetriever.getPasswords(PasswordRetriever.SPEC_STDIN, "Key \"" + keyAlias + "\" password for " + name, additionalPasswordEncodings);
                entryKey = getKeyStoreKey(ks, keyAlias, keyPasswords);
            }
        }
        if (entryKey == null) {
            throw new ParameterException(keystoreFile + " entry \"" + keyAlias + "\" does not contain a key");
        } else if (!(entryKey instanceof PrivateKey)) {
            throw new ParameterException(keystoreFile + " entry \"" + keyAlias + "\" does not contain a private" + " key. It contains a key of algorithm: " + entryKey.getAlgorithm());
        }
        key = (PrivateKey) entryKey;
    } catch (UnrecoverableKeyException e) {
        throw new IOException("Failed to obtain key with alias \"" + keyAlias + "\" from " + keystoreFile + ". Wrong password?", e);
    }
    this.privateKey = key;
    Certificate[] certChain = ks.getCertificateChain(keyAlias);
    if ((certChain == null) || (certChain.length == 0)) {
        throw new ParameterException(keystoreFile + " entry \"" + keyAlias + "\" does not contain certificates");
    }
    this.certs = new ArrayList<>(certChain.length);
    for (Certificate cert : certChain) {
        this.certs.add(new GuaranteedEncodedFormX509Certificate((X509Certificate) cert, cert.getEncoded()));
    }
}
#method_after
private void loadPrivateKeyAndCertsFromKeyStore(PasswordRetriever passwordRetriever) throws Exception {
    if (keystoreFile == null) {
        throw new ParameterException("KeyStore (--ks) must be specified");
    }
    // 1. Obtain a KeyStore implementation
    String ksType = (keystoreType != null) ? keystoreType : KeyStore.getDefaultType();
    KeyStore ks;
    if (keystoreProviderName != null) {
        // Use a named Provider (assumes the provider is already installed)
        ks = KeyStore.getInstance(ksType, keystoreProviderName);
    } else if (keystoreProviderClass != null) {
        // Use a new Provider instance (does not require the provider to be installed)
        Class<?> ksProviderClass = Class.forName(keystoreProviderClass);
        if (!Provider.class.isAssignableFrom(ksProviderClass)) {
            throw new ParameterException("Keystore Provider class " + keystoreProviderClass + " not subclass of " + Provider.class.getName());
        }
        Provider ksProvider;
        if (keystoreProviderArg != null) {
            // Single-arg Provider constructor
            ksProvider = (Provider) ksProviderClass.getConstructor(String.class).newInstance(keystoreProviderArg);
        } else {
            // No-arg Provider constructor
            ksProvider = (Provider) ksProviderClass.getConstructor().newInstance();
        }
        ks = KeyStore.getInstance(ksType, ksProvider);
    } else {
        // Use the highest-priority Provider which offers the requested KeyStore type
        ks = KeyStore.getInstance(ksType);
    }
    // 2. Load the KeyStore
    List<char[]> keystorePasswords;
    Charset[] additionalPasswordEncodings;
    {
        String keystorePasswordSpec = (this.keystorePasswordSpec != null) ? this.keystorePasswordSpec : PasswordRetriever.SPEC_STDIN;
        additionalPasswordEncodings = (passwordCharset != null) ? new Charset[] { passwordCharset } : new Charset[0];
        keystorePasswords = passwordRetriever.getPasswords(keystorePasswordSpec, "Keystore password for " + name, additionalPasswordEncodings);
        loadKeyStoreFromFile(ks, "NONE".equals(keystoreFile) ? null : keystoreFile, keystorePasswords);
    }
    // 3. Load the PrivateKey and cert chain from KeyStore
    String keyAlias = null;
    PrivateKey key = null;
    try {
        if (keystoreKeyAlias == null) {
            // Private key entry alias not specified. Find the key entry contained in this
            // KeyStore. If the KeyStore contains multiple key entries, return an error.
            Enumeration<String> aliases = ks.aliases();
            if (aliases != null) {
                while (aliases.hasMoreElements()) {
                    String entryAlias = aliases.nextElement();
                    if (ks.isKeyEntry(entryAlias)) {
                        keyAlias = entryAlias;
                        if (keystoreKeyAlias != null) {
                            throw new ParameterException(keystoreFile + " contains multiple key entries" + ". --ks-key-alias option must be used to specify" + " which entry to use.");
                        }
                        keystoreKeyAlias = keyAlias;
                    }
                }
            }
            if (keystoreKeyAlias == null) {
                throw new ParameterException(keystoreFile + " does not contain key entries");
            }
        }
        // Private key entry alias known. Load that entry's private key.
        keyAlias = keystoreKeyAlias;
        if (!ks.isKeyEntry(keyAlias)) {
            throw new ParameterException(keystoreFile + " entry \"" + keyAlias + "\" does not contain a key");
        }
        Key entryKey;
        if (keyPasswordSpec != null) {
            // Key password spec is explicitly specified. Use this spec to obtain the
            // password and then load the key using that password.
            List<char[]> keyPasswords = passwordRetriever.getPasswords(keyPasswordSpec, "Key \"" + keyAlias + "\" password for " + name, additionalPasswordEncodings);
            entryKey = getKeyStoreKey(ks, keyAlias, keyPasswords);
        } else {
            // password.
            try {
                entryKey = getKeyStoreKey(ks, keyAlias, keystorePasswords);
            } catch (UnrecoverableKeyException expected) {
                List<char[]> keyPasswords = passwordRetriever.getPasswords(PasswordRetriever.SPEC_STDIN, "Key \"" + keyAlias + "\" password for " + name, additionalPasswordEncodings);
                entryKey = getKeyStoreKey(ks, keyAlias, keyPasswords);
            }
        }
        if (entryKey == null) {
            throw new ParameterException(keystoreFile + " entry \"" + keyAlias + "\" does not contain a key");
        } else if (!(entryKey instanceof PrivateKey)) {
            throw new ParameterException(keystoreFile + " entry \"" + keyAlias + "\" does not contain a private" + " key. It contains a key of algorithm: " + entryKey.getAlgorithm());
        }
        key = (PrivateKey) entryKey;
    } catch (UnrecoverableKeyException e) {
        throw new IOException("Failed to obtain key with alias \"" + keyAlias + "\" from " + keystoreFile + ". Wrong password?", e);
    }
    this.privateKey = key;
    Certificate[] certChain = ks.getCertificateChain(keyAlias);
    if ((certChain == null) || (certChain.length == 0)) {
        throw new ParameterException(keystoreFile + " entry \"" + keyAlias + "\" does not contain certificates");
    }
    this.certs = new ArrayList<>(certChain.length);
    for (Certificate cert : certChain) {
        this.certs.add((X509Certificate) cert);
    }
}
#end_block

#method_before
private void loadPrivateKeyAndCertsFromFiles(PasswordRetriever passwordRetriver) throws Exception {
    if (keyFile == null) {
        throw new ParameterException("Private key file (--key) must be specified");
    }
    if (certFile == null) {
        throw new ParameterException("Certificate file (--cert) must be specified");
    }
    byte[] privateKeyBlob = readFully(new File(keyFile));
    PKCS8EncodedKeySpec keySpec;
    // Potentially encrypted key blob
    try {
        EncryptedPrivateKeyInfo encryptedPrivateKeyInfo = new EncryptedPrivateKeyInfo(privateKeyBlob);
        // The blob is indeed an encrypted private key blob
        String passwordSpec = (keyPasswordSpec != null) ? keyPasswordSpec : PasswordRetriever.SPEC_STDIN;
        Charset[] additionalPasswordEncodings = (passwordCharset != null) ? new Charset[] { passwordCharset } : new Charset[0];
        List<char[]> keyPasswords = passwordRetriver.getPasswords(passwordSpec, "Private key password for " + name, additionalPasswordEncodings);
        keySpec = decryptPkcs8EncodedKey(encryptedPrivateKeyInfo, keyPasswords);
    } catch (IOException e) {
        // The blob is not an encrypted private key blob
        if (keyPasswordSpec == null) {
            // Given that no password was specified, assume the blob is an unencrypted
            // private key blob
            keySpec = new PKCS8EncodedKeySpec(privateKeyBlob);
        } else {
            throw new InvalidKeySpecException("Failed to parse encrypted private key blob " + keyFile, e);
        }
    }
    // Load the private key from its PKCS #8 encoded form.
    try {
        privateKey = loadPkcs8EncodedPrivateKey(keySpec);
    } catch (InvalidKeySpecException e) {
        throw new InvalidKeySpecException("Failed to load PKCS #8 encoded private key from " + keyFile, e);
    }
    // Load certificates
    Collection<? extends Certificate> certs;
    try (FileInputStream in = new FileInputStream(certFile)) {
        certs = CertificateFactory.getInstance("X.509").generateCertificates(in);
    }
    List<X509Certificate> certList = new ArrayList<>(certs.size());
    for (Certificate cert : certs) {
        certList.add(new GuaranteedEncodedFormX509Certificate((X509Certificate) cert, cert.getEncoded()));
    }
    this.certs = certList;
}
#method_after
private void loadPrivateKeyAndCertsFromFiles(PasswordRetriever passwordRetriver) throws Exception {
    if (keyFile == null) {
        throw new ParameterException("Private key file (--key) must be specified");
    }
    if (certFile == null) {
        throw new ParameterException("Certificate file (--cert) must be specified");
    }
    byte[] privateKeyBlob = readFully(new File(keyFile));
    PKCS8EncodedKeySpec keySpec;
    // Potentially encrypted key blob
    try {
        EncryptedPrivateKeyInfo encryptedPrivateKeyInfo = new EncryptedPrivateKeyInfo(privateKeyBlob);
        // The blob is indeed an encrypted private key blob
        String passwordSpec = (keyPasswordSpec != null) ? keyPasswordSpec : PasswordRetriever.SPEC_STDIN;
        Charset[] additionalPasswordEncodings = (passwordCharset != null) ? new Charset[] { passwordCharset } : new Charset[0];
        List<char[]> keyPasswords = passwordRetriver.getPasswords(passwordSpec, "Private key password for " + name, additionalPasswordEncodings);
        keySpec = decryptPkcs8EncodedKey(encryptedPrivateKeyInfo, keyPasswords);
    } catch (IOException e) {
        // The blob is not an encrypted private key blob
        if (keyPasswordSpec == null) {
            // Given that no password was specified, assume the blob is an unencrypted
            // private key blob
            keySpec = new PKCS8EncodedKeySpec(privateKeyBlob);
        } else {
            throw new InvalidKeySpecException("Failed to parse encrypted private key blob " + keyFile, e);
        }
    }
    // Load the private key from its PKCS #8 encoded form.
    try {
        privateKey = loadPkcs8EncodedPrivateKey(keySpec);
    } catch (InvalidKeySpecException e) {
        throw new InvalidKeySpecException("Failed to load PKCS #8 encoded private key from " + keyFile, e);
    }
    // Load certificates
    Collection<? extends Certificate> certs;
    try (FileInputStream in = new FileInputStream(certFile)) {
        certs = CertificateFactory.getInstance("X.509").generateCertificates(in);
    }
    List<X509Certificate> certList = new ArrayList<>(certs.size());
    for (Certificate cert : certs) {
        certList.add((X509Certificate) cert);
    }
    this.certs = certList;
}
#end_block

#method_before
public static AppInterface getInstance(int slotId) {
    return getInstance(null, null, null, slotId);
}
#method_after
public static CatService getInstance(CommandsInterface ci, Context context, UiccProfile uiccProfile, int slotId) {
    UiccCardApplication ca = null;
    IccFileHandler fh = null;
    IccRecords ir = null;
    if (uiccProfile != null) {
        /* Since Cat is not tied to any application, but rather is Uicc application
             * in itself - just get first FileHandler and IccRecords object
             */
        ca = uiccProfile.getApplicationIndex(0);
        if (ca != null) {
            fh = ca.getIccFileHandler();
            ir = ca.getIccRecords();
        }
    }
    synchronized (sInstanceLock) {
        if (sInstance == null) {
            int simCount = TelephonyManager.getDefault().getSimCount();
            sInstance = new CatService[simCount];
            for (int i = 0; i < simCount; i++) {
                sInstance[i] = null;
            }
        }
        if (sInstance[slotId] == null) {
            if (ci == null || ca == null || ir == null || context == null || fh == null || uiccProfile == null) {
                return null;
            }
            sInstance[slotId] = new CatService(ci, ca, ir, context, fh, uiccProfile, slotId);
        } else if ((ir != null) && (mIccRecords != ir)) {
            if (mIccRecords != null) {
                mIccRecords.unregisterForRecordsLoaded(sInstance[slotId]);
            }
            mIccRecords = ir;
            mUiccApplication = ca;
            mIccRecords.registerForRecordsLoaded(sInstance[slotId], MSG_ID_ICC_RECORDS_LOADED, null);
            CatLog.d(sInstance[slotId], "registerForRecordsLoaded slotid=" + slotId + " instance:" + sInstance[slotId]);
        }
        return sInstance[slotId];
    }
}
#end_block

#method_before
private boolean isSupportedSetupEventCommand(CatCmdMessage cmdMsg) {
    boolean flag = true;
    for (int eventVal : cmdMsg.getSetEventList().eventList) {
        CatLog.d(this, "Event: " + eventVal);
        switch(eventVal) {
            /* Currently android is supporting only the below events in SetupEventList
                 * Language Selection.  */
            case IDLE_SCREEN_AVAILABLE_EVENT:
            case LANGUAGE_SELECTION_EVENT:
                break;
            default:
                flag = false;
        }
    }
    return flag;
}
#method_after
private boolean isSupportedSetupEventCommand(CatCmdMessage cmdMsg) {
    boolean flag = true;
    for (int eventVal : cmdMsg.getSetEventList().eventList) {
        CatLog.d(this, "Event: " + eventVal);
        switch(eventVal) {
            /* Currently android is supporting only the below events in SetupEventList
                 * Language Selection.  */
            case IDLE_SCREEN_AVAILABLE_EVENT:
            case LANGUAGE_SELECTION_EVENT:
            case USER_ACTIVITY_EVENT:
                break;
            default:
                flag = false;
        }
    }
    return flag;
}
#end_block

#method_before
private void handleCommand(CommandParams cmdParams, boolean isProactiveCmd) {
    CatLog.d(this, cmdParams.getCommandType().name());
    // Log all proactive commands.
    if (isProactiveCmd) {
        if (mUiccController != null) {
            mUiccController.addCardLog("ProactiveCommand mSlotId=" + mSlotId + " cmdParams=" + cmdParams);
        }
    }
    CharSequence message;
    ResultCode resultCode;
    CatCmdMessage cmdMsg = new CatCmdMessage(cmdParams);
    switch(cmdParams.getCommandType()) {
        case SET_UP_MENU:
            if (removeMenu(cmdMsg.getMenu())) {
                mMenuCmd = null;
            } else {
                mMenuCmd = cmdMsg;
            }
            resultCode = cmdParams.mLoadIconFailed ? ResultCode.PRFRMD_ICON_NOT_DISPLAYED : ResultCode.OK;
            sendTerminalResponse(cmdParams.mCmdDet, resultCode, false, 0, null);
            break;
        case DISPLAY_TEXT:
            break;
        case REFRESH:
            // ME side only handles refresh commands which meant to remove IDLE
            // MODE TEXT.
            cmdParams.mCmdDet.typeOfCommand = CommandType.SET_UP_IDLE_MODE_TEXT.value();
            break;
        case SET_UP_IDLE_MODE_TEXT:
            resultCode = cmdParams.mLoadIconFailed ? ResultCode.PRFRMD_ICON_NOT_DISPLAYED : ResultCode.OK;
            sendTerminalResponse(cmdParams.mCmdDet, resultCode, false, 0, null);
            break;
        case SET_UP_EVENT_LIST:
            if (isSupportedSetupEventCommand(cmdMsg)) {
                sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, null);
            } else {
                sendTerminalResponse(cmdParams.mCmdDet, ResultCode.BEYOND_TERMINAL_CAPABILITY, false, 0, null);
            }
            break;
        case PROVIDE_LOCAL_INFORMATION:
            ResponseData resp;
            switch(cmdParams.mCmdDet.commandQualifier) {
                case CommandParamsFactory.DTTZ_SETTING:
                    resp = new DTTZResponseData(null);
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, resp);
                    break;
                case CommandParamsFactory.LANGUAGE_SETTING:
                    resp = new LanguageResponseData(Locale.getDefault().getLanguage());
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, resp);
                    break;
                default:
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, null);
            }
            // No need to start STK app here.
            return;
        case LAUNCH_BROWSER:
            if ((((LaunchBrowserParams) cmdParams).mConfirmMsg.text != null) && (((LaunchBrowserParams) cmdParams).mConfirmMsg.text.equals(STK_DEFAULT))) {
                message = mContext.getText(com.android.internal.R.string.launchBrowserDefault);
                ((LaunchBrowserParams) cmdParams).mConfirmMsg.text = message.toString();
            }
            break;
        case SELECT_ITEM:
        case GET_INPUT:
        case GET_INKEY:
            break;
        case SEND_DTMF:
        case SEND_SMS:
        case RUN_AT:
        case SEND_SS:
        case SEND_USSD:
            if ((((DisplayTextParams) cmdParams).mTextMsg.text != null) && (((DisplayTextParams) cmdParams).mTextMsg.text.equals(STK_DEFAULT))) {
                message = mContext.getText(com.android.internal.R.string.sending);
                ((DisplayTextParams) cmdParams).mTextMsg.text = message.toString();
            }
            break;
        case PLAY_TONE:
            break;
        case SET_UP_CALL:
            if ((((CallSetupParams) cmdParams).mConfirmMsg.text != null) && (((CallSetupParams) cmdParams).mConfirmMsg.text.equals(STK_DEFAULT))) {
                message = mContext.getText(com.android.internal.R.string.SetupCallDefault);
                ((CallSetupParams) cmdParams).mConfirmMsg.text = message.toString();
            }
            break;
        case LANGUAGE_NOTIFICATION:
            String language = ((LanguageParams) cmdParams).mLanguage;
            ResultCode result = ResultCode.OK;
            if (language != null && language.length() > 0) {
                try {
                    changeLanguage(language);
                } catch (RemoteException e) {
                    result = ResultCode.TERMINAL_CRNTLY_UNABLE_TO_PROCESS;
                }
            }
            sendTerminalResponse(cmdParams.mCmdDet, result, false, 0, null);
            return;
        case OPEN_CHANNEL:
        case CLOSE_CHANNEL:
        case RECEIVE_DATA:
        case SEND_DATA:
            BIPClientParams cmd = (BIPClientParams) cmdParams;
            /* Per 3GPP specification 102.223,
                 * if the alpha identifier is not provided by the UICC,
                 * the terminal MAY give information to the user
                 * noAlphaUsrCnf defines if you need to show user confirmation or not
                 */
            boolean noAlphaUsrCnf = false;
            try {
                noAlphaUsrCnf = mContext.getResources().getBoolean(com.android.internal.R.bool.config_stkNoAlphaUsrCnf);
            } catch (NotFoundException e) {
                noAlphaUsrCnf = false;
            }
            if ((cmd.mTextMsg.text == null) && (cmd.mHasAlphaId || noAlphaUsrCnf)) {
                CatLog.d(this, "cmd " + cmdParams.getCommandType() + " with null alpha id");
                // If alpha length is zero, we just respond with OK.
                if (isProactiveCmd) {
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, null);
                } else if (cmdParams.getCommandType() == CommandType.OPEN_CHANNEL) {
                    mCmdIf.handleCallSetupRequestFromSim(true, null);
                }
                return;
            }
            // Respond with permanent failure to avoid retry if STK app is not present.
            if (!mStkAppInstalled) {
                CatLog.d(this, "No STK application found.");
                if (isProactiveCmd) {
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.BEYOND_TERMINAL_CAPABILITY, false, 0, null);
                    return;
                }
            }
            /*
                 * CLOSE_CHANNEL, RECEIVE_DATA and SEND_DATA can be delivered by
                 * either PROACTIVE_COMMAND or EVENT_NOTIFY.
                 * If PROACTIVE_COMMAND is used for those commands, send terminal
                 * response here.
                 */
            if (isProactiveCmd && ((cmdParams.getCommandType() == CommandType.CLOSE_CHANNEL) || (cmdParams.getCommandType() == CommandType.RECEIVE_DATA) || (cmdParams.getCommandType() == CommandType.SEND_DATA))) {
                sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, null);
            }
            break;
        default:
            CatLog.d(this, "Unsupported command");
            return;
    }
    mCurrntCmd = cmdMsg;
    broadcastCatCmdIntent(cmdMsg);
}
#method_after
private void handleCommand(CommandParams cmdParams, boolean isProactiveCmd) {
    CatLog.d(this, cmdParams.getCommandType().name());
    // Log all proactive commands.
    if (isProactiveCmd) {
        if (mUiccController != null) {
            mUiccController.addCardLog("ProactiveCommand mSlotId=" + mSlotId + " cmdParams=" + cmdParams);
        }
    }
    CharSequence message;
    ResultCode resultCode;
    CatCmdMessage cmdMsg = new CatCmdMessage(cmdParams);
    switch(cmdParams.getCommandType()) {
        case SET_UP_MENU:
            if (removeMenu(cmdMsg.getMenu())) {
                mMenuCmd = null;
            } else {
                mMenuCmd = cmdMsg;
            }
            resultCode = cmdParams.mLoadIconFailed ? ResultCode.PRFRMD_ICON_NOT_DISPLAYED : ResultCode.OK;
            sendTerminalResponse(cmdParams.mCmdDet, resultCode, false, 0, null);
            break;
        case DISPLAY_TEXT:
            break;
        case REFRESH:
            // ME side only handles refresh commands which meant to remove IDLE
            // MODE TEXT.
            cmdParams.mCmdDet.typeOfCommand = CommandType.SET_UP_IDLE_MODE_TEXT.value();
            break;
        case SET_UP_IDLE_MODE_TEXT:
            resultCode = cmdParams.mLoadIconFailed ? ResultCode.PRFRMD_ICON_NOT_DISPLAYED : ResultCode.OK;
            sendTerminalResponse(cmdParams.mCmdDet, resultCode, false, 0, null);
            break;
        case SET_UP_EVENT_LIST:
            if (isSupportedSetupEventCommand(cmdMsg)) {
                sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, null);
            } else {
                sendTerminalResponse(cmdParams.mCmdDet, ResultCode.BEYOND_TERMINAL_CAPABILITY, false, 0, null);
            }
            break;
        case PROVIDE_LOCAL_INFORMATION:
            ResponseData resp;
            switch(cmdParams.mCmdDet.commandQualifier) {
                case CommandParamsFactory.DTTZ_SETTING:
                    resp = new DTTZResponseData(null);
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, resp);
                    break;
                case CommandParamsFactory.LANGUAGE_SETTING:
                    resp = new LanguageResponseData(Locale.getDefault().getLanguage());
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, resp);
                    break;
                default:
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, null);
            }
            // No need to start STK app here.
            return;
        case LAUNCH_BROWSER:
            if ((((LaunchBrowserParams) cmdParams).mConfirmMsg.text != null) && (((LaunchBrowserParams) cmdParams).mConfirmMsg.text.equals(STK_DEFAULT))) {
                message = mContext.getText(com.android.internal.R.string.launchBrowserDefault);
                ((LaunchBrowserParams) cmdParams).mConfirmMsg.text = message.toString();
            }
            break;
        case SELECT_ITEM:
        case GET_INPUT:
        case GET_INKEY:
            break;
        case RUN_AT:
            if (STK_DEFAULT.equals(((DisplayTextParams) cmdParams).mTextMsg.text)) {
                // Remove the default text which was temporarily added and shall not be shown
                ((DisplayTextParams) cmdParams).mTextMsg.text = null;
            }
            break;
        case SEND_DTMF:
        case SEND_SMS:
        case SEND_SS:
        case SEND_USSD:
            if ((((DisplayTextParams) cmdParams).mTextMsg.text != null) && (((DisplayTextParams) cmdParams).mTextMsg.text.equals(STK_DEFAULT))) {
                message = mContext.getText(com.android.internal.R.string.sending);
                ((DisplayTextParams) cmdParams).mTextMsg.text = message.toString();
            }
            break;
        case PLAY_TONE:
            break;
        case SET_UP_CALL:
            if ((((CallSetupParams) cmdParams).mConfirmMsg.text != null) && (((CallSetupParams) cmdParams).mConfirmMsg.text.equals(STK_DEFAULT))) {
                message = mContext.getText(com.android.internal.R.string.SetupCallDefault);
                ((CallSetupParams) cmdParams).mConfirmMsg.text = message.toString();
            }
            break;
        case LANGUAGE_NOTIFICATION:
            String language = ((LanguageParams) cmdParams).mLanguage;
            ResultCode result = ResultCode.OK;
            if (language != null && language.length() > 0) {
                try {
                    changeLanguage(language);
                } catch (RemoteException e) {
                    result = ResultCode.TERMINAL_CRNTLY_UNABLE_TO_PROCESS;
                }
            }
            sendTerminalResponse(cmdParams.mCmdDet, result, false, 0, null);
            return;
        case OPEN_CHANNEL:
        case CLOSE_CHANNEL:
        case RECEIVE_DATA:
        case SEND_DATA:
            BIPClientParams cmd = (BIPClientParams) cmdParams;
            /* Per 3GPP specification 102.223,
                 * if the alpha identifier is not provided by the UICC,
                 * the terminal MAY give information to the user
                 * noAlphaUsrCnf defines if you need to show user confirmation or not
                 */
            boolean noAlphaUsrCnf = false;
            try {
                noAlphaUsrCnf = mContext.getResources().getBoolean(com.android.internal.R.bool.config_stkNoAlphaUsrCnf);
            } catch (NotFoundException e) {
                noAlphaUsrCnf = false;
            }
            if ((cmd.mTextMsg.text == null) && (cmd.mHasAlphaId || noAlphaUsrCnf)) {
                CatLog.d(this, "cmd " + cmdParams.getCommandType() + " with null alpha id");
                // If alpha length is zero, we just respond with OK.
                if (isProactiveCmd) {
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, null);
                } else if (cmdParams.getCommandType() == CommandType.OPEN_CHANNEL) {
                    mCmdIf.handleCallSetupRequestFromSim(true, null);
                }
                return;
            }
            // Respond with permanent failure to avoid retry if STK app is not present.
            if (!mStkAppInstalled) {
                CatLog.d(this, "No STK application found.");
                if (isProactiveCmd) {
                    sendTerminalResponse(cmdParams.mCmdDet, ResultCode.BEYOND_TERMINAL_CAPABILITY, false, 0, null);
                    return;
                }
            }
            /*
                 * CLOSE_CHANNEL, RECEIVE_DATA and SEND_DATA can be delivered by
                 * either PROACTIVE_COMMAND or EVENT_NOTIFY.
                 * If PROACTIVE_COMMAND is used for those commands, send terminal
                 * response here.
                 */
            if (isProactiveCmd && ((cmdParams.getCommandType() == CommandType.CLOSE_CHANNEL) || (cmdParams.getCommandType() == CommandType.RECEIVE_DATA) || (cmdParams.getCommandType() == CommandType.SEND_DATA))) {
                sendTerminalResponse(cmdParams.mCmdDet, ResultCode.OK, false, 0, null);
            }
            break;
        default:
            CatLog.d(this, "Unsupported command");
            return;
    }
    mCurrntCmd = cmdMsg;
    broadcastCatCmdIntent(cmdMsg);
}
#end_block

#method_before
private void encodeOptionalTags(CommandDetails cmdDet, ResultCode resultCode, Input cmdInput, ByteArrayOutputStream buf) {
    CommandType cmdType = AppInterface.CommandType.fromInt(cmdDet.typeOfCommand);
    if (cmdType != null) {
        switch(cmdType) {
            case GET_INKEY:
                // occured, then add DURATION TLV for variable timeout case.
                if ((resultCode.value() == ResultCode.NO_RESPONSE_FROM_USER.value()) && (cmdInput != null) && (cmdInput.duration != null)) {
                    getInKeyResponse(buf, cmdInput);
                }
                break;
            case PROVIDE_LOCAL_INFORMATION:
                if ((cmdDet.commandQualifier == CommandParamsFactory.LANGUAGE_SETTING) && (resultCode.value() == ResultCode.OK.value())) {
                    getPliResponse(buf);
                }
                break;
            default:
                CatLog.d(this, "encodeOptionalTags() Unsupported Cmd details=" + cmdDet);
                break;
        }
    } else {
        CatLog.d(this, "encodeOptionalTags() bad Cmd details=" + cmdDet);
    }
}
#method_after
private void encodeOptionalTags(CommandDetails cmdDet, ResultCode resultCode, Input cmdInput, ByteArrayOutputStream buf) {
    CommandType cmdType = AppInterface.CommandType.fromInt(cmdDet.typeOfCommand);
    if (cmdType != null) {
        switch(cmdType) {
            case GET_INPUT:
            case GET_INKEY:
                // GET INPUT command should also be handled in the same manner.
                if ((resultCode.value() == ResultCode.NO_RESPONSE_FROM_USER.value()) && (cmdInput != null) && (cmdInput.duration != null)) {
                    getInKeyResponse(buf, cmdInput);
                }
                break;
            case PROVIDE_LOCAL_INFORMATION:
                if ((cmdDet.commandQualifier == CommandParamsFactory.LANGUAGE_SETTING) && (resultCode.value() == ResultCode.OK.value())) {
                    getPliResponse(buf);
                }
                break;
            default:
                CatLog.d(this, "encodeOptionalTags() Unsupported Cmd details=" + cmdDet);
                break;
        }
    } else {
        CatLog.d(this, "encodeOptionalTags() bad Cmd details=" + cmdDet);
    }
}
#end_block

#method_before
private void eventDownload(int event, int sourceId, int destinationId, byte[] additionalInfo, boolean oneShot) {
    ByteArrayOutputStream buf = new ByteArrayOutputStream();
    // tag
    int tag = BerTlv.BER_EVENT_DOWNLOAD_TAG;
    buf.write(tag);
    // length
    // place holder, assume length < 128.
    buf.write(0x00);
    // event list
    tag = 0x80 | ComprehensionTlvTag.EVENT_LIST.value();
    buf.write(tag);
    // length
    buf.write(0x01);
    // event value
    buf.write(event);
    // device identities
    tag = 0x80 | ComprehensionTlvTag.DEVICE_IDENTITIES.value();
    buf.write(tag);
    // length
    buf.write(0x02);
    // source device id
    buf.write(sourceId);
    // destination device id
    buf.write(destinationId);
    /* TODO: eventDownload should be extended for other Envelope Commands */
    switch(event) {
        case IDLE_SCREEN_AVAILABLE_EVENT:
            CatLog.d(sInstance, " Sending Idle Screen Available event download to ICC");
            break;
        case LANGUAGE_SELECTION_EVENT:
            CatLog.d(sInstance, " Sending Language Selection event download to ICC");
            tag = 0x80 | ComprehensionTlvTag.LANGUAGE.value();
            buf.write(tag);
            // Language length should be 2 byte
            buf.write(0x02);
            break;
        default:
            break;
    }
    // additional information
    if (additionalInfo != null) {
        for (byte b : additionalInfo) {
            buf.write(b);
        }
    }
    byte[] rawData = buf.toByteArray();
    // write real length
    // minus (tag + length)
    int len = rawData.length - 2;
    rawData[1] = (byte) len;
    String hexString = IccUtils.bytesToHexString(rawData);
    CatLog.d(this, "ENVELOPE COMMAND: " + hexString);
    mCmdIf.sendEnvelope(hexString, null);
}
#method_after
private void eventDownload(int event, int sourceId, int destinationId, byte[] additionalInfo, boolean oneShot) {
    ByteArrayOutputStream buf = new ByteArrayOutputStream();
    // tag
    int tag = BerTlv.BER_EVENT_DOWNLOAD_TAG;
    buf.write(tag);
    // length
    // place holder, assume length < 128.
    buf.write(0x00);
    // event list
    tag = 0x80 | ComprehensionTlvTag.EVENT_LIST.value();
    buf.write(tag);
    // length
    buf.write(0x01);
    // event value
    buf.write(event);
    // device identities
    tag = 0x80 | ComprehensionTlvTag.DEVICE_IDENTITIES.value();
    buf.write(tag);
    // length
    buf.write(0x02);
    // source device id
    buf.write(sourceId);
    // destination device id
    buf.write(destinationId);
    /* TODO: eventDownload should be extended for other Envelope Commands */
    switch(event) {
        case IDLE_SCREEN_AVAILABLE_EVENT:
            CatLog.d(sInstance, " Sending Idle Screen Available event download to ICC");
            break;
        case LANGUAGE_SELECTION_EVENT:
            CatLog.d(sInstance, " Sending Language Selection event download to ICC");
            tag = 0x80 | ComprehensionTlvTag.LANGUAGE.value();
            buf.write(tag);
            // Language length should be 2 byte
            buf.write(0x02);
            break;
        case USER_ACTIVITY_EVENT:
            break;
        default:
            break;
    }
    // additional information
    if (additionalInfo != null) {
        for (byte b : additionalInfo) {
            buf.write(b);
        }
    }
    byte[] rawData = buf.toByteArray();
    // write real length
    // minus (tag + length)
    int len = rawData.length - 2;
    rawData[1] = (byte) len;
    String hexString = IccUtils.bytesToHexString(rawData);
    CatLog.d(this, "ENVELOPE COMMAND: " + hexString);
    mCmdIf.sendEnvelope(hexString, null);
}
#end_block

#method_before
public void update(CommandsInterface ci, Context context, UiccCard ic) {
    UiccCardApplication ca = null;
    IccRecords ir = null;
    if (ic != null) {
        /* Since Cat is not tied to any application, but rather is Uicc application
             * in itself - just get first FileHandler and IccRecords object
             */
        ca = ic.getApplicationIndex(0);
        if (ca != null) {
            ir = ca.getIccRecords();
        }
    }
    synchronized (sInstanceLock) {
        if ((ir != null) && (mIccRecords != ir)) {
            if (mIccRecords != null) {
                mIccRecords.unregisterForRecordsLoaded(this);
            }
            CatLog.d(this, "Reinitialize the Service with SIMRecords and UiccCardApplication");
            mIccRecords = ir;
            mUiccApplication = ca;
            // re-Register for SIM ready event.
            mIccRecords.registerForRecordsLoaded(this, MSG_ID_ICC_RECORDS_LOADED, null);
            CatLog.d(this, "registerForRecordsLoaded slotid=" + mSlotId + " instance:" + this);
        }
    }
}
#method_after
public void update(CommandsInterface ci, Context context, UiccProfile uiccProfile) {
    UiccCardApplication ca = null;
    IccRecords ir = null;
    if (uiccProfile != null) {
        /* Since Cat is not tied to any application, but rather is Uicc application
             * in itself - just get first FileHandler and IccRecords object
             */
        ca = uiccProfile.getApplicationIndex(0);
        if (ca != null) {
            ir = ca.getIccRecords();
        }
    }
    synchronized (sInstanceLock) {
        if ((ir != null) && (mIccRecords != ir)) {
            if (mIccRecords != null) {
                mIccRecords.unregisterForRecordsLoaded(this);
            }
            CatLog.d(this, "Reinitialize the Service with SIMRecords and UiccCardApplication");
            mIccRecords = ir;
            mUiccApplication = ca;
            // re-Register for SIM ready event.
            mIccRecords.registerForRecordsLoaded(this, MSG_ID_ICC_RECORDS_LOADED, null);
            CatLog.d(this, "registerForRecordsLoaded slotid=" + mSlotId + " instance:" + this);
        }
    }
}
#end_block

#method_before
private boolean processGetInput(CommandDetails cmdDet, List<ComprehensionTlv> ctlvs) throws ResultException {
    CatLog.d(this, "process GetInput");
    Input input = new Input();
    IconId iconId = null;
    ComprehensionTlv ctlv = searchForTag(ComprehensionTlvTag.TEXT_STRING, ctlvs);
    if (ctlv != null) {
        input.text = ValueParser.retrieveTextString(ctlv);
    } else {
        throw new ResultException(ResultCode.REQUIRED_VALUES_MISSING);
    }
    ctlv = searchForTag(ComprehensionTlvTag.RESPONSE_LENGTH, ctlvs);
    if (ctlv != null) {
        try {
            byte[] rawValue = ctlv.getRawValue();
            int valueIndex = ctlv.getValueIndex();
            input.minLen = rawValue[valueIndex] & 0xff;
            input.maxLen = rawValue[valueIndex + 1] & 0xff;
        } catch (IndexOutOfBoundsException e) {
            throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
        }
    } else {
        throw new ResultException(ResultCode.REQUIRED_VALUES_MISSING);
    }
    ctlv = searchForTag(ComprehensionTlvTag.DEFAULT_TEXT, ctlvs);
    if (ctlv != null) {
        input.defaultText = ValueParser.retrieveTextString(ctlv);
    }
    // parse icon identifier
    ctlv = searchForTag(ComprehensionTlvTag.ICON_ID, ctlvs);
    if (ctlv != null) {
        iconId = ValueParser.retrieveIconId(ctlv);
        input.iconSelfExplanatory = iconId.selfExplanatory;
    }
    input.digitOnly = (cmdDet.commandQualifier & 0x01) == 0;
    input.ucs2 = (cmdDet.commandQualifier & 0x02) != 0;
    input.echo = (cmdDet.commandQualifier & 0x04) == 0;
    input.packed = (cmdDet.commandQualifier & 0x08) != 0;
    input.helpAvailable = (cmdDet.commandQualifier & 0x80) != 0;
    // be encoded. Limit depends on DCS in Command Qualifier.
    if (input.ucs2 && input.maxLen > MAX_UCS2_CHARS) {
        CatLog.d(this, "UCS2: received maxLen = " + input.maxLen + ", truncating to " + MAX_UCS2_CHARS);
        input.maxLen = MAX_UCS2_CHARS;
    } else if (!input.packed && input.maxLen > MAX_GSM7_DEFAULT_CHARS) {
        CatLog.d(this, "GSM 7Bit Default: received maxLen = " + input.maxLen + ", truncating to " + MAX_GSM7_DEFAULT_CHARS);
        input.maxLen = MAX_GSM7_DEFAULT_CHARS;
    }
    mCmdParams = new GetInputParams(cmdDet, input);
    if (iconId != null) {
        mloadIcon = true;
        mIconLoadState = LOAD_SINGLE_ICON;
        mIconLoader.loadIcon(iconId.recordNumber, this.obtainMessage(MSG_ID_LOAD_ICON_DONE));
        return true;
    }
    return false;
}
#method_after
private boolean processGetInput(CommandDetails cmdDet, List<ComprehensionTlv> ctlvs) throws ResultException {
    CatLog.d(this, "process GetInput");
    Input input = new Input();
    IconId iconId = null;
    ComprehensionTlv ctlv = searchForTag(ComprehensionTlvTag.TEXT_STRING, ctlvs);
    if (ctlv != null) {
        input.text = ValueParser.retrieveTextString(ctlv);
    } else {
        throw new ResultException(ResultCode.REQUIRED_VALUES_MISSING);
    }
    ctlv = searchForTag(ComprehensionTlvTag.RESPONSE_LENGTH, ctlvs);
    if (ctlv != null) {
        try {
            byte[] rawValue = ctlv.getRawValue();
            int valueIndex = ctlv.getValueIndex();
            input.minLen = rawValue[valueIndex] & 0xff;
            input.maxLen = rawValue[valueIndex + 1] & 0xff;
        } catch (IndexOutOfBoundsException e) {
            throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
        }
    } else {
        throw new ResultException(ResultCode.REQUIRED_VALUES_MISSING);
    }
    ctlv = searchForTag(ComprehensionTlvTag.DEFAULT_TEXT, ctlvs);
    if (ctlv != null) {
        input.defaultText = ValueParser.retrieveTextString(ctlv);
    }
    // parse icon identifier
    ctlv = searchForTag(ComprehensionTlvTag.ICON_ID, ctlvs);
    if (ctlv != null) {
        iconId = ValueParser.retrieveIconId(ctlv);
        input.iconSelfExplanatory = iconId.selfExplanatory;
    }
    ctlv = searchForTag(ComprehensionTlvTag.DURATION, ctlvs);
    if (ctlv != null) {
        input.duration = ValueParser.retrieveDuration(ctlv);
    }
    input.digitOnly = (cmdDet.commandQualifier & 0x01) == 0;
    input.ucs2 = (cmdDet.commandQualifier & 0x02) != 0;
    input.echo = (cmdDet.commandQualifier & 0x04) == 0;
    input.packed = (cmdDet.commandQualifier & 0x08) != 0;
    input.helpAvailable = (cmdDet.commandQualifier & 0x80) != 0;
    // be encoded. Limit depends on DCS in Command Qualifier.
    if (input.ucs2 && input.maxLen > MAX_UCS2_CHARS) {
        CatLog.d(this, "UCS2: received maxLen = " + input.maxLen + ", truncating to " + MAX_UCS2_CHARS);
        input.maxLen = MAX_UCS2_CHARS;
    } else if (!input.packed && input.maxLen > MAX_GSM7_DEFAULT_CHARS) {
        CatLog.d(this, "GSM 7Bit Default: received maxLen = " + input.maxLen + ", truncating to " + MAX_GSM7_DEFAULT_CHARS);
        input.maxLen = MAX_GSM7_DEFAULT_CHARS;
    }
    mCmdParams = new GetInputParams(cmdDet, input);
    if (iconId != null) {
        mloadIcon = true;
        mIconLoadState = LOAD_SINGLE_ICON;
        mIconLoader.loadIcon(iconId.recordNumber, this.obtainMessage(MSG_ID_LOAD_ICON_DONE));
        return true;
    }
    return false;
}
#end_block

#method_before
private short[] decodeToMemory(AudioParameter audioParams, int testinput, int resetMode, int configMode, int eossample, List<Long> timestamps) throws IOException {
    String localTag = TAG + "#decodeToMemory";
    Log.v(localTag, String.format("reset = %d; config: %s", resetMode, configMode));
    short[] decoded = new short[0];
    int decodedIdx = 0;
    AssetFileDescriptor testFd = mResources.openRawResourceFd(testinput);
    MediaExtractor extractor;
    MediaCodec codec;
    ByteBuffer[] codecInputBuffers;
    ByteBuffer[] codecOutputBuffers;
    extractor = new MediaExtractor();
    extractor.setDataSource(testFd.getFileDescriptor(), testFd.getStartOffset(), testFd.getLength());
    testFd.close();
    assertEquals("wrong number of tracks", 1, extractor.getTrackCount());
    MediaFormat format = extractor.getTrackFormat(0);
    String mime = format.getString(MediaFormat.KEY_MIME);
    assertTrue("not an audio file", mime.startsWith("audio/"));
    MediaFormat configFormat = format;
    codec = MediaCodec.createDecoderByType(mime);
    if (configMode == CONFIG_MODE_QUEUE && format.containsKey(CSD_KEYS[0])) {
        configFormat = MediaFormat.createAudioFormat(mime, format.getInteger(MediaFormat.KEY_SAMPLE_RATE), format.getInteger(MediaFormat.KEY_CHANNEL_COUNT));
        configFormat.setLong(MediaFormat.KEY_DURATION, format.getLong(MediaFormat.KEY_DURATION));
        String[] keys = new String[] { "max-input-size", "encoder-delay", "encoder-padding" };
        for (String k : keys) {
            if (format.containsKey(k)) {
                configFormat.setInteger(k, format.getInteger(k));
            }
        }
    }
    Log.v(localTag, "configuring with " + configFormat);
    codec.configure(configFormat, null, /* surface */
    null, /* crypto */
    0);
    codec.start();
    codecInputBuffers = codec.getInputBuffers();
    codecOutputBuffers = codec.getOutputBuffers();
    if (resetMode == RESET_MODE_RECONFIGURE) {
        codec.stop();
        codec.configure(configFormat, null, /* surface */
        null, /* crypto */
        0);
        codec.start();
        codecInputBuffers = codec.getInputBuffers();
        codecOutputBuffers = codec.getOutputBuffers();
    } else if (resetMode == RESET_MODE_FLUSH) {
        codec.flush();
    }
    extractor.selectTrack(0);
    if (configMode == CONFIG_MODE_QUEUE) {
        queueConfig(codec, format);
    }
    // start decoding
    MediaFormat outFormat = codec.getOutputFormat();
    int outWidth = outFormat.getInteger(MediaFormat.KEY_WIDTH);
    int outHeight = outFormat.getInteger(MediaFormat.KEY_HEIGHT);
    // 5ms timeout
    long kTimeOutUs = 5000;
    // in the 4K decoding case in byte buffer mode, set kTimeOutUs to 10ms
    if (outWidth >= 3840 && outHeight >= 2160 && surface == null) {
        kTimeOutUs = 10000;
    }
    MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();
    boolean sawInputEOS = false;
    boolean sawOutputEOS = false;
    int noOutputCounter = 0;
    int samplecounter = 0;
    while (!sawOutputEOS && noOutputCounter < 50) {
        noOutputCounter++;
        if (!sawInputEOS) {
            int inputBufIndex = codec.dequeueInputBuffer(kTimeOutUs);
            if (inputBufIndex >= 0) {
                ByteBuffer dstBuf = codecInputBuffers[inputBufIndex];
                int sampleSize = extractor.readSampleData(dstBuf, 0);
                long presentationTimeUs = 0;
                if (sampleSize < 0 && eossample > 0) {
                    fail("test is broken: never reached eos sample");
                }
                if (sampleSize < 0) {
                    Log.d(TAG, "saw input EOS.");
                    sawInputEOS = true;
                    sampleSize = 0;
                } else {
                    if (samplecounter == eossample) {
                        sawInputEOS = true;
                    }
                    samplecounter++;
                    presentationTimeUs = extractor.getSampleTime();
                }
                codec.queueInputBuffer(inputBufIndex, 0, /* offset */
                sampleSize, presentationTimeUs, sawInputEOS ? MediaCodec.BUFFER_FLAG_END_OF_STREAM : 0);
                if (!sawInputEOS) {
                    extractor.advance();
                }
            }
        }
        int res = codec.dequeueOutputBuffer(info, kTimeOutUs);
        if (res >= 0) {
            if (info.size > 0) {
                noOutputCounter = 0;
                if (timestamps != null) {
                    timestamps.add(info.presentationTimeUs);
                }
            }
            if (info.size > 0 && resetMode != RESET_MODE_NONE && resetMode != RESET_MODE_EOS_FLUSH) {
                // once we've gotten some data out of the decoder, reset and start again
                if (resetMode == RESET_MODE_RECONFIGURE) {
                    codec.stop();
                    codec.configure(configFormat, null, /* surface */
                    null, /* crypto */
                    0);
                    codec.start();
                    codecInputBuffers = codec.getInputBuffers();
                    codecOutputBuffers = codec.getOutputBuffers();
                    if (configMode == CONFIG_MODE_QUEUE) {
                        queueConfig(codec, format);
                    }
                } else /* resetMode == RESET_MODE_FLUSH */
                {
                    codec.flush();
                }
                resetMode = RESET_MODE_NONE;
                extractor.seekTo(0, MediaExtractor.SEEK_TO_NEXT_SYNC);
                sawInputEOS = false;
                samplecounter = 0;
                if (timestamps != null) {
                    timestamps.clear();
                }
                continue;
            }
            int outputBufIndex = res;
            ByteBuffer buf = codecOutputBuffers[outputBufIndex];
            if (decodedIdx + (info.size / 2) >= decoded.length) {
                decoded = Arrays.copyOf(decoded, decodedIdx + (info.size / 2));
            }
            buf.position(info.offset);
            for (int i = 0; i < info.size; i += 2) {
                decoded[decodedIdx++] = buf.getShort();
            }
            codec.releaseOutputBuffer(outputBufIndex, false);
            if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                Log.d(TAG, "saw output EOS.");
                if (resetMode == RESET_MODE_EOS_FLUSH) {
                    resetMode = RESET_MODE_NONE;
                    codec.flush();
                    extractor.seekTo(0, MediaExtractor.SEEK_TO_NEXT_SYNC);
                    sawInputEOS = false;
                    samplecounter = 0;
                    decoded = new short[0];
                    decodedIdx = 0;
                    if (timestamps != null) {
                        timestamps.clear();
                    }
                } else {
                    sawOutputEOS = true;
                }
            }
        } else if (res == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
            codecOutputBuffers = codec.getOutputBuffers();
            Log.d(TAG, "output buffers have changed.");
        } else if (res == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
            MediaFormat oformat = codec.getOutputFormat();
            audioParams.setNumChannels(oformat.getInteger(MediaFormat.KEY_CHANNEL_COUNT));
            audioParams.setSamplingRate(oformat.getInteger(MediaFormat.KEY_SAMPLE_RATE));
            Log.d(TAG, "output format has changed to " + oformat);
        } else {
            Log.d(TAG, "dequeueOutputBuffer returned " + res);
        }
    }
    if (noOutputCounter >= 50) {
        fail("decoder stopped outputing data");
    }
    codec.stop();
    codec.release();
    return decoded;
}
#method_after
private short[] decodeToMemory(AudioParameter audioParams, int testinput, int resetMode, int configMode, int eossample, List<Long> timestamps) throws IOException {
    String localTag = TAG + "#decodeToMemory";
    Log.v(localTag, String.format("reset = %d; config: %s", resetMode, configMode));
    short[] decoded = new short[0];
    int decodedIdx = 0;
    AssetFileDescriptor testFd = mResources.openRawResourceFd(testinput);
    MediaExtractor extractor;
    MediaCodec codec;
    ByteBuffer[] codecInputBuffers;
    ByteBuffer[] codecOutputBuffers;
    extractor = new MediaExtractor();
    extractor.setDataSource(testFd.getFileDescriptor(), testFd.getStartOffset(), testFd.getLength());
    testFd.close();
    assertEquals("wrong number of tracks", 1, extractor.getTrackCount());
    MediaFormat format = extractor.getTrackFormat(0);
    String mime = format.getString(MediaFormat.KEY_MIME);
    assertTrue("not an audio file", mime.startsWith("audio/"));
    MediaFormat configFormat = format;
    codec = MediaCodec.createDecoderByType(mime);
    if (configMode == CONFIG_MODE_QUEUE && format.containsKey(CSD_KEYS[0])) {
        configFormat = MediaFormat.createAudioFormat(mime, format.getInteger(MediaFormat.KEY_SAMPLE_RATE), format.getInteger(MediaFormat.KEY_CHANNEL_COUNT));
        configFormat.setLong(MediaFormat.KEY_DURATION, format.getLong(MediaFormat.KEY_DURATION));
        String[] keys = new String[] { "max-input-size", "encoder-delay", "encoder-padding" };
        for (String k : keys) {
            if (format.containsKey(k)) {
                configFormat.setInteger(k, format.getInteger(k));
            }
        }
    }
    Log.v(localTag, "configuring with " + configFormat);
    codec.configure(configFormat, null, /* surface */
    null, /* crypto */
    0);
    codec.start();
    codecInputBuffers = codec.getInputBuffers();
    codecOutputBuffers = codec.getOutputBuffers();
    if (resetMode == RESET_MODE_RECONFIGURE) {
        codec.stop();
        codec.configure(configFormat, null, /* surface */
        null, /* crypto */
        0);
        codec.start();
        codecInputBuffers = codec.getInputBuffers();
        codecOutputBuffers = codec.getOutputBuffers();
    } else if (resetMode == RESET_MODE_FLUSH) {
        codec.flush();
    }
    extractor.selectTrack(0);
    if (configMode == CONFIG_MODE_QUEUE) {
        queueConfig(codec, format);
    }
    // start decoding
    MediaFormat outFormat = codec.getOutputFormat();
    int outWidth = outFormat.getInteger(MediaFormat.KEY_WIDTH);
    int outHeight = outFormat.getInteger(MediaFormat.KEY_HEIGHT);
    // 5ms timeout
    long kTimeOutUs = 5000;
    // involve a memcpy
    if (outWidth * outHeight >= 8000000) {
        kTimeOutUs = 10000;
    }
    MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();
    boolean sawInputEOS = false;
    boolean sawOutputEOS = false;
    int noOutputCounter = 0;
    int samplecounter = 0;
    while (!sawOutputEOS && noOutputCounter < 50) {
        noOutputCounter++;
        if (!sawInputEOS) {
            int inputBufIndex = codec.dequeueInputBuffer(kTimeOutUs);
            if (inputBufIndex >= 0) {
                ByteBuffer dstBuf = codecInputBuffers[inputBufIndex];
                int sampleSize = extractor.readSampleData(dstBuf, 0);
                long presentationTimeUs = 0;
                if (sampleSize < 0 && eossample > 0) {
                    fail("test is broken: never reached eos sample");
                }
                if (sampleSize < 0) {
                    Log.d(TAG, "saw input EOS.");
                    sawInputEOS = true;
                    sampleSize = 0;
                } else {
                    if (samplecounter == eossample) {
                        sawInputEOS = true;
                    }
                    samplecounter++;
                    presentationTimeUs = extractor.getSampleTime();
                }
                codec.queueInputBuffer(inputBufIndex, 0, /* offset */
                sampleSize, presentationTimeUs, sawInputEOS ? MediaCodec.BUFFER_FLAG_END_OF_STREAM : 0);
                if (!sawInputEOS) {
                    extractor.advance();
                }
            }
        }
        int res = codec.dequeueOutputBuffer(info, kTimeOutUs);
        if (res >= 0) {
            if (info.size > 0) {
                noOutputCounter = 0;
                if (timestamps != null) {
                    timestamps.add(info.presentationTimeUs);
                }
            }
            if (info.size > 0 && resetMode != RESET_MODE_NONE && resetMode != RESET_MODE_EOS_FLUSH) {
                // once we've gotten some data out of the decoder, reset and start again
                if (resetMode == RESET_MODE_RECONFIGURE) {
                    codec.stop();
                    codec.configure(configFormat, null, /* surface */
                    null, /* crypto */
                    0);
                    codec.start();
                    codecInputBuffers = codec.getInputBuffers();
                    codecOutputBuffers = codec.getOutputBuffers();
                    if (configMode == CONFIG_MODE_QUEUE) {
                        queueConfig(codec, format);
                    }
                } else /* resetMode == RESET_MODE_FLUSH */
                {
                    codec.flush();
                }
                resetMode = RESET_MODE_NONE;
                extractor.seekTo(0, MediaExtractor.SEEK_TO_NEXT_SYNC);
                sawInputEOS = false;
                samplecounter = 0;
                if (timestamps != null) {
                    timestamps.clear();
                }
                continue;
            }
            int outputBufIndex = res;
            ByteBuffer buf = codecOutputBuffers[outputBufIndex];
            if (decodedIdx + (info.size / 2) >= decoded.length) {
                decoded = Arrays.copyOf(decoded, decodedIdx + (info.size / 2));
            }
            buf.position(info.offset);
            for (int i = 0; i < info.size; i += 2) {
                decoded[decodedIdx++] = buf.getShort();
            }
            codec.releaseOutputBuffer(outputBufIndex, false);
            if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                Log.d(TAG, "saw output EOS.");
                if (resetMode == RESET_MODE_EOS_FLUSH) {
                    resetMode = RESET_MODE_NONE;
                    codec.flush();
                    extractor.seekTo(0, MediaExtractor.SEEK_TO_NEXT_SYNC);
                    sawInputEOS = false;
                    samplecounter = 0;
                    decoded = new short[0];
                    decodedIdx = 0;
                    if (timestamps != null) {
                        timestamps.clear();
                    }
                } else {
                    sawOutputEOS = true;
                }
            }
        } else if (res == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
            codecOutputBuffers = codec.getOutputBuffers();
            Log.d(TAG, "output buffers have changed.");
        } else if (res == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
            MediaFormat oformat = codec.getOutputFormat();
            audioParams.setNumChannels(oformat.getInteger(MediaFormat.KEY_CHANNEL_COUNT));
            audioParams.setSamplingRate(oformat.getInteger(MediaFormat.KEY_SAMPLE_RATE));
            Log.d(TAG, "output format has changed to " + oformat);
        } else {
            Log.d(TAG, "dequeueOutputBuffer returned " + res);
        }
    }
    if (noOutputCounter >= 50) {
        fail("decoder stopped outputing data");
    }
    codec.stop();
    codec.release();
    return decoded;
}
#end_block

#method_before
@Override
public void start(String description, long duration) {
    assert description == null;
    this.description = description;
    this.duration = duration;
    this.progress = 0;
    display(description, 0);
}
#method_after
@Override
public void start(String description, long duration) {
    assert this.description == null;
    this.description = description;
    this.duration = duration;
    this.progress = 0;
    display(description, 0);
}
#end_block

#method_before
@Override
public void done() {
    update(duration);
    System.out.println("");
    this.description = null;
}
#method_after
@Override
public void done() {
    update(duration);
    System.out.println();
    this.description = null;
}
#end_block

#method_before
public Parser map(ProguardMap map) {
    this.map = map;
    return this;
}
#method_after
public Parser map(ProguardMap map) {
    if (map == null) {
        throw new NullPointerException("map == null");
    }
    this.map = map;
    return this;
}
#end_block

#method_before
public Parser progress(Progress progress) {
    this.progress = progress;
    return this;
}
#method_after
public Parser progress(Progress progress) {
    if (progress == null) {
        throw new NullPointerException("progress == null");
    }
    this.progress = progress;
    return this;
}
#end_block

#method_before
@Override
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    // If the user is logged out, allow them to log back in and return to the page.
    // Set the logout URL to direct back to a login page that directs to the current request.
    UserService userService = UserServiceFactory.getUserService();
    Optional<User> currentUser = Optional.ofNullable(userService.getCurrentUser());
    String currentUserEmail = currentUser.isPresent() ? currentUser.map(user -> user.getEmail().trim()).orElse("") : "";
    String requestUri = request.getRequestURI();
    String requestArgs = request.getQueryString();
    String loginURI = userService.createLoginURL(requestUri + '?' + requestArgs);
    String logoutURI = userService.createLogoutURL(loginURI);
    if (currentUserEmail != "") {
        int activeIndex;
        switch(getNavParentType()) {
            case PROFILING_LIST:
                activeIndex = 3;
                break;
            case COVERAGE_OVERVIEW:
                activeIndex = 2;
                break;
            case RELEASE:
                activeIndex = 1;
                break;
            default:
                activeIndex = 0;
                break;
        }
        if (request.getParameter(TREE_DEFAULT_PARAM) != null) {
            HttpSession session = request.getSession(true);
            boolean treeDefault = request.getParameter(TREE_DEFAULT_PARAM).equals("true");
            session.setAttribute(TREE_DEFAULT_PARAM, treeDefault);
        }
        request.setAttribute("serverName", request.getServerName());
        request.setAttribute("logoutURL", logoutURI);
        request.setAttribute("email", currentUserEmail);
        request.setAttribute("analyticsID", new Gson().toJson(ANALYTICS_ID));
        request.setAttribute("breadcrumbLinks", getBreadcrumbLinks(request));
        request.setAttribute("navbarLinks", navbarLinks);
        request.setAttribute("activeIndex", activeIndex);
        response.setContentType("text/html");
        if (currentUserEmail.endsWith("@google.com")) {
            doGetHandler(request, response);
        } else {
            RequestDispatcher dispatcher = request.getRequestDispatcher("WEB-INF/jsp/auth_error.jsp");
            try {
                dispatcher.forward(request, response);
            } catch (ServletException e) {
                logger.log(Level.SEVERE, "Servlet Exception caught : ", e);
            }
        }
    } else {
        response.sendRedirect(loginURI);
    }
}
#method_after
@Override
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    // If the user is logged out, allow them to log back in and return to the page.
    // Set the logout URL to direct back to a login page that directs to the current request.
    UserService userService = UserServiceFactory.getUserService();
    Optional<User> currentUser = Optional.ofNullable(userService.getCurrentUser());
    String currentUserEmail = currentUser.isPresent() ? currentUser.map(user -> user.getEmail().trim()).orElse("") : "";
    String requestUri = request.getRequestURI();
    String requestArgs = request.getQueryString();
    String loginURI = userService.createLoginURL(requestUri + '?' + requestArgs);
    String logoutURI = userService.createLogoutURL(loginURI);
    if (currentUserEmail != "") {
        int activeIndex;
        switch(getNavParentType()) {
            case PROFILING_LIST:
                activeIndex = 3;
                break;
            case COVERAGE_OVERVIEW:
                activeIndex = 2;
                break;
            case RELEASE:
                activeIndex = 1;
                break;
            default:
                activeIndex = 0;
                break;
        }
        if (request.getParameter(TREE_DEFAULT_PARAM) != null) {
            HttpSession session = request.getSession(true);
            boolean treeDefault = request.getParameter(TREE_DEFAULT_PARAM).equals("true");
            session.setAttribute(TREE_DEFAULT_PARAM, treeDefault);
        }
        request.setAttribute("serverName", request.getServerName());
        request.setAttribute("logoutURL", logoutURI);
        request.setAttribute("email", currentUserEmail);
        request.setAttribute("analyticsID", new Gson().toJson(ANALYTICS_ID));
        request.setAttribute("breadcrumbLinks", getBreadcrumbLinks(request));
        request.setAttribute("navbarLinks", navbarLinks);
        request.setAttribute("activeIndex", activeIndex);
        response.setContentType("text/html");
        if (currentUserEmail.endsWith("@google.com") || UserEntity.getUserList().contains(currentUserEmail)) {
            doGetHandler(request, response);
        } else {
            RequestDispatcher dispatcher = request.getRequestDispatcher("WEB-INF/jsp/auth_error.jsp");
            try {
                dispatcher.forward(request, response);
            } catch (ServletException e) {
                logger.log(Level.SEVERE, "Servlet Exception caught : ", e);
            }
        }
    } else {
        response.sendRedirect(loginURI);
    }
}
#end_block

#method_before
@Override
public void contextInitialized(ServletContextEvent servletContextEvent) {
    ObjectifyService.init();
    // ObjectifyFactory objectifyFactory = ObjectifyService.factory();
    ObjectifyService.register(TestSuiteFileEntity.class);
    ObjectifyService.register(TestSuiteResultEntity.class);
    ObjectifyService.register(UserEntity.class);
    ObjectifyService.begin();
    logger.log(Level.INFO, "Value Initialized from context.");
    Properties systemConfigProp = new Properties();
    try {
        InputStream defaultInputStream = ObjectifyListener.class.getClassLoader().getResourceAsStream("config.properties");
        systemConfigProp.load(defaultInputStream);
        String adminEmail = systemConfigProp.getProperty("user.adminEmail");
        if (adminEmail.isEmpty()) {
            logger.log(Level.WARNING, "Admin email is not properly set. Check config file");
        } else {
            String adminName = systemConfigProp.getProperty("user.adminName");
            String adminCompany = systemConfigProp.getProperty("user.adminCompany");
            Key key = Key.create(UserEntity.class, adminEmail);
            List<UserEntity> userEntityList = ofy().load().type(UserEntity.class).filterKey(key).filter("enable", true).filter("isAdmin", true).list();
            logger.log(Level.INFO, "found user ? => " + userEntityList.size());
            if (userEntityList.size() == 0) {
                UserEntity userEntity = new UserEntity(adminEmail, adminName, adminCompany);
                userEntity.setIsAdmin(true);
                userEntity.save();
                logger.log(Level.INFO, "user is saved!!!!!!!!!!!!");
            }
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
#method_after
@Override
public void contextInitialized(ServletContextEvent servletContextEvent) {
    ObjectifyService.init();
    ObjectifyService.register(TestSuiteFileEntity.class);
    ObjectifyService.register(TestSuiteResultEntity.class);
    ObjectifyService.register(UserEntity.class);
    ObjectifyService.begin();
    logger.log(Level.INFO, "Value Initialized from context.");
    Properties systemConfigProp = new Properties();
    try {
        InputStream defaultInputStream = ObjectifyListener.class.getClassLoader().getResourceAsStream("config.properties");
        systemConfigProp.load(defaultInputStream);
        String adminEmail = systemConfigProp.getProperty("user.adminEmail");
        if (adminEmail.isEmpty()) {
            logger.log(Level.WARNING, "Admin email is not properly set. Check config file");
        } else {
            String adminName = systemConfigProp.getProperty("user.adminName");
            String adminCompany = systemConfigProp.getProperty("user.adminCompany");
            if (UserEntity.getAdminUserList(adminEmail).size() == 0) {
                UserEntity userEntity = new UserEntity(adminEmail, adminName, adminCompany);
                userEntity.setIsAdmin(true);
                userEntity.save();
                logger.log(Level.INFO, "The user is saved successfully.");
            }
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
#end_block

