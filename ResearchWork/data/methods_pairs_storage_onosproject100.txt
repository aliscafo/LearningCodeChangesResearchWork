890
#method_before
@Activate
public void activate(ComponentContext context) {
    configService.registerProperties(getClass());
    nodeId = clusterService.getLocalNode().id();
    appId = coreService.registerApplication("org.onosproject.intentperf." + nodeId.toString());
    // TODO: replace with shared timer
    reportTimer = new Timer("onos-intent-perf-reporter");
    workers = Executors.newFixedThreadPool(DEFAULT_NUM_WORKERS, groupedThreads("onos/intent-perf", "worker-%d"));
    // disable flow backups for testing
    configService.setProperty("org.onosproject.store.flow.impl.newDistributedFlowRuleStore", "backupEnabled", "true");
    // TODO: replace with shared executor
    messageHandlingExecutor = Executors.newSingleThreadExecutor(groupedThreads("onos/perf", "command-handler"));
    communicationService.addSubscriber(CONTROL, new InternalControl(), messageHandlingExecutor);
    listener = new Listener();
    intentService.addListener(listener);
    // TODO: investigate why this seems to be necessary for configs to get picked up on initial activation
    modify(context);
}
#method_after
@Activate
public void activate(ComponentContext context) {
    configService.registerProperties(getClass());
    nodeId = clusterService.getLocalNode().id();
    appId = coreService.registerApplication("org.onosproject.intentperf." + nodeId.toString());
    // TODO: replace with shared timer
    reportTimer = new Timer("onos-intent-perf-reporter");
    workers = Executors.newFixedThreadPool(DEFAULT_NUM_WORKERS, groupedThreads("onos/intent-perf", "worker-%d"));
    // disable flow backups for testing
    configService.setProperty("org.onosproject.store.flow.impl.NewDistributedFlowRuleStore", "backupEnabled", "true");
    // TODO: replace with shared executor
    messageHandlingExecutor = Executors.newSingleThreadExecutor(groupedThreads("onos/perf", "command-handler"));
    communicationService.addSubscriber(CONTROL, new InternalControl(), messageHandlingExecutor);
    listener = new Listener();
    intentService.addListener(listener);
    // TODO: investigate why this seems to be necessary for configs to get picked up on initial activation
    modify(context);
}
#end_block

#method_before
public static void processHello(Ethernet ethPkt, ConnectPoint receivedFrom) {
    MacAddress srcmac = ethPkt.getSourceMAC();
    IPv4 ip = (IPv4) ethPkt.getPayload();
    Ip4Address srcip = Ip4Address.valueOf(ip.getSourceAddress());
    PIM pim = (PIM) ip.getPayload();
    PIMHello hello = (PIMHello) pim.getPayload();
    PIMNeighbor nbr = PIMNeighbors.findOrCreate(srcip, srcmac, receivedFrom);
    if (nbr == null) {
        log.error("Could not create a neighbor for: {1}", srcip.toString());
        return;
    }
    nbr.setConnectPoint(receivedFrom);
    nbr.refresh(hello);
}
#method_after
public static void processHello(Ethernet ethPkt, ConnectPoint receivedFrom) {
    checkNotNull(ethPkt);
    checkNotNull(ethPkt);
    MacAddress srcmac = ethPkt.getSourceMAC();
    IPv4 ip = (IPv4) ethPkt.getPayload();
    Ip4Address srcip = Ip4Address.valueOf(ip.getSourceAddress());
    PIM pim = (PIM) ip.getPayload();
    checkNotNull(pim);
    PIMHello hello = (PIMHello) pim.getPayload();
    checkNotNull(hello);
    PIMNeighbor nbr = PIMNeighbors.findOrCreate(srcip, srcmac, receivedFrom);
    if (nbr == null) {
        log.error("Could not create a neighbor for: {1}", srcip.toString());
        return;
    }
    nbr.setConnectPoint(receivedFrom);
    nbr.refresh(hello);
}
#end_block

#method_before
public void addNeighbor(PIMNeighbor nbr) {
    if (neighbors.containsKey(nbr.getPrimaryAddr())) {
        // TODO: this is really a bug.
        neighbors.remove(nbr.getPrimaryAddr(), nbr);
    }
    nbr.setNeighbors(this);
    neighbors.put(nbr.getPrimaryAddr(), nbr);
}
#method_after
public void addNeighbor(PIMNeighbor nbr) {
    if (neighbors.containsKey(nbr.getPrimaryAddr())) {
        // TODO: Hmmm, how should this be handled?
        log.debug("We are adding a neighbor that already exists: {}", nbr.toString());
        neighbors.remove(nbr.getPrimaryAddr(), nbr);
    }
    nbr.setNeighbors(this);
    neighbors.put(nbr.getPrimaryAddr(), nbr);
}
#end_block

#method_before
private void sendHelloPacket() {
    PIMHello hello = new PIMHello();
// TODO: we will need to implement the network config service to assign ip addresses
// and such from a config file./
/*
        hello.createDefaultOptions();

        Ethernet eth = hello.createPIMHello(this.ourIpAddress);
        hello.sendPacket(this.connectPoint);
        */
}
#method_after
private void sendHelloPacket() {
    PIMHello hello = new PIMHello();
// TODO: we will need to implement the network config service to assign ip addresses & options
/*
        hello.createDefaultOptions();

        Ethernet eth = hello.createPIMHello(this.ourIpAddress);
        hello.sendPacket(this.connectPoint);
        */
}
#end_block

#method_before
public String toString() {
    String out = "PIM Neighbors: ";
    if (this.ourIpAddress != null) {
        out += "IP: " + this.ourIpAddress.toString();
    } else {
        out += "IP: *Null*";
    }
    out += "\tPR: " + String.valueOf(this.ourPriority) + "\n";
    return out;
}
#method_after
@Override
public String toString() {
    String out = "PIM Neighbors: ";
    if (this.ourIpAddress != null) {
        out += "IP: " + this.ourIpAddress.toString();
    } else {
        out += "IP: *Null*";
    }
    out += "\tPR: " + String.valueOf(this.ourPriority) + "\n";
    return out;
}
#end_block

#method_before
public void refresh(PIMHello hello) {
    for (PIMHelloOption opt : hello.getOptions().values()) {
        int len = opt.getOptLength();
        byte[] value = new byte[len];
        ByteBuffer bb = ByteBuffer.wrap(value);
        switch(opt.getOptType()) {
            case PIMHelloOption.OPT_GENID:
                int newid = bb.getInt();
                if (this.genId != newid) {
                    // TODO: we have a newly rebooted neighbor.  Send them our joins.
                    this.genId = newid;
                }
                break;
            case PIMHelloOption.OPT_PRIORITY:
                int newpri = bb.getInt();
                if (this.priority != newpri) {
                    // The priorities have changed.  We may need to re-elect a new DR?
                    if (this.isDr || this.neighbors.getDesignatedRouter().getPriority() < priority) {
                        reelect = true;
                    }
                    this.priority = newpri;
                }
                break;
            case PIMHelloOption.OPT_HOLDTIME:
                short holdtime = bb.getShort();
                if (this.holdtime != holdtime) {
                    this.holdtime = holdtime;
                    if (holdtime == 0) {
                        // TODO: What else do we need to do when a neighbor goes down?
                        return;
                    }
                }
                break;
            case PIMHelloOption.OPT_PRUNEDELAY:
            case PIMHelloOption.OPT_ADDRLIST:
            default:
                log.debug("PIM Hello option type: {} not yet supported or unknown.", opt.getOptType());
                break;
        }
    }
    if (reelect) {
        this.neighbors.electDR(this);
    }
    // Reset the next timeout timer
    this.resetTimeout();
}
#method_after
public void refresh(PIMHello hello) {
    checkNotNull(hello);
    for (PIMHelloOption opt : hello.getOptions().values()) {
        int len = opt.getOptLength();
        byte[] value = new byte[len];
        ByteBuffer bb = ByteBuffer.wrap(value);
        switch(opt.getOptType()) {
            case PIMHelloOption.OPT_GENID:
                int newid = bb.getInt();
                if (this.genId != newid) {
                    // TODO: we have a newly rebooted neighbor.  Send them our joins.
                    this.genId = newid;
                }
                break;
            case PIMHelloOption.OPT_PRIORITY:
                int newpri = bb.getInt();
                if (this.priority != newpri) {
                    // The priorities have changed.  We may need to re-elect a new DR?
                    if (this.isDr || this.neighbors.getDesignatedRouter().getPriority() < priority) {
                        reelect = true;
                    }
                    this.priority = newpri;
                }
                break;
            case PIMHelloOption.OPT_HOLDTIME:
                short holdtime = bb.getShort();
                if (this.holdtime != holdtime) {
                    this.holdtime = holdtime;
                    if (holdtime == 0) {
                        // We have a neighbor going down.  We can remove all joins
                        // we have learned from them.
                        // TODO: What else do we need to do when a neighbor goes down?
                        log.debug("PIM Neighbor has timed out: {}", this.primaryAddr.toString());
                        return;
                    }
                }
                break;
            case PIMHelloOption.OPT_PRUNEDELAY:
            case PIMHelloOption.OPT_ADDRLIST:
            default:
                log.debug("PIM Hello option type: {} not yet supported or unknown.", opt.getOptType());
                break;
        }
    }
    if (reelect) {
        this.neighbors.electDR(this);
    }
    // Reset the next timeout timer
    this.resetTimeout();
}
#end_block

#method_before
/* --------------------------------------- Timer functions -------------------------- */
private void resetTimeout() {
    if (this.holdtime == 0) {
        // log("shutting down timer for nbr");
        if (this.timeout != null) {
            this.timeout.cancel();
            this.timeout = null;
        }
        return;
    }
    // Cancel the existing timeout and start a fresh new one.
    if (this.timeout != null) {
        this.timeout.cancel();
    }
    this.timeout = PIMTimer.getTimer().newTimeout(new NeighborTimeoutTask(this), holdtime, TimeUnit.SECONDS);
}
#method_after
/* --------------------------------------- Timer functions -------------------------- */
private void resetTimeout() {
    if (this.holdtime == 0) {
        // Prepare to die.
        log.debug("shutting down timer for nbr {}", this.primaryAddr.toString());
        if (this.timeout != null) {
            this.timeout.cancel();
            this.timeout = null;
        }
        return;
    }
    // Cancel the existing timeout and start a fresh new one.
    if (this.timeout != null) {
        this.timeout.cancel();
    }
    this.timeout = PIMTimer.getTimer().newTimeout(new NeighborTimeoutTask(this), holdtime, TimeUnit.SECONDS);
}
#end_block

#method_before
public String toString() {
    String out = "";
    if (this.isDr) {
        out += "*NBR:";
    } else {
        out += "NBR:";
    }
    out += "\tIP: " + this.primaryAddr.toString();
    out += "\tPr: " + String.valueOf(this.priority);
    out += "\tHoldTime: " + String.valueOf(this.holdtime);
    out += "\tGenID: " + String.valueOf(this.genId) + "\n";
    return out;
}
#method_after
@Override
public String toString() {
    String out = "";
    if (this.isDr) {
        out += "*NBR:";
    } else {
        out += "NBR:";
    }
    out += "\tIP: " + this.primaryAddr.toString();
    out += "\tPr: " + String.valueOf(this.priority);
    out += "\tHoldTime: " + String.valueOf(this.holdtime);
    out += "\tGenID: " + String.valueOf(this.genId) + "\n";
    return out;
}
#end_block

#method_before
private static synchronized void initTimer() {
    if (PIMTimer.timer == null) {
        HashedWheelTimer hwTimer = new HashedWheelTimer();
        hwTimer.start();
        PIMTimer.timer = hwTimer;
    }
}
#method_after
private static synchronized void initTimer() {
    if (PIMTimer.timer == null) {
        // Create and start a new hashed wheel timer, if it does not exist.
        HashedWheelTimer hwTimer = new HashedWheelTimer();
        hwTimer.start();
        PIMTimer.timer = hwTimer;
    }
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    // can't do any more to it.
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethPkt = pkt.parsed();
    if (ethPkt == null) {
        return;
    }
    /*
             * IPv6 MLD packets are handled by ICMP6. We'll only deal
             * with IPv4.
             */
    if (ethPkt.getEtherType() != Ethernet.TYPE_IPV4) {
        return;
    }
    IPv4 ip = (IPv4) ethPkt.getPayload();
    IpAddress gaddr = IpAddress.valueOf(ip.getDestinationAddress());
    IpAddress saddr = Ip4Address.valueOf(ip.getSourceAddress());
    log.debug("Packet (" + saddr.toString() + ", " + gaddr.toString() + "\tingress port: " + context.inPacket().receivedFrom().toString());
    if (ip.getProtocol() != IPv4.PROTOCOL_PIM) {
        log.debug("PIM Picked up a non PIM packet: IP protocol: " + ip.getProtocol());
        return;
    }
    // TODO: check incoming to be PIM.PIM_ADDRESS or "Our" address.
    IpPrefix spfx = IpPrefix.valueOf(saddr, 32);
    IpPrefix gpfx = IpPrefix.valueOf(gaddr, 32);
    PIM pim = (PIM) ip.getPayload();
    switch(pim.getPimMsgType()) {
        case PIM.TYPE_HELLO:
            PIMNeighbors.processHello(ethPkt, context.inPacket().receivedFrom());
            break;
        case PIM.TYPE_JOIN_PRUNE_REQUEST:
            // Create the function
            break;
        case PIM.TYPE_ASSERT:
        case PIM.TYPE_BOOTSTRAP:
        case PIM.TYPE_CANDIDATE_RP_ADV:
        case PIM.TYPE_GRAFT:
        case PIM.TYPE_GRAFT_ACK:
        case PIM.TYPE_REGISTER:
        case PIM.TYPE_REGISTER_STOP:
            log.debug("Unsupported PIM message type: " + pim.getPimMsgType());
            break;
        default:
            log.debug("Unkown PIM message type: " + pim.getPimMsgType());
            break;
    }
}
#method_after
@Override
public void process(PacketContext context) {
    // can't do any more to it.
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    if (pkt == null) {
        return;
    }
    Ethernet ethPkt = pkt.parsed();
    if (ethPkt == null) {
        return;
    }
    /*
             * IPv6 MLD packets are handled by ICMP6. We'll only deal
             * with IPv4.
             */
    if (ethPkt.getEtherType() != Ethernet.TYPE_IPV4) {
        return;
    }
    IPv4 ip = (IPv4) ethPkt.getPayload();
    IpAddress gaddr = IpAddress.valueOf(ip.getDestinationAddress());
    IpAddress saddr = Ip4Address.valueOf(ip.getSourceAddress());
    log.debug("Packet (" + saddr.toString() + ", " + gaddr.toString() + "\tingress port: " + context.inPacket().receivedFrom().toString());
    if (ip.getProtocol() != IPv4.PROTOCOL_PIM) {
        log.debug("PIM Picked up a non PIM packet: IP protocol: " + ip.getProtocol());
        return;
    }
    // TODO: check incoming to be PIM.PIM_ADDRESS or "Our" address.
    IpPrefix spfx = IpPrefix.valueOf(saddr, 32);
    IpPrefix gpfx = IpPrefix.valueOf(gaddr, 32);
    PIM pim = (PIM) ip.getPayload();
    switch(pim.getPimMsgType()) {
        case PIM.TYPE_HELLO:
            PIMNeighbors.processHello(ethPkt, context.inPacket().receivedFrom());
            break;
        case PIM.TYPE_JOIN_PRUNE_REQUEST:
            // Create the function
            break;
        case PIM.TYPE_ASSERT:
        case PIM.TYPE_BOOTSTRAP:
        case PIM.TYPE_CANDIDATE_RP_ADV:
        case PIM.TYPE_GRAFT:
        case PIM.TYPE_GRAFT_ACK:
        case PIM.TYPE_REGISTER:
        case PIM.TYPE_REGISTER_STOP:
            log.debug("Unsupported PIM message type: " + pim.getPimMsgType());
            break;
        default:
            log.debug("Unkown PIM message type: " + pim.getPimMsgType());
            break;
    }
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    providerService = providerRegistry.register(this);
    controller.addListener(listener);
    controller.addEventListener(listener);
    pendingBatches = createBatchCache();
    createCollectors();
    log.info("Started");
}
#method_after
@Activate
public void activate(ComponentContext context) {
    cfgService.registerProperties(getClass());
    providerService = providerRegistry.register(this);
    controller.addListener(listener);
    controller.addEventListener(listener);
    pendingBatches = createBatchCache();
    createCollectors();
    log.info("Started with flowPollFrequency = {}, adaptiveFlowSampling = {}", flowPollFrequency, adaptiveFlowSampling);
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    int newFlowPollFrequency;
    try {
        String s = get(properties, "flowPollFrequency");
        newFlowPollFrequency = isNullOrEmpty(s) ? flowPollFrequency : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        newFlowPollFrequency = flowPollFrequency;
    }
    if (newFlowPollFrequency != flowPollFrequency) {
        flowPollFrequency = newFlowPollFrequency;
        adjustRate();
    }
    log.info("Settings: flowPollFrequency={}", flowPollFrequency);
}
#method_after
@Modified
public void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    int newFlowPollFrequency;
    try {
        String s = get(properties, "flowPollFrequency");
        newFlowPollFrequency = isNullOrEmpty(s) ? flowPollFrequency : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        newFlowPollFrequency = flowPollFrequency;
    }
    if (newFlowPollFrequency != flowPollFrequency) {
        flowPollFrequency = newFlowPollFrequency;
        adjustRate();
    }
    log.info("Settings: flowPollFrequency={}", flowPollFrequency);
    boolean newAdaptiveFlowSampling;
    String s = get(properties, "adaptiveFlowSampling");
    newAdaptiveFlowSampling = isNullOrEmpty(s) ? adaptiveFlowSampling : Boolean.parseBoolean(s.trim());
    if (newAdaptiveFlowSampling != adaptiveFlowSampling) {
        // stop previous collector
        stopCollectors();
        adaptiveFlowSampling = newAdaptiveFlowSampling;
        // create new collectors
        createCollectors();
    }
    log.info("Settings: adaptiveFlowSampling={}", adaptiveFlowSampling);
}
#end_block

#method_before
private void createCollector(OpenFlowSwitch sw) {
    // NewAdaptiveFlowStatsCollector Constructor
    NewAdaptiveFlowStatsCollector fsc = new NewAdaptiveFlowStatsCollector(sw, flowPollFrequency);
    fsc.start();
    collectors.put(new Dpid(sw.getId()), fsc);
}
#method_after
private void createCollector(OpenFlowSwitch sw) {
    if (adaptiveFlowSampling) {
        // NewAdaptiveFlowStatsCollector Constructor
        NewAdaptiveFlowStatsCollector fsc = new NewAdaptiveFlowStatsCollector(sw, flowPollFrequency);
        fsc.start();
        afsCollectors.put(new Dpid(sw.getId()), fsc);
    } else {
        FlowStatsCollector fsc = new FlowStatsCollector(timer, sw, flowPollFrequency);
        fsc.start();
        simpleCollectors.put(new Dpid(sw.getId()), fsc);
    }
}
#end_block

#method_before
private void stopCollectors() {
    // NewAdaptiveFlowStatsCollector Destructor
    collectors.values().forEach(NewAdaptiveFlowStatsCollector::stop);
    collectors.clear();
}
#method_after
private void stopCollectors() {
    if (adaptiveFlowSampling) {
        // NewAdaptiveFlowStatsCollector Destructor
        afsCollectors.values().forEach(NewAdaptiveFlowStatsCollector::stop);
        afsCollectors.clear();
    } else {
        simpleCollectors.values().forEach(FlowStatsCollector::stop);
        simpleCollectors.clear();
    }
}
#end_block

#method_before
private void adjustRate() {
    DefaultLoad.setPollInterval(flowPollFrequency);
    // NewAdaptiveFlowStatsCollector calAndPollInterval
    collectors.values().forEach(fsc -> fsc.adjustCalAndPollInterval(flowPollFrequency));
}
#method_after
private void adjustRate() {
    DefaultLoad.setPollInterval(flowPollFrequency);
    if (adaptiveFlowSampling) {
        // NewAdaptiveFlowStatsCollector calAndPollInterval
        afsCollectors.values().forEach(fsc -> fsc.adjustCalAndPollInterval(flowPollFrequency));
    } else {
        simpleCollectors.values().forEach(fsc -> fsc.adjustPollInterval(flowPollFrequency));
    }
}
#end_block

#method_before
private void applyRule(FlowRule flowRule) {
    Dpid dpid = Dpid.dpid(flowRule.deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    FlowRuleExtPayLoad flowRuleExtPayLoad = flowRule.payLoad();
    if (hasPayload(flowRuleExtPayLoad)) {
        OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
        sw.sendMsg(msg);
        return;
    }
    sw.sendMsg(FlowModBuilder.builder(flowRule, sw.factory(), Optional.empty()).buildFlowAdd());
    // 
    // Add TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
    // 
    collectors.get(dpid).addWithFlowRule(flowRule);
}
#method_after
private void applyRule(FlowRule flowRule) {
    Dpid dpid = Dpid.dpid(flowRule.deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    FlowRuleExtPayLoad flowRuleExtPayLoad = flowRule.payLoad();
    if (hasPayload(flowRuleExtPayLoad)) {
        OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
        sw.sendMsg(msg);
        return;
    }
    sw.sendMsg(FlowModBuilder.builder(flowRule, sw.factory(), Optional.empty()).buildFlowAdd());
    if (adaptiveFlowSampling) {
        // Add TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
        afsCollectors.get(dpid).addWithFlowRule(flowRule);
    }
}
#end_block

#method_before
private void removeRule(FlowRule flowRule) {
    Dpid dpid = Dpid.dpid(flowRule.deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    FlowRuleExtPayLoad flowRuleExtPayLoad = flowRule.payLoad();
    if (hasPayload(flowRuleExtPayLoad)) {
        OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
        sw.sendMsg(msg);
        return;
    }
    sw.sendMsg(FlowModBuilder.builder(flowRule, sw.factory(), Optional.empty()).buildFlowDel());
    // 
    // Remove TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
    // 
    collectors.get(dpid).removeFlows(flowRule);
}
#method_after
private void removeRule(FlowRule flowRule) {
    Dpid dpid = Dpid.dpid(flowRule.deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    FlowRuleExtPayLoad flowRuleExtPayLoad = flowRule.payLoad();
    if (hasPayload(flowRuleExtPayLoad)) {
        OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
        sw.sendMsg(msg);
        return;
    }
    sw.sendMsg(FlowModBuilder.builder(flowRule, sw.factory(), Optional.empty()).buildFlowDel());
    if (adaptiveFlowSampling) {
        // Remove TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
        afsCollectors.get(dpid).removeFlows(flowRule);
    }
}
#end_block

#method_before
@Override
public void executeBatch(FlowRuleBatchOperation batch) {
    pendingBatches.put(batch.id(), new InternalCacheEntry(batch));
    Dpid dpid = Dpid.dpid(batch.deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    OFFlowMod mod;
    for (FlowRuleBatchEntry fbe : batch.getOperations()) {
        // flow is the third party privacy flow
        FlowRuleExtPayLoad flowRuleExtPayLoad = fbe.target().payLoad();
        if (hasPayload(flowRuleExtPayLoad)) {
            OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
            sw.sendMsg(msg);
            continue;
        }
        FlowModBuilder builder = FlowModBuilder.builder(fbe.target(), sw.factory(), Optional.of(batch.id()));
        switch(fbe.operator()) {
            case ADD:
                mod = builder.buildFlowAdd();
                // 
                // Add TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
                // 
                collectors.get(dpid).addWithFlowRule(fbe.target());
                break;
            case REMOVE:
                mod = builder.buildFlowDel();
                // 
                // Remove TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
                // 
                collectors.get(dpid).removeFlows(fbe.target());
                break;
            case MODIFY:
                mod = builder.buildFlowMod();
                // 
                // Add or Update TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
                // 
                collectors.get(dpid).addWithFlowRule(fbe.target());
                break;
            default:
                log.error("Unsupported batch operation {}; skipping flowmod {}", fbe.operator(), fbe);
                continue;
        }
        sw.sendMsg(mod);
    }
    OFBarrierRequest.Builder builder = sw.factory().buildBarrierRequest().setXid(batch.id());
    sw.sendMsg(builder.build());
}
#method_after
@Override
public void executeBatch(FlowRuleBatchOperation batch) {
    checkNotNull(batch);
    pendingBatches.put(batch.id(), new InternalCacheEntry(batch));
    Dpid dpid = Dpid.dpid(batch.deviceId().uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    OFFlowMod mod;
    for (FlowRuleBatchEntry fbe : batch.getOperations()) {
        // flow is the third party privacy flow
        FlowRuleExtPayLoad flowRuleExtPayLoad = fbe.target().payLoad();
        if (hasPayload(flowRuleExtPayLoad)) {
            OFMessage msg = new ThirdPartyMessage(flowRuleExtPayLoad.payLoad());
            sw.sendMsg(msg);
            continue;
        }
        FlowModBuilder builder = FlowModBuilder.builder(fbe.target(), sw.factory(), Optional.of(batch.id()));
        switch(fbe.operator()) {
            case ADD:
                mod = builder.buildFlowAdd();
                if (adaptiveFlowSampling) {
                    // Add TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
                    afsCollectors.get(dpid).addWithFlowRule(fbe.target());
                }
                break;
            case REMOVE:
                mod = builder.buildFlowDel();
                if (adaptiveFlowSampling) {
                    // Remove TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
                    afsCollectors.get(dpid).removeFlows(fbe.target());
                }
                break;
            case MODIFY:
                mod = builder.buildFlowMod();
                if (adaptiveFlowSampling) {
                    // Add or Update TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
                    // afsCollectors.get(dpid).addWithFlowRule(fbe.target()); //check if add is good or not
                    afsCollectors.get(dpid).addOrUpdateFlows((FlowEntry) fbe.target());
                }
                break;
            default:
                log.error("Unsupported batch operation {}; skipping flowmod {}", fbe.operator(), fbe);
                continue;
        }
        sw.sendMsg(mod);
    }
    OFBarrierRequest.Builder builder = sw.factory().buildBarrierRequest().setXid(batch.id());
    sw.sendMsg(builder.build());
}
#end_block

#method_before
@Override
public void switchAdded(Dpid dpid) {
    createCollector(controller.getSwitch(dpid));
}
#method_after
@Override
public void switchAdded(Dpid dpid) {
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    createCollector(controller.getSwitch(dpid));
}
#end_block

#method_before
@Override
public void switchRemoved(Dpid dpid) {
    NewAdaptiveFlowStatsCollector collector = collectors.remove(dpid);
    if (collector != null) {
        collector.stop();
    }
}
#method_after
@Override
public void switchRemoved(Dpid dpid) {
    if (adaptiveFlowSampling) {
        NewAdaptiveFlowStatsCollector collector = afsCollectors.remove(dpid);
        if (collector != null) {
            collector.stop();
        }
    } else {
        FlowStatsCollector collector = simpleCollectors.remove(dpid);
        if (collector != null) {
            collector.stop();
        }
    }
}
#end_block

#method_before
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    switch(msg.getType()) {
        case FLOW_REMOVED:
            OFFlowRemoved removed = (OFFlowRemoved) msg;
            FlowEntry fr = new FlowEntryBuilder(dpid, removed).build();
            providerService.flowRemoved(fr);
            // 
            // Removed TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
            // 
            collectors.get(dpid).flowRemoved(fr);
            break;
        case STATS_REPLY:
            if (((OFStatsReply) msg).getStatsType() == OFStatsType.FLOW) {
                pushFlowMetrics(dpid, (OFFlowStatsReply) msg);
            }
            break;
        case BARRIER_REPLY:
            try {
                InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                if (entry != null) {
                    providerService.batchOperationCompleted(msg.getXid(), entry.completed());
                } else {
                    log.warn("Received unknown Barrier Reply: {}", msg.getXid());
                }
            } finally {
                pendingBatches.invalidate(msg.getXid());
            }
            break;
        case ERROR:
            // TODO: This needs to get suppressed in a better way.
            if (msg instanceof OFBadRequestErrorMsg && ((OFBadRequestErrorMsg) msg).getCode() == OFBadRequestCode.BAD_TYPE) {
                log.debug("Received error message {} from {}", msg, dpid);
            } else {
                log.warn("Received error message {} from {}", msg, dpid);
            }
            OFErrorMsg error = (OFErrorMsg) msg;
            if (error.getErrType() == OFErrorType.FLOW_MOD_FAILED) {
                OFFlowModFailedErrorMsg fmFailed = (OFFlowModFailedErrorMsg) error;
                if (fmFailed.getData().getParsedMessage().isPresent()) {
                    OFMessage m = fmFailed.getData().getParsedMessage().get();
                    OFFlowMod fm = (OFFlowMod) m;
                    InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                    if (entry != null) {
                        entry.appendFailure(new FlowEntryBuilder(dpid, fm).build());
                    } else {
                        log.error("No matching batch for this error: {}", error);
                    }
                } else {
                    // FIXME: Potentially add flowtracking to avoid this message.
                    log.error("Flow installation failed but switch didn't" + " tell us which one.");
                }
            }
        default:
            log.debug("Unhandled message type: {}", msg.getType());
    }
}
#method_after
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    switch(msg.getType()) {
        case FLOW_REMOVED:
            OFFlowRemoved removed = (OFFlowRemoved) msg;
            FlowEntry fr = new FlowEntryBuilder(dpid, removed).build();
            providerService.flowRemoved(fr);
            if (adaptiveFlowSampling) {
                // Removed TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
                afsCollectors.get(dpid).flowRemoved(fr);
            }
            break;
        case STATS_REPLY:
            if (((OFStatsReply) msg).getStatsType() == OFStatsType.FLOW) {
                pushFlowMetrics(dpid, (OFFlowStatsReply) msg);
            }
            break;
        case BARRIER_REPLY:
            try {
                InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                if (entry != null) {
                    providerService.batchOperationCompleted(msg.getXid(), entry.completed());
                } else {
                    log.warn("Received unknown Barrier Reply: {}", msg.getXid());
                }
            } finally {
                pendingBatches.invalidate(msg.getXid());
            }
            break;
        case ERROR:
            // TODO: This needs to get suppressed in a better way.
            if (msg instanceof OFBadRequestErrorMsg && ((OFBadRequestErrorMsg) msg).getCode() == OFBadRequestCode.BAD_TYPE) {
                log.debug("Received error message {} from {}", msg, dpid);
            } else {
                log.warn("Received error message {} from {}", msg, dpid);
            }
            OFErrorMsg error = (OFErrorMsg) msg;
            if (error.getErrType() == OFErrorType.FLOW_MOD_FAILED) {
                OFFlowModFailedErrorMsg fmFailed = (OFFlowModFailedErrorMsg) error;
                if (fmFailed.getData().getParsedMessage().isPresent()) {
                    OFMessage m = fmFailed.getData().getParsedMessage().get();
                    OFFlowMod fm = (OFFlowMod) m;
                    InternalCacheEntry entry = pendingBatches.getIfPresent(msg.getXid());
                    if (entry != null) {
                        entry.appendFailure(new FlowEntryBuilder(dpid, fm).build());
                    } else {
                        log.error("No matching batch for this error: {}", error);
                    }
                } else {
                    // FIXME: Potentially add flowtracking to avoid this message.
                    log.error("Flow installation failed but switch didn't" + " tell us which one.");
                }
            }
        default:
            log.debug("Unhandled message type: {}", msg.getType());
    }
}
#end_block

#method_before
private void pushFlowMetrics(Dpid dpid, OFFlowStatsReply replies) {
    DeviceId did = DeviceId.deviceId(Dpid.uri(dpid));
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    List<FlowEntry> flowEntries = replies.getEntries().stream().map(entry -> new FlowEntryBuilder(dpid, entry).build()).collect(Collectors.toList());
    providerService.pushFlowMetrics(did, flowEntries);
    // 
    // Update TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
    // 
    collectors.get(dpid).pushFlowMetrics(flowEntries);
}
#method_after
private void pushFlowMetrics(Dpid dpid, OFFlowStatsReply replies) {
    DeviceId did = DeviceId.deviceId(Dpid.uri(dpid));
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    List<FlowEntry> flowEntries = replies.getEntries().stream().map(entry -> new FlowEntryBuilder(dpid, entry).build()).collect(Collectors.toList());
    if (adaptiveFlowSampling) {
        NewAdaptiveFlowStatsCollector afsc = afsCollectors.get(dpid);
        synchronized (afsc) {
            if (afsc.getFlowMissingXid() != NewAdaptiveFlowStatsCollector.NO_FLOW_MISSING_XID) {
                log.debug("OpenFlowRuleProvider:pushFlowMetrics, flowMissingXid={}, " + "OFFlowStatsReply Xid={}, for {}", afsc.getFlowMissingXid(), replies.getXid(), dpid);
            }
            // Check that OFFlowStatsReply Xid is same with the one of OFFlowStatsRequest?
            if (afsc.getFlowMissingXid() != NewAdaptiveFlowStatsCollector.NO_FLOW_MISSING_XID) {
                if (afsc.getFlowMissingXid() == replies.getXid()) {
                    // call entire flow stats update with flowMissing synchronization.
                    // used existing pushFlowMetrics
                    providerService.pushFlowMetrics(did, flowEntries);
                }
                // reset flowMissingXid to NO_FLOW_MISSING_XID
                afsc.setFlowMissingXid(NewAdaptiveFlowStatsCollector.NO_FLOW_MISSING_XID);
            } else {
                // call individual flow stats update
                providerService.pushFlowMetricsWithoutFlowMissing(did, flowEntries);
            }
            // Update TypedFlowEntry to deviceFlowEntries in NewAdaptiveFlowStatsCollector
            afsc.pushFlowMetrics(flowEntries);
        }
    } else {
        // call existing entire flow stats update with flowMissing synchronization
        providerService.pushFlowMetrics(did, flowEntries);
    }
}
#end_block

#method_before
private void initMemberVars(int pollInterval) {
    if (pollInterval < MIN_CAL_AND_POLL_FREQUENCY) {
        this.calAndPollInterval = MIN_CAL_AND_POLL_FREQUENCY;
    } else if (pollInterval >= MAX_CAL_AND_POLL_FREQUENCY) {
        this.calAndPollInterval = MAX_CAL_AND_POLL_FREQUENCY;
    } else {
        this.calAndPollInterval = pollInterval;
    }
    calAndPollInterval = CAL_AND_POLL_TIMES * calAndPollInterval;
    midPollInterval = MID_POLL_TIMES * calAndPollInterval;
    longPollInterval = LONG_POLL_TIMES * calAndPollInterval;
    entirePollInterval = ENTIRE_POLL_TIMES * calAndPollInterval;
    callCountCalAndShortFlowsTask = 0;
    callCountMidFlowsTask = 0;
    callCountLongFlowsTask = 0;
}
#method_after
private void initMemberVars(int pollInterval) {
    if (pollInterval < MIN_CAL_AND_POLL_FREQUENCY) {
        this.calAndPollInterval = MIN_CAL_AND_POLL_FREQUENCY;
    } else if (pollInterval >= MAX_CAL_AND_POLL_FREQUENCY) {
        this.calAndPollInterval = MAX_CAL_AND_POLL_FREQUENCY;
    } else {
        this.calAndPollInterval = pollInterval;
    }
    calAndPollInterval = CAL_AND_POLL_TIMES * calAndPollInterval;
    midPollInterval = MID_POLL_TIMES * calAndPollInterval;
    longPollInterval = LONG_POLL_TIMES * calAndPollInterval;
    entirePollInterval = ENTIRE_POLL_TIMES * calAndPollInterval;
    callCountCalAndShortFlowsTask = 0;
    callCountMidFlowsTask = 0;
    callCountLongFlowsTask = 0;
    flowMissingXid = NO_FLOW_MISSING_XID;
}
#end_block

#method_before
synchronized void adjustCalAndPollInterval(int pollInterval) {
    initMemberVars(pollInterval);
    if (calAndShortFlowsThread != null) {
        calAndShortFlowsThread.cancel(false);
    }
    if (midFlowsThread != null) {
        midFlowsThread.cancel(false);
    }
    if (longFlowsThread != null) {
        longFlowsThread.cancel(false);
    }
    calAndShortFlowsTask = new CalAndShortFlowsTask();
    calAndShortFlowsThread = adaptiveFlowStatsScheduler.scheduleWithFixedDelay(calAndShortFlowsTask, 0, calAndPollInterval, TimeUnit.SECONDS);
    midFlowsTask = new MidFlowsTask();
    midFlowsThread = adaptiveFlowStatsScheduler.scheduleWithFixedDelay(midFlowsTask, 0, midPollInterval, TimeUnit.SECONDS);
    longFlowsTask = new LongFlowsTask();
    longFlowsThread = adaptiveFlowStatsScheduler.scheduleWithFixedDelay(longFlowsTask, 0, longPollInterval, TimeUnit.SECONDS);
    log.info("calAndPollInterval=" + calAndPollInterval + "is adjusted");
}
#method_after
synchronized void adjustCalAndPollInterval(int pollInterval) {
    initMemberVars(pollInterval);
    if (calAndShortFlowsThread != null) {
        calAndShortFlowsThread.cancel(false);
    }
    if (midFlowsThread != null) {
        midFlowsThread.cancel(false);
    }
    if (longFlowsThread != null) {
        longFlowsThread.cancel(false);
    }
    calAndShortFlowsTask = new CalAndShortFlowsTask();
    calAndShortFlowsThread = adaptiveFlowStatsScheduler.scheduleWithFixedDelay(calAndShortFlowsTask, 0, calAndPollInterval, TimeUnit.SECONDS);
    midFlowsTask = new MidFlowsTask();
    midFlowsThread = adaptiveFlowStatsScheduler.scheduleWithFixedDelay(midFlowsTask, 0, midPollInterval, TimeUnit.SECONDS);
    longFlowsTask = new LongFlowsTask();
    longFlowsThread = adaptiveFlowStatsScheduler.scheduleWithFixedDelay(longFlowsTask, 0, longPollInterval, TimeUnit.SECONDS);
    log.debug("calAndPollInterval=" + calAndPollInterval + "is adjusted");
}
#end_block

#method_before
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        log.trace("CalAndShortFlowsTask Collecting AdaptiveStats for {}", sw.getStringId());
        if (isFirstTimeStart) {
            // isFirstTimeStart, get entire flow stats from a given switch sw
            log.trace("CalAndShortFlowsTask Collecting Entire AdaptiveStats at first time start for {}", sw.getStringId());
            ofFlowStatsRequestAllSend();
            callCountCalAndShortFlowsTask = 0;
            isFirstTimeStart = false;
        } else if (callCountCalAndShortFlowsTask == ENTIRE_POLL_TIMES) {
            // entrire_poll_times, get entire flow stats from a given switch sw
            log.trace("CalAndShortFlowsTask Collecting Entire AdaptiveStats for {}", sw.getStringId());
            ofFlowStatsRequestAllSend();
            callCountCalAndShortFlowsTask = 0;
        // TODO: check flows deleted in switch, but exist in controller flow table, then remove them
        // 
        } else {
            calAndShortFlowsTaskInternal();
            callCountCalAndShortFlowsTask += CAL_AND_POLL_TIMES;
        }
    }
}
#method_after
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        log.trace("CalAndShortFlowsTask Collecting AdaptiveStats for {}", sw.getStringId());
        if (isFirstTimeStart) {
            // isFirstTimeStart, get entire flow stats from a given switch sw
            log.trace("CalAndShortFlowsTask Collecting Entire AdaptiveStats at first time start for {}", sw.getStringId());
            ofFlowStatsRequestAllSend();
            callCountCalAndShortFlowsTask += CAL_AND_POLL_TIMES;
            isFirstTimeStart = false;
        } else if (callCountCalAndShortFlowsTask == ENTIRE_POLL_TIMES) {
            // entire_poll_times, get entire flow stats from a given switch sw
            log.trace("CalAndShortFlowsTask Collecting Entire AdaptiveStats for {}", sw.getStringId());
            ofFlowStatsRequestAllSend();
            callCountCalAndShortFlowsTask = CAL_AND_POLL_TIMES;
        // TODO: check flows deleted in switch, but exist in controller flow table, then remove them
        // 
        } else {
            calAndShortFlowsTaskInternal();
            callCountCalAndShortFlowsTask += CAL_AND_POLL_TIMES;
        }
    }
}
#end_block

#method_before
private void ofFlowStatsRequestAllSend() {
    OFFlowStatsRequest request = sw.factory().buildFlowStatsRequest().setMatch(sw.factory().matchWildcardAll()).setTableId(TableId.ALL).setOutPort(OFPort.NO_MASK).build();
    sw.sendMsg(request);
}
#method_after
private void ofFlowStatsRequestAllSend() {
    OFFlowStatsRequest request = sw.factory().buildFlowStatsRequest().setMatch(sw.factory().matchWildcardAll()).setTableId(TableId.ALL).setOutPort(OFPort.NO_MASK).build();
    synchronized (this) {
        // set the request xid to check the reply in OpenFlowRuleProvider
        // After processing the reply of this request message,
        // this must be set to NO_FLOW_MISSING_XID(-1) by provider
        setFlowMissingXid(request.getXid());
        log.debug("ofFlowStatsRequestAllSend,Request={},for {}", request.toString(), sw.getStringId());
        sw.sendMsg(request);
    }
}
#end_block

#method_before
private void ofFlowStatsRequestFlowSend(FlowEntry fe) {
    // set find match
    Match match = FlowModBuilder.builder(fe, sw.factory(), Optional.empty()).buildMatch();
    // set find tableId
    TableId tableId = TableId.of(fe.tableId());
    // set output port
    Instruction ins = fe.treatment().allInstructions().stream().filter(i -> (i.type() == Instruction.Type.OUTPUT)).findFirst().orElse(null);
    OFPort ofPort = OFPort.NO_MASK;
    if (ins != null) {
        Instructions.OutputInstruction out = (Instructions.OutputInstruction) ins;
        ofPort = OFPort.of((int) ((out.port().toLong())));
    }
    OFFlowStatsRequest request = sw.factory().buildFlowStatsRequest().setMatch(// .setMatch(sw.factory().matchWildcardAll())
    match).setTableId(// .setTableId(TableId.ALL)
    tableId).setOutPort(// .setOutPort(OFPort.NO_MASK)
    ofPort).build();
    sw.sendMsg(request);
}
#method_after
private void ofFlowStatsRequestFlowSend(FlowEntry fe) {
    // set find match
    Match match = FlowModBuilder.builder(fe, sw.factory(), Optional.empty()).buildMatch();
    // set find tableId
    TableId tableId = TableId.of(fe.tableId());
    // set output port
    Instruction ins = fe.treatment().allInstructions().stream().filter(i -> (i.type() == Instruction.Type.OUTPUT)).findFirst().orElse(null);
    OFPort ofPort = OFPort.NO_MASK;
    if (ins != null) {
        Instructions.OutputInstruction out = (Instructions.OutputInstruction) ins;
        ofPort = OFPort.of((int) ((out.port().toLong())));
    }
    OFFlowStatsRequest request = sw.factory().buildFlowStatsRequest().setMatch(match).setTableId(tableId).setOutPort(ofPort).build();
    synchronized (this) {
        if (getFlowMissingXid() != NO_FLOW_MISSING_XID) {
            log.debug("ofFlowStatsRequestFlowSend: previous FlowStatsRequestAll does not be processed yet," + " set no flow missing xid anyway, for {}", sw.getStringId());
            setFlowMissingXid(NO_FLOW_MISSING_XID);
        }
        sw.sendMsg(request);
    }
}
#end_block

#method_before
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        log.trace("MidFlowsTask Collecting AdaptiveStats for {}", sw.getStringId());
        // skip collecting because CalAndShortFlowsTask collects entire flow stats from a given switch sw
        if (callCountMidFlowsTask == ENTIRE_POLL_TIMES) {
            callCountMidFlowsTask = 0;
        } else {
            midFlowsTaskInternal();
            callCountMidFlowsTask += MID_POLL_TIMES;
        }
    }
}
#method_after
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        log.trace("MidFlowsTask Collecting AdaptiveStats for {}", sw.getStringId());
        // skip collecting because CalAndShortFlowsTask collects entire flow stats from a given switch sw
        if (callCountMidFlowsTask == ENTIRE_POLL_TIMES) {
            callCountMidFlowsTask = MID_POLL_TIMES;
        } else {
            midFlowsTaskInternal();
            callCountMidFlowsTask += MID_POLL_TIMES;
        }
    }
}
#end_block

#method_before
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        log.trace("LongFlowsTask Collecting AdaptiveStats for {}", sw.getStringId());
        // skip collecting because CalAndShortFlowsTask collects entire flow stats from a given switch sw
        if (callCountLongFlowsTask == ENTIRE_POLL_TIMES) {
            callCountLongFlowsTask = 0;
        } else {
            longFlowsTaskInternal();
            callCountLongFlowsTask += LONG_POLL_TIMES;
        }
    }
}
#method_after
@Override
public void run() {
    if (sw.getRole() == RoleState.MASTER) {
        log.trace("LongFlowsTask Collecting AdaptiveStats for {}", sw.getStringId());
        // skip collecting because CalAndShortFlowsTask collects entire flow stats from a given switch sw
        if (callCountLongFlowsTask == ENTIRE_POLL_TIMES) {
            callCountLongFlowsTask = LONG_POLL_TIMES;
        } else {
            longFlowsTaskInternal();
            callCountLongFlowsTask += LONG_POLL_TIMES;
        }
    }
}
#end_block

#method_before
public boolean addWithFlowRule(FlowRule... flowRules) {
    for (FlowRule fr : flowRules) {
        // First remove old entry unconditionally, if exist
        deviceFlowTable.remove(fr);
        // add new flow entry, we suppose IMMEDIATE_FLOW
        TypedStoredFlowEntry newFlowEntry = new DefaultTypedFlowEntry(fr, FlowLiveType.IMMEDIATE_FLOW);
        deviceFlowTable.addWithCalAndSetFlowLiveType(newFlowEntry);
    }
    return true;
}
#method_after
public synchronized void addWithFlowRule(FlowRule... flowRules) {
    for (FlowRule fr : flowRules) {
        // First remove old entry unconditionally, if exist
        deviceFlowTable.remove(fr);
        // add new flow entry, we suppose IMMEDIATE_FLOW
        TypedStoredFlowEntry newFlowEntry = new DefaultTypedFlowEntry(fr, FlowLiveType.IMMEDIATE_FLOW);
        deviceFlowTable.addWithCalAndSetFlowLiveType(newFlowEntry);
    }
}
#end_block

#method_before
public boolean addOrUpdateFlows(FlowEntry... flowEntries) {
    for (FlowEntry fe : flowEntries) {
        TypedStoredFlowEntry stored = deviceFlowTable.getFlowEntry(fe);
        if (stored != null) {
            stored.setLife(fe.life());
            stored.setPackets(fe.packets());
            stored.setBytes(fe.bytes());
            stored.setLastSeen();
            if (stored.state() == FlowEntry.FlowEntryState.PENDING_ADD) {
                // flow is really RULE_ADDED
                stored.setState(FlowEntry.FlowEntryState.ADDED);
            }
            // deviceFlowTable.calAndSetFlowLiveType(stored);
            continue;
        }
        // add new flow entry, we suppose IMMEDIATE_FLOW
        TypedStoredFlowEntry newFlowEntry = new DefaultTypedFlowEntry(fe, FlowLiveType.IMMEDIATE_FLOW);
        deviceFlowTable.addWithCalAndSetFlowLiveType(newFlowEntry);
    }
    return true;
}
#method_after
public synchronized void addOrUpdateFlows(FlowEntry... flowEntries) {
    for (FlowEntry fe : flowEntries) {
        // check if this new rule is an update to an existing entry
        TypedStoredFlowEntry stored = deviceFlowTable.getFlowEntry(fe);
        if (stored != null) {
            // duplicated flow entry is collected!, just skip
            if (fe.bytes() == stored.bytes() && fe.packets() == stored.packets() && fe.life() == stored.life()) {
                log.debug("addOrUpdateFlows:, FlowId=" + Long.toHexString(fe.id().value()) + ",is DUPLICATED stats collection, just skip." + " AdaptiveStats collection thread for {}", sw.getStringId());
                stored.setLastSeen();
                continue;
            } else if (fe.life() < stored.life()) {
                // Invalid updates the stats values, i.e., bytes, packets, durations ...
                log.debug("addOrUpdateFlows():" + " Invalid Flow Update! The new life is SMALLER than the previous one, jus skip." + " new flowId=" + Long.toHexString(fe.id().value()) + ", old flowId=" + Long.toHexString(stored.id().value()) + ", new bytes=" + fe.bytes() + ", old bytes=" + stored.bytes() + ", new life=" + fe.life() + ", old life=" + stored.life() + ", new lastSeen=" + fe.lastSeen() + ", old lastSeen=" + stored.lastSeen());
                // go next
                stored.setLastSeen();
                continue;
            }
            // update now
            stored.setLife(fe.life());
            stored.setPackets(fe.packets());
            stored.setBytes(fe.bytes());
            stored.setLastSeen();
            if (stored.state() == FlowEntry.FlowEntryState.PENDING_ADD) {
                // flow is really RULE_ADDED
                stored.setState(FlowEntry.FlowEntryState.ADDED);
            }
            // deviceFlowTable.calAndSetFlowLiveType(stored);
            continue;
        }
        // add new flow entry, we suppose IMMEDIATE_FLOW
        TypedStoredFlowEntry newFlowEntry = new DefaultTypedFlowEntry(fe, FlowLiveType.IMMEDIATE_FLOW);
        deviceFlowTable.addWithCalAndSetFlowLiveType(newFlowEntry);
    }
}
#end_block

#method_before
public boolean removeFlows(FlowRule... flowRules) {
    for (FlowRule rule : flowRules) {
        deviceFlowTable.remove(rule);
    }
    return true;
}
#method_after
public synchronized void removeFlows(FlowRule... flowRules) {
    for (FlowRule rule : flowRules) {
        deviceFlowTable.remove(rule);
    }
}
#end_block

#method_before
public boolean flowRemoved(FlowRule... flowRules) {
    removeFlows(flowRules);
    return true;
}
#method_after
// same as removeFlows() function
public void flowRemoved(FlowRule... flowRules) {
    removeFlows(flowRules);
}
#end_block

#method_before
public boolean pushFlowMetrics(List<FlowEntry> flowEntries) {
    flowEntries.forEach(fe -> addOrUpdateFlows(fe));
    return true;
}
#method_after
// same as addOrUpdateFlows() function
public void pushFlowMetrics(List<FlowEntry> flowEntries) {
    flowEntries.forEach(fe -> {
        addOrUpdateFlows(fe);
    });
}
#end_block

#method_before
public int getFlowCount() {
    return flowEntries.values().stream().mapToInt(Set::size).sum();
}
#method_after
public long getFlowCount() {
    return flowEntries.values().stream().mapToLong(Set::size).sum();
}
#end_block

#method_before
public TypedStoredFlowEntry getFlowEntry(FlowRule rule) {
    return getFlowEntryInternal(rule);
}
#method_after
public TypedStoredFlowEntry getFlowEntry(FlowRule rule) {
    checkNotNull(rule);
    return getFlowEntryInternal(rule);
}
#end_block

#method_before
public Set<StoredFlowEntry> getShortFlows() {
    // Sets.newHashSet(shortFlows);
    Set<StoredFlowEntry> result = ImmutableSet.copyOf(shortFlows);
    return result;
}
#method_after
public Set<StoredFlowEntry> getShortFlows() {
    // Sets.newHashSet(shortFlows);
    return ImmutableSet.copyOf(shortFlows);
}
#end_block

#method_before
public Set<StoredFlowEntry> getMidFlows() {
    // Sets.newHashSet(midFlows);
    Set<StoredFlowEntry> result = ImmutableSet.copyOf(midFlows);
    return result;
}
#method_after
public Set<StoredFlowEntry> getMidFlows() {
    // Sets.newHashSet(midFlows);
    return ImmutableSet.copyOf(midFlows);
}
#end_block

#method_before
public Set<StoredFlowEntry> getLongFlows() {
    // Sets.newHashSet(longFlows);
    Set<StoredFlowEntry> result = ImmutableSet.copyOf(longFlows);
    return result;
}
#method_after
public Set<StoredFlowEntry> getLongFlows() {
    // Sets.newHashSet(longFlows);
    return ImmutableSet.copyOf(longFlows);
}
#end_block

#method_before
public void add(TypedStoredFlowEntry rule) {
    // rule have to be new new DefaultTypedFlowEntry
    getFlowEntriesInternal(rule.id()).add(rule);
    addCount++;
// log.debug("add, FlowId=" + Long.toHexString(rule.id().value())
// + ", liveType=" + rule.flowLiveType()
// + " AdaptiveStats collection thread for {}", sw.getStringId());
}
#method_after
public synchronized void add(TypedStoredFlowEntry rule) {
    checkNotNull(rule);
    // rule have to be new DefaultTypedFlowEntry
    boolean result = getFlowEntriesInternal(rule.id()).add(rule);
    if (result) {
        addCount++;
    }
}
#end_block

#method_before
public void calAndSetFlowLiveType(TypedStoredFlowEntry rule) {
    calAndSetFlowLiveTypeInternal(rule);
}
#method_after
public void calAndSetFlowLiveType(TypedStoredFlowEntry rule) {
    checkNotNull(rule);
    calAndSetFlowLiveTypeInternal(rule);
}
#end_block

#method_before
public void addWithCalAndSetFlowLiveType(TypedStoredFlowEntry rule) {
    // rule have to be new new DefaultTypedFlowEntry
    getFlowEntriesInternal(rule.id()).add(rule);
    calAndSetFlowLiveTypeInternal(rule);
    addWithSetFlowLiveTypeCount++;
// log.debug("addWithSetFlowLiveType, FlowId=" + Long.toHexString(rule.id().value())
// + ", liveType=" + rule.flowLiveType()
// + " AdaptiveStats collection thread for {}", sw.getStringId());
}
#method_after
public synchronized void addWithCalAndSetFlowLiveType(TypedStoredFlowEntry rule) {
    checkNotNull(rule);
    // rule have to be new DefaultTypedFlowEntry
    boolean result = getFlowEntriesInternal(rule.id()).add(rule);
    if (result) {
        calAndSetFlowLiveTypeInternal(rule);
        addWithSetFlowLiveTypeCount++;
    } else {
        log.debug("addWithCalAndSetFlowLiveType, FlowId=" + Long.toHexString(rule.id().value()) + " ADD Failed, cause it may already exists in table !!!," + " AdaptiveStats collection thread for {}", sw.getStringId());
    }
}
#end_block

#method_before
private void calAndSetFlowLiveTypeInternal(TypedStoredFlowEntry rule) {
    long life = rule.life();
    FlowLiveType prevFlowLiveType = rule.flowLiveType();
    if (life >= longPollInterval) {
        rule.setFlowLiveType(FlowLiveType.LONG_FLOW);
        longFlows.add(rule);
    } else if (life >= midPollInterval) {
        rule.setFlowLiveType(FlowLiveType.MID_FLOW);
        midFlows.add(rule);
    } else if (life >= calAndPollInterval) {
        rule.setFlowLiveType(FlowLiveType.SHORT_FLOW);
        shortFlows.add(rule);
    } else if (life >= 0) {
        rule.setFlowLiveType(FlowLiveType.IMMEDIATE_FLOW);
    } else {
        // life < 0
        rule.setFlowLiveType(FlowLiveType.UNKNOWN_FLOW);
    }
    if (rule.flowLiveType() != prevFlowLiveType) {
        switch(prevFlowLiveType) {
            // delete it from previous flow table
            case SHORT_FLOW:
                shortFlows.remove(rule);
                break;
            case MID_FLOW:
                midFlows.remove(rule);
                break;
            case LONG_FLOW:
                longFlows.remove(rule);
                break;
            default:
                break;
        }
    }
// log.debug("setFlowLiveTypeInternal, FlowId=" + Long.toHexString(rule.id().value())
// + ", liveType=" + rule.flowLiveType()
// + ", life=" + life
// + " AdaptiveStats collection thread for {}", sw.getStringId());
}
#method_after
// In real, calculates and set the flow live type at the first time,
private void calAndSetFlowLiveTypeInternal(TypedStoredFlowEntry rule) {
    long life = rule.life();
    FlowLiveType prevFlowLiveType = rule.flowLiveType();
    if (life >= longPollInterval) {
        rule.setFlowLiveType(FlowLiveType.LONG_FLOW);
        longFlows.add(rule);
    } else if (life >= midPollInterval) {
        rule.setFlowLiveType(FlowLiveType.MID_FLOW);
        midFlows.add(rule);
    } else if (life >= calAndPollInterval) {
        rule.setFlowLiveType(FlowLiveType.SHORT_FLOW);
        shortFlows.add(rule);
    } else if (life >= 0) {
        rule.setFlowLiveType(FlowLiveType.IMMEDIATE_FLOW);
    } else {
        // life < 0
        rule.setFlowLiveType(FlowLiveType.UNKNOWN_FLOW);
    }
    if (rule.flowLiveType() != prevFlowLiveType) {
        switch(prevFlowLiveType) {
            // delete it from previous flow table
            case SHORT_FLOW:
                shortFlows.remove(rule);
                break;
            case MID_FLOW:
                midFlows.remove(rule);
                break;
            case LONG_FLOW:
                longFlows.remove(rule);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
public void checkAndMoveLiveFlowAll() {
    Set<TypedStoredFlowEntry> typedFlowEntries = getFlowEntriesInternal();
    long calCurTime = System.currentTimeMillis();
    typedFlowEntries.forEach(fe -> {
        if (!checkAndMoveLiveFlow(fe, calCurTime)) {
            remove(fe);
        }
    });
    log.debug("checkAndMoveLiveFlowAll, Total Flow_Count=" + getFlowCount() + ", add - remove_Count=" + (addCount + addWithSetFlowLiveTypeCount - removeCount) + ", IMMEDIATE_FLOW_Count=" + (getFlowCount() - shortFlows.size() - midFlows.size() - longFlows.size()) + ", SHORT_FLOW_Count=" + shortFlows.size() + ", MID_FLOW_Count=" + midFlows.size() + ", LONG_FLOW_Count=" + longFlows.size() + ", add_Count=" + addCount + ",addWithSetFlowLiveType_Count=" + addWithSetFlowLiveTypeCount + ", remove_Count=" + removeCount + " AdaptiveStats collection thread for {}", sw.getStringId());
    log.trace("checkAndMoveLiveFlowAll, AdaptiveStats for {}", sw.getStringId());
}
#method_after
public void checkAndMoveLiveFlowAll() {
    Set<TypedStoredFlowEntry> typedFlowEntries = getFlowEntriesInternal();
    long calCurTime = System.currentTimeMillis();
    typedFlowEntries.forEach(fe -> {
        if (!checkAndMoveLiveFlowInternal(fe, calCurTime)) {
            remove(fe);
        }
    });
    // print table counts for debug
    if (log.isDebugEnabled()) {
        synchronized (this) {
            long totalFlowCount = getFlowCount();
            long shortFlowCount = shortFlows.size();
            long midFlowCount = midFlows.size();
            long longFlowCount = longFlows.size();
            long immediateFlowCount = totalFlowCount - shortFlowCount - midFlowCount - longFlowCount;
            long calTotalCount = addCount + addWithSetFlowLiveTypeCount - removeCount;
            log.debug("--------------------------------------------------------------------------- for {}", sw.getStringId());
            log.debug("checkAndMoveLiveFlowAll, Total Flow_Count=" + totalFlowCount + ", add - remove_Count=" + calTotalCount + ", IMMEDIATE_FLOW_Count=" + immediateFlowCount + ", SHORT_FLOW_Count=" + shortFlowCount + ", MID_FLOW_Count=" + midFlowCount + ", LONG_FLOW_Count=" + longFlowCount + ", add_Count=" + addCount + ", addWithSetFlowLiveType_Count=" + addWithSetFlowLiveTypeCount + ", remove_Count=" + removeCount + " AdaptiveStats collection thread for {}", sw.getStringId());
            log.debug("--------------------------------------------------------------------------- for {}", sw.getStringId());
            if (totalFlowCount != calTotalCount) {
                log.error("checkAndMoveLiveFlowAll, Real total flow count and " + "calculated total flow count do NOT match, something is wrong internally " + "or check counter value bound is over!");
            }
            if (immediateFlowCount < 0) {
                log.error("checkAndMoveLiveFlowAll, IMMEDIATE_FLOW count is negative, " + "something is wrong internally " + "or check counter value bound is over!");
            }
        }
    }
    log.trace("checkAndMoveLiveFlowAll, AdaptiveStats for {}", sw.getStringId());
}
#end_block

#method_before
public boolean remove(FlowRule rule) {
    TypedStoredFlowEntry removeStore = getFlowEntryInternal(rule);
    if (removeStore != null) {
        // log.debug("remove, FlowId=" + removeStore.id() + ", liveType=" + removeStore.flowLiveType()
        // + " AdaptiveStats collection thread for {}", sw.getStringId());
        removeLiveFlowsInternal((TypedStoredFlowEntry) removeStore);
        boolean result = getFlowEntriesInternal(rule.id()).remove(removeStore);
        removeCount++;
        return result;
    }
    return false;
}
#method_after
public synchronized void remove(FlowRule rule) {
    checkNotNull(rule);
    TypedStoredFlowEntry removeStore = getFlowEntryInternal(rule);
    if (removeStore != null) {
        removeLiveFlowsInternal((TypedStoredFlowEntry) removeStore);
        boolean result = getFlowEntriesInternal(rule.id()).remove(removeStore);
        if (result) {
            removeCount++;
        }
    }
}
#end_block

#method_before
private boolean removeLiveFlowsInternal(TypedStoredFlowEntry fe) {
    switch(fe.flowLiveType()) {
        case IMMEDIATE_FLOW:
            // do nothing
            break;
        case SHORT_FLOW:
            shortFlows.remove(fe);
            break;
        case MID_FLOW:
            midFlows.remove(fe);
            break;
        case LONG_FLOW:
            longFlows.remove(fe);
            break;
        default:
            // error in Flow Live Type
            return false;
    }
    return true;
}
#method_after
private void removeLiveFlowsInternal(TypedStoredFlowEntry fe) {
    switch(fe.flowLiveType()) {
        case IMMEDIATE_FLOW:
            // do nothing
            break;
        case SHORT_FLOW:
            shortFlows.remove(fe);
            break;
        case MID_FLOW:
            midFlows.remove(fe);
            break;
        case LONG_FLOW:
            longFlows.remove(fe);
            break;
        default:
            // error in Flow Live Type
            log.error("removeLiveFlowsInternal, Unknown Live Type error!");
            break;
    }
}
#end_block

#method_before
public static TemplateRecord portStatsInTemplateRecord() {
    TemplateRecord tr = new TemplateRecord();
    tr.setTemplateID(TEMPLATE_ID);
    tr.setFieldCount(FIELD_COUNT);
    List<InformationElement> ieTemp = tr.getInformationElements();
    InformationElement ieIpv4Exporter = new InformationElement();
    ieIpv4Exporter.setFieldLength(4);
    ieIpv4Exporter.setInformationElementID(130);
    ieTemp.add(ieIpv4Exporter);
    InformationElement ieIpv6Exporter = new InformationElement();
    ieIpv6Exporter.setFieldLength(16);
    ieIpv6Exporter.setInformationElementID(131);
    ieTemp.add(ieIpv6Exporter);
    InformationElement ieIntf = new InformationElement();
    ieIntf.setFieldLength(4);
    ieIntf.setInformationElementID(10);
    ieTemp.add(ieIntf);
    InformationElement ieBytes = new InformationElement();
    ieBytes.setFieldLength(8);
    ieBytes.setInformationElementID(1);
    ieTemp.add(ieBytes);
    InformationElement iePackets = new InformationElement();
    iePackets.setFieldLength(8);
    iePackets.setInformationElementID(2);
    ieTemp.add(iePackets);
    InformationElement ieStart = new InformationElement();
    ieStart.setFieldLength(8);
    ieStart.setInformationElementID(152);
    ieTemp.add(ieStart);
    InformationElement ieEnd = new InformationElement();
    ieEnd.setFieldLength(8);
    ieEnd.setInformationElementID(153);
    ieTemp.add(ieEnd);
    return tr;
}
#method_after
public static TemplateRecord portStatsInTemplateRecord() {
    TemplateRecord tr = new TemplateRecord();
    tr.setTemplateID(TEMPLATE_ID);
    tr.setFieldCount(FIELD_COUNT);
    List<InformationElement> ieTemp = tr.getInformationElements();
    ieTemp.add(new InformationElement(Ie.exporterIPv4Address));
    ieTemp.add(new InformationElement(Ie.exporterIPv6Address));
    ieTemp.add(new InformationElement(Ie.ingressInterface));
    ieTemp.add(new InformationElement(Ie.octetDeltaCount));
    ieTemp.add(new InformationElement(Ie.packetDeltaCount));
    ieTemp.add(new InformationElement(Ie.flowStartMilliseconds));
    ieTemp.add(new InformationElement(Ie.flowEndMilliseconds));
    return tr;
}
#end_block

#method_before
public static TemplateRecord portStatsOutTemplateRecord() {
    TemplateRecord tr = new TemplateRecord();
    tr.setTemplateID(TEMPLATE_ID);
    tr.setFieldCount(FIELD_COUNT);
    List<InformationElement> ieTemp = tr.getInformationElements();
    InformationElement ieIpv4Exporter = new InformationElement();
    ieIpv4Exporter.setFieldLength(4);
    ieIpv4Exporter.setInformationElementID(130);
    ieTemp.add(ieIpv4Exporter);
    InformationElement ieIpv6Exporter = new InformationElement();
    ieIpv6Exporter.setFieldLength(16);
    ieIpv6Exporter.setInformationElementID(131);
    ieTemp.add(ieIpv6Exporter);
    InformationElement ieIntf = new InformationElement();
    ieIntf.setFieldLength(4);
    ieIntf.setInformationElementID(14);
    ieTemp.add(ieIntf);
    InformationElement ieBytes = new InformationElement();
    ieBytes.setFieldLength(8);
    ieBytes.setInformationElementID(1);
    ieTemp.add(ieBytes);
    InformationElement iePackets = new InformationElement();
    iePackets.setFieldLength(8);
    iePackets.setInformationElementID(2);
    ieTemp.add(iePackets);
    InformationElement ieStart = new InformationElement();
    ieStart.setFieldLength(8);
    ieStart.setInformationElementID(152);
    ieTemp.add(ieStart);
    InformationElement ieEnd = new InformationElement();
    ieEnd.setFieldLength(8);
    ieEnd.setInformationElementID(153);
    ieTemp.add(ieEnd);
    return tr;
}
#method_after
public static TemplateRecord portStatsOutTemplateRecord() {
    TemplateRecord tr = new TemplateRecord();
    tr.setTemplateID(TEMPLATE_ID);
    tr.setFieldCount(FIELD_COUNT);
    List<InformationElement> ieTemp = tr.getInformationElements();
    ieTemp.add(new InformationElement(Ie.exporterIPv4Address));
    ieTemp.add(new InformationElement(Ie.exporterIPv6Address));
    ieTemp.add(new InformationElement(Ie.egressInterface));
    ieTemp.add(new InformationElement(Ie.octetDeltaCount));
    ieTemp.add(new InformationElement(Ie.packetDeltaCount));
    ieTemp.add(new InformationElement(Ie.flowStartMilliseconds));
    ieTemp.add(new InformationElement(Ie.flowEndMilliseconds));
    return tr;
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    appId = coreService.registerApplication("net.sdnmon.of2ipfix");
    cfgService.registerProperties(getClass());
    getProperties(context);
    collectorIp = IpAddress.valueOf(collectorAddress);
    if (reactiveForwardingFlowExport) {
        flowRemovedListener = new FlowRemovedListener(this);
        flowRuleService.addListener(flowRemovedListener);
    }
    if (portStatsFlowExport) {
        portStatsListener = new PortStatsListener(this);
        deviceService.addListener(portStatsListener);
    }
    ipfixSender = new IpfixSender();
    log.info("Started. reactiveForwardingFlowExport={}, portStatsFlowExport={}, IPFIX collector: ip={}, port={}", reactiveForwardingFlowExport, portStatsFlowExport, collectorAddress, collectorPort);
}
#method_after
@Activate
public void activate(ComponentContext context) {
    appId = coreService.registerApplication("net.sdnmon.of2ipfix");
    cfgService.registerProperties(getClass());
    getProperties(context);
    collectorIp = IpAddress.valueOf(collectorAddress);
    if (reactiveForwardingFlowExport) {
        flowRemovedListener = new FlowRemovedListener(this);
        flowRuleService.addListener(flowRemovedListener);
    }
    if (portStatsFlowExport) {
        portStatsListener = new PortStatsListener(this);
        deviceService.addListener(portStatsListener);
    }
    ipfixSender = new IpfixSender(this);
    log.info("Started. reactiveForwardingFlowExport={}, portStatsFlowExport={}, IPFIX collector: ip={}, port={}", reactiveForwardingFlowExport, portStatsFlowExport, collectorAddress, collectorPort);
}
#end_block

#method_before
public int getTemplateID() {
    return templateID;
}
#method_after
/**
 * Option Template Header format.
 *
 *   0                   1                   2                   3
 *   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  | Template ID (larger than 255) |         Field Count           |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |      Scope Field Count        |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
public int getTemplateID() {
    return templateID;
}
#end_block

#method_before
public static OptionTemplateRecord parse(byte[] data) throws HeaderException {
    try {
        if (data.length < 6) {
            throw new HeaderException("Data array too short.");
        }
        OptionTemplateRecord otr = new OptionTemplateRecord();
        // template ID
        byte[] templateID = new byte[2];
        System.arraycopy(data, 0, templateID, 0, 2);
        otr.setTemplateID(Ints.fromByteArray(templateID));
        // field count
        byte[] fieldCount = new byte[2];
        System.arraycopy(data, 2, fieldCount, 0, 2);
        otr.setFieldCount(Ints.fromByteArray(fieldCount));
        // scope field count
        byte[] scopeFieldCount = new byte[2];
        System.arraycopy(data, 4, scopeFieldCount, 0, 2);
        otr.setScopeFieldCount(Ints.fromByteArray(scopeFieldCount));
        int offset = 6;
        for (int i = 0; i < otr.getFieldCount(); i++) {
            byte[] subData = new byte[InformationElement.LENGTH];
            System.arraycopy(data, offset + (i * InformationElement.LENGTH), subData, 0, InformationElement.LENGTH);
            InformationElement ie = InformationElement.parse(subData);
            if (i < otr.getScopeFieldCount()) {
                otr.getScopeInformationElements().add(ie);
            } else {
                otr.getInformationElements().add(ie);
            }
        }
        return otr;
    } catch (Exception e) {
        throw new HeaderException("Parse error: " + e.getMessage());
    }
}
#method_after
public static OptionTemplateRecord parse(byte[] data) throws HeaderException {
    try {
        if (data.length < HEADER_LENGTH) {
            throw new HeaderException("Data array too short.");
        }
        OptionTemplateRecord otr = new OptionTemplateRecord();
        // template ID
        byte[] templateID = new byte[2];
        System.arraycopy(data, 0, templateID, 0, 2);
        otr.setTemplateID(Ints.fromByteArray(templateID));
        // field count
        byte[] fieldCount = new byte[2];
        System.arraycopy(data, 2, fieldCount, 0, 2);
        otr.setFieldCount(Ints.fromByteArray(fieldCount));
        // scope field count
        byte[] scopeFieldCount = new byte[2];
        System.arraycopy(data, 4, scopeFieldCount, 0, 2);
        otr.setScopeFieldCount(Ints.fromByteArray(scopeFieldCount));
        int offset = HEADER_LENGTH;
        for (int i = 0; i < otr.getFieldCount(); i++) {
            byte[] subData = new byte[InformationElement.LENGTH];
            System.arraycopy(data, offset + (i * InformationElement.LENGTH), subData, 0, InformationElement.LENGTH);
            InformationElement ie = InformationElement.parse(subData);
            if (i < otr.getScopeFieldCount()) {
                otr.getScopeInformationElements().add(ie);
            } else {
                otr.getInformationElements().add(ie);
            }
        }
        return otr;
    } catch (Exception e) {
        throw new HeaderException("Parse error: " + e.getMessage());
    }
}
#end_block

#method_before
public byte[] getBytes() throws HeaderException {
    try {
        int length = 6 + (scopeInformationElements.size() * InformationElement.LENGTH) + (informationElements.size() * InformationElement.LENGTH);
        if (length % 4 != 0) {
            // padding
            length += (length % 4);
        }
        byte[] data = new byte[length];
        // template ID
        System.arraycopy(Shorts.toByteArray((short) getTemplateID()), 0, data, 0, 2);
        // field count
        System.arraycopy(Shorts.toByteArray((short) getFieldCount()), 0, data, 2, 2);
        // scope field count
        System.arraycopy(Shorts.toByteArray((short) getScopeFieldCount()), 0, data, 4, 2);
        // information elements
        int offset = 6;
        for (InformationElement ie : scopeInformationElements) {
            System.arraycopy(ie.getBytes(), 0, data, offset, InformationElement.LENGTH);
            offset += InformationElement.LENGTH;
        }
        for (InformationElement ie : informationElements) {
            System.arraycopy(ie.getBytes(), 0, data, offset, InformationElement.LENGTH);
            offset += InformationElement.LENGTH;
        }
        return data;
    } catch (Exception e) {
        throw new HeaderException("Error while generating the bytes: " + e.getMessage());
    }
}
#method_after
public byte[] getBytes() throws HeaderException {
    try {
        int length = HEADER_LENGTH + (scopeInformationElements.size() * InformationElement.LENGTH) + (informationElements.size() * InformationElement.LENGTH);
        if (length % 4 != 0) {
            // padding
            length += (length % 4);
        }
        byte[] data = new byte[length];
        // template ID
        System.arraycopy(Shorts.toByteArray((short) getTemplateID()), 0, data, 0, 2);
        // field count
        System.arraycopy(Shorts.toByteArray((short) getFieldCount()), 0, data, 2, 2);
        // scope field count
        System.arraycopy(Shorts.toByteArray((short) getScopeFieldCount()), 0, data, 4, 2);
        // information elements
        int offset = HEADER_LENGTH;
        for (InformationElement ie : scopeInformationElements) {
            System.arraycopy(ie.getBytes(), 0, data, offset, InformationElement.LENGTH);
            offset += InformationElement.LENGTH;
        }
        for (InformationElement ie : informationElements) {
            System.arraycopy(ie.getBytes(), 0, data, offset, InformationElement.LENGTH);
            offset += InformationElement.LENGTH;
        }
        return data;
    } catch (Exception e) {
        throw new HeaderException("Error while generating the bytes: " + e.getMessage());
    }
}
#end_block

#method_before
public static SamplingDataRecord parse(byte[] data) throws HeaderException {
    try {
        if (data.length < LENGTH) {
            throw new HeaderException("Data array too short.");
        }
        SamplingDataRecord sdr = new SamplingDataRecord();
        // observationDomainId
        byte[] observationDomainId = new byte[4];
        System.arraycopy(data, 0, observationDomainId, 0, 4);
        sdr.setObservationDomainId(Longs.fromByteArray(observationDomainId));
        // selectorAlgorithm
        byte[] selectorAlgorithm = new byte[2];
        System.arraycopy(data, 4, selectorAlgorithm, 0, 2);
        sdr.setSelectorAlgorithm(Ints.fromByteArray(selectorAlgorithm));
        // samplingPacketInterval
        byte[] samplingPacketInterval = new byte[4];
        System.arraycopy(data, 6, samplingPacketInterval, 0, 4);
        sdr.setSamplingPacketInterval(Longs.fromByteArray(samplingPacketInterval));
        // samplingPacketSpace
        byte[] samplingPacketSpace = new byte[4];
        System.arraycopy(data, 10, samplingPacketSpace, 0, 4);
        sdr.setSamplingPacketSpace(Longs.fromByteArray(samplingPacketSpace));
        return sdr;
    } catch (Exception e) {
        throw new HeaderException("Parse error: " + e.getMessage());
    }
}
#method_after
public static SamplingDataRecord parse(byte[] data) throws HeaderException {
    try {
        if (data.length < HEADER_LENGTH) {
            throw new HeaderException("Data array too short.");
        }
        SamplingDataRecord sdr = new SamplingDataRecord();
        // observationDomainId
        byte[] observationDomainId = new byte[4];
        System.arraycopy(data, 0, observationDomainId, 0, 4);
        sdr.setObservationDomainId(Longs.fromByteArray(observationDomainId));
        // selectorAlgorithm
        byte[] selectorAlgorithm = new byte[2];
        System.arraycopy(data, 4, selectorAlgorithm, 0, 2);
        sdr.setSelectorAlgorithm(Ints.fromByteArray(selectorAlgorithm));
        // samplingPacketInterval
        byte[] samplingPacketInterval = new byte[4];
        System.arraycopy(data, 6, samplingPacketInterval, 0, 4);
        sdr.setSamplingPacketInterval(Longs.fromByteArray(samplingPacketInterval));
        // samplingPacketSpace
        byte[] samplingPacketSpace = new byte[4];
        System.arraycopy(data, 10, samplingPacketSpace, 0, 4);
        sdr.setSamplingPacketSpace(Longs.fromByteArray(samplingPacketSpace));
        return sdr;
    } catch (Exception e) {
        throw new HeaderException("Parse error: " + e.getMessage());
    }
}
#end_block

#method_before
public byte[] getBytes() throws HeaderException {
    try {
        byte[] data = new byte[LENGTH];
        // observationDomainId
        System.arraycopy(Ints.toByteArray((int) getObservationDomainId()), 0, data, 0, 4);
        // selectorAlgorithm
        System.arraycopy(Ints.toByteArray((int) getSelectorAlgorithm()), 0, data, 4, 2);
        // samplingPacketInterval
        System.arraycopy(Ints.toByteArray((int) getSamplingPacketInterval()), 0, data, 6, 4);
        // samplingPacketSpace
        System.arraycopy(Ints.toByteArray((int) getSamplingPacketSpace()), 0, data, 10, 4);
        return data;
    } catch (Exception e) {
        throw new HeaderException("Error while generating the bytes: " + e.getMessage());
    }
}
#method_after
public byte[] getBytes() throws HeaderException {
    try {
        byte[] data = new byte[HEADER_LENGTH];
        // observationDomainId
        System.arraycopy(Ints.toByteArray((int) getObservationDomainId()), 0, data, 0, 4);
        // selectorAlgorithm
        System.arraycopy(Ints.toByteArray((int) getSelectorAlgorithm()), 0, data, 4, 2);
        // samplingPacketInterval
        System.arraycopy(Ints.toByteArray((int) getSamplingPacketInterval()), 0, data, 6, 4);
        // samplingPacketSpace
        System.arraycopy(Ints.toByteArray((int) getSamplingPacketSpace()), 0, data, 10, 4);
        return data;
    } catch (Exception e) {
        throw new HeaderException("Error while generating the bytes: " + e.getMessage());
    }
}
#end_block

#method_before
public static TemplateRecord getTemplateRecord() {
    TemplateRecord tr = new TemplateRecord();
    tr.setTemplateID(TEMPLATE_ID);
    tr.setFieldCount(FIELD_COUNT);
    List<InformationElement> ieTemp = tr.getInformationElements();
    InformationElement ieIpv4Exporter = new InformationElement();
    ieIpv4Exporter.setFieldLength(4);
    ieIpv4Exporter.setInformationElementID(130);
    ieTemp.add(ieIpv4Exporter);
    InformationElement ieIpv6Exporter = new InformationElement();
    ieIpv6Exporter.setFieldLength(16);
    ieIpv6Exporter.setInformationElementID(131);
    ieTemp.add(ieIpv6Exporter);
    InformationElement ieStart = new InformationElement();
    ieStart.setFieldLength(8);
    ieStart.setInformationElementID(152);
    ieTemp.add(ieStart);
    InformationElement ieEnd = new InformationElement();
    ieEnd.setFieldLength(8);
    ieEnd.setInformationElementID(153);
    ieTemp.add(ieEnd);
    InformationElement ieBytes = new InformationElement();
    ieBytes.setFieldLength(8);
    ieBytes.setInformationElementID(1);
    ieTemp.add(ieBytes);
    InformationElement iePackets = new InformationElement();
    iePackets.setFieldLength(8);
    iePackets.setInformationElementID(2);
    ieTemp.add(iePackets);
    InformationElement ieIngressIntf = new InformationElement();
    ieIngressIntf.setFieldLength(4);
    ieIngressIntf.setInformationElementID(10);
    ieTemp.add(ieIngressIntf);
    InformationElement ieEgressIntf = new InformationElement();
    ieEgressIntf.setFieldLength(4);
    ieEgressIntf.setInformationElementID(14);
    ieTemp.add(ieEgressIntf);
    InformationElement ieSrcMac = new InformationElement();
    ieSrcMac.setFieldLength(6);
    ieSrcMac.setInformationElementID(56);
    ieTemp.add(ieSrcMac);
    InformationElement ieDstMac = new InformationElement();
    ieDstMac.setFieldLength(6);
    ieDstMac.setInformationElementID(80);
    ieTemp.add(ieDstMac);
    InformationElement ieEtherType = new InformationElement();
    ieEtherType.setFieldLength(2);
    ieEtherType.setInformationElementID(256);
    ieTemp.add(ieEtherType);
    InformationElement ieVlanId = new InformationElement();
    ieVlanId.setFieldLength(2);
    ieVlanId.setInformationElementID(58);
    ieTemp.add(ieVlanId);
    return tr;
}
#method_after
public static TemplateRecord getTemplateRecord() {
    TemplateRecord tr = new TemplateRecord();
    tr.setTemplateID(TEMPLATE_ID);
    tr.setFieldCount(FIELD_COUNT);
    List<InformationElement> ieTemp = tr.getInformationElements();
    ieTemp.add(new InformationElement(Ie.exporterIPv4Address));
    ieTemp.add(new InformationElement(Ie.exporterIPv6Address));
    ieTemp.add(new InformationElement(Ie.flowStartMilliseconds));
    ieTemp.add(new InformationElement(Ie.flowEndMilliseconds));
    ieTemp.add(new InformationElement(Ie.octetDeltaCount));
    ieTemp.add(new InformationElement(Ie.packetDeltaCount));
    ieTemp.add(new InformationElement(Ie.ingressInterface));
    ieTemp.add(new InformationElement(Ie.egressInterface));
    ieTemp.add(new InformationElement(Ie.sourceMacAddress));
    ieTemp.add(new InformationElement(Ie.destinationMacAddress));
    ieTemp.add(new InformationElement(Ie.ethernetType));
    ieTemp.add(new InformationElement(Ie.vlanId));
    return tr;
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    switch(event.type()) {
        case PORT_STATS_UPDATED:
            if (of2ipfix.deviceService.getRole(device.id()) == MastershipRole.MASTER) {
                of2ipfix.log.trace("PortStats Updated: I am MASTER for deviceId={}", device.id().toString());
                List<DataRecord> recordsInList = new ArrayList<DataRecord>();
                List<DataRecord> recordsOutList = new ArrayList<DataRecord>();
                IpAddress exporterIpv4 = IpAddress.valueOf(device.annotations().toString().split("=")[2].split(":")[0]);
                long dpid = Dpid.dpid(device.id().uri()).value();
                byte[] byteExporterIpv6 = new byte[16];
                System.arraycopy(Longs.toByteArray(0), 0, byteExporterIpv6, 0, 8);
                System.arraycopy(Longs.toByteArray(dpid), 0, byteExporterIpv6, 8, 8);
                Ip6Address exporterIpv6 = Ip6Address.valueOf(byteExporterIpv6);
                for (PortStatistics stat : of2ipfix.deviceService.getPortDeltaStatistics(device.id())) {
                    final String format = "PortStatsListener Delta Stats: port={}, pktRx={}, pktTx={}," + "bytesRx={}, bytesTx={}, pktRxDrp={}, pktTxDrp={}, Dur={}.{}";
                    of2ipfix.log.trace(format, stat.port(), stat.packetsReceived(), stat.packetsSent(), stat.bytesReceived(), stat.bytesSent(), stat.packetsRxDropped(), stat.packetsTxDropped(), stat.durationSec(), (stat.durationNano() / 1000000));
                    long inBytes = stat.bytesReceived();
                    long inPackets = stat.packetsReceived();
                    long outBytes = stat.bytesSent();
                    long outPackets = stat.packetsSent();
                    long endTime = System.currentTimeMillis();
                    long startTime = endTime - (stat.durationSec() * TimeUnit.SECONDS.toMillis(1) + stat.durationNano() / TimeUnit.MILLISECONDS.toNanos(1));
                    DataRecordPortStatsIn recordIn = new DataRecordPortStatsIn(exporterIpv4, exporterIpv6, stat.port(), inBytes, inPackets, startTime, endTime);
                    DataRecordPortStatsOut recordOut = new DataRecordPortStatsOut(exporterIpv4, exporterIpv6, stat.port(), outBytes, outPackets, startTime, endTime);
                    recordsInList.add(recordIn);
                    recordsOutList.add(recordOut);
                }
                if (recordsInList.isEmpty() && recordsOutList.isEmpty()) {
                    of2ipfix.log.trace("PortStats: Previous PortStats for device={} where zero," + "not sending IPFIX flow", device.id());
                } else {
                    TemplateRecord trIn = DataRecordPortStatsIn.portStatsInTemplateRecord();
                    TemplateRecord trOut = DataRecordPortStatsOut.portStatsOutTemplateRecord();
                    of2ipfix.ipfixSender.sendRecords(trIn, recordsInList, dpid, IpfixManager.collectorIp, IpfixManager.collectorPort);
                    of2ipfix.ipfixSender.sendRecords(trOut, recordsOutList, dpid, IpfixManager.collectorIp, IpfixManager.collectorPort);
                }
            }
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    switch(event.type()) {
        case PORT_STATS_UPDATED:
            if (ipfixManager.deviceService.getRole(device.id()) == MastershipRole.MASTER) {
                ipfixManager.log.trace("PortStats Updated: I am MASTER for deviceId={}", device.id().toString());
                List<DataRecord> recordsInList = new ArrayList<DataRecord>();
                List<DataRecord> recordsOutList = new ArrayList<DataRecord>();
                IpAddress exporterIpv4 = IpAddress.valueOf(device.annotations().toString().split("=")[2].split(":")[0]);
                long dpid = Dpid.dpid(device.id().uri()).value();
                byte[] byteExporterIpv6 = new byte[16];
                System.arraycopy(Longs.toByteArray(0), 0, byteExporterIpv6, 0, 8);
                System.arraycopy(Longs.toByteArray(dpid), 0, byteExporterIpv6, 8, 8);
                Ip6Address exporterIpv6 = Ip6Address.valueOf(byteExporterIpv6);
                for (PortStatistics stat : ipfixManager.deviceService.getPortDeltaStatistics(device.id())) {
                    final String format = "PortStatsListener Delta Stats: port={}, pktRx={}, pktTx={}," + "bytesRx={}, bytesTx={}, pktRxDrp={}, pktTxDrp={}, Dur={}.{}";
                    ipfixManager.log.trace(format, stat.port(), stat.packetsReceived(), stat.packetsSent(), stat.bytesReceived(), stat.bytesSent(), stat.packetsRxDropped(), stat.packetsTxDropped(), stat.durationSec(), (stat.durationNano() / 1000000));
                    long inBytes = stat.bytesReceived();
                    long inPackets = stat.packetsReceived();
                    long outBytes = stat.bytesSent();
                    long outPackets = stat.packetsSent();
                    long endTime = System.currentTimeMillis();
                    long startTime = endTime - (stat.durationSec() * TimeUnit.SECONDS.toMillis(1) + stat.durationNano() / TimeUnit.MILLISECONDS.toNanos(1));
                    DataRecordPortStatsIn recordIn = new DataRecordPortStatsIn(exporterIpv4, exporterIpv6, stat.port(), inBytes, inPackets, startTime, endTime);
                    DataRecordPortStatsOut recordOut = new DataRecordPortStatsOut(exporterIpv4, exporterIpv6, stat.port(), outBytes, outPackets, startTime, endTime);
                    recordsInList.add(recordIn);
                    recordsOutList.add(recordOut);
                }
                if (recordsInList.isEmpty() && recordsOutList.isEmpty()) {
                    ipfixManager.log.trace("PortStats: Previous PortStats for device={} where zero," + "not sending IPFIX flow", device.id());
                } else {
                    TemplateRecord trIn = DataRecordPortStatsIn.portStatsInTemplateRecord();
                    TemplateRecord trOut = DataRecordPortStatsOut.portStatsOutTemplateRecord();
                    ipfixManager.ipfixSender.sendRecords(trIn, recordsInList, dpid, IpfixManager.collectorIp, IpfixManager.collectorPort);
                    ipfixManager.ipfixSender.sendRecords(trOut, recordsOutList, dpid, IpfixManager.collectorIp, IpfixManager.collectorPort);
                }
            }
            break;
        default:
            break;
    }
}
#end_block

#method_before
public int getVersionNumber() {
    return IPFIX_VERSION;
}
#method_after
/**
 * Message Header format.
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |       Version Number          |            Length             |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                           Export Time                         |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                       Sequence Number                         |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |                    Observation Domain ID                      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
public int getVersionNumber() {
    return IPFIX_VERSION;
}
#end_block

#method_before
public void setSetHeaders(List<SetHeader> setHeaders) {
    this.setHeaders = setHeaders;
    int length = HEADERLENGTH;
    for (SetHeader header : setHeaders) {
        length += header.getLength();
    }
    setLength(length);
}
#method_after
public void setSetHeaders(List<SetHeader> setHeaders) {
    this.setHeaders = setHeaders;
    int length = HEADER_LENGTH;
    for (SetHeader header : setHeaders) {
        length += header.getLength();
    }
    setLength(length);
}
#end_block

#method_before
public static MessageHeader parse(byte[] data) throws HeaderException {
    try {
        if (data.length < 16) {
            throw new HeaderException("Data array too short.");
        }
        MessageHeader mh = new MessageHeader();
        // version number
        byte[] versionNumber = new byte[2];
        System.arraycopy(data, 0, versionNumber, 0, 2);
        mh.setVersionNumber(Ints.fromByteArray(versionNumber));
        // length
        byte[] length = new byte[2];
        System.arraycopy(data, 2, length, 0, 2);
        mh.setLength(Ints.fromByteArray(length));
        // export time
        byte[] exportTime = new byte[4];
        System.arraycopy(data, 4, exportTime, 0, 4);
        long secondsSinceEpoche = Longs.fromByteArray(exportTime);
        long milliSecondsSinceEpoche = secondsSinceEpoche * 1000;
        mh.setExportTime(new Date(milliSecondsSinceEpoche));
        // sequence number
        byte[] sequenceNumber = new byte[4];
        System.arraycopy(data, 8, sequenceNumber, 0, 4);
        mh.setSequenceNumber(Longs.fromByteArray(sequenceNumber));
        // observation domain id
        byte[] observationDomainID = new byte[4];
        System.arraycopy(data, 12, observationDomainID, 0, 4);
        mh.setObservationDomainID(Longs.fromByteArray(observationDomainID));
        // set header
        int offset = 16;
        while ((mh.getLength() - offset) > 0) {
            byte[] subData = new byte[mh.getLength() - offset];
            System.arraycopy(data, offset, subData, 0, subData.length);
            SetHeader sh = SetHeader.parse(subData);
            mh.getSetHeaders().add(sh);
            offset += sh.getLength();
        }
        if ((mh.getLength() - offset) != 0) {
            LOGGER.log(Level.INFO, "Unused bytes: " + (mh.getLength() - offset));
        }
        return mh;
    } catch (Exception e) {
        throw new HeaderException("Parse error: " + e.getMessage());
    }
}
#method_after
public static MessageHeader parse(byte[] data) throws HeaderException {
    try {
        if (data.length < HEADER_LENGTH) {
            throw new HeaderException("Data array too short.");
        }
        MessageHeader mh = new MessageHeader();
        // version number
        byte[] versionNumber = new byte[2];
        System.arraycopy(data, 0, versionNumber, 0, 2);
        mh.setVersionNumber(Ints.fromByteArray(versionNumber));
        // length
        byte[] length = new byte[2];
        System.arraycopy(data, 2, length, 0, 2);
        mh.setLength(Ints.fromByteArray(length));
        // export time
        byte[] exportTime = new byte[4];
        System.arraycopy(data, 4, exportTime, 0, 4);
        long secondsSinceEpoche = Longs.fromByteArray(exportTime);
        long milliSecondsSinceEpoche = secondsSinceEpoche * 1000;
        mh.setExportTime(new Date(milliSecondsSinceEpoche));
        // sequence number
        byte[] sequenceNumber = new byte[4];
        System.arraycopy(data, 8, sequenceNumber, 0, 4);
        mh.setSequenceNumber(Longs.fromByteArray(sequenceNumber));
        // observation domain id
        byte[] observationDomainID = new byte[4];
        System.arraycopy(data, 12, observationDomainID, 0, 4);
        mh.setObservationDomainID(Longs.fromByteArray(observationDomainID));
        // set header
        int offset = HEADER_LENGTH;
        while ((mh.getLength() - offset) > 0) {
            byte[] subData = new byte[mh.getLength() - offset];
            System.arraycopy(data, offset, subData, 0, subData.length);
            SetHeader sh = SetHeader.parse(subData);
            mh.getSetHeaders().add(sh);
            offset += sh.getLength();
        }
        if ((mh.getLength() - offset) != 0) {
            LOGGER.log(Level.INFO, "Unused bytes: " + (mh.getLength() - offset));
        }
        return mh;
    } catch (Exception e) {
        throw new HeaderException("Parse error: " + e.getMessage());
    }
}
#end_block

#method_before
public byte[] getBytes() throws HeaderException {
    try {
        byte[] data = new byte[length];
        // version number
        System.arraycopy(Shorts.toByteArray((short) versionNumber), 0, data, 0, 2);
        // length
        System.arraycopy(Shorts.toByteArray((short) length), 0, data, 2, 2);
        // export time
        System.arraycopy(Ints.toByteArray((int) exportTime.getTime() / 1000), 0, data, 4, 4);
        // sequence number
        System.arraycopy(Ints.toByteArray((int) sequenceNumber), 0, data, 8, 4);
        // observation domain id
        System.arraycopy(Ints.toByteArray((int) observationDomainID), 0, data, 12, 4);
        // set header
        int offset = HEADERLENGTH;
        for (SetHeader sh : setHeaders) {
            byte[] temp = sh.getBytes();
            System.arraycopy(temp, 0, data, offset, temp.length);
            offset += temp.length;
        }
        return data;
    } catch (Exception e) {
        e.printStackTrace();
        throw new HeaderException("Error while generating the bytes: " + e.getMessage());
    }
}
#method_after
public byte[] getBytes() throws HeaderException {
    try {
        byte[] data = new byte[length];
        // version number
        System.arraycopy(Shorts.toByteArray((short) versionNumber), 0, data, 0, 2);
        // length
        System.arraycopy(Shorts.toByteArray((short) length), 0, data, 2, 2);
        // export time
        System.arraycopy(Ints.toByteArray((int) exportTime.getTime() / 1000), 0, data, 4, 4);
        // sequence number
        System.arraycopy(Ints.toByteArray((int) sequenceNumber), 0, data, 8, 4);
        // observation domain id
        System.arraycopy(Ints.toByteArray((int) observationDomainID), 0, data, 12, 4);
        // set header
        int offset = HEADER_LENGTH;
        for (SetHeader sh : setHeaders) {
            byte[] temp = sh.getBytes();
            System.arraycopy(temp, 0, data, offset, temp.length);
            offset += temp.length;
        }
        return data;
    } catch (Exception e) {
        e.printStackTrace();
        throw new HeaderException("Error while generating the bytes: " + e.getMessage());
    }
}
#end_block

#method_before
public int getTemplateID() {
    return templateID;
}
#method_after
/**
 * Template Record header.
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * | Template ID (larger than 255) |         Field Count           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
public int getTemplateID() {
    return templateID;
}
#end_block

#method_before
public int getLength() {
    return HEADERLENGTH + (informationElements.size() * InformationElement.LENGTH);
}
#method_after
public int getLength() {
    return HEADER_LENGTH + (informationElements.size() * InformationElement.LENGTH);
}
#end_block

#method_before
public static TemplateRecord parse(byte[] data) throws HeaderException {
    try {
        if (data.length < 4) {
            throw new HeaderException("Data array too short.");
        }
        TemplateRecord tr = new TemplateRecord();
        // template ID
        byte[] templateID = new byte[2];
        System.arraycopy(data, 0, templateID, 0, 2);
        tr.setTemplateID(Ints.fromByteArray(templateID));
        // field count
        byte[] fieldCount = new byte[2];
        System.arraycopy(data, 2, fieldCount, 0, 2);
        tr.setFieldCount(Ints.fromByteArray(fieldCount));
        int offset = 4;
        for (int i = 0; i < tr.getFieldCount(); i++) {
            byte[] subData = new byte[InformationElement.LENGTH];
            System.arraycopy(data, offset + (i * InformationElement.LENGTH), subData, 0, InformationElement.LENGTH);
            InformationElement ie = InformationElement.parse(subData);
            tr.getInformationElements().add(ie);
        }
        return tr;
    } catch (Exception e) {
        throw new HeaderException("Parse error: " + e.getMessage());
    }
}
#method_after
public static TemplateRecord parse(byte[] data) throws HeaderException {
    try {
        if (data.length < HEADER_LENGTH) {
            throw new HeaderException("Data array too short.");
        }
        TemplateRecord tr = new TemplateRecord();
        // template ID
        byte[] templateID = new byte[2];
        System.arraycopy(data, 0, templateID, 0, 2);
        tr.setTemplateID(Ints.fromByteArray(templateID));
        // field count
        byte[] fieldCount = new byte[2];
        System.arraycopy(data, 2, fieldCount, 0, 2);
        tr.setFieldCount(Ints.fromByteArray(fieldCount));
        int offset = HEADER_LENGTH;
        for (int i = 0; i < tr.getFieldCount(); i++) {
            byte[] subData = new byte[InformationElement.LENGTH];
            System.arraycopy(data, offset + (i * InformationElement.LENGTH), subData, 0, InformationElement.LENGTH);
            InformationElement ie = InformationElement.parse(subData);
            tr.getInformationElements().add(ie);
        }
        return tr;
    } catch (Exception e) {
        throw new HeaderException("Parse error: " + e.getMessage());
    }
}
#end_block

#method_before
public byte[] getBytes() throws HeaderException {
    try {
        int length = 4 + (informationElements.size() * InformationElement.LENGTH);
        byte[] data = new byte[length];
        // template ID
        System.arraycopy(Shorts.toByteArray((short) getTemplateID()), 0, data, 0, 2);
        // field count
        System.arraycopy(Shorts.toByteArray((short) getFieldCount()), 0, data, 2, 2);
        // information elements
        int offset = 4;
        for (InformationElement ie : informationElements) {
            System.arraycopy(ie.getBytes(), 0, data, offset, InformationElement.LENGTH);
            offset += InformationElement.LENGTH;
        }
        return data;
    } catch (Exception e) {
        throw new HeaderException("Error while generating the bytes: " + e.getMessage());
    }
}
#method_after
public byte[] getBytes() throws HeaderException {
    try {
        int length = HEADER_LENGTH + (informationElements.size() * InformationElement.LENGTH);
        byte[] data = new byte[length];
        // template ID
        System.arraycopy(Shorts.toByteArray((short) getTemplateID()), 0, data, 0, 2);
        // field count
        System.arraycopy(Shorts.toByteArray((short) getFieldCount()), 0, data, 2, 2);
        // information elements
        int offset = HEADER_LENGTH;
        for (InformationElement ie : informationElements) {
            System.arraycopy(ie.getBytes(), 0, data, offset, InformationElement.LENGTH);
            offset += InformationElement.LENGTH;
        }
        return data;
    } catch (Exception e) {
        throw new HeaderException("Error while generating the bytes: " + e.getMessage());
    }
}
#end_block

#method_before
public static TemplateRecord getTemplateRecord() {
    TemplateRecord tr = new TemplateRecord();
    tr.setTemplateID(TEMPLATE_ID);
    tr.setFieldCount(FIELD_COUNT);
    List<InformationElement> ieTemp = tr.getInformationElements();
    InformationElement ieIpv4Exporter = new InformationElement();
    ieIpv4Exporter.setFieldLength(4);
    ieIpv4Exporter.setInformationElementID(130);
    ieTemp.add(ieIpv4Exporter);
    InformationElement ieIpv6Exporter = new InformationElement();
    ieIpv6Exporter.setFieldLength(16);
    ieIpv6Exporter.setInformationElementID(131);
    ieTemp.add(ieIpv6Exporter);
    InformationElement ieStart = new InformationElement();
    ieStart.setFieldLength(8);
    ieStart.setInformationElementID(152);
    ieTemp.add(ieStart);
    InformationElement ieEnd = new InformationElement();
    ieEnd.setFieldLength(8);
    ieEnd.setInformationElementID(153);
    ieTemp.add(ieEnd);
    InformationElement ieBytes = new InformationElement();
    ieBytes.setFieldLength(8);
    ieBytes.setInformationElementID(1);
    ieTemp.add(ieBytes);
    InformationElement iePackets = new InformationElement();
    iePackets.setFieldLength(8);
    iePackets.setInformationElementID(2);
    ieTemp.add(iePackets);
    InformationElement ieIngressIntf = new InformationElement();
    ieIngressIntf.setFieldLength(4);
    ieIngressIntf.setInformationElementID(10);
    ieTemp.add(ieIngressIntf);
    InformationElement ieEgressIntf = new InformationElement();
    ieEgressIntf.setFieldLength(4);
    ieEgressIntf.setInformationElementID(14);
    ieTemp.add(ieEgressIntf);
    InformationElement ieSrcMac = new InformationElement();
    ieSrcMac.setFieldLength(6);
    ieSrcMac.setInformationElementID(56);
    ieTemp.add(ieSrcMac);
    InformationElement ieDstMac = new InformationElement();
    ieDstMac.setFieldLength(6);
    ieDstMac.setInformationElementID(80);
    ieTemp.add(ieDstMac);
    InformationElement ieEtherType = new InformationElement();
    ieEtherType.setFieldLength(2);
    ieEtherType.setInformationElementID(256);
    ieTemp.add(ieEtherType);
    InformationElement ieVlanId = new InformationElement();
    ieVlanId.setFieldLength(2);
    ieVlanId.setInformationElementID(58);
    ieTemp.add(ieVlanId);
    InformationElement ieSrcIp = new InformationElement();
    ieSrcIp.setFieldLength(4);
    ieSrcIp.setInformationElementID(8);
    ieTemp.add(ieSrcIp);
    InformationElement ieDstIp = new InformationElement();
    ieDstIp.setFieldLength(4);
    ieDstIp.setInformationElementID(12);
    ieTemp.add(ieDstIp);
    InformationElement ieProtocol = new InformationElement();
    ieProtocol.setFieldLength(1);
    ieProtocol.setInformationElementID(4);
    ieTemp.add(ieProtocol);
    InformationElement ieTos = new InformationElement();
    ieTos.setFieldLength(1);
    ieTos.setInformationElementID(5);
    ieTemp.add(ieTos);
    InformationElement ieSrcPort = new InformationElement();
    ieSrcPort.setFieldLength(2);
    ieSrcPort.setInformationElementID(7);
    ieTemp.add(ieSrcPort);
    InformationElement ieDstPort = new InformationElement();
    ieDstPort.setFieldLength(2);
    ieDstPort.setInformationElementID(11);
    ieTemp.add(ieDstPort);
    return tr;
}
#method_after
public static TemplateRecord getTemplateRecord() {
    TemplateRecord tr = new TemplateRecord();
    tr.setTemplateID(TEMPLATE_ID);
    tr.setFieldCount(FIELD_COUNT);
    List<InformationElement> ieTemp = tr.getInformationElements();
    ieTemp.add(new InformationElement(Ie.exporterIPv4Address));
    ieTemp.add(new InformationElement(Ie.exporterIPv6Address));
    ieTemp.add(new InformationElement(Ie.flowStartMilliseconds));
    ieTemp.add(new InformationElement(Ie.flowEndMilliseconds));
    ieTemp.add(new InformationElement(Ie.octetDeltaCount));
    ieTemp.add(new InformationElement(Ie.packetDeltaCount));
    ieTemp.add(new InformationElement(Ie.ingressInterface));
    ieTemp.add(new InformationElement(Ie.egressInterface));
    ieTemp.add(new InformationElement(Ie.sourceMacAddress));
    ieTemp.add(new InformationElement(Ie.destinationMacAddress));
    ieTemp.add(new InformationElement(Ie.ethernetType));
    ieTemp.add(new InformationElement(Ie.vlanId));
    ieTemp.add(new InformationElement(Ie.sourceIPv4Address));
    ieTemp.add(new InformationElement(Ie.destinationIPv4Address));
    ieTemp.add(new InformationElement(Ie.protocolIdentifier));
    ieTemp.add(new InformationElement(Ie.ipClassOfService));
    ieTemp.add(new InformationElement(Ie.sourceTransportPort));
    ieTemp.add(new InformationElement(Ie.destinationTransportPort));
    return tr;
}
#end_block

#method_before
public static TemplateRecord getTemplateRecord() {
    TemplateRecord tr = new TemplateRecord();
    tr.setTemplateID(TEMPLATE_ID);
    tr.setFieldCount(FIELD_COUNT);
    List<InformationElement> ieTemp = tr.getInformationElements();
    InformationElement ieIpv4Exporter = new InformationElement();
    ieIpv4Exporter.setFieldLength(4);
    ieIpv4Exporter.setInformationElementID(130);
    ieTemp.add(ieIpv4Exporter);
    InformationElement ieIpv6Exporter = new InformationElement();
    ieIpv6Exporter.setFieldLength(16);
    ieIpv6Exporter.setInformationElementID(131);
    ieTemp.add(ieIpv6Exporter);
    InformationElement ieStart = new InformationElement();
    ieStart.setFieldLength(8);
    ieStart.setInformationElementID(152);
    ieTemp.add(ieStart);
    InformationElement ieEnd = new InformationElement();
    ieEnd.setFieldLength(8);
    ieEnd.setInformationElementID(153);
    ieTemp.add(ieEnd);
    InformationElement ieBytes = new InformationElement();
    ieBytes.setFieldLength(8);
    ieBytes.setInformationElementID(1);
    ieTemp.add(ieBytes);
    InformationElement iePackets = new InformationElement();
    iePackets.setFieldLength(8);
    iePackets.setInformationElementID(2);
    ieTemp.add(iePackets);
    InformationElement ieIngressIntf = new InformationElement();
    ieIngressIntf.setFieldLength(4);
    ieIngressIntf.setInformationElementID(10);
    ieTemp.add(ieIngressIntf);
    InformationElement ieEgressIntf = new InformationElement();
    ieEgressIntf.setFieldLength(4);
    ieEgressIntf.setInformationElementID(14);
    ieTemp.add(ieEgressIntf);
    InformationElement ieSrcMac = new InformationElement();
    ieSrcMac.setFieldLength(6);
    ieSrcMac.setInformationElementID(56);
    ieTemp.add(ieSrcMac);
    InformationElement ieDstMac = new InformationElement();
    ieDstMac.setFieldLength(6);
    ieDstMac.setInformationElementID(80);
    ieTemp.add(ieDstMac);
    InformationElement ieEtherType = new InformationElement();
    ieEtherType.setFieldLength(2);
    ieEtherType.setInformationElementID(256);
    ieTemp.add(ieEtherType);
    InformationElement ieVlanId = new InformationElement();
    ieVlanId.setFieldLength(2);
    ieVlanId.setInformationElementID(58);
    ieTemp.add(ieVlanId);
    InformationElement ieSrcIp6 = new InformationElement();
    ieSrcIp6.setFieldLength(16);
    ieSrcIp6.setInformationElementID(27);
    ieTemp.add(ieSrcIp6);
    InformationElement ieDstIp6 = new InformationElement();
    ieDstIp6.setFieldLength(16);
    ieDstIp6.setInformationElementID(28);
    ieTemp.add(ieDstIp6);
    InformationElement ieFlowLabel = new InformationElement();
    ieFlowLabel.setFieldLength(4);
    ieFlowLabel.setInformationElementID(31);
    ieTemp.add(ieFlowLabel);
    InformationElement ieProtocol = new InformationElement();
    ieProtocol.setFieldLength(1);
    ieProtocol.setInformationElementID(4);
    ieTemp.add(ieProtocol);
    InformationElement ieTos = new InformationElement();
    ieTos.setFieldLength(1);
    ieTos.setInformationElementID(5);
    ieTemp.add(ieTos);
    InformationElement ieSrcPort = new InformationElement();
    ieSrcPort.setFieldLength(2);
    ieSrcPort.setInformationElementID(7);
    ieTemp.add(ieSrcPort);
    InformationElement ieDstPort = new InformationElement();
    ieDstPort.setFieldLength(2);
    ieDstPort.setInformationElementID(11);
    ieTemp.add(ieDstPort);
    return tr;
}
#method_after
public static TemplateRecord getTemplateRecord() {
    TemplateRecord tr = new TemplateRecord();
    tr.setTemplateID(TEMPLATE_ID);
    tr.setFieldCount(FIELD_COUNT);
    List<InformationElement> ieTemp = tr.getInformationElements();
    ieTemp.add(new InformationElement(Ie.exporterIPv4Address));
    ieTemp.add(new InformationElement(Ie.exporterIPv6Address));
    ieTemp.add(new InformationElement(Ie.flowStartMilliseconds));
    ieTemp.add(new InformationElement(Ie.flowEndMilliseconds));
    ieTemp.add(new InformationElement(Ie.octetDeltaCount));
    ieTemp.add(new InformationElement(Ie.packetDeltaCount));
    ieTemp.add(new InformationElement(Ie.ingressInterface));
    ieTemp.add(new InformationElement(Ie.egressInterface));
    ieTemp.add(new InformationElement(Ie.sourceMacAddress));
    ieTemp.add(new InformationElement(Ie.destinationMacAddress));
    ieTemp.add(new InformationElement(Ie.ethernetType));
    ieTemp.add(new InformationElement(Ie.vlanId));
    ieTemp.add(new InformationElement(Ie.sourceIPv6Address));
    ieTemp.add(new InformationElement(Ie.destinationIPv6Address));
    ieTemp.add(new InformationElement(Ie.flowLabelIPv6));
    ieTemp.add(new InformationElement(Ie.protocolIdentifier));
    ieTemp.add(new InformationElement(Ie.ipClassOfService));
    ieTemp.add(new InformationElement(Ie.sourceTransportPort));
    ieTemp.add(new InformationElement(Ie.destinationTransportPort));
    return tr;
}
#end_block

#method_before
@Override
public void event(FlowRuleEvent event) {
    switch(event.type()) {
        case RULE_REMOVED:
            FlowRule rule = event.subject();
            FlowEntry entry = (FlowEntry) rule;
            if (entry.appId() == of2ipfix.coreService.getAppId("org.onosproject.fwd").id()) {
                flowRemovedRfwd(entry);
            }
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(FlowRuleEvent event) {
    switch(event.type()) {
        case RULE_REMOVED:
            FlowRule rule = event.subject();
            FlowEntry entry = (FlowEntry) rule;
            if (entry.appId() == ipfixManager.coreService.getAppId("org.onosproject.fwd").id()) {
                flowRemovedRfwd(entry);
            }
            break;
        default:
            break;
    }
}
#end_block

#method_before
private void flowRemovedRfwd(FlowEntry entry) {
    // Log
    of2ipfix.log.trace("Flow Removed from Reactive Forwarding, id={}, device={}, selector={}, treatment={}", entry.id(), entry.deviceId(), entry.selector(), entry.treatment());
    // Exporters
    IpAddress exporterIpv4 = IpAddress.valueOf(of2ipfix.deviceService.getDevice(entry.deviceId()).annotations().toString().split("=")[2].split(":")[0]);
    long dpid = Dpid.dpid(entry.deviceId().uri()).value();
    byte[] byteExporterIpv6 = new byte[16];
    System.arraycopy(Longs.toByteArray(0), 0, byteExporterIpv6, 0, 8);
    System.arraycopy(Longs.toByteArray(dpid), 0, byteExporterIpv6, 8, 8);
    Ip6Address exporterIpv6 = Ip6Address.valueOf(byteExporterIpv6);
    // Timestamps, octets, packets
    long start = System.currentTimeMillis() - (1000 * entry.life());
    long end = System.currentTimeMillis();
    long octets = entry.bytes();
    long packets = entry.packets();
    // Input and Output ports
    PortCriterion portCrit = (PortCriterion) entry.selector().getCriterion(Type.IN_PORT);
    int intfIn = (portCrit == null) ? 0 : (int) portCrit.port().toLong();
    List<Instruction> instructions = entry.treatment().allInstructions();
    int intfOut = 0;
    for (Instruction instruction : instructions) {
        if (instruction.type() == Instruction.Type.OUTPUT) {
            OutputInstruction outputInstruction = (OutputInstruction) instruction;
            intfOut = (outputInstruction == null) ? 0 : (int) outputInstruction.port().toLong();
        }
    }
    // Ethernet MACs, Ethertype and VLAN
    EthCriterion ethCrit;
    ethCrit = (EthCriterion) entry.selector().getCriterion(Type.ETH_SRC);
    MacAddress srcMac = (ethCrit == null) ? MacAddress.valueOf("00:00:00:00:00:00") : ethCrit.mac();
    ethCrit = (EthCriterion) entry.selector().getCriterion(Type.ETH_DST);
    MacAddress dstMac = (ethCrit == null) ? MacAddress.valueOf("00:00:00:00:00:00") : ethCrit.mac();
    EthTypeCriterion ethTypeCrit = (EthTypeCriterion) entry.selector().getCriterion(Type.ETH_TYPE);
    Short ethType = (ethTypeCrit == null) ? 0x0000 : ethTypeCrit.ethType().toShort();
    VlanIdCriterion vlanCrit = (VlanIdCriterion) entry.selector().getCriterion(Type.VLAN_VID);
    Short vlan = (vlanCrit == null) ? 0x0000 : vlanCrit.vlanId().toShort();
    // IP Criterion check
    IPCriterion srcIpCrit = (IPCriterion) entry.selector().getCriterion(Type.IPV4_SRC);
    IPCriterion dstIpCrit = (IPCriterion) entry.selector().getCriterion(Type.IPV4_DST);
    IPCriterion srcIp6Crit = (IPCriterion) entry.selector().getCriterion(Type.IPV6_SRC);
    IPCriterion dstIp6Crit = (IPCriterion) entry.selector().getCriterion(Type.IPV6_DST);
    // If IP criterions are null send MAC Data Record, else send IPv4 or IPv6 Data Record
    if (srcIpCrit == null && dstIpCrit == null && srcIp6Crit == null && dstIp6Crit == null) {
        DataRecordRfwdMac record = new DataRecordRfwdMac(exporterIpv4, exporterIpv6, start, end, octets, packets, intfIn, intfOut, srcMac, dstMac, ethType, vlan);
        List<DataRecord> recordList = new ArrayList<DataRecord>();
        recordList.add(record);
        of2ipfix.ipfixSender.sendRecords(DataRecordRfwdMac.getTemplateRecord(), recordList, dpid, IpfixManager.collectorIp, IpfixManager.collectorPort);
    } else {
        // Checking IPv4 and IPv6 criterions
        IPProtocolCriterion protocolCrit = (IPProtocolCriterion) entry.selector().getCriterion(Type.IP_PROTO);
        byte ipProtocol = (protocolCrit == null) ? (byte) 0xff : (byte) protocolCrit.protocol();
        IPDscpCriterion dscpCrit = (IPDscpCriterion) entry.selector().getCriterion(Type.IP_DSCP);
        byte dscp = (dscpCrit == null) ? 0x00 : dscpCrit.ipDscp();
        IPEcnCriterion ecnCrit = (IPEcnCriterion) entry.selector().getCriterion(Type.IP_ECN);
        byte ecn = (ecnCrit == null) ? 0x00 : ecnCrit.ipEcn();
        byte tos = (byte) ((byte) (dscp << 2) | ecn);
        IPv6FlowLabelCriterion flowLabelCrit = (IPv6FlowLabelCriterion) entry.selector().getCriterion(Type.IPV6_FLABEL);
        int flowLabelIpv6 = (flowLabelCrit == null) ? 0 : flowLabelCrit.flowLabel();
        int srcPort = 0;
        int dstPort = 0;
        if (ipProtocol == 6) {
            TcpPortCriterion tcpCrit;
            tcpCrit = (TcpPortCriterion) entry.selector().getCriterion(Type.TCP_SRC);
            srcPort = (tcpCrit == null) ? 0 : tcpCrit.tcpPort().toInt();
            tcpCrit = (TcpPortCriterion) entry.selector().getCriterion(Type.TCP_DST);
            dstPort = (tcpCrit == null) ? 0 : tcpCrit.tcpPort().toInt();
        } else if (ipProtocol == 17) {
            UdpPortCriterion udpCrit;
            udpCrit = (UdpPortCriterion) entry.selector().getCriterion(Type.UDP_SRC);
            srcPort = (udpCrit == null) ? 0 : udpCrit.udpPort().toInt();
            udpCrit = (UdpPortCriterion) entry.selector().getCriterion(Type.UDP_DST);
            dstPort = (udpCrit == null) ? 0 : udpCrit.udpPort().toInt();
        } else if (ipProtocol == 1) {
            IcmpTypeCriterion icmpTypeCrit = (IcmpTypeCriterion) entry.selector().getCriterion(Type.ICMPV4_TYPE);
            Short icmpType = (icmpTypeCrit == null) ? 0 : icmpTypeCrit.icmpType();
            IcmpCodeCriterion icmpCodeCrit = (IcmpCodeCriterion) entry.selector().getCriterion(Type.ICMPV4_CODE);
            Short icmpCode = (icmpCodeCrit == null) ? 0 : icmpCodeCrit.icmpCode();
            dstPort = 256 * icmpType + icmpCode;
        } else if (ipProtocol == 58) {
            Icmpv6TypeCriterion icmpv6TypeCrit = (Icmpv6TypeCriterion) entry.selector().getCriterion(Type.ICMPV6_TYPE);
            Short icmpType = (icmpv6TypeCrit == null) ? 0 : icmpv6TypeCrit.icmpv6Type();
            Icmpv6CodeCriterion icmpv6CodeCrit = (Icmpv6CodeCriterion) entry.selector().getCriterion(Type.ICMPV6_CODE);
            Short icmpCode = (icmpv6CodeCrit == null) ? 0 : icmpv6CodeCrit.icmpv6Code();
            dstPort = 256 * icmpType + icmpCode;
        }
        // If IPv4 than send IPv4 Data record
        if ((srcIpCrit != null || dstIpCrit != null) && ethType == Ethernet.TYPE_IPV4) {
            IpAddress srcIp = (srcIpCrit == null) ? IpAddress.valueOf(0) : srcIpCrit.ip().address();
            IpAddress dstIp = (dstIpCrit == null) ? IpAddress.valueOf(0) : dstIpCrit.ip().address();
            DataRecordRfwdIpv4 record = new DataRecordRfwdIpv4(exporterIpv4, exporterIpv6, start, end, octets, packets, intfIn, intfOut, srcMac, dstMac, ethType, vlan, srcIp, dstIp, ipProtocol, tos, (short) srcPort, (short) dstPort);
            List<DataRecord> recordList = new ArrayList<DataRecord>();
            recordList.add(record);
            of2ipfix.ipfixSender.sendRecords(DataRecordRfwdIpv4.getTemplateRecord(), recordList, dpid, IpfixManager.collectorIp, IpfixManager.collectorPort);
        }
        // If IPv6 than send IPv6 Data record
        if ((srcIp6Crit != null || dstIp6Crit != null) && ethType == Ethernet.TYPE_IPV6) {
            Ip6Address srcIp6 = (srcIp6Crit == null) ? Ip6Address.valueOf("0:0:0:0:0:0:0:0") : srcIp6Crit.ip().address().getIp6Address();
            Ip6Address dstIp6 = (dstIp6Crit == null) ? Ip6Address.valueOf("0:0:0:0:0:0:0:0") : dstIp6Crit.ip().address().getIp6Address();
            DataRecordRfwdIpv6 record = new DataRecordRfwdIpv6(exporterIpv4, exporterIpv6, start, end, octets, packets, intfIn, intfOut, srcMac, dstMac, ethType, vlan, srcIp6, dstIp6, flowLabelIpv6, ipProtocol, tos, (short) srcPort, (short) dstPort);
            List<DataRecord> recordList = new ArrayList<DataRecord>();
            recordList.add(record);
            of2ipfix.ipfixSender.sendRecords(DataRecordRfwdIpv6.getTemplateRecord(), recordList, dpid, IpfixManager.collectorIp, IpfixManager.collectorPort);
        }
    }
}
#method_after
private void flowRemovedRfwd(FlowEntry entry) {
    // Log
    ipfixManager.log.trace("Flow Removed from Reactive Forwarding, id={}, device={}, selector={}, treatment={}", entry.id(), entry.deviceId(), entry.selector(), entry.treatment());
    // Exporters
    IpAddress exporterIpv4 = IpAddress.valueOf(ipfixManager.deviceService.getDevice(entry.deviceId()).annotations().toString().split("=")[2].split(":")[0]);
    long dpid = Dpid.dpid(entry.deviceId().uri()).value();
    byte[] byteExporterIpv6 = new byte[16];
    System.arraycopy(Longs.toByteArray(0), 0, byteExporterIpv6, 0, 8);
    System.arraycopy(Longs.toByteArray(dpid), 0, byteExporterIpv6, 8, 8);
    Ip6Address exporterIpv6 = Ip6Address.valueOf(byteExporterIpv6);
    // Timestamps, octets, packets
    long start = System.currentTimeMillis() - (1000 * entry.life());
    long end = System.currentTimeMillis();
    long octets = entry.bytes();
    long packets = entry.packets();
    // Input and Output ports
    PortCriterion portCrit = (PortCriterion) entry.selector().getCriterion(Type.IN_PORT);
    int intfIn = (portCrit == null) ? 0 : (int) portCrit.port().toLong();
    List<Instruction> instructions = entry.treatment().allInstructions();
    int intfOut = 0;
    for (Instruction instruction : instructions) {
        if (instruction.type() == Instruction.Type.OUTPUT) {
            OutputInstruction outputInstruction = (OutputInstruction) instruction;
            intfOut = (outputInstruction == null) ? 0 : (int) outputInstruction.port().toLong();
        }
    }
    // Ethernet MACs, Ethertype and VLAN
    EthCriterion ethCrit;
    ethCrit = (EthCriterion) entry.selector().getCriterion(Type.ETH_SRC);
    MacAddress srcMac = (ethCrit == null) ? MacAddress.valueOf("00:00:00:00:00:00") : ethCrit.mac();
    ethCrit = (EthCriterion) entry.selector().getCriterion(Type.ETH_DST);
    MacAddress dstMac = (ethCrit == null) ? MacAddress.valueOf("00:00:00:00:00:00") : ethCrit.mac();
    EthTypeCriterion ethTypeCrit = (EthTypeCriterion) entry.selector().getCriterion(Type.ETH_TYPE);
    Short ethType = (ethTypeCrit == null) ? 0x0000 : ethTypeCrit.ethType().toShort();
    VlanIdCriterion vlanCrit = (VlanIdCriterion) entry.selector().getCriterion(Type.VLAN_VID);
    Short vlan = (vlanCrit == null) ? 0x0000 : vlanCrit.vlanId().toShort();
    // IP Criterion check
    IPCriterion srcIpCrit = (IPCriterion) entry.selector().getCriterion(Type.IPV4_SRC);
    IPCriterion dstIpCrit = (IPCriterion) entry.selector().getCriterion(Type.IPV4_DST);
    IPCriterion srcIp6Crit = (IPCriterion) entry.selector().getCriterion(Type.IPV6_SRC);
    IPCriterion dstIp6Crit = (IPCriterion) entry.selector().getCriterion(Type.IPV6_DST);
    // If IP criterions are null send MAC Data Record, else send IPv4 or IPv6 Data Record
    if (srcIpCrit == null && dstIpCrit == null && srcIp6Crit == null && dstIp6Crit == null) {
        DataRecordRfwdMac record = new DataRecordRfwdMac(exporterIpv4, exporterIpv6, start, end, octets, packets, intfIn, intfOut, srcMac, dstMac, ethType, vlan);
        List<DataRecord> recordList = new ArrayList<DataRecord>();
        recordList.add(record);
        ipfixManager.ipfixSender.sendRecords(DataRecordRfwdMac.getTemplateRecord(), recordList, dpid, IpfixManager.collectorIp, IpfixManager.collectorPort);
    } else {
        // Checking IPv4 and IPv6 criterions
        IPProtocolCriterion protocolCrit = (IPProtocolCriterion) entry.selector().getCriterion(Type.IP_PROTO);
        byte ipProtocol = (protocolCrit == null) ? (byte) 0xff : (byte) protocolCrit.protocol();
        IPDscpCriterion dscpCrit = (IPDscpCriterion) entry.selector().getCriterion(Type.IP_DSCP);
        byte dscp = (dscpCrit == null) ? 0x00 : dscpCrit.ipDscp();
        IPEcnCriterion ecnCrit = (IPEcnCriterion) entry.selector().getCriterion(Type.IP_ECN);
        byte ecn = (ecnCrit == null) ? 0x00 : ecnCrit.ipEcn();
        byte tos = (byte) ((byte) (dscp << 2) | ecn);
        IPv6FlowLabelCriterion flowLabelCrit = (IPv6FlowLabelCriterion) entry.selector().getCriterion(Type.IPV6_FLABEL);
        int flowLabelIpv6 = (flowLabelCrit == null) ? 0 : flowLabelCrit.flowLabel();
        int srcPort = 0;
        int dstPort = 0;
        if (ipProtocol == IPv4.PROTOCOL_TCP) {
            TcpPortCriterion tcpCrit;
            tcpCrit = (TcpPortCriterion) entry.selector().getCriterion(Type.TCP_SRC);
            srcPort = (tcpCrit == null) ? 0 : tcpCrit.tcpPort().toInt();
            tcpCrit = (TcpPortCriterion) entry.selector().getCriterion(Type.TCP_DST);
            dstPort = (tcpCrit == null) ? 0 : tcpCrit.tcpPort().toInt();
        } else if (ipProtocol == IPv4.PROTOCOL_UDP) {
            UdpPortCriterion udpCrit;
            udpCrit = (UdpPortCriterion) entry.selector().getCriterion(Type.UDP_SRC);
            srcPort = (udpCrit == null) ? 0 : udpCrit.udpPort().toInt();
            udpCrit = (UdpPortCriterion) entry.selector().getCriterion(Type.UDP_DST);
            dstPort = (udpCrit == null) ? 0 : udpCrit.udpPort().toInt();
        } else if (ipProtocol == IPv4.PROTOCOL_ICMP) {
            IcmpTypeCriterion icmpTypeCrit = (IcmpTypeCriterion) entry.selector().getCriterion(Type.ICMPV4_TYPE);
            Short icmpType = (icmpTypeCrit == null) ? 0 : icmpTypeCrit.icmpType();
            IcmpCodeCriterion icmpCodeCrit = (IcmpCodeCriterion) entry.selector().getCriterion(Type.ICMPV4_CODE);
            Short icmpCode = (icmpCodeCrit == null) ? 0 : icmpCodeCrit.icmpCode();
            dstPort = 256 * icmpType + icmpCode;
        } else if (ipProtocol == IPv6.PROTOCOL_ICMP6) {
            Icmpv6TypeCriterion icmpv6TypeCrit = (Icmpv6TypeCriterion) entry.selector().getCriterion(Type.ICMPV6_TYPE);
            Short icmpType = (icmpv6TypeCrit == null) ? 0 : icmpv6TypeCrit.icmpv6Type();
            Icmpv6CodeCriterion icmpv6CodeCrit = (Icmpv6CodeCriterion) entry.selector().getCriterion(Type.ICMPV6_CODE);
            Short icmpCode = (icmpv6CodeCrit == null) ? 0 : icmpv6CodeCrit.icmpv6Code();
            dstPort = 256 * icmpType + icmpCode;
        }
        // If IPv4 than send IPv4 Data record
        if ((srcIpCrit != null || dstIpCrit != null) && ethType == Ethernet.TYPE_IPV4) {
            IpAddress srcIp = (srcIpCrit == null) ? IpAddress.valueOf(0) : srcIpCrit.ip().address();
            IpAddress dstIp = (dstIpCrit == null) ? IpAddress.valueOf(0) : dstIpCrit.ip().address();
            DataRecordRfwdIpv4 record = new DataRecordRfwdIpv4(exporterIpv4, exporterIpv6, start, end, octets, packets, intfIn, intfOut, srcMac, dstMac, ethType, vlan, srcIp, dstIp, ipProtocol, tos, (short) srcPort, (short) dstPort);
            List<DataRecord> recordList = new ArrayList<DataRecord>();
            recordList.add(record);
            ipfixManager.ipfixSender.sendRecords(DataRecordRfwdIpv4.getTemplateRecord(), recordList, dpid, IpfixManager.collectorIp, IpfixManager.collectorPort);
        }
        // If IPv6 than send IPv6 Data record
        if ((srcIp6Crit != null || dstIp6Crit != null) && ethType == Ethernet.TYPE_IPV6) {
            Ip6Address srcIp6 = (srcIp6Crit == null) ? Ip6Address.valueOf("0:0:0:0:0:0:0:0") : srcIp6Crit.ip().address().getIp6Address();
            Ip6Address dstIp6 = (dstIp6Crit == null) ? Ip6Address.valueOf("0:0:0:0:0:0:0:0") : dstIp6Crit.ip().address().getIp6Address();
            DataRecordRfwdIpv6 record = new DataRecordRfwdIpv6(exporterIpv4, exporterIpv6, start, end, octets, packets, intfIn, intfOut, srcMac, dstMac, ethType, vlan, srcIp6, dstIp6, flowLabelIpv6, ipProtocol, tos, (short) srcPort, (short) dstPort);
            List<DataRecord> recordList = new ArrayList<DataRecord>();
            recordList.add(record);
            ipfixManager.ipfixSender.sendRecords(DataRecordRfwdIpv6.getTemplateRecord(), recordList, dpid, IpfixManager.collectorIp, IpfixManager.collectorPort);
        }
    }
}
#end_block

#method_before
public void sendRecords(TemplateRecord tr, List<DataRecord> recordsList, long oid, IpAddress collector, int port) {
    MessageHeader mh = new MessageHeader();
    mh.setVersionNumber(IPFIX_VERSION);
    mh.setObservationDomainID(oid);
    seqNumber++;
    mh.setSequenceNumber(seqNumber);
    mh.setExportTime(new Date());
    // Set header for the template
    SetHeader shTemplate = new SetHeader();
    shTemplate.setSetID(TEMPLATE_SETID);
    // Add template record
    List<TemplateRecord> trTemp = shTemplate.getTemplateRecords();
    trTemp.add(tr);
    shTemplate.setTemplateRecords(trTemp);
    // Set header for the Data Records
    SetHeader shData = new SetHeader();
    shData.setSetID(tr.getTemplateID());
    // Add Data records from the recordsList
    List<DataRecord> drTemp = shData.getDataRecords();
    for (DataRecord tempRecord : recordsList) {
        drTemp.add(tempRecord);
    }
    shData.setDataRecords(drTemp);
    // Make Set Headers from Template and Data
    List<SetHeader> shTemp = mh.getSetHeaders();
    shTemp.add(shTemplate);
    shTemp.add(shData);
    mh.setSetHeaders(shTemp);
    // socket handling and IPFIX UDP packet sending
    InetAddress collectorAddress = null;
    try {
        collectorAddress = InetAddress.getByAddress(collector.toOctets());
    } catch (UnknownHostException e) {
        e.printStackTrace();
    }
    DatagramSocket dSocket = null;
    DatagramPacket dPacket = null;
    try {
        dSocket = new DatagramSocket();
    } catch (SocketException e) {
        e.printStackTrace();
    }
    try {
        dPacket = new DatagramPacket(mh.getBytes(), mh.getBytes().length, collectorAddress, port);
    } catch (HeaderException e) {
        e.printStackTrace();
    }
    try {
        dSocket.send(dPacket);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
#method_after
public void sendRecords(TemplateRecord tr, List<DataRecord> recordsList, long oid, IpAddress collector, int port) {
    MessageHeader mh = new MessageHeader();
    mh.setVersionNumber(IPFIX_VERSION);
    mh.setObservationDomainID(oid);
    seqNumber++;
    mh.setSequenceNumber(seqNumber);
    mh.setExportTime(new Date());
    // Set header for the template
    SetHeader shTemplate = new SetHeader();
    shTemplate.setSetID(TEMPLATE_SETID);
    // Add template record
    List<TemplateRecord> trTemp = shTemplate.getTemplateRecords();
    trTemp.add(tr);
    shTemplate.setTemplateRecords(trTemp);
    // Set header for the Data Records
    SetHeader shData = new SetHeader();
    shData.setSetID(tr.getTemplateID());
    // Add Data records from the recordsList
    List<DataRecord> drTemp = shData.getDataRecords();
    for (DataRecord tempRecord : recordsList) {
        drTemp.add(tempRecord);
    }
    shData.setDataRecords(drTemp);
    // Make Set Headers from Template and Data
    List<SetHeader> shTemp = mh.getSetHeaders();
    shTemp.add(shTemplate);
    shTemp.add(shData);
    mh.setSetHeaders(shTemp);
    // socket handling and IPFIX UDP packet sending
    InetAddress collectorAddress = null;
    try {
        collectorAddress = InetAddress.getByAddress(collector.toOctets());
    } catch (UnknownHostException e) {
        ipfixManager.log.warn("IPFIX Collector IP address format problem: " + e.getMessage());
        return;
    }
    DatagramSocket dSocket = null;
    DatagramPacket dPacket = null;
    try {
        dSocket = new DatagramSocket();
    } catch (SocketException e) {
        ipfixManager.log.warn("IPFIX datagram socket problem: " + e.getMessage());
        return;
    }
    try {
        dPacket = new DatagramPacket(mh.getBytes(), mh.getBytes().length, collectorAddress, port);
    } catch (HeaderException e) {
        ipfixManager.log.warn("IPFIX datagram packet problem: " + e.getMessage());
        dSocket.close();
        return;
    }
    try {
        dSocket.send(dPacket);
    } catch (IOException e) {
        ipfixManager.log.warn("IPFIX packet send IO exception: " + e.getMessage());
        dSocket.close();
        return;
    }
    dSocket.close();
}
#end_block

#method_before
public int getSetID() {
    return setID;
}
#method_after
/**
 * Set Header format.
 *
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |          Set ID               |          Length               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
public int getSetID() {
    return setID;
}
#end_block

#method_before
private void updateLength() {
    int newLength = 0;
    for (TemplateRecord template : templateRecords) {
        newLength += template.getLength();
    }
    for (OptionTemplateRecord optionTemplate : optionTemplateRecords) {
        newLength += optionTemplate.getLength();
    }
    for (DataRecord record : dataRecords) {
        newLength += record.getLength();
    }
    this.length = newLength + HEADERLENGTH;
}
#method_after
private void updateLength() {
    int newLength = 0;
    for (TemplateRecord template : templateRecords) {
        newLength += template.getLength();
    }
    for (OptionTemplateRecord optionTemplate : optionTemplateRecords) {
        newLength += optionTemplate.getLength();
    }
    for (DataRecord record : dataRecords) {
        newLength += record.getLength();
    }
    this.length = newLength + HEADER_LENGTH;
}
#end_block

#method_before
public static SetHeader parse(byte[] data) throws HeaderException {
    try {
        if (data.length < 4) {
            throw new HeaderException("Data array too short.");
        }
        SetHeader sh = new SetHeader();
        // set id
        byte[] setID = new byte[2];
        System.arraycopy(data, 0, setID, 0, 2);
        sh.setSetID(Ints.fromByteArray(setID));
        // length
        byte[] length = new byte[2];
        System.arraycopy(data, 2, length, 0, 2);
        sh.setLength(Ints.fromByteArray(length));
        // 2 -> template sets;
        if (sh.getSetID() == 2) {
            int offset = 4;
            byte[] subData = new byte[sh.getLength() - offset];
            System.arraycopy(data, offset, subData, 0, subData.length);
            TemplateRecord tr = TemplateRecord.parse(subData);
            sh.getTemplateRecords().add(tr);
        } else if (sh.getSetID() == 3) {
            // 3 -> template option sets
            int offset = 4;
            byte[] subData = new byte[sh.getLength() - offset];
            System.arraycopy(data, offset, subData, 0, subData.length);
            OptionTemplateRecord otr = OptionTemplateRecord.parse(subData);
            sh.getOptionTemplateRecords().add(otr);
        } else if (sh.getSetID() == 256) {
            // > 256 -> data record;
            int offset = 4;
            byte[] subData = new byte[sh.getLength() - offset];
            System.arraycopy(data, offset, subData, 0, subData.length);
            SamplingDataRecord sdr = SamplingDataRecord.parse(subData);
            sh.getDataRecords().add(sdr);
        } else {
            LOGGER.log(Level.INFO, "Set ID " + sh.getSetID() + " is unknown and not handled");
        }
        return sh;
    } catch (Exception e) {
        throw new HeaderException("Parse error: " + e.getMessage());
    }
}
#method_after
public static SetHeader parse(byte[] data) throws HeaderException {
    try {
        if (data.length < HEADER_LENGTH) {
            throw new HeaderException("Data array too short.");
        }
        SetHeader sh = new SetHeader();
        // set id
        byte[] setID = new byte[2];
        System.arraycopy(data, 0, setID, 0, 2);
        sh.setSetID(Ints.fromByteArray(setID));
        // length
        byte[] length = new byte[2];
        System.arraycopy(data, 2, length, 0, 2);
        sh.setLength(Ints.fromByteArray(length));
        // 2 -> template sets;
        if (sh.getSetID() == TEMPLATE_SET_ID) {
            int offset = HEADER_LENGTH;
            byte[] subData = new byte[sh.getLength() - offset];
            System.arraycopy(data, offset, subData, 0, subData.length);
            TemplateRecord tr = TemplateRecord.parse(subData);
            sh.getTemplateRecords().add(tr);
        } else if (sh.getSetID() == OPTION_SET_ID) {
            // 3 -> template option sets
            int offset = HEADER_LENGTH;
            byte[] subData = new byte[sh.getLength() - offset];
            System.arraycopy(data, offset, subData, 0, subData.length);
            OptionTemplateRecord otr = OptionTemplateRecord.parse(subData);
            sh.getOptionTemplateRecords().add(otr);
        } else if (sh.getSetID() == 256) {
            // > 256 -> data record;
            int offset = HEADER_LENGTH;
            byte[] subData = new byte[sh.getLength() - offset];
            System.arraycopy(data, offset, subData, 0, subData.length);
            SamplingDataRecord sdr = SamplingDataRecord.parse(subData);
            sh.getDataRecords().add(sdr);
        } else {
            LOGGER.log(Level.INFO, "Set ID " + sh.getSetID() + " is unknown and not handled");
        }
        return sh;
    } catch (Exception e) {
        throw new HeaderException("Parse error: " + e.getMessage());
    }
}
#end_block

#method_before
public byte[] getBytes() throws HeaderException {
    try {
        int length = HEADERLENGTH;
        for (DataRecord dr : dataRecords) {
            length += dr.getLength();
        }
        for (TemplateRecord tr : templateRecords) {
            length += tr.getLength();
        }
        for (OptionTemplateRecord otr : optionTemplateRecords) {
            length += otr.getLength();
        }
        byte[] data = new byte[length];
        // set id
        System.arraycopy(Shorts.toByteArray((short) getSetID()), 0, data, 0, 2);
        // length
        System.arraycopy(Shorts.toByteArray((short) getLength()), 0, data, 2, 2);
        // data record
        int offset = 4;
        for (DataRecord record : dataRecords) {
            System.arraycopy(record.getBytes(), 0, data, offset, record.getLength());
            offset += record.getLength();
        }
        for (TemplateRecord record : templateRecords) {
            byte[] recordData = record.getBytes();
            System.arraycopy(recordData, 0, data, offset, record.getLength());
            offset += recordData.length;
        }
        for (OptionTemplateRecord record : optionTemplateRecords) {
            byte[] recordData = record.getBytes();
            System.arraycopy(recordData, 0, data, offset, record.getLength());
            offset += recordData.length;
        }
        return data;
    } catch (Exception e) {
        throw new HeaderException("Error while generating the bytes: " + e.getMessage());
    }
}
#method_after
public byte[] getBytes() throws HeaderException {
    try {
        int length = HEADER_LENGTH;
        for (DataRecord dr : dataRecords) {
            length += dr.getLength();
        }
        for (TemplateRecord tr : templateRecords) {
            length += tr.getLength();
        }
        for (OptionTemplateRecord otr : optionTemplateRecords) {
            length += otr.getLength();
        }
        byte[] data = new byte[length];
        // set id
        System.arraycopy(Shorts.toByteArray((short) getSetID()), 0, data, 0, 2);
        // length
        System.arraycopy(Shorts.toByteArray((short) getLength()), 0, data, 2, 2);
        // data record
        int offset = HEADER_LENGTH;
        for (DataRecord record : dataRecords) {
            System.arraycopy(record.getBytes(), 0, data, offset, record.getLength());
            offset += record.getLength();
        }
        for (TemplateRecord record : templateRecords) {
            byte[] recordData = record.getBytes();
            System.arraycopy(recordData, 0, data, offset, record.getLength());
            offset += recordData.length;
        }
        for (OptionTemplateRecord record : optionTemplateRecords) {
            byte[] recordData = record.getBytes();
            System.arraycopy(recordData, 0, data, offset, record.getLength());
            offset += recordData.length;
        }
        return data;
    } catch (Exception e) {
        throw new HeaderException("Error while generating the bytes: " + e.getMessage());
    }
}
#end_block

#method_before
@Override
public void onHostDetected(Host host) {
    String ifaceId = host.annotations().value(IFACEID);
    DeviceId deviceId = host.location().deviceId();
    String currentControllerIp = getControllerIpOfSwitch(deviceId);
    Iterable<Device> devices = deviceService.getAvailableDevices();
    VirtualPortId portId = VirtualPortId.portId(ifaceId);
    VirtualPort port = virtualPortService.getPort(portId);
    TenantNetwork network = tenantNetworkService.getNetwork(port.networkId());
    String tunnelName = "vxlan-" + currentControllerIp;
    binding.put(host.id(), network.segmentationId());
    List<Port> allPorts = deviceService.getPorts(deviceId);
    PortNumber inPort = host.location().port();
    List<PortNumber> localVmPorts = getLocalPorts(deviceId, ifaceId);
    List<PortNumber> localTunnelPorts = new ArrayList<>();
    Sets.newHashSet(allPorts.iterator()).stream().filter(p -> !p.number().equals(PortNumber.LOCAL)).forEach(p -> {
        if (p.annotations().value("portName").startsWith(PORT_HEAD)) {
            localTunnelPorts.add(p.number());
        }
    });
    localVmPorts.forEach(lp -> programLocalBcastRules(deviceId, network.segmentationId(), lp, localVmPorts, localTunnelPorts, appId, Objective.Operation.ADD));
    programLocalOut(deviceId, network.segmentationId(), inPort, host.mac(), appId, Objective.Operation.ADD);
    localTunnelPorts.forEach(tp -> programTunnelFloodOut(deviceId, network.segmentationId(), tp, localVmPorts, appId, Objective.Operation.ADD));
    Sets.newHashSet(devices).stream().filter(d -> d.type() == Device.Type.CONTROLLER).forEach(d -> {
        DriverHandler handler = driverService.createHandler(d.id());
        BridgeConfig bridgeConfig = handler.behaviour(BridgeConfig.class);
        Collection<BridgeDescription> bridgeDescriptions = bridgeConfig.getBridges();
        Iterator<BridgeDescription> it = bridgeDescriptions.iterator();
        if (it.hasNext()) {
            BridgeDescription sw = it.next();
            Set<PortNumber> ports = bridgeConfig.getPortNumbers();
            ports.stream().filter(p -> p.name().equalsIgnoreCase(tunnelName)).forEach(p -> {
                programTunnelOut(sw.deviceId(), network.segmentationId(), p, host.mac(), appId, Objective.Operation.ADD);
            });
        }
    });
    programLocalIn(deviceId, network.segmentationId(), inPort, host.mac(), appId, Objective.Operation.ADD);
    localTunnelPorts.forEach(tp -> programTunnelIn(deviceId, network.segmentationId(), tp, inPort, host.mac(), appId, Objective.Operation.ADD));
}
#method_after
@Override
public void onHostDetected(Host host) {
    String ifaceId = host.annotations().value(IFACEID);
    DeviceId deviceId = host.location().deviceId();
    String currentControllerIp = getControllerIpOfSwitch(deviceId);
    Iterable<Device> devices = deviceService.getAvailableDevices();
    VirtualPortId portId = VirtualPortId.portId(ifaceId);
    VirtualPort port = virtualPortService.getPort(portId);
    TenantNetwork network = tenantNetworkService.getNetwork(port.networkId());
    String tunnelName = "vxlan-" + currentControllerIp;
    binding.put(host.id(), network.segmentationId());
    List<Port> allPorts = deviceService.getPorts(deviceId);
    PortNumber inPort = host.location().port();
    List<PortNumber> localVmPorts = getLocalPorts(deviceId, ifaceId);
    List<PortNumber> localTunnelPorts = new ArrayList<>();
    Sets.newHashSet(allPorts.iterator()).stream().filter(p -> !p.number().equals(PortNumber.LOCAL)).forEach(p -> {
        if (p.annotations().value("portName").startsWith(PORT_HEAD)) {
            localTunnelPorts.add(p.number());
        }
    });
    localVmPorts.forEach(lp -> programLocalBcastRules(deviceId, network.segmentationId(), lp, localVmPorts, localTunnelPorts, appId, Objective.Operation.ADD));
    programLocalOut(deviceId, network.segmentationId(), inPort, host.mac(), appId, Objective.Operation.ADD);
    localTunnelPorts.forEach(tp -> programTunnelFloodOut(deviceId, network.segmentationId(), tp, localVmPorts, appId, Objective.Operation.ADD));
    Sets.newHashSet(devices).stream().filter(d -> d.type() == Device.Type.CONTROLLER).forEach(d -> {
        DriverHandler handler = driverService.createHandler(d.id());
        BridgeConfig bridgeConfig = handler.behaviour(BridgeConfig.class);
        Collection<BridgeDescription> bridgeDescriptions = bridgeConfig.getBridges();
        Iterator<BridgeDescription> it = bridgeDescriptions.iterator();
        if (it.hasNext()) {
            BridgeDescription sw = it.next();
            Set<PortNumber> ports = bridgeConfig.getPortNumbers();
            ports.stream().filter(p -> p.name().equalsIgnoreCase(tunnelName)).forEach(p -> programTunnelOut(sw.deviceId(), network.segmentationId(), p, host.mac(), appId, Objective.Operation.ADD));
        }
    });
    programLocalIn(deviceId, network.segmentationId(), inPort, host.mac(), appId, Objective.Operation.ADD);
    localTunnelPorts.forEach(tp -> programTunnelIn(deviceId, network.segmentationId(), tp, inPort, host.mac(), appId, Objective.Operation.ADD));
}
#end_block

#method_before
@Override
public void onHostVanished(Host host) {
    String ifaceId = host.annotations().value(IFACEID);
    SegmentationId segId = binding.remove(host.id());
    DeviceId deviceId = host.location().deviceId();
    String currentControllerIp = getControllerIpOfSwitch(deviceId);
    Iterable<Device> devices = deviceService.getAvailableDevices();
    String tunnelName = "vxlan-" + currentControllerIp;
    List<Port> allPorts = deviceService.getPorts(deviceId);
    PortNumber inPort = host.location().port();
    List<PortNumber> localTunnelPorts = new ArrayList<>();
    Sets.newHashSet(allPorts.iterator()).stream().filter(p -> !p.number().equals(PortNumber.LOCAL)).forEach(p -> {
        if (p.annotations().value("portName").startsWith(PORT_HEAD)) {
            localTunnelPorts.add(p.number());
        }
    });
    List<PortNumber> localVmPorts = getLocalPorts(deviceId, ifaceId);
    localVmPorts.add(inPort);
    localVmPorts.forEach(lp -> programLocalBcastRules(deviceId, segId, lp, localVmPorts, localTunnelPorts, appId, Objective.Operation.REMOVE));
    programLocalOut(deviceId, segId, inPort, host.mac(), appId, Objective.Operation.REMOVE);
    localTunnelPorts.forEach(tp -> programTunnelFloodOut(deviceId, segId, tp, localVmPorts, appId, Objective.Operation.REMOVE));
    Sets.newHashSet(devices).stream().filter(d -> d.type() == Device.Type.CONTROLLER).forEach(d -> {
        DriverHandler handler = driverService.createHandler(d.id());
        BridgeConfig bridgeConfig = handler.behaviour(BridgeConfig.class);
        Collection<BridgeDescription> bridgeDescriptions = bridgeConfig.getBridges();
        Iterator<BridgeDescription> it = bridgeDescriptions.iterator();
        if (it.hasNext()) {
            BridgeDescription sw = it.next();
            Set<PortNumber> ports = bridgeConfig.getPortNumbers();
            ports.stream().filter(p -> p.name().equalsIgnoreCase(tunnelName)).forEach(p -> {
                programTunnelOut(sw.deviceId(), segId, p, host.mac(), appId, Objective.Operation.REMOVE);
            });
        }
    });
    programLocalIn(deviceId, segId, inPort, host.mac(), appId, Objective.Operation.REMOVE);
    localTunnelPorts.forEach(tp -> programTunnelIn(deviceId, segId, tp, inPort, host.mac(), appId, Objective.Operation.REMOVE));
}
#method_after
@Override
public void onHostVanished(Host host) {
    String ifaceId = host.annotations().value(IFACEID);
    SegmentationId segId = binding.remove(host.id());
    DeviceId deviceId = host.location().deviceId();
    String currentControllerIp = getControllerIpOfSwitch(deviceId);
    Iterable<Device> devices = deviceService.getAvailableDevices();
    String tunnelName = "vxlan-" + currentControllerIp;
    List<Port> allPorts = deviceService.getPorts(deviceId);
    PortNumber inPort = host.location().port();
    List<PortNumber> localTunnelPorts = new ArrayList<>();
    Sets.newHashSet(allPorts.iterator()).stream().filter(p -> !p.number().equals(PortNumber.LOCAL)).forEach(p -> {
        if (p.annotations().value("portName").startsWith(PORT_HEAD)) {
            localTunnelPorts.add(p.number());
        }
    });
    List<PortNumber> localVmPorts = getLocalPorts(deviceId, ifaceId);
    localVmPorts.add(inPort);
    localVmPorts.forEach(lp -> programLocalBcastRules(deviceId, segId, lp, localVmPorts, localTunnelPorts, appId, Objective.Operation.REMOVE));
    programLocalOut(deviceId, segId, inPort, host.mac(), appId, Objective.Operation.REMOVE);
    localTunnelPorts.forEach(tp -> programTunnelFloodOut(deviceId, segId, tp, localVmPorts, appId, Objective.Operation.REMOVE));
    Sets.newHashSet(devices).stream().filter(d -> d.type() == Device.Type.CONTROLLER).forEach(d -> {
        DriverHandler handler = driverService.createHandler(d.id());
        BridgeConfig bridgeConfig = handler.behaviour(BridgeConfig.class);
        Collection<BridgeDescription> bridgeDescriptions = bridgeConfig.getBridges();
        Iterator<BridgeDescription> it = bridgeDescriptions.iterator();
        if (it.hasNext()) {
            BridgeDescription sw = it.next();
            Set<PortNumber> ports = bridgeConfig.getPortNumbers();
            ports.stream().filter(p -> p.name().equalsIgnoreCase(tunnelName)).forEach(p -> programTunnelOut(sw.deviceId(), segId, p, host.mac(), appId, Objective.Operation.REMOVE));
        }
    });
    programLocalIn(deviceId, segId, inPort, host.mac(), appId, Objective.Operation.REMOVE);
    localTunnelPorts.forEach(tp -> programTunnelIn(deviceId, segId, tp, inPort, host.mac(), appId, Objective.Operation.REMOVE));
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    if (Device.Type.CONTROLLER == device.type() && DeviceEvent.Type.DEVICE_ADDED == event.type()) {
        backgroundService.execute(() -> {
            onServerDetected(device);
        });
    } else if (Device.Type.CONTROLLER == device.type() && DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED == event.type()) {
        backgroundService.execute(() -> {
            onServerVanished(device);
        });
    } else if (Device.Type.SWITCH == device.type() && DeviceEvent.Type.DEVICE_ADDED == event.type()) {
        backgroundService.execute(() -> {
            onOvsDetected(device);
        });
    } else if (Device.Type.SWITCH == device.type() && DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED == event.type()) {
        backgroundService.execute(() -> {
            onOvsVanished(device);
        });
    } else {
        log.info("Do nothing for this device type");
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    if (Device.Type.CONTROLLER == device.type() && DeviceEvent.Type.DEVICE_ADDED == event.type()) {
        backgroundService.execute(() -> onServerDetected(device));
    } else if (Device.Type.CONTROLLER == device.type() && DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED == event.type()) {
        backgroundService.execute(() -> onServerVanished(device));
    } else if (Device.Type.SWITCH == device.type() && DeviceEvent.Type.DEVICE_ADDED == event.type()) {
        backgroundService.execute(() -> onOvsDetected(device));
    } else if (Device.Type.SWITCH == device.type() && DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED == event.type()) {
        backgroundService.execute(() -> onOvsVanished(device));
    } else {
        log.info("Do nothing for this device type");
    }
}
#end_block

#method_before
@Override
public void event(HostEvent event) {
    Host host = event.subject();
    if (HostEvent.Type.HOST_ADDED == event.type()) {
        backgroundService.execute(() -> {
            onHostDetected(host);
        });
    } else if (HostEvent.Type.HOST_REMOVED == event.type()) {
        backgroundService.execute(() -> {
            onHostVanished(host);
        });
    } else if (HostEvent.Type.HOST_UPDATED == event.type()) {
        backgroundService.execute(() -> {
            onHostVanished(host);
            onHostDetected(host);
        });
    }
}
#method_after
@Override
public void event(HostEvent event) {
    Host host = event.subject();
    if (HostEvent.Type.HOST_ADDED == event.type()) {
        backgroundService.execute(() -> onHostDetected(host));
    } else if (HostEvent.Type.HOST_REMOVED == event.type()) {
        backgroundService.execute(() -> onHostVanished(host));
    } else if (HostEvent.Type.HOST_UPDATED == event.type()) {
        backgroundService.execute(() -> {
            onHostVanished(host);
            onHostDetected(host);
        });
    }
}
#end_block

#method_before
private Iterable<String> getIfaceIds(String ifaceId) {
    VirtualPortId portId = VirtualPortId.portId(ifaceId);
    VirtualPort port = virtualPortService.getPort(portId);
    Collection<String> ifaceIds = new HashSet<String>();
    if (port != null) {
        TenantNetwork network = tenantNetworkService.getNetwork(port.networkId());
        if (network != null) {
            Collection<VirtualPort> ports = virtualPortService.getPorts(network.id());
            Sets.newHashSet(ports).stream().forEach(p -> ifaceIds.add(p.portId().portId()));
        }
    }
    return ifaceIds;
}
#method_after
private Iterable<String> getIfaceIds(String ifaceId) {
    VirtualPortId portId = VirtualPortId.portId(ifaceId);
    VirtualPort port = virtualPortService.getPort(portId);
    if (port == null) {
        return Collections.emptyList();
    }
    TenantNetwork network = tenantNetworkService.getNetwork(port.networkId());
    if (network == null) {
        return Collections.emptyList();
    }
    Collection<VirtualPort> ports = virtualPortService.getPorts(network.id());
    return ports.stream().map(p -> p.portId().portId()).collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public Collection<VirtualPort> getPorts(TenantNetworkId networkId) {
    checkNotNull(networkId, NETWORKID_NOT_NULL);
    Collection<VirtualPort> vPortWithNetworkIds = new ArrayList<VirtualPort>();
    Collection<VirtualPort> virtualPorts = vPortStore.values();
    for (VirtualPort vPort : virtualPorts) {
        if (vPort.networkId().equals(networkId)) {
            vPortWithNetworkIds.add(vPort);
        }
    }
    return vPortWithNetworkIds;
}
#method_after
@Override
public Collection<VirtualPort> getPorts(TenantNetworkId networkId) {
    checkNotNull(networkId, NETWORKID_NOT_NULL);
    return vPortStore.values().stream().filter(d -> d.networkId().equals(networkId)).collect(Collectors.toList());
}
#end_block

#method_before
@Override
public Collection<VirtualPort> getPorts(TenantId tenantId) {
    checkNotNull(tenantId, TENANTID_NOT_NULL);
    Collection<VirtualPort> vPortWithTenantIds = new ArrayList<VirtualPort>();
    Collection<VirtualPort> virtualPorts = vPortStore.values();
    for (VirtualPort vPort : virtualPorts) {
        if (vPort.tenantId().equals(tenantId)) {
            vPortWithTenantIds.add(vPort);
        }
    }
    return vPortWithTenantIds;
}
#method_after
@Override
public Collection<VirtualPort> getPorts(TenantId tenantId) {
    checkNotNull(tenantId, TENANTID_NOT_NULL);
    return vPortStore.values().stream().filter(d -> d.tenantId().equals(tenantId)).collect(Collectors.toList());
}
#end_block

#method_before
@Override
public Collection<VirtualPort> getPorts(DeviceId deviceId) {
    checkNotNull(deviceId, DEVICEID_NOT_NULL);
    Collection<VirtualPort> vPortWithDeviceIds = new ArrayList<VirtualPort>();
    Collection<VirtualPort> virtualPorts = vPortStore.values();
    for (VirtualPort vPort : virtualPorts) {
        if (vPort.deviceId().equals(deviceId)) {
            vPortWithDeviceIds.add(vPort);
        }
    }
    return vPortWithDeviceIds;
}
#method_after
@Override
public Collection<VirtualPort> getPorts(DeviceId deviceId) {
    checkNotNull(deviceId, DEVICEID_NOT_NULL);
    return vPortStore.values().stream().filter(d -> d.deviceId().equals(deviceId)).collect(Collectors.toList());
}
#end_block

#method_before
private Map<String, String> readComponentConfiguration(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    Map<String, String> outProperties = new HashMap<>();
    String port = get(properties, "openflowPort");
    if (!Strings.isNullOrEmpty(port)) {
        outProperties.put("openflowport", port);
    }
    try {
        String strDpid = (String) properties.get("corsaDpid");
        if (strDpid != null) {
            outProperties.put("corsaDpid", strDpid);
        }
    } catch (ClassCastException e) {
        return outProperties;
    }
    return outProperties;
}
#method_after
private Map<String, String> readComponentConfiguration(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    Map<String, String> outProperties = new HashMap<>();
    String port = get(properties, "openflowPort");
    if (!Strings.isNullOrEmpty(port)) {
        outProperties.put("openflowport", port);
    }
    String thread = get(properties, "workerThreads");
    if (!Strings.isNullOrEmpty(thread)) {
        outProperties.put("workerthreads", thread);
    }
    return outProperties;
}
#end_block

#method_before
@Override
public void processPacket(Dpid dpid, OFMessage msg) {
    Collection<OFFlowStatsEntry> flowStats;
    Collection<OFGroupStatsEntry> groupStats;
    Collection<OFGroupDescStatsEntry> groupDescStats;
    Collection<OFPortStatsEntry> portStats;
    switch(msg.getType()) {
        case PORT_STATUS:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.portChanged(dpid, (OFPortStatus) msg);
            }
            break;
        case FEATURES_REPLY:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.switchChanged(dpid);
            }
            break;
        case PACKET_IN:
            OpenFlowPacketContext pktCtx = DefaultOpenFlowPacketContext.packetContextFromPacketIn(this.getSwitch(dpid), (OFPacketIn) msg);
            for (PacketListener p : ofPacketListener.values()) {
                p.handlePacket(pktCtx);
            }
            break;
        // ie. Back to back error could cause us to starve.
        case FLOW_REMOVED:
        case ERROR:
            executorMsgs.submit(new OFMessageHandler(dpid, msg));
            break;
        case STATS_REPLY:
            OFStatsReply reply = (OFStatsReply) msg;
            switch(reply.getStatsType()) {
                case PORT_DESC:
                    for (OpenFlowSwitchListener l : ofSwitchListener) {
                        l.switchChanged(dpid);
                    }
                    break;
                case FLOW:
                    flowStats = publishFlowStats(dpid, (OFFlowStatsReply) reply);
                    if (flowStats != null) {
                        OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                        rep.setEntries(Lists.newLinkedList(flowStats));
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP:
                    groupStats = publishGroupStats(dpid, (OFGroupStatsReply) reply);
                    if (groupStats != null) {
                        OFGroupStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP_DESC:
                    groupDescStats = publishGroupDescStats(dpid, (OFGroupDescStatsReply) reply);
                    if (groupDescStats != null) {
                        OFGroupDescStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupDescStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupDescStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case PORT:
                    executorMsgs.submit(new OFMessageHandler(dpid, reply));
                    break;
                case METER:
                    executorMsgs.submit(new OFMessageHandler(dpid, reply));
                    break;
                case EXPERIMENTER:
                    if (reply instanceof OFCalientFlowStatsReply) {
                        // Convert Calient flow statistics to regular flow stats
                        // TODO: parse remaining fields such as power levels etc. when we have proper monitoring API
                        OFFlowStatsReply.Builder fsr = getSwitch(dpid).factory().buildFlowStatsReply();
                        List<OFFlowStatsEntry> entries = new LinkedList<>();
                        for (OFCalientFlowStatsEntry entry : ((OFCalientFlowStatsReply) msg).getEntries()) {
                            // Single instruction, i.e., output to port
                            OFActionOutput action = OFFactories.getFactory(msg.getVersion()).actions().buildOutput().setPort(entry.getOutPort()).build();
                            OFInstruction instruction = OFFactories.getFactory(msg.getVersion()).instructions().applyActions(Collections.singletonList(action));
                            OFFlowStatsEntry fs = getSwitch(dpid).factory().buildFlowStatsEntry().setMatch(entry.getMatch()).setTableId(entry.getTableId()).setDurationSec(entry.getDurationSec()).setDurationNsec(entry.getDurationNsec()).setPriority(entry.getPriority()).setIdleTimeout(entry.getIdleTimeout()).setHardTimeout(entry.getHardTimeout()).setFlags(entry.getFlags()).setCookie(entry.getCookie()).setInstructions(Collections.singletonList(instruction)).build();
                            entries.add(fs);
                        }
                        fsr.setEntries(entries);
                        flowStats = publishFlowStats(dpid, fsr.build());
                        if (flowStats != null) {
                            OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                            rep.setEntries(Lists.newLinkedList(flowStats));
                            executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                        }
                    } else {
                        log.warn("Unsupported stats type : {}", reply.getStatsType());
                    }
                    break;
                default:
                    log.warn("Discarding unknown stats reply type {}", reply.getStatsType());
                    break;
            }
            break;
        case BARRIER_REPLY:
            executorBarrier.submit(new OFMessageHandler(dpid, msg));
            break;
        case EXPERIMENTER:
            long experimenter = ((OFExperimenter) msg).getExperimenter();
            if (experimenter == 0x748771) {
                // LINC-OE port stats
                OFCircuitPortStatus circuitPortStatus = (OFCircuitPortStatus) msg;
                OFPortStatus.Builder portStatus = this.getSwitch(dpid).factory().buildPortStatus();
                OFPortDesc.Builder portDesc = this.getSwitch(dpid).factory().buildPortDesc();
                portDesc.setPortNo(circuitPortStatus.getPortNo()).setHwAddr(circuitPortStatus.getHwAddr()).setName(circuitPortStatus.getName()).setConfig(circuitPortStatus.getConfig()).setState(circuitPortStatus.getState());
                portStatus.setReason(circuitPortStatus.getReason()).setDesc(portDesc.build());
                for (OpenFlowSwitchListener l : ofSwitchListener) {
                    l.portChanged(dpid, portStatus.build());
                }
            } else {
                log.warn("Handling experimenter type {} not yet implemented", ((OFExperimenter) msg).getExperimenter(), msg);
            }
            break;
        default:
            log.warn("Handling message type {} not yet implemented {}", msg.getType(), msg);
    }
}
#method_after
@Override
public void processPacket(Dpid dpid, OFMessage msg) {
    Collection<OFFlowStatsEntry> flowStats;
    Collection<OFGroupStatsEntry> groupStats;
    Collection<OFGroupDescStatsEntry> groupDescStats;
    Collection<OFPortStatsEntry> portStats;
    switch(msg.getType()) {
        case PORT_STATUS:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.portChanged(dpid, (OFPortStatus) msg);
            }
            break;
        case FEATURES_REPLY:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.switchChanged(dpid);
            }
            break;
        case PACKET_IN:
            OpenFlowPacketContext pktCtx = DefaultOpenFlowPacketContext.packetContextFromPacketIn(this.getSwitch(dpid), (OFPacketIn) msg);
            for (PacketListener p : ofPacketListener.values()) {
                p.handlePacket(pktCtx);
            }
            break;
        // ie. Back to back error could cause us to starve.
        case FLOW_REMOVED:
        case ERROR:
            executorMsgs.submit(new OFMessageHandler(dpid, msg));
            break;
        case STATS_REPLY:
            OFStatsReply reply = (OFStatsReply) msg;
            switch(reply.getStatsType()) {
                case PORT_DESC:
                    for (OpenFlowSwitchListener l : ofSwitchListener) {
                        l.switchChanged(dpid);
                    }
                    break;
                case FLOW:
                    flowStats = publishFlowStats(dpid, (OFFlowStatsReply) reply);
                    if (flowStats != null) {
                        OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                        rep.setEntries(Lists.newLinkedList(flowStats));
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP:
                    groupStats = publishGroupStats(dpid, (OFGroupStatsReply) reply);
                    if (groupStats != null) {
                        OFGroupStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP_DESC:
                    groupDescStats = publishGroupDescStats(dpid, (OFGroupDescStatsReply) reply);
                    if (groupDescStats != null) {
                        OFGroupDescStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupDescStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupDescStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case PORT:
                    executorMsgs.submit(new OFMessageHandler(dpid, reply));
                    break;
                case METER:
                    executorMsgs.submit(new OFMessageHandler(dpid, reply));
                    break;
                case EXPERIMENTER:
                    if (reply instanceof OFCalientFlowStatsReply) {
                        // Convert Calient flow statistics to regular flow stats
                        // TODO: parse remaining fields such as power levels etc. when we have proper monitoring API
                        OFFlowStatsReply.Builder fsr = getSwitch(dpid).factory().buildFlowStatsReply();
                        List<OFFlowStatsEntry> entries = new LinkedList<>();
                        for (OFCalientFlowStatsEntry entry : ((OFCalientFlowStatsReply) msg).getEntries()) {
                            // Single instruction, i.e., output to port
                            OFActionOutput action = OFFactories.getFactory(msg.getVersion()).actions().buildOutput().setPort(entry.getOutPort()).build();
                            OFInstruction instruction = OFFactories.getFactory(msg.getVersion()).instructions().applyActions(Collections.singletonList(action));
                            OFFlowStatsEntry fs = getSwitch(dpid).factory().buildFlowStatsEntry().setMatch(entry.getMatch()).setTableId(entry.getTableId()).setDurationSec(entry.getDurationSec()).setDurationNsec(entry.getDurationNsec()).setPriority(entry.getPriority()).setIdleTimeout(entry.getIdleTimeout()).setHardTimeout(entry.getHardTimeout()).setFlags(entry.getFlags()).setCookie(entry.getCookie()).setInstructions(Collections.singletonList(instruction)).build();
                            entries.add(fs);
                        }
                        fsr.setEntries(entries);
                        flowStats = publishFlowStats(dpid, fsr.build());
                        if (flowStats != null) {
                            OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                            rep.setEntries(Lists.newLinkedList(flowStats));
                            executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                        }
                    } else {
                        executorMsgs.submit(new OFMessageHandler(dpid, reply));
                    }
                    break;
                default:
                    log.warn("Discarding unknown stats reply type {}", reply.getStatsType());
                    break;
            }
            break;
        case BARRIER_REPLY:
            executorBarrier.submit(new OFMessageHandler(dpid, msg));
            break;
        case EXPERIMENTER:
            long experimenter = ((OFExperimenter) msg).getExperimenter();
            if (experimenter == 0x748771) {
                // LINC-OE port stats
                OFCircuitPortStatus circuitPortStatus = (OFCircuitPortStatus) msg;
                OFPortStatus.Builder portStatus = this.getSwitch(dpid).factory().buildPortStatus();
                OFPortDesc.Builder portDesc = this.getSwitch(dpid).factory().buildPortDesc();
                portDesc.setPortNo(circuitPortStatus.getPortNo()).setHwAddr(circuitPortStatus.getHwAddr()).setName(circuitPortStatus.getName()).setConfig(circuitPortStatus.getConfig()).setState(circuitPortStatus.getState());
                portStatus.setReason(circuitPortStatus.getReason()).setDesc(portDesc.build());
                for (OpenFlowSwitchListener l : ofSwitchListener) {
                    l.portChanged(dpid, portStatus.build());
                }
            } else {
                log.warn("Handling experimenter type {} not yet implemented", ((OFExperimenter) msg).getExperimenter(), msg);
            }
            break;
        default:
            log.warn("Handling message type {} not yet implemented {}", msg.getType(), msg);
    }
}
#end_block

#method_before
private void setupDefaultFlows() {
    TrafficSelector ofInBandMatchUp = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_TCP).matchTcpDst(ofPort).matchInPort(PortNumber.portNumber(6)).build();
    TrafficSelector ofInBandMatchDown = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_TCP).matchTcpSrc(ofPort).matchInPort(PortNumber.portNumber(1)).build();
    TrafficSelector oltMgmtUp = DefaultTrafficSelector.builder().matchEthSrc(MacAddress.valueOf("00:0c:d5:00:01:01")).matchInPort(PortNumber.portNumber(2)).build();
    TrafficSelector oltMgmtDown = DefaultTrafficSelector.builder().matchEthDst(MacAddress.valueOf("00:0c:d5:00:01:01")).matchInPort(PortNumber.portNumber(9)).build();
    TrafficTreatment up = DefaultTrafficTreatment.builder().setOutput(PortNumber.portNumber(1)).build();
    TrafficTreatment down = DefaultTrafficTreatment.builder().setOutput(PortNumber.portNumber(6)).build();
    TrafficSelector toRadius = DefaultTrafficSelector.builder().matchInPort(PortNumber.portNumber(2)).matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_UDP).matchUdpDst(radiusPort).build();
    TrafficSelector fromRadius = DefaultTrafficSelector.builder().matchInPort(PortNumber.portNumber(5)).matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_UDP).matchUdpDst(radiusPort).build();
    TrafficTreatment toOlt = DefaultTrafficTreatment.builder().setOutput(PortNumber.portNumber(2)).build();
    TrafficTreatment toVolt = DefaultTrafficTreatment.builder().setOutput(PortNumber.portNumber(9)).build();
    TrafficTreatment sentToRadius = DefaultTrafficTreatment.builder().setOutput(PortNumber.portNumber(5)).build();
    TrafficTreatment testPort = DefaultTrafficTreatment.builder().setOutput(PortNumber.portNumber(8)).build();
    ForwardingObjective ofTestPath = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(TESTPRIO).withSelector(DefaultTrafficSelector.builder().matchInPort(PortNumber.portNumber(2)).build()).withTreatment(testPort).add();
    ForwardingObjective radiusToServer = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY).withSelector(toRadius).withTreatment(sentToRadius).add();
    ForwardingObjective serverToRadius = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY).withSelector(fromRadius).withTreatment(toOlt).add();
    ForwardingObjective upCtrl = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY).withSelector(ofInBandMatchUp).withTreatment(up).add();
    ForwardingObjective downCtrl = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY).withSelector(ofInBandMatchDown).withTreatment(down).add();
    ForwardingObjective upOltMgmt = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY).withSelector(oltMgmtUp).withTreatment(toVolt).add();
    ForwardingObjective downOltMgmt = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY).withSelector(oltMgmtDown).withTreatment(toOlt).add();
    if (testMode) {
        flowObjectiveService.forward(fabricDeviceId, ofTestPath);
    }
    flowObjectiveService.forward(fabricDeviceId, upCtrl);
    flowObjectiveService.forward(fabricDeviceId, downCtrl);
    flowObjectiveService.forward(fabricDeviceId, radiusToServer);
    flowObjectiveService.forward(fabricDeviceId, serverToRadius);
    flowObjectiveService.forward(fabricDeviceId, upOltMgmt);
    flowObjectiveService.forward(fabricDeviceId, downOltMgmt);
}
#method_after
private void setupDefaultFlows() {
    TrafficSelector ofInBandMatchUp = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_TCP).matchTcpDst(TpPort.tpPort(ofPort)).matchInPort(PortNumber.portNumber(6)).build();
    TrafficSelector ofInBandMatchDown = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_TCP).matchTcpSrc(TpPort.tpPort(ofPort)).matchInPort(PortNumber.portNumber(1)).build();
    TrafficSelector oltMgmtUp = DefaultTrafficSelector.builder().matchEthSrc(MacAddress.valueOf("00:0c:d5:00:01:01")).matchInPort(PortNumber.portNumber(2)).build();
    TrafficSelector oltMgmtDown = DefaultTrafficSelector.builder().matchEthDst(MacAddress.valueOf("00:0c:d5:00:01:01")).matchInPort(PortNumber.portNumber(9)).build();
    TrafficTreatment up = DefaultTrafficTreatment.builder().setOutput(PortNumber.portNumber(1)).build();
    TrafficTreatment down = DefaultTrafficTreatment.builder().setOutput(PortNumber.portNumber(6)).build();
    TrafficSelector toRadius = DefaultTrafficSelector.builder().matchInPort(PortNumber.portNumber(2)).matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_UDP).matchUdpDst(TpPort.tpPort(radiusPort)).build();
    TrafficSelector fromRadius = DefaultTrafficSelector.builder().matchInPort(PortNumber.portNumber(5)).matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_UDP).matchUdpDst(TpPort.tpPort(radiusPort)).build();
    TrafficTreatment toOlt = DefaultTrafficTreatment.builder().setOutput(PortNumber.portNumber(2)).build();
    TrafficTreatment toVolt = DefaultTrafficTreatment.builder().setOutput(PortNumber.portNumber(9)).build();
    TrafficTreatment sentToRadius = DefaultTrafficTreatment.builder().setOutput(PortNumber.portNumber(5)).build();
    TrafficTreatment testPort = DefaultTrafficTreatment.builder().setOutput(PortNumber.portNumber(8)).build();
    ForwardingObjective ofTestPath = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(TESTPRIO).withSelector(DefaultTrafficSelector.builder().matchInPort(PortNumber.portNumber(2)).build()).withTreatment(testPort).add();
    ForwardingObjective radiusToServer = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY).withSelector(toRadius).withTreatment(sentToRadius).add();
    ForwardingObjective serverToRadius = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY).withSelector(fromRadius).withTreatment(toOlt).add();
    ForwardingObjective upCtrl = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY).withSelector(ofInBandMatchUp).withTreatment(up).add();
    ForwardingObjective downCtrl = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY).withSelector(ofInBandMatchDown).withTreatment(down).add();
    ForwardingObjective upOltMgmt = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY).withSelector(oltMgmtUp).withTreatment(toVolt).add();
    ForwardingObjective downOltMgmt = DefaultForwardingObjective.builder().fromApp(appId).makePermanent().withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PRIORITY).withSelector(oltMgmtDown).withTreatment(toOlt).add();
    if (testMode) {
        flowObjectiveService.forward(fabricDeviceId, ofTestPath);
    }
    flowObjectiveService.forward(fabricDeviceId, upCtrl);
    flowObjectiveService.forward(fabricDeviceId, downCtrl);
    flowObjectiveService.forward(fabricDeviceId, radiusToServer);
    flowObjectiveService.forward(fabricDeviceId, serverToRadius);
    flowObjectiveService.forward(fabricDeviceId, upOltMgmt);
    flowObjectiveService.forward(fabricDeviceId, downOltMgmt);
}
#end_block

#method_before
@Override
public List<FabricVlan> getVlans() {
    List<FabricVlan> fVlans = new ArrayList<>();
    vlans.keySet().forEach(vlan -> fVlans.add(// FIXME: Very aweful but will fo for now
    new FabricVlan(vlan, vlans.get(vlan), vlan.toShort() == 201 ? true : false)));
    return fVlans;
}
#method_after
@Override
public List<FabricVlan> getVlans() {
    List<FabricVlan> fVlans = new ArrayList<>();
    vlans.keySet().forEach(vlan -> fVlans.add(// FIXME: Very aweful but will fo for now
    new FabricVlan(vlan, vlans.get(vlan), vlan.toShort() == 201)));
    return fVlans;
}
#end_block

#method_before
private HostId isHostId(String id) {
    if (id.length() < VLAN_SEPARATOR_OFFSET + 1 || id.charAt(FIRST_MAC_ADDRESS_SEPARATOR_OFFSET) != ':' || id.charAt(SECOND_MAC_ADDRESS_SEPARATOR_OFFSET) != ':' || id.charAt(THIRD_MAC_ADDRESS_SEPARATOR_OFFSET) != ':' || id.charAt(VLAN_SEPARATOR_OFFSET) != '/') {
        return null;
    }
    return HostId.hostId(id);
}
#method_after
private HostId isHostId(String id) {
    return id.matches("..:..:..:..:..:../.*") ? HostId.hostId(id) : null;
}
#end_block

#method_before
public Path primary() {
    return path1;
}
#method_after
@Override
public Path primary() {
    return path1;
}
#end_block

#method_before
public Path backup() {
    return path2;
}
#method_after
@Override
public Path backup() {
    return path2;
}
#end_block

#method_before
public boolean useBackup() {
    if (path2 == null || path2.links() == null) {
        return false;
    }
    usingPath1 = !usingPath1;
    return true;
}
#method_after
@Override
public boolean useBackup() {
    if (path2 == null || path2.links() == null) {
        return false;
    }
    usingPath1 = !usingPath1;
    return true;
}
#end_block

#method_before
public void start() {
    connectionExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("onos/cordvtn", "connection-executor"));
    connectionExecutor.scheduleWithFixedDelay(() -> nodeStore.values().stream().filter(node -> mastershipService.isLocalMaster(node.bridgeId())).forEach(node -> connectNode(node)), 0, DELAY_SEC, TimeUnit.SECONDS);
}
#method_after
public void start() {
    connectionExecutor = Executors.newSingleThreadScheduledExecutor(groupedThreads("onos/cordvtn", "connection-executor"));
    connectionExecutor.scheduleWithFixedDelay(() -> nodeStore.values().stream().filter(node -> localId.equals(getMaster(node))).forEach(node -> connectNode(node)), 0, DELAY_SEC, TimeUnit.SECONDS);
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.cordvtn");
    local = clusterService.getLocalNode().id();
    nodeStore = storageService.<DeviceId, OvsdbNode>eventuallyConsistentMapBuilder().withName("cordvtn-nodestore").withSerializer(NODE_SERIALIZER).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    processLeadershipChange(leadershipService.getLeader(appId.name()));
    leadershipService.addListener(leadershipListener);
    leadershipService.runForLeadership(appId.name());
    deviceService.addListener(deviceListener);
    hostService.addListener(hostListener);
    nodeConnectionManager = new NodeConnectionManager(local, nodeStore, mastershipService);
    nodeConnectionManager.start();
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.cordvtn");
    local = clusterService.getLocalNode().id();
    nodeStore = storageService.<DeviceId, OvsdbNode>eventuallyConsistentMapBuilder().withName("cordvtn-nodestore").withSerializer(NODE_SERIALIZER).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    configRegistry.registerConfigFactory(configFactory);
    deviceService.addListener(deviceListener);
    hostService.addListener(hostListener);
    leadershipService.addListener(leadershipListener);
    leadershipService.runForLeadership(appId.name());
    nodeConnectionManager = new NodeConnectionManager(appId, local, nodeStore, mastershipService, leadershipService);
    nodeConnectionManager.start();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    nodeConnectionManager.stop();
    hostService.removeListener(hostListener);
    deviceService.removeListener(deviceListener);
    leadershipService.removeListener(leadershipListener);
    leadershipService.withdraw(appId.name());
    nodeStore.destroy();
    eventExecutor.shutdown();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    nodeConnectionManager.stop();
    leadershipService.removeListener(leadershipListener);
    leadershipService.withdraw(appId.name());
    deviceService.removeListener(deviceListener);
    hostService.removeListener(hostListener);
    eventExecutor.shutdown();
    nodeStore.destroy();
    configRegistry.unregisterConfigFactory(configFactory);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void addNode(IpAddress ip, TpPort port) {
    DefaultOvsdbNode newNode = new DefaultOvsdbNode(ip, port, leadershipService.getLeader(appId.name()));
    nodeStore.put(newNode.deviceId(), newNode);
    nodeConnectionManager.connectNode(newNode);
}
#method_after
@Override
public void addNode(String hostname, IpAddress ip, TpPort port) {
    DefaultOvsdbNode node = new DefaultOvsdbNode(hostname, ip, port, DeviceId.NONE, INIT);
    if (nodeStore.containsKey(node.deviceId())) {
        log.warn("Node {} with ovsdb-server {}:{} already exists", hostname, ip, port);
        return;
    }
    nodeStore.put(node.deviceId(), node);
    log.info("New node {} with ovsdb-server {}:{} has been added", hostname, ip, port);
}
#end_block

#method_before
@Override
public void deleteNode(IpAddress ip, TpPort port) {
    DeviceId deviceId = DeviceId.deviceId("ovsdb:" + ip + port);
    OvsdbNode node = nodeStore.get(deviceId);
    if (node == null) {
        log.warn("Node with ip: {} and port: {} does not exist", ip, port);
        return;
    }
    nodeConnectionManager.disconnectNode(node);
    nodeStore.remove(deviceId);
}
#method_after
@Override
public void deleteNode(IpAddress ip, TpPort port) {
    DeviceId deviceId = DeviceId.deviceId("ovsdb:" + ip + ":" + port);
    OvsdbNode node = nodeStore.get(deviceId);
    if (node == null) {
        log.warn("Node with ovsdb-server on {}:{} does not exist", ip, port);
        return;
    }
    nodeConnectionManager.disconnectNode(node);
    nodeStore.remove(node.deviceId());
}
#end_block

#method_before
private void initialSetup() {
    // TODO: read node list from network config and add ovsdbNode with INIT state
    NodeConfig config = networkConfigService.getConfig(appId, NodeConfig.class);
    if (config == null) {
        return;
    }
// TODO: set default master of the node to the leader
// Once an integration bridge is created and one master controller is set for each ovs,
// we can utilize the ovs controller as an ovsdb node controller, too
}
#method_after
private void initialSetup() {
    // Read ovsdb nodes from network config
    CordVtnConfig config = configService.getConfig(appId, CordVtnConfig.class);
    if (config == null) {
        log.warn("No configuration found");
        return;
    }
    config.ovsdbNodes().forEach(node -> addNode(node.hostname(), node.ip(), node.port()));
}
#end_block

#method_before
private synchronized void processLeadershipChange(NodeId leader) {
    if (leader == null || !leader.equals(local)) {
        return;
    }
    initialSetup();
}
#method_after
private synchronized void processLeadershipChange(NodeId leader) {
    // Only the leader performs the initial setup
    if (leader == null || !leader.equals(local)) {
        return;
    }
    initialSetup();
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    ConnectionHandler handler = (device.type() == Device.Type.CONTROLLER ? nodeHandler : bridgeHandler);
    switch(event.type()) {
        case DEVICE_ADDED:
            eventExecutor.submit(() -> handler.connected(device));
            break;
        case DEVICE_AVAILABILITY_CHANGED:
            eventExecutor.submit(() -> handler.disconnected(device));
            break;
        default:
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    ConnectionHandler handler = (device.type() == Device.Type.CONTROLLER ? nodeHandler : bridgeHandler);
    switch(event.type()) {
        case DEVICE_ADDED:
            eventExecutor.submit(() -> handler.connected(device));
            break;
        case DEVICE_AVAILABILITY_CHANGED:
            eventExecutor.submit(() -> handler.disconnected(device));
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void event(HostEvent event) {
    Host vm = event.subject();
    switch(event.type()) {
        case HOST_ADDED:
            eventExecutor.submit(() -> vmHandler.connected(vm));
            break;
        case HOST_REMOVED:
            eventExecutor.submit(() -> vmHandler.disconnected(vm));
            break;
        default:
    }
}
#method_after
@Override
public void event(HostEvent event) {
    Host vm = event.subject();
    switch(event.type()) {
        case HOST_ADDED:
            eventExecutor.submit(() -> vmHandler.connected(vm));
            break;
        case HOST_REMOVED:
            eventExecutor.submit(() -> vmHandler.disconnected(vm));
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void disconnected(Device device) {
// set node state disconnected
}
#method_after
@Override
public void disconnected(Device device) {
// set node state disconnected if the node exists
// which means that the node is not deleted explicitly
}
#end_block

#method_before
@Test
public void testDeserializeTruncated() throws Exception {
    // byte [] bits = pimHello.serialize();
    // PacketTestUtils.testDeserializeTruncated(deserializer, bits);
    byte[] bits = pimJoinPrune.serialize();
    PacketTestUtils.testDeserializeTruncated(deserializer, bits);
}
#method_after
@Test
public void testDeserializeTruncated() throws Exception {
    byte[] bits = pimJoinPrune.serialize();
    PacketTestUtils.testDeserializeTruncated(deserializer, bits);
}
#end_block

#method_before
@Override
public byte[] serialize() {
    int totalLen = 0;
    /**
     * Since we are likely to only have 3-4 options, go head and walk the
     * hashmap twice, once to calculate the space needed to allocate a
     * buffer, the second time serialize the options into the buffer.  This
     * saves us from allocating an oversized buffer the re-allocating and
     * copying.
     */
    for (Short optType : options.keySet()) {
        PIMHelloOption opt = options.get(optType);
        totalLen += PIMHelloOption.MINIMUM_OPTION_LEN_BYTES + opt.getOptLength();
    }
    byte[] data = new byte[totalLen];
    ByteBuffer bb = ByteBuffer.wrap(data);
    // Now serialize the data.
    for (Short optType : options.keySet()) {
        PIMHelloOption opt = options.get(optType);
        bb.put(opt.serialize());
    }
    return data;
}
#method_after
@Override
public byte[] serialize() {
    int totalLen = 0;
    // copying.
    for (Short optType : options.keySet()) {
        PIMHelloOption opt = options.get(optType);
        totalLen += PIMHelloOption.MINIMUM_OPTION_LEN_BYTES + opt.getOptLength();
    }
    byte[] data = new byte[totalLen];
    ByteBuffer bb = ByteBuffer.wrap(data);
    // Now serialize the data.
    for (Short optType : options.keySet()) {
        PIMHelloOption opt = options.get(optType);
        bb.put(opt.serialize());
    }
    return data;
}
#end_block

#method_before
@Override
public boolean assignIP(HostId hostId, Ip4Address ipAddr, int leaseTime) {
    IpAssignment assignmentInfo;
    if (allocationMap.containsKey(hostId)) {
        assignmentInfo = allocationMap.get(hostId).value();
        IpAssignment.AssignmentStatus status = assignmentInfo.assignmentStatus();
        if ((assignmentInfo.ipAddress().toInt() == ipAddr.toInt()) && ipWithinRange(ipAddr)) {
            if (status == IpAssignment.AssignmentStatus.Option_Assigned || status == IpAssignment.AssignmentStatus.Option_Requested) {
                // Client has a currently active binding with the server.
                assignmentInfo = IpAssignment.builder().ipAddress(ipAddr).timestamp(new Date()).leasePeriod(leaseTime).assignmentStatus(IpAssignment.AssignmentStatus.Option_Assigned).build();
                allocationMap.put(hostId, assignmentInfo);
                return true;
            } else if (status == IpAssignment.AssignmentStatus.Option_Expired) {
                // Client has an expired binding with the server.
                if (freeIPPool.contains(ipAddr)) {
                    assignmentInfo = IpAssignment.builder().ipAddress(ipAddr).timestamp(new Date()).leasePeriod(leaseTime).assignmentStatus(IpAssignment.AssignmentStatus.Option_Assigned).build();
                    if (freeIPPool.remove(ipAddr)) {
                        allocationMap.put(hostId, assignmentInfo);
                        return true;
                    }
                }
            }
        }
    } else if (freeIPPool.contains(ipAddr)) {
        assignmentInfo = IpAssignment.builder().ipAddress(ipAddr).timestamp(new Date()).leasePeriod(leaseTime).assignmentStatus(IpAssignment.AssignmentStatus.Option_Assigned).build();
        if (freeIPPool.remove(ipAddr)) {
            allocationMap.put(hostId, assignmentInfo);
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean assignIP(HostId hostId, Ip4Address ipAddr, int leaseTime) {
    IpAssignment assignmentInfo;
    if (allocationMap.containsKey(hostId)) {
        assignmentInfo = allocationMap.get(hostId).value();
        IpAssignment.AssignmentStatus status = assignmentInfo.assignmentStatus();
        if (Objects.equals(assignmentInfo.ipAddress(), ipAddr) && ipWithinRange(ipAddr)) {
            if (status == IpAssignment.AssignmentStatus.Option_Assigned || status == IpAssignment.AssignmentStatus.Option_Requested) {
                // Client has a currently active binding with the server.
                assignmentInfo = IpAssignment.builder().ipAddress(ipAddr).timestamp(new Date()).leasePeriod(leaseTime).assignmentStatus(IpAssignment.AssignmentStatus.Option_Assigned).build();
                allocationMap.put(hostId, assignmentInfo);
                return true;
            } else if (status == IpAssignment.AssignmentStatus.Option_Expired) {
                // Client has an expired binding with the server.
                if (freeIPPool.contains(ipAddr)) {
                    assignmentInfo = IpAssignment.builder().ipAddress(ipAddr).timestamp(new Date()).leasePeriod(leaseTime).assignmentStatus(IpAssignment.AssignmentStatus.Option_Assigned).build();
                    if (freeIPPool.remove(ipAddr)) {
                        allocationMap.put(hostId, assignmentInfo);
                        return true;
                    }
                }
            }
        }
    } else if (freeIPPool.contains(ipAddr)) {
        assignmentInfo = IpAssignment.builder().ipAddress(ipAddr).timestamp(new Date()).leasePeriod(leaseTime).assignmentStatus(IpAssignment.AssignmentStatus.Option_Assigned).build();
        if (freeIPPool.remove(ipAddr)) {
            allocationMap.put(hostId, assignmentInfo);
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public Map<HostId, IpAssignment> listAllMapping() {
    return allocationMap.asJavaMap();
}
#method_after
@Override
public Map<HostId, IpAssignment> listAllMapping() {
    Map<HostId, IpAssignment> validMapping = new HashMap<>();
    for (Map.Entry<HostId, Versioned<IpAssignment>> entry : allocationMap.entrySet()) {
        validMapping.put(entry.getKey(), entry.getValue().value());
    }
    return validMapping;
}
#end_block

#method_before
@Override
public Map<HostId, IpAssignment> listMapping() {
    return dhcpStore.listValidMapping();
}
#method_after
@Override
public Map<HostId, IpAssignment> listMapping() {
    return dhcpStore.listAssignedMapping();
}
#end_block

#method_before
@Override
public Iterable<FlowEntry> getFlowEntries(DeviceId deviceId) {
    // flatten and make iterator unmodifiable
    return FluentIterable.from(getFlowTable(deviceId).values()).transformAndConcat(input -> Collections.unmodifiableList(input));
}
#method_after
@Override
public Iterable<FlowEntry> getFlowEntries(DeviceId deviceId) {
    // flatten and make iterator unmodifiable
    return FluentIterable.from(getFlowTable(deviceId).values()).transformAndConcat(Collections::unmodifiableList);
}
#end_block

#method_before
@Override
public void start() {
    this.hostService.addListener(hostListener);
    bgpService.start(new InternalRouteListener());
    bgpUpdatesExecutor.execute(() -> doUpdatesThread());
}
#method_after
@Override
public void start() {
    this.hostService.addListener(hostListener);
    bgpService.start(new InternalRouteListener());
    bgpUpdatesExecutor.execute(this::doUpdatesThread);
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    Ethernet packet = context.inPacket().parsed();
    if (packet == null) {
        return;
    }
    if (packet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) packet.getPayload();
        if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_UDP) {
            UDP udpPacket = (UDP) ipv4Packet.getPayload();
            if (udpPacket.getDestinationPort() == UDP.DHCP_SERVER_PORT && udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT) {
                // This is meant for the dhcp server so process the packet here.
                DHCP dhcpPayload = (DHCP) udpPacket.getPayload();
                processDHCPPacket(context, dhcpPayload);
            }
        }
    } else if (packet.getEtherType() == Ethernet.TYPE_ARP) {
        ARP arpPacket = (ARP) packet.getPayload();
        if ((arpPacket.getOpCode() == ARP.OP_REQUEST) && Objects.equal(myIP, Ip4Address.valueOf(arpPacket.getTargetProtocolAddress()))) {
            processARPPacket(context, packet);
        }
    }
}
#method_after
@Override
public void process(PacketContext context) {
    Ethernet packet = context.inPacket().parsed();
    if (packet == null) {
        return;
    }
    if (packet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) packet.getPayload();
        if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_UDP) {
            UDP udpPacket = (UDP) ipv4Packet.getPayload();
            if (udpPacket.getDestinationPort() == UDP.DHCP_SERVER_PORT && udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT) {
                // This is meant for the dhcp server so process the packet here.
                DHCP dhcpPayload = (DHCP) udpPacket.getPayload();
                processDHCPPacket(context, dhcpPayload);
            }
        }
    } else if (packet.getEtherType() == Ethernet.TYPE_ARP) {
        ARP arpPacket = (ARP) packet.getPayload();
        if ((arpPacket.getOpCode() == ARP.OP_REQUEST) && Objects.equals(myIP, Ip4Address.valueOf(arpPacket.getTargetProtocolAddress()))) {
            processARPPacket(context, packet);
        }
    }
}
#end_block

#method_before
public int timerDelay() {
    return get(TIMER_DELAY, -1);
}
#method_after
public int timerDelay() {
    return get(TIMER_DELAY, DEFAULT);
}
#end_block

#method_before
@Override
public Integer getPuntCount() {
    return puntCount;
}
#method_after
@Override
public int getPuntCount() {
    return puntCount;
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    // can't do any more to it.
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethPkt = pkt.parsed();
    if (ethPkt == null) {
        return;
    }
    if (ethPkt.getEtherType() != Ethernet.TYPE_IPV4 && ethPkt.getEtherType() != Ethernet.TYPE_IPV6) {
        return;
    }
    if (ethPkt.getEtherType() == Ethernet.TYPE_IPV6) {
        // Ignore ipv6 at the moment.
        return;
    }
    IPv4 ip = (IPv4) ethPkt.getPayload();
    IpAddress gaddr = IpAddress.valueOf(ip.getDestinationAddress());
    IpAddress saddr = Ip4Address.valueOf(ip.getSourceAddress());
    log.debug("Packet (" + saddr.toString() + ", " + gaddr.toString() + ") has been punted\n" + "\tingress port: " + context.inPacket().receivedFrom().toString() + "\n");
    if (!mcast.contains(gaddr)) {
        // Yikes, this is a bad group address
        return;
    }
    if (mcast.contains(saddr)) {
        // Yikes, the source address is multicast
        return;
    }
    IpPrefix spfx = IpPrefix.valueOf(saddr, 32);
    IpPrefix gpfx = IpPrefix.valueOf(gaddr, 32);
    /*
             * Do a best match lookup on the (s, g) of the packet. If an entry does
             * not exist create one and store it's incoming connect point.
             *
             * The connect point is deviceId / portId that the packet entered
             * the SDN network.  This differs from traditional mcast where the
             * ingress port would be a specific device.
             */
    McastRoute entry = mrib.findBestMatch(spfx, gpfx);
    if (entry == null || entry.getSaddr().equals(IPv4.fromIPv4Address(0))) {
        /*
                 * Create an entry that we can fast drop.
                 */
        entry = mrib.addRoute(spfx, gpfx);
        entry.addIngressPoint(context.inPacket().receivedFrom());
    }
    /*
             * TODO: If we do not have an ingress or any egress connect points we
             * should set up a fast drop entry.
             */
    if (entry.getIngressPoint() == null) {
        return;
    }
    if (entry.getEgressPoints().isEmpty()) {
        return;
    }
    /*
             * This is odd, we should not have received a punted packet if an
             * intent was installed unless the intent was not installed
             * correctly.  However, we are seeing packets get punted after
             * the intent has been installed.
             *
             * Therefore we are going to forward the packets even if they
             * should have already been forwarded by the intent fabric.
             */
    if (entry.getIntentKey() != null) {
        return;
    }
    entry.setIntent();
    McastIntentManager im = McastIntentManager.getInstance();
    im.setIntent(entry);
    entry.incrementPuntCount();
    // Send the pack out each of the egress devices & port
    forwardPacketToDst(context, entry);
}
#method_after
@Override
public void process(PacketContext context) {
    // can't do any more to it.
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethPkt = pkt.parsed();
    if (ethPkt == null) {
        return;
    }
    if (ethPkt.getEtherType() != Ethernet.TYPE_IPV4 && ethPkt.getEtherType() != Ethernet.TYPE_IPV6) {
        return;
    }
    if (ethPkt.getEtherType() == Ethernet.TYPE_IPV6) {
        // Ignore ipv6 at the moment.
        return;
    }
    IPv4 ip = (IPv4) ethPkt.getPayload();
    IpAddress gaddr = IpAddress.valueOf(ip.getDestinationAddress());
    IpAddress saddr = Ip4Address.valueOf(ip.getSourceAddress());
    log.debug("Packet ({}, {}) has been punted\n" + "\tingress port: {}\n", saddr.toString(), gaddr.toString(), context.inPacket().receivedFrom().toString());
    if (!mcast.contains(gaddr)) {
        // Yikes, this is a bad group address
        return;
    }
    if (mcast.contains(saddr)) {
        // Yikes, the source address is multicast
        return;
    }
    IpPrefix spfx = IpPrefix.valueOf(saddr, 32);
    IpPrefix gpfx = IpPrefix.valueOf(gaddr, 32);
    /*
             * Do a best match lookup on the (s, g) of the packet. If an entry does
             * not exist create one and store it's incoming connect point.
             *
             * The connect point is deviceId / portId that the packet entered
             * the SDN network.  This differs from traditional mcast where the
             * ingress port would be a specific device.
             */
    McastRoute entry = mrib.findBestMatch(spfx, gpfx);
    if (entry == null || entry.getSaddr().equals(IPv4.fromIPv4Address(0))) {
        /*
                 * Create an entry that we can fast drop.
                 */
        entry = mrib.addRoute(spfx, gpfx);
        entry.addIngressPoint(context.inPacket().receivedFrom());
    }
    /*
             * TODO: If we do not have an ingress or any egress connect points we
             * should set up a fast drop entry.
             */
    if (entry.getIngressPoint() == null) {
        return;
    }
    if (entry.getEgressPoints().isEmpty()) {
        return;
    }
    /*
             * This is odd, we should not have received a punted packet if an
             * intent was installed unless the intent was not installed
             * correctly.  However, we are seeing packets get punted after
             * the intent has been installed.
             *
             * Therefore we are going to forward the packets even if they
             * should have already been forwarded by the intent fabric.
             */
    if (entry.getIntentKey() != null) {
        return;
    }
    entry.setIntent();
    McastIntentManager im = McastIntentManager.getInstance();
    im.setIntent(entry);
    entry.incrementPuntCount();
    // Send the pack out each of the egress devices & port
    forwardPacketToDst(context, entry);
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.igmp");
    packetService.addProcessor(processor, PacketProcessor.director(1));
    // Build a traffic selector for all multicast traffic
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchEthType(Ethernet.TYPE_IPV4);
    selector.matchIPProtocol(IGMP.PROTOCOL_IGMP);
    packetService.requestPackets(selector.build(), PacketPriority.REACTIVE, appId);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.igmp");
    packetService.addProcessor(processor, PacketProcessor.director(1));
    // Build a traffic selector for all multicast traffic
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchEthType(Ethernet.TYPE_IPV4);
    selector.matchIPProtocol(IPv4.PROTOCOL_IGMP);
    packetService.requestPackets(selector.build(), PacketPriority.REACTIVE, appId);
    log.info("Started");
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    // can't do any more to it.
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethPkt = pkt.parsed();
    if (ethPkt == null) {
        return;
    }
    /*
             * IPv6 MLD packets are handled by ICMP6. We'll only deal
             * with IPv4.
             */
    if (ethPkt.getEtherType() != Ethernet.TYPE_IPV4) {
        return;
    }
    IPv4 ip = (IPv4) ethPkt.getPayload();
    IpAddress gaddr = IpAddress.valueOf(ip.getDestinationAddress());
    IpAddress saddr = Ip4Address.valueOf(ip.getSourceAddress());
    log.debug("Packet (" + saddr.toString() + ", " + gaddr.toString() + "\tingress port: " + context.inPacket().receivedFrom().toString());
    if (ip.getProtocol() != IGMP.PROTOCOL_IGMP) {
        log.error("IGMP Picked up a non IGMP packet.");
        return;
    }
    IpPrefix mcast = IpPrefix.valueOf("224.0.0.0/4");
    if (!mcast.contains(gaddr)) {
        log.error("IGMP Picked up a non multicast packet.");
        return;
    }
    if (mcast.contains(saddr)) {
        log.error("IGMP Picked up a packet with a multicast source address.");
        return;
    }
    IpPrefix spfx = IpPrefix.valueOf(saddr, 32);
    IpPrefix gpfx = IpPrefix.valueOf(gaddr, 32);
}
#method_after
@Override
public void process(PacketContext context) {
    // can't do any more to it.
    if (context.isHandled()) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethPkt = pkt.parsed();
    if (ethPkt == null) {
        return;
    }
    /*
             * IPv6 MLD packets are handled by ICMP6. We'll only deal
             * with IPv4.
             */
    if (ethPkt.getEtherType() != Ethernet.TYPE_IPV4) {
        return;
    }
    IPv4 ip = (IPv4) ethPkt.getPayload();
    IpAddress gaddr = IpAddress.valueOf(ip.getDestinationAddress());
    IpAddress saddr = Ip4Address.valueOf(ip.getSourceAddress());
    log.debug("Packet (" + saddr.toString() + ", " + gaddr.toString() + "\tingress port: " + context.inPacket().receivedFrom().toString());
    if (ip.getProtocol() != IPv4.PROTOCOL_IGMP) {
        log.error("IGMP Picked up a non IGMP packet.");
        return;
    }
    IpPrefix mcast = IpPrefix.valueOf("224.0.0.0/4");
    if (!mcast.contains(gaddr)) {
        log.error("IGMP Picked up a non multicast packet.");
        return;
    }
    if (mcast.contains(saddr)) {
        log.error("IGMP Picked up a packet with a multicast source address.");
        return;
    }
    IpPrefix spfx = IpPrefix.valueOf(saddr, 32);
    IpPrefix gpfx = IpPrefix.valueOf(gaddr, 32);
    IGMP igmp = (IGMP) ip.getPayload();
    switch(igmp.getIgmpType()) {
        case IGMP.TYPE_IGMPV3_MEMBERSHIP_REPORT:
            IGMPProcessMembership.processMembership(igmp, pkt.receivedFrom());
            break;
        case IGMP.TYPE_IGMPV3_MEMBERSHIP_QUERY:
            IGMPProcessQuery.processQuery(igmp, pkt.receivedFrom());
            break;
        case IGMP.TYPE_IGMPV1_MEMBERSHIP_REPORT:
        case IGMP.TYPE_IGMPV2_MEMBERSHIP_REPORT:
        case IGMP.TYPE_IGMPV2_LEAVE_GROUP:
            log.debug("IGMP version 1 & 2 message types are not currently supported. Message type: " + igmp.getIgmpType());
            break;
        default:
            log.debug("Unkown IGMP message type: " + igmp.getIgmpType());
            break;
    }
}
#end_block

#method_before
public static Deserializer<PIMJoinPrune> deserializer() {
    return (data, offset, length) -> {
        checkInput(data, offset, length, PIM.PIM_HEADER_LEN);
        PIMJoinPrune jp = new PIMJoinPrune();
        final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
        // We must get a PIM encoded unicast address
        PIMAddrUnicast upstream = new PIMAddrUnicast();
        upstream.deserialize(bb);
        jp.setUpstreamAddr(upstream);
        // get and skip the reserved byte
        bb.get();
        // Get the number of groups.
        int ngroups = bb.get();
        // Save the holdtime.
        jp.setHoldTime(bb.getShort());
        // Now we start iterating through the group joins and prunes
        for (int i = 0; i < ngroups; i++) {
            PIMAddrGroup grp = new PIMAddrGroup();
            grp.deserialize(bb);
            int njoins = bb.getShort();
            int nprunes = bb.getShort();
            // Now iterate through the joins for this group
            for (; njoins > 0; njoins--) {
                PIMAddrSource src = new PIMAddrSource();
                src.deserialize(bb);
                jp.addJoinPrune(src.getAddr().toIpPrefix(), grp.getAddr().toIpPrefix(), true);
            }
            // Now iterate through the prunes for this group
            for (; nprunes > 0; nprunes--) {
                PIMAddrSource src = new PIMAddrSource();
                src.deserialize(bb);
                jp.addJoinPrune(src.getAddr().toIpPrefix(), grp.getAddr().toIpPrefix(), false);
            }
        }
        return jp;
    };
}
#method_after
public static Deserializer<PIMJoinPrune> deserializer() {
    return (data, offset, length) -> {
        /*
             * Delay buffer checks until we read enough of the packet to know how
             * much data we will require.  Each encoded address deserializer function
             * will ensure there is enough data for that address.
             */
        PIMJoinPrune jp = new PIMJoinPrune();
        final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
        // We must get a PIM encoded unicast address
        PIMAddrUnicast upstream = new PIMAddrUnicast();
        upstream.deserialize(bb);
        jp.setUpstreamAddr(upstream);
        // Use this boolean to determine the buffer space we need according to address sizes
        boolean ipv4 = upstream.getAddr().isIp4();
        // We need at minimum 4 bytes for reserved(1), ngroups(1) & holdtime(2)
        checkInput(bb.array(), bb.position(), bb.limit() - bb.position(), 4);
        // get and skip the reserved byte
        bb.get();
        // Get the number of groups.
        int ngroups = bb.get();
        // Save the holdtime.
        jp.setHoldTime(bb.getShort());
        for (int i = 0; i < ngroups; i++) {
            PIMAddrGroup grp = new PIMAddrGroup();
            /*
                 * grp.deserialize will ensure the buffer has enough data to read the group address.
                 */
            grp.deserialize(bb);
            checkInput(bb.array(), bb.position(), bb.limit() - bb.position(), 4);
            int njoins = bb.getShort();
            int nprunes = bb.getShort();
            /*
                 * Now we'll verify we have enough buffer to read the next
                 * group of join and prune addresses for this group.
                 */
            int required = (njoins + nprunes) * (ipv4 ? PIMAddrSource.ENC_SOURCE_IPV4_BYTE_LENGTH : PIMAddrSource.ENC_SOURCE_IPV6_BYTE_LENGTH);
            checkInput(bb.array(), bb.position(), bb.limit() - bb.position(), required);
            // Now iterate through the joins for this group
            for (; njoins > 0; njoins--) {
                PIMAddrSource src = new PIMAddrSource();
                src.deserialize(bb);
                jp.addJoinPrune(src.getAddr().toIpPrefix(), grp.getAddr().toIpPrefix(), true);
            }
            // Now iterate through the prunes for this group
            for (; nprunes > 0; nprunes--) {
                PIMAddrSource src = new PIMAddrSource();
                src.deserialize(bb);
                jp.addJoinPrune(src.getAddr().toIpPrefix(), grp.getAddr().toIpPrefix(), false);
            }
        }
        return jp;
    };
}
#end_block

#method_before
public PIMAddrGroup deserialize(ByteBuffer bb) {
    this.family = bb.get();
    this.encType = bb.get();
    this.reserved = bb.get();
    if ((this.reserved & 0x80) != 0) {
        this.bBit = true;
    }
    if ((this.reserved & 0x01) != 0) {
        this.zBit = true;
    }
    // Remove the z and b bits from reserved
    this.reserved |= 0x7d;
    this.masklen = bb.get();
    if (this.family == 4) {
        this.addr = IpAddress.valueOf(bb.getInt());
    } else if (this.family == 6) {
        this.addr = Ip6Address.valueOf(bb.array(), 2);
    }
    return this;
}
#method_after
public PIMAddrGroup deserialize(ByteBuffer bb) throws DeserializationException {
    /*
         * We need to verify that we have enough buffer space.  First we'll assume that
         * we are decoding an IPv4 address.  After we read the first by (address family),
         * we'll determine if we actually need more buffer space for an IPv6 address.
         */
    checkInput(bb.array(), bb.position(), bb.limit() - bb.position(), ENC_GROUP_IPV4_BYTE_LENGTH);
    this.family = bb.get();
    if (family != 4 && family != 6) {
        throw new DeserializationException("Illegal IP version number: " + family + "\n");
    } else if (family == 6) {
        // Check for one less by since we have already read the first byte of the packet.
        checkInput(bb.array(), bb.position(), bb.limit() - bb.position(), ENC_GROUP_IPV6_BYTE_LENGTH - 1);
    }
    this.encType = bb.get();
    this.reserved = bb.get();
    if ((this.reserved & 0x80) != 0) {
        this.bBit = true;
    }
    if ((this.reserved & 0x01) != 0) {
        this.zBit = true;
    }
    // Remove the z and b bits from reserved
    this.reserved |= 0x7d;
    this.masklen = bb.get();
    if (this.family == 4) {
        this.addr = IpAddress.valueOf(bb.getInt());
    } else if (this.family == 6) {
        this.addr = Ip6Address.valueOf(bb.array(), 2);
    }
    return this;
}
#end_block

#method_before
public int getFamily() {
    return this.family;
}
#method_after
public byte getFamily() {
    return this.family;
}
#end_block

#method_before
public byte[] serialize() {
    int len = getByteSize();
    final byte[] data = new byte[len];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    bb.put(this.family);
    bb.put(this.encType);
    // Todo: technically we should be setting the B and Z bits, but we'll never use them.
    byte mask = 0x0;
    if (this.sBit) {
        this.reserved |= 0x4;
    }
    if (this.wBit) {
        this.reserved |= 0x2;
    }
    if (this.rBit) {
        this.reserved |= 0x1;
    }
    bb.put(reserved);
    bb.put(this.masklen);
    bb.put(this.addr.toOctets());
    return data;
}
#method_after
public byte[] serialize() {
    int len = addr.isIp4() ? ENC_SOURCE_IPV4_BYTE_LENGTH : ENC_SOURCE_IPV6_BYTE_LENGTH;
    final byte[] data = new byte[len];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    bb.put(this.family);
    bb.put(this.encType);
    // Todo: technically we should be setting the B and Z bits, but we'll never use them.
    byte mask = 0x0;
    if (this.sBit) {
        this.reserved |= 0x4;
    }
    if (this.wBit) {
        this.reserved |= 0x2;
    }
    if (this.rBit) {
        this.reserved |= 0x1;
    }
    bb.put(reserved);
    bb.put(this.masklen);
    bb.put(this.addr.toOctets());
    return data;
}
#end_block

#method_before
public PIMAddrSource deserialize(byte[] data, int offset, int length) {
    final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
    return deserialize(bb);
}
#method_after
public PIMAddrSource deserialize(byte[] data, int offset, int length) throws DeserializationException {
    final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
    return deserialize(bb);
}
#end_block

#method_before
public PIMAddrSource deserialize(ByteBuffer bb) {
    this.family = bb.get();
    this.encType = bb.get();
    this.reserved = bb.get();
    if ((this.reserved & 0x01) != 0) {
        this.rBit = true;
    }
    if ((this.reserved & 0x02) != 0) {
        this.wBit = true;
    }
    if ((this.reserved & 0x4) != 0) {
        this.sBit = true;
    }
    // Remove the s, reserved
    this.reserved &= 0xf8;
    this.masklen = bb.get();
    if (this.family == 4) {
        this.addr = IpAddress.valueOf(bb.getInt());
    } else if (this.family == 6) {
        this.addr = Ip6Address.valueOf(bb.array(), 2);
    }
    return this;
}
#method_after
public PIMAddrSource deserialize(ByteBuffer bb) throws DeserializationException {
    /*
         * We need to verify that we have enough buffer space.  First we'll assume that
         * we are decoding an IPv4 address.  After we read the first by (address family),
         * we'll determine if we actually need more buffer space for an IPv6 address.
         */
    checkInput(bb.array(), bb.position(), bb.limit() - bb.position(), ENC_SOURCE_IPV4_BYTE_LENGTH);
    this.family = bb.get();
    if (family != 4 && family != 6) {
        throw new DeserializationException("Illegal IP version number: " + family + "\n");
    } else if (family == 6) {
        // Check for one less by since we have already read the first byte of the packet.
        checkInput(bb.array(), bb.position(), bb.limit() - bb.position(), ENC_SOURCE_IPV6_BYTE_LENGTH - 1);
    }
    this.encType = bb.get();
    this.reserved = bb.get();
    if ((this.reserved & 0x01) != 0) {
        this.rBit = true;
    }
    if ((this.reserved & 0x02) != 0) {
        this.wBit = true;
    }
    if ((this.reserved & 0x4) != 0) {
        this.sBit = true;
    }
    // Remove the s, reserved
    this.reserved &= 0xf8;
    this.masklen = bb.get();
    if (this.family == 4) {
        this.addr = IpAddress.valueOf(bb.getInt());
    } else if (this.family == 6) {
        this.addr = Ip6Address.valueOf(bb.array(), 2);
    }
    return this;
}
#end_block

#method_before
public PIMAddrUnicast deserialize(ByteBuffer bb) {
    this.family = bb.get();
    this.encType = bb.get();
    if (this.family == 4) {
        this.addr = IpAddress.valueOf(bb.getInt());
    } else if (this.family == 6) {
        this.addr = Ip6Address.valueOf(bb.array(), 2);
    }
    return this;
}
#method_after
public PIMAddrUnicast deserialize(ByteBuffer bb) throws DeserializationException {
    // Assume IPv4 for check length until we read the encoded family.
    checkInput(bb.array(), bb.position(), bb.limit() - bb.position(), ENC_UNICAST_IPV4_BYTE_LENGTH);
    this.family = bb.get();
    // If we have IPv6 we need to ensure we have adequate buffer space.
    if (this.family != 4 && this.family != 6) {
        throw new DeserializationException("Invalid address family: " + this.family);
    } else if (this.family == 6) {
        // Subtract -1 from ENC_UNICAST_IPv6 BYTE_LENGTH because we read one byte for family previously.
        checkInput(bb.array(), bb.position(), bb.limit() - bb.position(), ENC_UNICAST_IPV6_BYTE_LENGTH - 1);
    }
    this.encType = bb.get();
    if (this.family == 4) {
        this.addr = IpAddress.valueOf(bb.getInt());
    } else if (this.family == 6) {
        this.addr = Ip6Address.valueOf(bb.array(), 2);
    }
    return this;
}
#end_block

#method_before
// TODO: I suppose I really need to implement this?
public IPacket deserialize(final byte[] data, final int offset, final int length) {
    final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
    return this;
}
#method_after
/**
 * XXX: This is deprecated, DO NOT USE, use the deserializer() function instead.
 */
public IPacket deserialize(final byte[] data, final int offset, final int length) {
    // 
    return null;
}
#end_block

#method_before
public static Deserializer<PIMHello> deserializer() {
    return (data, offset, length) -> {
        checkInput(data, offset, length, PIM.PIM_HEADER_LEN);
        final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
        PIMHello hello = new PIMHello();
        while (bb.hasRemaining()) {
            int optType = bb.getShort();
            int optLen = bb.getShort();
            if (optType == Option.GENID.optType) {
                hello.addGenId(bb.getInt());
            } else if (optType == Option.PRIORITY.optType) {
                hello.addPriority(bb.getInt());
            } else if (optType == Option.HOLDTIME.optType) {
                hello.addHoldtime((int) bb.getShort());
            }
        }
        return hello;
    };
}
#method_after
public static Deserializer<PIMHello> deserializer() {
    return (data, offset, length) -> {
        checkInput(data, offset, length, MINIMUM_OPTION_LEN_BYTES);
        final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
        PIMHello hello = new PIMHello();
        while (bb.hasRemaining()) {
            int optType = bb.getShort();
            int optLen = bb.getShort();
            // Check that we have enough buffer for the next option.
            checkInput(data, bb.position(), bb.limit() - bb.position(), optLen);
            if (optType == Option.GENID.optType) {
                hello.addGenId(bb.getInt());
            } else if (optType == Option.PRIORITY.optType) {
                hello.addPriority(bb.getInt());
            } else if (optType == Option.HOLDTIME.optType) {
                hello.addHoldtime((int) bb.getShort());
            }
        }
        return hello;
    };
}
#end_block

#method_before
@Override
public void init(DeviceId deviceId, PipelinerContext context) {
    this.serviceDirectory = context.directory();
    this.deviceId = deviceId;
    coreService = serviceDirectory.get(CoreService.class);
    flowRuleService = serviceDirectory.get(FlowRuleService.class);
    flowObjectiveStore = context.store();
    coreService.registerApplication("org.onosproject.driver.OpenVSwitchPipeline");
}
#method_after
@Override
public void init(DeviceId deviceId, PipelinerContext context) {
    super.init(deviceId, context);
    this.serviceDirectory = context.directory();
    this.deviceId = deviceId;
    coreService = serviceDirectory.get(CoreService.class);
    flowRuleService = serviceDirectory.get(FlowRuleService.class);
    flowObjectiveStore = context.store();
    coreService.registerApplication("org.onosproject.driver.OpenVSwitchPipeline");
}
#end_block

#method_before
@Override
public void filter(FilteringObjective filteringObjective) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void filter(FilteringObjective filteringObjective) {
    super.filter(filteringObjective);
}
#end_block

#method_before
@Override
public void forward(ForwardingObjective fwd) {
    Collection<FlowRule> rules;
    FlowRuleOperations.Builder flowOpsBuilder = FlowRuleOperations.builder();
    rules = processForward(fwd);
    switch(fwd.op()) {
        case ADD:
            rules.stream().filter(rule -> rule != null).forEach(flowOpsBuilder::add);
            break;
        case REMOVE:
            rules.stream().filter(rule -> rule != null).forEach(flowOpsBuilder::remove);
            break;
        default:
            fail(fwd, ObjectiveError.UNKNOWN);
            log.warn("Unknown forwarding type {}", fwd.op());
    }
    flowRuleService.apply(flowOpsBuilder.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(fwd);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#method_after
@Override
public void forward(ForwardingObjective fwd) {
    if (!VTN_APP_ID.equals(fwd.appId().name())) {
        super.forward(fwd);
        return;
    }
    Collection<FlowRule> rules;
    FlowRuleOperations.Builder flowOpsBuilder = FlowRuleOperations.builder();
    rules = processForward(fwd);
    switch(fwd.op()) {
        case ADD:
            rules.stream().filter(rule -> rule != null).forEach(flowOpsBuilder::add);
            break;
        case REMOVE:
            rules.stream().filter(rule -> rule != null).forEach(flowOpsBuilder::remove);
            break;
        default:
            fail(fwd, ObjectiveError.UNKNOWN);
            log.warn("Unknown forwarding type {}", fwd.op());
    }
    flowRuleService.apply(flowOpsBuilder.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(fwd);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(fwd, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#end_block

#method_before
@Override
public void next(NextObjective nextObjective) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void next(NextObjective nextObjective) {
    super.next(nextObjective);
}
#end_block

#method_before
@Override
public Collection<BridgeDescription> getBridges() {
    DriverHandler handler = handler();
    DeviceId deviceId = handler.data().deviceId();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    Set<OvsdbBridge> ovsdbSet = clientService.getBridges();
    Collection<BridgeDescription> bridges = Sets.newHashSet();
    ovsdbSet.forEach(o -> {
        BridgeName bridgeName = BridgeName.bridgeName(o.bridgeName().value());
        DeviceId ownDeviceId = DeviceId.deviceId("of:" + o.datapathId().value());
        BridgeDescription description = new DefaultBridgeDescription(bridgeName, deviceId, ownDeviceId);
        bridges.add(description);
    });
    return bridges == null ? Collections.emptySet() : bridges;
}
#method_after
@Override
public Collection<BridgeDescription> getBridges() {
    DriverHandler handler = handler();
    DeviceId deviceId = handler.data().deviceId();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    Set<OvsdbBridge> bridges = clientService.getBridges();
    return bridges.stream().map(x -> new DefaultBridgeDescription(BridgeName.bridgeName(x.bridgeName().value()), deviceId, DeviceId.deviceId("of:" + x.datapathId().value()))).collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public Collection<PortDescription> getPorts() {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    Set<OvsdbPort> ovsdbSet = clientService.getPorts();
    Collection<PortDescription> ports = Sets.newHashSet();
    ovsdbSet.forEach(o -> {
        PortNumber port = PortNumber.portNumber(o.portNumber().value());
        PortDescription description = new DefaultPortDescription(port, true);
        ports.add(description);
    });
    return ports;
}
#method_after
@Override
public Collection<PortDescription> getPorts() {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    Set<OvsdbPort> ports = clientService.getPorts();
    return ports.stream().map(x -> new DefaultPortDescription(PortNumber.portNumber(x.portNumber().value()), true)).collect(Collectors.toSet());
}
#end_block

#method_before
// OvsdbNodeId(IP:port) is used in the adaptor while DeviceId(ovsdb:IP:port)
private OvsdbNodeId changeDeviceIdToNodeId(DeviceId deviceId) {
    int lastColon = deviceId.toString().lastIndexOf(":");
    int fistColon = deviceId.toString().indexOf(":");
    String ip = deviceId.toString().substring(fistColon + 1, lastColon);
    String port = deviceId.toString().substring(lastColon + 1);
    IpAddress ipAddress = IpAddress.valueOf(ip);
    long portL = Long.valueOf(port).longValue();
    return new OvsdbNodeId(ipAddress, portL);
}
#method_after
// OvsdbNodeId(IP:port) is used in the adaptor while DeviceId(ovsdb:IP:port)
private OvsdbNodeId changeDeviceIdToNodeId(DeviceId deviceId) {
    int lastColon = deviceId.toString().lastIndexOf(":");
    int fistColon = deviceId.toString().indexOf(":");
    String ip = deviceId.toString().substring(fistColon + 1, lastColon);
    String port = deviceId.toString().substring(lastColon + 1);
    IpAddress ipAddress = IpAddress.valueOf(ip);
    long portL = Long.parseLong(port);
    return new OvsdbNodeId(ipAddress, portL);
}
#end_block

#method_before
@Override
public Set<PortNumber> getPortNumbers() {
    Set<PortNumber> ports = new HashSet<>();
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    Set<OvsdbPort> ovsdbSet = clientService.getPorts();
    ovsdbSet.forEach(o -> {
        PortNumber port = PortNumber.portNumber(o.portNumber().value(), o.portName().value());
        ports.add(port);
    });
    return ports;
}
#method_after
@Override
public Set<PortNumber> getPortNumbers() {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    Set<OvsdbPort> ports = clientService.getPorts();
    return ports.stream().map(x -> PortNumber.portNumber(x.portNumber().value(), x.portName().value())).collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public void onServerDetected(Device device) {
    Iterable<Device> devices = deviceService.getAvailableDevices();
    DriverHandler handler = driverService.createHandler(device.id());
    BridgeConfig bridgeConfig = handler.behaviour(BridgeConfig.class);
    bridgeConfig.addBridge(BridgeName.bridgeName(DEFAULT_BRIDGE_NAME));
    String ipAddress = device.annotations().value(CONTROLLER_IP_KEY);
    IpAddress ip = IpAddress.valueOf(ipAddress);
    Sets.newHashSet(devices).stream().filter(d -> Device.Type.CONTROLLER == d.type()).filter(d -> !device.id().equals(d.id())).forEach(d -> {
        if (!device.id().equals(d.id()) && Device.Type.CONTROLLER == d.type()) {
            String ipAddress1 = d.annotations().value(CONTROLLER_IP_KEY);
            IpAddress ip1 = IpAddress.valueOf(ipAddress1);
            applyTunnelConfig(ip, ip1, handler);
            DriverHandler handler1 = driverService.createHandler(d.id());
            applyTunnelConfig(ip1, ip, handler1);
        }
    });
}
#method_after
@Override
public void onServerDetected(Device device) {
    Iterable<Device> devices = deviceService.getAvailableDevices();
    DriverHandler handler = driverService.createHandler(device.id());
    BridgeConfig bridgeConfig = handler.behaviour(BridgeConfig.class);
    bridgeConfig.addBridge(BridgeName.bridgeName(DEFAULT_BRIDGE_NAME));
    String ipAddress = device.annotations().value(CONTROLLER_IP_KEY);
    IpAddress ip = IpAddress.valueOf(ipAddress);
    Sets.newHashSet(devices).stream().filter(d -> Device.Type.CONTROLLER == d.type()).filter(d -> !device.id().equals(d.id())).forEach(d -> {
        String ipAddress1 = d.annotations().value(CONTROLLER_IP_KEY);
        IpAddress ip1 = IpAddress.valueOf(ipAddress1);
        applyTunnelConfig(ip, ip1, handler);
        DriverHandler handler1 = driverService.createHandler(d.id());
        applyTunnelConfig(ip1, ip, handler1);
    });
}
#end_block

#method_before
private void programLocalOut(DeviceId dpid, SegmentationId segmentationId, PortNumber outPort, MacAddress sourceMac, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchTunnelId(Long.parseLong(segmentationId.toString())).matchEthDst(sourceMac).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(outPort).build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(MAC_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#method_after
private void programLocalOut(DeviceId dpid, SegmentationId segmentationId, PortNumber outPort, MacAddress sourceMac, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchTunnelId(Long.parseLong(segmentationId.toString())).matchEthDst(sourceMac).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(outPort).build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(MAC_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowServiceForward(dpid, objective.add());
    } else {
        flowServiceForward(dpid, objective.remove());
    }
}
#end_block

#method_before
private void programTunnelOut(DeviceId dpid, SegmentationId segmentationId, PortNumber tunnelOutPort, MacAddress dstMac, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(dstMac).add(Criteria.matchTunnelId(Long.parseLong(segmentationId.toString()))).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(tunnelOutPort).build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(MAC_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#method_after
private void programTunnelOut(DeviceId dpid, SegmentationId segmentationId, PortNumber tunnelOutPort, MacAddress dstMac, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(dstMac).add(Criteria.matchTunnelId(Long.parseLong(segmentationId.toString()))).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(tunnelOutPort).build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC).withPriority(MAC_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowServiceForward(dpid, objective.add());
    } else {
        flowServiceForward(dpid, objective.remove());
    }
}
#end_block

#method_before
// Used to forward multicast flows to remote VMs of the same tenant via
private void programTunnelFloodOut(DeviceId deviceId, SegmentationId segmentationId, PortNumber ofPortOut, List<PortNumber> localVmPorts, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(ofPortOut).add(Criteria.matchTunnelId(Long.parseLong(segmentationId.toString()))).matchEthDst(MacAddress.BROADCAST).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    for (PortNumber outPort : localVmPorts) {
        treatment.setOutput(outPort);
    }
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC).withPriority(MAC_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#method_after
// Used to forward multicast flows to remote VMs of the same tenant via
private void programTunnelFloodOut(DeviceId deviceId, SegmentationId segmentationId, PortNumber ofPortOut, List<PortNumber> localVmPorts, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(ofPortOut).add(Criteria.matchTunnelId(Long.parseLong(segmentationId.toString()))).matchEthDst(MacAddress.BROADCAST).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    for (PortNumber outPort : localVmPorts) {
        treatment.setOutput(outPort);
    }
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC).withPriority(MAC_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowServiceForward(deviceId, objective.add());
    } else {
        flowServiceForward(deviceId, objective.remove());
    }
}
#end_block

#method_before
private void programMacDefaultRules(DeviceId dpid, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().drop().build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC).withPriority(DEFAULT_MAC_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#method_after
private void programMacDefaultRules(DeviceId dpid, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().drop().build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC).withPriority(DEFAULT_MAC_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowServiceForward(dpid, objective.add());
    } else {
        flowServiceForward(dpid, objective.remove());
    }
}
#end_block

#method_before
private void programLocalBcastRules(DeviceId deviceId, SegmentationId segmentationId, PortNumber inPort, List<PortNumber> localVmPorts, List<PortNumber> localTunnelPorts, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(inPort).matchEthDst(MacAddress.BROADCAST).add(Criteria.matchTunnelId(Long.parseLong(segmentationId.toString()))).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    for (PortNumber outPort : localVmPorts) {
        if (inPort != outPort) {
            treatment.setOutput(outPort);
        }
    }
    for (PortNumber outport : localTunnelPorts) {
        treatment.setOutput(outport);
    }
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC).withPriority(MAC_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(deviceId, objective.add());
    } else {
        flowObjectiveService.forward(deviceId, objective.remove());
    }
}
#method_after
private void programLocalBcastRules(DeviceId deviceId, SegmentationId segmentationId, PortNumber inPort, List<PortNumber> localVmPorts, List<PortNumber> localTunnelPorts, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(inPort).matchEthDst(MacAddress.BROADCAST).add(Criteria.matchTunnelId(Long.parseLong(segmentationId.toString()))).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    for (PortNumber outPort : localVmPorts) {
        if (inPort != outPort) {
            treatment.setOutput(outPort);
        }
    }
    for (PortNumber outport : localTunnelPorts) {
        treatment.setOutput(outport);
    }
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC).withPriority(MAC_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowServiceForward(deviceId, objective.add());
    } else {
        flowServiceForward(deviceId, objective.remove());
    }
}
#end_block

#method_before
private void programLocalIn(DeviceId dpid, SegmentationId segmentationId, PortNumber inPort, MacAddress srcMac, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(inPort).matchEthSrc(srcMac).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.add(Instructions.modTunnelId(Long.parseLong(segmentationId.toString())));
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC).withPriority(PORT_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#method_after
private void programLocalIn(DeviceId dpid, SegmentationId segmentationId, PortNumber inPort, MacAddress srcMac, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(inPort).matchEthSrc(srcMac).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.add(Instructions.modTunnelId(Long.parseLong(segmentationId.toString())));
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC).withPriority(PORT_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowServiceForward(dpid, objective.add());
    } else {
        flowServiceForward(dpid, objective.remove());
    }
}
#end_block

#method_before
private void programTunnelIn(DeviceId dpid, SegmentationId segmentationId, PortNumber tunnelInPort, PortNumber outPort, MacAddress sourceMac, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(tunnelInPort).add(Criteria.matchTunnelId(Long.parseLong(segmentationId.toString()))).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC).withPriority(PORT_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#method_after
private void programTunnelIn(DeviceId dpid, SegmentationId segmentationId, PortNumber tunnelInPort, PortNumber outPort, MacAddress sourceMac, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(tunnelInPort).add(Criteria.matchTunnelId(Long.parseLong(segmentationId.toString()))).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC).withPriority(PORT_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowServiceForward(dpid, objective.add());
    } else {
        flowServiceForward(dpid, objective.remove());
    }
}
#end_block

#method_before
private void programPortDefaultRules(DeviceId dpid, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC).withPriority(DEFAULT_PORT_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#method_after
private void programPortDefaultRules(DeviceId dpid, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC).withPriority(DEFAULT_PORT_PRIORITY);
    if (type.equals(Objective.Operation.ADD)) {
        flowServiceForward(dpid, objective.add());
    } else {
        flowServiceForward(dpid, objective.remove());
    }
}
#end_block

#method_before
public static PcepValueType read(ChannelBuffer c) {
    byte temp = c.readByte();
    boolean bLFlag;
    boolean bRFlag;
    if ((temp & LFLAG_SET) == SET) {
        bLFlag = true;
    } else {
        bLFlag = false;
    }
    if ((temp & RFLAG_SET) == SET) {
        bRFlag = true;
    } else {
        bRFlag = false;
    }
    return new MPLSProtocolMaskTlv(bLFlag, bRFlag);
}
#method_after
public static PcepValueType read(ChannelBuffer c) {
    byte temp = c.readByte();
    boolean bLFlag;
    boolean bRFlag;
    bLFlag = (temp & LFLAG_SET) == LFLAG_SET;
    bRFlag = (temp & RFLAG_SET) == RFLAG_SET;
    return new MPLSProtocolMaskTlv(bLFlag, bRFlag);
}
#end_block

#method_before
public static PcepSrpObject read(ChannelBuffer cb) throws PcepParseException {
    log.debug("SrpObject::read");
    PcepObjectHeader srpObjHeader;
    boolean bRFlag;
    int srpID;
    int flags;
    LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
    srpObjHeader = PcepObjectHeader.read(cb);
    if (srpObjHeader.getObjClass() != SRP_OBJ_CLASS) {
        throw new PcepParseException("SRP object expected. But received " + srpObjHeader.getObjClass());
    }
    // take only SrpObject buffer.
    ChannelBuffer tempCb = cb.readBytes(srpObjHeader.getObjLen() - MINIMUM_COMMON_HEADER_LENGTH);
    flags = tempCb.readInt();
    bRFlag = 0 < flags;
    srpID = tempCb.readInt();
    llOptionalTlv = parseOptionalTlv(tempCb);
    return new PcepSrpObjectVer1(srpObjHeader, bRFlag, srpID, llOptionalTlv);
}
#method_after
public static PcepSrpObject read(ChannelBuffer cb) throws PcepParseException {
    log.debug("SrpObject::read");
    PcepObjectHeader srpObjHeader;
    boolean bRFlag;
    int srpID;
    int flags;
    LinkedList<PcepValueType> llOptionalTlv = new LinkedList<>();
    srpObjHeader = PcepObjectHeader.read(cb);
    if (srpObjHeader.getObjClass() != SRP_OBJ_CLASS) {
        throw new PcepParseException("SRP object expected. But received " + srpObjHeader.getObjClass());
    }
    // take only SrpObject buffer.
    ChannelBuffer tempCb = cb.readBytes(srpObjHeader.getObjLen() - MINIMUM_COMMON_HEADER_LENGTH);
    flags = tempCb.readInt();
    bRFlag = 0 < flags;
    srpID = tempCb.readInt();
    llOptionalTlv = parseOptionalTlv(tempCb);
    return new PcepSrpObjectVer1(srpObjHeader, bRFlag, srpID, llOptionalTlv);
}
#end_block

#method_before
public static LinkedList<PcepValueType> parseOptionalTlv(ChannelBuffer cb) throws PcepParseException {
    LinkedList<PcepValueType> llOutOptionalTlv = new LinkedList<PcepValueType>();
    while (MINIMUM_COMMON_HEADER_LENGTH <= cb.readableBytes()) {
        PcepValueType tlv;
        short hType = cb.readShort();
        short hLength = cb.readShort();
        switch(hType) {
            case SymbolicPathNameTlv.TYPE:
                tlv = SymbolicPathNameTlv.read(cb, hLength);
                cb.skipBytes(hLength);
                break;
            default:
                throw new PcepParseException("Unsupported TLV received in SRP Object.");
        }
        // Check for the padding
        int pad = hLength % 4;
        if (0 < pad) {
            pad = 4 - pad;
            if (pad <= cb.readableBytes()) {
                cb.skipBytes(pad);
            }
        }
        llOutOptionalTlv.add(tlv);
    }
    return llOutOptionalTlv;
}
#method_after
public static LinkedList<PcepValueType> parseOptionalTlv(ChannelBuffer cb) throws PcepParseException {
    LinkedList<PcepValueType> llOutOptionalTlv = new LinkedList<>();
    while (MINIMUM_COMMON_HEADER_LENGTH <= cb.readableBytes()) {
        PcepValueType tlv;
        short hType = cb.readShort();
        short hLength = cb.readShort();
        switch(hType) {
            case SymbolicPathNameTlv.TYPE:
                tlv = SymbolicPathNameTlv.read(cb, hLength);
                cb.skipBytes(hLength);
                break;
            default:
                throw new PcepParseException("Unsupported TLV received in SRP Object.");
        }
        // Check for the padding
        int pad = hLength % 4;
        if (0 < pad) {
            pad = 4 - pad;
            if (pad <= cb.readableBytes()) {
                cb.skipBytes(pad);
            }
        }
        llOutOptionalTlv.add(tlv);
    }
    return llOutOptionalTlv;
}
#end_block

#method_before
public static LinkedList<PcepValueType> parseOptionalTlv(ChannelBuffer cb) throws PcepParseException {
    LinkedList<PcepValueType> llOutOptionalTlv = new LinkedList<PcepValueType>();
    return llOutOptionalTlv;
}
#method_after
public static LinkedList<PcepValueType> parseOptionalTlv(ChannelBuffer cb) throws PcepParseException {
    LinkedList<PcepValueType> llOutOptionalTlv = new LinkedList<>();
    return llOutOptionalTlv;
}
#end_block

#method_before
public static PcepLspObject read(ChannelBuffer cb) throws PcepParseException {
    PcepObjectHeader lspObjHeader;
    int iPlspId;
    // 3-bits
    byte yOFlag;
    boolean bAFlag;
    boolean bRFlag;
    boolean bSFlag;
    boolean bDFlag;
    // Optional TLV
    LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
    lspObjHeader = PcepObjectHeader.read(cb);
    if (lspObjHeader.getObjClass() != PcepLspObjectVer1.LSP_OBJ_CLASS) {
        throw new PcepParseException(PcepErrorDetailInfo.ERROR_TYPE_6, PcepErrorDetailInfo.ERROR_VALUE_8);
    }
    // take only LspObject buffer.
    ChannelBuffer tempCb = cb.readBytes(lspObjHeader.getObjLen() - OBJECT_HEADER_LENGTH);
    Integer iTemp = tempCb.readInt();
    iPlspId = (iTemp & PLSPID_TEMP_SHIFT_VALUE) >> PLSPID_SHIFT_VALUE;
    Integer iX = (iTemp & OFLAG_TEMP_SHIFT_VALUE) >> OFLAG_SHIFT_VALUE;
    yOFlag = iX.byteValue();
    iX = (iTemp & AFLAG_TEMP_SHIFT_VALUE) >> AFLAG_SHIFT_VALUE;
    bAFlag = iX > 0;
    iX = (iTemp & RFLAG_TEMP_SHIFT_VALUE) >> RFLAG_SHIFT_VALUE;
    bRFlag = iX > 0;
    iX = (iTemp & SFLAG_TEMP_SHIFT_VALUE) >> SFLAG_SHIFT_VALUE;
    bSFlag = iX > 0;
    iX = iTemp & DFLAG_TEMP_SHIFT_VALUE;
    bDFlag = iX > 0;
    // parse optional TLV
    llOptionalTlv = parseOptionalTlv(tempCb);
    return new PcepLspObjectVer1(lspObjHeader, iPlspId, yOFlag, bAFlag, bRFlag, bSFlag, bDFlag, llOptionalTlv);
}
#method_after
public static PcepLspObject read(ChannelBuffer cb) throws PcepParseException {
    PcepObjectHeader lspObjHeader;
    int iPlspId;
    // 3-bits
    byte yOFlag;
    boolean bAFlag;
    boolean bRFlag;
    boolean bSFlag;
    boolean bDFlag;
    // Optional TLV
    LinkedList<PcepValueType> llOptionalTlv = new LinkedList<>();
    lspObjHeader = PcepObjectHeader.read(cb);
    if (lspObjHeader.getObjClass() != PcepLspObjectVer1.LSP_OBJ_CLASS) {
        throw new PcepParseException(PcepErrorDetailInfo.ERROR_TYPE_6, PcepErrorDetailInfo.ERROR_VALUE_8);
    }
    // take only LspObject buffer.
    ChannelBuffer tempCb = cb.readBytes(lspObjHeader.getObjLen() - OBJECT_HEADER_LENGTH);
    Integer iTemp = tempCb.readInt();
    iPlspId = (iTemp & PLSPID_TEMP_SHIFT_VALUE) >> PLSPID_SHIFT_VALUE;
    Integer iX = (iTemp & OFLAG_TEMP_SHIFT_VALUE) >> OFLAG_SHIFT_VALUE;
    yOFlag = iX.byteValue();
    iX = (iTemp & AFLAG_TEMP_SHIFT_VALUE) >> AFLAG_SHIFT_VALUE;
    bAFlag = iX > 0;
    iX = (iTemp & RFLAG_TEMP_SHIFT_VALUE) >> RFLAG_SHIFT_VALUE;
    bRFlag = iX > 0;
    iX = (iTemp & SFLAG_TEMP_SHIFT_VALUE) >> SFLAG_SHIFT_VALUE;
    bSFlag = iX > 0;
    iX = iTemp & DFLAG_TEMP_SHIFT_VALUE;
    bDFlag = iX > 0;
    // parse optional TLV
    llOptionalTlv = parseOptionalTlv(tempCb);
    return new PcepLspObjectVer1(lspObjHeader, iPlspId, yOFlag, bAFlag, bRFlag, bSFlag, bDFlag, llOptionalTlv);
}
#end_block

#method_before
protected static LinkedList<PcepValueType> parseOptionalTlv(ChannelBuffer cb) throws PcepParseException {
    LinkedList<PcepValueType> llOutOptionalTlv;
    llOutOptionalTlv = new LinkedList<PcepValueType>();
    while (MINIMUM_COMMON_HEADER_LENGTH <= cb.readableBytes()) {
        PcepValueType tlv;
        short hType = cb.readShort();
        short hLength = cb.readShort();
        int iValue = 0;
        switch(hType) {
            case StatefulIPv4LspIdentidiersTlv.TYPE:
                tlv = StatefulIPv4LspIdentidiersTlv.read(cb);
                break;
            case StatefulLspErrorCodeTlv.TYPE:
                iValue = cb.readInt();
                tlv = new StatefulLspErrorCodeTlv(iValue);
                break;
            case StatefulRsvpErrorSpecTlv.TYPE:
                tlv = StatefulRsvpErrorSpecTlv.read(cb);
                break;
            case SymbolicPathNameTlv.TYPE:
                tlv = SymbolicPathNameTlv.read(cb, hLength);
                break;
            case StatefulLspDbVerTlv.TYPE:
                tlv = StatefulLspDbVerTlv.read(cb);
                break;
            default:
                throw new PcepParseException("Received unsupported TLV type :" + hType);
        }
        // Check for the padding
        int pad = hLength % 4;
        if (0 < pad) {
            pad = 4 - pad;
            if (pad <= cb.readableBytes()) {
                cb.skipBytes(pad);
            }
        }
        llOutOptionalTlv.add(tlv);
    }
    if (0 < cb.readableBytes()) {
        throw new PcepParseException("Optional Tlv parsing error. Extra bytes received.");
    }
    return llOutOptionalTlv;
}
#method_after
protected static LinkedList<PcepValueType> parseOptionalTlv(ChannelBuffer cb) throws PcepParseException {
    LinkedList<PcepValueType> llOutOptionalTlv;
    llOutOptionalTlv = new LinkedList<>();
    while (MINIMUM_COMMON_HEADER_LENGTH <= cb.readableBytes()) {
        PcepValueType tlv;
        short hType = cb.readShort();
        short hLength = cb.readShort();
        int iValue = 0;
        switch(hType) {
            case StatefulIPv4LspIdentidiersTlv.TYPE:
                tlv = StatefulIPv4LspIdentidiersTlv.read(cb);
                break;
            case StatefulLspErrorCodeTlv.TYPE:
                iValue = cb.readInt();
                tlv = new StatefulLspErrorCodeTlv(iValue);
                break;
            case StatefulRsvpErrorSpecTlv.TYPE:
                tlv = StatefulRsvpErrorSpecTlv.read(cb);
                break;
            case SymbolicPathNameTlv.TYPE:
                tlv = SymbolicPathNameTlv.read(cb, hLength);
                break;
            case StatefulLspDbVerTlv.TYPE:
                tlv = StatefulLspDbVerTlv.read(cb);
                break;
            default:
                throw new PcepParseException("Received unsupported TLV type :" + hType);
        }
        // Check for the padding
        int pad = hLength % 4;
        if (0 < pad) {
            pad = 4 - pad;
            if (pad <= cb.readableBytes()) {
                cb.skipBytes(pad);
            }
        }
        llOutOptionalTlv.add(tlv);
    }
    if (0 < cb.readableBytes()) {
        throw new PcepParseException("Optional Tlv parsing error. Extra bytes received.");
    }
    return llOutOptionalTlv;
}
#end_block

#method_before
public static PcepRPObject read(ChannelBuffer cb) throws PcepParseException {
    log.debug("read");
    PcepObjectHeader rpObjHeader;
    int iRequestIdNum;
    boolean bOFlag;
    boolean bBFlag;
    boolean bRFlag;
    // 3bytes
    byte yPriFlag;
    LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
    rpObjHeader = PcepObjectHeader.read(cb);
    // take only LspObject buffer.
    ChannelBuffer tempCb = cb.readBytes(rpObjHeader.getObjLen() - OBJECT_HEADER_LENGTH);
    int iTemp = tempCb.readInt();
    yPriFlag = (byte) (iTemp & PRIFLAG_TEMP_SHIFT_VALUE);
    bOFlag = (iTemp & OFLAG_TEMP_SHIFT_VALUE) == OFLAG_TEMP_SHIFT_VALUE;
    bBFlag = (iTemp & BFLAG_TEMP_SHIFT_VALUE) == BFLAG_TEMP_SHIFT_VALUE;
    bRFlag = (iTemp & RFLAG_TEMP_SHIFT_VALUE) == RFLAG_TEMP_SHIFT_VALUE;
    iRequestIdNum = tempCb.readInt();
    // parse optional TLV
    llOptionalTlv = parseOptionalTlv(tempCb);
    return new PcepRPObjectVer1(rpObjHeader, iRequestIdNum, bOFlag, bBFlag, bRFlag, yPriFlag, llOptionalTlv);
}
#method_after
public static PcepRPObject read(ChannelBuffer cb) throws PcepParseException {
    log.debug("read");
    PcepObjectHeader rpObjHeader;
    int iRequestIdNum;
    boolean bOFlag;
    boolean bBFlag;
    boolean bRFlag;
    // 3bytes
    byte yPriFlag;
    LinkedList<PcepValueType> llOptionalTlv = new LinkedList<>();
    rpObjHeader = PcepObjectHeader.read(cb);
    // take only LspObject buffer.
    ChannelBuffer tempCb = cb.readBytes(rpObjHeader.getObjLen() - OBJECT_HEADER_LENGTH);
    int iTemp = tempCb.readInt();
    yPriFlag = (byte) (iTemp & PRIFLAG_TEMP_SHIFT_VALUE);
    bOFlag = (iTemp & OFLAG_TEMP_SHIFT_VALUE) == OFLAG_TEMP_SHIFT_VALUE;
    bBFlag = (iTemp & BFLAG_TEMP_SHIFT_VALUE) == BFLAG_TEMP_SHIFT_VALUE;
    bRFlag = (iTemp & RFLAG_TEMP_SHIFT_VALUE) == RFLAG_TEMP_SHIFT_VALUE;
    iRequestIdNum = tempCb.readInt();
    // parse optional TLV
    llOptionalTlv = parseOptionalTlv(tempCb);
    return new PcepRPObjectVer1(rpObjHeader, iRequestIdNum, bOFlag, bBFlag, bRFlag, yPriFlag, llOptionalTlv);
}
#end_block

#method_before
protected static LinkedList<PcepValueType> parseOptionalTlv(ChannelBuffer cb) throws PcepParseException {
    LinkedList<PcepValueType> llOutOptionalTlv = new LinkedList<PcepValueType>();
    // Currently no optional TLvs, will be added based on requirements.
    return llOutOptionalTlv;
}
#method_after
protected static LinkedList<PcepValueType> parseOptionalTlv(ChannelBuffer cb) throws PcepParseException {
    LinkedList<PcepValueType> llOutOptionalTlv = new LinkedList<>();
    // Currently no optional TLvs, will be added based on requirements.
    return llOutOptionalTlv;
}
#end_block

#method_before
protected static LinkedList<PcepValueType> parseOptionalTlv(ChannelBuffer cb) throws PcepParseException {
    LinkedList<PcepValueType> llOutOptionalTlv;
    llOutOptionalTlv = new LinkedList<PcepValueType>();
    while (MINIMUM_TLV_HEADER_LENGTH <= cb.readableBytes()) {
        PcepValueType tlv;
        short hType = cb.readShort();
        short hLength = cb.readShort();
        long lValue = 0;
        switch(hType) {
            case RoutingUniverseTlv.TYPE:
                lValue = cb.readLong();
                tlv = new RoutingUniverseTlv(lValue);
                break;
            case LocalTENodeDescriptorsTlv.TYPE:
                tlv = LocalTENodeDescriptorsTlv.read(cb, hLength);
                break;
            case RemoteTENodeDescriptorsTlv.TYPE:
                tlv = RemoteTENodeDescriptorsTlv.read(cb, hLength);
                break;
            case TELinkDescriptorsTlv.TYPE:
                tlv = TELinkDescriptorsTlv.read(cb, hLength);
                break;
            case TENodeAttributesTlv.TYPE:
                tlv = TENodeAttributesTlv.read(cb, hLength);
                break;
            case TELinkAttributesTlv.TYPE:
                tlv = TELinkAttributesTlv.read(cb, hLength);
                break;
            default:
                throw new PcepParseException("Unsupported TLV type :" + hType);
        }
        // Check for the padding
        int pad = hLength % 4;
        if (0 < pad) {
            pad = 4 - pad;
            if (pad <= cb.readableBytes()) {
                cb.skipBytes(pad);
            }
        }
        llOutOptionalTlv.add(tlv);
    }
    if (0 < cb.readableBytes()) {
        throw new PcepParseException("Optional Tlv parsing error. Extra bytes received.");
    }
    return llOutOptionalTlv;
}
#method_after
protected static LinkedList<PcepValueType> parseOptionalTlv(ChannelBuffer cb) throws PcepParseException {
    LinkedList<PcepValueType> llOutOptionalTlv;
    llOutOptionalTlv = new LinkedList<>();
    while (MINIMUM_TLV_HEADER_LENGTH <= cb.readableBytes()) {
        PcepValueType tlv;
        short hType = cb.readShort();
        short hLength = cb.readShort();
        long lValue = 0;
        switch(hType) {
            case RoutingUniverseTlv.TYPE:
                lValue = cb.readLong();
                tlv = new RoutingUniverseTlv(lValue);
                break;
            case LocalTENodeDescriptorsTlv.TYPE:
                tlv = LocalTENodeDescriptorsTlv.read(cb, hLength);
                break;
            case RemoteTENodeDescriptorsTlv.TYPE:
                tlv = RemoteTENodeDescriptorsTlv.read(cb, hLength);
                break;
            case TELinkDescriptorsTlv.TYPE:
                tlv = TELinkDescriptorsTlv.read(cb, hLength);
                break;
            case TENodeAttributesTlv.TYPE:
                tlv = TENodeAttributesTlv.read(cb, hLength);
                break;
            case TELinkAttributesTlv.TYPE:
                tlv = TELinkAttributesTlv.read(cb, hLength);
                break;
            default:
                throw new PcepParseException("Unsupported TLV type :" + hType);
        }
        // Check for the padding
        int pad = hLength % 4;
        if (0 < pad) {
            pad = 4 - pad;
            if (pad <= cb.readableBytes()) {
                cb.skipBytes(pad);
            }
        }
        llOutOptionalTlv.add(tlv);
    }
    if (0 < cb.readableBytes()) {
        throw new PcepParseException("Optional Tlv parsing error. Extra bytes received.");
    }
    return llOutOptionalTlv;
}
#end_block

#method_before
public static PcepInterLayerObject read(ChannelBuffer cb) throws PcepParseException {
    PcepObjectHeader interLayerObjHeader;
    boolean bNFlag;
    boolean bIFlag;
    interLayerObjHeader = PcepObjectHeader.read(cb);
    // take only InterLayerObject buffer.
    ChannelBuffer tempCb = cb.readBytes(interLayerObjHeader.getObjLen() - OBJECT_HEADER_LENGTH);
    int iTemp = tempCb.readInt();
    bIFlag = ((iTemp & (byte) IFLAG_SHIFT_VALUE) == FLAGS_SET_VALUE);
    // suspicious: the condition is always false
    bNFlag = ((iTemp & (byte) NFLAG_SHIFT_VALUE) == FLAGS_SET_VALUE);
    return new PcepInterLayerObjectVer1(interLayerObjHeader, bNFlag, bIFlag);
}
#method_after
public static PcepInterLayerObject read(ChannelBuffer cb) throws PcepParseException {
    PcepObjectHeader interLayerObjHeader;
    boolean bNFlag;
    boolean bIFlag;
    interLayerObjHeader = PcepObjectHeader.read(cb);
    // take only InterLayerObject buffer.
    ChannelBuffer tempCb = cb.readBytes(interLayerObjHeader.getObjLen() - OBJECT_HEADER_LENGTH);
    int iTemp = tempCb.readInt();
    bIFlag = ((iTemp & (byte) IFLAG_SHIFT_VALUE) == IFLAG_SHIFT_VALUE);
    bNFlag = ((iTemp & (byte) NFLAG_SHIFT_VALUE) == NFLAG_SHIFT_VALUE);
    return new PcepInterLayerObjectVer1(interLayerObjHeader, bNFlag, bIFlag);
}
#end_block

#method_before
public PcepErrorMsg getErrorMsg(byte errorType, byte errorValue) throws PcepParseException {
    LinkedList<PcepErrorObject> llerrObj = new LinkedList<PcepErrorObject>();
    PcepErrorMsg errMsg;
    PcepErrorObject errObj = factory1.buildPcepErrorObject().setErrorValue(errorValue).setErrorType(errorType).build();
    llerrObj.add(errObj);
    if (state == ChannelState.OPENWAIT) {
        // If Error caught in Openmessage
        PcepOpenObject openObj = null;
        ErrorObjListWithOpen errorObjListWithOpen = null;
        if (0 != sessionId) {
            openObj = factory1.buildOpenObject().setSessionId(sessionId).build();
            errorObjListWithOpen = new ErrorObjListWithOpen(llerrObj, openObj);
        } else {
            errorObjListWithOpen = new ErrorObjListWithOpen(llerrObj, null);
        }
        errMsg = factory1.buildPcepErrorMsg().setErrorObjListWithOpen(errorObjListWithOpen).build();
    } else {
        // If Error caught in other than Openmessage
        LinkedList<PcepError> llPcepErr = new LinkedList<PcepError>();
        PcepError pcepErr = factory1.buildPcepError().setErrorObjList(llerrObj).build();
        llPcepErr.add(pcepErr);
        PcepErrorInfo errInfo = factory1.buildPcepErrorInfo().setPcepErrorList(llPcepErr).build();
        errMsg = factory1.buildPcepErrorMsg().setPcepErrorInfo(errInfo).build();
    }
    return errMsg;
}
#method_after
public PcepErrorMsg getErrorMsg(byte errorType, byte errorValue) throws PcepParseException {
    LinkedList<PcepErrorObject> llerrObj = new LinkedList<>();
    PcepErrorMsg errMsg;
    PcepErrorObject errObj = factory1.buildPcepErrorObject().setErrorValue(errorValue).setErrorType(errorType).build();
    llerrObj.add(errObj);
    if (state == ChannelState.OPENWAIT) {
        // If Error caught in Openmessage
        PcepOpenObject openObj = null;
        ErrorObjListWithOpen errorObjListWithOpen = null;
        if (0 != sessionId) {
            openObj = factory1.buildOpenObject().setSessionId(sessionId).build();
            errorObjListWithOpen = new ErrorObjListWithOpen(llerrObj, openObj);
        } else {
            errorObjListWithOpen = new ErrorObjListWithOpen(llerrObj, null);
        }
        errMsg = factory1.buildPcepErrorMsg().setErrorObjListWithOpen(errorObjListWithOpen).build();
    } else {
        // If Error caught in other than Openmessage
        LinkedList<PcepError> llPcepErr = new LinkedList<>();
        PcepError pcepErr = factory1.buildPcepError().setErrorObjList(llerrObj).build();
        llPcepErr.add(pcepErr);
        PcepErrorInfo errInfo = factory1.buildPcepErrorInfo().setPcepErrorList(llPcepErr).build();
        errMsg = factory1.buildPcepErrorMsg().setPcepErrorInfo(errInfo).build();
    }
    return errMsg;
}
#end_block

#method_before
public static PcepLabelObject read(ChannelBuffer cb) throws PcepParseException {
    PcepObjectHeader labelObjHeader;
    boolean bOFlag;
    int label;
    // Optional TLV
    LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
    labelObjHeader = PcepObjectHeader.read(cb);
    // take only LspObject buffer.
    ChannelBuffer tempCb = cb.readBytes(labelObjHeader.getObjLen() - OBJECT_HEADER_LENGTH);
    int iTemp = tempCb.readInt();
    bOFlag = (iTemp & (byte) 0x01) == 1;
    label = tempCb.readInt();
    // parse optional TLV
    llOptionalTlv = parseOptionalTlv(tempCb);
    return new PcepLabelObjectVer1(labelObjHeader, bOFlag, label, llOptionalTlv);
}
#method_after
public static PcepLabelObject read(ChannelBuffer cb) throws PcepParseException {
    PcepObjectHeader labelObjHeader;
    boolean bOFlag;
    int label;
    // Optional TLV
    LinkedList<PcepValueType> llOptionalTlv = new LinkedList<>();
    labelObjHeader = PcepObjectHeader.read(cb);
    // take only LspObject buffer.
    ChannelBuffer tempCb = cb.readBytes(labelObjHeader.getObjLen() - OBJECT_HEADER_LENGTH);
    int iTemp = tempCb.readInt();
    bOFlag = (iTemp & (byte) 0x01) == 1;
    label = tempCb.readInt();
    // parse optional TLV
    llOptionalTlv = parseOptionalTlv(tempCb);
    return new PcepLabelObjectVer1(labelObjHeader, bOFlag, label, llOptionalTlv);
}
#end_block

#method_before
protected static LinkedList<PcepValueType> parseOptionalTlv(ChannelBuffer cb) throws PcepParseException {
    LinkedList<PcepValueType> llOutOptionalTlv = new LinkedList<PcepValueType>();
    while (MINIMUM_COMMON_HEADER_LENGTH <= cb.readableBytes()) {
        PcepValueType tlv;
        short hType = cb.readShort();
        short hLength = cb.readShort();
        int iValue = 0;
        switch(hType) {
            case NexthopIPv4addressTlv.TYPE:
                iValue = cb.readInt();
                tlv = new NexthopIPv4addressTlv(iValue);
                break;
            case NexthopIPv6addressTlv.TYPE:
                byte[] ipv6Value = new byte[NexthopIPv6addressTlv.VALUE_LENGTH];
                cb.readBytes(ipv6Value, 0, NexthopIPv6addressTlv.VALUE_LENGTH);
                tlv = new NexthopIPv6addressTlv(ipv6Value);
                break;
            case NexthopUnnumberedIPv4IDTlv.TYPE:
                tlv = NexthopUnnumberedIPv4IDTlv.read(cb);
                break;
            default:
                throw new PcepParseException("Unsupported TLV type :" + hType);
        }
        // Check for the padding
        int pad = hLength % 4;
        if (0 < pad) {
            pad = 4 - pad;
            if (pad <= cb.readableBytes()) {
                cb.skipBytes(pad);
            }
        }
        llOutOptionalTlv.add(tlv);
    }
    if (0 < cb.readableBytes()) {
        throw new PcepParseException("Optional Tlv parsing error. Extra bytes received.");
    }
    return llOutOptionalTlv;
}
#method_after
protected static LinkedList<PcepValueType> parseOptionalTlv(ChannelBuffer cb) throws PcepParseException {
    LinkedList<PcepValueType> llOutOptionalTlv = new LinkedList<>();
    while (MINIMUM_COMMON_HEADER_LENGTH <= cb.readableBytes()) {
        PcepValueType tlv;
        short hType = cb.readShort();
        short hLength = cb.readShort();
        int iValue = 0;
        switch(hType) {
            case NexthopIPv4addressTlv.TYPE:
                iValue = cb.readInt();
                tlv = new NexthopIPv4addressTlv(iValue);
                break;
            case NexthopIPv6addressTlv.TYPE:
                byte[] ipv6Value = new byte[NexthopIPv6addressTlv.VALUE_LENGTH];
                cb.readBytes(ipv6Value, 0, NexthopIPv6addressTlv.VALUE_LENGTH);
                tlv = new NexthopIPv6addressTlv(ipv6Value);
                break;
            case NexthopUnnumberedIPv4IDTlv.TYPE:
                tlv = NexthopUnnumberedIPv4IDTlv.read(cb);
                break;
            default:
                throw new PcepParseException("Unsupported TLV type :" + hType);
        }
        // Check for the padding
        int pad = hLength % 4;
        if (0 < pad) {
            pad = 4 - pad;
            if (pad <= cb.readableBytes()) {
                cb.skipBytes(pad);
            }
        }
        llOutOptionalTlv.add(tlv);
    }
    if (0 < cb.readableBytes()) {
        throw new PcepParseException("Optional Tlv parsing error. Extra bytes received.");
    }
    return llOutOptionalTlv;
}
#end_block

#method_before
@Override
public LinkedList<Integer> getErrorType() {
    LinkedList<Integer> errorType = new LinkedList<Integer>();
    ListIterator<PcepError> listIterator = errList.listIterator();
    PcepErrorObject errObj;
    int error;
    while (listIterator.hasNext()) {
        PcepError pcepError = listIterator.next();
        LinkedList<PcepErrorObject> llErrObjList = pcepError.getErrorObjList();
        if (llErrObjList != null) {
            ListIterator<PcepErrorObject> errObjListIterator = llErrObjList.listIterator();
            while (errObjListIterator.hasNext()) {
                errObj = errObjListIterator.next();
                error = errObj.getErrorType();
                errorType.add(error);
            }
        }
    }
    return errorType;
}
#method_after
@Override
public LinkedList<Integer> getErrorType() {
    LinkedList<Integer> errorType = new LinkedList<>();
    ListIterator<PcepError> listIterator = errList.listIterator();
    PcepErrorObject errObj;
    int error;
    while (listIterator.hasNext()) {
        PcepError pcepError = listIterator.next();
        LinkedList<PcepErrorObject> llErrObjList = pcepError.getErrorObjList();
        if (llErrObjList != null) {
            ListIterator<PcepErrorObject> errObjListIterator = llErrObjList.listIterator();
            while (errObjListIterator.hasNext()) {
                errObj = errObjListIterator.next();
                error = errObj.getErrorType();
                errorType.add(error);
            }
        }
    }
    return errorType;
}
#end_block

#method_before
@Override
public LinkedList<Integer> getErrorValue() {
    LinkedList<Integer> errorValue = new LinkedList<Integer>();
    ListIterator<PcepError> listIterator = errList.listIterator();
    PcepErrorObject errObj;
    int error;
    while (listIterator.hasNext()) {
        PcepError pcepError = listIterator.next();
        LinkedList<PcepErrorObject> llErrObjList = pcepError.getErrorObjList();
        if (llErrObjList != null) {
            ListIterator<PcepErrorObject> errObjListIterator = llErrObjList.listIterator();
            while (errObjListIterator.hasNext()) {
                errObj = errObjListIterator.next();
                error = errObj.getErrorValue();
                errorValue.add(error);
            }
        }
    }
    return errorValue;
}
#method_after
@Override
public LinkedList<Integer> getErrorValue() {
    LinkedList<Integer> errorValue = new LinkedList<>();
    ListIterator<PcepError> listIterator = errList.listIterator();
    PcepErrorObject errObj;
    int error;
    while (listIterator.hasNext()) {
        PcepError pcepError = listIterator.next();
        LinkedList<PcepErrorObject> llErrObjList = pcepError.getErrorObjList();
        if (llErrObjList != null) {
            ListIterator<PcepErrorObject> errObjListIterator = llErrObjList.listIterator();
            while (errObjListIterator.hasNext()) {
                errObj = errObjListIterator.next();
                error = errObj.getErrorValue();
                errorValue.add(error);
            }
        }
    }
    return errorValue;
}
#end_block

#method_before
public LinkedList<Integer> getErrorType() {
    LinkedList<Integer> errorType = new LinkedList<Integer>();
    if (llerrorObjList != null) {
        ListIterator<PcepErrorObject> errObjListIterator = llerrorObjList.listIterator();
        int error;
        PcepErrorObject errorObj;
        while (errObjListIterator.hasNext()) {
            errorObj = errObjListIterator.next();
            error = errorObj.getErrorType();
            errorType.add(error);
        }
    }
    return errorType;
}
#method_after
public LinkedList<Integer> getErrorType() {
    LinkedList<Integer> errorType = new LinkedList<>();
    if (llerrorObjList != null) {
        ListIterator<PcepErrorObject> errObjListIterator = llerrorObjList.listIterator();
        int error;
        PcepErrorObject errorObj;
        while (errObjListIterator.hasNext()) {
            errorObj = errObjListIterator.next();
            error = errorObj.getErrorType();
            errorType.add(error);
        }
    }
    return errorType;
}
#end_block

#method_before
public LinkedList<Integer> getErrorValue() {
    LinkedList<Integer> errorValue = new LinkedList<Integer>();
    if (llerrorObjList != null) {
        ListIterator<PcepErrorObject> errObjListIterator = llerrorObjList.listIterator();
        int error;
        PcepErrorObject errorObj;
        while (errObjListIterator.hasNext()) {
            errorObj = errObjListIterator.next();
            error = errorObj.getErrorValue();
            errorValue.add(error);
        }
    }
    return errorValue;
}
#method_after
public LinkedList<Integer> getErrorValue() {
    LinkedList<Integer> errorValue = new LinkedList<>();
    if (llerrorObjList != null) {
        ListIterator<PcepErrorObject> errObjListIterator = llerrorObjList.listIterator();
        int error;
        PcepErrorObject errorObj;
        while (errObjListIterator.hasNext()) {
            errorObj = errObjListIterator.next();
            error = errorObj.getErrorValue();
            errorValue.add(error);
        }
    }
    return errorValue;
}
#end_block

#method_before
@Override
public void deviceConnected(DeviceId deviceId, DeviceDescription deviceDescription) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(deviceDescription, DEVICE_DESCRIPTION_NULL);
    checkValidity();
    BasicDeviceConfig cfg = networkConfigService.getConfig(deviceId, BasicDeviceConfig.class);
    if (!isAllowed(cfg)) {
        log.warn("Device {} is not allowed", deviceId);
        return;
    }
    // Generate updated description and establish my Role
    deviceDescription = BasicDeviceOperator.combine(cfg, deviceDescription);
    Futures.getUnchecked(mastershipService.requestRoleFor(deviceId).thenAccept(role -> {
        log.info("Local role is {} for {}", role, deviceId);
        applyRole(deviceId, role);
    }));
    DeviceEvent event = store.createOrUpdateDevice(provider().id(), deviceId, deviceDescription);
    if (event != null) {
        log.trace("event: {} {}", event.type(), event);
        post(event);
    }
}
#method_after
@Override
public void deviceConnected(DeviceId deviceId, DeviceDescription deviceDescription) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(deviceDescription, DEVICE_DESCRIPTION_NULL);
    checkValidity();
    BasicDeviceConfig cfg = networkConfigService.getConfig(deviceId, BasicDeviceConfig.class);
    if (!isAllowed(cfg)) {
        log.warn("Device {} is not allowed", deviceId);
        return;
    }
    // Generate updated description and establish my Role
    deviceDescription = BasicDeviceOperator.combine(cfg, deviceDescription);
    Futures.getUnchecked(mastershipService.requestRoleFor(deviceId).thenAccept(role -> {
        log.info("Local role is {} for {}", role, deviceId);
        applyRole(deviceId, role);
    }));
    DeviceEvent event = store.createOrUpdateDevice(provider().id(), deviceId, deviceDescription);
    log.info("Device {} connected", deviceId);
    if (event != null) {
        log.trace("event: {} {}", event.type(), event);
        post(event);
    }
}
#end_block

#method_before
private ImmutableSet<Permission> getPermissions(XMLConfiguration cfg) {
    List<Permission> permissionList = new ArrayList();
    for (Object o : cfg.getList(APP_PERMISSIONS)) {
        String name = (String) o;
        try {
            AppPermission appPerm = new AppPermission(AppPermission.Type.valueOf(name));
            permissionList.add(appPerm);
        } catch (IllegalArgumentException e) {
            log.debug("Unknown permission specified: %s", name);
        }
    }
    for (Object o : cfg.getList(NET_PERMISSIONS)) {
        // TODO: TO BE FLESHED OUT WHEN NETWORK PERMISSIONS ARE SUPPORTED
        System.out.print("");
    }
    List<HierarchicalConfiguration> fields = cfg.configurationsAt(JAVA_PERMISSIONS);
    for (HierarchicalConfiguration sub : fields) {
        String classname = sub.getString("classname");
        String name = sub.getString("name");
        String actions = sub.getString("actions");
        if (classname != null && name != null && actions != null) {
            classname = classname.trim();
            name = name.trim();
            actions = actions.trim();
            if (FilePermission.class.getName().equals(classname)) {
                permissionList.add(new FilePermission(name, actions));
            } else if (SerializablePermission.class.getName().equals(classname)) {
                permissionList.add(new SerializablePermission(name, actions));
            } else if (NetPermission.class.getName().equals(classname)) {
                permissionList.add(new NetPermission(name, actions));
            } else if (RuntimePermission.class.getName().equals(classname)) {
                permissionList.add(new RuntimePermission(name, actions));
            } else if (SocketPermission.class.getName().equals(classname)) {
                permissionList.add(new SocketPermission(name, actions));
            } else if (SQLPermission.class.getName().equals(classname)) {
                permissionList.add(new SQLPermission(name, actions));
            } else if (PropertyPermission.class.getName().equals(classname)) {
                permissionList.add(new PropertyPermission(name, actions));
            } else if (LoggingPermission.class.getName().equals(classname)) {
                permissionList.add(new LoggingPermission(name, actions));
            } else if (SSLPermission.class.getName().equals(classname)) {
                permissionList.add(new SSLPermission(name, actions));
            } else if (AuthPermission.class.getName().equals(classname)) {
                permissionList.add(new AuthPermission(name, actions));
            } else if (PrivateCredentialPermission.class.getName().equals(classname)) {
                permissionList.add(new PrivateCredentialPermission(name, actions));
            } else if (DelegationPermission.class.getName().equals(classname)) {
                permissionList.add(new DelegationPermission(name, actions));
            } else if (javax.security.auth.kerberos.ServicePermission.class.getName().equals(classname)) {
                permissionList.add(new javax.security.auth.kerberos.ServicePermission(name, actions));
            } else if (AudioPermission.class.getName().equals(classname)) {
                permissionList.add(new AudioPermission(name, actions));
            } else if (AdaptPermission.class.getName().equals(classname)) {
                permissionList.add(new AdaptPermission(name, actions));
            } else if (BundlePermission.class.getName().equals(classname)) {
                permissionList.add(new BundlePermission(name, actions));
            } else if (CapabilityPermission.class.getName().equals(classname)) {
                permissionList.add(new CapabilityPermission(name, actions));
            } else if (PackagePermission.class.getName().equals(classname)) {
                permissionList.add(new PackagePermission(name, actions));
            } else if (ServicePermission.class.getName().equals(classname)) {
                permissionList.add(new ServicePermission(name, actions));
            } else {
                // AllPermission, SecurityPermission, UnresolvedPermission
                // AWTPermission, AdminPermission(osgi), ReflectPermission not allowed
                log.warn("%s does not exist or not allowed.", classname);
            }
        }
    }
    return ImmutableSet.copyOf(permissionList);
}
#method_after
private ImmutableSet<Permission> getPermissions(XMLConfiguration cfg) {
    List<Permission> permissionList = new ArrayList();
    for (Object o : cfg.getList(APP_PERMISSIONS)) {
        String name = (String) o;
        permissionList.add(new Permission(AppPermission.class.getName(), name));
    }
    for (Object o : cfg.getList(NET_PERMISSIONS)) {
        // TODO: TO BE FLESHED OUT WHEN NETWORK PERMISSIONS ARE SUPPORTED
        break;
    }
    List<HierarchicalConfiguration> fields = cfg.configurationsAt(JAVA_PERMISSIONS);
    for (HierarchicalConfiguration sub : fields) {
        String classname = sub.getString("classname");
        String name = sub.getString("name");
        String actions = sub.getString("actions");
        if (classname != null && name != null) {
            permissionList.add(new Permission(classname, name, actions));
        }
    }
    return ImmutableSet.copyOf(permissionList);
}
#end_block

#method_before
public static boolean isSecurityModeEnabled() {
    if (System.getSecurityManager() != null) {
        SecurityAdminService securityService = serviceDirectory.get(SecurityAdminService.class);
        if (securityService != null) {
            return true;
        }
    }
    return false;
}
#method_after
public static boolean isSecurityModeEnabled() {
    if (System.getSecurityManager() != null) {
        try {
            SecurityAdminService securityService = serviceDirectory.get(SecurityAdminService.class);
            if (securityService != null) {
                return true;
            }
        } catch (ServiceNotFoundException e) {
            return false;
        }
    }
    return false;
}
#end_block

#method_before
public static SecurityAdminService getSecurityService() {
    if (isSecurityModeEnabled()) {
        return serviceDirectory.get(SecurityAdminService.class);
    }
    return null;
}
#method_after
public static SecurityAdminService getSecurityService() {
    if (System.getSecurityManager() != null) {
        try {
            SecurityAdminService securityService = serviceDirectory.get(SecurityAdminService.class);
            if (securityService != null) {
                return securityService;
            }
        } catch (ServiceNotFoundException e) {
            return null;
        }
    }
    return null;
}
#end_block

#method_before
@Test
public void permissions() {
    Application app = createTestApp();
    ImmutableSet<Permission> permissions = ImmutableSet.of(new AppPermission(FLOWRULE_WRITE));
    store.setPermissions(app.id(), permissions);
    assertEquals("incorrect app perms", 1, store.getPermissions(app.id()).size());
    assertEquals("incorrect app state", INSTALLED, store.getState(app.id()));
    assertEquals("incorrect event type", APP_PERMISSIONS_CHANGED, delegate.event.type());
    assertEquals("incorrect event app", app, delegate.event.subject());
}
#method_after
@Test
public void permissions() {
    Application app = createTestApp();
    ImmutableSet<Permission> permissions = ImmutableSet.of(new Permission(AppPermission.class.getName(), "FLOWRULE_WRITE"));
    store.setPermissions(app.id(), permissions);
    assertEquals("incorrect app perms", 1, store.getPermissions(app.id()).size());
    assertEquals("incorrect app state", INSTALLED, store.getState(app.id()));
    assertEquals("incorrect event type", APP_PERMISSIONS_CHANGED, delegate.event.type());
    assertEquals("incorrect event app", app, delegate.event.subject());
}
#end_block

#method_before
@Activate
public void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API);
    store = storageService.<ApplicationId, SecurityInfo>consistentMapBuilder().withName("smonos-sdata").withSerializer(SERIALIZER).build();
    store.addListener(new SecurityStateListener());
    requestedPermissions = storageService.<ApplicationId, List<Permission>>eventuallyConsistentMapBuilder().withName("smonos-rperms").withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    localBundleAppDirectory = new ConcurrentHashMap<>();
    localAppBundleDirectory = new ConcurrentHashMap<>();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    states = storageService.<ApplicationId, SecurityInfo>consistentMapBuilder().withName("smonos-sdata").withSerializer(STATE_SERIALIZER).build();
    states.addListener(new SecurityStateListener());
    violations = storageService.<ApplicationId, Set<Permission>>eventuallyConsistentMapBuilder().withName("smonos-rperms").withSerializer(VIOLATION_SERIALIZER).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    localBundleAppDirectory = new ConcurrentHashMap<>();
    localAppBundleDirectory = new ConcurrentHashMap<>();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    requestedPermissions.destroy();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    violations.destroy();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public Set<String> getBundleLocations(ApplicationId appId) {
    if (localAppBundleDirectory.containsKey(appId)) {
        return localAppBundleDirectory.get(appId);
    }
    return new HashSet<>();
}
#method_after
@Override
public Set<String> getBundleLocations(ApplicationId appId) {
    Set<String> locations = localAppBundleDirectory.get(appId);
    return locations != null ? locations : Sets.newHashSet();
}
#end_block

#method_before
@Override
public Set<ApplicationId> getApplicationIds(String location) {
    if (localBundleAppDirectory.containsKey(location)) {
        return localBundleAppDirectory.get(location);
    }
    return new HashSet<>();
}
#method_after
@Override
public Set<ApplicationId> getApplicationIds(String location) {
    Set<ApplicationId> appIds = localBundleAppDirectory.get(location);
    return appIds != null ? appIds : Sets.newHashSet();
}
#end_block

#method_before
@Override
public List<Permission> getRequestedPermissions(ApplicationId appId) {
    if (requestedPermissions.containsKey(appId)) {
        return requestedPermissions.get(appId);
    }
    return new ArrayList<>();
}
#method_after
@Override
public Set<Permission> getRequestedPermissions(ApplicationId appId) {
    Set<Permission> permissions = violations.get(appId);
    return permissions != null ? permissions : ImmutableSet.of();
}
#end_block

#method_before
@Override
public PermissionInfo[] getGrantedPermissions(ApplicationId appId) {
    if (store.containsKey(appId)) {
        return store.get(appId).value().getPermissions();
    }
    return new PermissionInfo[0];
}
#method_after
@Override
public Set<Permission> getGrantedPermissions(ApplicationId appId) {
    return states.asJavaMap().getOrDefault(appId, new SecurityInfo(ImmutableSet.of(), null)).getPermissions();
}
#end_block

#method_before
@Override
public void requestPermission(ApplicationId appId, Permission permission) {
    List<Permission> perms = new ArrayList<>();
    if (requestedPermissions.containsKey(appId)) {
        perms.addAll(requestedPermissions.get(appId));
    } else {
        perms.add(permission);
    }
    requestedPermissions.put(appId, optimizePermissions(perms));
    if (getState(appId) == REVIEWED) {
        if (store.containsKey(appId)) {
            PermissionInfo[] oldList = store.get(appId).value().getPermissions();
            store.put(appId, new SecurityInfo(oldList, REVIEW_PENDING));
        } else {
            store.put(appId, new SecurityInfo(new PermissionInfo[0], REVIEW_PENDING));
        }
    }
}
#method_after
@Override
public void requestPermission(ApplicationId appId, Permission permission) {
    states.computeIf(appId, securityInfo -> (securityInfo == null || securityInfo.getState() != POLICY_VIOLATED), (id, securityInfo) -> new SecurityInfo(securityInfo.getPermissions(), POLICY_VIOLATED));
    violations.compute(appId, (k, v) -> v == null ? Sets.newHashSet(permission) : addAndGet(v, permission));
}
#end_block

#method_before
@Override
public void acceptPolicy(ApplicationId appId, PermissionInfo[] permissionSet) {
    Application app = applicationAdminService.getApplication(appId);
    if (app == null) {
        log.warn("Unknown Application");
        return;
    }
    if (store.get(appId).value().getState().equals(REVIEWED)) {
        System.out.println("Application has already been reviewed");
        return;
    }
    store.put(appId, new SecurityInfo(permissionSet, REVIEWED));
}
#method_after
@Override
public void acceptPolicy(ApplicationId appId, Set<Permission> permissionSet) {
    Application app = applicationAdminService.getApplication(appId);
    if (app == null) {
        log.warn("Unknown Application");
        return;
    }
    states.computeIf(appId, securityInfo -> (securityInfo != null), (id, securityInfo) -> {
        switch(securityInfo.getState()) {
            case POLICY_VIOLATED:
                System.out.println("This application has violated the security policy. Please uninstall.");
                return securityInfo;
            case SECURED:
                System.out.println("The policy has been accepted already. To review policy, review [app.name]");
                return securityInfo;
            case INSTALLED:
                System.out.println("Please review the security policy prior to accept them");
                log.warn("Application has not been reviewed");
                return securityInfo;
            case REVIEWED:
                return new SecurityInfo(permissionSet, SECURED);
            default:
                return securityInfo;
        }
    });
}
#end_block

#method_before
@Override
public void event(MapEvent<ApplicationId, SecurityInfo> event) {
    if (delegate == null) {
        return;
    }
    ApplicationId appId = event.key();
    SecurityInfo info = event.value().value();
    if (event.type() == MapEvent.Type.INSERT || event.type() == MapEvent.Type.UPDATE) {
        switch(info.getState()) {
            case REVIEW_PENDING:
                notifyDelegate(new SecurityModeEvent(SecurityModeEvent.Type.POLICY_VIOLATED, appId));
                break;
            case REVIEWED:
                notifyDelegate(new SecurityModeEvent(SecurityModeEvent.Type.POLICY_REVIEWED, appId));
                break;
            default:
                break;
        }
    } else if (event.type() == MapEvent.Type.REMOVE) {
        removeAppFromDirectories(appId);
    }
}
#method_after
@Override
public void event(MapEvent<ApplicationId, SecurityInfo> event) {
    if (delegate == null) {
        return;
    }
    ApplicationId appId = event.key();
    SecurityInfo info = event.value().value();
    if (event.type() == MapEvent.Type.INSERT || event.type() == MapEvent.Type.UPDATE) {
        switch(info.getState()) {
            case POLICY_VIOLATED:
                notifyDelegate(new SecurityModeEvent(SecurityModeEvent.Type.POLICY_VIOLATED, appId));
                break;
            case SECURED:
                notifyDelegate(new SecurityModeEvent(SecurityModeEvent.Type.POLICY_ACCEPTED, appId));
            default:
                break;
        }
    } else if (event.type() == MapEvent.Type.REMOVE) {
        removeAppFromDirectories(appId);
    }
}
#end_block

#method_before
private void removeAppFromDirectories(ApplicationId appId) {
    for (String location : localAppBundleDirectory.get(appId)) {
        localBundleAppDirectory.get(location).remove(appId);
    }
    requestedPermissions.remove(appId);
    store.remove(appId);
    localAppBundleDirectory.remove(appId);
}
#method_after
private void removeAppFromDirectories(ApplicationId appId) {
    for (String location : localAppBundleDirectory.get(appId)) {
        localBundleAppDirectory.get(location).remove(appId);
    }
    violations.remove(appId);
    states.remove(appId);
    localAppBundleDirectory.remove(appId);
}
#end_block

#method_before
@Override
public boolean registerApplication(ApplicationId appId) {
    Application app = applicationAdminService.getApplication(appId);
    if (app == null) {
        log.warn("Unknown application.");
        return false;
    }
    localAppBundleDirectory.put(appId, getBundleLocations(app));
    for (String location : localAppBundleDirectory.get(appId)) {
        if (!localBundleAppDirectory.containsKey(location)) {
            localBundleAppDirectory.put(location, new HashSet<>());
        }
        if (!localBundleAppDirectory.get(location).contains(appId)) {
            localBundleAppDirectory.get(location).add(appId);
        }
    }
    if (!store.containsKey(appId)) {
        store.put(appId, new SecurityInfo(new PermissionInfo[0], INSTALLED));
    }
    return true;
}
#method_after
@Override
public boolean registerApplication(ApplicationId appId) {
    Application app = applicationAdminService.getApplication(appId);
    if (app == null) {
        log.warn("Unknown application.");
        return false;
    }
    localAppBundleDirectory.put(appId, getBundleLocations(app));
    for (String location : localAppBundleDirectory.get(appId)) {
        if (!localBundleAppDirectory.containsKey(location)) {
            localBundleAppDirectory.put(location, new HashSet<>());
        }
        if (!localBundleAppDirectory.get(location).contains(appId)) {
            localBundleAppDirectory.get(location).add(appId);
        }
    }
    states.put(appId, new SecurityInfo(Sets.newHashSet(), INSTALLED));
    return true;
}
#end_block

#method_before
@Override
public SecurityModeState getState(ApplicationId appId) {
    if (store.containsKey(appId)) {
        return store.get(appId).value().getState();
    }
    return null;
}
#method_after
@Override
public SecurityModeState getState(ApplicationId appId) {
    return states.asJavaMap().getOrDefault(appId, new SecurityInfo(null, null)).getState();
}
#end_block

#method_before
@Activate
public void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MultiValuedTimestamp.class).register(InternalState.class);
    executor = Executors.newSingleThreadScheduledExecutor(groupedThreads("onos/app", "store"));
    messageHandlingExecutor = Executors.newSingleThreadExecutor(groupedThreads("onos/store/app", "message-handler"));
    clusterCommunicator.addSubscriber(APP_BITS_REQUEST, new InternalBitServer(), messageHandlingExecutor);
    // FIXME: Consider consolidating into a single map.
    apps = storageService.<ApplicationId, Application>eventuallyConsistentMapBuilder().withName("apps").withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    states = storageService.<Application, InternalState>eventuallyConsistentMapBuilder().withName("app-states").withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    states.addListener(new InternalAppStatesListener());
    permissions = storageService.<Application, Set<Permission>>eventuallyConsistentMapBuilder().withName("app-permissions").withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(MultiValuedTimestamp.class).register(InternalState.class);
    executor = Executors.newSingleThreadScheduledExecutor(groupedThreads("onos/app", "store"));
    messageHandlingExecutor = Executors.newSingleThreadExecutor(groupedThreads("onos/store/app", "message-handler"));
    clusterCommunicator.<String, byte[]>addSubscriber(APP_BITS_REQUEST, bytes -> new String(bytes, Charsets.UTF_8), name -> {
        try {
            return toByteArray(getApplicationInputStream(name));
        } catch (IOException e) {
            throw new StorageException(e);
        }
    }, Function.identity(), messageHandlingExecutor);
    // FIXME: Consider consolidating into a single map.
    apps = storageService.<ApplicationId, Application>eventuallyConsistentMapBuilder().withName("apps").withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    states = storageService.<Application, InternalState>eventuallyConsistentMapBuilder().withName("app-states").withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    states.addListener(new InternalAppStatesListener());
    permissions = storageService.<Application, Set<Permission>>eventuallyConsistentMapBuilder().withName("app-permissions").withSerializer(serializer).withTimestampProvider((k, v) -> clockService.getTimestamp()).build();
    log.info("Started");
}
#end_block

#method_before
@Activate
public void activate() {
    eventDispatcher.addSink(SecurityModeEvent.class, listenerRegistry);
    // add Listeners
    appAdminService.addListener(securityApplicationListener);
    logReaderService.addLogListener(securityLogListener);
    initializing = true;
    store.setDelegate(delegate);
    initializing = false;
    if (System.getSecurityManager() == null) {
        log.warn("J2EE security manager is disabled.");
        deactivate();
        return;
    }
    if (permissionAdmin == null) {
        log.warn("Permission Admin not found.");
        deactivate();
        return;
    }
    init();
    log.info("Security-Mode Started");
}
#method_after
@Activate
public void activate() {
    eventDispatcher.addSink(SecurityModeEvent.class, listenerRegistry);
    // add Listeners
    logReaderService.addLogListener(securityLogListener);
    store.setDelegate(delegate);
    if (System.getSecurityManager() == null) {
        log.warn("J2EE security manager is disabled.");
        deactivate();
        return;
    }
    if (permissionAdmin == null) {
        log.warn("Permission Admin not found.");
        deactivate();
        return;
    }
    log.info("Security-Mode Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    eventDispatcher.removeSink(SecurityModeEvent.class);
    appAdminService.removeListener(securityApplicationListener);
    logReaderService.removeLogListener(securityLogListener);
    store.unsetDelegate(delegate);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    eventDispatcher.removeSink(SecurityModeEvent.class);
    logReaderService.removeLogListener(securityLogListener);
    store.unsetDelegate(delegate);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void review(ApplicationId appId) {
    printAppPolicy(appId);
}
#method_after
@Override
public void review(ApplicationId appId) {
    if (store.getState(appId) == null) {
        store.registerApplication(appId);
    }
    store.reviewPolicy(appId);
}
#end_block

#method_before
@Override
public void acceptPolicy(ApplicationId appId) {
    store.acceptPolicy(appId, permissionToInfos(optimizePermissions(getMaximumPermissions(appId))));
}
#method_after
@Override
public void acceptPolicy(ApplicationId appId) {
    if (store.getState(appId) == null) {
        store.registerApplication(appId);
    }
    store.acceptPolicy(appId, DefaultPolicyBuilder.convertToOnosPermissions(getMaximumPermissions(appId)));
}
#end_block

#method_before
@Override
public void logged(LogEntry entry) {
    if (entry.getException() != null && entry.getException() instanceof AccessControlException) {
        String location = entry.getBundle().getLocation();
        Permission permission = ((AccessControlException) entry.getException()).getPermission();
        for (ApplicationId appId : store.getApplicationIds(location)) {
            if (store.isReviewed(appId) && appAdminService.getState(appId) == ApplicationState.ACTIVE) {
                if (!store.getRequestedPermissions(appId).contains(permission)) {
                    store.requestPermission(appId, permission);
                    print("[POLICY VIOLATION] APP: %s / Bundle: %s / Permission: %s ", appId.name(), location, permission.toString());
                }
            }
        }
    }
}
#method_after
@Override
public void logged(LogEntry entry) {
    if (entry.getException() != null && entry.getException() instanceof AccessControlException) {
        String location = entry.getBundle().getLocation();
        Permission javaPerm = ((AccessControlException) entry.getException()).getPermission();
        org.onosproject.security.Permission permission = DefaultPolicyBuilder.getOnosPermission(javaPerm);
        if (permission == null) {
            log.warn("Unsupported permission requested.");
            return;
        }
        store.getApplicationIds(location).stream().filter(appId -> store.isSecured(appId) && appAdminService.getState(appId) == ApplicationState.ACTIVE).forEach(appId -> {
            store.requestPermission(appId, permission);
            print("[POLICY VIOLATION] APP: %s / Bundle: %s / Permission: %s ", appId.name(), location, permission.toString());
        });
    }
}
#end_block

#method_before
@Override
public void notify(SecurityModeEvent event) {
    if (event.type() == SecurityModeEvent.Type.POLICY_REVIEWED) {
        setLocalPermissions(event.subject());
        printAppPolicy(event.subject());
        print("%s is reviewed and the security policy has been enforced. You may activate the application", event.subject().name());
    } else if (event.type() == SecurityModeEvent.Type.POLICY_VIOLATED) {
        print("%s has violated security policy. Please review the application (review [app name])", event.subject().name());
    }
    eventDispatcher.post(event);
}
#method_after
@Override
public void notify(SecurityModeEvent event) {
    if (event.type() == SecurityModeEvent.Type.POLICY_ACCEPTED) {
        setLocalPermissions(event.subject());
        log.info("{} POLICY ACCEPTED and ENFORCED", event.subject().name());
    } else if (event.type() == SecurityModeEvent.Type.POLICY_VIOLATED) {
        log.info("{} POLICY VIOLATED", event.subject().name());
    } else if (event.type() == SecurityModeEvent.Type.POLICY_REVIEWED) {
        log.info("{} POLICY REVIEWED", event.subject().name());
    }
    eventDispatcher.post(event);
}
#end_block

#method_before
private void setLocalPermissions(ApplicationId applicationId) {
    for (String location : store.getBundleLocations(applicationId)) {
        permissionAdmin.setPermissions(location, store.getGrantedPermissions(applicationId));
    }
}
#method_after
private void setLocalPermissions(ApplicationId applicationId) {
    for (String location : store.getBundleLocations(applicationId)) {
        permissionAdmin.setPermissions(location, permissionsToInfo(store.getGrantedPermissions(applicationId)));
    }
}
#end_block

#method_before
private List<Permission> getMaximumPermissions(ApplicationId appId) {
    Application app = appAdminService.getApplication(appId);
    if (app == null) {
        print("Unknown application.");
        return null;
    }
    List<Permission> appPerms;
    switch(app.role()) {
        case ADMIN:
            appPerms = DefaultPolicyBuilder.getAdminApplicationPermissions(new ArrayList<>(app.permissions()));
            break;
        case USER:
            appPerms = DefaultPolicyBuilder.getUserApplicationPermissions(new ArrayList<>(app.permissions()));
            break;
        case UNSPECIFIED:
        default:
            print("Application %s has no role assigned.", app.id().name());
            appPerms = DefaultPolicyBuilder.getDefaultPerms();
            appPerms.addAll(app.permissions());
            break;
    }
    return optimizePermissions(appPerms);
}
#method_after
private List<Permission> getMaximumPermissions(ApplicationId appId) {
    Application app = appAdminService.getApplication(appId);
    if (app == null) {
        print("Unknown application.");
        return null;
    }
    List<Permission> appPerms;
    switch(app.role()) {
        case ADMIN:
            appPerms = DefaultPolicyBuilder.getAdminApplicationPermissions(app.permissions());
            break;
        case USER:
            appPerms = DefaultPolicyBuilder.getUserApplicationPermissions(app.permissions());
            break;
        case UNSPECIFIED:
        default:
            appPerms = DefaultPolicyBuilder.getDefaultPerms();
            break;
    }
    return appPerms;
}
#end_block

#method_before
public PermissionInfo[] getPermissions() {
    return grantedPermissions;
}
#method_after
public Set<Permission> getPermissions() {
    return grantedPermissions;
}
#end_block

#method_before
@Override
public Application install(InputStream appDescStream) {
    checkNotNull(appDescStream, "Application archive stream cannot be null");
    return store.create(appDescStream);
}
#method_after
@Override
public Application install(InputStream appDescStream) {
    checkNotNull(appDescStream, "Application archive stream cannot be null");
    Application app = store.create(appDescStream);
    SecurityUtil.register(app.id());
    return app;
}
#end_block

#method_before
@Override
public void activate(ApplicationId appId) {
    checkNotNull(appId, APP_ID_NULL);
    if (!SecurityUtil.isAppReviewed(appId)) {
        return;
    }
    store.activate(appId);
}
#method_after
@Override
public void activate(ApplicationId appId) {
    checkNotNull(appId, APP_ID_NULL);
    if (!SecurityUtil.isAppSecured(appId)) {
        return;
    }
    store.activate(appId);
}
#end_block

#method_before
@Activate
public void activate() {
    store.setDelegate(delegate);
    eventDispatcher.addSink(HostEvent.class, listenerRegistry);
    networkConfigService.addListener(networkConfigListener);
    monitor = new HostMonitor(deviceService, packetService, this);
    monitor.start();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    store.setDelegate(delegate);
    eventDispatcher.addSink(HostEvent.class, listenerRegistry);
    networkConfigService.addListener(networkConfigListener);
    monitor = new HostMonitor(packetService, this, interfaceService);
    monitor.start();
    log.info("Started");
}
#end_block

#method_before
@Override
protected void execute() {
    ApplicationAdminService applicationAdminService = get(ApplicationAdminService.class);
    ApplicationId appId = applicationAdminService.getId(name);
    if (appId == null) {
        print("No such application: %s", name);
        return;
    }
    SecurityAdminService smService = SecurityUtil.getSecurityService();
    if (smService == null) {
        print("Security Mode is disabled");
        return;
    }
    if (accept == null) {
        smService.review(appId);
    } else if (accept.trim().equals("accept")) {
        smService.acceptPolicy(appId);
    } else {
        print("Unknown command");
    }
}
#method_after
@Override
protected void execute() {
    ApplicationAdminService applicationAdminService = get(ApplicationAdminService.class);
    ApplicationId appId = applicationAdminService.getId(name);
    if (appId == null) {
        print("No such application: %s", name);
        return;
    }
    Application app = applicationAdminService.getApplication(appId);
    SecurityAdminService smService = SecurityUtil.getSecurityService();
    if (smService == null) {
        print("Security Mode is disabled");
        return;
    }
    if (accept == null) {
        smService.review(appId);
        printPolicy(smService, app);
    } else if (accept.trim().equals("accept")) {
        smService.acceptPolicy(appId);
        printPolicy(smService, app);
    } else {
        print("Unknown command");
    }
}
#end_block

#method_before
public static List<Permission> getUserApplicationPermissions(List<Permission> permissions) {
    List<Permission> permSet = new ArrayList<>();
    permSet.addAll(getDefaultPerms());
    for (Permission perm : permissions) {
        if (perm instanceof AppPermission) {
            if (((AppPermission) perm).getType() != null) {
                AppPermission ap = (AppPermission) perm;
                permSet.add(ap);
                if (serviceDirectory.containsKey(ap.getType())) {
                    for (String service : serviceDirectory.get(ap.getType())) {
                        permSet.add(new ServicePermission(service, ServicePermission.GET));
                    }
                }
            }
        } else if (perm instanceof ServicePermission) {
            if (!perm.getName().contains(SecurityAdminService.class.getName())) {
                permSet.add(perm);
            }
        } else {
            permSet.add(perm);
        }
    }
    return permSet;
}
#method_after
public static List<Permission> getUserApplicationPermissions(Set<org.onosproject.security.Permission> permissions) {
    List<Permission> perms = Lists.newArrayList();
    perms.addAll(defaultPermissions);
    perms.addAll(convertToJavaPermissions(permissions));
    return optimizePermissions(perms);
}
#end_block

#method_before
public static List<Permission> getAdminApplicationPermissions(List<Permission> permissions) {
    List<Permission> permSet = new ArrayList<>();
    permSet.addAll(getDefaultPerms());
    permSet.addAll(getAdminDefaultPerms());
    for (AppPermission.Type perm : serviceDirectory.keySet()) {
        permSet.add(new AppPermission(perm));
    }
    permSet.addAll(permissions);
    return permSet;
}
#method_after
public static List<Permission> getAdminApplicationPermissions(Set<org.onosproject.security.Permission> permissions) {
    List<Permission> perms = Lists.newArrayList();
    perms.addAll(defaultPermissions);
    perms.addAll(adminServicePermissions);
    for (AppPermission.Type perm : serviceDirectory.keySet()) {
        perms.add(new AppPermission(perm));
    }
    perms.addAll(convertToJavaPermissions(permissions));
    return optimizePermissions(perms);
}
#end_block

#method_before
public static List<Permission> getDefaultPerms() {
    List<Permission> permSet = new ArrayList<>();
    permSet.add(new PackagePermission("*", PackagePermission.EXPORTONLY));
    permSet.add(new PackagePermission("*", PackagePermission.IMPORT));
    permSet.add(new AdaptPermission("*", AdaptPermission.ADAPT));
    return permSet;
}
#method_after
public static List<Permission> getDefaultPerms() {
    List<Permission> permSet = Lists.newArrayList();
    permSet.add(new PackagePermission("*", PackagePermission.EXPORTONLY));
    permSet.add(new PackagePermission("*", PackagePermission.IMPORT));
    permSet.add(new AdaptPermission("*", AdaptPermission.ADAPT));
    permSet.add(new ConfigurationPermission("*", ConfigurationPermission.CONFIGURE));
    return permSet;
}
#end_block

#method_before
public static List<Permission> getAdminDefaultPerms() {
    List<Permission> permSet = new ArrayList<>();
    permSet.add(new ServicePermission(ApplicationAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ClusterAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(MastershipAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DeviceAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(HostAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(LinkAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DriverAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(StorageAdminService.class.getName(), ServicePermission.GET));
    // permSet.add(new ServicePermission(LabelResourceAdminService.class.getName(), ServicePermission.GET));
    // permSet.add(new ServicePermission(TunnelAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ApplicationService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ComponentConfigService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(CoreService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ClusterService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(LeadershipService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(MastershipService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DeviceService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DeviceClockService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DriverService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(FlowRuleService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(FlowObjectiveService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(GroupService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(HostService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(IntentService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(IntentClockService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(IntentExtensionService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(PartitionService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(LinkService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(LinkResourceService.class.getName(), ServicePermission.GET));
    // permSet.add(new ServicePermission(LabelResourceService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(PacketService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ProxyArpService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(StatisticService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(PathService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(TopologyService.class.getName(), ServicePermission.GET));
    // permSet.add(new ServicePermission(TunnelService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(StorageService.class.getName(), ServicePermission.GET));
    return permSet;
}
#method_after
private static List<Permission> getAdminDefaultPerms() {
    List<Permission> permSet = Lists.newArrayList();
    permSet.add(new ServicePermission(ApplicationAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ClusterAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(MastershipAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DeviceAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(HostAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(LinkAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DriverAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(StorageAdminService.class.getName(), ServicePermission.GET));
    // permSet.add(new ServicePermission(LabelResourceAdminService.class.getName(), ServicePermission.GET));
    // permSet.add(new ServicePermission(TunnelAdminService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ApplicationService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ComponentConfigService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(CoreService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ClusterService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(LeadershipService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(MastershipService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DeviceService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DeviceClockService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(DriverService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(FlowRuleService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(FlowObjectiveService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(GroupService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(HostService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(IntentService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(IntentClockService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(IntentExtensionService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(PartitionService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(LinkService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(LinkResourceService.class.getName(), ServicePermission.GET));
    // permSet.add(new ServicePermission(LabelResourceService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(PacketService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(ProxyArpService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(StatisticService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(PathService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(TopologyService.class.getName(), ServicePermission.GET));
    // permSet.add(new ServicePermission(TunnelService.class.getName(), ServicePermission.GET));
    permSet.add(new ServicePermission(StorageService.class.getName(), ServicePermission.GET));
    return permSet;
}
#end_block

#method_before
private static ConcurrentHashMap<AppPermission.Type, Set<String>> getServiceDirectory() {
    ConcurrentHashMap<AppPermission.Type, Set<String>> serviceDirectory = new ConcurrentHashMap<>();
    serviceDirectory.put(APP_READ, ImmutableSet.of(ApplicationService.class.getName(), CoreService.class.getName()));
    serviceDirectory.put(APP_EVENT, ImmutableSet.of(ApplicationService.class.getName(), CoreService.class.getName()));
    serviceDirectory.put(CONFIG_READ, ImmutableSet.of(ComponentConfigService.class.getName()));
    serviceDirectory.put(CONFIG_WRITE, ImmutableSet.of(ComponentConfigService.class.getName()));
    serviceDirectory.put(CLUSTER_READ, ImmutableSet.of(ClusterService.class.getName(), LeadershipService.class.getName(), MastershipService.class.getName()));
    serviceDirectory.put(CLUSTER_WRITE, ImmutableSet.of(LeadershipService.class.getName(), MastershipService.class.getName()));
    serviceDirectory.put(CLUSTER_EVENT, ImmutableSet.of(ClusterService.class.getName(), LeadershipService.class.getName(), MastershipService.class.getName()));
    serviceDirectory.put(DEVICE_READ, ImmutableSet.of(DeviceService.class.getName(), DeviceClockService.class.getName()));
    serviceDirectory.put(DEVICE_EVENT, ImmutableSet.of(DeviceService.class.getName()));
    serviceDirectory.put(DRIVER_READ, ImmutableSet.of(DriverService.class.getName()));
    serviceDirectory.put(DRIVER_WRITE, ImmutableSet.of(DriverService.class.getName()));
    serviceDirectory.put(FLOWRULE_READ, ImmutableSet.of(FlowRuleService.class.getName()));
    serviceDirectory.put(FLOWRULE_WRITE, ImmutableSet.of(FlowRuleService.class.getName(), FlowObjectiveService.class.getName()));
    serviceDirectory.put(FLOWRULE_EVENT, ImmutableSet.of(FlowRuleService.class.getName()));
    serviceDirectory.put(GROUP_READ, ImmutableSet.of(GroupService.class.getName()));
    serviceDirectory.put(GROUP_WRITE, ImmutableSet.of(GroupService.class.getName()));
    serviceDirectory.put(GROUP_EVENT, ImmutableSet.of(GroupService.class.getName()));
    serviceDirectory.put(HOST_WRITE, ImmutableSet.of(HostService.class.getName()));
    serviceDirectory.put(HOST_EVENT, ImmutableSet.of(HostService.class.getName()));
    serviceDirectory.put(INTENT_READ, ImmutableSet.of(IntentService.class.getName(), PartitionService.class.getName(), IntentClockService.class.getName()));
    serviceDirectory.put(INTENT_WRITE, ImmutableSet.of(IntentService.class.getName()));
    serviceDirectory.put(INTENT_EVENT, ImmutableSet.of(IntentService.class.getName()));
    // serviceDirectory.put(LINK_READ, ImmutableSet.of(
    // LinkService.class.getName(), LinkResourceService.class.getName(),
    // LabelResourceService.class.getName()));
    // serviceDirectory.put(LINK_WRITE, ImmutableSet.of(
    // LinkResourceService.class.getName(), LabelResourceService.class.getName()));
    // serviceDirectory.put(LINK_EVENT, ImmutableSet.of(
    // LinkService.class.getName(), LinkResourceService.class.getName(),
    // LabelResourceService.class.getName()));
    serviceDirectory.put(PACKET_READ, ImmutableSet.of(PacketService.class.getName(), ProxyArpService.class.getName()));
    serviceDirectory.put(PACKET_WRITE, ImmutableSet.of(PacketService.class.getName(), ProxyArpService.class.getName()));
    serviceDirectory.put(PACKET_EVENT, ImmutableSet.of(PacketService.class.getName()));
    serviceDirectory.put(STATISTIC_READ, ImmutableSet.of(StatisticService.class.getName()));
    serviceDirectory.put(TOPOLOGY_READ, ImmutableSet.of(TopologyService.class.getName(), PathService.class.getName()));
    serviceDirectory.put(TOPOLOGY_EVENT, ImmutableSet.of(TopologyService.class.getName()));
    // serviceDirectory.put(TUNNEL_READ, ImmutableSet.of(
    // TunnelService.class.getName()));
    // serviceDirectory.put(TUNNEL_WRITE, ImmutableSet.of(
    // TunnelService.class.getName()));
    // serviceDirectory.put(TUNNEL_EVENT, ImmutableSet.of(
    // TunnelService.class.getName()));
    serviceDirectory.put(STORAGE_WRITE, ImmutableSet.of(StorageService.class.getName()));
    return serviceDirectory;
}
#method_after
private static ConcurrentHashMap<AppPermission.Type, Set<String>> getServiceDirectory() {
    ConcurrentHashMap<AppPermission.Type, Set<String>> serviceDirectory = new ConcurrentHashMap<>();
    serviceDirectory.put(APP_READ, ImmutableSet.of(ApplicationService.class.getName(), CoreService.class.getName()));
    serviceDirectory.put(APP_EVENT, ImmutableSet.of(ApplicationService.class.getName(), CoreService.class.getName()));
    serviceDirectory.put(CONFIG_READ, ImmutableSet.of(ComponentConfigService.class.getName()));
    serviceDirectory.put(CONFIG_WRITE, ImmutableSet.of(ComponentConfigService.class.getName()));
    serviceDirectory.put(CLUSTER_READ, ImmutableSet.of(ClusterService.class.getName(), LeadershipService.class.getName(), MastershipService.class.getName()));
    serviceDirectory.put(CLUSTER_WRITE, ImmutableSet.of(LeadershipService.class.getName(), MastershipService.class.getName()));
    serviceDirectory.put(CLUSTER_EVENT, ImmutableSet.of(ClusterService.class.getName(), LeadershipService.class.getName(), MastershipService.class.getName()));
    serviceDirectory.put(DEVICE_READ, ImmutableSet.of(DeviceService.class.getName(), DeviceClockService.class.getName()));
    serviceDirectory.put(DEVICE_EVENT, ImmutableSet.of(DeviceService.class.getName()));
    serviceDirectory.put(DRIVER_READ, ImmutableSet.of(DriverService.class.getName()));
    serviceDirectory.put(DRIVER_WRITE, ImmutableSet.of(DriverService.class.getName()));
    serviceDirectory.put(FLOWRULE_READ, ImmutableSet.of(FlowRuleService.class.getName()));
    serviceDirectory.put(FLOWRULE_WRITE, ImmutableSet.of(FlowRuleService.class.getName(), FlowObjectiveService.class.getName()));
    serviceDirectory.put(FLOWRULE_EVENT, ImmutableSet.of(FlowRuleService.class.getName()));
    serviceDirectory.put(GROUP_READ, ImmutableSet.of(GroupService.class.getName()));
    serviceDirectory.put(GROUP_WRITE, ImmutableSet.of(GroupService.class.getName()));
    serviceDirectory.put(GROUP_EVENT, ImmutableSet.of(GroupService.class.getName()));
    serviceDirectory.put(HOST_READ, ImmutableSet.of(HostService.class.getName()));
    serviceDirectory.put(HOST_WRITE, ImmutableSet.of(HostService.class.getName()));
    serviceDirectory.put(HOST_EVENT, ImmutableSet.of(HostService.class.getName()));
    serviceDirectory.put(INTENT_READ, ImmutableSet.of(IntentService.class.getName(), PartitionService.class.getName(), IntentClockService.class.getName()));
    serviceDirectory.put(INTENT_WRITE, ImmutableSet.of(IntentService.class.getName()));
    serviceDirectory.put(INTENT_EVENT, ImmutableSet.of(IntentService.class.getName()));
    // serviceDirectory.put(LINK_READ, ImmutableSet.of(
    // LinkService.class.getName(), LinkResourceService.class.getName(),
    // LabelResourceService.class.getName()));
    // serviceDirectory.put(LINK_WRITE, ImmutableSet.of(
    // LinkResourceService.class.getName(), LabelResourceService.class.getName()));
    // serviceDirectory.put(LINK_EVENT, ImmutableSet.of(
    // LinkService.class.getName(), LinkResourceService.class.getName(),
    // LabelResourceService.class.getName()));
    serviceDirectory.put(PACKET_READ, ImmutableSet.of(PacketService.class.getName(), ProxyArpService.class.getName()));
    serviceDirectory.put(PACKET_WRITE, ImmutableSet.of(PacketService.class.getName(), ProxyArpService.class.getName()));
    serviceDirectory.put(PACKET_EVENT, ImmutableSet.of(PacketService.class.getName()));
    serviceDirectory.put(STATISTIC_READ, ImmutableSet.of(StatisticService.class.getName()));
    serviceDirectory.put(TOPOLOGY_READ, ImmutableSet.of(TopologyService.class.getName(), PathService.class.getName()));
    serviceDirectory.put(TOPOLOGY_EVENT, ImmutableSet.of(TopologyService.class.getName()));
    // serviceDirectory.put(TUNNEL_READ, ImmutableSet.of(
    // TunnelService.class.getName()));
    // serviceDirectory.put(TUNNEL_WRITE, ImmutableSet.of(
    // TunnelService.class.getName()));
    // serviceDirectory.put(TUNNEL_EVENT, ImmutableSet.of(
    // TunnelService.class.getName()));
    serviceDirectory.put(STORAGE_WRITE, ImmutableSet.of(StorageService.class.getName()));
    return serviceDirectory;
}
#end_block

#method_before
private void buildAndSubmitBatches(Iterable<Key> intentKeys, boolean compileAllFailed) {
    // Attempt recompilation of the specified intents first.
    for (Key key : intentKeys) {
        Intent intent = store.getIntent(key);
        if (intent == null) {
            continue;
        }
        submit(intent);
    }
    if (compileAllFailed) {
        // If required, compile all currently failed intents.
        for (Intent intent : getIntents()) {
            IntentState state = getIntentState(intent.key());
            if (RECOMPILE.contains(state)) {
                if (state == WITHDRAW_REQ) {
                    withdraw(intent);
                } else {
                    submit(intent);
                }
            }
        }
    }
// FIXME
// for (ApplicationId appId : batches.keySet()) {
// if (batchService.isLocalLeader(appId)) {
// execute(batches.get(appId).build());
// }
// }
}
#method_after
private void buildAndSubmitBatches(Iterable<Key> intentKeys, boolean compileAllFailed) {
    // Attempt recompilation of the specified intents first.
    for (Key key : intentKeys) {
        Intent intent = store.getIntent(key);
        if (intent == null) {
            continue;
        }
        submit(intent);
    }
    // If required, compile all currently failed intents.
    for (Intent intent : getIntents()) {
        IntentState state = getIntentState(intent.key());
        if ((compileAllFailed && RECOMPILE.contains(state)) || intentAllowsPartialFailure(intent)) {
            if (WITHDRAW.contains(state)) {
                withdraw(intent);
            } else {
                submit(intent);
            }
        }
    }
// FIXME
// for (ApplicationId appId : batches.keySet()) {
// if (batchService.isLocalLeader(appId)) {
// execute(batches.get(appId).build());
// }
// }
}
#end_block

#method_before
private void replyArp(Ethernet eth, ConnectPoint inPort) {
    ARP arp = (ARP) eth.getPayload();
    checkArgument(arp.getOpCode() == ARP.OP_REQUEST, NOT_ARP_REQUEST);
    checkNotNull(inPort);
    Ip4Address targetAddress = Ip4Address.valueOf(arp.getTargetProtocolAddress());
    VlanId vlan = vlanId(eth.getVlanID());
    if (isOutsidePort(inPort)) {
        // If the request came from outside the network, only reply if it was
        // for one of our external addresses.
        Set<PortAddresses> addressSet = hostService.getAddressBindingsForPort(inPort);
        for (PortAddresses addresses : addressSet) {
            for (InterfaceIpAddress ia : addresses.ipAddresses()) {
                if (ia.ipAddress().equals(targetAddress)) {
                    Ethernet arpReply = ARP.buildArpReply(targetAddress, addresses.mac(), eth);
                    sendTo(arpReply, inPort);
                }
            }
        }
        return;
    }
    // See if we have the target host in the host store
    Set<Host> hosts = hostService.getHostsByIp(targetAddress);
    Host dst = null;
    Host src = hostService.getHost(hostId(eth.getSourceMAC(), vlanId(eth.getVlanID())));
    for (Host host : hosts) {
        if (host.vlan().equals(vlan)) {
            dst = host;
            break;
        }
    }
    if (src != null && dst != null) {
        // We know the target host so we can respond
        Ethernet arpReply = ARP.buildArpReply(targetAddress, dst.mac(), eth);
        sendTo(arpReply, inPort);
        return;
    }
    // If the source address matches one of our external addresses
    // it could be a request from an internal host to an external
    // address. Forward it over to the correct port.
    Ip4Address source = Ip4Address.valueOf(arp.getSenderProtocolAddress());
    Set<PortAddresses> sourceAddresses = findPortsInSubnet(source);
    boolean matched = false;
    for (PortAddresses pa : sourceAddresses) {
        for (InterfaceIpAddress ia : pa.ipAddresses()) {
            if (ia.ipAddress().equals(source) && pa.vlan().equals(vlan)) {
                matched = true;
                sendTo(eth, pa.connectPoint());
                break;
            }
        }
    }
    if (matched) {
        return;
    }
    // 
    // The request couldn't be resolved.
    // Flood the request on all ports except the incoming port.
    // 
    flood(eth, inPort);
}
#method_after
private void replyArp(Ethernet eth, ConnectPoint inPort) {
    ARP arp = (ARP) eth.getPayload();
    checkArgument(arp.getOpCode() == ARP.OP_REQUEST, NOT_ARP_REQUEST);
    checkNotNull(inPort);
    Ip4Address targetAddress = Ip4Address.valueOf(arp.getTargetProtocolAddress());
    VlanId vlan = vlanId(eth.getVlanID());
    if (hasIpAddress(inPort)) {
        // If the request came from outside the network, only reply if it was
        // for one of our external addresses.
        interfaceService.getInterfacesByPort(inPort).stream().filter(intf -> intf.ipAddresses().stream().anyMatch(ia -> ia.ipAddress().equals(targetAddress))).forEach(intf -> buildAndSendArp(targetAddress, intf.mac(), eth, inPort));
        // Stop here and don't proxy ARPs if the port has an IP address
        return;
    }
    // See if we have the target host in the host store
    Set<Host> hosts = hostService.getHostsByIp(targetAddress);
    Host dst = null;
    Host src = hostService.getHost(hostId(eth.getSourceMAC(), vlanId(eth.getVlanID())));
    for (Host host : hosts) {
        if (host.vlan().equals(vlan)) {
            dst = host;
            break;
        }
    }
    if (src != null && dst != null) {
        // We know the target host so we can respond
        buildAndSendArp(targetAddress, dst.mac(), eth, inPort);
        return;
    }
    // If the source address matches one of our external addresses
    // it could be a request from an internal host to an external
    // address. Forward it over to the correct port.
    Ip4Address source = Ip4Address.valueOf(arp.getSenderProtocolAddress());
    boolean matched = false;
    Set<Interface> interfaces = interfaceService.getInterfacesByIp(source);
    for (Interface intf : interfaces) {
        if (intf.vlan().equals(vlan)) {
            matched = true;
            sendTo(eth, intf.connectPoint());
            break;
        }
    }
    if (matched) {
        return;
    }
    // The request couldn't be resolved.
    // Flood the request on all ports except the incoming port.
    flood(eth, inPort);
}
#end_block

#method_before
private void replyNdp(Ethernet eth, ConnectPoint inPort) {
    IPv6 ipv6 = (IPv6) eth.getPayload();
    ICMP6 icmpv6 = (ICMP6) ipv6.getPayload();
    NeighborSolicitation nsol = (NeighborSolicitation) icmpv6.getPayload();
    Ip6Address targetAddress = Ip6Address.valueOf(nsol.getTargetAddress());
    VlanId vlan = vlanId(eth.getVlanID());
    // for one of our external addresses.
    if (isOutsidePort(inPort)) {
        Set<PortAddresses> addressSet = hostService.getAddressBindingsForPort(inPort);
        for (PortAddresses addresses : addressSet) {
            for (InterfaceIpAddress ia : addresses.ipAddresses()) {
                if (ia.ipAddress().equals(targetAddress)) {
                    Ethernet ndpReply = buildNdpReply(targetAddress, addresses.mac(), eth);
                    sendTo(ndpReply, inPort);
                }
            }
        }
        return;
    } else {
        // If the source address matches one of our external addresses
        // it could be a request from an internal host to an external
        // address. Forward it over to the correct ports.
        Ip6Address source = Ip6Address.valueOf(ipv6.getSourceAddress());
        Set<PortAddresses> sourceAddresses = findPortsInSubnet(source);
        boolean matched = false;
        for (PortAddresses pa : sourceAddresses) {
            for (InterfaceIpAddress ia : pa.ipAddresses()) {
                if (ia.ipAddress().equals(source) && pa.vlan().equals(vlan)) {
                    matched = true;
                    sendTo(eth, pa.connectPoint());
                    break;
                }
            }
        }
        if (matched) {
            return;
        }
    }
    // Continue with normal proxy ARP case
    Set<Host> hosts = hostService.getHostsByIp(targetAddress);
    Host dst = null;
    Host src = hostService.getHost(hostId(eth.getSourceMAC(), vlanId(eth.getVlanID())));
    for (Host host : hosts) {
        if (host.vlan().equals(vlan)) {
            dst = host;
            break;
        }
    }
    if (src == null || dst == null) {
        // 
        // The request couldn't be resolved.
        // Flood the request on all ports except the incoming ports.
        // 
        flood(eth, inPort);
        return;
    }
    // 
    // Reply on the port the request was received on
    // 
    Ethernet ndpReply = buildNdpReply(targetAddress, dst.mac(), eth);
    sendTo(ndpReply, inPort);
}
#method_after
private void replyNdp(Ethernet eth, ConnectPoint inPort) {
    IPv6 ipv6 = (IPv6) eth.getPayload();
    ICMP6 icmpv6 = (ICMP6) ipv6.getPayload();
    NeighborSolicitation nsol = (NeighborSolicitation) icmpv6.getPayload();
    Ip6Address targetAddress = Ip6Address.valueOf(nsol.getTargetAddress());
    VlanId vlan = vlanId(eth.getVlanID());
    // for one of our external addresses.
    if (hasIpAddress(inPort)) {
        interfaceService.getInterfacesByPort(inPort).stream().filter(intf -> intf.ipAddresses().stream().anyMatch(ia -> ia.ipAddress().equals(targetAddress))).forEach(intf -> buildAndSendNdp(targetAddress, intf.mac(), eth, inPort));
        return;
    }
    // Continue with normal proxy ARP case
    Set<Host> hosts = hostService.getHostsByIp(targetAddress);
    Host dst = null;
    Host src = hostService.getHost(hostId(eth.getSourceMAC(), vlanId(eth.getVlanID())));
    for (Host host : hosts) {
        if (host.vlan().equals(vlan)) {
            dst = host;
            break;
        }
    }
    if (src != null && dst != null) {
        // We know the target host so we can respond
        buildAndSendNdp(targetAddress, dst.mac(), eth, inPort);
        return;
    }
    // If the source address matches one of our external addresses
    // it could be a request from an internal host to an external
    // address. Forward it over to the correct port.
    Ip6Address source = Ip6Address.valueOf(ipv6.getSourceAddress());
    boolean matched = false;
    Set<Interface> interfaces = interfaceService.getInterfacesByIp(source);
    for (Interface intf : interfaces) {
        if (intf.vlan().equals(vlan)) {
            matched = true;
            sendTo(eth, intf.connectPoint());
            break;
        }
    }
    if (matched) {
        return;
    }
    // The request couldn't be resolved.
    // Flood the request on all ports except the incoming ports.
    flood(eth, inPort);
}
#end_block

#method_before
// TODO checkpoint
private void sendTo(Ethernet packet, ConnectPoint outPort) {
    sendTo(outPort, ByteBuffer.wrap(packet.serialize()));
}
#method_after
private void sendTo(Ethernet packet, ConnectPoint outPort) {
    sendTo(outPort, ByteBuffer.wrap(packet.serialize()));
}
#end_block

#method_before
private void flood(Ethernet request, ConnectPoint inPort) {
    TrafficTreatment.Builder builder = null;
    ByteBuffer buf = ByteBuffer.wrap(request.serialize());
    for (ConnectPoint connectPoint : edgeService.getEdgePoints()) {
        if (isOutsidePort(connectPoint) || connectPoint.equals(inPort)) {
            continue;
        }
        builder = DefaultTrafficTreatment.builder();
        builder.setOutput(connectPoint.port());
        packetService.emit(new DefaultOutboundPacket(connectPoint.deviceId(), builder.build(), buf));
    }
}
#method_after
private void flood(Ethernet request, ConnectPoint inPort) {
    TrafficTreatment.Builder builder = null;
    ByteBuffer buf = ByteBuffer.wrap(request.serialize());
    for (ConnectPoint connectPoint : edgeService.getEdgePoints()) {
        if (hasIpAddress(connectPoint) || connectPoint.equals(inPort)) {
            continue;
        }
        builder = DefaultTrafficTreatment.builder();
        builder.setOutput(connectPoint.port());
        packetService.emit(new DefaultOutboundPacket(connectPoint.deviceId(), builder.build(), buf));
    }
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    int newTunnelStatsPollFrequency;
    try {
        String s = get(properties, "TunnelStatsPollFrequency");
        newTunnelStatsPollFrequency = isNullOrEmpty(s) ? tunnelStatsPollFrequency : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        newTunnelStatsPollFrequency = tunnelStatsPollFrequency;
    }
    if (newTunnelStatsPollFrequency != tunnelStatsPollFrequency) {
        tunnelStatsPollFrequency = newTunnelStatsPollFrequency;
        collectors.values().forEach(tsc -> tsc.adjustPollInterval(tunnelStatsPollFrequency));
        log.info("New setting: tunnelStatsPollFrequency={}", tunnelStatsPollFrequency);
    }
}
#method_after
@Modified
public void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    int newTunnelStatsPollFrequency;
    try {
        String s = get(properties, "tunnelStatsPollFrequency");
        newTunnelStatsPollFrequency = isNullOrEmpty(s) ? tunnelStatsPollFrequency : Integer.parseInt(s.trim());
    } catch (NumberFormatException | ClassCastException e) {
        newTunnelStatsPollFrequency = tunnelStatsPollFrequency;
    }
    if (newTunnelStatsPollFrequency != tunnelStatsPollFrequency) {
        tunnelStatsPollFrequency = newTunnelStatsPollFrequency;
        collectors.values().forEach(tsc -> tsc.adjustPollInterval(tunnelStatsPollFrequency));
        log.info("New setting: tunnelStatsPollFrequency={}", tunnelStatsPollFrequency);
    }
}
#end_block

#method_before
TunnelStatistics buildTunnelStatistics(PcepTunnelStatistics statistics) {
    DefaultTunnelStatistics.Builder builder = new DefaultTunnelStatistics.Builder();
    DefaultTunnelStatistics tunnelStatistics = builder.setBwUtilization(statistics.bwUtilization()).setFlowLossRatio(statistics.packetLossRatio()).setTrafficFlowDelay(statistics.flowDelay()).setAlarms(statistics.alarms()).build();
    return tunnelStatistics;
}
#method_after
private TunnelStatistics buildTunnelStatistics(PcepTunnelStatistics statistics) {
    DefaultTunnelStatistics.Builder builder = new DefaultTunnelStatistics.Builder();
    DefaultTunnelStatistics tunnelStatistics = builder.setBwUtilization(statistics.bandwidthUtilization()).setPacketLossRatio(statistics.packetLossRate()).setFlowDelay(statistics.flowDelay()).setAlarms(statistics.alarms()).build();
    return tunnelStatistics;
}
#end_block

#method_before
LinkedList<PcInitiatedLspRequest> createPcInitiatedLspReqList(Tunnel tunnel, Path path, PcepClient pc, int srpId) throws PcepParseException {
    PcepValueType tlv;
    LinkedList<PcepValueType> llSubObjects = createPcepPath(path);
    if (null == llSubObjects || 0 == llSubObjects.size()) {
        log.error("There is no link information to create tunnel");
        return null;
    }
    // build SRP object
    PcepSrpObject srpobj = pc.factory().buildSrpObject().setSrpID(srpId).setRFlag(false).build();
    LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
    LinkedList<PcInitiatedLspRequest> llPcInitiatedLspRequestList = new LinkedList<PcInitiatedLspRequest>();
    // set LSP identifiers TLV
    tlv = new StatefulIPv4LspIdentidiersTlv((((IpTunnelEndPoint) tunnel.src()).ip().getIp4Address().toInt()), (short) 0, (short) 0, 0, (((IpTunnelEndPoint) tunnel.dst()).ip().getIp4Address().toInt()));
    llOptionalTlv.add(tlv);
    // set SymbolicPathNameTlv of LSP object
    tlv = new SymbolicPathNameTlv(tunnel.tunnelName().value().getBytes());
    llOptionalTlv.add(tlv);
    // build LSP object
    PcepLspObject lspobj = pc.factory().buildLspObject().setAFlag(true).setOFlag((byte) 0).setPlspId(0).setOptionalTlv(llOptionalTlv).build();
    // build ENDPOINTS object
    PcepEndPointsObject endpointsobj = pc.factory().buildEndPointsObject().setSourceIpAddress(((IpTunnelEndPoint) tunnel.src()).ip().getIp4Address().toInt()).setDestIpAddress(((IpTunnelEndPoint) tunnel.dst()).ip().getIp4Address().toInt()).setPFlag(true).build();
    // build ERO object
    PcepEroObject eroobj = pc.factory().buildEroObject().setSubObjects(llSubObjects).build();
    int iBandwidth = DEFAULT_BANDWIDTH_VALUE;
    if (null != tunnel.annotations().value("bandwidth")) {
        iBandwidth = Integer.parseInt(tunnel.annotations().value("bandwidth"));
    }
    // build bandwidth object
    PcepBandwidthObject bandwidthObject = pc.factory().buildBandwidthObject().setBandwidth(iBandwidth).build();
    // build pcep attribute
    PcepAttribute pcepAttribute = pc.factory().buildPcepAttribute().setBandwidthObject(bandwidthObject).build();
    PcInitiatedLspRequest initiateLspRequest = pc.factory().buildPcInitiatedLspRequest().setSrpObject(srpobj).setLspObject(lspobj).setEndPointsObject(endpointsobj).setEroObject(eroobj).setPcepAttribute(pcepAttribute).build();
    llPcInitiatedLspRequestList.add(initiateLspRequest);
    return llPcInitiatedLspRequestList;
}
#method_after
LinkedList<PcInitiatedLspRequest> createPcInitiatedLspReqList(Tunnel tunnel, Path path, PcepClient pc, int srpId) throws PcepParseException {
    PcepValueType tlv;
    LinkedList<PcepValueType> llSubObjects = createPcepPath(path);
    if (llSubObjects == null || llSubObjects.size() == 0) {
        log.error("There is no link information to create tunnel");
        return null;
    }
    // build SRP object
    PcepSrpObject srpobj = pc.factory().buildSrpObject().setSrpID(srpId).setRFlag(false).build();
    LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
    LinkedList<PcInitiatedLspRequest> llPcInitiatedLspRequestList = new LinkedList<PcInitiatedLspRequest>();
    // set LSP identifiers TLV
    tlv = new StatefulIPv4LspIdentidiersTlv((((IpTunnelEndPoint) tunnel.src()).ip().getIp4Address().toInt()), (short) 0, (short) 0, 0, (((IpTunnelEndPoint) tunnel.dst()).ip().getIp4Address().toInt()));
    llOptionalTlv.add(tlv);
    // set SymbolicPathNameTlv of LSP object
    tlv = new SymbolicPathNameTlv(tunnel.tunnelName().value().getBytes());
    llOptionalTlv.add(tlv);
    // build LSP object
    PcepLspObject lspobj = pc.factory().buildLspObject().setAFlag(true).setOFlag((byte) 0).setPlspId(0).setOptionalTlv(llOptionalTlv).build();
    // build ENDPOINTS object
    PcepEndPointsObject endpointsobj = pc.factory().buildEndPointsObject().setSourceIpAddress(((IpTunnelEndPoint) tunnel.src()).ip().getIp4Address().toInt()).setDestIpAddress(((IpTunnelEndPoint) tunnel.dst()).ip().getIp4Address().toInt()).setPFlag(true).build();
    // build ERO object
    PcepEroObject eroobj = pc.factory().buildEroObject().setSubObjects(llSubObjects).build();
    int iBandwidth = DEFAULT_BANDWIDTH_VALUE;
    if (tunnel.annotations().value("bandwidth") != null) {
        iBandwidth = Integer.parseInt(tunnel.annotations().value("bandwidth"));
    }
    // build bandwidth object
    PcepBandwidthObject bandwidthObject = pc.factory().buildBandwidthObject().setBandwidth(iBandwidth).build();
    // build pcep attribute
    PcepAttribute pcepAttribute = pc.factory().buildPcepAttribute().setBandwidthObject(bandwidthObject).build();
    PcInitiatedLspRequest initiateLspRequest = pc.factory().buildPcInitiatedLspRequest().setSrpObject(srpobj).setLspObject(lspobj).setEndPointsObject(endpointsobj).setEroObject(eroobj).setPcepAttribute(pcepAttribute).build();
    llPcInitiatedLspRequestList.add(initiateLspRequest);
    return llPcInitiatedLspRequestList;
}
#end_block

#method_before
private void pcepSetupTunnel(Tunnel tunnel, Path path, PcepClient pc) {
    try {
        int srpId = SrpIdGenerators.create();
        PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.CREATE);
        pcepTunnelAPIMapper.addToCoreTunnelRequestQueue(pcepTunnelData);
        LinkedList<PcInitiatedLspRequest> llPcInitiatedLspRequestList = createPcInitiatedLspReqList(tunnel, path, pc, srpId);
        if (null == llPcInitiatedLspRequestList || 0 == llPcInitiatedLspRequestList.size()) {
            log.error("Failed to create PcInitiatedLspRequestList");
            return;
        }
        // build PCInitiate message
        PcepInitiateMsg pcInitiateMsg = pc.factory().buildPcepInitiateMsg().setPcInitiatedLspRequestList(llPcInitiatedLspRequestList).build();
        pc.sendMessage(Collections.singletonList(pcInitiateMsg));
        pcepTunnelAPIMapper.addToTunnelRequestQueue(srpId, pcepTunnelData);
    } catch (PcepParseException e) {
        log.error("PcepParseException occurred while processing setup tunnel {}", e.getMessage());
    }
}
#method_after
private void pcepSetupTunnel(Tunnel tunnel, Path path, PcepClient pc) {
    try {
        int srpId = SrpIdGenerators.create();
        PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.CREATE);
        pcepTunnelAPIMapper.addToCoreTunnelRequestQueue(pcepTunnelData);
        LinkedList<PcInitiatedLspRequest> llPcInitiatedLspRequestList = createPcInitiatedLspReqList(tunnel, path, pc, srpId);
        if (llPcInitiatedLspRequestList == null || llPcInitiatedLspRequestList.size() == 0) {
            log.error("Failed to create PcInitiatedLspRequestList");
            return;
        }
        // build PCInitiate message
        PcepInitiateMsg pcInitiateMsg = pc.factory().buildPcepInitiateMsg().setPcInitiatedLspRequestList(llPcInitiatedLspRequestList).build();
        pc.sendMessage(Collections.singletonList(pcInitiateMsg));
        pcepTunnelAPIMapper.addToTunnelRequestQueue(srpId, pcepTunnelData);
    } catch (PcepParseException e) {
        log.error("PcepParseException occurred while processing setup tunnel {}", e.getMessage());
    }
}
#end_block

#method_before
private void pcepReleaseTunnel(Tunnel tunnel, PcepClient pc) {
    try {
        PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, RequestType.DELETE);
        pcepTunnelAPIMapper.addToCoreTunnelRequestQueue(pcepTunnelData);
        int srpId = SrpIdGenerators.create();
        TunnelId tunnelId = tunnel.tunnelId();
        int plspId = 0;
        StatefulIPv4LspIdentidiersTlv statefulIpv4IndentifierTlv = null;
        if (!(pcepTunnelAPIMapper.checkFromTunnelDBQueue(tunnelId))) {
            log.error("Tunnel doesnot exists. Tunnel id {}" + tunnelId.toString());
            return;
        } else {
            PcepTunnelData pcepTunnelDbData = pcepTunnelAPIMapper.getDataFromTunnelDBQueue(tunnelId);
            plspId = pcepTunnelDbData.plspId();
            statefulIpv4IndentifierTlv = pcepTunnelDbData.statefulIpv4IndentifierTlv();
        }
        // build srp object
        PcepSrpObject srpobj = pc.factory().buildSrpObject().setSrpID(srpId).setRFlag(true).build();
        PcepValueType tlv;
        LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
        LinkedList<PcInitiatedLspRequest> llPcInitiatedLspRequestList = new LinkedList<PcInitiatedLspRequest>();
        if (null != statefulIpv4IndentifierTlv) {
            tlv = statefulIpv4IndentifierTlv;
        } else {
            tlv = new StatefulIPv4LspIdentidiersTlv((((IpTunnelEndPoint) tunnel.src()).ip().getIp4Address().toInt()), (short) 0, (short) 0, 0, (((IpTunnelEndPoint) tunnel.dst()).ip().getIp4Address().toInt()));
        }
        llOptionalTlv.add(tlv);
        tlv = new SymbolicPathNameTlv(tunnel.tunnelName().value().getBytes());
        llOptionalTlv.add(tlv);
        // build lsp object, set r flag as false to delete the tunnel
        PcepLspObject lspobj = pc.factory().buildLspObject().setRFlag(false).setPlspId(plspId).setOptionalTlv(llOptionalTlv).build();
        PcInitiatedLspRequest releaseLspRequest = pc.factory().buildPcInitiatedLspRequest().setSrpObject(srpobj).setLspObject(lspobj).build();
        llPcInitiatedLspRequestList.add(releaseLspRequest);
        PcepInitiateMsg pcInitiateMsg = pc.factory().buildPcepInitiateMsg().setPcInitiatedLspRequestList(llPcInitiatedLspRequestList).build();
        pc.sendMessage(Collections.singletonList(pcInitiateMsg));
        pcepTunnelAPIMapper.addToTunnelRequestQueue(srpId, pcepTunnelData);
    } catch (PcepParseException e) {
        log.error("PcepParseException occurred while processing release tunnel {}", e.getMessage());
    }
}
#method_after
private void pcepReleaseTunnel(Tunnel tunnel, PcepClient pc) {
    try {
        PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, RequestType.DELETE);
        pcepTunnelAPIMapper.addToCoreTunnelRequestQueue(pcepTunnelData);
        int srpId = SrpIdGenerators.create();
        TunnelId tunnelId = tunnel.tunnelId();
        int plspId = 0;
        StatefulIPv4LspIdentidiersTlv statefulIpv4IndentifierTlv = null;
        if (!(pcepTunnelAPIMapper.checkFromTunnelDBQueue(tunnelId))) {
            log.error("Tunnel doesnot exists. Tunnel id {}" + tunnelId.toString());
            return;
        } else {
            PcepTunnelData pcepTunnelDbData = pcepTunnelAPIMapper.getDataFromTunnelDBQueue(tunnelId);
            plspId = pcepTunnelDbData.plspId();
            statefulIpv4IndentifierTlv = pcepTunnelDbData.statefulIpv4IndentifierTlv();
        }
        // build srp object
        PcepSrpObject srpobj = pc.factory().buildSrpObject().setSrpID(srpId).setRFlag(true).build();
        PcepValueType tlv;
        LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
        LinkedList<PcInitiatedLspRequest> llPcInitiatedLspRequestList = new LinkedList<PcInitiatedLspRequest>();
        if (statefulIpv4IndentifierTlv != null) {
            tlv = statefulIpv4IndentifierTlv;
        } else {
            tlv = new StatefulIPv4LspIdentidiersTlv((((IpTunnelEndPoint) tunnel.src()).ip().getIp4Address().toInt()), (short) 0, (short) 0, 0, (((IpTunnelEndPoint) tunnel.dst()).ip().getIp4Address().toInt()));
        }
        llOptionalTlv.add(tlv);
        tlv = new SymbolicPathNameTlv(tunnel.tunnelName().value().getBytes());
        llOptionalTlv.add(tlv);
        // build lsp object, set r flag as false to delete the tunnel
        PcepLspObject lspobj = pc.factory().buildLspObject().setRFlag(false).setPlspId(plspId).setOptionalTlv(llOptionalTlv).build();
        PcInitiatedLspRequest releaseLspRequest = pc.factory().buildPcInitiatedLspRequest().setSrpObject(srpobj).setLspObject(lspobj).build();
        llPcInitiatedLspRequestList.add(releaseLspRequest);
        PcepInitiateMsg pcInitiateMsg = pc.factory().buildPcepInitiateMsg().setPcInitiatedLspRequestList(llPcInitiatedLspRequestList).build();
        pc.sendMessage(Collections.singletonList(pcInitiateMsg));
        pcepTunnelAPIMapper.addToTunnelRequestQueue(srpId, pcepTunnelData);
    } catch (PcepParseException e) {
        log.error("PcepParseException occurred while processing release tunnel {}", e.getMessage());
    }
}
#end_block

#method_before
private void pcepUpdateTunnel(Tunnel tunnel, Path path, PcepClient pc) {
    try {
        PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
        pcepTunnelAPIMapper.addToCoreTunnelRequestQueue(pcepTunnelData);
        int srpId = SrpIdGenerators.create();
        TunnelId tunnelId = tunnel.tunnelId();
        PcepValueType tlv;
        int plspId = 0;
        LinkedList<PcepValueType> llSubObjects = createPcepPath(path);
        LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
        LinkedList<PcepUpdateRequest> llUpdateRequestList = new LinkedList<PcepUpdateRequest>();
        // build SRP object
        PcepSrpObject srpobj = pc.factory().buildSrpObject().setSrpID(srpId).setRFlag(false).build();
        if (!(pcepTunnelAPIMapper.checkFromTunnelDBQueue(tunnelId))) {
            log.error("Tunnel doesnot exists in DB");
            return;
        } else {
            PcepTunnelData pcepTunnelDBData = pcepTunnelAPIMapper.getDataFromTunnelDBQueue(tunnelId);
            plspId = pcepTunnelDBData.plspId();
        }
        tlv = new StatefulIPv4LspIdentidiersTlv((((IpTunnelEndPoint) tunnel.src()).ip().getIp4Address().toInt()), (short) 0, (short) 0, 0, (((IpTunnelEndPoint) tunnel.dst()).ip().getIp4Address().toInt()));
        llOptionalTlv.add(tlv);
        if (tunnel.tunnelName().value() != null) {
            tlv = new SymbolicPathNameTlv(tunnel.tunnelName().value().getBytes());
            llOptionalTlv.add(tlv);
        }
        // build lsp object
        PcepLspObject lspobj = pc.factory().buildLspObject().setAFlag(true).setPlspId(plspId).setOptionalTlv(llOptionalTlv).build();
        // build ero object
        PcepEroObject eroobj = pc.factory().buildEroObject().setSubObjects(llSubObjects).build();
        int iBandwidth = DEFAULT_BANDWIDTH_VALUE;
        if (null != tunnel.annotations().value("bandwidth")) {
            iBandwidth = Integer.parseInt(tunnel.annotations().value("bandwidth"));
        }
        // build bandwidth object
        PcepBandwidthObject bandwidthObject = pc.factory().buildBandwidthObject().setBandwidth(iBandwidth).build();
        // build pcep attribute
        PcepAttribute pcepAttribute = pc.factory().buildPcepAttribute().setBandwidthObject(bandwidthObject).build();
        // build pcep msg path
        PcepMsgPath msgPath = pc.factory().buildPcepMsgPath().setEroObject(eroobj).setPcepAttribute(pcepAttribute).build();
        PcepUpdateRequest updateRequest = pc.factory().buildPcepUpdateRequest().setSrpObject(srpobj).setLspObject(lspobj).setMsgPath(msgPath).build();
        llUpdateRequestList.add(updateRequest);
        PcepUpdateMsg pcUpdateMsg = pc.factory().buildUpdateMsg().setUpdateRequestList(llUpdateRequestList).build();
        pc.sendMessage(Collections.singletonList(pcUpdateMsg));
        pcepTunnelAPIMapper.addToTunnelRequestQueue(srpId, pcepTunnelData);
    } catch (PcepParseException e) {
        log.error("PcepParseException occurred while processing release tunnel {}", e.getMessage());
    }
}
#method_after
private void pcepUpdateTunnel(Tunnel tunnel, Path path, PcepClient pc) {
    try {
        PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
        pcepTunnelAPIMapper.addToCoreTunnelRequestQueue(pcepTunnelData);
        int srpId = SrpIdGenerators.create();
        TunnelId tunnelId = tunnel.tunnelId();
        PcepValueType tlv;
        int plspId = 0;
        LinkedList<PcepValueType> llSubObjects = createPcepPath(path);
        LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
        LinkedList<PcepUpdateRequest> llUpdateRequestList = new LinkedList<PcepUpdateRequest>();
        // build SRP object
        PcepSrpObject srpobj = pc.factory().buildSrpObject().setSrpID(srpId).setRFlag(false).build();
        if (!(pcepTunnelAPIMapper.checkFromTunnelDBQueue(tunnelId))) {
            log.error("Tunnel doesnot exists in DB");
            return;
        } else {
            PcepTunnelData pcepTunnelDBData = pcepTunnelAPIMapper.getDataFromTunnelDBQueue(tunnelId);
            plspId = pcepTunnelDBData.plspId();
        }
        tlv = new StatefulIPv4LspIdentidiersTlv((((IpTunnelEndPoint) tunnel.src()).ip().getIp4Address().toInt()), (short) 0, (short) 0, 0, (((IpTunnelEndPoint) tunnel.dst()).ip().getIp4Address().toInt()));
        llOptionalTlv.add(tlv);
        if (tunnel.tunnelName().value() != null) {
            tlv = new SymbolicPathNameTlv(tunnel.tunnelName().value().getBytes());
            llOptionalTlv.add(tlv);
        }
        // build lsp object
        PcepLspObject lspobj = pc.factory().buildLspObject().setAFlag(true).setPlspId(plspId).setOptionalTlv(llOptionalTlv).build();
        // build ero object
        PcepEroObject eroobj = pc.factory().buildEroObject().setSubObjects(llSubObjects).build();
        int iBandwidth = DEFAULT_BANDWIDTH_VALUE;
        if (tunnel.annotations().value("bandwidth") != null) {
            iBandwidth = Integer.parseInt(tunnel.annotations().value("bandwidth"));
        }
        // build bandwidth object
        PcepBandwidthObject bandwidthObject = pc.factory().buildBandwidthObject().setBandwidth(iBandwidth).build();
        // build pcep attribute
        PcepAttribute pcepAttribute = pc.factory().buildPcepAttribute().setBandwidthObject(bandwidthObject).build();
        // build pcep msg path
        PcepMsgPath msgPath = pc.factory().buildPcepMsgPath().setEroObject(eroobj).setPcepAttribute(pcepAttribute).build();
        PcepUpdateRequest updateRequest = pc.factory().buildPcepUpdateRequest().setSrpObject(srpobj).setLspObject(lspobj).setMsgPath(msgPath).build();
        llUpdateRequestList.add(updateRequest);
        PcepUpdateMsg pcUpdateMsg = pc.factory().buildUpdateMsg().setUpdateRequestList(llUpdateRequestList).build();
        pc.sendMessage(Collections.singletonList(pcUpdateMsg));
        pcepTunnelAPIMapper.addToTunnelRequestQueue(srpId, pcepTunnelData);
    } catch (PcepParseException e) {
        log.error("PcepParseException occurred while processing release tunnel {}", e.getMessage());
    }
}
#end_block

#method_before
private void handleReportMessage(int srpId, PcepLspObject lspObj) {
    ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
    PcepTunnelData pcepTunnelData = pcepTunnelAPIMapper.getDataFromTunnelRequestQueue(srpId);
    SparseAnnotations annotations = (SparseAnnotations) pcepTunnelData.tunnel().annotations();
    // store the values required from report message
    pcepTunnelData.setPlspId(lspObj.getPlspId());
    pcepTunnelData.setLspAFlag(lspObj.getAFlag());
    pcepTunnelData.setLspOFlag(lspObj.getOFlag());
    pcepTunnelData.setLspDFlag(lspObj.getDFlag());
    StatefulIPv4LspIdentidiersTlv ipv4LspTlv = null;
    ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
    while (listTlvIterator.hasNext()) {
        PcepValueType tlv = listTlvIterator.next();
        if (tlv.getType() == StatefulIPv4LspIdentidiersTlv.TYPE) {
            ipv4LspTlv = (StatefulIPv4LspIdentidiersTlv) tlv;
            break;
        }
    }
    if (null != ipv4LspTlv) {
        pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspTlv);
    }
    Path path = pcepTunnelData.path();
    Tunnel tunnel = pcepTunnelData.tunnel();
    DefaultTunnelDescription td = new DefaultTunnelDescription(tunnel.tunnelId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), providerId, tunnel.tunnelName(), path, annotations);
    if (RequestType.CREATE == pcepTunnelData.requestType()) {
        log.debug("Report received for create request");
        pcepTunnelAPIMapper.handleCreateTunnelRequestQueue(srpId, pcepTunnelData);
        if (0 == lspObj.getOFlag()) {
            log.warn("The tunnel is in down state");
        }
        tunnelAdded(td);
    }
    if (RequestType.DELETE == pcepTunnelData.requestType()) {
        log.debug("Report received for delete request");
        pcepTunnelAPIMapper.handleRemoveFromTunnelRequestQueue(srpId, pcepTunnelData);
        tunnelRemoved(td);
    }
    if (RequestType.UPDATE == pcepTunnelData.requestType()) {
        log.debug("Report received for update request");
        pcepTunnelData.setRptFlag(true);
        pcepTunnelAPIMapper.addToTunnelIdMap(pcepTunnelData);
        pcepTunnelAPIMapper.handleUpdateTunnelRequestQueue(srpId, pcepTunnelData);
        if (0 == lspObj.getOFlag()) {
            log.warn("The tunnel is in down state");
        }
        if (!(pcepTunnelAPIMapper.checkFromTunnelRequestQueue(srpId))) {
            tunnelUpdated(td);
        }
    }
}
#method_after
private void handleReportMessage(int srpId, PcepLspObject lspObj) {
    ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
    PcepTunnelData pcepTunnelData = pcepTunnelAPIMapper.getDataFromTunnelRequestQueue(srpId);
    SparseAnnotations annotations = (SparseAnnotations) pcepTunnelData.tunnel().annotations();
    // store the values required from report message
    pcepTunnelData.setPlspId(lspObj.getPlspId());
    pcepTunnelData.setLspAFlag(lspObj.getAFlag());
    pcepTunnelData.setLspOFlag(lspObj.getOFlag());
    pcepTunnelData.setLspDFlag(lspObj.getDFlag());
    StatefulIPv4LspIdentidiersTlv ipv4LspTlv = null;
    ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
    while (listTlvIterator.hasNext()) {
        PcepValueType tlv = listTlvIterator.next();
        if (tlv.getType() == StatefulIPv4LspIdentidiersTlv.TYPE) {
            ipv4LspTlv = (StatefulIPv4LspIdentidiersTlv) tlv;
            break;
        }
    }
    if (ipv4LspTlv != null) {
        pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspTlv);
    }
    Path path = pcepTunnelData.path();
    Tunnel tunnel = pcepTunnelData.tunnel();
    DefaultTunnelDescription td = new DefaultTunnelDescription(tunnel.tunnelId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), providerId, tunnel.tunnelName(), path, annotations);
    if (RequestType.CREATE == pcepTunnelData.requestType()) {
        log.debug("Report received for create request");
        pcepTunnelAPIMapper.handleCreateTunnelRequestQueue(srpId, pcepTunnelData);
        if (0 == lspObj.getOFlag()) {
            log.warn("The tunnel is in down state");
        }
        tunnelAdded(td);
    }
    if (RequestType.DELETE == pcepTunnelData.requestType()) {
        log.debug("Report received for delete request");
        pcepTunnelAPIMapper.handleRemoveFromTunnelRequestQueue(srpId, pcepTunnelData);
        tunnelRemoved(td);
    }
    if (RequestType.UPDATE == pcepTunnelData.requestType()) {
        log.debug("Report received for update request");
        pcepTunnelData.setRptFlag(true);
        pcepTunnelAPIMapper.addToTunnelIdMap(pcepTunnelData);
        pcepTunnelAPIMapper.handleUpdateTunnelRequestQueue(srpId, pcepTunnelData);
        if (0 == lspObj.getOFlag()) {
            log.warn("The tunnel is in down state");
        }
        if (!(pcepTunnelAPIMapper.checkFromTunnelRequestQueue(srpId))) {
            tunnelUpdated(td);
        }
    }
}
#end_block

#method_before
private void handleSyncReport(PcepStateReport stateRpt) {
    PcepLspObject lspObj = stateRpt.getLspObject();
    PcepStateReport.PcepMsgPath msgPath = stateRpt.getMsgPath();
    checkNotNull(msgPath);
    PcepRroObject rroObj = msgPath.getRroObject();
    checkNotNull(rroObj);
    int bandwidth = 0;
    log.debug("Handle Sync report received from PCC.");
    if (0 == lspObj.getOFlag()) {
        log.warn("The PCC reported tunnel is in down state");
    }
    log.debug("Sync report received");
    if (null != msgPath.getBandwidthObject()) {
        bandwidth = msgPath.getBandwidthObject().getBandwidth();
    }
    buildAndStorePcepTunnelData(lspObj, rroObj, bandwidth);
}
#method_after
private void handleSyncReport(PcepStateReport stateRpt) {
    PcepLspObject lspObj = stateRpt.getLspObject();
    PcepStateReport.PcepMsgPath msgPath = stateRpt.getMsgPath();
    checkNotNull(msgPath);
    PcepRroObject rroObj = msgPath.getRroObject();
    if (rroObj == null) {
        log.debug("RRO object is null in sate report");
        return;
    }
    int bandwidth = 0;
    log.debug("Handle Sync report received from PCC.");
    if (0 == lspObj.getOFlag()) {
        log.warn("The PCC reported tunnel is in down state");
    }
    log.debug("Sync report received");
    if (msgPath.getBandwidthObject() != null) {
        bandwidth = msgPath.getBandwidthObject().getBandwidth();
    }
    buildAndStorePcepTunnelData(lspObj, rroObj, bandwidth);
}
#end_block

#method_before
private void sendTunnelStatistic() {
    controller.tunnelStatisticsRequest(pcepTunnelId);
}
#method_after
private void sendTunnelStatistic() {
    controller.getTunnelStatistics(pcepTunnelId);
}
#end_block

#method_before
@Override
public int write(ChannelBuffer c) {
    int tlvStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    int tlvLenIndex = c.writerIndex();
    hLength = 0;
    c.writeShort(hLength);
    ListIterator<PcepValueType> listIterator = llNodeAttributesSubTLVs.listIterator();
    while (listIterator.hasNext()) {
        PcepValueType tlv = listIterator.next();
        tlv.write(c);
        // need to take care of padding
        int pad = tlv.getLength() % 4;
        if (0 != pad) {
            pad = 4 - pad;
            for (int i = 0; i < pad; ++i) {
                c.writeByte((byte) 0);
            }
        }
    }
    hLength = (short) (c.writerIndex() - tlvStartIndex);
    c.setShort(tlvLenIndex, (hLength - 4));
    return c.writerIndex() - tlvStartIndex;
}
#method_after
@Override
public int write(ChannelBuffer c) {
    int tlvStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    int tlvLenIndex = c.writerIndex();
    hLength = 0;
    c.writeShort(hLength);
    ListIterator<PcepValueType> listIterator = llNodeAttributesSubTLVs.listIterator();
    while (listIterator.hasNext()) {
        PcepValueType tlv = listIterator.next();
        tlv.write(c);
        // need to take care of padding
        int pad = tlv.getLength() % 4;
        if (0 != pad) {
            pad = 4 - pad;
            for (int i = 0; i < pad; ++i) {
                c.writeByte((byte) 0);
            }
        }
    }
    hLength = (short) (c.writerIndex() - tlvStartIndex);
    c.setShort(tlvLenIndex, (hLength - TLV_HEADER_LENGTH));
    return c.writerIndex() - tlvStartIndex;
}
#end_block

#method_before
@Override
public int write(ChannelBuffer c) {
    int tlvStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    int tlvLenIndex = c.writerIndex();
    hLength = 0;
    c.writeShort(0);
    ListIterator<PcepValueType> listIterator = llNodeDescriptorSubTLVs.listIterator();
    while (listIterator.hasNext()) {
        PcepValueType tlv = listIterator.next();
        if (null == tlv) {
            log.debug("TLV is null from subTlv list");
            continue;
        }
        tlv.write(c);
        // need to take care of padding
        int pad = tlv.getLength() % 4;
        if (0 != pad) {
            pad = 4 - pad;
            for (int i = 0; i < pad; ++i) {
                c.writeByte((byte) 0);
            }
        }
    }
    hLength = (short) (c.writerIndex() - tlvStartIndex);
    c.setShort(tlvLenIndex, (hLength - 4));
    return c.writerIndex() - tlvStartIndex;
}
#method_after
@Override
public int write(ChannelBuffer c) {
    int tlvStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    int tlvLenIndex = c.writerIndex();
    hLength = 0;
    c.writeShort(0);
    ListIterator<PcepValueType> listIterator = llNodeDescriptorSubTLVs.listIterator();
    while (listIterator.hasNext()) {
        PcepValueType tlv = listIterator.next();
        if (null == tlv) {
            log.debug("TLV is null from subTlv list");
            continue;
        }
        tlv.write(c);
        // need to take care of padding
        int pad = tlv.getLength() % 4;
        if (0 != pad) {
            pad = 4 - pad;
            for (int i = 0; i < pad; ++i) {
                c.writeByte((byte) 0);
            }
        }
    }
    hLength = (short) (c.writerIndex() - tlvStartIndex);
    c.setShort(tlvLenIndex, (hLength - TLV_HEADER_LENGTH));
    return c.writerIndex() - tlvStartIndex;
}
#end_block

#method_before
@Override
public int write(ChannelBuffer c) {
    int tlvStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    int tlvLenIndex = c.writerIndex();
    hLength = 0;
    c.writeShort(hLength);
    ListIterator<PcepValueType> listIterator = llLinkDescriptorsSubTLVs.listIterator();
    while (listIterator.hasNext()) {
        PcepValueType tlv = listIterator.next();
        tlv.write(c);
        // need to take care of padding
        int pad = tlv.getLength() % 4;
        if (0 != pad) {
            pad = 4 - pad;
            for (int i = 0; i < pad; ++i) {
                c.writeByte((byte) 0);
            }
        }
    }
    hLength = (short) (c.writerIndex() - tlvStartIndex);
    c.setShort(tlvLenIndex, (hLength - 4));
    return c.writerIndex() - tlvStartIndex;
}
#method_after
@Override
public int write(ChannelBuffer c) {
    int tlvStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    int tlvLenIndex = c.writerIndex();
    hLength = 0;
    c.writeShort(hLength);
    ListIterator<PcepValueType> listIterator = llLinkDescriptorsSubTLVs.listIterator();
    while (listIterator.hasNext()) {
        PcepValueType tlv = listIterator.next();
        tlv.write(c);
        // need to take care of padding
        int pad = tlv.getLength() % 4;
        if (0 != pad) {
            pad = 4 - pad;
            for (int i = 0; i < pad; ++i) {
                c.writeByte((byte) 0);
            }
        }
    }
    hLength = (short) (c.writerIndex() - tlvStartIndex);
    c.setShort(tlvLenIndex, (hLength - TLV_HEADER_LENGTH));
    return c.writerIndex() - tlvStartIndex;
}
#end_block

#method_before
@Override
public int write(ChannelBuffer c) {
    int tlvStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    int tlvLenIndex = c.writerIndex();
    hLength = 0;
    c.writeShort(hLength);
    ListIterator<PcepValueType> listIterator = llLinkAttributesSubTLVs.listIterator();
    while (listIterator.hasNext()) {
        PcepValueType tlv = listIterator.next();
        if (null == tlv) {
            log.debug("TLV is null from subTlv list");
            continue;
        }
        tlv.write(c);
        // need to take care of padding
        int pad = tlv.getLength() % 4;
        if (0 != pad) {
            pad = 4 - pad;
            for (int i = 0; i < pad; ++i) {
                c.writeByte((byte) 0);
            }
        }
    }
    hLength = (short) (c.writerIndex() - tlvStartIndex);
    c.setShort(tlvLenIndex, (hLength - 4));
    return c.writerIndex() - tlvStartIndex;
}
#method_after
@Override
public int write(ChannelBuffer c) {
    int tlvStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    int tlvLenIndex = c.writerIndex();
    hLength = 0;
    c.writeShort(hLength);
    ListIterator<PcepValueType> listIterator = llLinkAttributesSubTLVs.listIterator();
    while (listIterator.hasNext()) {
        PcepValueType tlv = listIterator.next();
        if (null == tlv) {
            log.debug("TLV is null from subTlv list");
            continue;
        }
        tlv.write(c);
        // need to take care of padding
        int pad = tlv.getLength() % 4;
        if (0 != pad) {
            pad = 4 - pad;
            for (int i = 0; i < pad; ++i) {
                c.writeByte((byte) 0);
            }
        }
    }
    hLength = (short) (c.writerIndex() - tlvStartIndex);
    c.setShort(tlvLenIndex, (hLength - TLV_HEADER_LENGTH));
    return c.writerIndex() - tlvStartIndex;
}
#end_block

#method_before
@Test
public void initiateMessageTest1() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
         * StatefulLspErrorCodeTlv, StatefulRsvpErrorSpecTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC-LIST.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0xA4, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x38, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Metric object
    0x06, // Metric object
    0x10, // Metric object
    0x00, // Metric object
    0x0c, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x02, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x01, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest1() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
         * StatefulLspErrorCodeTlv, StatefulRsvpErrorSpecTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC-LIST.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0xA4, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x38, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Metric object
    0x06, // Metric object
    0x10, // Metric object
    0x00, // Metric object
    0x0c, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x02, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x01, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest2() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
         * StatefulLspErrorCodeTlv, StatefulRsvpErrorSpecTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0xA8, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x48, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // StatefulRsvpErrorSpecTlv
    0x00, // StatefulRsvpErrorSpecTlv
    0x15, // StatefulRsvpErrorSpecTlv
    0x00, // StatefulRsvpErrorSpecTlv
    0x0c, 0x00, 0x0c, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x05, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest2() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
         * StatefulLspErrorCodeTlv, StatefulRsvpErrorSpecTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0xA8, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x48, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // StatefulRsvpErrorSpecTlv
    0x00, // StatefulRsvpErrorSpecTlv
    0x15, // StatefulRsvpErrorSpecTlv
    0x00, // StatefulRsvpErrorSpecTlv
    0x0c, 0x00, 0x0c, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x05, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest3() throws PcepParseException {
    /* SRP, LSP (StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
         * StatefulLspErrorCodeTlv, StatefulRsvpErrorSpecTlv), END-POINTS, ERO, LSPA, BANDWIDTH.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x8c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest3() throws PcepParseException {
    /* SRP, LSP (StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
         * StatefulLspErrorCodeTlv, StatefulRsvpErrorSpecTlv), END-POINTS, ERO, LSPA, BANDWIDTH.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x8c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest4() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
         * StatefulLspErrorCodeTlv, StatefulRsvpErrorSpecTlv), END-POINTS, ERO, LSPA.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest4() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
         * StatefulLspErrorCodeTlv, StatefulRsvpErrorSpecTlv), END-POINTS, ERO, LSPA.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest5() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
         * StatefulLspErrorCodeTlv), END-POINTS, ERO, LSPA.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest5() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
         * StatefulLspErrorCodeTlv), END-POINTS, ERO, LSPA.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest6() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
         * StatefulLspErrorCodeTlv), END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x8c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest6() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
         * StatefulLspErrorCodeTlv), END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x8c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest7() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
         * StatefulLspErrorCodeTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x98, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest7() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv,
         * StatefulLspErrorCodeTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x98, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest8() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv),
         * END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x90, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x30, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest8() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv),
         * END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x90, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x30, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest9() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv),
         * END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x30, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest9() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv),
         * END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x30, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest10() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv),
         * END-POINTS, ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x70, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x24, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest10() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv),
         * END-POINTS, ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x70, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x24, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest11() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv),
         * END-POINTS, ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x7C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x30, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest11() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv),
         * END-POINTS, ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x7C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x30, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest12() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv),
         * END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x78, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x24, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest12() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv),
         * END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x78, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x24, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest13() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv),
         * END-POINTS, ERO, LSPA, BANDWIDTH , METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x24, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest13() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv, SymbolicPathNameTlv, StatefulLspDbVerTlv),
         * END-POINTS, ERO, LSPA, BANDWIDTH , METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x84, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x20, 0x10, 0x00, 0x24, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x04, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x32, // SymbolicPathNameTlv
    0x33, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest14() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv),
         * END-POINTS, ERO, LSPA, BANDWIDTH , METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x7c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest14() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv),
         * END-POINTS, ERO, LSPA, BANDWIDTH , METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x7c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest15() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv),
         * END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x70, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest15() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv),
         * END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x70, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest16() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv),
         * END-POINTS, ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x68, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest16() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv),
         * END-POINTS, ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x68, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest17() throws PcepParseException {
    /* SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest17() throws PcepParseException {
    /* SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest18() throws PcepParseException {
    /* SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x68, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, 0x20, 0x10, 0x00, 0x1c, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest18() throws PcepParseException {
    /* SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x68, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, 0x20, 0x10, 0x00, 0x1c, 0x00, 0x00, 0x10, 0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest19() throws PcepParseException {
    /* SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x74, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest19() throws PcepParseException {
    /* SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x74, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest20() throws PcepParseException {
    /* SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x64, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest20() throws PcepParseException {
    /* SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x64, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest21() throws PcepParseException {
    /* SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, 0x07, 0x10, 0x00, 0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest21() throws PcepParseException {
    /* SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, 0x07, 0x10, 0x00, 0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest22() throws PcepParseException {
    /* SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest22() throws PcepParseException {
    /* SRP, LSP (StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest23() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest23() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest25() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA BANDWIDTH OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest25() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv), END-POINTS, ERO, LSPA BANDWIDTH OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest26() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv), END-POINTS,
         * ERO, LSPA, BANDWIDTH, METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x6C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // Metric object
    0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest26() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, StatefulIPv4LspIdentidiersTlv), END-POINTS,
         * ERO, LSPA, BANDWIDTH, METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x6C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1c, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // Metric object
    0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest27() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, SymbolicPathNameTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // Metric object
    0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest27() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, SymbolicPathNameTlv), END-POINTS, ERO, LSPA, BANDWIDTH, METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // Metric object
    0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest28() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, SymbolicPathNameTlv), END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest28() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, SymbolicPathNameTlv), END-POINTS, ERO, LSPA, BANDWIDTH OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest29() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, SymbolicPathNameTlv), END-POINTS, ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x4C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest29() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, SymbolicPathNameTlv), END-POINTS, ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x4C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest30() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, SymbolicPathNameTlv), END-POINTS, ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x5C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest30() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv, SymbolicPathNameTlv), END-POINTS, ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x5C, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest31() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv), END-POINTS, ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest31() throws PcepParseException {
    /* SRP, LSP (SymbolicPathNameTlv), END-POINTS, ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest32() throws PcepParseException {
    /* SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
         * ERO, LSPA, BANDWIDTH, METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x64, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // Metric object
    0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest32() throws PcepParseException {
    /* SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
         * ERO, LSPA, BANDWIDTH, METRIC OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x64, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, // Metric object
    0x01 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest33() throws PcepParseException {
    /* SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
         * ERO, LSPA, BANDWIDTH OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest33() throws PcepParseException {
    /* SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
         * ERO, LSPA, BANDWIDTH OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest34() throws PcepParseException {
    /* SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
         * ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest34() throws PcepParseException {
    /* SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
         * ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x04, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest35() throws PcepParseException {
    /* SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
         * ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest35() throws PcepParseException {
    /* SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
         * ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Test
public void initiateMessageTest36() throws PcepParseException {
    /* SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
         * ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepInitiateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#method_after
@Test
public void initiateMessageTest36() throws PcepParseException {
    /* SRP, LSP ( StatefulLspDbVerTlv), END-POINTS,
         * ERO, LSPA OBJECT.
         */
    byte[] initiateCreationMsg = new byte[] { 0x20, 0x0C, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // Endpoints Object
    0x04, // Endpoints Object
    0x12, // Endpoints Object
    0x00, // Endpoints Object
    0x0C, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x01, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // Endpoints Object
    0x02, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, // ERO object
    0x01, // ERO object
    0x08, // ERO object
    0x0C, // ERO object
    0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x08, 0x0C, 0x01, 0x01, 0x02, 0x00, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testInitiateCreationMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(initiateCreationMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepInitiateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testInitiateCreationMsg = buf.array();
    int iReadLen = buf.writerIndex();
    testInitiateCreationMsg = new byte[iReadLen];
    buf.readBytes(testInitiateCreationMsg, 0, iReadLen);
    assertThat(testInitiateCreationMsg, is(initiateCreationMsg));
}
#end_block

#method_before
@Override
public int write(ChannelBuffer c) {
    int iStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    int tlvLenIndex = c.writerIndex();
    hLength = 0;
    c.writeShort(hLength);
    if (isErrSpceObjSet) {
        rsvpErrSpecObj.write(c);
    }
    hLength = (short) (c.writerIndex() - iStartIndex);
    c.setShort(tlvLenIndex, (hLength - 4));
    return c.writerIndex() - iStartIndex;
}
#method_after
@Override
public int write(ChannelBuffer c) {
    int iStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    int tlvLenIndex = c.writerIndex();
    hLength = 0;
    c.writeShort(hLength);
    if (isErrSpceObjSet) {
        rsvpErrSpecObj.write(c);
    }
    hLength = (short) (c.writerIndex() - iStartIndex);
    c.setShort(tlvLenIndex, (hLength - OBJECT_HEADER_LENGTH));
    return c.writerIndex() - iStartIndex;
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest1() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x8c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest1() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x8c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x38, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest2() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x68, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1C, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSP object
    0x09, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest2() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x68, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1C, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSP object
    0x09, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest3() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x08, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest3() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x08, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest4() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x5c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest4() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x5c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest5() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest5() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest6() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x5c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest6() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x5c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest7() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x64, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest7() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x64, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest8() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x5c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1C, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest8() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x5c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1C, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest9() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, 0x20, 0x10, 0x00, 0x18, 0x00, 0x00, 0x10, 0x03, // StatefulRsvpErrorSpecTlv
    0x00, // StatefulRsvpErrorSpecTlv
    0x15, // StatefulRsvpErrorSpecTlv
    0x00, // StatefulRsvpErrorSpecTlv
    0x0c, 0x00, 0x0c, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x05, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest9() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, 0x20, 0x10, 0x00, 0x18, 0x00, 0x00, 0x10, 0x03, // StatefulRsvpErrorSpecTlv
    0x00, // StatefulRsvpErrorSpecTlv
    0x15, // StatefulRsvpErrorSpecTlv
    0x00, // StatefulRsvpErrorSpecTlv
    0x0c, 0x00, 0x0c, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x05, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest10() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPa object
    0x09, // LSPa object
    0x10, // LSPa object
    0x00, // LSPa object
    0x14, // LSPa object
    0x00, // LSPa object
    0x00, // LSPa object
    0x00, // LSPa object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest10() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPa object
    0x09, // LSPa object
    0x10, // LSPa object
    0x00, // LSPa object
    0x14, // LSPa object
    0x00, // LSPa object
    0x00, // LSPa object
    0x00, // LSPa object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest11() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest11() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest12() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest12() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest13() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest13() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest14() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1C, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest14() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x60, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1C, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest15() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x4c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x08, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // lspa object
    0x09, // lspa object
    0x10, // lspa object
    0x00, // lspa object
    0x14, // lspa object
    0x00, // lspa object
    0x00, // lspa object
    0x00, // lspa object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest15() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x4c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x08, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // lspa object
    0x09, // lspa object
    0x10, // lspa object
    0x00, // lspa object
    0x14, // lspa object
    0x00, // lspa object
    0x00, // lspa object
    0x00, // lspa object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest16() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest16() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest17() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest17() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x58, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest18() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest18() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest19() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x5c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, 0x09, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest19() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x5c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, 0x09, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest20() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1C, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest20() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1C, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest21() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x40, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x08, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest21() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x40, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x08, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest22() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x48, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest22() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x48, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest23() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x4c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest23() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x4c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest24() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x48, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest24() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x48, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest25() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest25() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x50, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest26() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1C, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest26() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x1C, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest27() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x34, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x08, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest27() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x34, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x08, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest28() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x40, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest28() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x40, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0c, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest29() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest29() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x54, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest30() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x48, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest30() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x48, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, 0x05, 0x20, 0x00, 0x08, 0x00, 0x00, 0x00, // Bandwidth object
    0x00 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest31() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x4c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest31() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x4c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Test
public void pcepUpdateMsgTest32() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x64, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // Metric object
    0x06, // Metric object
    0x10, // Metric object
    0x00, // Metric object
    0x0c, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x01, // Metric object
    0x03, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x20, // Metric object
    0x06, // Metric object
    0x10, // Metric object
    0x00, // Metric object
    0x0c, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x01, // Metric object
    0x03, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x20, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, sameInstance((PcepUpdateMsg) message));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#method_after
@Test
public void pcepUpdateMsgTest32() throws PcepParseException {
    byte[] updateMsg = new byte[] { 0x20, 0x0b, 0x00, (byte) 0x64, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x14, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x14, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x03, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x17, // StatefulLspDbVerTlv
    0x00, // StatefulLspDbVerTlv
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // ERO Object
    0x01, // ERO Object
    0x08, // ERO Object
    0x11, // ERO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x01, 0x04, 0x00, // Metric object
    0x06, // Metric object
    0x10, // Metric object
    0x00, // Metric object
    0x0c, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x01, // Metric object
    0x03, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x20, // Metric object
    0x06, // Metric object
    0x10, // Metric object
    0x00, // Metric object
    0x0c, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x01, // Metric object
    0x03, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x20, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric object
    0x20 };
    byte[] testupdateMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(updateMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    assertThat(message, instanceOf(PcepUpdateMsg.class));
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    testupdateMsg = buf.array();
    int readLen = buf.writerIndex() - 0;
    testupdateMsg = new byte[readLen];
    buf.readBytes(testupdateMsg, 0, readLen);
    assertThat(testupdateMsg, is(updateMsg));
}
#end_block

#method_before
@Override
public int write(ChannelBuffer c) {
    int tlvStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    int tlvLenIndex = c.writerIndex();
    hLength = 0;
    c.writeShort(hLength);
    ListIterator<PcepValueType> listIterator = llRemoteTENodeDescriptorSubTLVs.listIterator();
    while (listIterator.hasNext()) {
        PcepValueType tlv = listIterator.next();
        if (null == tlv) {
            log.debug("TLV is null from subTlv list");
            continue;
        }
        tlv.write(c);
        // need to take care of padding
        int pad = tlv.getLength() % 4;
        if (0 != pad) {
            pad = 4 - pad;
            for (int i = 0; i < pad; ++i) {
                c.writeByte((byte) 0);
            }
        }
    }
    hLength = (short) (c.writerIndex() - tlvStartIndex);
    c.setShort(tlvLenIndex, (hLength - 4));
    return c.writerIndex() - tlvStartIndex;
}
#method_after
@Override
public int write(ChannelBuffer c) {
    int tlvStartIndex = c.writerIndex();
    c.writeShort(TYPE);
    int tlvLenIndex = c.writerIndex();
    hLength = 0;
    c.writeShort(hLength);
    ListIterator<PcepValueType> listIterator = llRemoteTENodeDescriptorSubTLVs.listIterator();
    while (listIterator.hasNext()) {
        PcepValueType tlv = listIterator.next();
        if (null == tlv) {
            log.debug("TLV is null from subTlv list");
            continue;
        }
        tlv.write(c);
        // need to take care of padding
        int pad = tlv.getLength() % 4;
        if (0 != pad) {
            pad = 4 - pad;
            for (int i = 0; i < pad; ++i) {
                c.writeByte((byte) 0);
            }
        }
    }
    hLength = (short) (c.writerIndex() - tlvStartIndex);
    c.setShort(tlvLenIndex, (hLength - TLV_HEADER_LENGTH));
    return c.writerIndex() - tlvStartIndex;
}
#end_block

#method_before
private void handleSyncReport(PcepStateReport stateRpt) {
    PcepLspObject lspObj = stateRpt.getLspObject();
    PcepStateReport.PcepMsgPath msgPath = stateRpt.getMsgPath();
    checkNotNull(msgPath);
    PcepRroObject rroObj = msgPath.getRroObject();
    if (null == rroObj) {
        return;
    }
    int bandwidth = 0;
    log.debug("Handle Sync report received from PCC.");
    if (0 == lspObj.getOFlag()) {
        log.warn("The PCC reported tunnel is in down state");
    }
    log.debug("Sync report received");
    if (null != msgPath.getBandwidthObject()) {
        bandwidth = msgPath.getBandwidthObject().getBandwidth();
    }
    buildAndStorePcepTunnelData(lspObj, rroObj, bandwidth);
}
#method_after
private void handleSyncReport(PcepStateReport stateRpt) {
    PcepLspObject lspObj = stateRpt.getLspObject();
    PcepStateReport.PcepMsgPath msgPath = stateRpt.getMsgPath();
    checkNotNull(msgPath);
    PcepRroObject rroObj = msgPath.getRroObject();
    if (rroObj == null) {
        log.debug("RRO object is null in sate report");
        return;
    }
    int bandwidth = 0;
    log.debug("Handle Sync report received from PCC.");
    if (0 == lspObj.getOFlag()) {
        log.warn("The PCC reported tunnel is in down state");
    }
    log.debug("Sync report received");
    if (null != msgPath.getBandwidthObject()) {
        bandwidth = msgPath.getBandwidthObject().getBandwidth();
    }
    buildAndStorePcepTunnelData(lspObj, rroObj, bandwidth);
}
#end_block

#method_before
@Activate
public void activate() {
    vPortStore = storageService.<VirtualPortId, VirtualPort>consistentMapBuilder().withName(VIRTUALPORT).withPurgeOnUninstall().withSerializer(Serializer.using(Arrays.asList(KryoNamespaces.API), VirtualPortId.class, TenantNetworkId.class, VirtualPort.State.class, TenantId.class, AllowedAddressPair.class, FixedIp.class, BindingHostId.class, SecurityGroup.class, SubnetId.class, IpAddress.class)).build().asJavaMap();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(VTNRSC_APP);
    vPortStore = storageService.<VirtualPortId, VirtualPort>consistentMapBuilder().withName(VIRTUALPORT).withApplicationId(appId).withPurgeOnUninstall().withSerializer(Serializer.using(Arrays.asList(KryoNamespaces.API), VirtualPortId.class, TenantNetworkId.class, VirtualPort.State.class, TenantId.class, AllowedAddressPair.class, FixedIp.class, BindingHostId.class, SecurityGroup.class, SubnetId.class, IpAddress.class)).build().asJavaMap();
    log.info("Started");
}
#end_block

#method_before
@Activate
public void activate() {
    subnetStore = storageService.<SubnetId, Subnet>consistentMapBuilder().withName(SUBNET).withPurgeOnUninstall().withSerializer(Serializer.using(Arrays.asList(KryoNamespaces.API), Subnet.class, SubnetId.class, TenantNetworkId.class, TenantId.class, IpAddress.Version.class, IpPrefix.class, IpAddress.class, HostRoute.class, Subnet.Mode.class, AllocationPool.class)).build().asJavaMap();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(VTNRSC_APP);
    subnetStore = storageService.<SubnetId, Subnet>consistentMapBuilder().withName(SUBNET).withApplicationId(appId).withPurgeOnUninstall().withSerializer(Serializer.using(Arrays.asList(KryoNamespaces.API), Subnet.class, SubnetId.class, TenantNetworkId.class, TenantId.class, HostRoute.class, Subnet.Mode.class, AllocationPool.class)).build().asJavaMap();
    log.info("Started");
}
#end_block

#method_before
@Activate
public void activate() {
    networkIdAsKeyStore = storageService.<TenantNetworkId, TenantNetwork>consistentMapBuilder().withName(TENANTNETWORK).withPurgeOnUninstall().withSerializer(Serializer.using(Arrays.asList(KryoNamespaces.API), TenantNetworkId.class, TenantNetwork.State.class, TenantId.class, TenantNetwork.Type.class, PhysicalNetwork.class, SegmentationId.class)).build().asJavaMap();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(VTNRSC_APP);
    networkIdAsKeyStore = storageService.<TenantNetworkId, TenantNetwork>consistentMapBuilder().withName(TENANTNETWORK).withApplicationId(appId).withPurgeOnUninstall().withSerializer(Serializer.using(Arrays.asList(KryoNamespaces.API), TenantNetworkId.class, TenantNetwork.State.class, TenantId.class, TenantNetwork.Type.class, PhysicalNetwork.class, SegmentationId.class)).build().asJavaMap();
    log.info("Started");
}
#end_block

#method_before
public void writeTo(ChannelBuffer c) {
    c.writeShort(tpn);
    c.writeShort(tslen);
    // 10 bytes
    c.writeBytes(tsmap);
    // wirte bytes for add padding alignment (the size of bytes in tsmap must be divided in 4)
    c.writeZero(2);
}
#method_after
public void writeTo(ChannelBuffer c) {
    c.writeShort(tpn);
    c.writeShort(tslen);
    // 10 bytes
    c.writeBytes(tsmap);
    // write bytes for add padding alignment (the size of bytes in tsmap must be divided in 4)
    c.writeZero(2);
}
#end_block

#method_before
@Override
public void addOrUpdateExtraneousGroupEntry(Group group) {
    log.debug("add/update extraneous group entry {} in device {}", group.id(), group.deviceId());
    ConcurrentMap<GroupId, Group> extraneousIdTable = getExtraneousGroupIdTable(group.deviceId());
    extraneousIdTable.put(group.id(), group);
// Check the reference counter
/*if (group.referenceCount() == 0) {
            log.debug("Flow reference counter is zero and triggering remove",
                    group.id(),
                    group.deviceId());
            notifyDelegate(new GroupEvent(Type.GROUP_REMOVE_REQUESTED, group));
        }*/
}
#method_after
@Override
public void addOrUpdateExtraneousGroupEntry(Group group) {
    log.debug("add/update extraneous group entry {} in device {}", group.id(), group.deviceId());
    ConcurrentMap<GroupId, Group> extraneousIdTable = getExtraneousGroupIdTable(group.deviceId());
    extraneousIdTable.put(group.id(), group);
// Don't remove the extraneous groups, instead re-use it when
// a group request comes with the same set of buckets
}
#end_block

#method_before
@Override
public void addOrUpdateExtraneousGroupEntry(Group group) {
    log.debug("add/update extraneous group entry {} in device {}", group.id(), group.deviceId());
    ConcurrentMap<GroupId, Group> extraneousIdTable = getExtraneousGroupIdTable(group.deviceId());
    extraneousIdTable.put(group.id(), group);
// Check the reference counter
/*if (group.referenceCount() == 0) {
            log.debug("Flow reference counter is zero and triggering remove",
                    group.id(),
                    group.deviceId());
            notifyDelegate(new GroupEvent(Type.GROUP_REMOVE_REQUESTED, group));
        }*/
}
#method_after
@Override
public void addOrUpdateExtraneousGroupEntry(Group group) {
    log.debug("add/update extraneous group entry {} in device {}", group.id(), group.deviceId());
    ConcurrentMap<GroupId, Group> extraneousIdTable = getExtraneousGroupIdTable(group.deviceId());
    extraneousIdTable.put(group.id(), group);
}
#end_block

#method_before
/**
 * @deprecated in Drake.
 */
// Consider changing return value to MplsLabel
// after deprecation process so that it'll be symmetric to
@Deprecated
public Integer label() {
    return mplsLabel.toInt();
}
#method_after
/**
 * @deprecated in Drake Release.
 */
// Consider changing return value to MplsLabel
// after deprecation process so that it'll be symmetric to
@Deprecated
public Integer label() {
    return mplsLabel.toInt();
}
#end_block

#method_before
@GET
@Path("{id}")
@Produces({ MediaType.APPLICATION_JSON })
public Response getportsById(@PathParam("id") String id) {
    if (!get(VirtualPortService.class).exists(VirtualPortId.portId(id))) {
        return ok("The virtualPort does not exists").build();
    }
    VirtualPort virtualPort = nullIsNotFound(get(VirtualPortService.class).getPort(VirtualPortId.portId(id)), VPORT_NOT_FOUND);
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("ports", new VirtualPortCodec().encode(virtualPort, this));
    return ok(result.toString()).build();
}
#method_after
@GET
@Path("{id}")
@Produces({ MediaType.APPLICATION_JSON })
public Response getportsById(@PathParam("id") String id) {
    if (!get(VirtualPortService.class).exists(VirtualPortId.portId(id))) {
        return ok("The virtualPort does not exists").build();
    }
    VirtualPort virtualPort = nullIsNotFound(get(VirtualPortService.class).getPort(VirtualPortId.portId(id)), VPORT_NOT_FOUND);
    ObjectNode result = new ObjectMapper().createObjectNode();
    result.set("port", new VirtualPortCodec().encode(virtualPort, this));
    return ok(result.toString()).build();
}
#end_block

#method_before
@Override
public DeviceEvent updatePortStatistics(ProviderId providerId, DeviceId deviceId, Collection<PortStatistics> newStatsCollection) {
    Map<PortNumber, PortStatistics> prvStatsMap = devicePortStats.get(deviceId);
    Map<PortNumber, PortStatistics> newStatsMap = Maps.newHashMap();
    Map<PortNumber, PortStatistics> deltaStatsMap = Maps.newHashMap();
    if (prvStatsMap != null) {
        for (PortStatistics newStats : newStatsCollection) {
            PortNumber port = PortNumber.portNumber(newStats.port());
            PortStatistics prvStats = prvStatsMap.get(port);
            DefaultPortStatistics.Builder builder = DefaultPortStatistics.builder();
            PortStatistics deltaStats = builder.build();
            if (prvStats != null) {
                deltaStats = calcDeltaStats(deviceId, prvStats, newStats);
            }
            deltaStatsMap.put(port, deltaStats);
            newStatsMap.put(port, newStats);
        }
    } else {
        for (PortStatistics newStats : newStatsCollection) {
            PortNumber port = PortNumber.portNumber(newStats.port());
            newStatsMap.put(port, newStats);
        }
    }
    devicePortDeltaStats.put(deviceId, deltaStatsMap);
    devicePortStats.put(deviceId, newStatsMap);
    // new DeviceEvent(PORT_STATS_UPDATED,  devices.get(deviceId), null);
    return null;
}
#method_after
@Override
public DeviceEvent updatePortStatistics(ProviderId providerId, DeviceId deviceId, Collection<PortStatistics> newStatsCollection) {
    Map<PortNumber, PortStatistics> prvStatsMap = devicePortStats.get(deviceId);
    Map<PortNumber, PortStatistics> newStatsMap = Maps.newHashMap();
    Map<PortNumber, PortStatistics> deltaStatsMap = Maps.newHashMap();
    if (prvStatsMap != null) {
        for (PortStatistics newStats : newStatsCollection) {
            PortNumber port = PortNumber.portNumber(newStats.port());
            PortStatistics prvStats = prvStatsMap.get(port);
            DefaultPortStatistics.Builder builder = DefaultPortStatistics.builder();
            PortStatistics deltaStats = builder.build();
            if (prvStats != null) {
                deltaStats = calcDeltaStats(deviceId, prvStats, newStats);
            }
            deltaStatsMap.put(port, deltaStats);
            newStatsMap.put(port, newStats);
        }
    } else {
        for (PortStatistics newStats : newStatsCollection) {
            PortNumber port = PortNumber.portNumber(newStats.port());
            newStatsMap.put(port, newStats);
        }
    }
    devicePortDeltaStats.put(deviceId, deltaStatsMap);
    devicePortStats.put(deviceId, newStatsMap);
    // DeviceEvent returns null because of InternalPortStatsListener usage
    return null;
}
#end_block

#method_before
public static int create() {
    return nextSrpId();
}
#method_after
public static int create() {
    do {
        if (srpId >= MAX_SRP_ID) {
            if (SRP_ID_GEN.get() >= MAX_SRP_ID) {
                SRP_ID_GEN.set(0);
            }
        }
        srpId = SRP_ID_GEN.incrementAndGet();
    } while (srpId > MAX_SRP_ID);
    return srpId;
}
#end_block

#method_before
public void addToTunnelIdMap(PcepTunnelData pcepTunnelData) {
    int value = pcepTunnelData.getStatefulIpv4IndentifierTlv().getTunnelId() & 0xFFFF;
    tunnelIdMap.put(pcepTunnelData.getTunnel().tunnelId(), (new Integer(value)));
    log.debug("tunnelIdMap dB: " + tunnelIdMap);
    log.debug("Tunnel ID Added to tunnelIdMap");
}
#method_after
public void addToTunnelIdMap(PcepTunnelData pcepTunnelData) {
    int value = pcepTunnelData.statefulIpv4IndentifierTlv().getTunnelId() & 0xFFFF;
    tunnelIdMap.put(pcepTunnelData.tunnel().tunnelId(), (new Integer(value)));
    log.debug("Tunnel ID Added to tunnelIdMap");
}
#end_block

#method_before
public void addToCoreTunnelRequestQueue(PcepTunnelData pcepTunnelData) {
    coreTunnelRequestQueue.put(pcepTunnelData.getTunnel().tunnelId(), pcepTunnelData);
    log.debug("Tunnel Added to CoreTunnelRequestQueue");
}
#method_after
public void addToCoreTunnelRequestQueue(PcepTunnelData pcepTunnelData) {
    coreTunnelRequestQueue.put(pcepTunnelData.tunnel().tunnelId(), pcepTunnelData);
    log.debug("Tunnel Added to CoreTunnelRequestQueue");
}
#end_block

#method_before
public void removeFromCoreTunnelRequestQueue(TunnelId tunnelId) {
    coreTunnelRequestQueue.remove(tunnelId);
    log.debug("[:CREATE:]Tunnnel create response sent to core and removed from CoreTunnelRequestQueue");
}
#method_after
public void removeFromCoreTunnelRequestQueue(TunnelId tunnelId) {
    coreTunnelRequestQueue.remove(tunnelId);
    log.debug("Tunnnel create response sent to core and removed from CoreTunnelRequestQueue");
}
#end_block

#method_before
public void handleCreateTunnelRequestQueue(int srpId, PcepTunnelData pcepTunnelData) {
    log.debug("handleCreateTunnelRequestQueue");
    int value = tunnelIdMap.get(pcepTunnelData.getTunnel().tunnelId());
    tunnelDB.put(new Integer(value), pcepTunnelData);
    tunnelRequestQueue.remove(new Integer(srpId), pcepTunnelData);
    log.debug("Tunnel Added to TunnelDBQueue and removed from TunnelRequestQueue. tunnel id :" + (new Integer(value)).toString());
}
#method_after
public void handleCreateTunnelRequestQueue(int srpId, PcepTunnelData pcepTunnelData) {
    int value = tunnelIdMap.get(pcepTunnelData.tunnel().tunnelId());
    tunnelDB.put(new Integer(value), pcepTunnelData);
    tunnelRequestQueue.remove(new Integer(srpId), pcepTunnelData);
    log.debug("Tunnel Added to TunnelDBQueue and removed from TunnelRequestQueue. tunnel id {}" + (new Integer(value)).toString());
}
#end_block

#method_before
public void handleUpdateTunnelRequestQueue(int srpId, PcepTunnelData pcepTunnelData) {
    log.debug("handleUpdateTunnelRequestQueue");
    if (pcepTunnelData.getRptFlag()) {
        pcepTunnelData.setRptFlag(false);
        int value = tunnelIdMap.get(pcepTunnelData.getTunnel().tunnelId());
        tunnelDB.put(new Integer(value), pcepTunnelData);
        tunnelRequestQueue.remove(new Integer(srpId), pcepTunnelData);
        log.debug("Tunnel Added to TunnelDBQueue and removed from TunnelRequestQueue. tunnel id :" + (new Integer(value)).toString());
    } else {
        pcepTunnelData.setRptFlag(true);
        tunnelRequestQueue.put(new Integer(srpId), pcepTunnelData);
        log.debug("Tunnel updated in TunnelRequestQueue");
    }
}
#method_after
public void handleUpdateTunnelRequestQueue(int srpId, PcepTunnelData pcepTunnelData) {
    if (pcepTunnelData.rptFlag()) {
        pcepTunnelData.setRptFlag(false);
        int value = tunnelIdMap.get(pcepTunnelData.tunnel().tunnelId());
        tunnelDB.put(new Integer(value), pcepTunnelData);
        tunnelRequestQueue.remove(new Integer(srpId), pcepTunnelData);
        log.debug("Tunnel Added to TunnelDBQueue and removed from TunnelRequestQueue. tunnel id {}", (new Integer(value)).toString());
    } else {
        pcepTunnelData.setRptFlag(true);
        tunnelRequestQueue.put(new Integer(srpId), pcepTunnelData);
        log.debug("Tunnel updated in TunnelRequestQueue");
    }
}
#end_block

#method_before
public void handleRemoveFromTunnelRequestQueue(int srpId, PcepTunnelData pcepTunnelData) {
    log.debug("handleRemoveFromTunnelRequestQueue");
    int value = tunnelIdMap.get(pcepTunnelData.getTunnel().tunnelId());
    log.debug("Tunnel Removed from TunnelDBQueue,tunnelIdMap and removed from" + "TunnelRequestQueue. tunnel id :" + (new Integer(value)).toString());
    tunnelIdMap.remove(pcepTunnelData.getTunnel().tunnelId());
    tunnelDB.remove(new Integer(value));
    tunnelRequestQueue.remove(srpId);
    log.debug("Tunnel removed from  TunnelDBQueue and TunnelRequestQueue");
}
#method_after
public void handleRemoveFromTunnelRequestQueue(int srpId, PcepTunnelData pcepTunnelData) {
    int value = tunnelIdMap.get(pcepTunnelData.tunnel().tunnelId());
    tunnelIdMap.remove(pcepTunnelData.tunnel().tunnelId());
    tunnelDB.remove(new Integer(value));
    tunnelRequestQueue.remove(srpId);
    log.debug("Tunnel removed from  TunnelDBQueue and TunnelRequestQueue");
}
#end_block

#method_before
public void addPccTunnelDB(PcepTunnelData pcepTunnelData) {
    pccTunnelDB.put(pcepTunnelData.getStatefulIpv4IndentifierTlv().getTunnelId() & 0xFFFFL, pcepTunnelData.getStatefulIpv4IndentifierTlv().getIpv4IngressAddress(), pcepTunnelData);
}
#method_after
public void addPccTunnelDB(PcepTunnelData pcepTunnelData) {
    pccTunnelDB.put(pcepTunnelData.statefulIpv4IndentifierTlv().getTunnelId() & 0xFFFFL, pcepTunnelData.statefulIpv4IndentifierTlv().getIpv4IngressAddress(), pcepTunnelData);
}
#end_block

#method_before
// TODO write getter and setter methods for each attribute
public void setElementId(ElementId elementId) {
    this.elementId = elementId;
}
#method_after
public void setElementId(ElementId elementId) {
    this.elementId = elementId;
}
#end_block

#method_before
@Override
public Builder buildOpenMsg() {
    // TODO
    return null;
}
#method_after
@Override
public PcepOpenMsg.Builder buildOpenMsg() {
    return new PcepOpenMsgVer1.Builder();
}
#end_block

#method_before
@Override
public org.onosproject.pcepio.protocol.PcepOpenObject.Builder buildOpenObject() {
    // TODO
    return null;
}
#method_after
@Override
public PcepOpenObject.Builder buildOpenObject() {
    return new PcepOpenObjectVer1.Builder();
}
#end_block

#method_before
@Override
public org.onosproject.pcepio.protocol.PcepReportMsg.Builder buildReportMsg() {
    // TODO
    return null;
}
#method_after
@Override
public PcepReportMsg.Builder buildReportMsg() {
    return new PcepReportMsgVer1.Builder();
}
#end_block

#method_before
@Override
public org.onosproject.pcepio.protocol.PcepRroObject.Builder buildRroObject() {
    // TODO
    return null;
}
#method_after
@Override
public PcepRroObject.Builder buildRroObject() {
    return new PcepRroObjectVer1.Builder();
}
#end_block

#method_before
@Override
public org.onosproject.pcepio.protocol.PcepStateReport.Builder buildPcepStateReport() {
    // TODO
    return null;
}
#method_after
@Override
public PcepStateReport.Builder buildPcepStateReport() {
    return new PcepStateReportVer1.Builder();
}
#end_block

#method_before
@Override
public org.onosproject.pcepio.protocol.PcepLabelUpdateMsg.Builder buildPcepLabelUpdateMsg() {
    // TODO
    return null;
}
#method_after
@Override
public PcepLabelUpdateMsg.Builder buildPcepLabelUpdateMsg() {
    return new PcepLabelUpdateMsgVer1.Builder();
}
#end_block

#method_before
@Override
public org.onosproject.pcepio.protocol.PcepLabelUpdate.Builder buildPcepLabelUpdateObject() {
    // TODO
    return null;
}
#method_after
@Override
public PcepLabelUpdate.Builder buildPcepLabelUpdateObject() {
    return new PcepLabelUpdateVer1.Builder();
}
#end_block

#method_before
@Override
public org.onosproject.pcepio.protocol.PcepLabelObject.Builder buildLabelObject() {
    // TODO
    return null;
}
#method_after
@Override
public PcepLabelObject.Builder buildLabelObject() {
    return new PcepLabelObjectVer1.Builder();
}
#end_block

#method_before
@Override
public org.onosproject.pcepio.protocol.PcepErrorMsg.Builder buildPcepErrorMsg() {
    // TODO
    return null;
}
#method_after
@Override
public PcepErrorMsg.Builder buildPcepErrorMsg() {
    return new PcepErrorMsgVer1.Builder();
}
#end_block

#method_before
@Override
public org.onosproject.pcepio.protocol.PcepErrorObject.Builder buildPcepErrorObject() {
    // TODO
    return null;
}
#method_after
@Override
public PcepErrorObject.Builder buildPcepErrorObject() {
    return new PcepErrorObjectVer1.Builder();
}
#end_block

#method_before
@Override
public org.onosproject.pcepio.protocol.PcepFecObjectIPv4Adjacency.Builder buildFecIpv4Adjacency() {
    // TODO
    return null;
}
#method_after
@Override
public PcepFecObjectIPv4Adjacency.Builder buildFecIpv4Adjacency() {
    return new PcepFecObjectIPv4AdjacencyVer1.Builder();
}
#end_block

#method_before
@Override
public org.onosproject.pcepio.protocol.PcepErrorInfo.Builder buildPcepErrorInfo() {
    // TODO
    return null;
}
#method_after
@Override
public PcepErrorInfo.Builder buildPcepErrorInfo() {
    return new PcepErrorInfoVer1.Builder();
}
#end_block

#method_before
@Override
public org.onosproject.pcepio.protocol.PcepError.Builder buildPcepError() {
    // TODO
    return null;
}
#method_after
@Override
public PcepError.Builder buildPcepError() {
    return new PcepErrorVer1.Builder();
}
#end_block

#method_before
@Override
public void setupTunnel(Tunnel tunnel, Path path) {
    try {
        log.debug("PcepTunnelProvider::setupTunnel");
        TunnelEndPoint tsrc = tunnel.src();
        if (!(tsrc instanceof IpTunnelEndPoint)) {
            log.error("Tunnel source or destination is not valid");
            return;
        }
        // Get the pcc client
        PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tsrc).ip()));
        if (!(pc instanceof PcepClient)) {
            log.error("There is no PCC connected with ip addresss :" + ((IpTunnelEndPoint) tsrc).ip().toString());
            return;
        }
        pcepSetupTunnel(tunnel, path, pc);
    } catch (NullPointerException e) {
        log.error("NullPointerException occurred while processing setupTunnel");
        e.printStackTrace();
    } catch (Exception e) {
        log.error("Exception occurred while processing setupTunnel");
        e.printStackTrace();
    }
}
#method_after
@Override
public void setupTunnel(Tunnel tunnel, Path path) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    // Get the pcc client
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    pcepSetupTunnel(tunnel, path, pc);
}
#end_block

#method_before
@Override
public void setupTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    try {
        if (!(srcElement instanceof IpElementId)) {
            log.error("Element id is not valid");
            return;
        }
        PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
        if (!(pc instanceof PcepClient)) {
            log.error("There is no PCC connected with ip addresss :" + ((IpElementId) srcElement).ipAddress().toString());
            return;
        }
        pcepSetupTunnel(tunnel, path, pc);
    } catch (NullPointerException e) {
        log.error("NullPointerException occurred while processing setupTunnel");
        e.printStackTrace();
    } catch (Exception e) {
        log.error("Exception occurred while processing setupTunnel");
        e.printStackTrace();
    }
}
#method_after
@Override
public void setupTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    pcepSetupTunnel(tunnel, path, pc);
}
#end_block

#method_before
@Override
public void releaseTunnel(Tunnel tunnel) {
    try {
        log.debug("PcepTunnelProvider::releaseTunnel");
        TunnelEndPoint tsrc = tunnel.src();
        if (!(tsrc instanceof IpTunnelEndPoint)) {
            log.error("Tunnel source or destination is not valid");
            return;
        }
        PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tsrc).ip()));
        if (!(pc instanceof PcepClient)) {
            log.error("There is no PCC connected with ip addresss :" + ((IpTunnelEndPoint) tsrc).ip().toString());
            return;
        }
        pcepReleaseTunnel(tunnel, pc);
    } catch (NullPointerException e) {
        log.error("NullPointerException occurred while processing releaseTunnel");
        e.printStackTrace();
    } catch (Exception e) {
        log.error("Exception occurred while processing releaseTunnel");
        e.printStackTrace();
    }
}
#method_after
@Override
public void releaseTunnel(Tunnel tunnel) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    pcepReleaseTunnel(tunnel, pc);
}
#end_block

#method_before
@Override
public void releaseTunnel(ElementId srcElement, Tunnel tunnel) {
    try {
        if (!(srcElement instanceof IpElementId)) {
            log.error("Element id is not valid");
            return;
        }
        PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
        if (!(pc instanceof PcepClient)) {
            log.error("There is no PCC connected with ip addresss :" + ((IpElementId) srcElement).ipAddress().toString());
            return;
        }
        pcepReleaseTunnel(tunnel, pc);
    } catch (NullPointerException e) {
        log.error("NullPointerException occurred while processing releaseTunnel");
        e.printStackTrace();
    } catch (Exception e) {
        log.error("Exception occurred while processing releaseTunnel");
        e.printStackTrace();
    }
}
#method_after
@Override
public void releaseTunnel(ElementId srcElement, Tunnel tunnel) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    pcepReleaseTunnel(tunnel, pc);
}
#end_block

#method_before
@Override
public void updateTunnel(Tunnel tunnel, Path path) {
    try {
        // tunnel end points
        TunnelEndPoint tsrc = tunnel.src();
        if (!(tsrc instanceof IpTunnelEndPoint)) {
            log.error("Tunnel source or destination is not valid");
            return;
        }
        PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tsrc).ip()));
        if (!(pc instanceof PcepClient)) {
            log.error("There is no PCC connected with ip addresss :" + ((IpTunnelEndPoint) tsrc).ip().toString());
            return;
        }
        pcepUpdateTunnel(tunnel, path, pc);
    } catch (NullPointerException e) {
        log.error("NullPointerException occurred while processing updateTunnel");
        e.printStackTrace();
    } catch (Exception e) {
        log.error("Exception occurred while processing updateTunnel");
        e.printStackTrace();
    }
}
#method_after
@Override
public void updateTunnel(Tunnel tunnel, Path path) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    pcepUpdateTunnel(tunnel, path, pc);
}
#end_block

#method_before
@Override
public void updateTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    try {
        if (!(srcElement instanceof IpElementId)) {
            log.error("Element id is not valid");
            return;
        }
        PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
        if (!(pc instanceof PcepClient)) {
            log.error("There is no PCC connected with ip addresss :" + ((IpElementId) srcElement).ipAddress().toString());
            return;
        }
        pcepUpdateTunnel(tunnel, path, pc);
    } catch (NullPointerException e) {
        log.error("NullPointerException occurred while processing updateTunnel");
        e.printStackTrace();
    } catch (Exception e) {
        log.error("Exception occurred while processing updateTunnel");
        e.printStackTrace();
    }
}
#method_after
@Override
public void updateTunnel(ElementId srcElement, Tunnel tunnel, Path path) {
    if (tunnel.type() != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    if (!(srcElement instanceof IpElementId)) {
        log.error("Element id is not valid");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpElementId) srcElement).ipAddress()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpElementId) srcElement).ipAddress().toString());
        return;
    }
    pcepUpdateTunnel(tunnel, path, pc);
}
#end_block

#method_before
private void pcepSetupTunnel(Tunnel tunnel, Path path, PcepClient pc) {
    try {
        // tunnel end points
        TunnelEndPoint tsrc = tunnel.src();
        TunnelEndPoint tdst = tunnel.dst();
        if (!(tsrc instanceof IpTunnelEndPoint) || !(tdst instanceof IpTunnelEndPoint)) {
            log.error("Tunnel source or destination is not valid");
            return;
        }
        Type type = tunnel.type();
        String tunnelName = tunnel.tunnelName().value();
        int srpId = SrpIdGenerators.create();
        PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.CREATE);
        pcepTunnelAPIMapper.addToCoreTunnelRequestQueue(pcepTunnelData);
        PcepValueType subObj = null;
        PcepValueType tlv;
        List<Link> listLink = path.links();
        ConnectPoint source;
        ConnectPoint destination = null;
        IpAddress ipDstAddress = null;
        IpAddress ipSrcAddress = null;
        LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
        LinkedList<PcepValueType> llSubObjects = new LinkedList<PcepValueType>();
        LinkedList<PcInitiatedLspRequest> llPcInitiatedLspRequestList = new LinkedList<PcInitiatedLspRequest>();
        if (type != Tunnel.Type.MPLS) {
            log.error("Error : Tunnel Type MPLS is only supported");
            return;
        }
        for (Link link : listLink) {
            source = link.src();
            if (!(source.equals(destination))) {
                // set IPv4SubObject of ERO object
                ipSrcAddress = source.ipElementId().ipAddress();
                subObj = new IPv4SubObject(ipSrcAddress.getIp4Address().toInt());
                llSubObjects.add(subObj);
            }
            destination = link.dst();
            ipDstAddress = destination.ipElementId().ipAddress();
            subObj = new IPv4SubObject(ipDstAddress.getIp4Address().toInt());
            llSubObjects.add(subObj);
        }
        // build SRP object
        PcepSrpObject srpobj = pc.factory().buildSrpObject().setSrpID(srpId).setRFlag(false).build();
        // set LSP identifiers TLV
        tlv = new StatefulIPv4LspIdentidiersTlv((((IpTunnelEndPoint) tsrc).ip().getIp4Address().toInt()), (short) 0, (short) 0, 0, (((IpTunnelEndPoint) tdst).ip().getIp4Address().toInt()));
        llOptionalTlv.add(tlv);
        // set SymbolicPathNameTlv of LSP object
        // raw is int!
        tlv = new SymbolicPathNameTlv(tunnelName.getBytes());
        llOptionalTlv.add(tlv);
        // build LSP object
        PcepLspObject lspobj = pc.factory().buildLspObject().setAFlag(true).setOFlag((byte) 0).setPlspId(0).setOptionalTlv(llOptionalTlv).build();
        // build ENDPOINTS object
        PcepEndPointsObject endpointsobj = pc.factory().buildEndPointsObject().setSourceIpAddress(((IpTunnelEndPoint) tsrc).ip().getIp4Address().toInt()).setDestIpAddress(((IpTunnelEndPoint) tdst).ip().getIp4Address().toInt()).setPFlag(true).build();
        if (0 == llSubObjects.size()) {
            log.error("There is no link information to create tunnel");
            return;
        }
        // build ERO object
        PcepEroObject eroobj = pc.factory().buildEroObject().setSubObjects(llSubObjects).build();
        int iBandwidth = DEFAULT_BANDWIDTH_VALUE;
        if (null != tunnel.annotations().value("bandwidth")) {
            iBandwidth = Integer.parseInt(tunnel.annotations().value("bandwidth"));
        }
        PcepBandwidthObject bandwidthObject = pc.factory().buildBandwidthObject().setBandwidth(iBandwidth).build();
        PcepAttribute pcepAttribute = pc.factory().buildPcepAttribute().setBandwidthObject(bandwidthObject).build();
        PcInitiatedLspRequest initiateLspRequest = pc.factory().buildPcInitiatedLspRequest().setSrpObject(srpobj).setLspObject(lspobj).setEndPointsObject(endpointsobj).setEroObject(eroobj).setPcepAttribute(pcepAttribute).build();
        llPcInitiatedLspRequestList.add(initiateLspRequest);
        // build PCInitiate message
        PcepInitiateMsg pcInitiateMsg = pc.factory().buildPcepInitiateMsg().setPcInitiatedLspRequestList(llPcInitiatedLspRequestList).build();
        pc.sendMessage(Collections.singletonList(pcInitiateMsg));
        log.debug("PC-INITIATE MESSAGE is sent to PCC.");
        pcepTunnelAPIMapper.addToTunnelRequestQueue(srpId, pcepTunnelData);
    } catch (PcepParseException e) {
        log.error("PcepParseException occurred while processing setup tunnel");
        e.printStackTrace();
    }
}
#method_after
private void pcepSetupTunnel(Tunnel tunnel, Path path, PcepClient pc) {
    try {
        int srpId = SrpIdGenerators.create();
        PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.CREATE);
        pcepTunnelAPIMapper.addToCoreTunnelRequestQueue(pcepTunnelData);
        LinkedList<PcInitiatedLspRequest> llPcInitiatedLspRequestList = createPcInitiatedLspReqList(tunnel, path, pc, srpId);
        if (null == llPcInitiatedLspRequestList || 0 == llPcInitiatedLspRequestList.size()) {
            log.error("Failed to create PcInitiatedLspRequestList");
            return;
        }
        // build PCInitiate message
        PcepInitiateMsg pcInitiateMsg = pc.factory().buildPcepInitiateMsg().setPcInitiatedLspRequestList(llPcInitiatedLspRequestList).build();
        pc.sendMessage(Collections.singletonList(pcInitiateMsg));
        pcepTunnelAPIMapper.addToTunnelRequestQueue(srpId, pcepTunnelData);
    } catch (PcepParseException e) {
        log.error("PcepParseException occurred while processing setup tunnel {}", e.getMessage());
    }
}
#end_block

#method_before
private void pcepReleaseTunnel(Tunnel tunnel, PcepClient pc) {
    try {
        // tunnel end points
        TunnelEndPoint tsrc = tunnel.src();
        TunnelEndPoint tdst = tunnel.dst();
        if (!(tsrc instanceof IpTunnelEndPoint) || !(tdst instanceof IpTunnelEndPoint)) {
            log.error("Tunnel source or destination is not valid");
            return;
        }
        int srpId = SrpIdGenerators.create();
        PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, RequestType.DELETE);
        pcepTunnelAPIMapper.addToCoreTunnelRequestQueue(pcepTunnelData);
        Type type = tunnel.type();
        String tunnelName = tunnel.tunnelName().value();
        TunnelId tunnelId = tunnel.tunnelId();
        int plspId = 0;
        StatefulIPv4LspIdentidiersTlv statefulIpv4IndentifierTlv = null;
        if (type != Tunnel.Type.MPLS) {
            log.error("Error : Tunnel Type MPLS is only supported");
            return;
        }
        if (!(pcepTunnelAPIMapper.checkFromTunnelDBQueue(tunnelId))) {
            log.error("Error: Tunnel doesnot exists. Tunnel id :" + tunnelId.toString());
            return;
        } else {
            PcepTunnelData pcepTunnelDbData = pcepTunnelAPIMapper.getDataFromTunnelDBQueue(tunnelId);
            plspId = pcepTunnelDbData.getPlspId();
            statefulIpv4IndentifierTlv = pcepTunnelDbData.getStatefulIpv4IndentifierTlv();
            log.debug("Plsp ID in releaseTunnel " + plspId);
        }
        PcepValueType tlv;
        LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
        LinkedList<PcInitiatedLspRequest> llPcInitiatedLspRequestList = new LinkedList<PcInitiatedLspRequest>();
        PcepSrpObject srpobj = pc.factory().buildSrpObject().setSrpID(srpId).setRFlag(true).build();
        if (null != statefulIpv4IndentifierTlv) {
            tlv = statefulIpv4IndentifierTlv;
        } else {
            tlv = new StatefulIPv4LspIdentidiersTlv((((IpTunnelEndPoint) tsrc).ip().getIp4Address().toInt()), (short) 0, (short) 0, 0, (((IpTunnelEndPoint) tdst).ip().getIp4Address().toInt()));
        }
        llOptionalTlv.add(tlv);
        tlv = new SymbolicPathNameTlv(tunnelName.getBytes());
        llOptionalTlv.add(tlv);
        PcepLspObject lspobj = pc.factory().buildLspObject().setRFlag(false).setPlspId(plspId).setOptionalTlv(llOptionalTlv).build();
        PcInitiatedLspRequest releaseLspRequest = pc.factory().buildPcInitiatedLspRequest().setSrpObject(srpobj).setLspObject(lspobj).build();
        llPcInitiatedLspRequestList.add(releaseLspRequest);
        PcepInitiateMsg pcInitiateMsg = pc.factory().buildPcepInitiateMsg().setPcInitiatedLspRequestList(llPcInitiatedLspRequestList).build();
        pc.sendMessage(Collections.singletonList(pcInitiateMsg));
        log.debug("Release tunnel Message Sent");
        pcepTunnelAPIMapper.addToTunnelRequestQueue(srpId, pcepTunnelData);
    } catch (PcepParseException e) {
        log.error("PcepParseException occurred while processing release tunnel");
        e.printStackTrace();
    }
}
#method_after
private void pcepReleaseTunnel(Tunnel tunnel, PcepClient pc) {
    try {
        PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, RequestType.DELETE);
        pcepTunnelAPIMapper.addToCoreTunnelRequestQueue(pcepTunnelData);
        int srpId = SrpIdGenerators.create();
        TunnelId tunnelId = tunnel.tunnelId();
        int plspId = 0;
        StatefulIPv4LspIdentidiersTlv statefulIpv4IndentifierTlv = null;
        if (!(pcepTunnelAPIMapper.checkFromTunnelDBQueue(tunnelId))) {
            log.error("Tunnel doesnot exists. Tunnel id {}" + tunnelId.toString());
            return;
        } else {
            PcepTunnelData pcepTunnelDbData = pcepTunnelAPIMapper.getDataFromTunnelDBQueue(tunnelId);
            plspId = pcepTunnelDbData.plspId();
            statefulIpv4IndentifierTlv = pcepTunnelDbData.statefulIpv4IndentifierTlv();
        }
        // build srp object
        PcepSrpObject srpobj = pc.factory().buildSrpObject().setSrpID(srpId).setRFlag(true).build();
        PcepValueType tlv;
        LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
        LinkedList<PcInitiatedLspRequest> llPcInitiatedLspRequestList = new LinkedList<PcInitiatedLspRequest>();
        if (null != statefulIpv4IndentifierTlv) {
            tlv = statefulIpv4IndentifierTlv;
        } else {
            tlv = new StatefulIPv4LspIdentidiersTlv((((IpTunnelEndPoint) tunnel.src()).ip().getIp4Address().toInt()), (short) 0, (short) 0, 0, (((IpTunnelEndPoint) tunnel.dst()).ip().getIp4Address().toInt()));
        }
        llOptionalTlv.add(tlv);
        tlv = new SymbolicPathNameTlv(tunnel.tunnelName().value().getBytes());
        llOptionalTlv.add(tlv);
        // build lsp object, set r flag as false to delete the tunnel
        PcepLspObject lspobj = pc.factory().buildLspObject().setRFlag(false).setPlspId(plspId).setOptionalTlv(llOptionalTlv).build();
        PcInitiatedLspRequest releaseLspRequest = pc.factory().buildPcInitiatedLspRequest().setSrpObject(srpobj).setLspObject(lspobj).build();
        llPcInitiatedLspRequestList.add(releaseLspRequest);
        PcepInitiateMsg pcInitiateMsg = pc.factory().buildPcepInitiateMsg().setPcInitiatedLspRequestList(llPcInitiatedLspRequestList).build();
        pc.sendMessage(Collections.singletonList(pcInitiateMsg));
        pcepTunnelAPIMapper.addToTunnelRequestQueue(srpId, pcepTunnelData);
    } catch (PcepParseException e) {
        log.error("PcepParseException occurred while processing release tunnel {}", e.getMessage());
    }
}
#end_block

#method_before
private void pcepUpdateTunnel(Tunnel tunnel, Path path, PcepClient pc) throws PcepParseException {
    // tunnel end points
    TunnelEndPoint tsrc = tunnel.src();
    TunnelEndPoint tdst = tunnel.dst();
    if (!(tsrc instanceof IpTunnelEndPoint) || !(tdst instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    int srpId = SrpIdGenerators.create();
    PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
    pcepTunnelAPIMapper.addToCoreTunnelRequestQueue(pcepTunnelData);
    Type type = tunnel.type();
    String tunnelName = tunnel.tunnelName().value();
    TunnelId tunnelId = tunnel.tunnelId();
    ConnectPoint source;
    ConnectPoint destination = null;
    IpAddress ipDstAddress = null;
    IpAddress ipSrcAddress = null;
    PcepValueType tlv;
    PcepValueType subObj = null;
    int plspId = 0;
    List<Link> listLink = path.links();
    LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
    LinkedList<PcepValueType> llSubObjects = new LinkedList<PcepValueType>();
    LinkedList<PcepUpdateRequest> llUpdateRequestList = new LinkedList<PcepUpdateRequest>();
    if (type != Tunnel.Type.MPLS) {
        log.error("Tunnel Type MPLS is only supported");
    }
    for (Link link : listLink) {
        source = link.src();
        if (!(source.equals(destination))) {
            ipSrcAddress = source.ipElementId().ipAddress();
            subObj = new IPv4SubObject(ipSrcAddress.getIp4Address().toInt());
            llSubObjects.add(subObj);
        }
        destination = link.dst();
        ipDstAddress = destination.ipElementId().ipAddress();
        subObj = new IPv4SubObject(ipDstAddress.getIp4Address().toInt());
        llSubObjects.add(subObj);
    }
    // build SRP object
    PcepSrpObject srpobj = pc.factory().buildSrpObject().setSrpID(srpId).setRFlag(false).build();
    if (!(pcepTunnelAPIMapper.checkFromTunnelDBQueue(tunnelId))) {
        log.error("Error: Tunnel doesnot exists in DB");
    } else {
        PcepTunnelData pcepTunnelDBData = pcepTunnelAPIMapper.getDataFromTunnelDBQueue(tunnelId);
        plspId = pcepTunnelDBData.getPlspId();
    }
    PcepLspObject lspobj;
    tlv = new StatefulIPv4LspIdentidiersTlv((((IpTunnelEndPoint) tsrc).ip().getIp4Address().toInt()), (short) 0, (short) 0, 0, (((IpTunnelEndPoint) tdst).ip().getIp4Address().toInt()));
    llOptionalTlv.add(tlv);
    if (tunnelName != null) {
        tlv = new SymbolicPathNameTlv(tunnelName.getBytes());
        llOptionalTlv.add(tlv);
    }
    lspobj = pc.factory().buildLspObject().setAFlag(true).setPlspId(plspId).setOptionalTlv(llOptionalTlv).build();
    PcepEroObject eroobj = pc.factory().buildEroObject().setSubObjects(llSubObjects).build();
    int iBandwidth = DEFAULT_BANDWIDTH_VALUE;
    if (null != tunnel.annotations().value("bandwidth")) {
        iBandwidth = Integer.parseInt(tunnel.annotations().value("bandwidth"));
    }
    PcepBandwidthObject bandwidthObject = pc.factory().buildBandwidthObject().setBandwidth(iBandwidth).build();
    PcepAttribute pcepAttribute = pc.factory().buildPcepAttribute().setBandwidthObject(bandwidthObject).build();
    PcepMsgPath msgPath = pc.factory().buildPcepMsgPath().setEroObject(eroobj).setPcepAttribute(pcepAttribute).build();
    PcepUpdateRequest updateRequest = pc.factory().buildPcepUpdateRequest().setSrpObject(srpobj).setLspObject(lspobj).setMsgPath(msgPath).build();
    llUpdateRequestList.add(updateRequest);
    PcepUpdateMsg pcUpdateMsg = pc.factory().buildUpdateMsg().setUpdateRequestList(llUpdateRequestList).build();
    pc.sendMessage(Collections.singletonList(pcUpdateMsg));
    pcepTunnelAPIMapper.addToTunnelRequestQueue(srpId, pcepTunnelData);
    log.debug("UPDATE TUNNEL request sent to PCC");
}
#method_after
private void pcepUpdateTunnel(Tunnel tunnel, Path path, PcepClient pc) {
    try {
        PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, RequestType.UPDATE);
        pcepTunnelAPIMapper.addToCoreTunnelRequestQueue(pcepTunnelData);
        int srpId = SrpIdGenerators.create();
        TunnelId tunnelId = tunnel.tunnelId();
        PcepValueType tlv;
        int plspId = 0;
        LinkedList<PcepValueType> llSubObjects = createPcepPath(path);
        LinkedList<PcepValueType> llOptionalTlv = new LinkedList<PcepValueType>();
        LinkedList<PcepUpdateRequest> llUpdateRequestList = new LinkedList<PcepUpdateRequest>();
        // build SRP object
        PcepSrpObject srpobj = pc.factory().buildSrpObject().setSrpID(srpId).setRFlag(false).build();
        if (!(pcepTunnelAPIMapper.checkFromTunnelDBQueue(tunnelId))) {
            log.error("Tunnel doesnot exists in DB");
            return;
        } else {
            PcepTunnelData pcepTunnelDBData = pcepTunnelAPIMapper.getDataFromTunnelDBQueue(tunnelId);
            plspId = pcepTunnelDBData.plspId();
        }
        tlv = new StatefulIPv4LspIdentidiersTlv((((IpTunnelEndPoint) tunnel.src()).ip().getIp4Address().toInt()), (short) 0, (short) 0, 0, (((IpTunnelEndPoint) tunnel.dst()).ip().getIp4Address().toInt()));
        llOptionalTlv.add(tlv);
        if (tunnel.tunnelName().value() != null) {
            tlv = new SymbolicPathNameTlv(tunnel.tunnelName().value().getBytes());
            llOptionalTlv.add(tlv);
        }
        // build lsp object
        PcepLspObject lspobj = pc.factory().buildLspObject().setAFlag(true).setPlspId(plspId).setOptionalTlv(llOptionalTlv).build();
        // build ero object
        PcepEroObject eroobj = pc.factory().buildEroObject().setSubObjects(llSubObjects).build();
        int iBandwidth = DEFAULT_BANDWIDTH_VALUE;
        if (null != tunnel.annotations().value("bandwidth")) {
            iBandwidth = Integer.parseInt(tunnel.annotations().value("bandwidth"));
        }
        // build bandwidth object
        PcepBandwidthObject bandwidthObject = pc.factory().buildBandwidthObject().setBandwidth(iBandwidth).build();
        // build pcep attribute
        PcepAttribute pcepAttribute = pc.factory().buildPcepAttribute().setBandwidthObject(bandwidthObject).build();
        // build pcep msg path
        PcepMsgPath msgPath = pc.factory().buildPcepMsgPath().setEroObject(eroobj).setPcepAttribute(pcepAttribute).build();
        PcepUpdateRequest updateRequest = pc.factory().buildPcepUpdateRequest().setSrpObject(srpobj).setLspObject(lspobj).setMsgPath(msgPath).build();
        llUpdateRequestList.add(updateRequest);
        PcepUpdateMsg pcUpdateMsg = pc.factory().buildUpdateMsg().setUpdateRequestList(llUpdateRequestList).build();
        pc.sendMessage(Collections.singletonList(pcUpdateMsg));
        pcepTunnelAPIMapper.addToTunnelRequestQueue(srpId, pcepTunnelData);
    } catch (PcepParseException e) {
        log.error("PcepParseException occurred while processing release tunnel {}", e.getMessage());
    }
}
#end_block

#method_before
@Override
public void handleMessage(PccId pccId, PcepMessage msg) {
    try {
        log.debug("tunnel provider handle message {}", msg.getType().toString());
        switch(msg.getType()) {
            case REPORT:
                int srpId = 0;
                int plspId = 0;
                RequestType requestType;
                Tunnel tunnel;
                Path path;
                int bandwidth = 0;
                ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
                PcepTunnelData pcepTunnelData = null;
                LinkedList<PcepStateReport> llStateReportList = null;
                llStateReportList = ((PcepReportMsg) msg).getStateReportList();
                ListIterator<PcepStateReport> listIterator = llStateReportList.listIterator();
                PcepSrpObject srpObj = null;
                PcepLspObject lspObj = null;
                PcepRroObject rroObj = null;
                while (listIterator.hasNext()) {
                    PcepStateReport stateRpt = listIterator.next();
                    srpObj = stateRpt.getSrpObject();
                    lspObj = stateRpt.getLspObject();
                    PcepStateReport.PcepMsgPath msgPath = stateRpt.getMsgPath();
                    rroObj = msgPath.getRroObject();
                    if (srpObj instanceof PcepSrpObject) {
                        srpId = srpObj.getSrpID();
                    }
                    plspId = lspObj.getPlspId();
                    log.debug("Plsp ID in handle message " + plspId);
                    log.debug("SRP ID in handle message " + srpId);
                    if (!(pcepTunnelAPIMapper.checkFromTunnelRequestQueue(srpId))) {
                        // report from PCC
                        boolean sFlag;
                        sFlag = lspObj.getSFlag();
                        // Sync in progress
                        if (sFlag) {
                            if (0 == lspObj.getOFlag()) {
                                log.warn("The PCC reported tunnel is in down state");
                            }
                            log.debug("Sync report received");
                            if (null == rroObj) {
                                continue;
                            }
                            if (null != msgPath.getBandwidthObject()) {
                                bandwidth = msgPath.getBandwidthObject().getBandwidth();
                            }
                            pcepTunnelData = buildPcepTunnelData(lspObj, rroObj, bandwidth);
                            if (pcepTunnelData instanceof PcepTunnelData) {
                                pcepTunnelAPIMapper.addPccTunnelDB(pcepTunnelData);
                                pcepTunnelAPIMapper.addToTunnelIdMap(pcepTunnelData);
                            }
                        } else if (!pcepClientController.getClient(pccId).isSyncComplete()) {
                            // sync is done
                            pcepClientController.getClient(pccId).setIsSyncComplete(true);
                        }
                        continue;
                    }
                    pcepTunnelData = pcepTunnelAPIMapper.getDataFromTunnelRequestQueue(srpId);
                    requestType = pcepTunnelData.getRequestType();
                    SparseAnnotations annotations = (SparseAnnotations) pcepTunnelData.getTunnel().annotations();
                    // store the values required from report message
                    pcepTunnelData.setPlspId(plspId);
                    pcepTunnelData.setLspAFlag(lspObj.getAFlag());
                    pcepTunnelData.setLspOFlag(lspObj.getOFlag());
                    pcepTunnelData.setLspDFlag(lspObj.getDFlag());
                    StatefulIPv4LspIdentidiersTlv ipv4LspTlv = null;
                    ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
                    while (listTlvIterator.hasNext()) {
                        PcepValueType tlv = listTlvIterator.next();
                        if (tlv.getType() == StatefulIPv4LspIdentidiersTlv.TYPE) {
                            ipv4LspTlv = (StatefulIPv4LspIdentidiersTlv) tlv;
                            break;
                        }
                    }
                    if (null != ipv4LspTlv) {
                        pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspTlv);
                    }
                    path = pcepTunnelData.getPath();
                    if (RequestType.CREATE == requestType) {
                        log.debug("REPORT for INITIATE REQUEST");
                        tunnel = pcepTunnelData.getTunnel();
                        DefaultTunnelDescription td = new DefaultTunnelDescription(tunnel.tunnelId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), providerId, tunnel.tunnelName(), path, annotations);
                        pcepTunnelAPIMapper.addToTunnelIdMap(pcepTunnelData);
                        pcepTunnelAPIMapper.handleCreateTunnelRequestQueue(srpId, pcepTunnelData);
                        if (0 == lspObj.getOFlag()) {
                            log.warn("The tunnel is in down state");
                        }
                        tunnelAdded(td);
                    }
                    if (RequestType.DELETE == requestType) {
                        log.debug("REPORT FOR DELETE TUNNEL REQUEST");
                        tunnel = pcepTunnelData.getTunnel();
                        DefaultTunnelDescription td = new DefaultTunnelDescription(tunnel.tunnelId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), providerId, tunnel.tunnelName(), path, annotations);
                        pcepTunnelAPIMapper.handleRemoveFromTunnelRequestQueue(srpId, pcepTunnelData);
                        if (lspObj.getRFlag()) {
                            log.warn("The tunnel is deleted");
                        }
                        tunnelRemoved(td);
                    }
                    if (RequestType.UPDATE == requestType) {
                        log.debug("REPORT FOR UPDATE TUNNEL REQUEST");
                        tunnel = pcepTunnelData.getTunnel();
                        DefaultTunnelDescription td = new DefaultTunnelDescription(tunnel.tunnelId(), tunnel.src(), tunnel.dst(), tunnel.type(), tunnel.groupId(), providerId, tunnel.tunnelName(), path, annotations);
                        pcepTunnelData.setRptFlag(true);
                        pcepTunnelAPIMapper.addToTunnelIdMap(pcepTunnelData);
                        pcepTunnelAPIMapper.handleUpdateTunnelRequestQueue(srpId, pcepTunnelData);
                        if (0 == lspObj.getOFlag()) {
                            log.warn("The tunnel is in down state");
                        }
                        if (!(pcepTunnelAPIMapper.checkFromTunnelRequestQueue(srpId))) {
                            tunnelUpdated(td);
                        }
                    }
                }
                break;
            default:
                log.debug("Received unsupported message type {}", msg.getType().toString());
        }
    } catch (Exception e) {
        e.printStackTrace();
        log.error("Exception occured while processing report message {}");
    }
}
#method_after
@Override
public void handleMessage(PccId pccId, PcepMessage msg) {
    try {
        log.debug("tunnel provider handle message {}", msg.getType().toString());
        switch(msg.getType()) {
            case REPORT:
                int srpId = 0;
                LinkedList<PcepStateReport> llStateReportList = null;
                llStateReportList = ((PcepReportMsg) msg).getStateReportList();
                ListIterator<PcepStateReport> listIterator = llStateReportList.listIterator();
                PcepSrpObject srpObj = null;
                PcepLspObject lspObj = null;
                while (listIterator.hasNext()) {
                    PcepStateReport stateRpt = listIterator.next();
                    srpObj = stateRpt.getSrpObject();
                    lspObj = stateRpt.getLspObject();
                    if (srpObj instanceof PcepSrpObject) {
                        srpId = srpObj.getSrpID();
                    }
                    log.debug("Plsp ID in handle message " + lspObj.getPlspId());
                    log.debug("SRP ID in handle message " + srpId);
                    if (!(pcepTunnelAPIMapper.checkFromTunnelRequestQueue(srpId))) {
                        // Check the sync status
                        if (lspObj.getSFlag()) {
                            handleSyncReport(stateRpt);
                        } else if (!pcepClientController.getClient(pccId).isSyncComplete()) {
                            // sync is done
                            pcepClientController.getClient(pccId).setIsSyncComplete(true);
                        }
                        continue;
                    }
                    handleReportMessage(srpId, lspObj);
                }
                break;
            default:
                log.debug("Received unsupported message type {}", msg.getType().toString());
        }
    } catch (Exception e) {
        log.error("Exception occured while processing report message {}", e.getMessage());
    }
}
#end_block

#method_before
@Test
public void labelUpdateMessageTest1() throws PcepParseException {
    // <pce-label-download> SRP, LSP, LABEL Object
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    0x0D, // common header
    0x00, // common header
    0x24, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testLabelUpdateMsg = { 0 };
    if (message instanceof PcepLabelUpdateMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testLabelUpdateMsg = new byte[iReadLen];
        buf.readBytes(testLabelUpdateMsg, 0, iReadLen);
        if (Arrays.equals(labelUpdate, testLabelUpdateMsg)) {
            Assert.assertArrayEquals(labelUpdate, testLabelUpdateMsg);
            log.debug("Pcep Label Update Msg are equal :" + testLabelUpdateMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void labelUpdateMessageTest1() throws PcepParseException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    0x0D, // common header
    0x00, // common header
    0x24, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcepLabelUpdate", message instanceof PcepLabelUpdateMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    Assert.assertArrayEquals("PcepLabelUpdate messages are not equal", labelUpdate, testLabelUpdateMsg);
}
#end_block

#method_before
@Test
public void labelUpdateMessageTest2() throws PcepParseException {
    // <pce-label-download> SRP, LSP, LABEL Object, LABEL Object
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    0x0D, // common header
    0x00, // common header
    0x30, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testLabelUpdateMsg = { 0 };
    if (message instanceof PcepLabelUpdateMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testLabelUpdateMsg = new byte[iReadLen];
        buf.readBytes(testLabelUpdateMsg, 0, iReadLen);
        if (Arrays.equals(labelUpdate, testLabelUpdateMsg)) {
            Assert.assertArrayEquals(labelUpdate, testLabelUpdateMsg);
            log.debug("Pcep Label Update Msg are equal :" + testLabelUpdateMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void labelUpdateMessageTest2() throws PcepParseException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    0x0D, // common header
    0x00, // common header
    0x30, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcepLabelUpdate", message instanceof PcepLabelUpdateMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    Assert.assertArrayEquals("PcepLabelUpdate messages are not equal", labelUpdate, testLabelUpdateMsg);
}
#end_block

#method_before
@Test
public void labelUpdateMessageTest3() throws PcepParseException {
    // <pce-label-map> SRP, LABEL, FEC Object
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    0x0D, // common header
    0x00, // common header
    0x24, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    0x24, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0B, 0x0B };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testLabelUpdateMsg = { 0 };
    if (message instanceof PcepLabelUpdateMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testLabelUpdateMsg = new byte[iReadLen];
        buf.readBytes(testLabelUpdateMsg, 0, iReadLen);
        if (Arrays.equals(labelUpdate, testLabelUpdateMsg)) {
            Assert.assertArrayEquals(labelUpdate, testLabelUpdateMsg);
            log.debug("Pcep Label Update Msg are equal :" + testLabelUpdateMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void labelUpdateMessageTest3() throws PcepParseException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    0x0D, // common header
    0x00, // common header
    0x24, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    0x24, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0B, 0x0B };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcepLabelUpdate", message instanceof PcepLabelUpdateMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    Assert.assertArrayEquals("PcepLabelUpdate messages are not equal", labelUpdate, testLabelUpdateMsg);
}
#end_block

#method_before
@Test
public void labelUpdateMessageTest4() throws PcepParseException {
    // <pce-label-download> SRP, LSP, LABEL, LABEL, <pce-label-download> SRP, LSP, LABEL
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    0x0D, // common header
    0x00, // common header
    0x50, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x02, 0x00, 0x00, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testLabelUpdateMsg = { 0 };
    if (message instanceof PcepLabelUpdateMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testLabelUpdateMsg = new byte[iReadLen];
        buf.readBytes(testLabelUpdateMsg, 0, iReadLen);
        if (Arrays.equals(labelUpdate, testLabelUpdateMsg)) {
            Assert.assertArrayEquals(labelUpdate, testLabelUpdateMsg);
            log.debug("Pcep Label Update Msg are equal :" + testLabelUpdateMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void labelUpdateMessageTest4() throws PcepParseException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    0x0D, // common header
    0x00, // common header
    0x50, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x02, 0x00, 0x00, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcepLabelUpdate", message instanceof PcepLabelUpdateMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    Assert.assertArrayEquals("PcepLabelUpdate messages are not equal", labelUpdate, testLabelUpdateMsg);
}
#end_block

#method_before
@Test
public void labelUpdateMessageTest5() throws PcepParseException {
    // <pce-label-map> SRP, LABEL, FEC, <pce-label-map> SRP, LABEL, FEC
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    0x0D, // common header
    0x00, // common header
    0x44, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    0x24, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0B, 0x0B, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    0x24, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0C, 0x0C };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testLabelUpdateMsg = { 0 };
    if (message instanceof PcepLabelUpdateMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testLabelUpdateMsg = new byte[iReadLen];
        buf.readBytes(testLabelUpdateMsg, 0, iReadLen);
        if (Arrays.equals(labelUpdate, testLabelUpdateMsg)) {
            Assert.assertArrayEquals(labelUpdate, testLabelUpdateMsg);
            log.debug("Pcep Label Update Msg are equal :" + testLabelUpdateMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void labelUpdateMessageTest5() throws PcepParseException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    0x0D, // common header
    0x00, // common header
    0x44, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    0x24, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0B, 0x0B, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    0x24, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0C, 0x0C };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcepLabelUpdate", message instanceof PcepLabelUpdateMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    Assert.assertArrayEquals("PcepLabelUpdate messages are not equal", labelUpdate, testLabelUpdateMsg);
}
#end_block

#method_before
@Test
public void labelUpdateMessageTest6() throws PcepParseException {
    // <pce-label-download> SRP, LSP, LABEL, LABEL, <pce-label-download> SRP, LABEL, FEC
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    0x0D, // common header
    0x00, // common header
    0x50, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    0x24, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0D, 0x0D };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testLabelUpdateMsg = { 0 };
    if (message instanceof PcepLabelUpdateMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testLabelUpdateMsg = new byte[iReadLen];
        buf.readBytes(testLabelUpdateMsg, 0, iReadLen);
        if (Arrays.equals(labelUpdate, testLabelUpdateMsg)) {
            Assert.assertArrayEquals(labelUpdate, testLabelUpdateMsg);
            log.debug("Pcep Label Update Msg are equal :" + testLabelUpdateMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void labelUpdateMessageTest6() throws PcepParseException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    0x0D, // common header
    0x00, // common header
    0x50, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    0x24, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0D, 0x0D };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcepLabelUpdate", message instanceof PcepLabelUpdateMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    Assert.assertArrayEquals("PcepLabelUpdate messages are not equal", labelUpdate, testLabelUpdateMsg);
}
#end_block

#method_before
@Test
public void labelUpdateMessageTest7() throws PcepParseException {
    // <pce-label-download> SRP, LABEL, FEC, <pce-label-download> SRP, LSP, LABEL, LABEL
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    0x0D, // common header
    0x00, // common header
    0x50, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    0x24, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0D, 0x0D, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testLabelUpdateMsg = { 0 };
    if (message instanceof PcepLabelUpdateMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testLabelUpdateMsg = new byte[iReadLen];
        buf.readBytes(testLabelUpdateMsg, 0, iReadLen);
        if (Arrays.equals(labelUpdate, testLabelUpdateMsg)) {
            Assert.assertArrayEquals(labelUpdate, testLabelUpdateMsg);
            log.debug("Pcep Label Update Msg are equal :" + testLabelUpdateMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void labelUpdateMessageTest7() throws PcepParseException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    0x0D, // common header
    0x00, // common header
    0x50, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    0x24, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0D, 0x0D, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcepLabelUpdate", message instanceof PcepLabelUpdateMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    Assert.assertArrayEquals("PcepLabelUpdate messages are not equal", labelUpdate, testLabelUpdateMsg);
}
#end_block

#method_before
@Test
public void labelUpdateMessageTest8() throws PcepParseException {
    /* <pce-label-download> SRP, LABEL, FEC, <pce-label-download> SRP, LSP, LABEL, LABEL,
         * <pce-label-download> SRP, LSP, LABEL, LABEL
         */
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    0x0D, // common header
    0x00, // common header
    0x7C, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    0x24, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0D, 0x0D, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testLabelUpdateMsg = { 0 };
    if (message instanceof PcepLabelUpdateMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testLabelUpdateMsg = new byte[iReadLen];
        buf.readBytes(testLabelUpdateMsg, 0, iReadLen);
        if (Arrays.equals(labelUpdate, testLabelUpdateMsg)) {
            Assert.assertArrayEquals(labelUpdate, testLabelUpdateMsg);
            log.debug("Pcep Label Update Msg are equal :" + testLabelUpdateMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void labelUpdateMessageTest8() throws PcepParseException {
    byte[] labelUpdate = new byte[] { // common header
    0x20, // common header
    0x0D, // common header
    0x00, // common header
    0x7C, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // FEC Object Header
    0x24, // FEC Object Header
    0x10, // FEC Object Header
    0x00, // FEC Object Header
    0x08, 0x0A, 0x0A, 0x0D, 0x0D, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, // SRP Object Header
    0x21, // SRP Object Header
    0x10, // SRP Object Header
    0x00, // SRP Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // LSP Object Header
    0x20, // LSP Object Header
    0x10, // LSP Object Header
    0x00, // LSP Object Header
    0x08, 0x00, 0x01, 0x00, 0x00, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, // LABEL Object Header
    0x23, // LABEL Object Header
    0x10, // LABEL Object Header
    0x00, // LABEL Object Header
    0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(labelUpdate);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testLabelUpdateMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcepLabelUpdate", message instanceof PcepLabelUpdateMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testLabelUpdateMsg = new byte[readLen];
    buf.readBytes(testLabelUpdateMsg, 0, readLen);
    Assert.assertArrayEquals("PcepLabelUpdate messages are not equal", labelUpdate, testLabelUpdateMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest1() throws PcepParseException {
    // TE Object (Routing Universe TLV, Local TE Node Descriptors TLV(AutonomousSystemTlv))
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x28, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x24, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x0C, // AutonomousSystem Tlv
    0x00, // AutonomousSystem Tlv
    0x64, // AutonomousSystem Tlv
    0x00, // AutonomousSystem Tlv
    0x04, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest1() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x28, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x24, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x0C, // AutonomousSystem Tlv
    0x00, // AutonomousSystem Tlv
    0x64, // AutonomousSystem Tlv
    0x00, // AutonomousSystem Tlv
    0x04, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest2() throws PcepParseException {
    // TE Object (Routing Universe TLV, Local TE Node Descriptors TLV(AutonomousSystemTlv)) with different TE-ID
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x28, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x24, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x0C, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest2() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x28, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x24, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x0C, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest3() throws PcepParseException {
    // TE Object (Routing Universe TLV)
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x1c, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x18, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest3() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x1c, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x18, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest4() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x44, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x40, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest4() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x44, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x40, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest5() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x3C, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x38, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x20, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest5() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x3C, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x38, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x20, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest6() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(OSPFareaIDsubTlv, RouterIDSubTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x34, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x30, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x18, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest6() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x34, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x30, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x18, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest7() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(RouterIDSubTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x2C, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x28, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x10, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest7() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x2C, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x28, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x10, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest8() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV)
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x20, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x1C, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x04 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest8() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x20, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x1C, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x04 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest9() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), RemoteTENodeDescriptorsTLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x6C, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x68, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest9() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x6C, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x68, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest10() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), RemoteTENodeDescriptorsTLV(BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x64, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x60, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x20, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest10() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x64, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x60, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x20, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest11() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), RemoteTENodeDescriptorsTLV(OSPFareaIDsubTlv, RouterIDSubTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x5C, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x58, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x18, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest11() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x5C, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x58, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x18, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest12() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), RemoteTENodeDescriptorsTLV(RouterIDSubTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x54, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x50, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x10, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest12() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x54, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x50, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x10, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest13() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), RemoteTENodeDescriptorsTLV)
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x48, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x44, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x04 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest13() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    0x48, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    0x44, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x04 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest14() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), RemoteTENodeDescriptorsTLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), TELinkDescriptorsTLV(LinkLocalRemoteIdentifiersTlv,
         * IPv4InterfaceAddressTlv, IPv4NeighborAddressTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    (byte) 0x8C, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    (byte) 0x88, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x20, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x04, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest14() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    (byte) 0x8C, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    (byte) 0x88, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x20, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x04, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest15() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), RemoteTENodeDescriptorsTLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), TELinkDescriptorsTLV(
         * IPv4InterfaceAddressTlv, IPv4NeighborAddressTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    (byte) 0x80, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    (byte) 0x7C, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x14, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest15() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    (byte) 0x80, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    (byte) 0x7C, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x14, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest16() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), RemoteTENodeDescriptorsTLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), TELinkDescriptorsTLV(IPv4NeighborAddressTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    (byte) 0x78, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    (byte) 0x74, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x0C, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest16() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    (byte) 0x78, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    (byte) 0x74, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x0C, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest17() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), RemoteTENodeDescriptorsTLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), TELinkDescriptorsTLV)
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    (byte) 0x70, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    (byte) 0x6C, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x04 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest17() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    (byte) 0x70, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    (byte) 0x6C, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x04 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest18() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), RemoteTENodeDescriptorsTLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), TELinkDescriptorsTLV(LinkLocalRemoteIdentifiersTlv,
         * IPv4InterfaceAddressTlv, IPv4NeighborAddressTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    (byte) 0xC0, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    (byte) 0xbC, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x20, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x04, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // TENodeAttributesTlv
    0x04, // TENodeAttributesTlv
    (byte) 0xF3, // TENodeAttributesTlv
    0x00, // TENodeAttributesTlv
    0x34, // NodeFlagBitsTlv
    0x00, // NodeFlagBitsTlv
    0x0E, // NodeFlagBitsTlv
    0x00, // NodeFlagBitsTlv
    0x01, (byte) 0x90, 0x00, 0x00, 0x00, // OpaqueNodeAttributeTlv
    0x03, // OpaqueNodeAttributeTlv
    (byte) 0xE9, // OpaqueNodeAttributeTlv
    0x00, // OpaqueNodeAttributeTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameTlv
    0x03, // NodeNameTlv
    (byte) 0xEF, // NodeNameTlv
    0x00, // NodeNameTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x6B, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    (byte) 0x86, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    0x04, 0x00, 0x01, 0x01, 0x02 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest18() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    (byte) 0xC0, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    (byte) 0xbC, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x20, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x04, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // TENodeAttributesTlv
    0x04, // TENodeAttributesTlv
    (byte) 0xF3, // TENodeAttributesTlv
    0x00, // TENodeAttributesTlv
    0x34, // NodeFlagBitsTlv
    0x00, // NodeFlagBitsTlv
    0x0E, // NodeFlagBitsTlv
    0x00, // NodeFlagBitsTlv
    0x01, (byte) 0x90, 0x00, 0x00, 0x00, // OpaqueNodeAttributeTlv
    0x03, // OpaqueNodeAttributeTlv
    (byte) 0xE9, // OpaqueNodeAttributeTlv
    0x00, // OpaqueNodeAttributeTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameTlv
    0x03, // NodeNameTlv
    (byte) 0xEF, // NodeNameTlv
    0x00, // NodeNameTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x6B, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    (byte) 0x86, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    0x04, 0x00, 0x01, 0x01, 0x02 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest19() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), RemoteTENodeDescriptorsTLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), TELinkDescriptorsTLV(LinkLocalRemoteIdentifiersTlv,
         * IPv4InterfaceAddressTlv, IPv4NeighborAddressTlv), TENodeAttributesTlv(NodeFlagBitsTlv,
         *  OpaqueNodeAttributeTlv, NodeNameTlv, ISISAreaIdentifierTlv, IPv4TERouterIdOfLocalNodeTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    (byte) 0xC0, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    (byte) 0xBC, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x20, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x04, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // TENodeAttributesTlv
    0x04, // TENodeAttributesTlv
    (byte) 0xF3, // TENodeAttributesTlv
    0x00, // TENodeAttributesTlv
    0x34, // NodeFlagBitsTlv
    0x00, // NodeFlagBitsTlv
    0x0E, // NodeFlagBitsTlv
    0x00, // NodeFlagBitsTlv
    0x01, (byte) 0x90, 0x00, 0x00, 0x00, // OpaqueNodeAttributeTlv
    0x03, // OpaqueNodeAttributeTlv
    (byte) 0xE9, // OpaqueNodeAttributeTlv
    0x00, // OpaqueNodeAttributeTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameTlv
    0x03, // NodeNameTlv
    (byte) 0xEF, // NodeNameTlv
    0x00, // NodeNameTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x6B, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    (byte) 0x86, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    0x04, 0x00, 0x01, 0x01, 0x02 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest19() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    (byte) 0xC0, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    (byte) 0xBC, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x20, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x04, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // TENodeAttributesTlv
    0x04, // TENodeAttributesTlv
    (byte) 0xF3, // TENodeAttributesTlv
    0x00, // TENodeAttributesTlv
    0x34, // NodeFlagBitsTlv
    0x00, // NodeFlagBitsTlv
    0x0E, // NodeFlagBitsTlv
    0x00, // NodeFlagBitsTlv
    0x01, (byte) 0x90, 0x00, 0x00, 0x00, // OpaqueNodeAttributeTlv
    0x03, // OpaqueNodeAttributeTlv
    (byte) 0xE9, // OpaqueNodeAttributeTlv
    0x00, // OpaqueNodeAttributeTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameTlv
    0x03, // NodeNameTlv
    (byte) 0xEF, // NodeNameTlv
    0x00, // NodeNameTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x6B, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    (byte) 0x86, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    0x04, 0x00, 0x01, 0x01, 0x02 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest20() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), RemoteTENodeDescriptorsTLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), TELinkDescriptorsTLV(LinkLocalRemoteIdentifiersTlv,
         * IPv4InterfaceAddressTlv, IPv4NeighborAddressTlv), TENodeAttributesTlv(OpaqueNodeAttributeTlv,
         *  NodeNameTlv, ISISAreaIdentifierTlv, IPv4TERouterIdOfLocalNodeTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    (byte) 0xB8, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    (byte) 0xB4, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x20, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x04, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // TENodeAttributesTlv
    0x04, // TENodeAttributesTlv
    (byte) 0xF3, // TENodeAttributesTlv
    0x00, // TENodeAttributesTlv
    0x2C, // OpaqueNodeAttributeTlv
    0x03, // OpaqueNodeAttributeTlv
    (byte) 0xE9, // OpaqueNodeAttributeTlv
    0x00, // OpaqueNodeAttributeTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameTlv
    0x03, // NodeNameTlv
    (byte) 0xEF, // NodeNameTlv
    0x00, // NodeNameTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x6B, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    (byte) 0x86, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    0x04, 0x00, 0x01, 0x01, 0x02 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest20() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    (byte) 0xB8, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    (byte) 0xB4, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x20, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x04, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // TENodeAttributesTlv
    0x04, // TENodeAttributesTlv
    (byte) 0xF3, // TENodeAttributesTlv
    0x00, // TENodeAttributesTlv
    0x2C, // OpaqueNodeAttributeTlv
    0x03, // OpaqueNodeAttributeTlv
    (byte) 0xE9, // OpaqueNodeAttributeTlv
    0x00, // OpaqueNodeAttributeTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameTlv
    0x03, // NodeNameTlv
    (byte) 0xEF, // NodeNameTlv
    0x00, // NodeNameTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x6B, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    (byte) 0x86, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    0x04, 0x00, 0x01, 0x01, 0x02 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest21() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), RemoteTENodeDescriptorsTLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), TELinkDescriptorsTLV(LinkLocalRemoteIdentifiersTlv,
         * IPv4InterfaceAddressTlv, IPv4NeighborAddressTlv), TENodeAttributesTlv(OpaqueNodeAttributeTlv,
         *  ISISAreaIdentifierTlv, IPv4TERouterIdOfLocalNodeTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    (byte) 0xAC, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    (byte) 0xA8, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x20, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x04, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // TENodeAttributesTlv
    0x04, // TENodeAttributesTlv
    (byte) 0xF3, // TENodeAttributesTlv
    0x00, // TENodeAttributesTlv
    0x20, // OpaqueNodeAttributeTlv
    0x03, // OpaqueNodeAttributeTlv
    (byte) 0xE9, // OpaqueNodeAttributeTlv
    0x00, // OpaqueNodeAttributeTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x6B, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    (byte) 0x86, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    0x04, 0x00, 0x01, 0x01, 0x02 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest21() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x00, // common header
    (byte) 0xAC, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x00, // TE Object Header
    (byte) 0xA8, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x20, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x04, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // TENodeAttributesTlv
    0x04, // TENodeAttributesTlv
    (byte) 0xF3, // TENodeAttributesTlv
    0x00, // TENodeAttributesTlv
    0x20, // OpaqueNodeAttributeTlv
    0x03, // OpaqueNodeAttributeTlv
    (byte) 0xE9, // OpaqueNodeAttributeTlv
    0x00, // OpaqueNodeAttributeTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x6B, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    (byte) 0x86, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    0x04, 0x00, 0x01, 0x01, 0x02 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest22() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), RemoteTENodeDescriptorsTLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), TELinkDescriptorsTLV(LinkLocalRemoteIdentifiersTlv,
         * IPv4InterfaceAddressTlv, IPv4NeighborAddressTlv), TENodeAttributesTlv(NodeFlagBitsTlv,
         * OpaqueNodeAttributeTlv, NodeNameTlv, ISISAreaIdentifierTlv, IPv4TERouterIdOfLocalNodeTlv),
         * TELinkAttributesTlv(IPv4TERouterIdOfRemoteNodeTlv, IPv6TERouterIdofRemoteNodeTlv, AdministrativeGroupTlv,
         * MaximumLinkBandwidthTlv, MaximumReservableLinkBandwidthTlv, UnreservedBandwidthTlv, TEDefaultMetricTlv,
         * LinkProtectionTypeTlv, MPLSProtocolMaskTlv, IGPMetricTlv:, SharedRiskLinkGroupTlv,
         * OpaqueLinkAttributeTlv, LinkNameTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x01, // common header
    (byte) 0x20, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x01, // TE Object Header
    (byte) 0x1C, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x20, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x04, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // TENodeAttributesTlv
    0x04, // TENodeAttributesTlv
    (byte) 0xF3, // TENodeAttributesTlv
    0x00, // TENodeAttributesTlv
    0x2C, // OpaqueNodeAttributeTlv
    0x03, // OpaqueNodeAttributeTlv
    (byte) 0xE9, // OpaqueNodeAttributeTlv
    0x00, // OpaqueNodeAttributeTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameTlv
    0x03, // NodeNameTlv
    (byte) 0xEF, // NodeNameTlv
    0x00, // NodeNameTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x6B, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    (byte) 0x86, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    0x04, 0x00, 0x01, 0x01, 0x02, // TELinkAttributesTlv
    0x07, // TELinkAttributesTlv
    0x69, // TELinkAttributesTlv
    0x00, // TELinkAttributesTlv
    0x68, // IPv4TERouterIdOfRemoteNodeTlv
    0x05, // IPv4TERouterIdOfRemoteNodeTlv
    0x3C, // IPv4TERouterIdOfRemoteNodeTlv
    0x00, // IPv4TERouterIdOfRemoteNodeTlv
    0x04, 0x00, 0x07, 0x08, 0x00, // AdministrativeGroupTlv
    0x00, // AdministrativeGroupTlv
    0x03, // AdministrativeGroupTlv
    0x00, // AdministrativeGroupTlv
    0x04, 0x00, 0x09, 0x08, 0x00, // MaximumLinkBandwidthTlv
    0x00, // MaximumLinkBandwidthTlv
    0x09, // MaximumLinkBandwidthTlv
    0x00, // MaximumLinkBandwidthTlv
    0x04, 0x00, 0x09, 0x00, 0x00, // MaximumReservableLinkBandwidthTlv
    0x00, // MaximumReservableLinkBandwidthTlv
    0x0a, // MaximumReservableLinkBandwidthTlv
    0x00, // MaximumReservableLinkBandwidthTlv
    0x04, 0x00, 0x10, 0x00, 0x00, // UnreservedBandwidthTlv
    0x00, // UnreservedBandwidthTlv
    0x0b, // UnreservedBandwidthTlv
    0x00, // UnreservedBandwidthTlv
    0x04, 0x00, 0x00, (byte) 0x90, 0x00, // TEDefaultMetricTlv
    0x34, // TEDefaultMetricTlv
    0x58, // TEDefaultMetricTlv
    0x00, // TEDefaultMetricTlv
    0x04, 0x00, (byte) 0x99, 0x09, 0x00, // LinkProtectionTypeTlv
    0x00, // LinkProtectionTypeTlv
    0x14, // LinkProtectionTypeTlv
    0x00, // LinkProtectionTypeTlv
    0x02, 0x09, 0x00, 0x00, 0x00, // MPLSProtocolMaskTlv
    0x04, // MPLSProtocolMaskTlv
    0x46, // MPLSProtocolMaskTlv
    0x00, // MPLSProtocolMaskTlv
    0x01, (byte) 0x80, 0x00, 0x00, 0x00, // IGPMetricTlv
    0x04, // IGPMetricTlv
    0x47, // IGPMetricTlv
    0x00, // IGPMetricTlv
    0x03, 0x09, (byte) 0x89, 0x07, 0x00, // SharedRiskLinkGroupTlv
    0x04, // SharedRiskLinkGroupTlv
    0x48, // SharedRiskLinkGroupTlv
    0x00, // SharedRiskLinkGroupTlv
    0x08, 0x04, 0x47, 0x00, 0x03, // OpaqueLinkAttributeTlv
    0x04, // OpaqueLinkAttributeTlv
    0x47, // OpaqueLinkAttributeTlv
    0x00, // OpaqueLinkAttributeTlv
    0x03, 0x04, 0x49, 0x00, 0x04, 0x04, 0x47, 0x00, 0x03, // LinkNameTlv
    0x04, // LinkNameTlv
    0x4A, // LinkNameTlv
    0x00, // LinkNameTlv
    0x04, 0x04, 0x47, 0x00, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest22() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x01, // common header
    (byte) 0x20, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x01, // TE Object Header
    (byte) 0x1C, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x20, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x04, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // TENodeAttributesTlv
    0x04, // TENodeAttributesTlv
    (byte) 0xF3, // TENodeAttributesTlv
    0x00, // TENodeAttributesTlv
    0x2C, // OpaqueNodeAttributeTlv
    0x03, // OpaqueNodeAttributeTlv
    (byte) 0xE9, // OpaqueNodeAttributeTlv
    0x00, // OpaqueNodeAttributeTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameTlv
    0x03, // NodeNameTlv
    (byte) 0xEF, // NodeNameTlv
    0x00, // NodeNameTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x6B, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    (byte) 0x86, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    0x04, 0x00, 0x01, 0x01, 0x02, // TELinkAttributesTlv
    0x07, // TELinkAttributesTlv
    0x69, // TELinkAttributesTlv
    0x00, // TELinkAttributesTlv
    0x68, // IPv4TERouterIdOfRemoteNodeTlv
    0x05, // IPv4TERouterIdOfRemoteNodeTlv
    0x3C, // IPv4TERouterIdOfRemoteNodeTlv
    0x00, // IPv4TERouterIdOfRemoteNodeTlv
    0x04, 0x00, 0x07, 0x08, 0x00, // AdministrativeGroupTlv
    0x00, // AdministrativeGroupTlv
    0x03, // AdministrativeGroupTlv
    0x00, // AdministrativeGroupTlv
    0x04, 0x00, 0x09, 0x08, 0x00, // MaximumLinkBandwidthTlv
    0x00, // MaximumLinkBandwidthTlv
    0x09, // MaximumLinkBandwidthTlv
    0x00, // MaximumLinkBandwidthTlv
    0x04, 0x00, 0x09, 0x00, 0x00, // MaximumReservableLinkBandwidthTlv
    0x00, // MaximumReservableLinkBandwidthTlv
    0x0a, // MaximumReservableLinkBandwidthTlv
    0x00, // MaximumReservableLinkBandwidthTlv
    0x04, 0x00, 0x10, 0x00, 0x00, // UnreservedBandwidthTlv
    0x00, // UnreservedBandwidthTlv
    0x0b, // UnreservedBandwidthTlv
    0x00, // UnreservedBandwidthTlv
    0x04, 0x00, 0x00, (byte) 0x90, 0x00, // TEDefaultMetricTlv
    0x34, // TEDefaultMetricTlv
    0x58, // TEDefaultMetricTlv
    0x00, // TEDefaultMetricTlv
    0x04, 0x00, (byte) 0x99, 0x09, 0x00, // LinkProtectionTypeTlv
    0x00, // LinkProtectionTypeTlv
    0x14, // LinkProtectionTypeTlv
    0x00, // LinkProtectionTypeTlv
    0x02, 0x09, 0x00, 0x00, 0x00, // MPLSProtocolMaskTlv
    0x04, // MPLSProtocolMaskTlv
    0x46, // MPLSProtocolMaskTlv
    0x00, // MPLSProtocolMaskTlv
    0x01, (byte) 0x80, 0x00, 0x00, 0x00, // IGPMetricTlv
    0x04, // IGPMetricTlv
    0x47, // IGPMetricTlv
    0x00, // IGPMetricTlv
    0x03, 0x09, (byte) 0x89, 0x07, 0x00, // SharedRiskLinkGroupTlv
    0x04, // SharedRiskLinkGroupTlv
    0x48, // SharedRiskLinkGroupTlv
    0x00, // SharedRiskLinkGroupTlv
    0x08, 0x04, 0x47, 0x00, 0x03, // OpaqueLinkAttributeTlv
    0x04, // OpaqueLinkAttributeTlv
    0x47, // OpaqueLinkAttributeTlv
    0x00, // OpaqueLinkAttributeTlv
    0x03, 0x04, 0x49, 0x00, 0x04, 0x04, 0x47, 0x00, 0x03, // LinkNameTlv
    0x04, // LinkNameTlv
    0x4A, // LinkNameTlv
    0x00, // LinkNameTlv
    0x04, 0x04, 0x47, 0x00, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest23() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), RemoteTENodeDescriptorsTLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), TELinkDescriptorsTLV(LinkLocalRemoteIdentifiersTlv,
         * IPv4InterfaceAddressTlv, IPv4NeighborAddressTlv), TENodeAttributesTlv(NodeFlagBitsTlv,
         * OpaqueNodeAttributeTlv, NodeNameTlv, ISISAreaIdentifierTlv, IPv4TERouterIdOfLocalNodeTlv),
         * TELinkAttributesTlv(IPv4TERouterIdOfRemoteNodeTlv, IPv6TERouterIdofRemoteNodeTlv, AdministrativeGroupTlv,
         * MaximumLinkBandwidthTlv, MaximumReservableLinkBandwidthTlv, UnreservedBandwidthTlv, TEDefaultMetricTlv,
         * LinkProtectionTypeTlv, MPLSProtocolMaskTlv, IGPMetricTlv:, SharedRiskLinkGroupTlv,
         * OpaqueLinkAttributeTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x01, // common header
    (byte) 0x18, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x01, // TE Object Header
    (byte) 0x14, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x20, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x04, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // TENodeAttributesTlv
    0x04, // TENodeAttributesTlv
    (byte) 0xF3, // TENodeAttributesTlv
    0x00, // TENodeAttributesTlv
    0x2C, // OpaqueNodeAttributeTlv
    0x03, // OpaqueNodeAttributeTlv
    (byte) 0xE9, // OpaqueNodeAttributeTlv
    0x00, // OpaqueNodeAttributeTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameTlv
    0x03, // NodeNameTlv
    (byte) 0xEF, // NodeNameTlv
    0x00, // NodeNameTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x6B, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    (byte) 0x86, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    0x04, 0x00, 0x01, 0x01, 0x02, // TELinkAttributesTlv
    0x07, // TELinkAttributesTlv
    0x69, // TELinkAttributesTlv
    0x00, // TELinkAttributesTlv
    0x60, // IPv4TERouterIdOfRemoteNodeTlv
    0x05, // IPv4TERouterIdOfRemoteNodeTlv
    0x3C, // IPv4TERouterIdOfRemoteNodeTlv
    0x00, // IPv4TERouterIdOfRemoteNodeTlv
    0x04, 0x00, 0x07, 0x08, 0x00, // AdministrativeGroupTlv
    0x00, // AdministrativeGroupTlv
    0x03, // AdministrativeGroupTlv
    0x00, // AdministrativeGroupTlv
    0x04, 0x00, 0x09, 0x08, 0x00, // MaximumLinkBandwidthTlv
    0x00, // MaximumLinkBandwidthTlv
    0x09, // MaximumLinkBandwidthTlv
    0x00, // MaximumLinkBandwidthTlv
    0x04, 0x00, 0x09, 0x00, 0x00, // MaximumReservableLinkBandwidthTlv
    0x00, // MaximumReservableLinkBandwidthTlv
    0x0a, // MaximumReservableLinkBandwidthTlv
    0x00, // MaximumReservableLinkBandwidthTlv
    0x04, 0x00, 0x10, 0x00, 0x00, // UnreservedBandwidthTlv
    0x00, // UnreservedBandwidthTlv
    0x0b, // UnreservedBandwidthTlv
    0x00, // UnreservedBandwidthTlv
    0x04, 0x00, 0x00, (byte) 0x90, 0x00, // TEDefaultMetricTlv
    0x34, // TEDefaultMetricTlv
    0x58, // TEDefaultMetricTlv
    0x00, // TEDefaultMetricTlv
    0x04, 0x00, (byte) 0x99, 0x09, 0x00, // LinkProtectionTypeTlv
    0x00, // LinkProtectionTypeTlv
    0x14, // LinkProtectionTypeTlv
    0x00, // LinkProtectionTypeTlv
    0x02, 0x09, 0x00, 0x00, 0x00, // MPLSProtocolMaskTlv
    0x04, // MPLSProtocolMaskTlv
    0x46, // MPLSProtocolMaskTlv
    0x00, // MPLSProtocolMaskTlv
    0x01, (byte) 0x80, 0x00, 0x00, 0x00, // IGPMetricTlv
    0x04, // IGPMetricTlv
    0x47, // IGPMetricTlv
    0x00, // IGPMetricTlv
    0x03, 0x09, (byte) 0x89, 0x07, 0x00, // SharedRiskLinkGroupTlv
    0x04, // SharedRiskLinkGroupTlv
    0x48, // SharedRiskLinkGroupTlv
    0x00, // SharedRiskLinkGroupTlv
    0x08, 0x04, 0x47, 0x00, 0x03, // OpaqueLinkAttributeTlv
    0x04, // OpaqueLinkAttributeTlv
    0x47, // OpaqueLinkAttributeTlv
    0x00, // OpaqueLinkAttributeTlv
    0x03, 0x04, 0x49, 0x00, 0x04, 0x04, 0x47, 0x00, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest23() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x01, // common header
    (byte) 0x18, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x01, // TE Object Header
    (byte) 0x14, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x20, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x04, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // TENodeAttributesTlv
    0x04, // TENodeAttributesTlv
    (byte) 0xF3, // TENodeAttributesTlv
    0x00, // TENodeAttributesTlv
    0x2C, // OpaqueNodeAttributeTlv
    0x03, // OpaqueNodeAttributeTlv
    (byte) 0xE9, // OpaqueNodeAttributeTlv
    0x00, // OpaqueNodeAttributeTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameTlv
    0x03, // NodeNameTlv
    (byte) 0xEF, // NodeNameTlv
    0x00, // NodeNameTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x6B, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    (byte) 0x86, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    0x04, 0x00, 0x01, 0x01, 0x02, // TELinkAttributesTlv
    0x07, // TELinkAttributesTlv
    0x69, // TELinkAttributesTlv
    0x00, // TELinkAttributesTlv
    0x60, // IPv4TERouterIdOfRemoteNodeTlv
    0x05, // IPv4TERouterIdOfRemoteNodeTlv
    0x3C, // IPv4TERouterIdOfRemoteNodeTlv
    0x00, // IPv4TERouterIdOfRemoteNodeTlv
    0x04, 0x00, 0x07, 0x08, 0x00, // AdministrativeGroupTlv
    0x00, // AdministrativeGroupTlv
    0x03, // AdministrativeGroupTlv
    0x00, // AdministrativeGroupTlv
    0x04, 0x00, 0x09, 0x08, 0x00, // MaximumLinkBandwidthTlv
    0x00, // MaximumLinkBandwidthTlv
    0x09, // MaximumLinkBandwidthTlv
    0x00, // MaximumLinkBandwidthTlv
    0x04, 0x00, 0x09, 0x00, 0x00, // MaximumReservableLinkBandwidthTlv
    0x00, // MaximumReservableLinkBandwidthTlv
    0x0a, // MaximumReservableLinkBandwidthTlv
    0x00, // MaximumReservableLinkBandwidthTlv
    0x04, 0x00, 0x10, 0x00, 0x00, // UnreservedBandwidthTlv
    0x00, // UnreservedBandwidthTlv
    0x0b, // UnreservedBandwidthTlv
    0x00, // UnreservedBandwidthTlv
    0x04, 0x00, 0x00, (byte) 0x90, 0x00, // TEDefaultMetricTlv
    0x34, // TEDefaultMetricTlv
    0x58, // TEDefaultMetricTlv
    0x00, // TEDefaultMetricTlv
    0x04, 0x00, (byte) 0x99, 0x09, 0x00, // LinkProtectionTypeTlv
    0x00, // LinkProtectionTypeTlv
    0x14, // LinkProtectionTypeTlv
    0x00, // LinkProtectionTypeTlv
    0x02, 0x09, 0x00, 0x00, 0x00, // MPLSProtocolMaskTlv
    0x04, // MPLSProtocolMaskTlv
    0x46, // MPLSProtocolMaskTlv
    0x00, // MPLSProtocolMaskTlv
    0x01, (byte) 0x80, 0x00, 0x00, 0x00, // IGPMetricTlv
    0x04, // IGPMetricTlv
    0x47, // IGPMetricTlv
    0x00, // IGPMetricTlv
    0x03, 0x09, (byte) 0x89, 0x07, 0x00, // SharedRiskLinkGroupTlv
    0x04, // SharedRiskLinkGroupTlv
    0x48, // SharedRiskLinkGroupTlv
    0x00, // SharedRiskLinkGroupTlv
    0x08, 0x04, 0x47, 0x00, 0x03, // OpaqueLinkAttributeTlv
    0x04, // OpaqueLinkAttributeTlv
    0x47, // OpaqueLinkAttributeTlv
    0x00, // OpaqueLinkAttributeTlv
    0x03, 0x04, 0x49, 0x00, 0x04, 0x04, 0x47, 0x00, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest24() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), RemoteTENodeDescriptorsTLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), TELinkDescriptorsTLV(LinkLocalRemoteIdentifiersTlv,
         * IPv4InterfaceAddressTlv, IPv4NeighborAddressTlv), TENodeAttributesTlv(NodeFlagBitsTlv,
         * OpaqueNodeAttributeTlv, NodeNameTlv, ISISAreaIdentifierTlv, IPv4TERouterIdOfLocalNodeTlv),
         * TELinkAttributesTlv(IPv4TERouterIdOfRemoteNodeTlv, IPv6TERouterIdofRemoteNodeTlv, AdministrativeGroupTlv,
         * MaximumLinkBandwidthTlv, MaximumReservableLinkBandwidthTlv, UnreservedBandwidthTlv, TEDefaultMetricTlv,
         * LinkProtectionTypeTlv, MPLSProtocolMaskTlv, IGPMetricTlv:, SharedRiskLinkGroupTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x01, // common header
    (byte) 0x10, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x01, // TE Object Header
    (byte) 0x0C, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x20, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x04, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // TENodeAttributesTlv
    0x04, // TENodeAttributesTlv
    (byte) 0xF3, // TENodeAttributesTlv
    0x00, // TENodeAttributesTlv
    0x2C, // OpaqueNodeAttributeTlv
    0x03, // OpaqueNodeAttributeTlv
    (byte) 0xE9, // OpaqueNodeAttributeTlv
    0x00, // OpaqueNodeAttributeTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameTlv
    0x03, // NodeNameTlv
    (byte) 0xEF, // NodeNameTlv
    0x00, // NodeNameTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x6B, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    (byte) 0x86, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    0x04, 0x00, 0x01, 0x01, 0x02, // TELinkAttributesTlv
    0x07, // TELinkAttributesTlv
    0x69, // TELinkAttributesTlv
    0x00, // TELinkAttributesTlv
    0x58, // IPv4TERouterIdOfRemoteNodeTlv
    0x05, // IPv4TERouterIdOfRemoteNodeTlv
    0x3C, // IPv4TERouterIdOfRemoteNodeTlv
    0x00, // IPv4TERouterIdOfRemoteNodeTlv
    0x04, 0x00, 0x07, 0x08, 0x00, // AdministrativeGroupTlv
    0x00, // AdministrativeGroupTlv
    0x03, // AdministrativeGroupTlv
    0x00, // AdministrativeGroupTlv
    0x04, 0x00, 0x09, 0x08, 0x00, // MaximumLinkBandwidthTlv
    0x00, // MaximumLinkBandwidthTlv
    0x09, // MaximumLinkBandwidthTlv
    0x00, // MaximumLinkBandwidthTlv
    0x04, 0x00, 0x09, 0x00, 0x00, // MaximumReservableLinkBandwidthTlv
    0x00, // MaximumReservableLinkBandwidthTlv
    0x0a, // MaximumReservableLinkBandwidthTlv
    0x00, // MaximumReservableLinkBandwidthTlv
    0x04, 0x00, 0x10, 0x00, 0x00, // UnreservedBandwidthTlv
    0x00, // UnreservedBandwidthTlv
    0x0b, // UnreservedBandwidthTlv
    0x00, // UnreservedBandwidthTlv
    0x04, 0x00, 0x00, (byte) 0x90, 0x00, // TEDefaultMetricTlv
    0x34, // TEDefaultMetricTlv
    0x58, // TEDefaultMetricTlv
    0x00, // TEDefaultMetricTlv
    0x04, 0x00, (byte) 0x99, 0x09, 0x00, // LinkProtectionTypeTlv
    0x00, // LinkProtectionTypeTlv
    0x14, // LinkProtectionTypeTlv
    0x00, // LinkProtectionTypeTlv
    0x02, 0x09, 0x00, 0x00, 0x00, // MPLSProtocolMaskTlv
    0x04, // MPLSProtocolMaskTlv
    0x46, // MPLSProtocolMaskTlv
    0x00, // MPLSProtocolMaskTlv
    0x01, (byte) 0x80, 0x00, 0x00, 0x00, // IGPMetricTlv
    0x04, // IGPMetricTlv
    0x47, // IGPMetricTlv
    0x00, // IGPMetricTlv
    0x03, 0x09, (byte) 0x89, 0x07, 0x00, // SharedRiskLinkGroupTlv
    0x04, // SharedRiskLinkGroupTlv
    0x48, // SharedRiskLinkGroupTlv
    0x00, // SharedRiskLinkGroupTlv
    0x08, 0x04, 0x47, 0x00, 0x03, 0x04, 0x47, 0x00, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest24() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x01, // common header
    (byte) 0x10, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x01, // TE Object Header
    (byte) 0x0C, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x20, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x04, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // TENodeAttributesTlv
    0x04, // TENodeAttributesTlv
    (byte) 0xF3, // TENodeAttributesTlv
    0x00, // TENodeAttributesTlv
    0x2C, // OpaqueNodeAttributeTlv
    0x03, // OpaqueNodeAttributeTlv
    (byte) 0xE9, // OpaqueNodeAttributeTlv
    0x00, // OpaqueNodeAttributeTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameTlv
    0x03, // NodeNameTlv
    (byte) 0xEF, // NodeNameTlv
    0x00, // NodeNameTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x6B, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    (byte) 0x86, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    0x04, 0x00, 0x01, 0x01, 0x02, // TELinkAttributesTlv
    0x07, // TELinkAttributesTlv
    0x69, // TELinkAttributesTlv
    0x00, // TELinkAttributesTlv
    0x58, // IPv4TERouterIdOfRemoteNodeTlv
    0x05, // IPv4TERouterIdOfRemoteNodeTlv
    0x3C, // IPv4TERouterIdOfRemoteNodeTlv
    0x00, // IPv4TERouterIdOfRemoteNodeTlv
    0x04, 0x00, 0x07, 0x08, 0x00, // AdministrativeGroupTlv
    0x00, // AdministrativeGroupTlv
    0x03, // AdministrativeGroupTlv
    0x00, // AdministrativeGroupTlv
    0x04, 0x00, 0x09, 0x08, 0x00, // MaximumLinkBandwidthTlv
    0x00, // MaximumLinkBandwidthTlv
    0x09, // MaximumLinkBandwidthTlv
    0x00, // MaximumLinkBandwidthTlv
    0x04, 0x00, 0x09, 0x00, 0x00, // MaximumReservableLinkBandwidthTlv
    0x00, // MaximumReservableLinkBandwidthTlv
    0x0a, // MaximumReservableLinkBandwidthTlv
    0x00, // MaximumReservableLinkBandwidthTlv
    0x04, 0x00, 0x10, 0x00, 0x00, // UnreservedBandwidthTlv
    0x00, // UnreservedBandwidthTlv
    0x0b, // UnreservedBandwidthTlv
    0x00, // UnreservedBandwidthTlv
    0x04, 0x00, 0x00, (byte) 0x90, 0x00, // TEDefaultMetricTlv
    0x34, // TEDefaultMetricTlv
    0x58, // TEDefaultMetricTlv
    0x00, // TEDefaultMetricTlv
    0x04, 0x00, (byte) 0x99, 0x09, 0x00, // LinkProtectionTypeTlv
    0x00, // LinkProtectionTypeTlv
    0x14, // LinkProtectionTypeTlv
    0x00, // LinkProtectionTypeTlv
    0x02, 0x09, 0x00, 0x00, 0x00, // MPLSProtocolMaskTlv
    0x04, // MPLSProtocolMaskTlv
    0x46, // MPLSProtocolMaskTlv
    0x00, // MPLSProtocolMaskTlv
    0x01, (byte) 0x80, 0x00, 0x00, 0x00, // IGPMetricTlv
    0x04, // IGPMetricTlv
    0x47, // IGPMetricTlv
    0x00, // IGPMetricTlv
    0x03, 0x09, (byte) 0x89, 0x07, 0x00, // SharedRiskLinkGroupTlv
    0x04, // SharedRiskLinkGroupTlv
    0x48, // SharedRiskLinkGroupTlv
    0x00, // SharedRiskLinkGroupTlv
    0x08, 0x04, 0x47, 0x00, 0x03, 0x04, 0x47, 0x00, 0x03 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void teReportMessageTest25() throws PcepParseException {
    /* TE Object (Routing Universe TLV,Local TE Node Descriptors TLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), RemoteTENodeDescriptorsTLV(AutonomousSystemTlv, BGPLSidentifierTlv,
         * OSPFareaIDsubTlv, RouterIDSubTlv), TELinkDescriptorsTLV(LinkLocalRemoteIdentifiersTlv,
         * IPv4InterfaceAddressTlv, IPv4NeighborAddressTlv), TENodeAttributesTlv(NodeFlagBitsTlv,
         * OpaqueNodeAttributeTlv, NodeNameTlv, ISISAreaIdentifierTlv, IPv4TERouterIdOfLocalNodeTlv),
         * TELinkAttributesTlv(IPv4TERouterIdOfRemoteNodeTlv, IPv6TERouterIdofRemoteNodeTlv, AdministrativeGroupTlv,
         * MaximumLinkBandwidthTlv, MaximumReservableLinkBandwidthTlv, UnreservedBandwidthTlv, TEDefaultMetricTlv,
         * LinkProtectionTypeTlv, MPLSProtocolMaskTlv, IGPMetricTlv))
         */
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x01, // common header
    0x04, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x01, // TE Object Header
    0x00, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x20, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x04, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // TENodeAttributesTlv
    0x04, // TENodeAttributesTlv
    (byte) 0xF3, // TENodeAttributesTlv
    0x00, // TENodeAttributesTlv
    0x2C, // OpaqueNodeAttributeTlv
    0x03, // OpaqueNodeAttributeTlv
    (byte) 0xE9, // OpaqueNodeAttributeTlv
    0x00, // OpaqueNodeAttributeTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameTlv
    0x03, // NodeNameTlv
    (byte) 0xEF, // NodeNameTlv
    0x00, // NodeNameTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x6B, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    (byte) 0x86, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    0x04, 0x00, 0x01, 0x01, 0x02, // TELinkAttributesTlv
    0x07, // TELinkAttributesTlv
    0x69, // TELinkAttributesTlv
    0x00, // TELinkAttributesTlv
    0x4C, // IPv4TERouterIdOfRemoteNodeTlv
    0x05, // IPv4TERouterIdOfRemoteNodeTlv
    0x3C, // IPv4TERouterIdOfRemoteNodeTlv
    0x00, // IPv4TERouterIdOfRemoteNodeTlv
    0x04, 0x00, 0x07, 0x08, 0x00, // AdministrativeGroupTlv
    0x00, // AdministrativeGroupTlv
    0x03, // AdministrativeGroupTlv
    0x00, // AdministrativeGroupTlv
    0x04, 0x00, 0x09, 0x08, 0x00, // MaximumLinkBandwidthTlv
    0x00, // MaximumLinkBandwidthTlv
    0x09, // MaximumLinkBandwidthTlv
    0x00, // MaximumLinkBandwidthTlv
    0x04, 0x00, 0x09, 0x00, 0x00, // MaximumReservableLinkBandwidthTlv
    0x00, // MaximumReservableLinkBandwidthTlv
    0x0a, // MaximumReservableLinkBandwidthTlv
    0x00, // MaximumReservableLinkBandwidthTlv
    0x04, 0x00, 0x10, 0x00, 0x00, // UnreservedBandwidthTlv
    0x00, // UnreservedBandwidthTlv
    0x0b, // UnreservedBandwidthTlv
    0x00, // UnreservedBandwidthTlv
    0x04, 0x00, 0x00, (byte) 0x90, 0x00, // TEDefaultMetricTlv
    0x34, // TEDefaultMetricTlv
    0x58, // TEDefaultMetricTlv
    0x00, // TEDefaultMetricTlv
    0x04, 0x00, (byte) 0x99, 0x09, 0x00, // LinkProtectionTypeTlv
    0x00, // LinkProtectionTypeTlv
    0x14, // LinkProtectionTypeTlv
    0x00, // LinkProtectionTypeTlv
    0x02, 0x09, 0x00, 0x00, 0x00, // MPLSProtocolMaskTlv
    0x04, // MPLSProtocolMaskTlv
    0x46, // MPLSProtocolMaskTlv
    0x00, // MPLSProtocolMaskTlv
    0x01, (byte) 0x80, 0x00, 0x00, 0x00, // IGPMetricTlv
    0x04, // IGPMetricTlv
    0x47, // IGPMetricTlv
    0x00, // IGPMetricTlv
    0x03, 0x09, (byte) 0x89, 0x07, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    byte[] testReportMsg = { 0 };
    if (message instanceof PcepTEReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(teReportMsg, testReportMsg)) {
            // Assert.assertArrayEquals(teReportMsg, testReportMsg);
            log.debug("Pcep TE Report Msg are equal :" + teReportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void teReportMessageTest25() throws PcepParseException {
    byte[] teReportMsg = new byte[] { // common header
    0x20, // common header
    0x0E, // common header
    0x01, // common header
    0x04, // TE Object Header
    0x0E, // TE Object Header
    0x10, // TE Object Header
    0x01, // TE Object Header
    0x00, // TE-ID
    0x01, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x03, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x00, // TE-ID
    0x10, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x0E, // Routing Universe TLV
    0x00, // Routing Universe TLV
    0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // Local TE Node Descriptors TLV
    0x06, // Local TE Node Descriptors TLV
    0x65, // Local TE Node Descriptors TLV
    0x00, // Local TE Node Descriptors TLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // RemoteTENodeDescriptorsTLV
    0x03, // RemoteTENodeDescriptorsTLV
    (byte) 0xEB, // RemoteTENodeDescriptorsTLV
    0x00, // RemoteTENodeDescriptorsTLV
    0x28, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x64, // AutonomousSystemTlv
    0x00, // AutonomousSystemTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x11, // BGPLSidentifierTlv
    0x00, // BGPLSidentifierTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // OSPFareaIDsubTlv
    0x02, // OSPFareaIDsubTlv
    0x58, // OSPFareaIDsubTlv
    0x00, // OSPFareaIDsubTlv
    0x04, 0x00, 0x00, 0x00, 0x11, // RouterIDSubTlv
    0x03, // RouterIDSubTlv
    (byte) 0xE8, // RouterIDSubTlv
    0x00, // RouterIDSubTlv
    0x08, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x11, // TELinkDescriptorsTLV
    0x04, // TELinkDescriptorsTLV
    0x2E, // TELinkDescriptorsTLV
    0x00, // TELinkDescriptorsTLV
    0x20, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x04, // LinkLocalRemoteIdentifiersTlv
    0x00, // LinkLocalRemoteIdentifiersTlv
    0x08, 0x01, 0x11, 0x00, 0x09, 0x01, 0x21, 0x00, 0x09, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x06, // IPv4InterfaceAddressTlv
    0x00, // IPv4InterfaceAddressTlv
    0x04, 0x01, 0x01, 0x01, 0x01, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x08, // IPv4NeighborAddressTlv
    0x00, // IPv4NeighborAddressTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // TENodeAttributesTlv
    0x04, // TENodeAttributesTlv
    (byte) 0xF3, // TENodeAttributesTlv
    0x00, // TENodeAttributesTlv
    0x2C, // OpaqueNodeAttributeTlv
    0x03, // OpaqueNodeAttributeTlv
    (byte) 0xE9, // OpaqueNodeAttributeTlv
    0x00, // OpaqueNodeAttributeTlv
    0x04, 0x01, 0x011, 0x01, 0x10, // NodeNameTlv
    0x03, // NodeNameTlv
    (byte) 0xEF, // NodeNameTlv
    0x00, // NodeNameTlv
    0x08, 0x08, 0x00, 0x01, 0x09, 0x08, 0x00, 0x01, 0x09, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x6B, // ISISAreaIdentifierTlv
    0x00, // ISISAreaIdentifierTlv
    0x08, 0x20, 0x01, 0x22, 0x01, 0x20, 0x01, 0x22, 0x01, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    (byte) 0x86, // IPv4TERouterIdOfLocalNodeTlv
    0x00, // IPv4TERouterIdOfLocalNodeTlv
    0x04, 0x00, 0x01, 0x01, 0x02, // TELinkAttributesTlv
    0x07, // TELinkAttributesTlv
    0x69, // TELinkAttributesTlv
    0x00, // TELinkAttributesTlv
    0x4C, // IPv4TERouterIdOfRemoteNodeTlv
    0x05, // IPv4TERouterIdOfRemoteNodeTlv
    0x3C, // IPv4TERouterIdOfRemoteNodeTlv
    0x00, // IPv4TERouterIdOfRemoteNodeTlv
    0x04, 0x00, 0x07, 0x08, 0x00, // AdministrativeGroupTlv
    0x00, // AdministrativeGroupTlv
    0x03, // AdministrativeGroupTlv
    0x00, // AdministrativeGroupTlv
    0x04, 0x00, 0x09, 0x08, 0x00, // MaximumLinkBandwidthTlv
    0x00, // MaximumLinkBandwidthTlv
    0x09, // MaximumLinkBandwidthTlv
    0x00, // MaximumLinkBandwidthTlv
    0x04, 0x00, 0x09, 0x00, 0x00, // MaximumReservableLinkBandwidthTlv
    0x00, // MaximumReservableLinkBandwidthTlv
    0x0a, // MaximumReservableLinkBandwidthTlv
    0x00, // MaximumReservableLinkBandwidthTlv
    0x04, 0x00, 0x10, 0x00, 0x00, // UnreservedBandwidthTlv
    0x00, // UnreservedBandwidthTlv
    0x0b, // UnreservedBandwidthTlv
    0x00, // UnreservedBandwidthTlv
    0x04, 0x00, 0x00, (byte) 0x90, 0x00, // TEDefaultMetricTlv
    0x34, // TEDefaultMetricTlv
    0x58, // TEDefaultMetricTlv
    0x00, // TEDefaultMetricTlv
    0x04, 0x00, (byte) 0x99, 0x09, 0x00, // LinkProtectionTypeTlv
    0x00, // LinkProtectionTypeTlv
    0x14, // LinkProtectionTypeTlv
    0x00, // LinkProtectionTypeTlv
    0x02, 0x09, 0x00, 0x00, 0x00, // MPLSProtocolMaskTlv
    0x04, // MPLSProtocolMaskTlv
    0x46, // MPLSProtocolMaskTlv
    0x00, // MPLSProtocolMaskTlv
    0x01, (byte) 0x80, 0x00, 0x00, 0x00, // IGPMetricTlv
    0x04, // IGPMetricTlv
    0x47, // IGPMetricTlv
    0x00, // IGPMetricTlv
    0x03, 0x09, (byte) 0x89, 0x07, 0x00 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(teReportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    byte[] testReportMsg = { 0 };
    Assert.assertTrue("PcepMessage is not instance of PcTERpt", message instanceof PcepTEReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcTERpt messages are not equal", teReportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest39() throws PcepParseException {
    // srp,lsp,ero,srp,lsp,ero,lspa,bandwidth,metric-list,rro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x98, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object //LSP object
    0x20, // LSP object //LSP object
    0x10, // LSP object //LSP object
    0x00, // LSP object //LSP object
    0x10, // LSP object //LSP object
    0x00, // LSP object //LSP object
    0x00, // LSP object //LSP object
    0x10, // LSP object //LSP object
    (byte) 0x83, // symoblic path tlv
    0x00, // symoblic path tlv
    0x11, // symoblic path tlv
    0x00, // symoblic path tlv
    0x02, // symoblic path tlv
    0x54, // symoblic path tlv
    0x31, // symoblic path tlv
    0x00, // symoblic path tlv
    0x00, // ERO object //ERO object
    0x07, // ERO object //ERO object
    0x10, // ERO object //ERO object
    0x00, // ERO object //ERO object
    0x14, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object //LSP object
    0x20, // LSP object //LSP object
    0x10, // LSP object //LSP object
    0x00, // LSP object //LSP object
    0x10, // LSP object //LSP object
    0x00, // LSP object //LSP object
    0x00, // LSP object //LSP object
    0x10, // LSP object //LSP object
    (byte) 0x83, // symoblic path tlv
    0x00, // symoblic path tlv
    0x11, // symoblic path tlv
    0x00, // symoblic path tlv
    0x02, // symoblic path tlv
    0x54, // symoblic path tlv
    0x31, // symoblic path tlv
    0x00, // symoblic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO object
    0x01, // RRO object
    0x08, // RRO object
    0x11, // RRO object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest39() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x98, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    (byte) 0x83, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    (byte) 0x83, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO object
    0x01, // RRO object
    0x08, // RRO object
    0x11, // RRO object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest40() throws PcepParseException {
    // srp,lsp,ero,srp,lsp,ero
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x64, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    (byte) 0x83, // symoblic path tlv
    0x00, // symoblic path tlv
    0x11, // symoblic path tlv
    0x00, // symoblic path tlv
    0x02, // symoblic path tlv
    0x54, // symoblic path tlv
    0x31, // symoblic path tlv
    0x00, // symoblic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    (byte) 0x83, // symoblic path tlv
    0x00, // symoblic path tlv
    0x11, // symoblic path tlv
    0x00, // symoblic path tlv
    0x02, // symoblic path tlv
    0x54, // symoblic path tlv
    0x31, // symoblic path tlv
    0x00, // symoblic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest40() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x64, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    (byte) 0x83, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    (byte) 0x83, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest41() throws PcepParseException {
    // srp,lsp,ero,lspa,srp,lsp,ero,lspa
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x8c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    (byte) 0x83, // symoblic path tlv
    0x00, // symoblic path tlv
    0x11, // symoblic path tlv
    0x00, // symoblic path tlv
    0x02, // symoblic path tlv
    0x54, // symoblic path tlv
    0x31, // symoblic path tlv
    0x00, // symoblic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    (byte) 0x83, // symoblic path tlv
    0x00, // symoblic path tlv
    0x11, // symoblic path tlv
    0x00, // symoblic path tlv
    0x02, // symoblic path tlv
    0x54, // symoblic path tlv
    0x31, // symoblic path tlv
    0x00, // symoblic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest41() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x8c, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    (byte) 0x83, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    (byte) 0x83, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest42() throws PcepParseException {
    // srp,lsp,ero,lspa,bandwidth,metric-list,srp,lsp,ero,lspa,bandwidth,metric-list,rro,
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0xE8, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    (byte) 0x83, // symoblic path tlv
    0x00, // symoblic path tlv
    0x11, // symoblic path tlv
    0x00, // symoblic path tlv
    0x02, // symoblic path tlv
    0x54, // symoblic path tlv
    0x31, // symoblic path tlv
    0x00, // symoblic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Metric object
    0x06, // Metric object
    0x10, // Metric object
    0x00, // Metric object
    0x0c, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x01, // Metric object
    0x03, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x20, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    (byte) 0x83, // symoblic path tlv
    0x00, // symoblic path tlv
    0x11, // symoblic path tlv
    0x00, // symoblic path tlv
    0x02, // symoblic path tlv
    0x54, // symoblic path tlv
    0x31, // symoblic path tlv
    0x00, // symoblic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Metric object
    0x06, // Metric object
    0x10, // Metric object
    0x00, // Metric object
    0x0c, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x01, // Metric object
    0x03, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x20, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO object
    0x01, // RRO object
    0x08, // RRO object
    0x11, // RRO object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest42() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0xE8, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    (byte) 0x83, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Metric object
    0x06, // Metric object
    0x10, // Metric object
    0x00, // Metric object
    0x0c, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x01, // Metric object
    0x03, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x20, // SRP object
    0x21, // SRP object
    0x10, // SRP object
    0x00, // SRP object
    0x0C, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x00, // SRP object
    0x01, // LSP object
    0x20, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    0x00, // LSP object
    0x00, // LSP object
    0x10, // LSP object
    (byte) 0x83, // symbolic path tlv
    0x00, // symbolic path tlv
    0x11, // symbolic path tlv
    0x00, // symbolic path tlv
    0x02, // symbolic path tlv
    0x54, // symbolic path tlv
    0x31, // symbolic path tlv
    0x00, // symbolic path tlv
    0x00, // ERO object
    0x07, // ERO object
    0x10, // ERO object
    0x00, // ERO object
    0x14, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, (byte) 0x81, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA object
    0x09, // LSPA object
    0x10, // LSPA object
    0x00, // LSPA object
    0x14, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, // LSPA object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth object
    0x05, // Bandwidth object
    0x20, // Bandwidth object
    0x00, // Bandwidth object
    0x08, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Bandwidth object
    0x00, // Metric object
    0x06, // Metric object
    0x10, // Metric object
    0x00, // Metric object
    0x0c, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x01, // Metric object
    0x03, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x20, // RRO object
    0x08, // RRO object
    0x10, // RRO object
    0x00, // RRO object
    0x34, // RRO object
    0x01, // RRO object
    0x08, // RRO object
    0x11, // RRO object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest1() throws PcepParseException {
    // srp, lsp(Symbolic path name tlv), ero.
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, 0x24, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0c, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x07, 0x10, 0x00, // ERO Object
    0x04 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest1() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, 0x24, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0c, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, 0x07, 0x10, 0x00, // ERO Object
    0x04 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest2() throws PcepParseException {
    // srp, lsp, ero, lspa, metric-list, iro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x7c, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0c, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object // LSP Object
    0x20, // LSP Object // LSP Object
    0x10, // LSP Object // LSP Object
    0x00, // LSP Object // LSP Object
    0x2c, // LSP Object // LSP Object
    0x00, // LSP Object // LSP Object
    0x00, // LSP Object // LSP Object
    0x10, // LSP Object // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // IPv4SubObjects
    0x01, // IPv4SubObjects
    0x08, // IPv4SubObjects
    (byte) 0xb6, // IPv4SubObjects
    0x02, // IPv4SubObjects
    0x4e, // IPv4SubObjects
    0x1f, // IPv4SubObjects
    0x04, // IPv4SubObjects
    0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x02, // Metric Object
    0x02, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20 // 0x12, 0x10, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01
    };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest2() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x7c, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0c, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object // LSP Object
    0x20, // LSP Object // LSP Object
    0x10, // LSP Object // LSP Object
    0x00, // LSP Object // LSP Object
    0x2c, // LSP Object // LSP Object
    0x00, // LSP Object // LSP Object
    0x00, // LSP Object // LSP Object
    0x10, // LSP Object // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // IPv4SubObjects
    0x01, // IPv4SubObjects
    0x08, // IPv4SubObjects
    (byte) 0xb6, // IPv4SubObjects
    0x02, // IPv4SubObjects
    0x4e, // IPv4SubObjects
    0x1f, // IPv4SubObjects
    0x04, // IPv4SubObjects
    0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x02, // Metric Object
    0x02, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest3() throws PcepParseException {
    // lsp, ero, lspa, metric-list, iro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x70, // LSP Object //LSP Object
    0x20, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x2c, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // Ipv4SubObjects
    0x01, // Ipv4SubObjects
    0x08, // Ipv4SubObjects
    (byte) 0xb6, // Ipv4SubObjects
    0x02, // Ipv4SubObjects
    0x4e, // Ipv4SubObjects
    0x1f, // Ipv4SubObjects
    0x04, // Ipv4SubObjects
    0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Metric Objects
    0x06, // Metric Objects
    0x10, // Metric Objects
    0x00, // Metric Objects
    0x0c, // Metric Objects
    0x00, // Metric Objects
    0x00, // Metric Objects
    0x02, // Metric Objects
    0x02, // Metric Objects
    0x00, // Metric Objects
    0x00, // Metric Objects
    0x00, // Metric Objects
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20 // 0x12, 0x10, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01
    };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest3() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x70, // LSP Object //LSP Object
    0x20, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x2c, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, // Ipv4SubObjects
    0x01, // Ipv4SubObjects
    0x08, // Ipv4SubObjects
    (byte) 0xb6, // Ipv4SubObjects
    0x02, // Ipv4SubObjects
    0x4e, // Ipv4SubObjects
    0x1f, // Ipv4SubObjects
    0x04, // Ipv4SubObjects
    0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Metric Objects
    0x06, // Metric Objects
    0x10, // Metric Objects
    0x00, // Metric Objects
    0x0c, // Metric Objects
    0x00, // Metric Objects
    0x00, // Metric Objects
    0x02, // Metric Objects
    0x02, // Metric Objects
    0x00, // Metric Objects
    0x00, // Metric Objects
    0x00, // Metric Objects
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest4() throws PcepParseException {
    // lsp, ero, lspa, metric-list
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x64, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0c, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object //LSP Object
    0x20, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x2c, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // 0x12, 0x10, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01
    };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest4() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x64, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0c, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object //LSP Object
    0x20, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x2c, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest5() throws PcepParseException {
    // srp, lsp, ero, iro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x50, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0c, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object //LSP Object
    0x20, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x2c, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00 // 0x12, 0x10, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01
    };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest5() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x50, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0c, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object //LSP Object
    0x20, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x2c, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest6() throws PcepParseException {
    // srp, lsp, ero, lspa, metric-list
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x6c, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0c, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x04, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Metric object
    0x06, // Metric object
    0x10, // Metric object
    0x00, // Metric object
    0x0c, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x02, // Metric object
    0x02, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20 // 0x12, 0x10, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01
    };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest6() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x6c, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0c, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x04, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Metric object
    0x06, // Metric object
    0x10, // Metric object
    0x00, // Metric object
    0x0c, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x02, // Metric object
    0x02, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest7() throws PcepParseException {
    // lsp, ero, lspa, metric-list, iro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x58, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0c, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object //LSP Object
    0x20, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x08, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Metric objects
    0x06, // Metric objects
    0x10, // Metric objects
    0x00, // Metric objects
    0x0c, // Metric objects
    0x00, // Metric objects
    0x00, // Metric objects
    0x02, // Metric objects
    0x02, // Metric objects
    0x00, // Metric objects
    0x00, // Metric objects
    0x00, // Metric objects
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0x20 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest7() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x58, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0c, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x08, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Metric objects
    0x06, // Metric objects
    0x10, // Metric objects
    0x00, // Metric objects
    0x0c, // Metric objects
    0x00, // Metric objects
    0x00, // Metric objects
    0x02, // Metric objects
    0x02, // Metric objects
    0x00, // Metric objects
    0x00, // Metric objects
    0x00, // Metric objects
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0x20 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest8() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x70, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0c, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object //LSP Object
    0x20, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x2c, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric Object
    0x20 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest8() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x70, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0c, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric Object
    0x20 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest9() throws PcepParseException {
    // lsp ,ero
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x44, // LSP Object //LSP Object
    0x20, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x2c, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest9() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x44, // LSP Object //LSP Object
    0x20, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x2c, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x00, // LSP Object //LSP Object
    0x10, // LSP Object //LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest10() throws PcepParseException {
    // srp,lsp(StatefulIPv4LspIdentidiersTlv)ero,rro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x74, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x1c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest10() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x74, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x1c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest11() throws PcepParseException {
    // srp,lsp(SymbolicPathNameTlv)ero,rro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x68, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest11() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x68, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest12() throws PcepParseException {
    // srp,lsp, ero,rro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x60, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x08, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest12() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x60, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x08, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest13() throws PcepParseException {
    // srp,lsp(StatefulLspErrorCodeTlv)ero,rro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x68, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest13() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x68, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest14() throws PcepParseException {
    // srp,lsp(StatefulRsvpErrorSpecTlv),ero,rro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x60, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x08, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest14() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x60, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x08, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest15() throws PcepParseException {
    // srp,lsp,lspa,ero
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x7C, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest15() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x7C, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest16() throws PcepParseException {
    // srp,lsp,bandwidth,ero
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x70, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest16() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x70, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest17() throws PcepParseException {
    // srp,lsp,ero,lspa,rro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x74, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x08, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest17() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x74, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x08, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest18() throws PcepParseException {
    // srp,lsp,ero,bandwidth,rro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x68, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x08, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest18() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x68, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x08, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest19() throws PcepParseException {
    // srp,lsp,ero,metric-list,rro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x6C, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x08, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest19() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x6C, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x08, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest20() throws PcepParseException {
    // srp,lsp,ero,lspa,bandwidth,metric-list,rro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x88, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x08, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, 0x09, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest20() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x88, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x08, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, 0x09, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest21() throws PcepParseException {
    // srp,lsp(all tlv),ero,lspa,bandwidth,metric-list,rro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0xac, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, 0x09, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest21() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0xac, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, 0x09, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest22() throws PcepParseException {
    // lsp(all tlv),ero,lspa,bandwidth,metric-list,rro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0xA0, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, 0x09, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest22() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0xA0, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, 0x09, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest23() throws PcepParseException {
    // lsp(all tlv),ero,bandwidth,metric-list,rro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x8c, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest23() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x8c, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest24() throws PcepParseException {
    // lsp(all tlv),ero,metric-list,rro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest24() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x84, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest25() throws PcepParseException {
    // lsp(all tlv),ero,lspa,rro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x8c, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest25() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x8c, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest26() throws PcepParseException {
    // lsp(all tlv),ero,lspa
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x58, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest26() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x58, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest27() throws PcepParseException {
    // lsp(all tlv),ero
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x44, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest27() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x44, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest28() throws PcepParseException {
    // lsp(all tlv),lspa,bandwidth,metric-list,ero
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x6c, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, 0x09, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0x20 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest28() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x6c, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x2c, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x12, // StatefulIPv4LspIdentidiersTlv
    0x00, // StatefulIPv4LspIdentidiersTlv
    0x10, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x00, 0x01, (byte) 0x80, 0x01, (byte) 0xb6, 0x02, 0x4e, 0x1f, (byte) 0xb6, 0x02, 0x4e, 0x20, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x14, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x04, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x00, // StatefulLspErrorCodeTlv
    0x08, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, 0x09, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0x20 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest29() throws PcepParseException {
    // srp,lsp,ero,metric-list,rro
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x74, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest29() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x74, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest30() throws PcepParseException {
    // srp,lsp,ero,metric-list,rro,srp,lsp,ero,metric-list,rro,
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0xE4, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest30() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0xE4, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest31() throws PcepParseException {
    // srp,lsp,ero,lspa,bandwidth,metric-list,rro,srp,lsp,ero,metric-list,rro,
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x01, 0x00, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest31() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x01, 0x00, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest32() throws PcepParseException {
    // srp,lsp,ero,lspa,bandwidth,metric-list,rro,srp,lsp,ero,lspa,metric-list,rro,
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x01, (byte) 0x14, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest32() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x01, (byte) 0x14, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest33() throws PcepParseException {
    // srp,lsp,ero,lspa,bandwidth,metric-list,rro,srp,lsp,ero,lspa,bandwidth,metric-list,rro,
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x01, (byte) 0x1c, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, 0x09, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest33() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x01, (byte) 0x1c, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, 0x09, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // RRO Object
    0x08, // RRO Object
    0x10, // RRO Object
    0x00, // RRO Object
    0x34, // RRO Object
    0x01, // RRO Object
    0x08, // RRO Object
    0x11, // RRO Object
    0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x11, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x06, 0x06, 0x06, 0x06, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x02, 0x04, 0x00, 0x01, 0x08, 0x12, 0x01, 0x01, 0x01, 0x04, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x05, 0x04, 0x00 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest34() throws PcepParseException {
    // srp,lsp,ero,lspa,bandwidth,metric-list,srp,lsp,ero,lspa,bandwidth,metric-list
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0xB4, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x04, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric Object
    0x20 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest34() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0xB4, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Metric Object
    0x06, // Metric Object
    0x10, // Metric Object
    0x00, // Metric Object
    0x0c, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x01, // Metric Object
    0x03, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x00, // Metric Object
    0x20, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x04, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, // LSPA Object
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric Object
    0x20 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void reportMessageTest35() throws PcepParseException {
    // srp,lsp,ero,srp,lsp,ero,lspa,bandwidth,metric-list
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x8C, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric Object
    0x20 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    try {
        message = reader.readFrom(buffer);
    } catch (PcepParseException e) {
        e.printStackTrace();
    }
    if (message instanceof PcepReportMsg) {
        ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
        message.writeTo(buf);
        int iReadLen = buf.writerIndex() - 0;
        testReportMsg = new byte[iReadLen];
        buf.readBytes(testReportMsg, 0, iReadLen);
        if (Arrays.equals(reportMsg, testReportMsg)) {
            Assert.assertArrayEquals(reportMsg, testReportMsg);
            log.debug("Pcep Report Msg are equal :" + reportMsg);
        } else {
            Assert.fail("test case failed");
            log.debug("not equal");
        }
    } else {
        Assert.fail("test case failed");
        log.debug("not equal");
    }
}
#method_after
@Test
public void reportMessageTest35() throws PcepParseException {
    byte[] reportMsg = new byte[] { 0x20, 0x0a, 0x00, (byte) 0x8C, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // SRP Object
    0x21, // SRP Object
    0x10, // SRP Object
    0x00, // SRP Object
    0x0C, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x00, // SRP Object
    0x01, // LSP Object
    0x20, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x00, // LSP Object
    0x00, // LSP Object
    0x10, // LSP Object
    0x03, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x11, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x02, // SymbolicPathNameTlv
    0x54, // SymbolicPathNameTlv
    0x31, // SymbolicPathNameTlv
    0x00, // SymbolicPathNameTlv
    0x00, // ERO Object
    0x07, // ERO Object
    0x10, // ERO Object
    0x00, // ERO Object
    0x14, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x1f, 0x04, 0x00, 0x01, 0x08, (byte) 0xb6, 0x02, 0x4e, 0x20, 0x04, 0x00, // LSPA Object
    0x09, // LSPA Object
    0x10, // LSPA Object
    0x00, // LSPA Object
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Bandwidth Object
    0x05, // Bandwidth Object
    0x20, // Bandwidth Object
    0x00, // Bandwidth Object
    0x08, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, // Bandwidth Object
    0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, // Metric Object
    0x20 };
    byte[] testReportMsg = { 0 };
    ChannelBuffer buffer = ChannelBuffers.dynamicBuffer();
    buffer.writeBytes(reportMsg);
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    PcepMessage message = null;
    message = reader.readFrom(buffer);
    Assert.assertTrue("PcepMessage is not instance of PcRpt", message instanceof PcepReportMsg);
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    message.writeTo(buf);
    int readLen = buf.writerIndex() - 0;
    testReportMsg = new byte[readLen];
    buf.readBytes(testReportMsg, 0, readLen);
    Assert.assertArrayEquals("PcRpt messages are not equal", reportMsg, testReportMsg);
}
#end_block

#method_before
@Test
public void basics() {
    new EqualsTester().addEqualityGroup(tlv1, tlv2).testEquals();
}
#method_after
@Test
public void basics() {
    new EqualsTester().addEqualityGroup(tlv1, sameAstlv1).addEqualityGroup(tlv2).testEquals();
}
#end_block

#method_before
public static PcepFactory getFactory(PcepVersion version) throws PcepParseException {
    switch(version) {
        case PCEP_1:
            return PcepFactoryVer1.INSTANCE;
        default:
            throw new PcepParseException("Unknown version: " + version);
    }
}
#method_after
public static PcepFactory getFactory(PcepVersion version) {
    switch(version) {
        case PCEP_1:
            return PcepFactoryVer1.INSTANCE;
        default:
            throw new IllegalArgumentException("Unknown version: " + version);
    }
}
#end_block

#method_before
@Override
protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg) throws Exception {
    log.debug("Sending message");
    if (!(msg instanceof List)) {
        log.debug("Invalid msg.");
        return msg;
    }
    @SuppressWarnings("unchecked")
    List<PcepMessage> msglist = (List<PcepMessage>) msg;
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    log.debug("SENDING MESSAGE");
    for (PcepMessage pm : msglist) {
        pm.writeTo(buf);
    // pm.print();
    }
    HexDump.pcepHexDump(buf);
    return buf;
}
#method_after
@Override
protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg) throws Exception {
    log.debug("Sending message");
    if (!(msg instanceof List)) {
        log.debug("Invalid msg.");
        return msg;
    }
    @SuppressWarnings("unchecked")
    List<PcepMessage> msglist = (List<PcepMessage>) msg;
    ChannelBuffer buf = ChannelBuffers.dynamicBuffer();
    for (PcepMessage pm : msglist) {
        pm.writeTo(buf);
    }
    HexDump.pcepHexDump(buf);
    return buf;
}
#end_block

#method_before
public int outPacketCount() {
    return outPacketCount;
}
#method_after
@Override
public int outPacketCount() {
    return outPacketCount;
}
#end_block

#method_before
public int inPacketCount() {
    return inPacketCount;
}
#method_after
@Override
public int inPacketCount() {
    return inPacketCount;
}
#end_block

#method_before
public int wrongPacketCount() {
    return wrongPacketCount;
}
#method_after
@Override
public int wrongPacketCount() {
    return wrongPacketCount;
}
#end_block

#method_before
public long getTime() {
    return this.time;
}
#method_after
@Override
public long getTime() {
    return this.time;
}
#end_block

#method_before
@Override
protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer) throws Exception {
    log.debug("Message received.");
    if (!channel.isConnected()) {
        log.info("Channel is not connected.");
        // This check avoids that from reading corrupted frames
        return null;
    }
    HexDump.pcepHexDump(buffer);
    // Note that a single call to decode results in reading a single
    // PcepMessage from the channel buffer, which is passed on to, and processed
    // by, the controller (in PcepChannelHandler).
    // This is different from earlier behavior (with the original pcepIO),
    // where we parsed all the messages in the buffer, before passing on
    // a list of the parsed messages to the controller.
    // The performance *may or may not* not be as good as before.
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    List<PcepMessage> msgList = new LinkedList<PcepMessage>();
    while (buffer.readableBytes() > 0) {
        PcepMessage message = reader.readFrom(buffer);
        msgList.add(message);
        message.print();
    }
    return msgList;
}
#method_after
@Override
protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer) throws Exception {
    log.debug("Message received.");
    if (!channel.isConnected()) {
        log.info("Channel is not connected.");
        // This check avoids that from reading corrupted frames
        return null;
    }
    HexDump.pcepHexDump(buffer);
    // Note that a single call to decode results in reading a single
    // PcepMessage from the channel buffer, which is passed on to, and processed
    // by, the controller (in PcepChannelHandler).
    // This is different from earlier behavior (with the original pcepIO),
    // where we parsed all the messages in the buffer, before passing on
    // a list of the parsed messages to the controller.
    // The performance *may or may not* not be as good as before.
    PcepMessageReader<PcepMessage> reader = PcepFactories.getGenericReader();
    List<PcepMessage> msgList = new LinkedList<PcepMessage>();
    while (buffer.readableBytes() > 0) {
        PcepMessage message = reader.readFrom(buffer);
        msgList.add(message);
    }
    return msgList;
}
#end_block

#method_before
// ***************
// Getters/Setters
// ***************
public PcepFactory getPcepMessageFactory1() {
    return FACTORY1;
}
#method_after
public PcepFactory getPcepMessageFactory1() {
    return FACTORY1;
}
#end_block

#method_before
// **************
// Initialization
// **************
public void run() {
    try {
        final ServerBootstrap bootstrap = createServerBootStrap();
        bootstrap.setOption("reuseAddr", true);
        bootstrap.setOption("child.keepAlive", true);
        bootstrap.setOption("child.tcpNoDelay", true);
        bootstrap.setOption("child.sendBufferSize", Controller.SEND_BUFFER_SIZE);
        ChannelPipelineFactory pfact = new PcepPipelineFactory(this);
        bootstrap.setPipelineFactory(pfact);
        InetSocketAddress sa = new InetSocketAddress(pcepPort);
        cg = new DefaultChannelGroup();
        cg.add(bootstrap.bind(sa));
        log.info("Listening for PCC connection on {}", sa);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#method_after
public void run() {
    try {
        final ServerBootstrap bootstrap = createServerBootStrap();
        bootstrap.setOption("reuseAddr", true);
        bootstrap.setOption("child.keepAlive", true);
        bootstrap.setOption("child.tcpNoDelay", true);
        bootstrap.setOption("child.sendBufferSize", Controller.SEND_BUFFER_SIZE);
        ChannelPipelineFactory pfact = new PcepPipelineFactory(this);
        bootstrap.setPipelineFactory(pfact);
        InetSocketAddress sa = new InetSocketAddress(pcepPort);
        cg = new DefaultChannelGroup();
        cg.add(bootstrap.bind(sa));
        log.info("Listening for PCC connection on {}", sa);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
// **************
// Utility methods
// **************
public Map<String, Long> getMemory() {
    Map<String, Long> m = new HashMap<>();
    Runtime runtime = Runtime.getRuntime();
    m.put("total", runtime.totalMemory());
    m.put("free", runtime.freeMemory());
    return m;
}
#method_after
public Map<String, Long> getMemory() {
    Map<String, Long> m = new HashMap<>();
    Runtime runtime = Runtime.getRuntime();
    m.put("total", runtime.totalMemory());
    m.put("free", runtime.freeMemory());
    return m;
}
#end_block

#method_before
/**
 * Creates instance of Pcep client.
 *
 * @param pccId pcc identifier
 * @param sessionID session id
 * @param pv pcep version
 * @param pktStats pcep packet statistics
 * @return instance of PcepClient
 */
protected PcepClientDriver getPcepClientInstance(PccId pccId, int sessionID, PcepVersion pv, PcepPacketStats pktStats) {
    PcepClientDriver pcepClientDriver = new PcepClientImpl();
    pcepClientDriver.init(pccId, pv, pktStats);
    pcepClientDriver.setAgent(agent);
    return pcepClientDriver;
}
#method_after
protected PcepClientDriver getPcepClientInstance(PccId pccId, int sessionID, PcepVersion pv, PcepPacketStats pktStats) {
    PcepClientDriver pcepClientDriver = new PcepClientImpl();
    pcepClientDriver.init(pccId, pv, pktStats);
    pcepClientDriver.setAgent(agent);
    return pcepClientDriver;
}
#end_block

#method_before
// *************************
// Channel handler methods
// *************************
@Override
public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
    channel = e.getChannel();
    log.info("PCC connected from {}", channel.getRemoteAddress());
    // Wait for open message from pcc client
    setState(ChannelState.OPENWAIT);
}
#method_after
@Override
public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
    channel = e.getChannel();
    log.info("PCC connected from {}", channel.getRemoteAddress());
    // Wait for open message from pcc client
    setState(ChannelState.OPENWAIT);
}
#end_block

#method_before
@Override
public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
    PcepErrorMsg errMsg;
    log.info("[exceptionCaught]: " + e.toString());
    if (e.getCause() instanceof ReadTimeoutException) {
        if (ChannelState.OPENWAIT == state) {
            // When ReadTimeout timer is expired in OPENWAIT state, it is considered
            // OpenWait timer.
            errMsg = getErrorMsg(PcepErrorDetailInfo.ERROR_TYPE_1, PcepErrorDetailInfo.ERROR_VALUE_2);
            log.debug("Sending PCEP-ERROR message to PCC.");
            channel.write(Collections.singletonList(errMsg));
            channel.close();
            state = ChannelState.INIT;
            return;
        } else if (ChannelState.KEEPWAIT == state) {
            // When ReadTimeout timer is expired in KEEPWAIT state, is is considered
            // KeepWait timer.
            errMsg = getErrorMsg(PcepErrorDetailInfo.ERROR_TYPE_1, PcepErrorDetailInfo.ERROR_VALUE_7);
            log.debug("Sending PCEP-ERROR message to PCC.");
            channel.write(Collections.singletonList(errMsg));
            channel.close();
            state = ChannelState.INIT;
            return;
        }
    } else if (e.getCause() instanceof ClosedChannelException) {
        log.debug("Channel for pc {} already closed", getClientInfoString());
    } else if (e.getCause() instanceof IOException) {
        log.error("Disconnecting client {} due to IO Error: {}", getClientInfoString(), e.getCause().getMessage());
        if (log.isDebugEnabled()) {
            // still print stack trace if debug is enabled
            log.debug("StackTrace for previous Exception: ", e.getCause());
        }
        channel.close();
    } else if (e.getCause() instanceof PcepParseException) {
        PcepParseException errMsgParse = (PcepParseException) e.getCause();
        byte errorType = errMsgParse.getErrorType();
        byte errorValue = errMsgParse.getErrorValue();
        if ((errorType == (byte) 0x0) && (errorValue == (byte) 0x0)) {
            processUnknownMsg();
        } else {
            errMsg = getErrorMsg(errorType, errorValue);
            log.debug("Sending PCEP-ERROR message to PCC.");
            channel.write(Collections.singletonList(errMsg));
        }
    } else if (e.getCause() instanceof RejectedExecutionException) {
        log.warn("Could not process message: queue full");
    } else {
        log.error("Error while processing message from client " + getClientInfoString() + "state " + this.state);
        channel.close();
    }
}
#method_after
@Override
public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) throws Exception {
    PcepErrorMsg errMsg;
    log.info("exceptionCaught: " + e.toString());
    if (e.getCause() instanceof ReadTimeoutException) {
        if (ChannelState.OPENWAIT == state) {
            // When ReadTimeout timer is expired in OPENWAIT state, it is considered
            // OpenWait timer.
            errMsg = getErrorMsg(PcepErrorDetailInfo.ERROR_TYPE_1, PcepErrorDetailInfo.ERROR_VALUE_2);
            log.debug("Sending PCEP-ERROR message to PCC.");
            channel.write(Collections.singletonList(errMsg));
            channel.close();
            state = ChannelState.INIT;
            return;
        } else if (ChannelState.KEEPWAIT == state) {
            // When ReadTimeout timer is expired in KEEPWAIT state, is is considered
            // KeepWait timer.
            errMsg = getErrorMsg(PcepErrorDetailInfo.ERROR_TYPE_1, PcepErrorDetailInfo.ERROR_VALUE_7);
            log.debug("Sending PCEP-ERROR message to PCC.");
            channel.write(Collections.singletonList(errMsg));
            channel.close();
            state = ChannelState.INIT;
            return;
        }
    } else if (e.getCause() instanceof ClosedChannelException) {
        log.debug("Channel for pc {} already closed", getClientInfoString());
    } else if (e.getCause() instanceof IOException) {
        log.error("Disconnecting client {} due to IO Error: {}", getClientInfoString(), e.getCause().getMessage());
        if (log.isDebugEnabled()) {
            // still print stack trace if debug is enabled
            log.debug("StackTrace for previous Exception: ", e.getCause());
        }
        channel.close();
    } else if (e.getCause() instanceof PcepParseException) {
        PcepParseException errMsgParse = (PcepParseException) e.getCause();
        byte errorType = errMsgParse.getErrorType();
        byte errorValue = errMsgParse.getErrorValue();
        if ((errorType == (byte) 0x0) && (errorValue == (byte) 0x0)) {
            processUnknownMsg();
        } else {
            errMsg = getErrorMsg(errorType, errorValue);
            log.debug("Sending PCEP-ERROR message to PCC.");
            channel.write(Collections.singletonList(errMsg));
        }
    } else if (e.getCause() instanceof RejectedExecutionException) {
        log.warn("Could not process message: queue full");
    } else {
        log.error("Error while processing message from client " + getClientInfoString() + "state " + this.state);
        channel.close();
    }
}
#end_block

#method_before
// *************************
// Channel utility methods
// *************************
// 
public void setHandshakeComplete(boolean handshakeComplete) {
    this.state.setHandshakeComplete(handshakeComplete);
}
#method_after
public void setHandshakeComplete(boolean handshakeComplete) {
    this.state.setHandshakeComplete(handshakeComplete);
}
#end_block

#method_before
private boolean capabilityValidation(PcepOpenMsg pOpenmsg) {
    LinkedList<PcepValueType> tlvList = pOpenmsg.getPcepOpenObject().getOptionalTlv();
    boolean bFoundPceccCapability = false;
    boolean bFoundStatefulPceCapability = false;
    boolean bFoundPcInstantiationCapability = false;
    ListIterator<PcepValueType> listIterator = tlvList.listIterator();
    while (listIterator.hasNext()) {
        PcepValueType tlv = listIterator.next();
        switch(tlv.getType()) {
            case PceccCapabilityTlv.TYPE:
                bFoundPceccCapability = true;
                break;
            case StatefulPceCapabilityTlv.TYPE:
                bFoundStatefulPceCapability = true;
                StatefulPceCapabilityTlv stetefulPcCapTlv = (StatefulPceCapabilityTlv) tlv;
                if (true == stetefulPcCapTlv.getIFlag()) {
                    bFoundPcInstantiationCapability = true;
                }
                break;
            default:
                continue;
        }
    }
    return (bFoundPceccCapability && bFoundStatefulPceCapability && bFoundPcInstantiationCapability) ? true : false;
}
#method_after
private boolean capabilityValidation(PcepOpenMsg pOpenmsg) {
    LinkedList<PcepValueType> tlvList = pOpenmsg.getPcepOpenObject().getOptionalTlv();
    boolean bFoundPceccCapability = false;
    boolean bFoundStatefulPceCapability = false;
    boolean bFoundPcInstantiationCapability = false;
    ListIterator<PcepValueType> listIterator = tlvList.listIterator();
    while (listIterator.hasNext()) {
        PcepValueType tlv = listIterator.next();
        switch(tlv.getType()) {
            case PceccCapabilityTlv.TYPE:
                bFoundPceccCapability = true;
                break;
            case StatefulPceCapabilityTlv.TYPE:
                bFoundStatefulPceCapability = true;
                StatefulPceCapabilityTlv stetefulPcCapTlv = (StatefulPceCapabilityTlv) tlv;
                if (stetefulPcCapTlv.getIFlag()) {
                    bFoundPcInstantiationCapability = true;
                }
                break;
            default:
                continue;
        }
    }
    return (bFoundPceccCapability && bFoundStatefulPceCapability && bFoundPcInstantiationCapability) ? true : false;
}
#end_block

#method_before
@Override
public void init(PccId pccId, PcepVersion pcepVersion, PcepPacketStats pktStats) {
    this.pccId = pccId;
    this.pcepVersion = pcepVersion;
    this.pktStats = pktStats;
}
#method_after
@Override
public void init(PccId pccId, PcepVersion pcepVersion, PcepPacketStats pktStats) {
    this.pccId = pccId;
    this.pcepVersion = pcepVersion;
    this.pktStats = (PcepPacketStatsImpl) pktStats;
}
#end_block

#method_before
// ************************
// Channel related
// ************************
@Override
public final void disconnectClient() {
    this.channel.close();
}
#method_after
@Override
public final void disconnectClient() {
    this.channel.close();
}
#end_block

#method_before
@Override
public final void sendMessage(PcepMessage m) {
    log.debug("Sending messate to {}", channel.getRemoteAddress());
    try {
        channel.write(Collections.singletonList(m));
        this.pktStats.addOutPacket();
    } catch (RejectedExecutionException e) {
        log.warn(e.getMessage());
        if (!e.getMessage().contains(SHUTDOWN_MSG)) {
            throw e;
        }
    }
}
#method_after
@Override
public final void sendMessage(PcepMessage m) {
    log.debug("Sending message to {}", channel.getRemoteAddress());
    try {
        channel.write(Collections.singletonList(m));
        this.pktStats.addOutPacket();
    } catch (RejectedExecutionException e) {
        log.warn(e.getMessage());
        if (!e.getMessage().contains(SHUTDOWN_MSG)) {
            throw e;
        }
    }
}
#end_block

#method_before
// ************************
// Pcc Client features related
// ************************
@Override
public final PccId getPccId() {
    return this.pccId;
}
#method_after
@Override
public final PccId getPccId() {
    return this.pccId;
}
#end_block

#method_before
// ************************
// Message handling
// ************************
@Override
public final void handleMessage(PcepMessage m) {
    this.pktStats.addInPacket();
    this.agent.processPcepMessage(pccId, m);
}
#method_after
@Override
public final void handleMessage(PcepMessage m) {
    this.pktStats.addInPacket();
    this.agent.processPcepMessage(pccId, m);
}
#end_block

#method_before
@Override
public String toString() {
    return this.getClass().getName() + " [" + ((channel != null) ? channel.getRemoteAddress() : "?") + " PCCIP[" + ((pccId != null) ? pccId.toString() : "?") + "]]";
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("channel", channelId()).add("pccId", getPccId()).toString();
}
#end_block

#method_before
@Override
public PcepTEReportMsg readFrom(ChannelBuffer cb) throws PcepParseException {
    if (cb.readableBytes() < PACKET_MINIMUM_LENGTH) {
        return null;
    }
    llTEReportList = new LinkedList<PcepTEObject>();
    byte version = cb.readByte();
    version = (byte) (version >> PcepMessageVer1.SHIFT_FLAG);
    if (version != PACKET_VERSION) {
        throw new PcepParseException("Wrong version. Expected=PcepVersion.PCEP_1(1), got=" + version);
    }
    byte type = cb.readByte();
    if (type != MSG_TYPE.getType()) {
        throw new PcepParseException("Wrong type. Expected=PcepType.TE_REPORT(14), got=" + type);
    }
    short length = cb.readShort();
    if (length < PACKET_MINIMUM_LENGTH) {
        throw new PcepParseException("Wrong length. Expected to be >= " + PACKET_MINIMUM_LENGTH + ", is: " + length);
    }
    // Parse state report list
    parseTEReportList(cb);
    return new PcepTEReportMsgVer1(llTEReportList);
}
#method_after
@Override
public PcepTEReportMsg readFrom(ChannelBuffer cb) throws PcepParseException {
    if (cb.readableBytes() < PACKET_MINIMUM_LENGTH) {
        return null;
    }
    teReportList = new LinkedList<PcepTEObject>();
    byte version = cb.readByte();
    version = (byte) (version >> PcepMessageVer1.SHIFT_FLAG);
    if (version != PcepMessageVer1.PACKET_VERSION) {
        throw new PcepParseException("Wrong version. Expected=PcepVersion.PCEP_1(1), got=" + version);
    }
    byte type = cb.readByte();
    if (type != MSG_TYPE.getType()) {
        throw new PcepParseException("Wrong type. Expected=PcepType.TE_REPORT(14), got=" + type);
    }
    short length = cb.readShort();
    if (length < PACKET_MINIMUM_LENGTH) {
        throw new PcepParseException("Wrong length. Expected to be >= " + PACKET_MINIMUM_LENGTH + ", is: " + length);
    }
    // Parse state report list
    parseTEReportList(cb);
    return new PcepTEReportMsgVer1(teReportList);
}
#end_block

#method_before
public void parseTEReportList(ChannelBuffer cb) throws PcepParseException {
    while (0 < cb.readableBytes()) {
        // store TE objectS
        if (!llTEReportList.add(PcepTEObjectVer1.read(cb))) {
            throw new PcepParseException("Failed to add TE object to TE report list");
        }
    }
}
#method_after
public void parseTEReportList(ChannelBuffer cb) throws PcepParseException {
    while (0 < cb.readableBytes()) {
        // store TE objectS
        if (!teReportList.add(PcepTEObjectVer1.read(cb))) {
            throw new PcepParseException("Failed to add TE object to TE report list");
        }
    }
}
#end_block

#method_before
@Override
public PcepTEReportMsg build() {
    return new PcepTEReportMsgVer1(this.llTEReportList);
}
#method_after
@Override
public PcepTEReportMsg build() {
    return new PcepTEReportMsgVer1(this.teReportList);
}
#end_block

#method_before
@Override
public LinkedList<PcepTEObject> getTEReportList() {
    return this.llTEReportList;
}
#method_after
@Override
public LinkedList<PcepTEObject> getTEReportList() {
    return this.teReportList;
}
#end_block

#method_before
@Override
public Builder setTEReportList(LinkedList<PcepTEObject> ll) {
    this.llTEReportList = ll;
    return this;
}
#method_after
@Override
public Builder setTEReportList(LinkedList<PcepTEObject> ll) {
    this.teReportList = ll;
    return this;
}
#end_block

#method_before
@Override
public void write(ChannelBuffer bb, PcepTEReportMsgVer1 message) throws PcepParseException {
    int startIndex = bb.writerIndex();
    // first 3 bits set to version
    bb.writeByte((byte) (PACKET_VERSION << PcepMessageVer1.SHIFT_FLAG));
    // message type
    bb.writeByte(MSG_TYPE.getType());
    // Length of the message will be updated at the end
    // First write with 0s
    int msgLenIndex = bb.writerIndex();
    bb.writeShort((short) 0);
    ListIterator<PcepTEObject> listIterator = message.llTEReportList.listIterator();
    while (listIterator.hasNext()) {
        PcepTEObject teObj = listIterator.next();
        teObj.write(bb);
    }
    // update message length field
    int length = bb.writerIndex() - startIndex;
    bb.setShort(msgLenIndex, (short) length);
}
#method_after
@Override
public void write(ChannelBuffer bb, PcepTEReportMsgVer1 message) throws PcepParseException {
    int startIndex = bb.writerIndex();
    // first 3 bits set to version
    bb.writeByte((byte) (PcepMessageVer1.PACKET_VERSION << PcepMessageVer1.SHIFT_FLAG));
    // message type
    bb.writeByte(MSG_TYPE.getType());
    // Length of the message will be updated at the end
    // First write with 0s
    int msgLenIndex = bb.writerIndex();
    bb.writeShort((short) 0);
    ListIterator<PcepTEObject> listIterator = message.teReportList.listIterator();
    while (listIterator.hasNext()) {
        PcepTEObject teObj = listIterator.next();
        teObj.write(bb);
    }
    // update message length field
    int length = bb.writerIndex() - startIndex;
    bb.setShort(msgLenIndex, (short) length);
}
#end_block

#method_before
@Override
public LinkedList<PcepTEObject> getTEReportList() {
    return this.llTEReportList;
}
#method_after
@Override
public LinkedList<PcepTEObject> getTEReportList() {
    return this.teReportList;
}
#end_block

#method_before
@Override
public void setTEReportList(LinkedList<PcepTEObject> ll) {
    this.llTEReportList = ll;
}
#method_after
@Override
public void setTEReportList(LinkedList<PcepTEObject> ll) {
    this.teReportList = ll;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("fec Obj Header", fecObjHeader).add("Node ID: ", nodeID).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("fecObjHeader", fecObjHeader).add("NodeID: ", nodeID).toString();
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("Type", TYPE).add("Length", LENGTH).add("Value", rawValue).toString();
}
#method_after
@Override
public String toString() {
    ToStringHelper toStrHelper = MoreObjects.toStringHelper(getClass());
    toStrHelper.add("Type", TYPE);
    toStrHelper.add("Length", LENGTH);
    StringBuffer result = new StringBuffer();
    for (byte b : rawValue) {
        result.append(String.format("%02X ", b));
    }
    toStrHelper.add("IpAddress", result);
    return toStrHelper.toString();
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("fec Obj Header", fecObjHeader).add("node ID: ", nodeID).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("fecObjHeader", fecObjHeader).add("nodeID: ", nodeID).toString();
}
#end_block

#method_before
@Override
public String toString() {
    ToStringHelper toStrHelper = MoreObjects.toStringHelper(getClass());
    if (labelDownload instanceof PcepLabelDownload) {
        toStrHelper.add("Label download", labelDownload);
    }
    if (labelMap instanceof PcepLabelMap) {
        toStrHelper.add("Label map", labelMap);
    }
    return toStrHelper.toString();
}
#method_after
@Override
public String toString() {
    ToStringHelper toStrHelper = MoreObjects.toStringHelper(getClass());
    if (labelDownload instanceof PcepLabelDownload) {
        toStrHelper.add("LabelDownload", labelDownload);
    }
    if (labelMap instanceof PcepLabelMap) {
        toStrHelper.add("LabelMap", labelMap);
    }
    return toStrHelper.toString();
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("Type", TYPE).add("Length", LENGTH).add("Ipv4 Address ", rawValue).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("Type", TYPE).add("Length", LENGTH).add("Ipv4Address ", rawValue).toString();
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("Type", TYPE).add("Length", LENGTH).add("Node Id", nodeID).add("Interface Id", interfaceID).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("Type", TYPE).add("Length", LENGTH).add("NodeId", nodeID).add("InterfaceId", interfaceID).toString();
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("Local Node ID: ", localNodeID).add("Local Interface ID: ", localInterfaceID).add("Remote Node ID: ", remoteNodeID).add("Remote Interface ID: ", remoteInterfaceID).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("LocalNodeID: ", localNodeID).add("LocalInterfaceID: ", localInterfaceID).add("RemoteNodeID: ", remoteNodeID).add("RemoteInterfaceID: ", remoteInterfaceID).toString();
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("local IPv6 Address", localIPv6Address).add("remote IPv6 Address: ", remoteIPv6Address).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("localIPv6Address", localIPv6Address).add("remoteIPv6Address: ", remoteIPv6Address).toString();
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("fec Obj Header", fecObjHeader).add("local IPv4 Address", localIPv4Address).add("remote IPv4 Address", remoteIPv4Address).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("fecObjHeader", fecObjHeader).add("localIPv4Address", localIPv4Address).add("remoteIPv4Address", remoteIPv4Address).toString();
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("O flag", bOFlag).add("label", label).add("list of optional tlv", llOptionalTlv).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("OFlag", bOFlag).add("label", label).add("OptionalTlvList", llOptionalTlv).toString();
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("Pc Label Update List", llPcLabelUpdateList).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("PcLabelUpdateList", llPcLabelUpdateList).toString();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof PceccCapabilityTlv) {
        PcepLabelDbVerTlv other = (PcepLabelDbVerTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof PceccCapabilityTlv) {
        PcepLabelDbVerTlv other = (PcepLabelDbVerTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof MaximumReservableLinkBandwidthTlv) {
        MaximumReservableLinkBandwidthTlv other = (MaximumReservableLinkBandwidthTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof MaximumReservableLinkBandwidthTlv) {
        MaximumReservableLinkBandwidthTlv other = (MaximumReservableLinkBandwidthTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof SharedRiskLinkGroupTlv) {
        SharedRiskLinkGroupTlv other = (SharedRiskLinkGroupTlv) obj;
        return Objects.equals(this.srlgValue, other.srlgValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof SharedRiskLinkGroupTlv) {
        SharedRiskLinkGroupTlv other = (SharedRiskLinkGroupTlv) obj;
        return Objects.equals(this.srlgValue, other.srlgValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof StatefulPceCapabilityTlv) {
        StatefulPceCapabilityTlv other = (StatefulPceCapabilityTlv) obj;
        if (isRawValueSet) {
            return Objects.equals(this.rawValue, other.rawValue);
        } else {
            return Objects.equals(this.bDFlag, other.bDFlag) && Objects.equals(this.bTFlag, other.bTFlag) && Objects.equals(this.bIFlag, other.bIFlag) && Objects.equals(this.bSFlag, other.bSFlag) && Objects.equals(this.bUFlag, other.bUFlag);
        }
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof StatefulPceCapabilityTlv) {
        StatefulPceCapabilityTlv other = (StatefulPceCapabilityTlv) obj;
        if (isRawValueSet) {
            return Objects.equals(this.rawValue, other.rawValue);
        } else {
            return Objects.equals(this.bDFlag, other.bDFlag) && Objects.equals(this.bTFlag, other.bTFlag) && Objects.equals(this.bIFlag, other.bIFlag) && Objects.equals(this.bSFlag, other.bSFlag) && Objects.equals(this.bUFlag, other.bUFlag);
        }
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    /*
         * Here we have a list of Tlv so to compare each sub tlv between the object
         * we have to take a list iterator so one by one we can get each sub tlv object
         * and can compare them.
         * it may be possible that the size of 2 lists is not equal so we have to first check
         * the size, if both are same then we should check for the subtlv objects otherwise
         * we should return false.
         */
    if (obj instanceof TELinkDescriptorsTLV) {
        int countObjSubTlv = 0;
        int countOtherSubTlv = 0;
        boolean isCommonSubTlv = true;
        TELinkDescriptorsTLV other = (TELinkDescriptorsTLV) obj;
        Iterator<PcepValueType> objListIterator = ((TELinkDescriptorsTLV) obj).llLinkDescriptorsSubTLVs.iterator();
        countObjSubTlv = ((TELinkDescriptorsTLV) obj).llLinkDescriptorsSubTLVs.size();
        countOtherSubTlv = other.llLinkDescriptorsSubTLVs.size();
        if (countObjSubTlv != countOtherSubTlv) {
            return false;
        } else {
            while (objListIterator.hasNext() && isCommonSubTlv) {
                PcepValueType subTlv = objListIterator.next();
                isCommonSubTlv = Objects.equals(llLinkDescriptorsSubTLVs.contains(subTlv), other.llLinkDescriptorsSubTLVs.contains(subTlv));
            }
            return isCommonSubTlv;
        }
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    /*
         * Here we have a list of Tlv so to compare each sub tlv between the object
         * we have to take a list iterator so one by one we can get each sub tlv object
         * and can compare them.
         * it may be possible that the size of 2 lists is not equal so we have to first check
         * the size, if both are same then we should check for the subtlv objects otherwise
         * we should return false.
         */
    if (obj instanceof TELinkDescriptorsTLV) {
        int countObjSubTlv = 0;
        int countOtherSubTlv = 0;
        boolean isCommonSubTlv = true;
        TELinkDescriptorsTLV other = (TELinkDescriptorsTLV) obj;
        Iterator<PcepValueType> objListIterator = ((TELinkDescriptorsTLV) obj).llLinkDescriptorsSubTLVs.iterator();
        countObjSubTlv = ((TELinkDescriptorsTLV) obj).llLinkDescriptorsSubTLVs.size();
        countOtherSubTlv = other.llLinkDescriptorsSubTLVs.size();
        if (countObjSubTlv != countOtherSubTlv) {
            return false;
        } else {
            while (objListIterator.hasNext() && isCommonSubTlv) {
                PcepValueType subTlv = objListIterator.next();
                isCommonSubTlv = Objects.equals(llLinkDescriptorsSubTLVs.contains(subTlv), other.llLinkDescriptorsSubTLVs.contains(subTlv));
            }
            return isCommonSubTlv;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof MPLSProtocolMaskTlv) {
        MPLSProtocolMaskTlv other = (MPLSProtocolMaskTlv) obj;
        if (isRawValueSet) {
            return Objects.equals(this.bLFlag, other.bLFlag) && Objects.equals(this.bRFlag, other.bRFlag);
        } else {
            return Objects.equals(this.rawValue, other.rawValue);
        }
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof MPLSProtocolMaskTlv) {
        MPLSProtocolMaskTlv other = (MPLSProtocolMaskTlv) obj;
        if (isRawValueSet) {
            return Objects.equals(this.bLFlag, other.bLFlag) && Objects.equals(this.bRFlag, other.bRFlag);
        } else {
            return Objects.equals(this.rawValue, other.rawValue);
        }
    }
    return false;
}
#end_block

#method_before
public LinkedList<Integer> getErrorType() {
    if ((errObjListWithOpen instanceof ErrorObjListWithOpen) && (errObjListWithOpen.isErrorObjListWithOpenPresent())) {
        LinkedList<Integer> llErrorType = new LinkedList<Integer>();
        llErrorType = errObjListWithOpen.getErrorType();
        return llErrorType;
    } else if ((errInfo instanceof PcepErrorInfo) && (errInfo.isErrorInfoPresent())) {
        LinkedList<Integer> llErrorType = new LinkedList<Integer>();
        llErrorType = errInfo.getErrorType();
        return llErrorType;
    } else {
        return null;
    }
}
#method_after
public LinkedList<Integer> getErrorType() {
    LinkedList<Integer> llErrorType = new LinkedList<Integer>();
    if ((errObjListWithOpen instanceof ErrorObjListWithOpen) && (errObjListWithOpen.isErrorObjListWithOpenPresent())) {
        llErrorType = errObjListWithOpen.getErrorType();
    } else if ((errInfo instanceof PcepErrorInfo) && (errInfo.isErrorInfoPresent())) {
        llErrorType = errInfo.getErrorType();
    }
    return llErrorType;
}
#end_block

#method_before
public LinkedList<Integer> getErrorValue() {
    if ((errObjListWithOpen instanceof ErrorObjListWithOpen) && (errObjListWithOpen.isErrorObjListWithOpenPresent())) {
        LinkedList<Integer> llErrorValue = new LinkedList<Integer>();
        llErrorValue = errObjListWithOpen.getErrorValue();
        return llErrorValue;
    } else if ((errInfo instanceof PcepErrorInfo) && (errInfo.isErrorInfoPresent())) {
        LinkedList<Integer> llErrorValue = new LinkedList<Integer>();
        llErrorValue = errInfo.getErrorValue();
        return llErrorValue;
    } else {
        return null;
    }
}
#method_after
public LinkedList<Integer> getErrorValue() {
    LinkedList<Integer> llErrorValue = new LinkedList<Integer>();
    if ((errObjListWithOpen instanceof ErrorObjListWithOpen) && (errObjListWithOpen.isErrorObjListWithOpenPresent())) {
        llErrorValue = errObjListWithOpen.getErrorValue();
    } else if ((errInfo instanceof PcepErrorInfo) && (errInfo.isErrorInfoPresent())) {
        llErrorValue = errInfo.getErrorValue();
    }
    return llErrorValue;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof StatefulLspDbVerTlv) {
        StatefulLspDbVerTlv other = (StatefulLspDbVerTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof StatefulLspDbVerTlv) {
        StatefulLspDbVerTlv other = (StatefulLspDbVerTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof NodeFlagBitsTlv) {
        NodeFlagBitsTlv other = (NodeFlagBitsTlv) obj;
        if (isRawValueSet) {
            return Objects.equals(this.bOFlag, other.bOFlag) && Objects.equals(this.bTFlag, other.bTFlag) && Objects.equals(this.bEFlag, other.bEFlag) && Objects.equals(this.bBFlag, other.bBFlag);
        } else {
            return Objects.equals(this.rawValue, other.rawValue);
        }
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof NodeFlagBitsTlv) {
        NodeFlagBitsTlv other = (NodeFlagBitsTlv) obj;
        if (isRawValueSet) {
            return Objects.equals(this.bOFlag, other.bOFlag) && Objects.equals(this.bTFlag, other.bTFlag) && Objects.equals(this.bEFlag, other.bEFlag) && Objects.equals(this.bBFlag, other.bBFlag);
        } else {
            return Objects.equals(this.rawValue, other.rawValue);
        }
    }
    return false;
}
#end_block

#method_before
@Override
public LinkedList<Integer> getErrorType() {
    LinkedList<Integer> errorType = new LinkedList<Integer>();
    ListIterator<PcepError> listIterator = errList.listIterator();
    PcepErrorObject errObj;
    while (listIterator.hasNext()) {
        PcepError pcepError = listIterator.next();
        LinkedList<PcepErrorObject> llErrObjList = pcepError.getErrorObjList();
        if (llErrObjList != null) {
            ListIterator<PcepErrorObject> errObjListIterator = llErrObjList.listIterator();
            int error;
            while (errObjListIterator.hasNext()) {
                errObj = errObjListIterator.next();
                error = errObj.getErrorType();
                errorType.add(error);
            }
        }
    }
    return errorType;
}
#method_after
@Override
public LinkedList<Integer> getErrorType() {
    LinkedList<Integer> errorType = new LinkedList<Integer>();
    ListIterator<PcepError> listIterator = errList.listIterator();
    PcepErrorObject errObj;
    int error;
    while (listIterator.hasNext()) {
        PcepError pcepError = listIterator.next();
        LinkedList<PcepErrorObject> llErrObjList = pcepError.getErrorObjList();
        if (llErrObjList != null) {
            ListIterator<PcepErrorObject> errObjListIterator = llErrObjList.listIterator();
            while (errObjListIterator.hasNext()) {
                errObj = errObjListIterator.next();
                error = errObj.getErrorType();
                errorType.add(error);
            }
        }
    }
    return errorType;
}
#end_block

#method_before
@Override
public LinkedList<Integer> getErrorValue() {
    LinkedList<Integer> errorValue = new LinkedList<Integer>();
    ListIterator<PcepError> listIterator = errList.listIterator();
    PcepErrorObject errObj;
    while (listIterator.hasNext()) {
        PcepError pcepError = listIterator.next();
        LinkedList<PcepErrorObject> llErrObjList = pcepError.getErrorObjList();
        if (llErrObjList != null) {
            ListIterator<PcepErrorObject> errObjListIterator = llErrObjList.listIterator();
            int error;
            while (errObjListIterator.hasNext()) {
                errObj = errObjListIterator.next();
                error = errObj.getErrorValue();
                errorValue.add(error);
            }
        }
    }
    return errorValue;
}
#method_after
@Override
public LinkedList<Integer> getErrorValue() {
    LinkedList<Integer> errorValue = new LinkedList<Integer>();
    ListIterator<PcepError> listIterator = errList.listIterator();
    PcepErrorObject errObj;
    int error;
    while (listIterator.hasNext()) {
        PcepError pcepError = listIterator.next();
        LinkedList<PcepErrorObject> llErrObjList = pcepError.getErrorObjList();
        if (llErrObjList != null) {
            ListIterator<PcepErrorObject> errObjListIterator = llErrObjList.listIterator();
            while (errObjListIterator.hasNext()) {
                errObj = errObjListIterator.next();
                error = errObj.getErrorValue();
                errorValue.add(error);
            }
        }
    }
    return errorValue;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof MaximumLinkBandwidthTlv) {
        MaximumLinkBandwidthTlv other = (MaximumLinkBandwidthTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof MaximumLinkBandwidthTlv) {
        MaximumLinkBandwidthTlv other = (MaximumLinkBandwidthTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof LinkProtectionTypeTlv) {
        LinkProtectionTypeTlv other = (LinkProtectionTypeTlv) obj;
        return Objects.equals(protectionCap, other.protectionCap) && Objects.equals(reserved, other.reserved);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof LinkProtectionTypeTlv) {
        LinkProtectionTypeTlv other = (LinkProtectionTypeTlv) obj;
        return Objects.equals(protectionCap, other.protectionCap) && Objects.equals(reserved, other.reserved);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    /*
         * Here we have a list of Tlv so to compare each sub tlv between the object
         * we have to take a list iterator so one by one we can get each sub tlv object
         * and can compare them.
         * it may be possible that the size of 2 lists is not equal so we have to first check
         * the size, if both are same then we should check for the subtlv objects otherwise
         * we should return false.
         */
    if (obj instanceof TENodeAttributesTlv) {
        int countObjSubTlv = 0;
        int countOtherSubTlv = 0;
        boolean isCommonSubTlv = true;
        TENodeAttributesTlv other = (TENodeAttributesTlv) obj;
        Iterator<PcepValueType> objListIterator = ((TENodeAttributesTlv) obj).llNodeAttributesSubTLVs.iterator();
        countObjSubTlv = ((TENodeAttributesTlv) obj).llNodeAttributesSubTLVs.size();
        countOtherSubTlv = other.llNodeAttributesSubTLVs.size();
        if (countObjSubTlv != countOtherSubTlv) {
            return false;
        } else {
            while (objListIterator.hasNext() && isCommonSubTlv) {
                PcepValueType subTlv = objListIterator.next();
                isCommonSubTlv = Objects.equals(llNodeAttributesSubTLVs.contains(subTlv), other.llNodeAttributesSubTLVs.contains(subTlv));
            }
            return isCommonSubTlv;
        }
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    /*
         * Here we have a list of Tlv so to compare each sub tlv between the object
         * we have to take a list iterator so one by one we can get each sub tlv object
         * and can compare them.
         * it may be possible that the size of 2 lists is not equal so we have to first check
         * the size, if both are same then we should check for the subtlv objects otherwise
         * we should return false.
         */
    if (obj instanceof TENodeAttributesTlv) {
        int countObjSubTlv = 0;
        int countOtherSubTlv = 0;
        boolean isCommonSubTlv = true;
        TENodeAttributesTlv other = (TENodeAttributesTlv) obj;
        Iterator<PcepValueType> objListIterator = ((TENodeAttributesTlv) obj).llNodeAttributesSubTLVs.iterator();
        countObjSubTlv = ((TENodeAttributesTlv) obj).llNodeAttributesSubTLVs.size();
        countOtherSubTlv = other.llNodeAttributesSubTLVs.size();
        if (countObjSubTlv != countOtherSubTlv) {
            return false;
        } else {
            while (objListIterator.hasNext() && isCommonSubTlv) {
                PcepValueType subTlv = objListIterator.next();
                isCommonSubTlv = Objects.equals(llNodeAttributesSubTLVs.contains(subTlv), other.llNodeAttributesSubTLVs.contains(subTlv));
            }
            return isCommonSubTlv;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof OpaqueLinkAttributeTlv) {
        OpaqueLinkAttributeTlv other = (OpaqueLinkAttributeTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof OpaqueLinkAttributeTlv) {
        OpaqueLinkAttributeTlv other = (OpaqueLinkAttributeTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof IPv6TERouterIdofRemoteNodeTlv) {
        IPv6TERouterIdofRemoteNodeTlv other = (IPv6TERouterIdofRemoteNodeTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof IPv6TERouterIdofRemoteNodeTlv) {
        IPv6TERouterIdofRemoteNodeTlv other = (IPv6TERouterIdofRemoteNodeTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof IPv6NeighborAddressTlv) {
        IPv6NeighborAddressTlv other = (IPv6NeighborAddressTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof IPv6NeighborAddressTlv) {
        IPv6NeighborAddressTlv other = (IPv6NeighborAddressTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof OpaqueLinkAttributeTlv) {
        OpaqueNodeAttributeTlv other = (OpaqueNodeAttributeTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof OpaqueLinkAttributeTlv) {
        OpaqueNodeAttributeTlv other = (OpaqueNodeAttributeTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof AdministrativeGroupTlv) {
        AdministrativeGroupTlv other = (AdministrativeGroupTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof AdministrativeGroupTlv) {
        AdministrativeGroupTlv other = (AdministrativeGroupTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof IPv6InterfaceAddressTlv) {
        IPv6InterfaceAddressTlv other = (IPv6InterfaceAddressTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof IPv6InterfaceAddressTlv) {
        IPv6InterfaceAddressTlv other = (IPv6InterfaceAddressTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof GmplsCapabilityTlv) {
        GmplsCapabilityTlv other = (GmplsCapabilityTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof GmplsCapabilityTlv) {
        GmplsCapabilityTlv other = (GmplsCapabilityTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    /*
         * Here we have a list of Tlv so to compare each sub tlv between the object
         * we have to take a list iterator so one by one we can get each sub tlv object
         * and can compare them.
         * it may be possible that the size of 2 lists is not equal so we have to first check
         * the size, if both are same then we should check for the subtlv objects otherwise
         * we should return false.
         */
    if (obj instanceof RemoteTENodeDescriptorsTLV) {
        int countObjSubTlv = 0;
        int countOtherSubTlv = 0;
        boolean isCommonSubTlv = true;
        RemoteTENodeDescriptorsTLV other = (RemoteTENodeDescriptorsTLV) obj;
        Iterator<PcepValueType> objListIterator = ((RemoteTENodeDescriptorsTLV) obj).llRemoteTENodeDescriptorSubTLVs.iterator();
        countObjSubTlv = ((RemoteTENodeDescriptorsTLV) obj).llRemoteTENodeDescriptorSubTLVs.size();
        countOtherSubTlv = other.llRemoteTENodeDescriptorSubTLVs.size();
        if (countObjSubTlv != countOtherSubTlv) {
            return false;
        } else {
            while (objListIterator.hasNext() && isCommonSubTlv) {
                PcepValueType subTlv = objListIterator.next();
                isCommonSubTlv = Objects.equals(llRemoteTENodeDescriptorSubTLVs.contains(subTlv), other.llRemoteTENodeDescriptorSubTLVs.contains(subTlv));
            }
            return isCommonSubTlv;
        }
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    /*
         * Here we have a list of Tlv so to compare each sub tlv between the object
         * we have to take a list iterator so one by one we can get each sub tlv object
         * and can compare them.
         * it may be possible that the size of 2 lists is not equal so we have to first check
         * the size, if both are same then we should check for the subtlv objects otherwise
         * we should return false.
         */
    if (obj instanceof RemoteTENodeDescriptorsTLV) {
        int countObjSubTlv = 0;
        int countOtherSubTlv = 0;
        boolean isCommonSubTlv = true;
        RemoteTENodeDescriptorsTLV other = (RemoteTENodeDescriptorsTLV) obj;
        Iterator<PcepValueType> objListIterator = ((RemoteTENodeDescriptorsTLV) obj).llRemoteTENodeDescriptorSubTLVs.iterator();
        countObjSubTlv = ((RemoteTENodeDescriptorsTLV) obj).llRemoteTENodeDescriptorSubTLVs.size();
        countOtherSubTlv = other.llRemoteTENodeDescriptorSubTLVs.size();
        if (countObjSubTlv != countOtherSubTlv) {
            return false;
        } else {
            while (objListIterator.hasNext() && isCommonSubTlv) {
                PcepValueType subTlv = objListIterator.next();
                isCommonSubTlv = Objects.equals(llRemoteTENodeDescriptorSubTLVs.contains(subTlv), other.llRemoteTENodeDescriptorSubTLVs.contains(subTlv));
            }
            return isCommonSubTlv;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof UnreservedBandwidthTlv) {
        UnreservedBandwidthTlv other = (UnreservedBandwidthTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof UnreservedBandwidthTlv) {
        UnreservedBandwidthTlv other = (UnreservedBandwidthTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof IPv4TERouterIdOfRemoteNodeTlv) {
        IPv4TERouterIdOfRemoteNodeTlv other = (IPv4TERouterIdOfRemoteNodeTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof IPv4TERouterIdOfRemoteNodeTlv) {
        IPv4TERouterIdOfRemoteNodeTlv other = (IPv4TERouterIdOfRemoteNodeTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof RoutingUniverseTLV) {
        RoutingUniverseTLV other = (RoutingUniverseTLV) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof RoutingUniverseTLV) {
        RoutingUniverseTLV other = (RoutingUniverseTLV) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof IPv4TERouterIdOfLocalNodeTlv) {
        IPv4TERouterIdOfLocalNodeTlv other = (IPv4TERouterIdOfLocalNodeTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof IPv4TERouterIdOfLocalNodeTlv) {
        IPv4TERouterIdOfLocalNodeTlv other = (IPv4TERouterIdOfLocalNodeTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof ISISAreaIdentifierTlv) {
        ISISAreaIdentifierTlv other = (ISISAreaIdentifierTlv) obj;
        return Objects.equals(hLength, other.hLength) && Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof ISISAreaIdentifierTlv) {
        ISISAreaIdentifierTlv other = (ISISAreaIdentifierTlv) obj;
        return Objects.equals(hLength, other.hLength) && Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof IPv4InterfaceAddressTlv) {
        IPv4InterfaceAddressTlv other = (IPv4InterfaceAddressTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof IPv4InterfaceAddressTlv) {
        IPv4InterfaceAddressTlv other = (IPv4InterfaceAddressTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof LinkNameTlv) {
        LinkNameTlv other = (LinkNameTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof LinkNameTlv) {
        LinkNameTlv other = (LinkNameTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof TEDefaultMetricTlv) {
        TEDefaultMetricTlv other = (TEDefaultMetricTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof TEDefaultMetricTlv) {
        TEDefaultMetricTlv other = (TEDefaultMetricTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof IGPMetricTlv) {
        IGPMetricTlv other = (IGPMetricTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof IGPMetricTlv) {
        IGPMetricTlv other = (IGPMetricTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof LinkLocalRemoteIdentifiersTlv) {
        LinkLocalRemoteIdentifiersTlv other = (LinkLocalRemoteIdentifiersTlv) obj;
        return Objects.equals(iLinkLocalIdentifier, other.iLinkLocalIdentifier) && Objects.equals(iLinkRemoteIdentifier, other.iLinkRemoteIdentifier);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof LinkLocalRemoteIdentifiersTlv) {
        LinkLocalRemoteIdentifiersTlv other = (LinkLocalRemoteIdentifiersTlv) obj;
        return Objects.equals(iLinkLocalIdentifier, other.iLinkLocalIdentifier) && Objects.equals(iLinkRemoteIdentifier, other.iLinkRemoteIdentifier);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    /*
         * Here we have a list of Tlv so to compare each sub tlv between the object
         * we have to take a list iterator so one by one we can get each sub tlv object
         * and can compare them.
         * it may be possible that the size of 2 lists is not equal so we have to first check
         * the size, if both are same then we should check for the subtlv objects otherwise
         * we should return false.
         */
    if (obj instanceof TELinkAttributesTlv) {
        int countObjSubTlv = 0;
        int countOtherSubTlv = 0;
        boolean isCommonSubTlv = true;
        TELinkAttributesTlv other = (TELinkAttributesTlv) obj;
        Iterator<PcepValueType> objListIterator = ((TELinkAttributesTlv) obj).llLinkAttributesSubTLVs.iterator();
        countObjSubTlv = ((TELinkAttributesTlv) obj).llLinkAttributesSubTLVs.size();
        countOtherSubTlv = other.llLinkAttributesSubTLVs.size();
        if (countObjSubTlv != countOtherSubTlv) {
            return false;
        } else {
            while (objListIterator.hasNext() && isCommonSubTlv) {
                PcepValueType subTlv = objListIterator.next();
                isCommonSubTlv = Objects.equals(llLinkAttributesSubTLVs.contains(subTlv), other.llLinkAttributesSubTLVs.contains(subTlv));
            }
            return isCommonSubTlv;
        }
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    /*
         * Here we have a list of Tlv so to compare each sub tlv between the object
         * we have to take a list iterator so one by one we can get each sub tlv object
         * and can compare them.
         * it may be possible that the size of 2 lists is not equal so we have to first check
         * the size, if both are same then we should check for the subtlv objects otherwise
         * we should return false.
         */
    if (obj instanceof TELinkAttributesTlv) {
        int countObjSubTlv = 0;
        int countOtherSubTlv = 0;
        boolean isCommonSubTlv = true;
        TELinkAttributesTlv other = (TELinkAttributesTlv) obj;
        Iterator<PcepValueType> objListIterator = ((TELinkAttributesTlv) obj).llLinkAttributesSubTLVs.iterator();
        countObjSubTlv = ((TELinkAttributesTlv) obj).llLinkAttributesSubTLVs.size();
        countOtherSubTlv = other.llLinkAttributesSubTLVs.size();
        if (countObjSubTlv != countOtherSubTlv) {
            return false;
        } else {
            while (objListIterator.hasNext() && isCommonSubTlv) {
                PcepValueType subTlv = objListIterator.next();
                isCommonSubTlv = Objects.equals(llLinkAttributesSubTLVs.contains(subTlv), other.llLinkAttributesSubTLVs.contains(subTlv));
            }
            return isCommonSubTlv;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof PceccCapabilityTlv) {
        PceccCapabilityTlv other = (PceccCapabilityTlv) obj;
        if (isRawValueSet) {
            return Objects.equals(this.rawValue, other.rawValue);
        } else {
            return Objects.equals(this.bGFlag, other.bGFlag) && Objects.equals(this.bLFlag, other.bLFlag);
        }
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof PceccCapabilityTlv) {
        PceccCapabilityTlv other = (PceccCapabilityTlv) obj;
        if (isRawValueSet) {
            return Objects.equals(this.rawValue, other.rawValue);
        } else {
            return Objects.equals(this.bGFlag, other.bGFlag) && Objects.equals(this.bLFlag, other.bLFlag);
        }
    }
    return false;
}
#end_block

#method_before
@Override
public PcepOpenMsg readFrom(ChannelBuffer cb) throws PcepParseException {
    if (cb.readableBytes() < PACKET_MINIMUM_LENGTH) {
        throw new PcepParseException("Packet size is less than the minimum length.");
    }
    byte version = cb.readByte();
    version = (byte) (version >> PcepMessageVer1.SHIFT_FLAG);
    if (version != PACKET_VERSION) {
        log.error("[readFrom] Invalid version: " + version);
        throw new PcepParseException(PcepErrorDetailInfo.ERROR_TYPE_1, PcepErrorDetailInfo.ERROR_VALUE_1);
    }
    // fixed value property type == 1
    byte type = cb.readByte();
    if (type != MSG_TYPE.getType()) {
        log.error("[readFrom] Unexpected type: " + type);
        throw new PcepParseException(PcepErrorDetailInfo.ERROR_TYPE_1, PcepErrorDetailInfo.ERROR_VALUE_1);
    }
    int length = (int) cb.readShort();
    if (length < PACKET_MINIMUM_LENGTH) {
        throw new PcepParseException("Wrong length: Expected to be >= " + PACKET_MINIMUM_LENGTH + ", was: " + length);
    }
    return new PcepOpenMsgVer1(PcepOpenObjectVer1.read(cb));
}
#method_after
@Override
public PcepOpenMsg readFrom(ChannelBuffer cb) throws PcepParseException {
    if (cb.readableBytes() < PACKET_MINIMUM_LENGTH) {
        throw new PcepParseException("Packet size is less than the minimum length.");
    }
    byte version = cb.readByte();
    version = (byte) (version >> PcepMessageVer1.SHIFT_FLAG);
    if (version != PACKET_VERSION) {
        log.error("[readFrom] Invalid version: " + version);
        throw new PcepParseException(PcepErrorDetailInfo.ERROR_TYPE_1, PcepErrorDetailInfo.ERROR_VALUE_1);
    }
    // fixed value property type == 1
    byte type = cb.readByte();
    if (type != MSG_TYPE.getType()) {
        log.error("[readFrom] Unexpected type: " + type);
        throw new PcepParseException(PcepErrorDetailInfo.ERROR_TYPE_1, PcepErrorDetailInfo.ERROR_VALUE_1);
    }
    int length = cb.readShort();
    if (length < PACKET_MINIMUM_LENGTH) {
        throw new PcepParseException("Wrong length: Expected to be >= " + PACKET_MINIMUM_LENGTH + ", was: " + length);
    }
    return new PcepOpenMsgVer1(PcepOpenObjectVer1.read(cb));
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof NodeNameTlv) {
        NodeNameTlv other = (NodeNameTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof NodeNameTlv) {
        NodeNameTlv other = (NodeNameTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof TedCapabilityTlv) {
        TedCapabilityTlv other = (TedCapabilityTlv) obj;
        if (isRawValueSet) {
            return Objects.equals(this.rawValue, other.rawValue);
        } else {
            return Objects.equals(this.bRFlag, other.bRFlag);
        }
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof TedCapabilityTlv) {
        TedCapabilityTlv other = (TedCapabilityTlv) obj;
        if (isRawValueSet) {
            return Objects.equals(this.rawValue, other.rawValue);
        } else {
            return Objects.equals(this.bRFlag, other.bRFlag);
        }
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof IPv6TERouterIdofLocalNodeTlv) {
        IPv6TERouterIdofLocalNodeTlv other = (IPv6TERouterIdofLocalNodeTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof IPv6TERouterIdofLocalNodeTlv) {
        IPv6TERouterIdofLocalNodeTlv other = (IPv6TERouterIdofLocalNodeTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    /*
         * Here we have a list of Tlv so to compare each sub tlv between the object
         * we have to take a list iterator so one by one we can get each sub tlv object
         * and can compare them.
         * it may be possible that the size of 2 lists is not equal so we have to first check
         * the size, if both are same then we should check for the subtlv objects otherwise
         * we should return false.
         */
    if (obj instanceof LocalTENodeDescriptorsTLV) {
        int countObjSubTlv = 0;
        int countOtherSubTlv = 0;
        boolean isCommonSubTlv = true;
        LocalTENodeDescriptorsTLV other = (LocalTENodeDescriptorsTLV) obj;
        Iterator<PcepValueType> objListIterator = ((LocalTENodeDescriptorsTLV) obj).llNodeDescriptorSubTLVs.iterator();
        countObjSubTlv = ((LocalTENodeDescriptorsTLV) obj).llNodeDescriptorSubTLVs.size();
        countOtherSubTlv = other.llNodeDescriptorSubTLVs.size();
        if (countObjSubTlv != countOtherSubTlv) {
            return false;
        } else {
            while (objListIterator.hasNext() && isCommonSubTlv) {
                PcepValueType subTlv = objListIterator.next();
                isCommonSubTlv = Objects.equals(llNodeDescriptorSubTLVs.contains(subTlv), other.llNodeDescriptorSubTLVs.contains(subTlv));
            }
            return isCommonSubTlv;
        }
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    /*
         * Here we have a list of Tlv so to compare each sub tlv between the object
         * we have to take a list iterator so one by one we can get each sub tlv object
         * and can compare them.
         * it may be possible that the size of 2 lists is not equal so we have to first check
         * the size, if both are same then we should check for the subtlv objects otherwise
         * we should return false.
         */
    if (obj instanceof LocalTENodeDescriptorsTLV) {
        int countObjSubTlv = 0;
        int countOtherSubTlv = 0;
        boolean isCommonSubTlv = true;
        LocalTENodeDescriptorsTLV other = (LocalTENodeDescriptorsTLV) obj;
        Iterator<PcepValueType> objListIterator = ((LocalTENodeDescriptorsTLV) obj).llNodeDescriptorSubTLVs.iterator();
        countObjSubTlv = ((LocalTENodeDescriptorsTLV) obj).llNodeDescriptorSubTLVs.size();
        countOtherSubTlv = other.llNodeDescriptorSubTLVs.size();
        if (countObjSubTlv != countOtherSubTlv) {
            return false;
        } else {
            while (objListIterator.hasNext() && isCommonSubTlv) {
                PcepValueType subTlv = objListIterator.next();
                isCommonSubTlv = Objects.equals(llNodeDescriptorSubTLVs.contains(subTlv), other.llNodeDescriptorSubTLVs.contains(subTlv));
            }
            return isCommonSubTlv;
        }
    }
    return false;
}
#end_block

#method_before
public static PcepErrorVer1 read(ChannelBuffer cb) throws PcepParseException {
    if (cb.readableBytes() < OBJECT_HEADER_LENGTH) {
        throw new PcepParseException("Unknown Object");
    }
    PcepErrorVer1 pcepError = new PcepErrorVer1();
    // check whether any PCEP Error Info is present
    cb.markReaderIndex();
    PcepObjectHeader tempObjHeader = PcepObjectHeader.read(cb);
    cb.resetReaderIndex();
    byte yObjClass = tempObjHeader.getObjClass();
    // If RPlist present then store it.RPList and TPList are optional
    if (yObjClass == PcepRPObjectVer1.RP_OBJ_CLASS) {
        log.debug("RP_LIST");
        pcepError.parseRPList(cb);
        yObjClass = checkNextObject(cb);
    } else if (yObjClass == PcepTEObjectVer1.TE_OBJ_CLASS) {
        log.debug("TE_LIST");
        pcepError.parseTEList(cb);
        yObjClass = checkNextObject(cb);
    }
    if (yObjClass == PcepErrorObjectVer1.ERROR_OBJ_CLASS) {
        log.debug("PCEP-ERROR obj list");
        pcepError.parseErrObjList(cb);
        yObjClass = checkNextObject(cb);
    }
    return pcepError;
}
#method_after
public static PcepErrorVer1 read(ChannelBuffer cb) throws PcepParseException {
    if (cb.readableBytes() < OBJECT_HEADER_LENGTH) {
        throw new PcepParseException("Unknown Object");
    }
    PcepErrorVer1 pcepError = new PcepErrorVer1();
    // check whether any PCEP Error Info is present
    cb.markReaderIndex();
    PcepObjectHeader tempObjHeader = PcepObjectHeader.read(cb);
    cb.resetReaderIndex();
    byte yObjClass = tempObjHeader.getObjClass();
    // If RPlist present then store it.RPList and TEList are optional
    if (yObjClass == PcepRPObjectVer1.RP_OBJ_CLASS) {
        log.debug("RP_LIST");
        pcepError.parseRPList(cb);
        yObjClass = checkNextObject(cb);
    } else if (yObjClass == PcepTEObjectVer1.TE_OBJ_CLASS) {
        log.debug("TE_LIST");
        pcepError.parseTEList(cb);
        yObjClass = checkNextObject(cb);
    }
    if (yObjClass == PcepErrorObjectVer1.ERROR_OBJ_CLASS) {
        log.debug("PCEP-ERROR obj list");
        pcepError.parseErrObjList(cb);
        yObjClass = checkNextObject(cb);
    }
    return pcepError;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof BGPLSidentifierTlv) {
        BGPLSidentifierTlv other = (BGPLSidentifierTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof BGPLSidentifierTlv) {
        BGPLSidentifierTlv other = (BGPLSidentifierTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof OSPFareaIDsubTlv) {
        OSPFareaIDsubTlv other = (OSPFareaIDsubTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof OSPFareaIDsubTlv) {
        OSPFareaIDsubTlv other = (OSPFareaIDsubTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof RouterIDSubTlv) {
        RouterIDSubTlv other = (RouterIDSubTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof RouterIDSubTlv) {
        RouterIDSubTlv other = (RouterIDSubTlv) obj;
        return Objects.equals(this.rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj instanceof IPv4NeighborAddressTlv) {
        IPv4NeighborAddressTlv other = (IPv4NeighborAddressTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof IPv4NeighborAddressTlv) {
        IPv4NeighborAddressTlv other = (IPv4NeighborAddressTlv) obj;
        return Objects.equals(rawValue, other.rawValue);
    }
    return false;
}
#end_block

#method_before
@Override
public void addBridge(BridgeName bridgeName) {
    DriverHandler handler = handler();
    OvsdbClientService ovsdbClient = getOvsdbClientService(handler);
    ovsdbClient.createBridge(bridgeName.name());
}
#method_after
@Override
public void addBridge(BridgeName bridgeName) {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    clientService.createBridge(bridgeName.name());
}
#end_block

#method_before
@Override
public void deleteBridge(BridgeName bridgeName) {
    DriverHandler handler = handler();
    OvsdbClientService ovsdbNode = getOvsdbClientService(handler);
    ovsdbNode.dropBridge(bridgeName.name());
}
#method_after
@Override
public void deleteBridge(BridgeName bridgeName) {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    clientService.dropBridge(bridgeName.name());
}
#end_block

#method_before
@Override
protected void populateTable(TableModel tm, ObjectNode payload) {
    TunnelService ts = get(TunnelService.class);
    if (!isNullOrEmpty(ts.queryAllTunnels())) {
        for (Tunnel tunnel : ts.queryAllTunnels()) {
            populateRow(tm.addRow(), tunnel);
        }
    }
}
#method_after
@Override
protected void populateTable(TableModel tm, ObjectNode payload) {
    TunnelService ts = get(TunnelService.class);
    ts.queryAllTunnels().forEach(tunnel -> {
        populateRow(tm.addRow(), tunnel);
    });
}
#end_block

#method_before
private TrafficSelector buildSelector() {
    MacAddress mac;
    Ip4Prefix ip4Prefix;
    Ip6Address ip6Address;
    Ip6Prefix ip6Prefix;
    TrafficSelector.Builder builder = DefaultTrafficSelector.builder();
    for (MatchField<?> field : match.getMatchFields()) {
        switch(field.id) {
            case IN_PORT:
                builder.matchInPort(PortNumber.portNumber(match.get(MatchField.IN_PORT).getPortNumber()));
                break;
            case IN_PHY_PORT:
                builder.matchInPhyPort(PortNumber.portNumber(match.get(MatchField.IN_PHY_PORT).getPortNumber()));
                break;
            case METADATA:
                long metadata = match.get(MatchField.METADATA).getValue().getValue();
                builder.matchMetadata(metadata);
                break;
            case ETH_DST:
                mac = MacAddress.valueOf(match.get(MatchField.ETH_DST).getLong());
                builder.matchEthDst(mac);
                break;
            case ETH_SRC:
                mac = MacAddress.valueOf(match.get(MatchField.ETH_SRC).getLong());
                builder.matchEthSrc(mac);
                break;
            case ETH_TYPE:
                int ethType = match.get(MatchField.ETH_TYPE).getValue();
                if (ethType == EthType.VLAN_FRAME.getValue()) {
                    builder.matchVlanId(VlanId.ANY);
                } else {
                    builder.matchEthType((short) ethType);
                }
                break;
            case VLAN_VID:
                VlanId vlanId = null;
                if (match.isPartiallyMasked(MatchField.VLAN_VID)) {
                    Masked<OFVlanVidMatch> masked = match.getMasked(MatchField.VLAN_VID);
                    if (masked.getValue().equals(OFVlanVidMatch.PRESENT) && masked.getMask().equals(OFVlanVidMatch.PRESENT)) {
                        vlanId = VlanId.ANY;
                    }
                } else {
                    if (!match.get(MatchField.VLAN_VID).isPresentBitSet()) {
                        vlanId = VlanId.NONE;
                    } else {
                        vlanId = VlanId.vlanId(match.get(MatchField.VLAN_VID).getVlan());
                    }
                }
                if (vlanId != null) {
                    builder.matchVlanId(vlanId);
                }
                break;
            case VLAN_PCP:
                byte vlanPcp = match.get(MatchField.VLAN_PCP).getValue();
                builder.matchVlanPcp(vlanPcp);
                break;
            case IP_DSCP:
                byte ipDscp = match.get(MatchField.IP_DSCP).getDscpValue();
                builder.matchIPDscp(ipDscp);
                break;
            case IP_ECN:
                byte ipEcn = match.get(MatchField.IP_ECN).getEcnValue();
                builder.matchIPEcn(ipEcn);
                break;
            case IP_PROTO:
                short proto = match.get(MatchField.IP_PROTO).getIpProtocolNumber();
                builder.matchIPProtocol((byte) proto);
                break;
            case IPV4_SRC:
                if (match.isPartiallyMasked(MatchField.IPV4_SRC)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_SRC);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_SRC).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPSrc(ip4Prefix);
                break;
            case IPV4_DST:
                if (match.isPartiallyMasked(MatchField.IPV4_DST)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_DST);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_DST).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPDst(ip4Prefix);
                break;
            case TCP_SRC:
                builder.matchTcpSrc((short) match.get(MatchField.TCP_SRC).getPort());
                break;
            case TCP_DST:
                builder.matchTcpDst((short) match.get(MatchField.TCP_DST).getPort());
                break;
            case UDP_SRC:
                builder.matchUdpSrc((short) match.get(MatchField.UDP_SRC).getPort());
                break;
            case UDP_DST:
                builder.matchUdpDst((short) match.get(MatchField.UDP_DST).getPort());
                break;
            case MPLS_LABEL:
                builder.matchMplsLabel(MplsLabel.mplsLabel((int) match.get(MatchField.MPLS_LABEL).getValue()));
                break;
            case SCTP_SRC:
                builder.matchSctpSrc((short) match.get(MatchField.SCTP_SRC).getPort());
                break;
            case SCTP_DST:
                builder.matchSctpDst((short) match.get(MatchField.SCTP_DST).getPort());
                break;
            case ICMPV4_TYPE:
                byte icmpType = (byte) match.get(MatchField.ICMPV4_TYPE).getType();
                builder.matchIcmpType(icmpType);
                break;
            case ICMPV4_CODE:
                byte icmpCode = (byte) match.get(MatchField.ICMPV4_CODE).getCode();
                builder.matchIcmpCode(icmpCode);
                break;
            case IPV6_SRC:
                if (match.isPartiallyMasked(MatchField.IPV6_SRC)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_SRC);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_SRC).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Src(ip6Prefix);
                break;
            case IPV6_DST:
                if (match.isPartiallyMasked(MatchField.IPV6_DST)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_DST);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_DST).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Dst(ip6Prefix);
                break;
            case IPV6_FLABEL:
                int flowLabel = match.get(MatchField.IPV6_FLABEL).getIPv6FlowLabelValue();
                builder.matchIPv6FlowLabel(flowLabel);
                break;
            case ICMPV6_TYPE:
                byte icmpv6type = (byte) match.get(MatchField.ICMPV6_TYPE).getValue();
                builder.matchIcmpv6Type(icmpv6type);
                break;
            case ICMPV6_CODE:
                byte icmpv6code = (byte) match.get(MatchField.ICMPV6_CODE).getValue();
                builder.matchIcmpv6Code(icmpv6code);
                break;
            case IPV6_ND_TARGET:
                ip6Address = Ip6Address.valueOf(match.get(MatchField.IPV6_ND_TARGET).getBytes());
                builder.matchIPv6NDTargetAddress(ip6Address);
                break;
            case IPV6_ND_SLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_SLL).getLong());
                builder.matchIPv6NDSourceLinkLayerAddress(mac);
                break;
            case IPV6_ND_TLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_TLL).getLong());
                builder.matchIPv6NDTargetLinkLayerAddress(mac);
                break;
            case IPV6_EXTHDR:
                builder.matchIPv6ExthdrFlags((short) match.get(MatchField.IPV6_EXTHDR).getValue());
                break;
            case OCH_SIGID:
                CircuitSignalID sigId = match.get(MatchField.OCH_SIGID);
                builder.add(matchLambda(Lambda.ochSignal(lookupGridType(sigId.getGridType()), lookupChannelSpacing(sigId.getChannelSpacing()), sigId.getChannelNumber(), sigId.getSpectralWidth())));
                break;
            case OCH_SIGTYPE:
                U8 sigType = match.get(MatchField.OCH_SIGTYPE);
                builder.add(matchOchSignalType(lookupOchSignalType((byte) sigType.getValue())));
                break;
            case TUNNEL_ID:
                long tunnelId = match.get(MatchField.TUNNEL_ID).getValue();
                builder.matchTunnelId(tunnelId);
                break;
            case ARP_OP:
            case ARP_SHA:
            case ARP_SPA:
            case ARP_THA:
            case ARP_TPA:
            case MPLS_TC:
            default:
                log.warn("Match type {} not yet implemented.", field.id);
        }
    }
    return builder.build();
}
#method_after
private TrafficSelector buildSelector() {
    MacAddress mac;
    Ip4Prefix ip4Prefix;
    Ip6Address ip6Address;
    Ip6Prefix ip6Prefix;
    TrafficSelector.Builder builder = DefaultTrafficSelector.builder();
    for (MatchField<?> field : match.getMatchFields()) {
        switch(field.id) {
            case IN_PORT:
                builder.matchInPort(PortNumber.portNumber(match.get(MatchField.IN_PORT).getPortNumber()));
                break;
            case IN_PHY_PORT:
                builder.matchInPhyPort(PortNumber.portNumber(match.get(MatchField.IN_PHY_PORT).getPortNumber()));
                break;
            case METADATA:
                long metadata = match.get(MatchField.METADATA).getValue().getValue();
                builder.matchMetadata(metadata);
                break;
            case ETH_DST:
                mac = MacAddress.valueOf(match.get(MatchField.ETH_DST).getLong());
                builder.matchEthDst(mac);
                break;
            case ETH_SRC:
                mac = MacAddress.valueOf(match.get(MatchField.ETH_SRC).getLong());
                builder.matchEthSrc(mac);
                break;
            case ETH_TYPE:
                int ethType = match.get(MatchField.ETH_TYPE).getValue();
                if (ethType == EthType.VLAN_FRAME.getValue()) {
                    builder.matchVlanId(VlanId.ANY);
                } else {
                    builder.matchEthType((short) ethType);
                }
                break;
            case VLAN_VID:
                VlanId vlanId = null;
                if (match.isPartiallyMasked(MatchField.VLAN_VID)) {
                    Masked<OFVlanVidMatch> masked = match.getMasked(MatchField.VLAN_VID);
                    if (masked.getValue().equals(OFVlanVidMatch.PRESENT) && masked.getMask().equals(OFVlanVidMatch.PRESENT)) {
                        vlanId = VlanId.ANY;
                    }
                } else {
                    if (!match.get(MatchField.VLAN_VID).isPresentBitSet()) {
                        vlanId = VlanId.NONE;
                    } else {
                        vlanId = VlanId.vlanId(match.get(MatchField.VLAN_VID).getVlan());
                    }
                }
                if (vlanId != null) {
                    builder.matchVlanId(vlanId);
                }
                break;
            case VLAN_PCP:
                byte vlanPcp = match.get(MatchField.VLAN_PCP).getValue();
                builder.matchVlanPcp(vlanPcp);
                break;
            case IP_DSCP:
                byte ipDscp = match.get(MatchField.IP_DSCP).getDscpValue();
                builder.matchIPDscp(ipDscp);
                break;
            case IP_ECN:
                byte ipEcn = match.get(MatchField.IP_ECN).getEcnValue();
                builder.matchIPEcn(ipEcn);
                break;
            case IP_PROTO:
                short proto = match.get(MatchField.IP_PROTO).getIpProtocolNumber();
                builder.matchIPProtocol((byte) proto);
                break;
            case IPV4_SRC:
                if (match.isPartiallyMasked(MatchField.IPV4_SRC)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_SRC);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_SRC).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPSrc(ip4Prefix);
                break;
            case IPV4_DST:
                if (match.isPartiallyMasked(MatchField.IPV4_DST)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_DST);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_DST).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPDst(ip4Prefix);
                break;
            case TCP_SRC:
                builder.matchTcpSrc((short) match.get(MatchField.TCP_SRC).getPort());
                break;
            case TCP_DST:
                builder.matchTcpDst((short) match.get(MatchField.TCP_DST).getPort());
                break;
            case UDP_SRC:
                builder.matchUdpSrc((short) match.get(MatchField.UDP_SRC).getPort());
                break;
            case UDP_DST:
                builder.matchUdpDst((short) match.get(MatchField.UDP_DST).getPort());
                break;
            case MPLS_LABEL:
                builder.matchMplsLabel(MplsLabel.mplsLabel((int) match.get(MatchField.MPLS_LABEL).getValue()));
                break;
            case MPLS_BOS:
                builder.matchMplsBos(match.get(MatchField.MPLS_BOS).getValue());
                break;
            case SCTP_SRC:
                builder.matchSctpSrc((short) match.get(MatchField.SCTP_SRC).getPort());
                break;
            case SCTP_DST:
                builder.matchSctpDst((short) match.get(MatchField.SCTP_DST).getPort());
                break;
            case ICMPV4_TYPE:
                byte icmpType = (byte) match.get(MatchField.ICMPV4_TYPE).getType();
                builder.matchIcmpType(icmpType);
                break;
            case ICMPV4_CODE:
                byte icmpCode = (byte) match.get(MatchField.ICMPV4_CODE).getCode();
                builder.matchIcmpCode(icmpCode);
                break;
            case IPV6_SRC:
                if (match.isPartiallyMasked(MatchField.IPV6_SRC)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_SRC);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_SRC).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Src(ip6Prefix);
                break;
            case IPV6_DST:
                if (match.isPartiallyMasked(MatchField.IPV6_DST)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_DST);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_DST).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Dst(ip6Prefix);
                break;
            case IPV6_FLABEL:
                int flowLabel = match.get(MatchField.IPV6_FLABEL).getIPv6FlowLabelValue();
                builder.matchIPv6FlowLabel(flowLabel);
                break;
            case ICMPV6_TYPE:
                byte icmpv6type = (byte) match.get(MatchField.ICMPV6_TYPE).getValue();
                builder.matchIcmpv6Type(icmpv6type);
                break;
            case ICMPV6_CODE:
                byte icmpv6code = (byte) match.get(MatchField.ICMPV6_CODE).getValue();
                builder.matchIcmpv6Code(icmpv6code);
                break;
            case IPV6_ND_TARGET:
                ip6Address = Ip6Address.valueOf(match.get(MatchField.IPV6_ND_TARGET).getBytes());
                builder.matchIPv6NDTargetAddress(ip6Address);
                break;
            case IPV6_ND_SLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_SLL).getLong());
                builder.matchIPv6NDSourceLinkLayerAddress(mac);
                break;
            case IPV6_ND_TLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_TLL).getLong());
                builder.matchIPv6NDTargetLinkLayerAddress(mac);
                break;
            case IPV6_EXTHDR:
                builder.matchIPv6ExthdrFlags((short) match.get(MatchField.IPV6_EXTHDR).getValue());
                break;
            case OCH_SIGID:
                CircuitSignalID sigId = match.get(MatchField.OCH_SIGID);
                builder.add(matchLambda(Lambda.ochSignal(lookupGridType(sigId.getGridType()), lookupChannelSpacing(sigId.getChannelSpacing()), sigId.getChannelNumber(), sigId.getSpectralWidth())));
                break;
            case OCH_SIGTYPE:
                U8 sigType = match.get(MatchField.OCH_SIGTYPE);
                builder.add(matchOchSignalType(lookupOchSignalType((byte) sigType.getValue())));
                break;
            case TUNNEL_ID:
                long tunnelId = match.get(MatchField.TUNNEL_ID).getValue();
                builder.matchTunnelId(tunnelId);
                break;
            case ARP_OP:
            case ARP_SHA:
            case ARP_SPA:
            case ARP_THA:
            case ARP_TPA:
            case MPLS_TC:
            default:
                log.warn("Match type {} not yet implemented.", field.id);
        }
    }
    return builder.build();
}
#end_block

#method_before
@Override
protected void execute() {
    StorageService storageService = get(StorageService.class);
    TransactionContext context = storageService.transactionContextBuilder().build();
    context.begin();
    try {
        map = context.getTransactionalMap(mapName, serializer);
        String response = map.get(key);
        context.commit();
        if (response == null) {
            print("Key %s not found.", key);
        } else {
            print("Key-value pair (%s, %s) found.", key, response);
        }
    } finally {
        context.abort();
    }
}
#method_after
@Override
protected void execute() {
    StorageService storageService = get(StorageService.class);
    TransactionContext context;
    if (inMemory) {
        context = storageService.transactionContextBuilder().withPartitionsDisabled().build();
    } else {
        context = storageService.transactionContextBuilder().build();
    }
    context.begin();
    try {
        map = context.getTransactionalMap(mapName, serializer);
        String response = map.get(key);
        context.commit();
        if (response == null) {
            print("Key %s not found.", key);
        } else {
            print("Key-value pair (%s, %s) found.", key, response);
        }
    } catch (Exception e) {
        context.abort();
        throw e;
    }
}
#end_block

#method_before
private static void checkEncoding(ByteBuf in) throws IOException {
    int inputStart = 0;
    int inputLength = 4;
    fliterCharaters(in);
    byte[] buff = new byte[4];
    in.getBytes(in.readerIndex(), buff);
    ByteSourceJsonBootstrapper strapper = new ByteSourceJsonBootstrapper(new IOContext(new BufferRecycler(), null, false), buff, inputStart, inputLength);
    JsonEncoding jsonEncoding = strapper.detectEncoding();
    if (!JsonEncoding.UTF8.equals(jsonEncoding)) {
        throw new UnSupportedException("Only UTF-8 encoding is supported.");
    }
}
#method_after
private static void checkEncoding(ByteBuf in) throws IOException {
    int inputStart = 0;
    int inputLength = 4;
    fliterCharaters(in);
    byte[] buff = new byte[4];
    in.getBytes(in.readerIndex(), buff);
    ByteSourceJsonBootstrapper strapper = new ByteSourceJsonBootstrapper(new IOContext(new BufferRecycler(), null, false), buff, inputStart, inputLength);
    JsonEncoding jsonEncoding = strapper.detectEncoding();
    if (!JsonEncoding.UTF8.equals(jsonEncoding)) {
        throw new UnsupportedException("Only UTF-8 encoding is supported.");
    }
}
#end_block

#method_before
public static String createFromMessage(String actualVersion, String fromVersion) {
    String message = toStringHelper("VersionMismatchException").addValue("The fromVersion should less than the actualVersion.\n" + "fromVersion: " + fromVersion + ".\n" + "actualVersion: " + actualVersion).toString();
    return message;
}
#method_after
public static String createFromMessage(String actualVersion, String fromVersion) {
    String message = "The fromVersion should less than the actualVersion.\n fromVersion: " + fromVersion + ".\n" + "actualVersion: " + actualVersion;
    return message;
}
#end_block

#method_before
public static String createToMessage(String actualVersion, String toVersion) {
    String message = toStringHelper("VersionMismatchException").addValue("The toVersion should greater than the required version.\n" + "toVersion: " + toVersion + ".\n" + "Actual Version: " + actualVersion).toString();
    return message;
}
#method_after
public static String createToMessage(String actualVersion, String toVersion) {
    String message = "The toVersion should greater than the actualVersion.\n" + "toVersion: " + toVersion + ".\n" + " actualVersion: " + actualVersion;
    return message;
}
#end_block

#method_before
private static Object convertResultType(JsonNode resultJsonNode, String methodName, ObjectMapper objectMapper) {
    switch(methodName) {
        case "getSchema":
        case "monitor":
            return resultJsonNode;
        case "echo":
        case "listDbs":
            return objectMapper.convertValue(resultJsonNode, objectMapper.getTypeFactory().constructParametricType(List.class, String.class));
        case "transact":
            return objectMapper.convertValue(resultJsonNode, objectMapper.getTypeFactory().constructParametricType(List.class, JsonNode.class));
        default:
            throw new UnSupportedException("does not support this rpc method" + methodName);
    }
}
#method_after
private static Object convertResultType(JsonNode resultJsonNode, String methodName, ObjectMapper objectMapper) {
    switch(methodName) {
        case "getSchema":
        case "monitor":
            return resultJsonNode;
        case "echo":
        case "listDbs":
            return objectMapper.convertValue(resultJsonNode, objectMapper.getTypeFactory().constructParametricType(List.class, String.class));
        case "transact":
            return objectMapper.convertValue(resultJsonNode, objectMapper.getTypeFactory().constructParametricType(List.class, JsonNode.class));
        default:
            throw new UnsupportedException("does not support this rpc method" + methodName);
    }
}
#end_block

#method_before
public static void jsonCallbackRequestParser(JsonNode jsonNode, Callback callback) {
    ObjectMapper objectMapper = ObjectMapperUtil.getObjectMapper();
    JsonNode params = jsonNode.get("params");
    Object param = null;
    String methodName = jsonNode.get("method").asText();
    switch(methodName) {
        case "update":
            param = objectMapper.convertValue(params, UpdateNotification.class);
            callback.update((UpdateNotification) param);
            break;
        default:
            throw new UnSupportedException("does not support this callback method: " + methodName);
    }
}
#method_after
public static void jsonCallbackRequestParser(JsonNode jsonNode, Callback callback) {
    ObjectMapper objectMapper = ObjectMapperUtil.getObjectMapper();
    JsonNode params = jsonNode.get("params");
    Object param = null;
    String methodName = jsonNode.get("method").asText();
    switch(methodName) {
        case "update":
            param = objectMapper.convertValue(params, UpdateNotification.class);
            callback.update((UpdateNotification) param);
            break;
        default:
            throw new UnsupportedException("does not support this callback method: " + methodName);
    }
}
#end_block

#method_before
@Override
public void onServerDetected(Device device) {
    Iterable<Device> devices = deviceService.getAvailableDevices();
    DriverHandler handler = driverService.createHandler(device.id());
    TunnelConfig config = handler.behaviour(TunnelConfig.class);
    BridgeConfig bridgeConfig = handler.behaviour(BridgeConfig.class);
    bridgeConfig.addBridge(BridgeName.bridgeName(DEFAULT_BRIDGE_NAME));
    String ipAddress = device.annotations().value(CONTROLLER_IP_KEY);
    IpAddress ip = IpAddress.valueOf(ipAddress);
    TunnelEndPoint tunnelAsSrcSrc = IpTunnelEndPoint.ipTunnelPoint(ip);
    TunnelEndPoint tunnelAsDstDst = IpTunnelEndPoint.ipTunnelPoint(ip);
    devices.forEach(d -> {
        if (!device.id().equals(d.id()) && Device.Type.CONTROLLER == d.type()) {
            String ipAddress1 = d.annotations().value(CONTROLLER_IP_KEY);
            IpAddress ip1 = IpAddress.valueOf(ipAddress1);
            TunnelEndPoint tunnelAsSrcDst = IpTunnelEndPoint.ipTunnelPoint(ip1);
            TunnelEndPoint tunnelAsDstSrc = IpTunnelEndPoint.ipTunnelPoint(ip1);
            TunnelDescription tunnelAsSrc = new DefaultTunnelDescription(tunnelAsSrcSrc, tunnelAsSrcDst, TunnelDescription.Type.VXLAN, null);
            TunnelDescription tunnelAsDst = new DefaultTunnelDescription(tunnelAsDstDst, tunnelAsDstSrc, TunnelDescription.Type.VXLAN, null);
            config.createTunnel(tunnelAsSrc);
            config.createTunnel(tunnelAsDst);
        }
    });
}
#method_after
@Override
public void onServerDetected(Device device) {
    Iterable<Device> devices = deviceService.getAvailableDevices();
    DriverHandler handler = driverService.createHandler(device.id());
    BridgeConfig bridgeConfig = handler.behaviour(BridgeConfig.class);
    bridgeConfig.addBridge(BridgeName.bridgeName(DEFAULT_BRIDGE_NAME));
    String ipAddress = device.annotations().value(CONTROLLER_IP_KEY);
    IpAddress ip = IpAddress.valueOf(ipAddress);
    Sets.newHashSet(devices).stream().filter(d -> d.type() == Device.Type.CONTROLLER).filter(d -> !device.id().equals(d.id())).forEach(d -> {
        String ipAddress1 = d.annotations().value(CONTROLLER_IP_KEY);
        IpAddress ip1 = IpAddress.valueOf(ipAddress1);
        applyTunnelConfig(ip, ip1, handler);
        DriverHandler handler1 = driverService.createHandler(d.id());
        applyTunnelConfig(ip1, ip, handler1);
    });
}
#end_block

#method_before
@Override
public void onServerVanished(Device device) {
    Iterable<Device> devices = deviceService.getAvailableDevices();
    DriverHandler handler = driverService.createHandler(device.id());
    TunnelConfig config = handler.behaviour(TunnelConfig.class);
    BridgeConfig bridgeConfig = handler.behaviour(BridgeConfig.class);
    bridgeConfig.deleteBridge(BridgeName.bridgeName(DEFAULT_BRIDGE_NAME));
    String ipAddress = device.annotations().value(CONTROLLER_IP_KEY);
    IpAddress ip = IpAddress.valueOf(ipAddress);
    TunnelEndPoint tunnelAsSrcSrc = IpTunnelEndPoint.ipTunnelPoint(ip);
    TunnelEndPoint tunnelAsDstDst = IpTunnelEndPoint.ipTunnelPoint(ip);
    devices.forEach(d -> {
        if (!device.id().equals(d.id()) && Device.Type.CONTROLLER == d.type()) {
            String ipAddress1 = d.annotations().value(CONTROLLER_IP_KEY);
            IpAddress ip1 = IpAddress.valueOf(ipAddress1);
            TunnelEndPoint tunnelAsSrcDst = IpTunnelEndPoint.ipTunnelPoint(ip1);
            TunnelEndPoint tunnelAsDstSrc = IpTunnelEndPoint.ipTunnelPoint(ip1);
            TunnelDescription tunnelAsSrc = new DefaultTunnelDescription(tunnelAsSrcSrc, tunnelAsSrcDst, TunnelDescription.Type.VXLAN, null);
            TunnelDescription tunnelAsDst = new DefaultTunnelDescription(tunnelAsDstDst, tunnelAsDstSrc, TunnelDescription.Type.VXLAN, null);
            config.removeTunnel(tunnelAsSrc);
            config.removeTunnel(tunnelAsDst);
        }
    });
}
#method_after
@Override
public void onServerVanished(Device device) {
    Iterable<Device> devices = deviceService.getAvailableDevices();
    String ipAddress = device.annotations().value(CONTROLLER_IP_KEY);
    IpAddress dst = IpAddress.valueOf(ipAddress);
    Sets.newHashSet(devices).stream().filter(d -> d.type() == Device.Type.CONTROLLER).filter(d -> !device.id().equals(d.id())).forEach(d -> {
        String ipAddress1 = d.annotations().value(CONTROLLER_IP_KEY);
        DriverHandler handler = driverService.createHandler(d.id());
        IpAddress src = IpAddress.valueOf(ipAddress1);
        removeTunnelConfig(src, dst, handler);
    });
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    if (Device.Type.CONTROLLER == device.type() && DeviceEvent.Type.DEVICE_ADDED == event.type()) {
        backgroundService.execute(() -> {
            onServerDetected(device);
        });
    } else if (Device.Type.CONTROLLER == device.type() && DeviceEvent.Type.DEVICE_REMOVED == event.type()) {
        backgroundService.execute(() -> {
            onServerVanished(device);
        });
    } else if (Device.Type.SWITCH == device.type() && DeviceEvent.Type.DEVICE_ADDED == event.type()) {
        backgroundService.execute(() -> {
            onOvsDetected(device);
        });
    } else if (Device.Type.SWITCH == device.type() && DeviceEvent.Type.DEVICE_REMOVED == event.type()) {
        backgroundService.execute(() -> {
            onOvsVanished(device);
        });
    } else {
        log.info("do nothing for this device type");
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    Device device = event.subject();
    if (Device.Type.CONTROLLER == device.type() && DeviceEvent.Type.DEVICE_ADDED == event.type()) {
        backgroundService.execute(() -> {
            onServerDetected(device);
        });
    } else if (Device.Type.CONTROLLER == device.type() && DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED == event.type()) {
        backgroundService.execute(() -> {
            onServerVanished(device);
        });
    } else if (Device.Type.SWITCH == device.type() && DeviceEvent.Type.DEVICE_ADDED == event.type()) {
        backgroundService.execute(() -> {
            onOvsDetected(device);
        });
    } else if (Device.Type.SWITCH == device.type() && DeviceEvent.Type.DEVICE_AVAILABILITY_CHANGED == event.type()) {
        backgroundService.execute(() -> {
            onOvsVanished(device);
        });
    } else {
        log.info("do nothing for this device type");
    }
}
#end_block

#method_before
private void programLocalOut(DeviceId dpid, SegmentationId segmentationId, PortNumber outPort, MacAddress sourceMac, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(sourceMac).matchEthType(ETH_TYPE_MAC).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().add(Instructions.modTunnelId(Long.parseLong(segmentationId.toString()))).setOutput(outPort).build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#method_after
private void programLocalOut(DeviceId dpid, SegmentationId segmentationId, PortNumber outPort, MacAddress sourceMac, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(sourceMac).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().add(Instructions.modTunnelId(Long.parseLong(segmentationId.toString()))).setOutput(outPort).build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).withFlag(Flag.SPECIFIC);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#end_block

#method_before
private void programTunnelOut(DeviceId dpid, SegmentationId segmentationId, PortNumber outPort, MacAddress sourceMac, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(sourceMac).matchEthType(ETH_TYPE_MAC).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().add(Instructions.modTunnelId(Long.parseLong(segmentationId.toString()))).setOutput(outPort).build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#method_after
private void programTunnelOut(DeviceId dpid, SegmentationId segmentationId, PortNumber outPort, MacAddress sourceMac, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthDst(sourceMac).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().add(Instructions.modTunnelId(Long.parseLong(segmentationId.toString()))).setOutput(outPort).build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#end_block

#method_before
private void programTunnelFloodOut(DeviceId dpid, SegmentationId segmentationId, PortNumber ofPortOut, Iterable<Port> localports, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(ofPortOut).matchEthType(ETH_TYPE_MAC).add(Criteria.matchTunnelId(Long.parseLong(segmentationId.toString()))).matchEthDst(MacAddress.BROADCAST).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    for (Port outport : localports) {
        treatment.setOutput(outport.number());
    }
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#method_after
// Used to forward multicast flows to remote VMs of the same tenant via
private void programTunnelFloodOut(DeviceId dpid, SegmentationId segmentationId, PortNumber ofPortOut, Iterable<Port> localports, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(ofPortOut).add(Criteria.matchTunnelId(Long.parseLong(segmentationId.toString()))).matchEthDst(MacAddress.BROADCAST).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    for (Port outport : localports) {
        treatment.setOutput(outport.number());
    }
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#end_block

#method_before
private void programMacDefaultRules(DeviceId dpid, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(ETH_TYPE_MAC).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().drop().build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#method_after
private void programMacDefaultRules(DeviceId dpid, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().drop().build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#end_block

#method_before
private void programLocalBcastRules(DeviceId dpid, SegmentationId segmentationId, PortNumber inPort, List<Port> allports, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(inPort).matchEthType(ETH_TYPE_MAC).matchEthDst(MacAddress.BROADCAST).add(Criteria.matchTunnelId(Long.parseLong(segmentationId.toString()))).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    for (Port outport : allports) {
        if (inPort != outport.number()) {
            treatment.setOutput(outport.number());
        }
    }
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#method_after
private void programLocalBcastRules(DeviceId dpid, SegmentationId segmentationId, PortNumber inPort, List<Port> allports, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(inPort).matchEthDst(MacAddress.BROADCAST).add(Criteria.matchTunnelId(Long.parseLong(segmentationId.toString()))).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    for (Port outport : allports) {
        if (inPort != outport.number()) {
            treatment.setOutput(outport.number());
        }
    }
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#end_block

#method_before
private void programLocalIn(DeviceId dpid, SegmentationId segmentationId, PortNumber inPort, MacAddress srcMac, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(inPort).matchEthSrc(srcMac).matchEthType(ETH_TYPE_PORT).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.add(Instructions.modTunnelId(Long.parseLong(segmentationId.toString())));
    treatment.transition(MAC_TABLE);
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#method_after
private void programLocalIn(DeviceId dpid, SegmentationId segmentationId, PortNumber inPort, MacAddress srcMac, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(inPort).matchEthSrc(srcMac).build();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.add(Instructions.modTunnelId(Long.parseLong(segmentationId.toString())));
    treatment.transition(MAC_TABLE);
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment.build()).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#end_block

#method_before
private void programTunnelIn(DeviceId dpid, SegmentationId segmentationId, PortNumber inPort, MacAddress sourceMac, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(inPort).matchEthType(ETH_TYPE_PORT).add(Criteria.matchTunnelId(Long.parseLong(segmentationId.toString()))).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().transition(MAC_TABLE).build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#method_after
private void programTunnelIn(DeviceId dpid, SegmentationId segmentationId, PortNumber inPort, MacAddress sourceMac, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchInPort(inPort).add(Criteria.matchTunnelId(Long.parseLong(segmentationId.toString()))).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().transition(MAC_TABLE).build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#end_block

#method_before
private void programPortDefaultRules(DeviceId dpid, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(ETH_TYPE_PORT).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().transition(MAC_TABLE).build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#method_after
private void programPortDefaultRules(DeviceId dpid, ApplicationId appid, Objective.Operation type) {
    TrafficSelector selector = DefaultTrafficSelector.builder().build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().transition(MAC_TABLE).build();
    ForwardingObjective.Builder objective = DefaultForwardingObjective.builder().withTreatment(treatment).withSelector(selector).fromApp(appId).makePermanent().withFlag(Flag.SPECIFIC);
    if (type.equals(Objective.Operation.ADD)) {
        flowObjectiveService.forward(dpid, objective.add());
    } else {
        flowObjectiveService.forward(dpid, objective.remove());
    }
}
#end_block

#method_before
@Override
public PcepMessage readFrom(ChannelBuffer bb) throws PcepParseError {
    if (!bb.readable()) {
        log.debug("[PcepFactory:]Error: Empty message received");
        throw new PcepParseError("[PcepFactory:]Error: Empty message received");
    }
    /*
             * 0                   1                   2                   3
             * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             * | Ver |  Flags  |                                               |
             * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             *
             * Currently Version 1 is supported
             * Currently no flags are used, it is all ignored
             */
    byte packetVersion = bb.getByte(bb.readerIndex());
    packetVersion = (byte) (packetVersion >> SHIFT_FLAG);
    PcepFactory factory;
    switch(packetVersion) {
        case 1:
            // TODO : get the factory for version 1
            break;
        default:
            throw new IllegalArgumentException("Unknown Packet version: " + packetVersion);
    }
    // TODO : Read the PCEP message from the factory
    return null;
}
#method_after
@Override
public PcepMessage readFrom(ChannelBuffer bb) throws PcepParseException {
    if (!bb.readable()) {
        log.debug("Empty message received");
        throw new PcepParseException("Empty message received");
    }
    /*
             * 0                   1                   2                   3
             * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             * | Ver |  Flags  |                                               |
             * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             *
             * Currently Version 1 is supported
             * Currently no flags are used, it is all ignored
             */
    byte packetVersion = bb.getByte(bb.readerIndex());
    packetVersion = (byte) (packetVersion >> SHIFT_FLAG);
    PcepFactory factory;
    switch(packetVersion) {
        case 1:
            // TODO : get the factory for version 1
            break;
        default:
            throw new IllegalArgumentException("Unknown Packet version: " + packetVersion);
    }
    // TODO : Read the PCEP message from the factory
    return null;
}
#end_block

#method_before
public int write(ChannelBuffer bb) throws PcepParseError {
    int iLenStartIndex = bb.writerIndex();
    boolean bIsErrObjListFound = false;
    // <error-obj-list> is mandatory , if not present throw exception.
    if (llerrorObjList != null) {
        ListIterator<PcepErrorObject> errObjListIterator = llerrorObjList.listIterator();
        while (errObjListIterator.hasNext()) {
            errObjListIterator.next().write(bb);
            bIsErrObjListFound = true;
        }
    }
    if (!bIsErrObjListFound) {
        throw new PcepParseError("Error: [ErrorObjListWithOpen::write] <error-obj-list> is mandatory.");
    }
    // Open Object is optional , if present write.
    if (openObject != null) {
        openObject.write(bb);
    }
    return bb.writerIndex() - iLenStartIndex;
}
#method_after
public int write(ChannelBuffer bb) throws PcepParseException {
    int iLenStartIndex = bb.writerIndex();
    boolean bIsErrObjListFound = false;
    // <error-obj-list> is mandatory , if not present throw exception.
    if (llerrorObjList != null) {
        ListIterator<PcepErrorObject> errObjListIterator = llerrorObjList.listIterator();
        while (errObjListIterator.hasNext()) {
            errObjListIterator.next().write(bb);
            bIsErrObjListFound = true;
        }
    }
    if (!bIsErrObjListFound) {
        throw new PcepParseException("Error: [ErrorObjListWithOpen::write] <error-obj-list> is mandatory.");
    }
    // Open Object is optional , if present write.
    if (openObject != null) {
        openObject.write(bb);
    }
    return bb.writerIndex() - iLenStartIndex;
}
#end_block

#method_before
@Activate
public void activate() {
    backgroundService = newSingleThreadScheduledExecutor(groupedThreads("onos/subnet", "manager-background"));
    // subnetStore = storageService
    // .<SubnetId, Subnet> eventuallyConsistentMapBuilder()
    // .withName("subnetid_subnet")
    // .withClockService(new WallclockClockManager<>()).build();
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(MultiValuedTimestamp.class);
    subnetStore = storageService.<SubnetId, Subnet>eventuallyConsistentMapBuilder().withName("all_subnet").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(MultiValuedTimestamp.class);
    subnetStore = storageService.<SubnetId, Subnet>eventuallyConsistentMapBuilder().withName("all_subnet").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.info("SubnetManager  started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    backgroundService.shutdown();
    subnetStore.destroy();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    subnetStore.destroy();
    log.info("SubnetManager stopped");
}
#end_block

#method_before
@Override
public boolean createSubnets(Iterable<Subnet> subnets) {
    for (Subnet subnet : subnets) {
        // if (!neutronNetworkService.isExists(NeutronNetworkId
        // .networkId(subnet.networkId().toString()))) {
        // return false;
        // }
        subnetStore.put(subnet.id(), subnet);
    }
    return true;
}
#method_after
@Override
public boolean createSubnets(Iterable<Subnet> subnets) {
    checkNotNull(subnets, SUBNET_NOT_NULL);
    for (Subnet subnet : subnets) {
        if (!tenantNetworkService.exists(subnet.networkId())) {
            log.debug("The network identifier that the subnet {} belong to is not exist", subnet.networkId().toString(), subnet.id().toString());
            return false;
        }
        subnetStore.put(subnet.id(), subnet);
        if (!subnetStore.containsKey(subnet.id())) {
            log.debug("The identified subnet whose identifier is {}  create failed", subnet.id().toString());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public boolean updateSubnets(Iterable<Subnet> subnets) {
    if (subnets != null) {
        for (Subnet subnet : subnets) {
            if (exists(subnet.id())) {
                subnetStore.put(subnet.id(), subnet);
            }
        }
    }
    return true;
}
#method_after
@Override
public boolean updateSubnets(Iterable<Subnet> subnets) {
    checkNotNull(subnets, SUBNET_NOT_NULL);
    if (subnets != null) {
        for (Subnet subnet : subnets) {
            if (!subnetStore.containsKey(subnet.id())) {
                log.debug("The subnet is not exist whose identifier is {}", subnet.id().toString());
                return false;
            }
            subnetStore.put(subnet.id(), subnet);
            if (!subnet.equals(subnetStore.get(subnet.id()))) {
                log.debug("The subnet is updated failed whose identifier is {}", subnet.id().toString());
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
public boolean removeSubnets(Iterable<SubnetId> subnetIds) {
    if (subnetIds != null) {
        for (SubnetId subnetId : subnetIds) {
            if (exists(subnetId)) {
                subnetStore.remove(subnetId);
            }
        }
    }
    return true;
}
#method_after
@Override
public boolean removeSubnets(Iterable<SubnetId> subnetIds) {
    checkNotNull(subnetIds, SUBNET_ID_NULL);
    if (subnetIds != null) {
        for (SubnetId subnetId : subnetIds) {
            subnetStore.remove(subnetId);
            if (subnetStore.containsKey(subnetId)) {
                log.debug("The subnet created is failed whose identifier is {}", subnetId.toString());
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
public static SubnetId subnetId(String subnetId) {
    return new SubnetId(subnetId);
}
#method_after
public String subnetId() {
    return subnetId;
}
#end_block

#method_before
@Override
public ObjectNode encode(AllowedAddressPair alocAddPair, CodecContext context) {
    checkNotNull(alocAddPair, "AllowedAddressPair cannot be null");
    ObjectNode result = context.mapper().createObjectNode().put("ip", alocAddPair.ip().toString()).put("mac", alocAddPair.mac().toString());
    return result;
}
#method_after
@Override
public ObjectNode encode(AllowedAddressPair alocAddPair, CodecContext context) {
    checkNotNull(alocAddPair, "AllowedAddressPair cannot be null");
    ObjectNode result = context.mapper().createObjectNode().put("ip_address", alocAddPair.ip().toString()).put("mac_address", alocAddPair.mac().toString());
    return result;
}
#end_block

#method_before
@Override
public ObjectNode encode(FixedIp fixIp, CodecContext context) {
    checkNotNull(fixIp, "FixedIp cannot be null");
    ObjectNode result = context.mapper().createObjectNode().put("subnetId", fixIp.subnetId().toString()).put("ipAddress", fixIp.ip().toString());
    return result;
}
#method_after
@Override
public ObjectNode encode(FixedIp fixIp, CodecContext context) {
    checkNotNull(fixIp, "FixedIp cannot be null");
    ObjectNode result = context.mapper().createObjectNode().put("subnet_id", fixIp.subnetId().toString()).put("ip_address", fixIp.ip().toString());
    return result;
}
#end_block

#method_before
@Override
public ObjectNode encode(SecurityGroup securGroup, CodecContext context) {
    checkNotNull(securGroup, "SecurityGroup cannot be null");
    ObjectNode result = context.mapper().createObjectNode().put("securityGroup", securGroup.securityGroup());
    return result;
}
#method_after
@Override
public ObjectNode encode(SecurityGroup securGroup, CodecContext context) {
    checkNotNull(securGroup, "SecurityGroup cannot be null");
    ObjectNode result = context.mapper().createObjectNode().put("security_group", securGroup.securityGroup());
    return result;
}
#end_block

#method_before
@Override
public ObjectNode encode(VirtualPort vPort, CodecContext context) {
    checkNotNull(vPort, "VPort cannot be null");
    ObjectNode result = context.mapper().createObjectNode().put("id", vPort.portId().toString()).put("networkId", vPort.networkId().toString()).put("adminStateUp", vPort.adminStateUp().toString()).put("name", vPort.name().toString()).put("state", vPort.state().toString()).put("macAddress", vPort.macAddress().toString()).put("tenantId", vPort.tenantId().toString()).put("deviceId", vPort.deviceId().toString()).put("deviceOwner", vPort.deviceOwner().toString()).put("bindingVnicType", vPort.bindingVnicType().toString()).put("bindingVifType", vPort.bindingVifType().toString()).put("bindingHostId", vPort.bindingHostId().toString()).put("bindingvifDetails", vPort.bindingvifDetails().toString());
    result.set("allowedAddressPairs", new AllowedAddressPairCodec().encode(vPort.allowedAddressPairs(), context));
    result.set("fixedIp", new FixedIpCodec().encode(vPort.fixedIps(), context));
    result.set("securityGroups", new SecurityGroupCodec().encode(vPort.securityGroups(), context));
    return result;
}
#method_after
@Override
public ObjectNode encode(VirtualPort vPort, CodecContext context) {
    checkNotNull(vPort, "VPort cannot be null");
    ObjectNode result = context.mapper().createObjectNode().put("id", vPort.portId().toString()).put("network_id", vPort.networkId().toString()).put("admin_state_up", vPort.adminStateUp()).put("name", vPort.name().toString()).put("status", vPort.state().toString()).put("mac_address", vPort.macAddress().toString()).put("tenant_id", vPort.tenantId().toString()).put("device_id", vPort.deviceId().toString()).put("device_owner", vPort.deviceOwner().toString()).put("binding:vnic_type", vPort.bindingVnicType().toString()).put("binding:Vif_type", vPort.bindingVifType().toString()).put("binding:host_id", vPort.bindingHostId().mac().toString()).put("binding:vif_details", vPort.bindingVifDetails().toString());
    result.set("allowed_address_pairs", new AllowedAddressPairCodec().encode(vPort.allowedAddressPairs(), context));
    result.set("fixed_ips", new FixedIpCodec().encode(vPort.fixedIps(), context));
    result.set("security_groups", new SecurityGroupCodec().encode(vPort.securityGroups(), context));
    return result;
}
#end_block

#method_before
@Override
public DistributedQueue<E> build() {
    checkState(validInputs());
    Consumer<Set<NodeId>> notifyOthers = nodes -> databaseManager.clusterCommunicator.multicast(name, DatabaseManager.QUEUE_UPDATED_TOPIC, s -> s.getBytes(Charsets.UTF_8), nodes);
    DefaultDistributedQueue<E> queue = new DefaultDistributedQueue<>(name, persistenceEnabled ? databaseManager.partitionedDatabase : databaseManager.inMemoryDatabase, serializer, databaseManager.localNodeId, usageMonitor, notifyOthers);
    databaseManager.registerQueue(queue);
    return queue;
}
#method_after
@Override
public DistributedQueue<E> build() {
    checkState(validInputs());
    Consumer<Set<NodeId>> notifyOthers = nodes -> databaseManager.clusterCommunicator.multicast(name, DatabaseManager.QUEUE_UPDATED_TOPIC, s -> s.getBytes(Charsets.UTF_8), nodes);
    DefaultDistributedQueue<E> queue = new DefaultDistributedQueue<>(name, persistenceEnabled ? databaseManager.partitionedDatabase : databaseManager.inMemoryDatabase, serializer, databaseManager.localNodeId, metering, notifyOthers);
    databaseManager.registerQueue(queue);
    return queue;
}
#end_block

#method_before
@Override
public boolean compareAndSet(V expect, V update) {
    final UsageMonitor.Context newTimer = monitor.startTimer(COMPARE_AND_SET);
    try {
        if (expect == null) {
            if (update == null) {
                return true;
            }
            return valueMap.putIfAbsent(name, serializer.encode(update)) == null;
        } else {
            if (update == null) {
                return valueMap.remove(name, serializer.encode(expect));
            }
            return valueMap.replace(name, serializer.encode(expect), serializer.encode(update));
        }
    } finally {
        newTimer.stop();
    }
}
#method_after
@Override
public boolean compareAndSet(V expect, V update) {
    final MeteringAgent.Context newTimer = monitor.startTimer(COMPARE_AND_SET);
    try {
        if (expect == null) {
            if (update == null) {
                return true;
            }
            return valueMap.putIfAbsent(name, serializer.encode(update)) == null;
        } else {
            if (update == null) {
                return valueMap.remove(name, serializer.encode(expect));
            }
            return valueMap.replace(name, serializer.encode(expect), serializer.encode(update));
        }
    } finally {
        newTimer.stop();
    }
}
#end_block

#method_before
@Override
public V get() {
    final UsageMonitor.Context newTimer = monitor.startTimer(GET);
    try {
        Versioned<byte[]> rawValue = valueMap.get(name);
        return rawValue == null ? null : serializer.decode(rawValue.value());
    } finally {
        newTimer.stop();
    }
}
#method_after
@Override
public V get() {
    final MeteringAgent.Context newTimer = monitor.startTimer(GET);
    try {
        Versioned<byte[]> rawValue = valueMap.get(name);
        return rawValue == null ? null : serializer.decode(rawValue.value());
    } finally {
        newTimer.stop();
    }
}
#end_block

#method_before
@Override
public V getAndSet(V value) {
    final UsageMonitor.Context newTimer = monitor.startTimer(GET_AND_SET);
    try {
        Versioned<byte[]> previousValue = value == null ? valueMap.remove(name) : valueMap.put(name, serializer.encode(value));
        return previousValue == null ? null : serializer.decode(previousValue.value());
    } finally {
        newTimer.stop();
    }
}
#method_after
@Override
public V getAndSet(V value) {
    final MeteringAgent.Context newTimer = monitor.startTimer(GET_AND_SET);
    try {
        Versioned<byte[]> previousValue = value == null ? valueMap.remove(name) : valueMap.put(name, serializer.encode(value));
        return previousValue == null ? null : serializer.decode(previousValue.value());
    } finally {
        newTimer.stop();
    }
}
#end_block

#method_before
@Override
public long size() {
    final UsageMonitor.Context timer = monitor.startTimer(SIZE);
    try {
        return Futures.getUnchecked(database.queueSize(name));
    } finally {
        timer.stop();
    }
}
#method_after
@Override
public long size() {
    final MeteringAgent.Context timer = monitor.startTimer(SIZE);
    try {
        return Futures.getUnchecked(database.queueSize(name));
    } finally {
        timer.stop();
    }
}
#end_block

#method_before
@Override
public void push(E entry) {
    final UsageMonitor.Context timer = monitor.startTimer(PUSH);
    try {
        checkNotNull(entry, ERROR_NULL_ENTRY);
        Futures.getUnchecked(database.queuePush(name, serializer.encode(entry)).thenAccept(notifyConsumers).thenApply(v -> null));
    } finally {
        timer.stop();
    }
}
#method_after
@Override
public void push(E entry) {
    final MeteringAgent.Context timer = monitor.startTimer(PUSH);
    try {
        checkNotNull(entry, ERROR_NULL_ENTRY);
        Futures.getUnchecked(database.queuePush(name, serializer.encode(entry)).thenAccept(notifyConsumers).thenApply(v -> null));
    } finally {
        timer.stop();
    }
}
#end_block

#method_before
@Override
public CompletableFuture<E> pop() {
    final UsageMonitor.Context timer = monitor.startTimer(POP);
    return database.queuePop(name, localNodeId).thenCompose(v -> {
        if (v != null) {
            return CompletableFuture.completedFuture(serializer.decode(v));
        } else {
            CompletableFuture<E> newPendingFuture = new CompletableFuture<>();
            pendingFutures.add(newPendingFuture);
            return newPendingFuture;
        }
    }).whenComplete((r, e) -> timer.stop());
}
#method_after
@Override
public CompletableFuture<E> pop() {
    final MeteringAgent.Context timer = monitor.startTimer(POP);
    return database.queuePop(name, localNodeId).thenCompose(v -> {
        if (v != null) {
            return CompletableFuture.completedFuture(serializer.decode(v));
        } else {
            CompletableFuture<E> newPendingFuture = new CompletableFuture<>();
            pendingFutures.add(newPendingFuture);
            return newPendingFuture;
        }
    }).whenComplete((r, e) -> timer.stop());
}
#end_block

#method_before
@Override
public E peek() {
    final UsageMonitor.Context timer = monitor.startTimer(PEEK);
    try {
        return Futures.getUnchecked(database.queuePeek(name).thenApply(v -> v != null ? serializer.decode(v) : null));
    } finally {
        timer.stop();
    }
}
#method_after
@Override
public E peek() {
    final MeteringAgent.Context timer = monitor.startTimer(PEEK);
    try {
        return Futures.getUnchecked(database.queuePeek(name).thenApply(v -> v != null ? serializer.decode(v) : null));
    } finally {
        timer.stop();
    }
}
#end_block

#method_before
@Override
public AtomicValue<V> build() {
    return new DefaultAtomicValue<>(mapBuilder.build(), name, usageMonitor, serializer);
}
#method_after
@Override
public AtomicValue<V> build() {
    return new DefaultAtomicValue<>(mapBuilder.build(), name, metering, serializer);
}
#end_block

#method_before
@Override
public CompletableFuture<Integer> size() {
    final UsageMonitor.Context timer = monitor.startTimer(SIZE);
    return database.mapSize(name).whenComplete((r, e) -> timer.stop());
}
#method_after
@Override
public CompletableFuture<Integer> size() {
    final MeteringAgent.Context timer = monitor.startTimer(SIZE);
    return database.mapSize(name).whenComplete((r, e) -> timer.stop());
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> isEmpty() {
    final UsageMonitor.Context timer = monitor.startTimer(IS_EMPTY);
    return database.mapIsEmpty(name).whenComplete((r, e) -> timer.stop());
}
#method_after
@Override
public CompletableFuture<Boolean> isEmpty() {
    final MeteringAgent.Context timer = monitor.startTimer(IS_EMPTY);
    return database.mapIsEmpty(name).whenComplete((r, e) -> timer.stop());
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> containsKey(K key) {
    checkNotNull(key, ERROR_NULL_KEY);
    final UsageMonitor.Context timer = monitor.startTimer(CONTAINS_KEY);
    return database.mapContainsKey(name, keyCache.getUnchecked(key)).whenComplete((r, e) -> timer.stop());
}
#method_after
@Override
public CompletableFuture<Boolean> containsKey(K key) {
    checkNotNull(key, ERROR_NULL_KEY);
    final MeteringAgent.Context timer = monitor.startTimer(CONTAINS_KEY);
    return database.mapContainsKey(name, keyCache.getUnchecked(key)).whenComplete((r, e) -> timer.stop());
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> containsValue(V value) {
    checkNotNull(value, ERROR_NULL_VALUE);
    final UsageMonitor.Context timer = monitor.startTimer(CONTAINS_VALUE);
    return database.mapContainsValue(name, serializer.encode(value)).whenComplete((r, e) -> timer.stop());
}
#method_after
@Override
public CompletableFuture<Boolean> containsValue(V value) {
    checkNotNull(value, ERROR_NULL_VALUE);
    final MeteringAgent.Context timer = monitor.startTimer(CONTAINS_VALUE);
    return database.mapContainsValue(name, serializer.encode(value)).whenComplete((r, e) -> timer.stop());
}
#end_block

#method_before
@Override
public CompletableFuture<Versioned<V>> get(K key) {
    checkNotNull(key, ERROR_NULL_KEY);
    final UsageMonitor.Context timer = monitor.startTimer(GET);
    return database.mapGet(name, keyCache.getUnchecked(key)).whenComplete((r, e) -> timer.stop()).thenApply(v -> v != null ? v.map(serializer::decode) : null);
}
#method_after
@Override
public CompletableFuture<Versioned<V>> get(K key) {
    checkNotNull(key, ERROR_NULL_KEY);
    final MeteringAgent.Context timer = monitor.startTimer(GET);
    return database.mapGet(name, keyCache.getUnchecked(key)).whenComplete((r, e) -> timer.stop()).thenApply(v -> v != null ? v.map(serializer::decode) : null);
}
#end_block

#method_before
@Override
public CompletableFuture<Versioned<V>> computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(mappingFunction, "Mapping function cannot be null");
    final UsageMonitor.Context timer = monitor.startTimer(COMPUTE_IF_ABSENT);
    return updateAndGet(key, Match.ifNull(), Match.any(), mappingFunction.apply(key)).whenComplete((r, e) -> timer.stop()).thenApply(v -> v.newValue());
}
#method_after
@Override
public CompletableFuture<Versioned<V>> computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(mappingFunction, "Mapping function cannot be null");
    final MeteringAgent.Context timer = monitor.startTimer(COMPUTE_IF_ABSENT);
    return updateAndGet(key, Match.ifNull(), Match.any(), mappingFunction.apply(key)).whenComplete((r, e) -> timer.stop()).thenApply(v -> v.newValue());
}
#end_block

#method_before
@Override
public CompletableFuture<Versioned<V>> computeIf(K key, Predicate<? super V> condition, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(condition, "predicate function cannot be null");
    checkNotNull(remappingFunction, "Remapping function cannot be null");
    final UsageMonitor.Context timer = monitor.startTimer(COMPUTE_IF);
    return get(key).thenCompose(r1 -> {
        V existingValue = r1 == null ? null : r1.value();
        // if the condition evaluates to false, return existing value.
        if (!condition.test(existingValue)) {
            return CompletableFuture.completedFuture(r1);
        }
        AtomicReference<V> computedValue = new AtomicReference<>();
        // if remappingFunction throws an exception, return the exception.
        try {
            computedValue.set(remappingFunction.apply(key, existingValue));
        } catch (Exception e) {
            return Tools.exceptionalFuture(e);
        }
        if (computedValue.get() == null && r1 == null) {
            return CompletableFuture.completedFuture(null);
        }
        Match<V> valueMatcher = r1 == null ? Match.ifNull() : Match.any();
        Match<Long> versionMatcher = r1 == null ? Match.any() : Match.ifValue(r1.version());
        return updateAndGet(key, valueMatcher, versionMatcher, computedValue.get()).whenComplete((r, e) -> timer.stop()).thenApply(v -> {
            if (v.updated()) {
                return v.newValue();
            } else {
                throw new ConsistentMapException.ConcurrentModification();
            }
        });
    });
}
#method_after
@Override
public CompletableFuture<Versioned<V>> computeIf(K key, Predicate<? super V> condition, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(condition, "predicate function cannot be null");
    checkNotNull(remappingFunction, "Remapping function cannot be null");
    final MeteringAgent.Context timer = monitor.startTimer(COMPUTE_IF);
    return get(key).thenCompose(r1 -> {
        V existingValue = r1 == null ? null : r1.value();
        // if the condition evaluates to false, return existing value.
        if (!condition.test(existingValue)) {
            return CompletableFuture.completedFuture(r1);
        }
        AtomicReference<V> computedValue = new AtomicReference<>();
        // if remappingFunction throws an exception, return the exception.
        try {
            computedValue.set(remappingFunction.apply(key, existingValue));
        } catch (Exception e) {
            return Tools.exceptionalFuture(e);
        }
        if (computedValue.get() == null && r1 == null) {
            return CompletableFuture.completedFuture(null);
        }
        Match<V> valueMatcher = r1 == null ? Match.ifNull() : Match.any();
        Match<Long> versionMatcher = r1 == null ? Match.any() : Match.ifValue(r1.version());
        return updateAndGet(key, valueMatcher, versionMatcher, computedValue.get()).whenComplete((r, e) -> timer.stop()).thenApply(v -> {
            if (v.updated()) {
                return v.newValue();
            } else {
                throw new ConsistentMapException.ConcurrentModification();
            }
        });
    });
}
#end_block

#method_before
@Override
public CompletableFuture<Versioned<V>> put(K key, V value) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(value, ERROR_NULL_VALUE);
    final UsageMonitor.Context timer = monitor.startTimer(PUT);
    return updateAndGet(key, Match.any(), Match.any(), value).thenApply(v -> v.oldValue()).whenComplete((r, e) -> timer.stop());
}
#method_after
@Override
public CompletableFuture<Versioned<V>> put(K key, V value) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(value, ERROR_NULL_VALUE);
    final MeteringAgent.Context timer = monitor.startTimer(PUT);
    return updateAndGet(key, Match.any(), Match.any(), value).thenApply(v -> v.oldValue()).whenComplete((r, e) -> timer.stop());
}
#end_block

#method_before
@Override
public CompletableFuture<Versioned<V>> putAndGet(K key, V value) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(value, ERROR_NULL_VALUE);
    final UsageMonitor.Context timer = monitor.startTimer(PUT_AND_GET);
    return updateAndGet(key, Match.any(), Match.any(), value).thenApply(v -> v.newValue()).whenComplete((r, e) -> timer.stop());
}
#method_after
@Override
public CompletableFuture<Versioned<V>> putAndGet(K key, V value) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(value, ERROR_NULL_VALUE);
    final MeteringAgent.Context timer = monitor.startTimer(PUT_AND_GET);
    return updateAndGet(key, Match.any(), Match.any(), value).thenApply(v -> v.newValue()).whenComplete((r, e) -> timer.stop());
}
#end_block

#method_before
@Override
public CompletableFuture<Versioned<V>> remove(K key) {
    checkNotNull(key, ERROR_NULL_KEY);
    final UsageMonitor.Context timer = monitor.startTimer(REMOVE);
    return updateAndGet(key, Match.any(), Match.any(), null).thenApply(v -> v.oldValue()).whenComplete((r, e) -> timer.stop());
}
#method_after
@Override
public CompletableFuture<Versioned<V>> remove(K key) {
    checkNotNull(key, ERROR_NULL_KEY);
    final MeteringAgent.Context timer = monitor.startTimer(REMOVE);
    return updateAndGet(key, Match.any(), Match.any(), null).thenApply(v -> v.oldValue()).whenComplete((r, e) -> timer.stop());
}
#end_block

#method_before
@Override
public CompletableFuture<Void> clear() {
    checkIfUnmodifiable();
    final UsageMonitor.Context timer = monitor.startTimer(CLEAR);
    return database.mapClear(name).thenApply(this::unwrapResult).whenComplete((r, e) -> timer.stop());
}
#method_after
@Override
public CompletableFuture<Void> clear() {
    checkIfUnmodifiable();
    final MeteringAgent.Context timer = monitor.startTimer(CLEAR);
    return database.mapClear(name).thenApply(this::unwrapResult).whenComplete((r, e) -> timer.stop());
}
#end_block

#method_before
@Override
public CompletableFuture<Set<K>> keySet() {
    final UsageMonitor.Context timer = monitor.startTimer(KEY_SET);
    return database.mapKeySet(name).thenApply(s -> s.stream().map(this::dK).collect(Collectors.toSet())).whenComplete((r, e) -> timer.stop());
}
#method_after
@Override
public CompletableFuture<Set<K>> keySet() {
    final MeteringAgent.Context timer = monitor.startTimer(KEY_SET);
    return database.mapKeySet(name).thenApply(s -> s.stream().map(this::dK).collect(Collectors.toSet())).whenComplete((r, e) -> timer.stop());
}
#end_block

#method_before
@Override
public CompletableFuture<Collection<Versioned<V>>> values() {
    final UsageMonitor.Context timer = monitor.startTimer(VALUES);
    return database.mapValues(name).whenComplete((r, e) -> timer.stop()).thenApply(c -> c.stream().map(v -> v.<V>map(serializer::decode)).collect(Collectors.toList()));
}
#method_after
@Override
public CompletableFuture<Collection<Versioned<V>>> values() {
    final MeteringAgent.Context timer = monitor.startTimer(VALUES);
    return database.mapValues(name).whenComplete((r, e) -> timer.stop()).thenApply(c -> c.stream().map(v -> v.<V>map(serializer::decode)).collect(Collectors.toList()));
}
#end_block

#method_before
@Override
public CompletableFuture<Set<Entry<K, Versioned<V>>>> entrySet() {
    final UsageMonitor.Context timer = monitor.startTimer(ENTRY_SET);
    return database.mapEntrySet(name).whenComplete((r, e) -> timer.stop()).thenApply(s -> s.stream().map(this::mapRawEntry).collect(Collectors.toSet()));
}
#method_after
@Override
public CompletableFuture<Set<Entry<K, Versioned<V>>>> entrySet() {
    final MeteringAgent.Context timer = monitor.startTimer(ENTRY_SET);
    return database.mapEntrySet(name).whenComplete((r, e) -> timer.stop()).thenApply(s -> s.stream().map(this::mapRawEntry).collect(Collectors.toSet()));
}
#end_block

#method_before
@Override
public CompletableFuture<Versioned<V>> putIfAbsent(K key, V value) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(value, ERROR_NULL_VALUE);
    final UsageMonitor.Context timer = monitor.startTimer(PUT_IF_ABSENT);
    return updateAndGet(key, Match.ifNull(), Match.any(), value).whenComplete((r, e) -> timer.stop()).thenApply(v -> v.oldValue());
}
#method_after
@Override
public CompletableFuture<Versioned<V>> putIfAbsent(K key, V value) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(value, ERROR_NULL_VALUE);
    final MeteringAgent.Context timer = monitor.startTimer(PUT_IF_ABSENT);
    return updateAndGet(key, Match.ifNull(), Match.any(), value).whenComplete((r, e) -> timer.stop()).thenApply(v -> v.oldValue());
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> remove(K key, V value) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(value, ERROR_NULL_VALUE);
    final UsageMonitor.Context timer = monitor.startTimer(REMOVE);
    return updateAndGet(key, Match.ifValue(value), Match.any(), null).whenComplete((r, e) -> timer.stop()).thenApply(v -> v.updated());
}
#method_after
@Override
public CompletableFuture<Boolean> remove(K key, V value) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(value, ERROR_NULL_VALUE);
    final MeteringAgent.Context timer = monitor.startTimer(REMOVE);
    return updateAndGet(key, Match.ifValue(value), Match.any(), null).whenComplete((r, e) -> timer.stop()).thenApply(v -> v.updated());
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> remove(K key, long version) {
    checkNotNull(key, ERROR_NULL_KEY);
    final UsageMonitor.Context timer = monitor.startTimer(REMOVE);
    return updateAndGet(key, Match.any(), Match.ifValue(version), null).whenComplete((r, e) -> timer.stop()).thenApply(v -> v.updated());
}
#method_after
@Override
public CompletableFuture<Boolean> remove(K key, long version) {
    checkNotNull(key, ERROR_NULL_KEY);
    final MeteringAgent.Context timer = monitor.startTimer(REMOVE);
    return updateAndGet(key, Match.any(), Match.ifValue(version), null).whenComplete((r, e) -> timer.stop()).thenApply(v -> v.updated());
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> replace(K key, V oldValue, V newValue) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(oldValue, ERROR_NULL_VALUE);
    checkNotNull(newValue, ERROR_NULL_VALUE);
    final UsageMonitor.Context timer = monitor.startTimer(REPLACE);
    return updateAndGet(key, Match.ifValue(oldValue), Match.any(), newValue).whenComplete((r, e) -> timer.stop()).thenApply(v -> v.updated());
}
#method_after
@Override
public CompletableFuture<Boolean> replace(K key, V oldValue, V newValue) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(oldValue, ERROR_NULL_VALUE);
    checkNotNull(newValue, ERROR_NULL_VALUE);
    final MeteringAgent.Context timer = monitor.startTimer(REPLACE);
    return updateAndGet(key, Match.ifValue(oldValue), Match.any(), newValue).whenComplete((r, e) -> timer.stop()).thenApply(v -> v.updated());
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> replace(K key, long oldVersion, V newValue) {
    final UsageMonitor.Context timer = monitor.startTimer(REPLACE);
    return updateAndGet(key, Match.any(), Match.ifValue(oldVersion), newValue).whenComplete((r, e) -> timer.stop()).thenApply(v -> v.updated());
}
#method_after
@Override
public CompletableFuture<Boolean> replace(K key, long oldVersion, V newValue) {
    final MeteringAgent.Context timer = monitor.startTimer(REPLACE);
    return updateAndGet(key, Match.any(), Match.ifValue(oldVersion), newValue).whenComplete((r, e) -> timer.stop()).thenApply(v -> v.updated());
}
#end_block

#method_before
private CompletableFuture<UpdateResult<K, V>> updateAndGet(K key, Match<V> oldValueMatch, Match<Long> oldVersionMatch, V value) {
    checkIfUnmodifiable();
    return database.mapUpdate(name, keyCache.getUnchecked(key), oldValueMatch.map(serializer::encode), oldVersionMatch, value == null ? null : serializer.encode(value)).thenApply(this::unwrapResult).thenApply(r -> r.<K, V>map(this::dK, serializer::decode)).whenComplete((r, e) -> {
        if (r != null && e == null && !database.hasChangeNotificationSupport()) {
            notifyListeners(r.toMapEvent());
        }
    });
}
#method_after
private CompletableFuture<UpdateResult<K, V>> updateAndGet(K key, Match<V> oldValueMatch, Match<Long> oldVersionMatch, V value) {
    checkIfUnmodifiable();
    return database.mapUpdate(name, keyCache.getUnchecked(key), oldValueMatch.map(serializer::encode), oldVersionMatch, value == null ? null : serializer.encode(value)).thenApply(this::unwrapResult).thenApply(r -> r.<K, V>map(this::dK, serializer::decode));
}
#end_block

#method_before
protected void notifyListeners(MapEvent<K, V> event) {
    try {
        if (event != null) {
            notifyLocalListeners(event);
            notifyRemoteListeners(event);
        }
    } catch (Exception e) {
        log.warn("Failure notifying listeners about {}", event, e);
    }
}
#method_after
protected void notifyListeners(MapEvent<K, V> event) {
    if (event == null) {
        return;
    }
    listeners.forEach(listener -> {
        try {
            listener.event(event);
        } catch (Exception e) {
            log.warn("Failure notifying listener about {}", event, e);
        }
    });
}
#end_block

#method_before
@Override
public AtomicCounter build() {
    validateInputs();
    Database database = partitionsEnabled ? partitionedDatabase : inMemoryDatabase;
    return new DefaultAtomicCounter(name, database, retryOnFailure, usageMonitor, retryExecutor);
}
#method_after
@Override
public AtomicCounter build() {
    validateInputs();
    Database database = partitionsEnabled ? partitionedDatabase : inMemoryDatabase;
    return new DefaultAtomicCounter(name, database, retryOnFailure, metering, retryExecutor);
}
#end_block

#method_before
@Override
public AsyncAtomicCounter buildAsyncCounter() {
    validateInputs();
    Database database = partitionsEnabled ? partitionedDatabase : inMemoryDatabase;
    return new DefaultAsyncAtomicCounter(name, database, retryOnFailure, usageMonitor, retryExecutor);
}
#method_after
@Override
public AsyncAtomicCounter buildAsyncCounter() {
    validateInputs();
    Database database = partitionsEnabled ? partitionedDatabase : inMemoryDatabase;
    return new DefaultAsyncAtomicCounter(name, database, retryOnFailure, metering, retryExecutor);
}
#end_block

#method_before
@Override
public DistributedSet<E> build() {
    return new DefaultDistributedSet<E>(name, usageMonitor, mapBuilder.build());
}
#method_after
@Override
public DistributedSet<E> build() {
    return new DefaultDistributedSet<E>(name, metering, mapBuilder.build());
}
#end_block

#method_before
@Override
public int size() {
    final UsageMonitor.Context timer = monitor.startTimer(SIZE);
    try {
        return backingMap.size();
    } finally {
        timer.stop();
    }
}
#method_after
@Override
public int size() {
    final MeteringAgent.Context timer = monitor.startTimer(SIZE);
    try {
        return backingMap.size();
    } finally {
        timer.stop();
    }
}
#end_block

#method_before
@Override
public boolean isEmpty() {
    final UsageMonitor.Context timer = monitor.startTimer(IS_EMPTY);
    try {
        return backingMap.isEmpty();
    } finally {
        timer.stop();
    }
}
#method_after
@Override
public boolean isEmpty() {
    final MeteringAgent.Context timer = monitor.startTimer(IS_EMPTY);
    try {
        return backingMap.isEmpty();
    } finally {
        timer.stop();
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public boolean contains(Object o) {
    final UsageMonitor.Context timer = monitor.startTimer(CONTAINS);
    try {
        return backingMap.containsKey((E) o);
    } finally {
        timer.stop();
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public boolean contains(Object o) {
    final MeteringAgent.Context timer = monitor.startTimer(CONTAINS);
    try {
        return backingMap.containsKey((E) o);
    } finally {
        timer.stop();
    }
}
#end_block

#method_before
@Override
public Iterator<E> iterator() {
    final UsageMonitor.Context timer = monitor.startTimer(ITERATOR);
    // Do we have to measure this guy?
    try {
        return backingMap.keySet().iterator();
    } finally {
        timer.stop();
    }
}
#method_after
@Override
public Iterator<E> iterator() {
    final MeteringAgent.Context timer = monitor.startTimer(ITERATOR);
    // Do we have to measure this guy?
    try {
        return backingMap.keySet().iterator();
    } finally {
        timer.stop();
    }
}
#end_block

#method_before
@Override
public Object[] toArray() {
    final UsageMonitor.Context timer = monitor.startTimer(TO_ARRAY);
    try {
        return backingMap.keySet().stream().toArray();
    } finally {
        timer.stop();
    }
}
#method_after
@Override
public Object[] toArray() {
    final MeteringAgent.Context timer = monitor.startTimer(TO_ARRAY);
    try {
        return backingMap.keySet().stream().toArray();
    } finally {
        timer.stop();
    }
}
#end_block

#method_before
@Override
public <T> T[] toArray(T[] a) {
    final UsageMonitor.Context timer = monitor.startTimer(TO_ARRAY);
    try {
        return backingMap.keySet().stream().toArray(size -> a);
    } finally {
        timer.stop();
    }
}
#method_after
@Override
public <T> T[] toArray(T[] a) {
    final MeteringAgent.Context timer = monitor.startTimer(TO_ARRAY);
    try {
        return backingMap.keySet().stream().toArray(size -> a);
    } finally {
        timer.stop();
    }
}
#end_block

#method_before
@Override
public boolean add(E e) {
    final UsageMonitor.Context timer = monitor.startTimer(ADD);
    try {
        return backingMap.putIfAbsent(e, true) == null;
    } finally {
        timer.stop();
    }
}
#method_after
@Override
public boolean add(E e) {
    final MeteringAgent.Context timer = monitor.startTimer(ADD);
    try {
        return backingMap.putIfAbsent(e, true) == null;
    } finally {
        timer.stop();
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public boolean remove(Object o) {
    final UsageMonitor.Context timer = monitor.startTimer(REMOVE);
    try {
        return backingMap.remove((E) o) != null;
    } finally {
        timer.stop();
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public boolean remove(Object o) {
    final MeteringAgent.Context timer = monitor.startTimer(REMOVE);
    try {
        return backingMap.remove((E) o) != null;
    } finally {
        timer.stop();
    }
}
#end_block

#method_before
@Override
public boolean containsAll(Collection<?> c) {
    final UsageMonitor.Context timer = monitor.startTimer(CONTAINS_ALL);
    try {
        return c.stream().allMatch(this::contains);
    } finally {
        timer.stop();
    }
}
#method_after
@Override
public boolean containsAll(Collection<?> c) {
    final MeteringAgent.Context timer = monitor.startTimer(CONTAINS_ALL);
    try {
        return c.stream().allMatch(this::contains);
    } finally {
        timer.stop();
    }
}
#end_block

#method_before
@Override
public boolean addAll(Collection<? extends E> c) {
    final UsageMonitor.Context timer = monitor.startTimer(ADD_ALL);
    try {
        return c.stream().map(this::add).reduce(Boolean::logicalOr).orElse(false);
    } finally {
        timer.stop();
    }
}
#method_after
@Override
public boolean addAll(Collection<? extends E> c) {
    final MeteringAgent.Context timer = monitor.startTimer(ADD_ALL);
    try {
        return c.stream().map(this::add).reduce(Boolean::logicalOr).orElse(false);
    } finally {
        timer.stop();
    }
}
#end_block

#method_before
@Override
public boolean retainAll(Collection<?> c) {
    final UsageMonitor.Context timer = monitor.startTimer(RETAIN_ALL);
    try {
        Set<?> retainSet = Sets.newHashSet(c);
        return backingMap.keySet().stream().filter(k -> !retainSet.contains(k)).map(this::remove).reduce(Boolean::logicalOr).orElse(false);
    } finally {
        timer.stop();
    }
}
#method_after
@Override
public boolean retainAll(Collection<?> c) {
    final MeteringAgent.Context timer = monitor.startTimer(RETAIN_ALL);
    try {
        Set<?> retainSet = Sets.newHashSet(c);
        return backingMap.keySet().stream().filter(k -> !retainSet.contains(k)).map(this::remove).reduce(Boolean::logicalOr).orElse(false);
    } finally {
        timer.stop();
    }
}
#end_block

#method_before
@Override
public boolean removeAll(Collection<?> c) {
    final UsageMonitor.Context timer = monitor.startTimer(REMOVE_ALL);
    try {
        Set<?> removeSet = Sets.newHashSet(c);
        return backingMap.keySet().stream().filter(removeSet::contains).map(this::remove).reduce(Boolean::logicalOr).orElse(false);
    } finally {
        timer.stop();
    }
}
#method_after
@Override
public boolean removeAll(Collection<?> c) {
    final MeteringAgent.Context timer = monitor.startTimer(REMOVE_ALL);
    try {
        Set<?> removeSet = Sets.newHashSet(c);
        return backingMap.keySet().stream().filter(removeSet::contains).map(this::remove).reduce(Boolean::logicalOr).orElse(false);
    } finally {
        timer.stop();
    }
}
#end_block

#method_before
@Override
public void clear() {
    final UsageMonitor.Context timer = monitor.startTimer(CLEAR);
    try {
        backingMap.clear();
    } finally {
        timer.stop();
    }
}
#method_after
@Override
public void clear() {
    final MeteringAgent.Context timer = monitor.startTimer(CLEAR);
    try {
        backingMap.clear();
    } finally {
        timer.stop();
    }
}
#end_block

#method_before
@Override
public CompletableFuture<Long> incrementAndGet() {
    final UsageMonitor.Context timer = monitor.startTimer(INCREMENT_AND_GET);
    return addAndGet(1L).whenComplete((r, e) -> timer.stop());
}
#method_after
@Override
public CompletableFuture<Long> incrementAndGet() {
    final MeteringAgent.Context timer = monitor.startTimer(INCREMENT_AND_GET);
    return addAndGet(1L).whenComplete((r, e) -> timer.stop());
}
#end_block

#method_before
@Override
public CompletableFuture<Long> get() {
    final UsageMonitor.Context timer = monitor.startTimer(GET);
    return database.counterGet(name).whenComplete((r, e) -> timer.stop());
}
#method_after
@Override
public CompletableFuture<Long> get() {
    final MeteringAgent.Context timer = monitor.startTimer(GET);
    return database.counterGet(name).whenComplete((r, e) -> timer.stop());
}
#end_block

#method_before
@Override
public CompletableFuture<Long> getAndIncrement() {
    final UsageMonitor.Context timer = monitor.startTimer(GET_AND_INCREMENT);
    return getAndAdd(1L).whenComplete((r, e) -> timer.stop());
}
#method_after
@Override
public CompletableFuture<Long> getAndIncrement() {
    final MeteringAgent.Context timer = monitor.startTimer(GET_AND_INCREMENT);
    return getAndAdd(1L).whenComplete((r, e) -> timer.stop());
}
#end_block

#method_before
@Override
public CompletableFuture<Long> getAndAdd(long delta) {
    final UsageMonitor.Context timer = monitor.startTimer(GET_AND_ADD);
    CompletableFuture<Long> result = database.counterGetAndAdd(name, delta);
    if (!retryOnFailure) {
        return result.whenComplete((r, e) -> timer.stop());
    }
    CompletableFuture<Long> future = new CompletableFuture<>();
    return result.whenComplete((r, e) -> {
        timer.stop();
        // TODO : Account for retries
        if (e != null) {
            log.warn("getAndAdd failed due to {}. Will retry", e.getMessage());
            retryExecutor.schedule(new RetryTask(database::counterGetAndAdd, delta, future), DELAY_BETWEEN_RETRY_SEC, TimeUnit.SECONDS);
        } else {
            future.complete(r);
        }
    }).thenCompose(v -> future);
}
#method_after
@Override
public CompletableFuture<Long> getAndAdd(long delta) {
    final MeteringAgent.Context timer = monitor.startTimer(GET_AND_ADD);
    CompletableFuture<Long> result = database.counterGetAndAdd(name, delta);
    if (!retryOnFailure) {
        return result.whenComplete((r, e) -> timer.stop());
    }
    CompletableFuture<Long> future = new CompletableFuture<>();
    return result.whenComplete((r, e) -> {
        timer.stop();
        // TODO : Account for retries
        if (e != null) {
            log.warn("getAndAdd failed due to {}. Will retry", e.getMessage());
            retryExecutor.schedule(new RetryTask(database::counterGetAndAdd, delta, future), DELAY_BETWEEN_RETRY_SEC, TimeUnit.SECONDS);
        } else {
            future.complete(r);
        }
    }).thenCompose(v -> future);
}
#end_block

#method_before
@Override
public CompletableFuture<Long> addAndGet(long delta) {
    final UsageMonitor.Context timer = monitor.startTimer(ADD_AND_GET);
    CompletableFuture<Long> result = database.counterAddAndGet(name, delta);
    if (!retryOnFailure) {
        return result.whenComplete((r, e) -> timer.stop());
    }
    CompletableFuture<Long> future = new CompletableFuture<>();
    return result.whenComplete((r, e) -> {
        timer.stop();
        // TODO : Account for retries
        if (e != null) {
            log.warn("addAndGet failed due to {}. Will retry", e.getMessage());
            retryExecutor.schedule(new RetryTask(database::counterAddAndGet, delta, future), DELAY_BETWEEN_RETRY_SEC, TimeUnit.SECONDS);
        } else {
            future.complete(r);
        }
    }).thenCompose(v -> future);
}
#method_after
@Override
public CompletableFuture<Long> addAndGet(long delta) {
    final MeteringAgent.Context timer = monitor.startTimer(ADD_AND_GET);
    CompletableFuture<Long> result = database.counterAddAndGet(name, delta);
    if (!retryOnFailure) {
        return result.whenComplete((r, e) -> timer.stop());
    }
    CompletableFuture<Long> future = new CompletableFuture<>();
    return result.whenComplete((r, e) -> {
        timer.stop();
        // TODO : Account for retries
        if (e != null) {
            log.warn("addAndGet failed due to {}. Will retry", e.getMessage());
            retryExecutor.schedule(new RetryTask(database::counterAddAndGet, delta, future), DELAY_BETWEEN_RETRY_SEC, TimeUnit.SECONDS);
        } else {
            future.complete(r);
        }
    }).thenCompose(v -> future);
}
#end_block

#method_before
private DefaultAsyncConsistentMap<K, V> buildAndRegisterMap() {
    validateInputs();
    DefaultAsyncConsistentMap<K, V> asyncMap = new DefaultAsyncConsistentMap<>(name, applicationId, partitionsEnabled ? manager.partitionedDatabase : manager.inMemoryDatabase, serializer, readOnly, purgeOnUninstall, usageMonitor, event -> manager.clusterCommunicator.<MapEvent<K, V>>broadcast(event, DatabaseManager.mapUpdatesSubject(name), serializer::encode));
    return manager.registerMap(asyncMap);
}
#method_after
private DefaultAsyncConsistentMap<K, V> buildAndRegisterMap() {
    validateInputs();
    DefaultAsyncConsistentMap<K, V> asyncMap = new DefaultAsyncConsistentMap<>(name, applicationId, partitionsEnabled ? manager.partitionedDatabase : manager.inMemoryDatabase, serializer, readOnly, purgeOnUninstall, metering);
    return manager.registerMap(asyncMap);
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    controller.start(agent, updateCallback);
}
#method_after
@Activate
public void activate(ComponentContext context) {
    controller.start(agent, updateCallback);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    controller.stop();
}
#method_after
@Deactivate
public void deactivate() {
    controller.stop();
    log.info("Stoped");
}
#end_block

#method_before
@Override
public List<OvsdbNodeId> getNodeIds() {
    return null;
}
#method_after
@Override
public List<OvsdbNodeId> getNodeIds() {
    // TODO Auto-generated method stub
    return null;
}
#end_block

#method_before
@Override
public void addConnectedNode(OvsdbNodeId nodeId, OvsdbClientService ovsdbClient) {
    if (ovsdbClients.get(nodeId) != null) {
        return;
    } else {
        ovsdbClients.put(nodeId, ovsdbClient);
        try {
            List<String> dbNames = ovsdbClient.listDbs().get();
            for (String dbName : dbNames) {
                DatabaseSchema dbSchema;
                dbSchema = ovsdbClient.getOvsdbSchema(dbName).get();
                log.info("Begin to monitor tables");
                String id = java.util.UUID.randomUUID().toString();
                TableUpdates updates = ovsdbClient.monitorTables(dbName, id).get();
                requestDbName.put(id, dbName);
                requestNotification.put(id, ovsdbClient);
                if (updates != null) {
                    processTableUpdates(ovsdbClient, updates, dbSchema.name());
                }
            }
        } catch (InterruptedException e) {
            log.warn("Interrupted while waiting to get message from ovsdb");
            Thread.currentThread().interrupt();
        } catch (ExecutionException e) {
            log.error("Exception thrown while to get message from ovsdb");
        }
        log.info("Add node to north");
        for (OvsdbNodeListener l : ovsdbNodeListener) {
            l.nodeAdded(nodeId);
        }
        return;
    }
}
#method_after
@Override
public void addConnectedNode(OvsdbNodeId nodeId, OvsdbClientService ovsdbClient) {
    if (ovsdbClients.get(nodeId) != null) {
        return;
    } else {
        ovsdbClients.put(nodeId, ovsdbClient);
        try {
            List<String> dbNames = ovsdbClient.listDbs().get();
            for (String dbName : dbNames) {
                DatabaseSchema dbSchema;
                dbSchema = ovsdbClient.getOvsdbSchema(dbName).get();
                log.debug("Begin to monitor tables");
                String id = java.util.UUID.randomUUID().toString();
                TableUpdates updates = ovsdbClient.monitorTables(dbName, id).get();
                requestDbName.put(id, dbName);
                requestNotification.put(id, ovsdbClient);
                if (updates != null) {
                    processTableUpdates(ovsdbClient, updates, dbSchema.name());
                }
            }
        } catch (InterruptedException e) {
            log.warn("Interrupted while waiting to get message from ovsdb");
            Thread.currentThread().interrupt();
        } catch (ExecutionException e) {
            log.error("Exception thrown while to get message from ovsdb");
        }
        log.debug("Add node to north");
        for (OvsdbNodeListener l : ovsdbNodeListener) {
            l.nodeAdded(nodeId);
        }
        return;
    }
}
#end_block

#method_before
@Override
public void removeConnectedNode(OvsdbNodeId nodeId) {
    ovsdbClients.remove(nodeId);
    log.info("Node connection is removed");
    for (OvsdbNodeListener l : ovsdbNodeListener) {
        l.nodeRemoved(nodeId);
    }
}
#method_after
@Override
public void removeConnectedNode(OvsdbNodeId nodeId) {
    ovsdbClients.remove(nodeId);
    log.debug("Node connection is removed");
    for (OvsdbNodeListener l : ovsdbNodeListener) {
        l.nodeRemoved(nodeId);
    }
}
#end_block

#method_before
private void processTableUpdates(OvsdbClientService clientService, TableUpdates updates, String dbName) throws InterruptedException {
    checkNotNull(clientService, "OvsdbClientService is not null");
    DatabaseSchema dbSchema = clientService.getDatabaseSchema(dbName);
    for (String tableName : updates.result().keySet()) {
        TableUpdate update = updates.result().get(tableName);
        for (UUID uuid : (Set<UUID>) update.rows().keySet()) {
            log.info("Begin to process table updates uuid: {}, databaseName: {}, tableName: {}", uuid.value(), dbName, tableName);
            Row row = clientService.getRow(dbName, tableName, uuid.value());
            clientService.updateOvsdbStore(dbName, tableName, uuid.value(), update.getNew(uuid));
            if (update.getNew(uuid) != null) {
                boolean isNewRow = (row == null) ? true : false;
                if (isNewRow) {
                    if (OvsdbConstant.PORT.equals(tableName)) {
                        dispatchEvent(clientService, update.getNew(uuid), null, OvsdbEvent.Type.PORT_ADDED, dbSchema);
                    }
                }
            } else if (update.getOld(uuid) != null) {
                clientService.removeRow(dbName, tableName, uuid.toString());
                if (update.getOld(uuid) != null) {
                    if (OvsdbConstant.PORT.equals(tableName)) {
                        dispatchEvent(clientService, null, update.getOld(uuid), OvsdbEvent.Type.PORT_REMOVED, dbSchema);
                    }
                }
            }
        }
    }
}
#method_after
private void processTableUpdates(OvsdbClientService clientService, TableUpdates updates, String dbName) throws InterruptedException {
    checkNotNull(clientService, "OvsdbClientService is not null");
    DatabaseSchema dbSchema = clientService.getDatabaseSchema(dbName);
    for (String tableName : updates.result().keySet()) {
        TableUpdate update = updates.result().get(tableName);
        for (UUID uuid : (Set<UUID>) update.rows().keySet()) {
            log.debug("Begin to process table updates uuid: {}, databaseName: {}, tableName: {}", uuid.value(), dbName, tableName);
            Row row = clientService.getRow(dbName, tableName, uuid.value());
            clientService.updateOvsdbStore(dbName, tableName, uuid.value(), update.getNew(uuid));
            if (update.getNew(uuid) != null) {
                boolean isNewRow = (row == null) ? true : false;
                if (isNewRow) {
                    if (OvsdbConstant.PORT.equals(tableName)) {
                        dispatchEvent(clientService, update.getNew(uuid), null, OvsdbEvent.Type.PORT_ADDED, dbSchema);
                    }
                }
            } else if (update.getOld(uuid) != null) {
                clientService.removeRow(dbName, tableName, uuid.toString());
                if (update.getOld(uuid) != null) {
                    if (OvsdbConstant.PORT.equals(tableName)) {
                        dispatchEvent(clientService, null, update.getOld(uuid), OvsdbEvent.Type.PORT_REMOVED, dbSchema);
                    }
                }
            }
        }
    }
}
#end_block

#method_before
@SuppressWarnings({ "unchecked" })
private void dispatchEvent(OvsdbClientService clientService, Row newRow, Row oldRow, Type eventType, DatabaseSchema dbSchema) {
    Port port = null;
    if (OvsdbEvent.Type.PORT_ADDED.equals(eventType)) {
        port = (Port) TableGenerator.getTable(dbSchema, newRow, OvsdbTable.PORT);
    } else if (OvsdbEvent.Type.PORT_REMOVED.equals(eventType)) {
        port = (Port) TableGenerator.getTable(dbSchema, oldRow, OvsdbTable.PORT);
    }
    if (port == null) {
        return;
    }
    long dpid = getDataPathid(clientService, dbSchema);
    Set<UUID> intfUuids = (Set<UUID>) port.getInterfacesColumn().data();
    for (UUID intfUuid : intfUuids) {
        Row intfRow = clientService.getRow(OvsdbConstant.DATABASENAME, "Interface", intfUuid.toString());
        Interface intf = (Interface) TableGenerator.getTable(dbSchema, intfRow, OvsdbTable.INTERFACE);
        String portType = (String) intf.getTypeColumn().data();
        long localPort = getOfPort(intf);
        String[] macAndIfaceId = getMacAndIfaceid(intf);
        if (macAndIfaceId == null) {
            return;
        }
        EventSubject eventSubject = new DefaultEventSubject(MacAddress.valueOf(macAndIfaceId[0]), new HashSet<IpAddress>(), new OvsdbPortName(port.getName()), new OvsdbPortNumber(localPort), new OvsdbDatapathId(Long.toString(dpid)), new OvsdbPortType(portType), new OvsdbIfaceId(macAndIfaceId[1]));
        for (OvsdbEventListener listener : ovsdbEventListener) {
            listener.handle(new OvsdbEvent<EventSubject>(eventType, eventSubject));
        }
    }
}
#method_after
private void dispatchEvent(OvsdbClientService clientService, Row newRow, Row oldRow, Type eventType, DatabaseSchema dbSchema) {
    Port port = null;
    if (OvsdbEvent.Type.PORT_ADDED.equals(eventType)) {
        port = (Port) TableGenerator.getTable(dbSchema, newRow, OvsdbTable.PORT);
    } else if (OvsdbEvent.Type.PORT_REMOVED.equals(eventType)) {
        port = (Port) TableGenerator.getTable(dbSchema, oldRow, OvsdbTable.PORT);
    }
    if (port == null) {
        return;
    }
    long dpid = getDataPathid(clientService, dbSchema);
    OvsdbSet intfUuidSet = (OvsdbSet) port.getInterfacesColumn().data();
    @SuppressWarnings({ "unchecked" })
    Set<UUID> intfUuids = intfUuidSet.set();
    for (UUID intfUuid : intfUuids) {
        Row intfRow = clientService.getRow(OvsdbConstant.DATABASENAME, "Interface", intfUuid.toString());
        if (intfRow == null) {
            continue;
        }
        Interface intf = (Interface) TableGenerator.getTable(dbSchema, intfRow, OvsdbTable.INTERFACE);
        String portType = (String) intf.getTypeColumn().data();
        long localPort = getOfPort(intf);
        String[] macAndIfaceId = getMacAndIfaceid(intf);
        if (macAndIfaceId == null) {
            return;
        }
        EventSubject eventSubject = new DefaultEventSubject(MacAddress.valueOf(macAndIfaceId[0]), new HashSet<IpAddress>(), new OvsdbPortName(port.getName()), new OvsdbPortNumber(localPort), new OvsdbDatapathId(Long.toString(dpid)), new OvsdbPortType(portType), new OvsdbIfaceId(macAndIfaceId[1]));
        for (OvsdbEventListener listener : ovsdbEventListener) {
            listener.handle(new OvsdbEvent<EventSubject>(eventType, eventSubject));
        }
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private String[] getMacAndIfaceid(Interface intf) {
    Map<String, String> externalIds = (Map<String, String>) intf.getExternalIdsColumn().data();
    if (externalIds == null) {
        log.info("The external_ids is null");
        return null;
    }
    String attachedMac = externalIds.get(OvsdbConstant.EXTERNAL_ID_VM_MAC);
    if (attachedMac == null) {
        log.info("The attachedMac is null");
        return null;
    }
    String ifaceid = externalIds.get(OvsdbConstant.EXTERNAL_ID_INTERFACE_ID);
    if (ifaceid == null) {
        log.info("The ifaceid is null");
        return null;
    }
    return new String[] { attachedMac, ifaceid };
}
#method_after
private String[] getMacAndIfaceid(Interface intf) {
    OvsdbMap ovsdbMap = (OvsdbMap) intf.getExternalIdsColumn().data();
    @SuppressWarnings("unchecked")
    Map<String, String> externalIds = ovsdbMap.map();
    if (externalIds == null) {
        log.warn("The external_ids is null");
        return null;
    }
    String attachedMac = externalIds.get(OvsdbConstant.EXTERNAL_ID_VM_MAC);
    if (attachedMac == null) {
        log.warn("The attachedMac is null");
        return null;
    }
    String ifaceid = externalIds.get(OvsdbConstant.EXTERNAL_ID_INTERFACE_ID);
    if (ifaceid == null) {
        log.warn("The ifaceid is null");
        return null;
    }
    return new String[] { attachedMac, ifaceid };
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private long getOfPort(Interface intf) {
    Set<Long> ofPorts = (Set<Long>) intf.getOpenFlowPortColumn().data();
    while (ofPorts == null || ofPorts.size() <= 0) {
        log.info("The ofport is null in {}", intf.getName());
        return 0;
    }
    return (long) ofPorts.toArray()[0];
}
#method_after
private long getOfPort(Interface intf) {
    OvsdbSet ovsdbSet = (OvsdbSet) intf.getOpenFlowPortColumn().data();
    @SuppressWarnings("unchecked")
    Set<Long> ofPorts = ovsdbSet.set();
    while (ofPorts == null || ofPorts.size() <= 0) {
        log.debug("The ofport is null in {}", intf.getName());
        return 0;
    }
    return (long) ofPorts.toArray()[0];
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private long getDataPathid(OvsdbClientService clientService, DatabaseSchema dbSchema) {
    String bridgeUuid = clientService.getBridgeUuid(OvsdbConstant.INTEGRATION_BRIDGE);
    if (bridgeUuid == null) {
        log.info("Unable to spot bridge uuid for {} in {}", OvsdbConstant.INTEGRATION_BRIDGE, clientService);
        return 0;
    }
    Row bridgeRow = clientService.getRow(OvsdbConstant.DATABASENAME, "Bridge", bridgeUuid);
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    Set<String> dpids = (Set<String>) bridge.getDatapathIdColumn().data();
    if (dpids == null || dpids.size() == 0) {
        return 0L;
    }
    return stringToLong((String) dpids.toArray()[0]);
}
#method_after
private long getDataPathid(OvsdbClientService clientService, DatabaseSchema dbSchema) {
    String bridgeUuid = clientService.getBridgeUuid(OvsdbConstant.INTEGRATION_BRIDGE);
    if (bridgeUuid == null) {
        log.debug("Unable to spot bridge uuid for {} in {}", OvsdbConstant.INTEGRATION_BRIDGE, clientService);
        return 0;
    }
    Row bridgeRow = clientService.getRow(OvsdbConstant.DATABASENAME, "Bridge", bridgeUuid);
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    OvsdbSet ovsdbSet = (OvsdbSet) bridge.getDatapathIdColumn().data();
    @SuppressWarnings("unchecked")
    Set<String> dpids = ovsdbSet.set();
    if (dpids == null || dpids.size() == 0) {
        return 0;
    }
    return stringToLong((String) dpids.toArray()[0]);
}
#end_block

#method_before
@Override
public boolean exists(TenantNetworkId networkId) {
    return networkIdAsKeyStore.containsKey(networkId);
}
#method_after
@Override
public boolean exists(TenantNetworkId networkId) {
    checkNotNull(networkId, NETWORK_ID_NULL);
    return networkIdAsKeyStore.containsKey(networkId);
}
#end_block

#method_before
@Override
public boolean createNetworks(Iterable<TenantNetwork> networks) {
    Iterator<TenantNetwork> networkors = networks.iterator();
    while (networkors.hasNext()) {
        TenantNetwork network = networkors.next();
        networkIdAsKeyStore.put(network.id(), network);
    }
    return true;
}
#method_after
@Override
public boolean createNetworks(Iterable<TenantNetwork> networks) {
    checkNotNull(networks, NETWORK_NOT_NULL);
    for (TenantNetwork network : networks) {
        networkIdAsKeyStore.put(network.id(), network);
        if (!networkIdAsKeyStore.containsKey(network.id())) {
            log.debug("the network created failed which identifier was {}", network.id().toString());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public boolean updateNetworks(Iterable<TenantNetwork> networks) {
    Iterator<TenantNetwork> networkors = networks.iterator();
    while (networkors.hasNext()) {
        TenantNetwork network = networkors.next();
        networkIdAsKeyStore.put(network.id(), network);
    }
    return true;
}
#method_after
@Override
public boolean updateNetworks(Iterable<TenantNetwork> networks) {
    checkNotNull(networks, NETWORK_NOT_NULL);
    for (TenantNetwork network : networks) {
        if (!networkIdAsKeyStore.containsKey(network.id())) {
            log.debug("the tenantNetwork did not exist whose identifier was {} ", network.id().toString());
            return false;
        }
        networkIdAsKeyStore.put(network.id(), network);
        if (network.equals(networkIdAsKeyStore.get(network.id()))) {
            log.debug("the network updated failed whose identifier was {} ", network.id().toString());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public boolean removeNetworks(Iterable<TenantNetworkId> networks) {
    Iterator<TenantNetworkId> networkors = networks.iterator();
    while (networkors.hasNext()) {
        TenantNetworkId network = networkors.next();
        networkIdAsKeyStore.remove(network);
    }
    return true;
}
#method_after
@Override
public boolean removeNetworks(Iterable<TenantNetworkId> networkIds) {
    checkNotNull(networkIds, NETWORK_NOT_NULL);
    for (TenantNetworkId networkId : networkIds) {
        networkIdAsKeyStore.remove(networkId);
        if (networkIdAsKeyStore.containsKey(networkId)) {
            log.debug("the network removed failed whose identifier was {}", networkId.toString());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void decode(ChannelHandlerContext ctx, ByteBuf buf, List<Object> out) throws Exception {
    log.info("Message decoder");
    JsonRpcReaderUtil.readToJsonNode(buf, out, context);
}
#method_after
@Override
protected void decode(ChannelHandlerContext ctx, ByteBuf buf, List<Object> out) throws Exception {
    log.debug("Message decoder");
    JsonRpcReaderUtil.readToJsonNode(buf, out, context);
}
#end_block

#method_before
@Override
public void operationComplete(ChannelFuture arg0) throws Exception {
    providerService.nodeRemoved();
}
#method_after
@Override
public void operationComplete(ChannelFuture arg0) {
    providerService.nodeRemoved();
}
#end_block

#method_before
private void processOvsdbMessage(JsonNode jsonNode) {
    log.info("Handle ovsdb message");
    if (jsonNode.has("result")) {
        log.info("Handle ovsdb result");
        ovsdbProviderService.processResult(jsonNode);
    } else if (jsonNode.hasNonNull("method")) {
        log.info("Handle ovsdb request");
        if (jsonNode.has("id") && !Strings.isNullOrEmpty(jsonNode.get("id").asText())) {
            ovsdbProviderService.processRequest(jsonNode);
        }
    }
    return;
}
#method_after
private void processOvsdbMessage(JsonNode jsonNode) {
    log.info("Handle ovsdb message");
    if (jsonNode.has("result")) {
        log.debug("Handle ovsdb result");
        ovsdbProviderService.processResult(jsonNode);
    } else if (jsonNode.hasNonNull("method")) {
        log.debug("Handle ovsdb request");
        if (jsonNode.has("id") && !Strings.isNullOrEmpty(jsonNode.get("id").asText())) {
            ovsdbProviderService.processRequest(jsonNode);
        }
    }
    return;
}
#end_block

#method_before
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
    log.info("Receive message from ovsdb");
    if (msg instanceof JsonNode) {
        JsonNode jsonNode = (JsonNode) msg;
        processOvsdbMessage(jsonNode);
    }
}
#method_after
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
    log.debug("Receive message from ovsdb");
    if (msg instanceof JsonNode) {
        JsonNode jsonNode = (JsonNode) msg;
        processOvsdbMessage(jsonNode);
    }
}
#end_block

#method_before
private OvsdbTableStore getTableStore(String dbName) {
    if (ovsdbStore == null) {
        return null;
    }
    return ovsdbStore.getOvsdbStore(dbName);
}
#method_after
private OvsdbTableStore getTableStore(String dbName) {
    if (ovsdbStore == null) {
        return null;
    }
    return ovsdbStore.getOvsdbTableStore(dbName);
}
#end_block

#method_before
private OvsdbRowStore getRowStore(String dbName, String tableName) {
    OvsdbTableStore tableStore = getTableStore(dbName);
    if (tableStore == null) {
        return null;
    }
    return tableStore.getTableStore(tableName);
}
#method_after
private OvsdbRowStore getRowStore(String dbName, String tableName) {
    OvsdbTableStore tableStore = getTableStore(dbName);
    if (tableStore == null) {
        return null;
    }
    return tableStore.getRows(tableName);
}
#end_block

#method_before
@Override
public Row getRow(String dbName, String tableName, String uuid) {
    OvsdbTableStore tableStore = getTableStore(dbName);
    if (tableStore == null) {
        return null;
    }
    OvsdbRowStore rowStore = tableStore.getTableStore(tableName);
    if (rowStore == null) {
        return null;
    }
    return rowStore.getRowStore(uuid);
}
#method_after
@Override
public Row getRow(String dbName, String tableName, String uuid) {
    OvsdbTableStore tableStore = getTableStore(dbName);
    if (tableStore == null) {
        return null;
    }
    OvsdbRowStore rowStore = tableStore.getRows(tableName);
    if (rowStore == null) {
        return null;
    }
    return rowStore.getRow(uuid);
}
#end_block

#method_before
@Override
public void removeRow(String dbName, String tableName, String uuid) {
    OvsdbTableStore tableStore = getTableStore(dbName);
    if (tableStore == null) {
        return;
    }
    OvsdbRowStore rowStore = tableStore.getTableStore(tableName);
    if (rowStore == null) {
        return;
    }
    rowStore.removeRowStore(uuid);
}
#method_after
@Override
public void removeRow(String dbName, String tableName, String uuid) {
    OvsdbTableStore tableStore = getTableStore(dbName);
    if (tableStore == null) {
        return;
    }
    OvsdbRowStore rowStore = tableStore.getRows(tableName);
    if (rowStore == null) {
        return;
    }
    rowStore.deleteRow(uuid);
}
#end_block

#method_before
@Override
public void updateOvsdbStore(String dbName, String tableName, String uuid, Row row) {
    OvsdbTableStore tableStore = ovsdbStore.getOvsdbStore(dbName);
    if (tableStore == null) {
        tableStore = new OvsdbTableStore();
    }
    OvsdbRowStore rowStore = tableStore.getTableStore(tableName);
    if (rowStore == null) {
        rowStore = new OvsdbRowStore();
    }
    rowStore.setRowStore(uuid, row);
    tableStore.setTableStore(tableName, rowStore);
    ovsdbStore.setOvsdbStore(dbName, tableStore);
}
#method_after
@Override
public void updateOvsdbStore(String dbName, String tableName, String uuid, Row row) {
    OvsdbTableStore tableStore = ovsdbStore.getOvsdbTableStore(dbName);
    if (tableStore == null) {
        tableStore = new OvsdbTableStore();
    }
    OvsdbRowStore rowStore = tableStore.getRows(tableName);
    if (rowStore == null) {
        rowStore = new OvsdbRowStore();
    }
    rowStore.insertRow(uuid, row);
    tableStore.createOrUpdateTable(tableName, rowStore);
    ovsdbStore.createOrUpdateOvsdbStore(dbName, tableStore);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public String getPortUuid(String portName, String bridgeUUID) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    Row bridgeRow = getRow(OvsdbConstant.DATABASENAME, OvsdbConstant.BRIDGE, bridgeUUID);
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    if (bridge != null) {
        Set<UUID> ports;
        ports = (Set<UUID>) bridge.getPortsColumn().data();
        if (ports == null || ports.size() == 0) {
            log.warn("The port uuid is null");
            return null;
        }
        for (UUID uuid : ports) {
            Row portRow = getRow(OvsdbConstant.DATABASENAME, OvsdbConstant.PORT, uuid.toString());
            Port port = (Port) TableGenerator.getTable(dbSchema, portRow, OvsdbTable.PORT);
            if (port != null && portName.equalsIgnoreCase(port.getName())) {
                return uuid.toString();
            }
        }
    }
    return null;
}
#method_after
@Override
public String getPortUuid(String portName, String bridgeUuid) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    Row bridgeRow = getRow(OvsdbConstant.DATABASENAME, OvsdbConstant.BRIDGE, bridgeUuid);
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    if (bridge != null) {
        OvsdbSet setPorts = (OvsdbSet) bridge.getPortsColumn().data();
        @SuppressWarnings("unchecked")
        Set<UUID> ports = setPorts.set();
        if (ports == null || ports.size() == 0) {
            log.warn("The port uuid is null");
            return null;
        }
        for (UUID uuid : ports) {
            Row portRow = getRow(OvsdbConstant.DATABASENAME, OvsdbConstant.PORT, uuid.value());
            if (portRow == null) {
                continue;
            }
            Port port = (Port) TableGenerator.getTable(dbSchema, portRow, OvsdbTable.PORT);
            if (port != null && portName.equalsIgnoreCase(port.getName())) {
                return uuid.value();
            }
        }
    }
    return null;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public String getInterfaceUuid(String portUuid, String portName) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    Row portRow = getRow(OvsdbConstant.DATABASENAME, OvsdbConstant.PORT, portUuid);
    Port port = (Port) TableGenerator.getTable(dbSchema, portRow, OvsdbTable.PORT);
    if (port != null) {
        Set<UUID> interfaces;
        interfaces = (Set<UUID>) port.getInterfacesColumn().data();
        if (interfaces == null || interfaces.size() == 0) {
            log.warn("The interface uuid is null");
            return null;
        }
        for (UUID uuid : interfaces) {
            Row intfRow = getRow(OvsdbConstant.DATABASENAME, OvsdbConstant.PORT, uuid.toString());
            Interface intf = (Interface) TableGenerator.getTable(dbSchema, intfRow, OvsdbTable.INTERFACE);
            if (intf != null && portName.equalsIgnoreCase(intf.getName())) {
                return uuid.toString();
            }
        }
    }
    return null;
}
#method_after
@Override
public String getInterfaceUuid(String portUuid, String portName) {
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    Row portRow = getRow(OvsdbConstant.DATABASENAME, OvsdbConstant.PORT, portUuid);
    Port port = (Port) TableGenerator.getTable(dbSchema, portRow, OvsdbTable.PORT);
    if (port != null) {
        OvsdbSet setInterfaces = (OvsdbSet) port.getInterfacesColumn().data();
        @SuppressWarnings("unchecked")
        Set<UUID> interfaces = setInterfaces.set();
        if (interfaces == null || interfaces.size() == 0) {
            log.warn("The interface uuid is null");
            return null;
        }
        for (UUID uuid : interfaces) {
            Row intfRow = getRow(OvsdbConstant.DATABASENAME, OvsdbConstant.INTERFACE, uuid.value());
            if (intfRow == null) {
                continue;
            }
            Interface intf = (Interface) TableGenerator.getTable(dbSchema, intfRow, OvsdbTable.INTERFACE);
            if (intf != null && portName.equalsIgnoreCase(intf.getName())) {
                return uuid.value();
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public void createPort(String bridgeName, String portName) {
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.error("Can't find bridge {} in {}", bridgeName, nodeId.getIpAddress());
        return;
    }
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    String portUuid = getPortUuid(portName, bridgeUuid);
    Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
    port.setName(portName);
    if (portUuid == null) {
        insertRow(OvsdbConstant.PORT, "_uuid", OvsdbConstant.BRIDGE, "ports", bridgeUuid, port.getRow());
    } else {
        updateRow("Port", "_uuid", portUuid, port.getRow());
    }
    return;
}
#method_after
@Override
public void createPort(String bridgeName, String portName) {
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.error("Can't find bridge {} in {}", bridgeName, nodeId.getIpAddress());
        return;
    }
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    String portUuid = getPortUuid(portName, bridgeUuid);
    Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
    port.setName(portName);
    if (portUuid == null) {
        insertConfig(OvsdbConstant.PORT, "_uuid", OvsdbConstant.BRIDGE, "ports", bridgeUuid, port.getRow());
    } else {
        updateConfig(OvsdbConstant.PORT, "_uuid", portUuid, port.getRow());
    }
    return;
}
#end_block

#method_before
@Override
public void dropPort(String bridgeName, String portName) {
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.error("Could not find Bridge {} in {}", bridgeName, nodeId);
        return;
    }
    String portUuid = getPortUuid(portName, bridgeUuid);
    if (portUuid != null) {
        log.info("Port {} delete", portName);
        deleteRow(OvsdbConstant.PORT, "_uuid", portUuid, OvsdbConstant.BRIDGE, "ports");
    }
}
#method_after
@Override
public void dropPort(String bridgeName, String portName) {
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.error("Could not find Bridge {} in {}", bridgeName, nodeId);
        return;
    }
    String portUuid = getPortUuid(portName, bridgeUuid);
    if (portUuid != null) {
        log.info("Port {} delete", portName);
        deleteConfig(OvsdbConstant.PORT, "_uuid", portUuid, OvsdbConstant.BRIDGE, "ports");
    }
}
#end_block

#method_before
@Override
public void createBridge(String bridgeName) {
    log.debug("create bridge {}", bridgeName);
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        log.warn("The schema is nullr");
        return;
    }
    Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
    if (bridge == null) {
        log.info("Can not create bridge");
        return;
    }
    Set<String> failModes = new HashSet<>();
    failModes.add("secure");
    bridge.setFailMode(failModes);
    Set<String> protocols = new HashSet<>();
    protocols.add(OvsdbConstant.OPENFLOW13);
    bridge.setProtocols(protocols);
    String ovsUuid = getOvsUuid(OvsdbConstant.DATABASENAME);
    if (ovsUuid == null) {
        log.info("The Open_vSwitch is null");
        return;
    }
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.debug("Create a new bridge");
        bridge.setName(bridgeName);
        bridgeUuid = insertRow(OvsdbConstant.BRIDGE, "_uuid", OvsdbConstant.DATABASENAME, "bridges", ovsUuid, bridge.getRow());
        if (bridgeUuid != null) {
            Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
            if (port != null) {
                log.debug("the port is not null");
                port.setName(bridgeName);
                insertRow("Port", "_uuid", "Bridge", "ports", bridgeUuid, port.getRow());
            }
        }
    } else {
        log.info("Update a bridge");
        updateRow("Bridge", "_uuid", bridgeUuid, bridge.getRow());
    }
    setController(bridgeUuid);
    log.info("Create bridge success");
}
#method_after
@Override
public void createBridge(String bridgeName) {
    log.debug("create bridge {}", bridgeName);
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    if (dbSchema == null) {
        log.warn("The schema is null");
        return;
    }
    Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
    if (bridge == null) {
        log.debug("Can not create bridge");
        return;
    }
    Set<String> failModes = new HashSet<>();
    failModes.add("secure");
    bridge.setFailMode(failModes);
    Set<String> protocols = new HashSet<>();
    protocols.add(OvsdbConstant.OPENFLOW13);
    bridge.setProtocols(protocols);
    String ovsUuid = getOvsUuid(OvsdbConstant.DATABASENAME);
    if (ovsUuid == null) {
        log.warn("The Open_vSwitch is null");
        return;
    }
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.debug("Create a new bridge");
        bridge.setName(bridgeName);
        bridgeUuid = insertConfig(OvsdbConstant.BRIDGE, "_uuid", OvsdbConstant.DATABASENAME, "bridges", ovsUuid, bridge.getRow());
        if (bridgeUuid != null) {
            Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
            if (port != null) {
                log.debug("the port is not null");
                port.setName(bridgeName);
                insertConfig(OvsdbConstant.PORT, "_uuid", "Bridge", "ports", bridgeUuid, port.getRow());
            }
        }
    } else {
        log.info("Update a bridge");
        updateConfig(OvsdbConstant.BRIDGE, "_uuid", bridgeUuid, bridge.getRow());
    }
    setController(bridgeUuid);
    log.info("Create bridge success");
}
#end_block

#method_before
private void setController(String bridgeUuid) {
    String controllerUuid = null;
    String iPAddress = IpAddress.valueOf(((InetSocketAddress) channel.localAddress()).getAddress().getHostAddress()).toString();
    String target = "tcp:" + iPAddress + ":" + OvsdbConstant.OFPORT;
    log.info("controller IP {}: port {}", iPAddress, OvsdbConstant.OFPORT);
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    Controller controller = (Controller) TableGenerator.createTable(dbSchema, OvsdbTable.CONTROLLER);
    if (controller != null) {
        controller.setTarget(target);
        controllerUuid = getControllerUuid(OvsdbConstant.CONTROLLER, target);
        if (controllerUuid == null) {
            insertRow(OvsdbConstant.CONTROLLER, "_uuid", OvsdbConstant.BRIDGE, "controller", bridgeUuid, controller.getRow());
        } else {
            Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
            Set<UUID> controllerUuids = new HashSet<>();
            controllerUuids.add(UUID.uuid(controllerUuid));
            bridge.setController(controllerUuids);
            updateRow("Controller", "_uuid", bridgeUuid, bridge.getRow());
        }
    }
}
#method_after
private void setController(String bridgeUuid) {
    String controllerUuid = null;
    String iPAddress = IpAddress.valueOf(((InetSocketAddress) channel.localAddress()).getAddress().getHostAddress()).toString();
    String target = "tcp:" + iPAddress + ":" + OvsdbConstant.OFPORT;
    log.debug("controller IP {}: port {}", iPAddress, OvsdbConstant.OFPORT);
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    Controller controller = (Controller) TableGenerator.createTable(dbSchema, OvsdbTable.CONTROLLER);
    if (controller != null) {
        controller.setTarget(target);
        controllerUuid = getControllerUuid(OvsdbConstant.CONTROLLER, target);
        if (controllerUuid == null) {
            insertConfig(OvsdbConstant.CONTROLLER, "_uuid", OvsdbConstant.BRIDGE, "controller", bridgeUuid, controller.getRow());
        } else {
            Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
            Set<UUID> controllerUuids = new HashSet<>();
            controllerUuids.add(UUID.uuid(controllerUuid));
            bridge.setController(controllerUuids);
            updateConfig(OvsdbConstant.CONTROLLER, "_uuid", bridgeUuid, bridge.getRow());
        }
    }
}
#end_block

#method_before
@Override
public void dropBridge(String bridgeName) {
    String bridgeUUID = getBridgeUuid(bridgeName);
    if (bridgeUUID == null) {
        log.warn("Could not find bridge in node", nodeId.getIpAddress());
        return;
    }
    deleteRow(OvsdbConstant.BRIDGE, "_uuid", bridgeUUID, OvsdbConstant.DATABASENAME, "bridges");
}
#method_after
@Override
public void dropBridge(String bridgeName) {
    String bridgeUUID = getBridgeUuid(bridgeName);
    if (bridgeUUID == null) {
        log.warn("Could not find bridge in node", nodeId.getIpAddress());
        return;
    }
    deleteConfig(OvsdbConstant.BRIDGE, "_uuid", bridgeUUID, OvsdbConstant.DATABASENAME, "bridges");
}
#end_block

#method_before
@Override
public void createTunnel(IpAddress srcIp, IpAddress dstIp) {
    String bridgeUuid = getBridgeUuid(OvsdbConstant.INTEGRATION_BRIDGE);
    if (bridgeUuid == null) {
        log.warn("Could not find bridge {} and Could not create tunnel. ", OvsdbConstant.INTEGRATION_BRIDGE);
        return;
    }
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    String portName = getTunnelName(OvsdbConstant.TYPEVXLAN, dstIp);
    String portUuid = getPortUuid(portName, bridgeUuid);
    Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
    if (port != null) {
        port.setName(portName);
    }
    if (portUuid == null) {
        insertRow(OvsdbConstant.PORT, "_uuid", OvsdbConstant.BRIDGE, "ports", bridgeUuid, port.getRow());
    } else {
        updateRow(OvsdbConstant.PORT, "_uuid", portUuid, port.getRow());
    }
    // When a tunnel is created, A row is inserted into port table and
    // interface table of the ovsdb node.
    // and the following step is to get the interface uuid from local store
    // in controller node.
    // but it need spend some time synchronising data between node and
    // controller.
    // so loop to judge if interfaceUUid is null is necessary.
    String interfaceUuid = null;
    for (int i = 0; i < 10; i++) {
        interfaceUuid = getInterfaceUuid(portUuid, portName);
        if (interfaceUuid == null) {
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                log.warn("Interrupted while waiting to get interfaceUuid");
                Thread.currentThread().interrupt();
            }
        } else {
            break;
        }
    }
    if (interfaceUuid != null) {
        OvsdbRowStore rowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.INTERFACE);
        if (rowStore == null) {
            log.debug("The bridge uuid is null");
            return;
        }
        ConcurrentMap<String, Row> intfTableRows = rowStore.getRowStore();
        if (intfTableRows == null) {
            log.debug("The bridge uuid is null");
            return;
        }
        Interface tunInterface = (Interface) TableGenerator.getTable(dbSchema, intfTableRows.get(interfaceUuid), OvsdbTable.INTERFACE);
        if (tunInterface != null) {
            tunInterface.setType(OvsdbConstant.TYPEVXLAN);
            Map<String, String> options = Maps.newHashMap();
            options.put("key", "flow");
            options.put("local_ip", srcIp.toString());
            options.put("remote_ip", dstIp.toString());
            tunInterface.setOptions(options);
            updateRow(OvsdbConstant.INTERFACE, "_uuid", interfaceUuid, tunInterface.getRow());
            log.info("Tunnel added success", tunInterface);
        }
    }
    return;
}
#method_after
@Override
public void createTunnel(IpAddress srcIp, IpAddress dstIp) {
    String bridgeUuid = getBridgeUuid(OvsdbConstant.INTEGRATION_BRIDGE);
    if (bridgeUuid == null) {
        log.warn("Could not find bridge {} and Could not create tunnel. ", OvsdbConstant.INTEGRATION_BRIDGE);
        return;
    }
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    String portName = getTunnelName(OvsdbConstant.TYPEVXLAN, dstIp);
    String portUuid = getPortUuid(portName, bridgeUuid);
    Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
    if (port != null) {
        port.setName(portName);
    }
    if (portUuid == null) {
        portUuid = insertConfig(OvsdbConstant.PORT, "_uuid", OvsdbConstant.BRIDGE, "ports", bridgeUuid, port.getRow());
    } else {
        updateConfig(OvsdbConstant.PORT, "_uuid", portUuid, port.getRow());
    }
    // When a tunnel is created, A row is inserted into port table and
    // interface table of the ovsdb node.
    // and the following step is to get the interface uuid from local store
    // in controller node.
    // but it need spend some time synchronising data between node and
    // controller.
    // so loop to judge if interfaceUUid is null is necessary.
    String interfaceUuid = null;
    for (int i = 0; i < 10; i++) {
        interfaceUuid = getInterfaceUuid(portUuid, portName);
        if (interfaceUuid == null) {
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                log.warn("Interrupted while waiting to get interfaceUuid");
                Thread.currentThread().interrupt();
            }
        } else {
            break;
        }
    }
    if (interfaceUuid != null) {
        OvsdbRowStore rowStore = getRowStore(OvsdbConstant.DATABASENAME, OvsdbConstant.INTERFACE);
        if (rowStore == null) {
            log.debug("The bridge uuid is null");
            return;
        }
        ConcurrentMap<String, Row> intfTableRows = rowStore.getRowStore();
        if (intfTableRows == null) {
            log.debug("The bridge uuid is null");
            return;
        }
        Interface tunInterface = (Interface) TableGenerator.getTable(dbSchema, intfTableRows.get(interfaceUuid), OvsdbTable.INTERFACE);
        if (tunInterface != null) {
            tunInterface.setType(OvsdbConstant.TYPEVXLAN);
            Map<String, String> options = Maps.newHashMap();
            options.put("key", "flow");
            options.put("local_ip", srcIp.toString());
            options.put("remote_ip", dstIp.toString());
            tunInterface.setOptions(options);
            updateConfig(OvsdbConstant.INTERFACE, "_uuid", interfaceUuid, tunInterface.getRow());
            log.info("Tunnel added success", tunInterface);
        }
    }
    return;
}
#end_block

#method_before
@Override
public void dropTunnel(IpAddress srcIp, IpAddress dstIp) {
    String bridgeName = OvsdbConstant.INTEGRATION_BRIDGE;
    String portName = getTunnelName(OvsdbConstant.TYPEVXLAN, dstIp);
    String bridgeUuid = getBridgeUuid(OvsdbConstant.INTEGRATION_BRIDGE);
    if (bridgeUuid == null) {
        log.warn("Could not find bridge {} in {}", bridgeName, nodeId.getIpAddress());
        return;
    }
    String portUUID = getPortUuid(portName, bridgeUuid);
    if (portUUID != null) {
        log.info("Delete tunnel");
        deleteRow(OvsdbConstant.PORT, "_uuid", portUUID, OvsdbConstant.BRIDGE, "ports");
    }
    return;
}
#method_after
@Override
public void dropTunnel(IpAddress srcIp, IpAddress dstIp) {
    String bridgeName = OvsdbConstant.INTEGRATION_BRIDGE;
    String portName = getTunnelName(OvsdbConstant.TYPEVXLAN, dstIp);
    String bridgeUuid = getBridgeUuid(OvsdbConstant.INTEGRATION_BRIDGE);
    if (bridgeUuid == null) {
        log.warn("Could not find bridge {} in {}", bridgeName, nodeId.getIpAddress());
        return;
    }
    String portUUID = getPortUuid(portName, bridgeUuid);
    if (portUUID != null) {
        log.info("Delete tunnel");
        deleteConfig(OvsdbConstant.PORT, "_uuid", portUUID, OvsdbConstant.BRIDGE, "ports");
    }
    return;
}
#end_block

#method_before
@Override
public ListenableFuture<DatabaseSchema> getOvsdbSchema(String dbName) {
    if (dbName == null) {
        return null;
    }
    DatabaseSchema databaseSchema = schema.get(dbName);
    if (databaseSchema == null) {
        List<String> dbNames = new ArrayList<String>();
        dbNames.add(dbName);
        Function<JsonNode, DatabaseSchema> rowFunction = new Function<JsonNode, DatabaseSchema>() {

            @Override
            public DatabaseSchema apply(JsonNode input) {
                log.info("Get ovsdb database schema", dbName);
                DatabaseSchema dbSchema = FromJsonUtil.jsonNodeToDbSchema(dbName, input);
                if (dbSchema == null) {
                    log.info("Get ovsdb database schema error");
                    return null;
                }
                schema.put(dbName, dbSchema);
                return dbSchema;
            }
        };
        ListenableFuture<JsonNode> input = getSchema(dbNames);
        if (input != null) {
            try {
                log.info("input message: {}", input.get().toString());
            } catch (InterruptedException e) {
                log.warn("Interrupted while waiting to get message");
                Thread.currentThread().interrupt();
            } catch (ExecutionException e) {
                log.error("Exception thrown while to get message");
            }
        }
        return Futures.transform(input, rowFunction);
    } else {
        return Futures.immediateFuture(databaseSchema);
    }
}
#method_after
@Override
public ListenableFuture<DatabaseSchema> getOvsdbSchema(String dbName) {
    if (dbName == null) {
        return null;
    }
    DatabaseSchema databaseSchema = schema.get(dbName);
    if (databaseSchema == null) {
        List<String> dbNames = new ArrayList<String>();
        dbNames.add(dbName);
        Function<JsonNode, DatabaseSchema> rowFunction = new Function<JsonNode, DatabaseSchema>() {

            @Override
            public DatabaseSchema apply(JsonNode input) {
                log.info("Get ovsdb database schema", dbName);
                DatabaseSchema dbSchema = FromJsonUtil.jsonNodeToDbSchema(dbName, input);
                if (dbSchema == null) {
                    log.debug("Get ovsdb database schema error");
                    return null;
                }
                schema.put(dbName, dbSchema);
                return dbSchema;
            }
        };
        ListenableFuture<JsonNode> input = getSchema(dbNames);
        if (input != null) {
            try {
                log.info("input message: {}", input.get().toString());
            } catch (InterruptedException e) {
                log.warn("Interrupted while waiting to get message");
                Thread.currentThread().interrupt();
            } catch (ExecutionException e) {
                log.error("Exception thrown while to get message");
            }
        }
        return Futures.transform(input, rowFunction);
    } else {
        return Futures.immediateFuture(databaseSchema);
    }
}
#end_block

#method_before
@Override
public ListenableFuture<TableUpdates> monitorTables(String dbName, String id) {
    if (dbName == null) {
        return null;
    }
    DatabaseSchema dbSchema = schema.get(dbName);
    if (dbSchema != null) {
        Function<JsonNode, TableUpdates> rowFunction = new Function<JsonNode, TableUpdates>() {

            @Override
            public TableUpdates apply(JsonNode input) {
                log.info("Get table updates");
                TableUpdates updates = FromJsonUtil.jsonNodeToTableUpdates(input, dbSchema);
                if (updates == null) {
                    log.info("Get table updates error");
                    return null;
                }
                return updates;
            }
        };
        return Futures.transform(monitor(dbSchema, id), rowFunction);
    }
    return null;
}
#method_after
@Override
public ListenableFuture<TableUpdates> monitorTables(String dbName, String id) {
    if (dbName == null) {
        return null;
    }
    DatabaseSchema dbSchema = schema.get(dbName);
    if (dbSchema != null) {
        Function<JsonNode, TableUpdates> rowFunction = new Function<JsonNode, TableUpdates>() {

            @Override
            public TableUpdates apply(JsonNode input) {
                log.info("Get table updates");
                TableUpdates updates = FromJsonUtil.jsonNodeToTableUpdates(input, dbSchema);
                if (updates == null) {
                    log.debug("Get table updates error");
                    return null;
                }
                return updates;
            }
        };
        return Futures.transform(monitor(dbSchema, id), rowFunction);
    }
    return null;
}
#end_block

#method_before
@Override
public ListenableFuture<List<OperationResult>> transactConfig(String dbName, List<Operation> operations) {
    if (dbName == null) {
        return null;
    }
    DatabaseSchema dbSchema = schema.get(dbName);
    if (dbSchema != null) {
        Function<List<JsonNode>, List<OperationResult>> rowFunction = new Function<List<JsonNode>, List<OperationResult>>() {

            @Override
            public List<OperationResult> apply(List<JsonNode> input) {
                log.info("Get ovsdb operation result");
                List<OperationResult> result = FromJsonUtil.jsonNodeToOperationResult(input, operations);
                if (result == null) {
                    log.info("The operation result is null");
                    return null;
                }
                return result;
            }
        };
        return Futures.transform(transact(dbSchema, operations), rowFunction);
    }
    return null;
}
#method_after
@Override
public ListenableFuture<List<OperationResult>> transactConfig(String dbName, List<Operation> operations) {
    if (dbName == null) {
        return null;
    }
    DatabaseSchema dbSchema = schema.get(dbName);
    if (dbSchema != null) {
        Function<List<JsonNode>, List<OperationResult>> rowFunction = new Function<List<JsonNode>, List<OperationResult>>() {

            @Override
            public List<OperationResult> apply(List<JsonNode> input) {
                log.info("Get ovsdb operation result");
                List<OperationResult> result = FromJsonUtil.jsonNodeToOperationResult(input, operations);
                if (result == null) {
                    log.debug("The operation result is null");
                    return null;
                }
                return result;
            }
        };
        return Futures.transform(transact(dbSchema, operations), rowFunction);
    }
    return null;
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
@Override
public void processResult(JsonNode response) {
    log.info("Handle result");
    String requestId = response.get("id").asText();
    SettableFuture sf = requestResult.get(requestId);
    if (sf == null) {
        log.info("No such future to process");
        return;
    }
    String methodName = requestMethod.get(requestId);
    Object result;
    result = FromJsonUtil.jsonResultParser(response, methodName);
    sf.set(result);
    return;
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
@Override
public void processResult(JsonNode response) {
    log.debug("Handle result");
    String requestId = response.get("id").asText();
    SettableFuture sf = requestResult.get(requestId);
    if (sf == null) {
        log.debug("No such future to process");
        return;
    }
    String methodName = requestMethod.get(requestId);
    Object result;
    result = FromJsonUtil.jsonResultParser(response, methodName);
    sf.set(result);
    return;
}
#end_block

#method_before
@Override
public void processRequest(JsonNode requestJson) {
    log.info("Handle request");
    if (requestJson.get("method").asText().equalsIgnoreCase("echo")) {
        log.info("handle echo request");
        String replyString = FromJsonUtil.getEchoRequestStr(requestJson);
        channel.writeAndFlush(replyString);
        return;
    } else {
        FromJsonUtil.jsonCallbackRequestParser(requestJson, monitorCallBack);
        return;
    }
}
#method_after
@Override
public void processRequest(JsonNode requestJson) {
    log.debug("Handle request");
    if (requestJson.get("method").asText().equalsIgnoreCase("echo")) {
        log.debug("handle echo request");
        String replyString = FromJsonUtil.getEchoRequestStr(requestJson);
        channel.writeAndFlush(replyString);
        return;
    } else {
        FromJsonUtil.jsonCallbackRequestParser(requestJson, monitorCallBack);
        return;
    }
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createAndAddHost(InputStream stream) {
    URI location;
    try {
        // Parse the input stream
        ObjectNode root = (ObjectNode) mapper().readTree(stream);
        // How to get a hostProviderRegistry in another way? Below gives NullPointerExc
        HostProviderRegistry hostProviderRegistry = get(HostProviderRegistry.class);
        InternalHostProvider hostProvider = new InternalHostProvider(hostProviderRegistry);
        hostProvider.register();
        HostId hostId = hostProvider.parseHost(root);
        UriBuilder locationBuilder = uriInfo.getBaseUriBuilder().path("hosts").path(hostId.mac().toString()).path(hostId.vlanId().toString());
        location = locationBuilder.build();
        hostProvider.unregister();
    } catch (IOException ex) {
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
    }
    return Response.created(location).build();
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createAndAddHost(InputStream stream) {
    URI location;
    try {
        // Parse the input stream
        ObjectNode root = (ObjectNode) mapper().readTree(stream);
        HostProviderRegistry hostProviderRegistry = get(HostProviderRegistry.class);
        InternalHostProvider hostProvider = new InternalHostProvider();
        HostProviderService hostProviderService = hostProviderRegistry.register(hostProvider);
        hostProvider.setHostProviderService(hostProviderService);
        HostId hostId = hostProvider.parseHost(root);
        UriBuilder locationBuilder = uriInfo.getBaseUriBuilder().path("hosts").path(hostId.mac().toString()).path(hostId.vlanId().toString());
        location = locationBuilder.build();
        hostProviderRegistry.unregister(hostProvider);
    } catch (IOException ex) {
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
    }
    return Response.created(location).build();
}
#end_block

#method_before
@Before
public void setUpTest() {
    expect(mockHostService.getHosts()).andReturn(hosts).anyTimes();
    // Register the services needed for the test
    final CodecManager codecService = new CodecManager();
    codecService.activate();
    ServiceDirectory testDirectory = new TestServiceDirectory().add(HostService.class, mockHostService).add(CodecService.class, codecService);
    BaseResource.setServiceDirectory(testDirectory);
}
#method_after
@Before
public void setUpTest() {
    expect(mockHostService.getHosts()).andReturn(hosts).anyTimes();
    // Register the services needed for the test
    final CodecManager codecService = new CodecManager();
    codecService.activate();
    ServiceDirectory testDirectory = new TestServiceDirectory().add(HostService.class, mockHostService).add(CodecService.class, codecService).add(HostProviderRegistry.class, mockHostProviderRegistry);
    BaseResource.setServiceDirectory(testDirectory);
}
#end_block

#method_before
@Test
public void testPost() {
    replay(mockHostService);
    InputStream jsonStream = IntentsResourceTest.class.getResourceAsStream("post-host.json");
    WebResource rs = resource();
    ClientResponse response = rs.path("hosts").type(MediaType.APPLICATION_JSON_TYPE).post(ClientResponse.class, jsonStream);
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_CREATED));
    String location = response.getLocation().getPath();
    assertThat(location, Matchers.startsWith("/11:22:33:44:55:66/-1"));
}
#method_after
@Test
public void testPost() {
    mockHostProviderService.hostDetected(anyObject(), anyObject());
    expectLastCall();
    replay(mockHostProviderService);
    expect(mockHostProviderRegistry.register(anyObject())).andReturn(mockHostProviderService);
    mockHostProviderRegistry.unregister(anyObject());
    expectLastCall();
    replay(mockHostProviderRegistry);
    replay(mockHostService);
    InputStream jsonStream = IntentsResourceTest.class.getResourceAsStream("post-host.json");
    WebResource rs = resource();
    ClientResponse response = rs.path("hosts").type(MediaType.APPLICATION_JSON_TYPE).post(ClientResponse.class, jsonStream);
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_CREATED));
    String location = response.getLocation().getPath();
    assertThat(location, Matchers.startsWith("/hosts/11:22:33:44:55:66/-1"));
}
#end_block

#method_before
public static int versionCompare(String fromVersion, String toVersion) {
    int fromFirst = Integer.parseInt(fromVersion.split("\\.")[0]);
    int fromMiddle = Integer.parseInt(fromVersion.split("\\.")[1]);
    int fromEnd = Integer.parseInt(fromVersion.split("\\.")[2]);
    int toFirst = Integer.parseInt(toVersion.split("\\.")[0]);
    int toMiddle = Integer.parseInt(toVersion.split("\\.")[1]);
    int toEnd = Integer.parseInt(toVersion.split("\\.")[2]);
    if (fromFirst - toFirst != 0) {
        return fromFirst - toFirst;
    } else if (fromMiddle - toMiddle != 0) {
        return fromMiddle - toMiddle;
    } else {
        return fromEnd - toEnd;
    }
}
#method_after
public static int versionCompare(String fromVersion, String toVersion) {
    String[] fromArr = fromVersion.split("\\.");
    String[] toArr = toVersion.split("\\.");
    int fromFirst = Integer.parseInt(fromArr[0]);
    int fromMiddle = Integer.parseInt(fromArr[1]);
    int fromEnd = Integer.parseInt(fromArr[2]);
    int toFirst = Integer.parseInt(toArr[0]);
    int toMiddle = Integer.parseInt(toArr[1]);
    int toEnd = Integer.parseInt(toArr[2]);
    if (fromFirst - toFirst != 0) {
        return fromFirst - toFirst;
    } else if (fromMiddle - toMiddle != 0) {
        return fromMiddle - toMiddle;
    } else {
        return fromEnd - toEnd;
    }
}
#end_block

#method_before
public static SparseAnnotations combine(OpticalPortConfig opc, SparseAnnotations an) {
    DefaultAnnotations.Builder b = DefaultAnnotations.builder();
    if (!opc.staticPort().isEmpty()) {
        b.set(STATIC_PORT, opc.staticPort());
    }
    if (opc.staticLambda().isPresent()) {
        b.set(STATIC_LAMBDA, opc.staticPort());
    }
    // The following may not need to be carried.
    if (!opc.name().isEmpty()) {
        b.set(AnnotationKeys.PORT_NAME, opc.name());
    }
    return DefaultAnnotations.union(an, b.build());
}
#method_after
public static SparseAnnotations combine(OpticalPortConfig opc, SparseAnnotations an) {
    DefaultAnnotations.Builder b = DefaultAnnotations.builder();
    if (!opc.staticPort().isEmpty()) {
        b.set(AnnotationKeys.STATIC_PORT, opc.staticPort());
    }
    if (opc.staticLambda().isPresent()) {
        b.set(AnnotationKeys.STATIC_LAMBDA, String.valueOf(opc.staticLambda().get()));
    }
    // The following may not need to be carried.
    if (!opc.name().isEmpty()) {
        b.set(AnnotationKeys.PORT_NAME, opc.name());
    }
    return DefaultAnnotations.union(an, b.build());
}
#end_block

#method_before
@Test(expected = RuntimeException.class)
public void testDescOps() {
    // port-null desc + opc with port number name
    OduCltPortDescription res = (OduCltPortDescription) OpticalPortOperator.combine(N_OPC, FAULTY);
    assertEquals(CFGNAME, res.portNumber().name());
    // full desc + opc with name
    assertEquals(TPNAME, N_DESC.portNumber().name());
    res = (OduCltPortDescription) OpticalPortOperator.combine(N_OPC, N_DESC);
    long sl = Long.valueOf(res.annotations().value(AnnotationKeys.STATIC_LAMBDA));
    assertEquals(CFGNAME, res.portNumber().name());
    assertEquals(101L, sl);
    // port-null desc + opc without port number name - throws RE
    res = (OduCltPortDescription) OpticalPortOperator.combine(UNN_OPC, FAULTY);
}
#method_after
@Test(expected = RuntimeException.class)
public void testDescOps() {
    // port-null desc + opc with port number name
    OduCltPortDescription res = (OduCltPortDescription) OpticalPortOperator.combine(N_OPC, FAULTY);
    assertEquals(CFGNAME, res.portNumber().name());
    // full desc + opc with name
    assertEquals(TPNAME, N_DESC.portNumber().name());
    res = (OduCltPortDescription) OpticalPortOperator.combine(N_OPC, N_DESC);
    long sl = Long.valueOf(res.annotations().value(AnnotationKeys.STATIC_LAMBDA));
    assertEquals(CFGNAME, res.portNumber().name());
    assertEquals(300L, sl);
    // port-null desc + opc without port number name - throws RE
    res = (OduCltPortDescription) OpticalPortOperator.combine(UNN_OPC, FAULTY);
}
#end_block

#method_before
public IpPrefix getGaddr() {
    return gaddr;
}
#method_after
@Override
public IpPrefix getGaddr() {
    return gaddr;
}
#end_block

#method_before
public IpPrefix getSaddr() {
    return saddr;
}
#method_after
@Override
public IpPrefix getSaddr() {
    return saddr;
}
#end_block

#method_before
public boolean isIp4() {
    return gaddr.isIp4();
}
#method_after
@Override
public boolean isIp4() {
    return gaddr.isIp4();
}
#end_block

#method_before
public boolean isIp6() {
    return gaddr.isIp6();
}
#method_after
@Override
public boolean isIp6() {
    return gaddr.isIp6();
}
#end_block

#method_before
public void addIngressPoint(ConnectPoint ingress) {
    ingressPoint = checkNotNull(ingress);
}
#method_after
@Override
public void addIngressPoint(ConnectPoint ingress) {
    ingressPoint = checkNotNull(ingress);
}
#end_block

#method_before
public void addIngressPoint(String deviceId, long portNum) {
    ingressPoint = new ConnectPoint(DeviceId.deviceId(deviceId), PortNumber.portNumber(portNum));
}
#method_after
@Override
public void addIngressPoint(String deviceId, long portNum) {
    ingressPoint = new ConnectPoint(DeviceId.deviceId(deviceId), PortNumber.portNumber(portNum));
}
#end_block

#method_before
public ConnectPoint getIngressPoint() {
    return this.ingressPoint;
}
#method_after
@Override
public ConnectPoint getIngressPoint() {
    return this.ingressPoint;
}
#end_block

#method_before
public void addEgressPoint(ConnectPoint member) {
    egressPoints.add(checkNotNull(member));
}
#method_after
@Override
public void addEgressPoint(ConnectPoint member) {
    egressPoints.add(checkNotNull(member));
}
#end_block

#method_before
public void addEgressPoint(String deviceId, long portNum) {
    ConnectPoint cp = new ConnectPoint(DeviceId.deviceId(deviceId), PortNumber.portNumber(portNum));
    this.egressPoints.add(cp);
}
#method_after
@Override
public void addEgressPoint(String deviceId, long portNum) {
    ConnectPoint cp = new ConnectPoint(DeviceId.deviceId(deviceId), PortNumber.portNumber(portNum));
    this.egressPoints.add(cp);
}
#end_block

#method_before
public Set<ConnectPoint> getEgressPoints() {
    return egressPoints;
}
#method_after
@Override
public Set<ConnectPoint> getEgressPoints() {
    return egressPoints;
}
#end_block

#method_before
public Integer getPuntCount() {
    return puntCount;
}
#method_after
@Override
public Integer getPuntCount() {
    return puntCount;
}
#end_block

#method_before
public void incrementPuntCount() {
    puntCount++;
}
#method_after
@Override
public void incrementPuntCount() {
    puntCount++;
}
#end_block

#method_before
public void setIntent() {
    if (this.intentKey != null) {
        this.withdrawIntent();
    }
    McastIntentManager im = McastIntentManager.getInstance();
    SinglePointToMultiPointIntent intent = im.setIntent(this);
    this.intentKey = intent.key();
}
#method_after
@Override
public void setIntent() {
    if (this.intentKey != null) {
        this.withdrawIntent();
    }
    McastIntentManager im = McastIntentManager.getInstance();
    SinglePointToMultiPointIntent intent = im.setIntent(this);
    this.intentKey = intent.key();
}
#end_block

#method_before
public void setIntent(SinglePointToMultiPointIntent intent) {
    intentKey = intent.key();
}
#method_after
@Override
public void setIntent(SinglePointToMultiPointIntent intent) {
    intentKey = intent.key();
}
#end_block

#method_before
public Key getIntentKey() {
    return this.intentKey;
}
#method_after
@Override
public Key getIntentKey() {
    return this.intentKey;
}
#end_block

#method_before
public void withdrawIntent() {
    if (intentKey == null) {
        // nothing to withdraw
        return;
    }
    McastIntentManager im = McastIntentManager.getInstance();
    im.withdrawIntent(this);
    this.intentKey = null;
}
#method_after
@Override
public void withdrawIntent() {
    if (intentKey == null) {
        // nothing to withdraw
        return;
    }
    McastIntentManager im = McastIntentManager.getInstance();
    im.withdrawIntent(this);
    this.intentKey = null;
}
#end_block

#method_before
public String toString() {
    String out = String.format("(%s, %s)\n\t", saddr.toString(), gaddr.toString());
    out += "intent: ";
    out += (intentKey == null) ? "not installed" : this.intentKey.toString();
    out += "\n\tingress: ";
    out += (ingressPoint == null) ? "NULL" : ingressPoint.toString();
    out += "\n\tegress: {\n";
    if (egressPoints != null && !egressPoints.isEmpty()) {
        for (ConnectPoint eg : egressPoints) {
            out += "\t\t" + eg.toString() + "\n";
        }
    }
    out += ("\t}\n");
    out += ("\tpunted: " + this.getPuntCount() + "\n");
    return out;
}
#method_after
@Override
public String toString() {
    String out = String.format("(%s, %s)\n\t", saddr.toString(), gaddr.toString());
    out += "intent: ";
    out += (intentKey == null) ? "not installed" : this.intentKey.toString();
    out += "\n\tingress: ";
    out += (ingressPoint == null) ? "NULL" : ingressPoint.toString();
    out += "\n\tegress: {\n";
    if (egressPoints != null && !egressPoints.isEmpty()) {
        for (ConnectPoint eg : egressPoints) {
            out += "\t\t" + eg.toString() + "\n";
        }
    }
    out += ("\t}\n");
    out += ("\tpunted: " + this.getPuntCount() + "\n");
    return out;
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.mfwd");
    packetService.addProcessor(processor, PacketProcessor.ADVISOR_MAX + 2);
    // Build a traffic selector for all multicast traffic
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchIPDst(mcast);
    packetService.requestPackets(selector.build(), PacketPriority.REACTIVE, appId);
    mrib = McastRouteTable.getInstance();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onosproject.mfwd");
    packetService.addProcessor(processor, PacketProcessor.ADVISOR_MAX + 2);
    // Build a traffic selector for all multicast traffic
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.matchEthType(Ethernet.TYPE_IPV4);
    selector.matchIPDst(mcast);
    packetService.requestPackets(selector.build(), PacketPriority.REACTIVE, appId);
    mrib = McastRouteTable.getInstance();
    log.info("Started");
}
#end_block

#method_before
@Override
public void serialize(UUID value, JsonGenerator generator, SerializerProvider provider) throws IOException, JsonProcessingException {
    generator.writeStartArray();
    try {
        java.util.UUID.fromString(value.value());
        generator.writeString("uuid");
    } catch (IllegalArgumentException ex) {
        log.info("don't match UUID, so it should be named-uuid");
        generator.writeString("named-uuid");
    }
    generator.writeString(value.value());
    generator.writeEndArray();
}
#method_after
@Override
public void serialize(UUID value, JsonGenerator generator, SerializerProvider provider) throws IOException {
    generator.writeStartArray();
    String reg = "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$";
    if (value.value().matches(reg)) {
        generator.writeString("uuid");
    } else {
        generator.writeString("named-uuid");
    }
    generator.writeString(value.value());
    generator.writeEndArray();
}
#end_block

#method_before
static int advisor(int priority) {
    checkArgument((priority >= 0) && (priority < ADVISOR_MAX), "Priority not within ADVISOR range");
    return priority;
}
#method_after
static int advisor(int priority) {
    int overallPriority = priority + 1;
    checkArgument(overallPriority > 0 && overallPriority <= ADVISOR_MAX, "Priority not within ADVISOR range");
    return overallPriority;
}
#end_block

#method_before
static int director(int priority) {
    int overallPriority = ADVISOR_MAX + priority;
    checkArgument((overallPriority >= ADVISOR_MAX) && (overallPriority < DIRECTOR_MAX), "Priority not within DIRECTOR range");
    return overallPriority;
}
#method_after
static int director(int priority) {
    int overallPriority = ADVISOR_MAX + priority + 1;
    checkArgument(overallPriority > ADVISOR_MAX && overallPriority <= DIRECTOR_MAX, "Priority not within DIRECTOR range");
    return overallPriority;
}
#end_block

#method_before
static int observer(int priority) {
    int overallPriority = DIRECTOR_MAX + priority;
    checkArgument((overallPriority >= DIRECTOR_MAX) && (overallPriority < OBSERVER_MAX), "Priority not within OBSERVER range");
    return overallPriority;
}
#method_after
static int observer(int priority) {
    int overallPriority = DIRECTOR_MAX + priority + 1;
    checkArgument(overallPriority > DIRECTOR_MAX && overallPriority <= OBSERVER_MAX, "Priority not within OBSERVER range");
    return overallPriority;
}
#end_block

#method_before
public Column getTargetColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("target", "getTargetColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getTargetColumn() {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.TARGET.columnName(), "getTargetColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setTarget(String target) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("target", "setTarget", "1.0.0");
    super.setDataHandler(columndesc, target);
}
#method_after
public void setTarget(String target) {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.TARGET.columnName(), "setTarget", VersionNum.VERSION100);
    super.setDataHandler(columndesc, target);
}
#end_block

#method_before
public Column getBurstLimitColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("controller_burst_limit", "getBurstLimitColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getBurstLimitColumn() {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.BURSTLIMIT.columnName(), "getBurstLimitColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setBurstLimit(Long burstLimit) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("controller_burst_limit", "setBurstLimit", "1.0.0");
    super.setDataHandler(columndesc, burstLimit);
}
#method_after
public void setBurstLimit(Long burstLimit) {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.BURSTLIMIT.columnName(), "setBurstLimit", VersionNum.VERSION100);
    super.setDataHandler(columndesc, burstLimit);
}
#end_block

#method_before
public Column getRateLimitColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("controller_rate_limit", "getRateLimitColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getRateLimitColumn() {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.RATELIMIT.columnName(), "getRateLimitColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setRateLimit(Long rateLimit) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("controller_rate_limit", "setRateLimit", "1.0.0");
    super.setDataHandler(columndesc, rateLimit);
}
#method_after
public void setRateLimit(Long rateLimit) {
    ColumnDescription columndesc = new ColumnDescription("controller_rate_limit", "setRateLimit", VersionNum.VERSION100);
    super.setDataHandler(columndesc, rateLimit);
}
#end_block

#method_before
public Column getConnectionModeColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("connection_mode", "getConnectionModeColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getConnectionModeColumn() {
    ColumnDescription columndesc = new ColumnDescription("connection_mode", "getConnectionModeColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setConnectionMode(Set<String> connectionMode) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("connection_mode", "setConnectionMode", "1.0.0");
    super.setDataHandler(columndesc, connectionMode);
}
#method_after
public void setConnectionMode(Set<String> connectionMode) {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.RATELIMIT.columnName(), "setConnectionMode", VersionNum.VERSION100);
    super.setDataHandler(columndesc, connectionMode);
}
#end_block

#method_before
public Column getEnableAsyncMessagesColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("enable_async_messages", "getEnableAsyncMessagesColumn", "6.7.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getEnableAsyncMessagesColumn() {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.ENABLEASYNCMESSAGES.columnName(), "getEnableAsyncMessagesColumn", VersionNum.VERSION670);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setEnableAsyncMessages(Set<Boolean> enableAsyncMessages) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("enable_async_messages", "setEnableAsyncMessages", "6.7.0");
    super.setDataHandler(columndesc, enableAsyncMessages);
}
#method_after
public void setEnableAsyncMessages(Set<Boolean> enableAsyncMessages) {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.ENABLEASYNCMESSAGES.columnName(), "setEnableAsyncMessages", VersionNum.VERSION670);
    super.setDataHandler(columndesc, enableAsyncMessages);
}
#end_block

#method_before
public Column getExternalIdsColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("external_ids", "getExternalIdsColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getExternalIdsColumn() {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.EXTERNALIDS.columnName(), "getExternalIdsColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setExternalIds(Map<String, String> externalIds) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("external_ids", "setExternalIds", "1.0.0");
    super.setDataHandler(columndesc, externalIds);
}
#method_after
public void setExternalIds(Map<String, String> externalIds) {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.EXTERNALIDS.columnName(), "setExternalIds", VersionNum.VERSION100);
    super.setDataHandler(columndesc, externalIds);
}
#end_block

#method_before
public Column getLocalNetmaskColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("local_netmask", "getLocalNetmaskColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getLocalNetmaskColumn() {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.LOCALNETMASK.columnName(), "getLocalNetmaskColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setLocalNetmask(Set<String> localNetmask) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("local_netmask", "setLocalNetmask", "1.0.0");
    super.setDataHandler(columndesc, localNetmask);
}
#method_after
public void setLocalNetmask(Set<String> localNetmask) {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.LOCALNETMASK.columnName(), "setLocalNetmask", VersionNum.VERSION100);
    super.setDataHandler(columndesc, localNetmask);
}
#end_block

#method_before
public Column getLocalGatewayColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("local_gateway", "getLocalGatewayColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getLocalGatewayColumn() {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.LOCALGATEWAY.columnName(), "getLocalGatewayColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setLocalGateway(Set<String> localGateway) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("local_gateway", "setLocalGateway", "1.0.0");
    super.setDataHandler(columndesc, localGateway);
}
#method_after
public void setLocalGateway(Set<String> localGateway) {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.LOCALGATEWAY.columnName(), "setLocalGateway", VersionNum.VERSION100);
    super.setDataHandler(columndesc, localGateway);
}
#end_block

#method_before
public Column getStatusColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("status", "getStatusColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getStatusColumn() {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.STATUS.columnName(), "getStatusColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setStatus(Map<String, String> status) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("status", "setStatus", "1.0.0");
    super.setDataHandler(columndesc, status);
}
#method_after
public void setStatus(Map<String, String> status) {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.STATUS.columnName(), "setStatus", VersionNum.VERSION100);
    super.setDataHandler(columndesc, status);
}
#end_block

#method_before
public Column getRoleColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("role", "getRoleColumn", "1.1.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getRoleColumn() {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.ROLE.columnName(), "getRoleColumn", VersionNum.VERSION110);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setRole(Set<String> role) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("role", "setRole", "1.1.0");
    super.setDataHandler(columndesc, role);
}
#method_after
public void setRole(Set<String> role) {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.ROLE.columnName(), "setRole", VersionNum.VERSION110);
    super.setDataHandler(columndesc, role);
}
#end_block

#method_before
public Column getInactivityProbeColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("inactivity_probe", "getInactivityProbeColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getInactivityProbeColumn() {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.INACTIVITYPROBE.columnName(), "getInactivityProbeColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setInactivityProbe(Set<Long> inactivityProbe) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("inactivity_probe", "setInactivityProbe", "1.0.0");
    super.setDataHandler(columndesc, inactivityProbe);
}
#method_after
public void setInactivityProbe(Set<Long> inactivityProbe) {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.INACTIVITYPROBE.columnName(), "setInactivityProbe", VersionNum.VERSION100);
    super.setDataHandler(columndesc, inactivityProbe);
}
#end_block

#method_before
public Column getIsConnectedColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("is_connected", "getIsConnectedColumn", "1.1.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getIsConnectedColumn() {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.ISCONNECTED.columnName(), "getIsConnectedColumn", VersionNum.VERSION110);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setIsConnected(Boolean isConnected) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("is_connected", "setIsConnected", "1.1.0");
    super.setDataHandler(columndesc, isConnected);
}
#method_after
public void setIsConnected(Boolean isConnected) {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.ISCONNECTED.columnName(), "setIsConnected", VersionNum.VERSION110);
    super.setDataHandler(columndesc, isConnected);
}
#end_block

#method_before
public Column getOtherConfigColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("other_config", "getOtherConfigColumn", "6.8.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getOtherConfigColumn() {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.OTHERCONFIG.columnName(), "getOtherConfigColumn", VersionNum.VERSION680);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setOtherConfig(Map<String, String> otherConfig) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("other_config", "setOtherConfig", "6.8.0");
    super.setDataHandler(columndesc, otherConfig);
}
#method_after
public void setOtherConfig(Map<String, String> otherConfig) {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.OTHERCONFIG.columnName(), "setOtherConfig", VersionNum.VERSION680);
    super.setDataHandler(columndesc, otherConfig);
}
#end_block

#method_before
public Column getMaxBackoffColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("max_backoff", "getMaxBackoffColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getMaxBackoffColumn() {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.MAXBACKOFF.columnName(), "getMaxBackoffColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setMaxBackoff(Long maxBackoff) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("max_backoff", "setMaxBackoff", "1.0.0");
    super.setDataHandler(columndesc, maxBackoff);
}
#method_after
public void setMaxBackoff(Long maxBackoff) {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.MAXBACKOFF.columnName(), "setMaxBackoff", VersionNum.VERSION100);
    super.setDataHandler(columndesc, maxBackoff);
}
#end_block

#method_before
public Column getLocalIpColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("local_ip", "getLocalIpColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getLocalIpColumn() {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.LOCALIP.columnName(), "getLocalIpColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setLocalIp(Set<String> localIp) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("local_ip", "setLocalIp", "1.0.0");
    super.setDataHandler(columndesc, localIp);
}
#method_after
public void setLocalIp(Set<String> localIp) {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.LOCALIP.columnName(), "setLocalIp", VersionNum.VERSION100);
    super.setDataHandler(columndesc, localIp);
}
#end_block

#method_before
public Column getDiscoverUpdateResolvConfColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("discover_update_resolv_conf", "getDiscoverUpdateResolvConfColumn", "1.0.0", "3.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getDiscoverUpdateResolvConfColumn() {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.DISCOVERUPDATERESOLVCONF.columnName(), "getDiscoverUpdateResolvConfColumn", VersionNum.VERSION100, VersionNum.VERSION300);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setDiscoverUpdateResolvConf(Set<String> discoverUpdateResolvConf) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("discover_update_resolv_conf", "setDiscoverUpdateResolvConf", "1.0.0", "3.0.0");
    super.setDataHandler(columndesc, discoverUpdateResolvConf);
}
#method_after
public void setDiscoverUpdateResolvConf(Set<String> discoverUpdateResolvConf) {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.DISCOVERUPDATERESOLVCONF.columnName(), "setDiscoverUpdateResolvConf", VersionNum.VERSION100, VersionNum.VERSION300);
    super.setDataHandler(columndesc, discoverUpdateResolvConf);
}
#end_block

#method_before
public Column getDiscoverAcceptRegexColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("discover_accept_regex", "getDiscoverAcceptRegexColumn", "1.0.0", "3.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getDiscoverAcceptRegexColumn() {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.DISCOVERACCEPTREGEX.columnName(), "getDiscoverAcceptRegexColumn", VersionNum.VERSION100, VersionNum.VERSION300);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setDiscoverAcceptRegex(Set<String> discoverAcceptRegex) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("discover_accept_regex", "setDiscoverAcceptRegex", "1.0.0", "3.0.0");
    super.setDataHandler(columndesc, discoverAcceptRegex);
}
#method_after
public void setDiscoverAcceptRegex(Set<String> discoverAcceptRegex) {
    ColumnDescription columndesc = new ColumnDescription(ControllerColumn.DISCOVERACCEPTREGEX.columnName(), "setDiscoverAcceptRegex", VersionNum.VERSION100, VersionNum.VERSION300);
    super.setDataHandler(columndesc, discoverAcceptRegex);
}
#end_block

#method_before
public static Object jsonResultParser(JsonNode jsonNode, String methodName) throws NoSuchMethodException {
    ObjectMapper objectMapper = ObjectMapperUtil.getObjectMapper();
    JsonNode error = jsonNode.get("error");
    if (error != null && !error.isNull()) {
        log.error("Error : {}", error.toString());
    }
    JsonNode resultJsonNode = jsonNode.get("result");
    Object result = convertResultType(resultJsonNode, methodName, objectMapper);
    return result;
}
#method_after
public static Object jsonResultParser(JsonNode jsonNode, String methodName) {
    ObjectMapper objectMapper = ObjectMapperUtil.getObjectMapper();
    JsonNode error = jsonNode.get("error");
    if (error != null && !error.isNull()) {
        log.error("Error : {}", error.toString());
    }
    JsonNode resultJsonNode = jsonNode.get("result");
    Object result = convertResultType(resultJsonNode, methodName, objectMapper);
    return result;
}
#end_block

#method_before
private static String getRequestStr(String uuid, String methodName, List params) throws JsonProcessingException {
    JsonRpcRequest request;
    if (params != null) {
        request = new JsonRpcRequest(uuid, methodName, params);
    } else {
        request = new JsonRpcRequest(uuid, methodName);
    }
    String str = ObjectMapperUtil.convertToString(request);
    return str;
}
#method_after
private static String getRequestStr(String uuid, String methodName, List params) {
    JsonRpcRequest request;
    if (params != null) {
        request = new JsonRpcRequest(uuid, methodName, params);
    } else {
        request = new JsonRpcRequest(uuid, methodName);
    }
    String str = ObjectMapperUtil.convertToString(request);
    return str;
}
#end_block

#method_before
public static String getSchemaStr(String uuid, List<String> dbnames) throws Throwable {
    String methodName = "get_schema";
    return getRequestStr(uuid, methodName, dbnames);
}
#method_after
public static String getSchemaStr(String uuid, List<String> dbnames) {
    String methodName = "get_schema";
    return getRequestStr(uuid, methodName, dbnames);
}
#end_block

#method_before
public static String echoStr(String uuid) throws Throwable {
    String methodName = "echo";
    return getRequestStr(uuid, methodName, null);
}
#method_after
public static String echoStr(String uuid) {
    String methodName = "echo";
    return getRequestStr(uuid, methodName, null);
}
#end_block

#method_before
public static String monitorStr(String uuid, String monotorId, DatabaseSchema dbSchema) throws Throwable {
    String methodName = "monitor";
    return getRequestStr(uuid, methodName, ParamUtil.getMonitorParams(monotorId, dbSchema));
}
#method_after
public static String monitorStr(String uuid, String monotorId, DatabaseSchema dbSchema) {
    String methodName = "monitor";
    return getRequestStr(uuid, methodName, ParamUtil.getMonitorParams(monotorId, dbSchema));
}
#end_block

#method_before
public static String listDbsStr(String uuid) throws Throwable {
    String methodName = "list_dbs";
    return getRequestStr(uuid, methodName, null);
}
#method_after
public static String listDbsStr(String uuid) {
    String methodName = "list_dbs";
    return getRequestStr(uuid, methodName, null);
}
#end_block

#method_before
public static String transactStr(String uuid, DatabaseSchema dbSchema, List<Operation> operations) throws Throwable {
    String methodName = "transact";
    return getRequestStr(uuid, methodName, ParamUtil.getTransactParams(dbSchema, operations));
}
#method_after
public static String transactStr(String uuid, DatabaseSchema dbSchema, List<Operation> operations) {
    String methodName = "transact";
    return getRequestStr(uuid, methodName, ParamUtil.getTransactParams(dbSchema, operations));
}
#end_block

#method_before
public Column getBridgesColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("bridges", "getBridgesColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getBridgesColumn() {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.BRIDGES.columnName(), "getBridgesColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setBridges(Set<UUID> bridges) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("bridges", "setBridges", "1.0.0");
    super.setDataHandler(columndesc, bridges);
}
#method_after
public void setBridges(Set<UUID> bridges) {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.BRIDGES.columnName(), "setBridges", VersionNum.VERSION100);
    super.setDataHandler(columndesc, bridges);
}
#end_block

#method_before
public Column getManagersColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("managers", "getManagersColumn", "1.0.0", "2.0.0");
    return (Column) super.getDataHandler(columndesc);
}
#method_after
public Column getManagersColumn() {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.MANAGERS.columnName(), "getManagersColumn", VersionNum.VERSION100, VersionNum.VERSION200);
    return (Column) super.getDataHandler(columndesc);
}
#end_block

#method_before
public void setManagers(Set<UUID> managers) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("managers", "setManagers", "1.0.0", "2.0.0");
    super.setDataHandler(columndesc, managers);
}
#method_after
public void setManagers(Set<UUID> managers) {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.MANAGERS.columnName(), "setManagers", VersionNum.VERSION100, VersionNum.VERSION200);
    super.setDataHandler(columndesc, managers);
}
#end_block

#method_before
public Column getManagerOptionsColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("manager_options", "getManagerOptionsColumn", "1.0.0");
    return (Column) super.getDataHandler(columndesc);
}
#method_after
public Column getManagerOptionsColumn() {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.MANAGEROPTIONS.columnName(), "getManagerOptionsColumn", VersionNum.VERSION100);
    return (Column) super.getDataHandler(columndesc);
}
#end_block

#method_before
public void setManagerOptions(Set<UUID> managerOptions) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("manager_options", "setManagerOptions", "1.0.0");
    super.setDataHandler(columndesc, managerOptions);
}
#method_after
public void setManagerOptions(Set<UUID> managerOptions) {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.MANAGEROPTIONS.columnName(), "setManagerOptions", VersionNum.VERSION100);
    super.setDataHandler(columndesc, managerOptions);
}
#end_block

#method_before
public Column getSslColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("ssl", "getSslColumn", "1.0.0");
    return (Column) super.getDataHandler(columndesc);
}
#method_after
public Column getSslColumn() {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.SSL.columnName(), "getSslColumn", VersionNum.VERSION100);
    return (Column) super.getDataHandler(columndesc);
}
#end_block

#method_before
public void setSsl(Set<UUID> ssl) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("ssl", "setSsl", "1.0.0");
    super.setDataHandler(columndesc, ssl);
}
#method_after
public void setSsl(Set<UUID> ssl) {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.SSL.columnName(), "setSsl", VersionNum.VERSION100);
    super.setDataHandler(columndesc, ssl);
}
#end_block

#method_before
public Column getOtherConfigColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("other_config", "getOtherConfigColumn", "5.1.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getOtherConfigColumn() {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.OTHERCONFIG.columnName(), "getOtherConfigColumn", VersionNum.VERSION510);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setOtherConfig(Map<String, String> otherConfig) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("other_config", "setOtherConfig", "5.1.0");
    super.setDataHandler(columndesc, otherConfig);
}
#method_after
public void setOtherConfig(Map<String, String> otherConfig) {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.OTHERCONFIG.columnName(), "setOtherConfig", VersionNum.VERSION510);
    super.setDataHandler(columndesc, otherConfig);
}
#end_block

#method_before
public Column getExternalIdsColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("external_ids", "getExternalIdsColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getExternalIdsColumn() {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.EXTERNALIDS.columnName(), "getExternalIdsColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setExternalIds(Map<String, String> externalIds) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("external_ids", "setExternalIds", "1.0.0");
    super.setDataHandler(columndesc, externalIds);
}
#method_after
public void setExternalIds(Map<String, String> externalIds) {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.EXTERNALIDS.columnName(), "setExternalIds", VersionNum.VERSION100);
    super.setDataHandler(columndesc, externalIds);
}
#end_block

#method_before
public Column getNextConfigColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("next_cfg", "getNextConfigColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getNextConfigColumn() {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.NEXTCFG.columnName(), "getNextConfigColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setNextConfig(Long nextConfig) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("next_cfg", "setNextConfig", "1.0.0");
    super.setDataHandler(columndesc, nextConfig);
}
#method_after
public void setNextConfig(Long nextConfig) {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.NEXTCFG.columnName(), "setNextConfig", VersionNum.VERSION100);
    super.setDataHandler(columndesc, nextConfig);
}
#end_block

#method_before
public Column getCurrentConfigColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("cur_cfg", "getCurrentConfigColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getCurrentConfigColumn() {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.CURCFG.columnName(), "getCurrentConfigColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setCurrentConfig(Long currentConfig) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("cur_cfg", "setCurrentConfig", "1.0.0");
    super.setDataHandler(columndesc, currentConfig);
}
#method_after
public void setCurrentConfig(Long currentConfig) {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.CURCFG.columnName(), "setCurrentConfig", VersionNum.VERSION100);
    super.setDataHandler(columndesc, currentConfig);
}
#end_block

#method_before
public Column getCapabilitiesColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("capabilities", "getCapabilitiesColumn", "1.0.0", "6.7.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getCapabilitiesColumn() {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.CAPABILITIES.columnName(), "getCapabilitiesColumn", VersionNum.VERSION100, VersionNum.VERSION670);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setCapabilities(Map<String, UUID> capabilities) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("capabilities", "setCapabilities", "1.0.0", "6.7.0");
    super.setDataHandler(columndesc, capabilities);
}
#method_after
public void setCapabilities(Map<String, UUID> capabilities) {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.CAPABILITIES.columnName(), "setCapabilities", VersionNum.VERSION100, VersionNum.VERSION670);
    super.setDataHandler(columndesc, capabilities);
}
#end_block

#method_before
public Column getStatisticsColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("statistics", "getStatisticsColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getStatisticsColumn() {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.STATISTICS.columnName(), "getStatisticsColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setStatistics(Map<String, Long> statistics) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("statistics", "setStatistics", "1.0.0");
    super.setDataHandler(columndesc, statistics);
}
#method_after
public void setStatistics(Map<String, Long> statistics) {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.STATISTICS.columnName(), "setStatistics", VersionNum.VERSION100);
    super.setDataHandler(columndesc, statistics);
}
#end_block

#method_before
public Column getOvsVersionColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("ovs_version", "getOvsVersionColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getOvsVersionColumn() {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.OVSVERSION.columnName(), "getOvsVersionColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setOvsVersion(Set<String> ovsVersion) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("ovs_version", "setOvsVersion", "1.0.0");
    super.setDataHandler(columndesc, ovsVersion);
}
#method_after
public void setOvsVersion(Set<String> ovsVersion) {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.OVSVERSION.columnName(), "setOvsVersion", VersionNum.VERSION100);
    super.setDataHandler(columndesc, ovsVersion);
}
#end_block

#method_before
public Column getDbVersionColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("db_version", "getDbVersionColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getDbVersionColumn() {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.DBVERSION.columnName(), "getDbVersionColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setDbVersion(Set<String> dbVersion) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("db_version", "setDbVersion", "1.0.0");
    super.setDataHandler(columndesc, dbVersion);
}
#method_after
public void setDbVersion(Set<String> dbVersion) {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.DBVERSION.columnName(), "setDbVersion", VersionNum.VERSION100);
    super.setDataHandler(columndesc, dbVersion);
}
#end_block

#method_before
public Column getSystemTypeColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("system_type", "getSystemTypeColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getSystemTypeColumn() {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.SYSTEMTYPE.columnName(), "getSystemTypeColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setSystemType(Set<String> systemType) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("system_type", "setSystemType", "1.0.0");
    super.setDataHandler(columndesc, systemType);
}
#method_after
public void setSystemType(Set<String> systemType) {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.SYSTEMTYPE.columnName(), "setSystemType", VersionNum.VERSION100);
    super.setDataHandler(columndesc, systemType);
}
#end_block

#method_before
public Column getSystemVersionColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("system_version", "getSystemVersionColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getSystemVersionColumn() {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.SYSTEMVERSION.columnName(), "getSystemVersionColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setSystemVersion(Set<String> systemVersion) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("system_version", "setSystemVersion", "1.0.0");
    super.setDataHandler(columndesc, systemVersion);
}
#method_after
public void setSystemVersion(Set<String> systemVersion) {
    ColumnDescription columndesc = new ColumnDescription(OpenVSwitchColumn.SYSTEMVERSION.columnName(), "setSystemVersion", VersionNum.VERSION100);
    super.setDataHandler(columndesc, systemVersion);
}
#end_block

#method_before
public Column getNameColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("name", "getNameColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getNameColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.NAME.columnName(), "getNameColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setName(String name) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("name", "setName", "1.0.0");
    super.setDataHandler(columndesc, name);
}
#method_after
public void setName(String name) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.NAME.columnName(), "setName", VersionNum.VERSION100);
    super.setDataHandler(columndesc, name);
}
#end_block

#method_before
public String getName() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("name", "getName", "1.0.0");
    return (String) super.getDataHandler(columndesc);
}
#method_after
public String getName() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.NAME.columnName(), "getName", VersionNum.VERSION100);
    return (String) super.getDataHandler(columndesc);
}
#end_block

#method_before
public Column getTypeColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("type", "getTypeColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getTypeColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.TYPE.columnName(), "getTypeColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setType(String type) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("type", "setType", "1.0.0");
    super.setDataHandler(columndesc, type);
}
#method_after
public void setType(String type) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.TYPE.columnName(), "setType", VersionNum.VERSION100);
    super.setDataHandler(columndesc, type);
}
#end_block

#method_before
public Column getOptionsColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("options", "getOptionsColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getOptionsColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.OPTIONS.columnName(), "getOptionsColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setOptions(Map<String, String> options) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("options", "setOptions", "1.0.0");
    super.setDataHandler(columndesc, options);
}
#method_after
public void setOptions(Map<String, String> options) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.OPTIONS.columnName(), "setOptions", VersionNum.VERSION100);
    super.setDataHandler(columndesc, options);
}
#end_block

#method_before
public Column getIngressPolicingRateColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("ingress_policing_rate", "getIngressPolicingRateColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getIngressPolicingRateColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.INGRESSPOLICINGRATE.columnName(), "getIngressPolicingRateColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setIngressPolicingRate(Set<Long> ingressPolicingRate) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("ingress_policing_rate", "setIngressPolicingRate", "1.0.0");
    super.setDataHandler(columndesc, ingressPolicingRate);
}
#method_after
public void setIngressPolicingRate(Set<Long> ingressPolicingRate) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.INGRESSPOLICINGRATE.columnName(), "setIngressPolicingRate", VersionNum.VERSION100);
    super.setDataHandler(columndesc, ingressPolicingRate);
}
#end_block

#method_before
public Column getIngressPolicingBurstColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("ingress_policing_burst", "getIngressPolicingBurstColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getIngressPolicingBurstColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.INGRESSPOLICINGBURST.columnName(), "getIngressPolicingBurstColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setIngressPolicingBurst(Set<Long> ingressPolicingBurst) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("ingress_policing_burst", "setIngressPolicingBurst", "1.0.0");
    super.setDataHandler(columndesc, ingressPolicingBurst);
}
#method_after
public void setIngressPolicingBurst(Set<Long> ingressPolicingBurst) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.INGRESSPOLICINGBURST.columnName(), "setIngressPolicingBurst", VersionNum.VERSION100);
    super.setDataHandler(columndesc, ingressPolicingBurst);
}
#end_block

#method_before
public Column getMacInUseColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("mac_in_use", "getMacInUseColumn", "7.1.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getMacInUseColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.MACINUSE.columnName(), "getMacInUseColumn", VersionNum.VERSION710);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setMacInUse(Set<String> macInUse) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("mac_in_use", "setMacInUse", "7.1.0");
    super.setDataHandler(columndesc, macInUse);
}
#method_after
public void setMacInUse(Set<String> macInUse) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.MACINUSE.columnName(), "setMacInUse", VersionNum.VERSION710);
    super.setDataHandler(columndesc, macInUse);
}
#end_block

#method_before
public Column getMacColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("mac", "getMacColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getMacColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.MAC.columnName(), "getMacColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setMac(Set<String> mac) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("mac", "setMac", "1.0.0");
    super.setDataHandler(columndesc, mac);
}
#method_after
public void setMac(Set<String> mac) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.MAC.columnName(), "setMac", VersionNum.VERSION100);
    super.setDataHandler(columndesc, mac);
}
#end_block

#method_before
public Column getIfIndexColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("ifindex", "getIfIndexColumn", "7.2.1");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getIfIndexColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.IFINDEX.columnName(), "getIfIndexColumn", VersionNum.VERSION721);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setIfIndex(Long ifIndex) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("ifindex", "setIfIndex", "7.2.1");
    super.setDataHandler(columndesc, ifIndex);
}
#method_after
public void setIfIndex(Long ifIndex) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.IFINDEX.columnName(), "setIfIndex", VersionNum.VERSION721);
    super.setDataHandler(columndesc, ifIndex);
}
#end_block

#method_before
public Column getExternalIdsColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("external_ids", "getExternalIdsColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getExternalIdsColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.EXTERNALIDS.columnName(), "getExternalIdsColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setExternalIds(Map<String, String> externalIds) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("external_ids", "setExternalIds", "1.0.0");
    super.setDataHandler(columndesc, externalIds);
}
#method_after
public void setExternalIds(Map<String, String> externalIds) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.EXTERNALIDS.columnName(), "setExternalIds", VersionNum.VERSION100);
    super.setDataHandler(columndesc, externalIds);
}
#end_block

#method_before
public Column getOpenFlowPortColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("ofport", "getOpenFlowPortColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getOpenFlowPortColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.OFPORT.columnName(), "getOpenFlowPortColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setOpenFlowPort(Set<Long> openFlowPort) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("ofport", "setOpenFlowPort", "1.0.0");
    super.setDataHandler(columndesc, openFlowPort);
}
#method_after
public void setOpenFlowPort(Set<Long> openFlowPort) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.OFPORT.columnName(), "setOpenFlowPort", VersionNum.VERSION100);
    super.setDataHandler(columndesc, openFlowPort);
}
#end_block

#method_before
public Column getOpenFlowPortRequestColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("ofport_request", "getOpenFlowPortRequestColumn", "6.2.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getOpenFlowPortRequestColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.OFPORTREQUEST.columnName(), "getOpenFlowPortRequestColumn", VersionNum.VERSION620);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setOpenFlowPortRequest(String openFlowPortRequest) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("ofport_request", "setOpenFlowPortRequest", "6.2.0");
    super.setDataHandler(columndesc, openFlowPortRequest);
}
#method_after
public void setOpenFlowPortRequest(String openFlowPortRequest) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.OFPORTREQUEST.columnName(), "setOpenFlowPortRequest", VersionNum.VERSION620);
    super.setDataHandler(columndesc, openFlowPortRequest);
}
#end_block

#method_before
public Column getBfdColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("bfd", "getBfdColumn", "7.2.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getBfdColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.BFD.columnName(), "getBfdColumn", VersionNum.VERSION720);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setBfd(Map<String, String> bfd) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("bfd", "setBfd", "7.2.0");
    super.setDataHandler(columndesc, bfd);
}
#method_after
public void setBfd(Map<String, String> bfd) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.BFD.columnName(), "setBfd", VersionNum.VERSION720);
    super.setDataHandler(columndesc, bfd);
}
#end_block

#method_before
public Column getBfdStatusColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("bfd_status", "getBfdStatusColumn", "7.2.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getBfdStatusColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.BFDSTATUS.columnName(), "getBfdStatusColumn", VersionNum.VERSION720);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setBfdStatus(Map<String, String> bfdStatus) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("bfd_status", "setBfdStatus", "7.2.0");
    super.setDataHandler(columndesc, bfdStatus);
}
#method_after
public void setBfdStatus(Map<String, String> bfdStatus) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.BFDSTATUS.columnName(), "setBfdStatus", VersionNum.VERSION720);
    super.setDataHandler(columndesc, bfdStatus);
}
#end_block

#method_before
public Column getMonitorColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("monitor", "getMonitorColumn", "1.0.0", "3.5.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getMonitorColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.MONITOR.columnName(), "getMonitorColumn", VersionNum.VERSION100, VersionNum.VERSION350);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setMonitor(String monitor) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("monitor", "setMonitor", "1.0.0", "3.5.0");
    super.setDataHandler(columndesc, monitor);
}
#method_after
public void setMonitor(String monitor) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.MONITOR.columnName(), "setMonitor", VersionNum.VERSION100, VersionNum.VERSION350);
    super.setDataHandler(columndesc, monitor);
}
#end_block

#method_before
public Column getCfmMpidColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("cfm_mpid", "getCfmMpidColumn", "4.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getCfmMpidColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.CFMMPID.columnName(), "getCfmMpidColumn", VersionNum.VERSION400);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setCfmMpid(Set<Long> cfmMpid) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("cfm_mpid", "setCfmMpid", "4.0.0");
    super.setDataHandler(columndesc, cfmMpid);
}
#method_after
public void setCfmMpid(Set<Long> cfmMpid) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.CFMMPID.columnName(), "setCfmMpid", VersionNum.VERSION400);
    super.setDataHandler(columndesc, cfmMpid);
}
#end_block

#method_before
public Column getCfmRemoteMpidColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("cfm_remote_mpid", "getCfmRemoteMpidColumn", "4.0.0", "5.2.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getCfmRemoteMpidColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.CFMREMOTEMPID.columnName(), "getCfmRemoteMpidColumn", VersionNum.VERSION400, VersionNum.VERSION520);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setCfmRemoteMpid(Set<Long> cfmRemoteMpid) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("cfm_remote_mpid", "setCfmRemoteMpid", "4.0.0", "5.2.0");
    super.setDataHandler(columndesc, cfmRemoteMpid);
}
#method_after
public void setCfmRemoteMpid(Set<Long> cfmRemoteMpid) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.CFMREMOTEMPID.columnName(), "setCfmRemoteMpid", VersionNum.VERSION400, VersionNum.VERSION520);
    super.setDataHandler(columndesc, cfmRemoteMpid);
}
#end_block

#method_before
public Column getCfmRemoteMpidsColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("cfm_remote_mpids", "getCfmRemoteMpidsColumn", "6.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getCfmRemoteMpidsColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.CFMREMOTEMPIDS.columnName(), "getCfmRemoteMpidsColumn", VersionNum.VERSION600);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setCfmRemoteMpids(Set<Long> cfmRemoteMpids) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("cfm_remote_mpids", "setCfmRemoteMpids", "6.0.0");
    super.setDataHandler(columndesc, cfmRemoteMpids);
}
#method_after
public void setCfmRemoteMpids(Set<Long> cfmRemoteMpids) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.CFMREMOTEMPIDS.columnName(), "setCfmRemoteMpids", VersionNum.VERSION600);
    super.setDataHandler(columndesc, cfmRemoteMpids);
}
#end_block

#method_before
public Column getCfmFlapCountColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("cfm_flap_count", "getCfmFlapCountColumn", "7.3.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getCfmFlapCountColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.CFMFLAPCOUNT.columnName(), "getCfmFlapCountColumn", VersionNum.VERSION730);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setCfmFlapCount(Set<Long> cfmFlapCount) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("cfm_flap_count", "setCfmFlapCount", "7.3.0");
    super.setDataHandler(columndesc, cfmFlapCount);
}
#method_after
public void setCfmFlapCount(Set<Long> cfmFlapCount) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.CFMFLAPCOUNT.columnName(), "setCfmFlapCount", VersionNum.VERSION730);
    super.setDataHandler(columndesc, cfmFlapCount);
}
#end_block

#method_before
public Column getCfmFaultColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("cfm_fault", "getCfmFaultColumn", "4.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getCfmFaultColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.CFMFAULT.columnName(), "getCfmFaultColumn", VersionNum.VERSION400);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setCfmFault(Set<Boolean> cfmFault) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("cfm_fault", "setCfmFault", "4.0.0");
    super.setDataHandler(columndesc, cfmFault);
}
#method_after
public void setCfmFault(Set<Boolean> cfmFault) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.CFMFAULT.columnName(), "setCfmFault", VersionNum.VERSION400);
    super.setDataHandler(columndesc, cfmFault);
}
#end_block

#method_before
public Column getCfmFaultStatusColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("cfm_fault_status", "getCfmFaultStatusColumn", "6.6.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getCfmFaultStatusColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.CFMFAULTSTATUS.columnName(), "getCfmFaultStatusColumn", VersionNum.VERSION660);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setCfmFaultStatus(Set<String> cfmFaultStatus) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("cfm_fault_status", "setCfmFaultStatus", "6.6.0");
    super.setDataHandler(columndesc, cfmFaultStatus);
}
#method_after
public void setCfmFaultStatus(Set<String> cfmFaultStatus) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.CFMFAULTSTATUS.columnName(), "setCfmFaultStatus", VersionNum.VERSION660);
    super.setDataHandler(columndesc, cfmFaultStatus);
}
#end_block

#method_before
public Column getCfmRemoteOpStateColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("cfm_remote_opstate", "getCfmRemoteOpStateColumn", "6.10.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getCfmRemoteOpStateColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.CFMREMOTEOPSTATE.columnName(), "getCfmRemoteOpStateColumn", VersionNum.VERSION6100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setCfmRemoteOpState(Set<String> cfmRemoteOpState) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("cfm_remote_opstate", "setCfmRemoteOpState", "6.10.0");
    super.setDataHandler(columndesc, cfmRemoteOpState);
}
#method_after
public void setCfmRemoteOpState(Set<String> cfmRemoteOpState) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.CFMREMOTEOPSTATE.columnName(), "setCfmRemoteOpState", VersionNum.VERSION6100);
    super.setDataHandler(columndesc, cfmRemoteOpState);
}
#end_block

#method_before
public Column getCfmHealthColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("cfm_health", "getCfmHealthColumn", "6.9.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getCfmHealthColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.CFMHEALTH.columnName(), "getCfmHealthColumn", VersionNum.VERSION690);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setCfmHealth(Set<Long> cfmHealth) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("cfmHealth", "setCfmHealth", "6.9.0");
    super.setDataHandler(columndesc, cfmHealth);
}
#method_after
public void setCfmHealth(Set<Long> cfmHealth) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.CFMHEALTH.columnName(), "setCfmHealth", VersionNum.VERSION690);
    super.setDataHandler(columndesc, cfmHealth);
}
#end_block

#method_before
public Column getLacpCurrentColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("lacp_current", "getLacpCurrentColumn", "3.3.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getLacpCurrentColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.LACPCURRENT.columnName(), "getLacpCurrentColumn", VersionNum.VERSION330);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setLacpCurrent(Set<Boolean> lacpCurrent) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("lacp_current", "setLacpCurrent", "3.3.0");
    super.setDataHandler(columndesc, lacpCurrent);
}
#method_after
public void setLacpCurrent(Set<Boolean> lacpCurrent) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.LACPCURRENT.columnName(), "setLacpCurrent", VersionNum.VERSION330);
    super.setDataHandler(columndesc, lacpCurrent);
}
#end_block

#method_before
public Column getOtherConfigColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("other_config", "getOtherConfigColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getOtherConfigColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.OTHERCONFIG.columnName(), "getOtherConfigColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setOtherConfig(Map<String, String> otherConfig) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("other_config", "setOtherConfig", "1.0.0");
    super.setDataHandler(columndesc, otherConfig);
}
#method_after
public void setOtherConfig(Map<String, String> otherConfig) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.OTHERCONFIG.columnName(), "setOtherConfig", VersionNum.VERSION100);
    super.setDataHandler(columndesc, otherConfig);
}
#end_block

#method_before
public Column getStatisticsColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("statistics", "getStatisticsColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getStatisticsColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.STATISTICS.columnName(), "getStatisticsColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setStatistics(Map<String, Long> statistics) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("statistics", "setStatistics", "1.0.0");
    super.setDataHandler(columndesc, statistics);
}
#method_after
public void setStatistics(Map<String, Long> statistics) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.STATISTICS.columnName(), "setStatistics", VersionNum.VERSION100);
    super.setDataHandler(columndesc, statistics);
}
#end_block

#method_before
public Column getStatusColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("status", "getStatusColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getStatusColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.STATUS.columnName(), "getStatusColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setStatus(Map<String, String> status) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("status", "setStatus", "1.0.0");
    super.setDataHandler(columndesc, status);
}
#method_after
public void setStatus(Map<String, String> status) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.STATUS.columnName(), "setStatus", VersionNum.VERSION100);
    super.setDataHandler(columndesc, status);
}
#end_block

#method_before
public Column getAdminStateColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("admin_state", "getAdminStateColumn", "1.0.6");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getAdminStateColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.ADMINSTATE.columnName(), "getAdminStateColumn", VersionNum.VERSION106);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setAdminState(Set<String> adminState) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("admin_state", "setAdminState", "1.0.6");
    super.setDataHandler(columndesc, adminState);
}
#method_after
public void setAdminState(Set<String> adminState) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.ADMINSTATE.columnName(), "setAdminState", VersionNum.VERSION106);
    super.setDataHandler(columndesc, adminState);
}
#end_block

#method_before
public Column getLinkStateColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("link_state", "getLinkStateColumn", "1.0.6");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getLinkStateColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.LINKSTATE.columnName(), "getLinkStateColumn", VersionNum.VERSION106);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setLinkState(Map<String, String> linkState) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("link_state", "setLinkState", "1.0.6");
    super.setDataHandler(columndesc, linkState);
}
#method_after
public void setLinkState(Map<String, String> linkState) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.LINKSTATE.columnName(), "setLinkState", VersionNum.VERSION106);
    super.setDataHandler(columndesc, linkState);
}
#end_block

#method_before
public Column getLinkResetsColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("link_resets", "getLinkResetsColumn", "6.2.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getLinkResetsColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.LINKRESETS.columnName(), "getLinkResetsColumn", VersionNum.VERSION620);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setLinkResets(Set<String> linkResets) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("link_resets", "setLinkResets", "6.2.0");
    super.setDataHandler(columndesc, linkResets);
}
#method_after
public void setLinkResets(Set<String> linkResets) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.LINKRESETS.columnName(), "setLinkResets", VersionNum.VERSION620);
    super.setDataHandler(columndesc, linkResets);
}
#end_block

#method_before
public Column getLinkSpeedColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("link_speed", "getLinkSpeedColumn", "1.0.6");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getLinkSpeedColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.LINKSPEED.columnName(), "getLinkSpeedColumn", VersionNum.VERSION106);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setLinkSpeed(Set<Long> linkSpeed) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("link_speed", "setLinkSpeed", "1.0.6");
    super.setDataHandler(columndesc, linkSpeed);
}
#method_after
public void setLinkSpeed(Set<Long> linkSpeed) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.LINKSPEED.columnName(), "setLinkSpeed", VersionNum.VERSION106);
    super.setDataHandler(columndesc, linkSpeed);
}
#end_block

#method_before
public Column getDuplexColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("duplex", "getDuplexColumn", "1.0.6");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getDuplexColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.DUPLEX.columnName(), "getDuplexColumn", VersionNum.VERSION106);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setDuplex(Set<Long> duplex) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("duplex", "setDuplex", "1.0.6");
    super.setDataHandler(columndesc, duplex);
}
#method_after
public void setDuplex(Set<Long> duplex) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.DUPLEX.columnName(), "setDuplex", VersionNum.VERSION106);
    super.setDataHandler(columndesc, duplex);
}
#end_block

#method_before
public Column getMtuColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("mtu", "getMtuColumn", "1.0.6");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getMtuColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.MTU.columnName(), "getMtuColumn", VersionNum.VERSION106);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setMtu(Set<Long> mtu) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("mtu", "setMtu", "1.0.6");
    super.setDataHandler(columndesc, mtu);
}
#method_after
public void setMtu(Set<Long> mtu) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.MTU.columnName(), "setMtu", VersionNum.VERSION106);
    super.setDataHandler(columndesc, mtu);
}
#end_block

#method_before
public Column getErrorColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("error", "getErrorColumn", "7.7.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getErrorColumn() {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.ERROR.columnName(), "getErrorColumn", VersionNum.VERSION770);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setError(Set<String> error) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("error", "setError", "7.7.0");
    super.setDataHandler(columndesc, error);
}
#method_after
public void setError(Set<String> error) {
    ColumnDescription columndesc = new ColumnDescription(InterfaceColumn.ERROR.columnName(), "setError", VersionNum.VERSION770);
    super.setDataHandler(columndesc, error);
}
#end_block

#method_before
public Column getNameColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("name", "getNameColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getNameColumn() {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.NAME.columnName(), "getNameColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setName(String name) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("name", "setName", "1.0.0");
    super.setDataHandler(columndesc, name);
}
#method_after
public void setName(String name) {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.NAME.columnName(), "setName", VersionNum.VERSION100);
    super.setDataHandler(columndesc, name);
}
#end_block

#method_before
public String getName() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("name", "getName", "1.0.0");
    return (String) super.getDataHandler(columndesc);
}
#method_after
public String getName() {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.NAME.columnName(), "getName", VersionNum.VERSION100);
    return (String) super.getDataHandler(columndesc);
}
#end_block

#method_before
public Column getDatapathTypeColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("datapath_type", "getDatapathTypeColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getDatapathTypeColumn() {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.DATAPATHTYPE.columnName(), "getDatapathTypeColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setDatapathType(String datapathType) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("datapath_type", "setDatapathType", "1.0.0");
    super.setDataHandler(columndesc, datapathType);
}
#method_after
public void setDatapathType(String datapathType) {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.DATAPATHTYPE.columnName(), "setDatapathType", VersionNum.VERSION100);
    super.setDataHandler(columndesc, datapathType);
}
#end_block

#method_before
public Column getDatapathIdColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("datapath_id", "getDatapathIdColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getDatapathIdColumn() {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.DATAPATHID.columnName(), "getDatapathIdColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setDatapathId(Set<String> datapathId) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("datapath_id", "setDatapathId", "1.0.0");
    super.setDataHandler(columndesc, datapathId);
}
#method_after
public void setDatapathId(Set<String> datapathId) {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.DATAPATHID.columnName(), "setDatapathId", VersionNum.VERSION100);
    super.setDataHandler(columndesc, datapathId);
}
#end_block

#method_before
public Column getStpEnableColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("stpenable", "getStpEnableColumn", "6.2.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getStpEnableColumn() {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.STPENABLE.columnName(), "getStpEnableColumn", VersionNum.VERSION620);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setStpEnable(Boolean stpenable) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("stpenable", "setStpEnable", "6.2.0");
    super.setDataHandler(columndesc, stpenable);
}
#method_after
public void setStpEnable(Boolean stpenable) {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.STPENABLE.columnName(), "setStpEnable", VersionNum.VERSION620);
    super.setDataHandler(columndesc, stpenable);
}
#end_block

#method_before
public Column getPortsColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("ports", "getPortsColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getPortsColumn() {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.PORTS.columnName(), "getPortsColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setPorts(Set<UUID> ports) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("ports", "setPorts", "1.0.0");
    super.setDataHandler(columndesc, ports);
}
#method_after
public void setPorts(Set<UUID> ports) {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.PORTS.columnName(), "setPorts", VersionNum.VERSION100);
    super.setDataHandler(columndesc, ports);
}
#end_block

#method_before
public Column getMirrorsColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("mirrors", "getMirrorsColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getMirrorsColumn() {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.MIRRORS.columnName(), "getMirrorsColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setMirrors(Set<UUID> mirrors) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("mirrors", "setMirrors", "1.0.0");
    super.setDataHandler(columndesc, mirrors);
}
#method_after
public void setMirrors(Set<UUID> mirrors) {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.MIRRORS.columnName(), "setMirrors", VersionNum.VERSION100);
    super.setDataHandler(columndesc, mirrors);
}
#end_block

#method_before
public Column getNetflowColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("netflow", "getNetflowColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getNetflowColumn() {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.NETFLOW.columnName(), "getNetflowColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setNetflow(Set<UUID> netflow) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("netflow", "setNetflow", "1.0.0");
    super.setDataHandler(columndesc, netflow);
}
#method_after
public void setNetflow(Set<UUID> netflow) {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.NETFLOW.columnName(), "setNetflow", VersionNum.VERSION100);
    super.setDataHandler(columndesc, netflow);
}
#end_block

#method_before
public Column getSflowColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("sflow", "getSflowColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getSflowColumn() {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.SFLOW.columnName(), "getSflowColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setSflow(Set<UUID> sflow) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("sflow", "setSflow", "1.0.0");
    super.setDataHandler(columndesc, sflow);
}
#method_after
public void setSflow(Set<UUID> sflow) {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.SFLOW.columnName(), "setSflow", VersionNum.VERSION100);
    super.setDataHandler(columndesc, sflow);
}
#end_block

#method_before
public Column getIpfixColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("ipfix", "getIpfixColumn", "7.1.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getIpfixColumn() {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.IPFIX.columnName(), "getIpfixColumn", VersionNum.VERSION710);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setIpfix(Set<UUID> ipfix) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("ipfix", "setIpfix", "7.1.0");
    super.setDataHandler(columndesc, ipfix);
}
#method_after
public void setIpfix(Set<UUID> ipfix) {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.IPFIX.columnName(), "setIpfix", VersionNum.VERSION710);
    super.setDataHandler(columndesc, ipfix);
}
#end_block

#method_before
public Column getControllerColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("controller", "getControllerColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getControllerColumn() {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.CONTROLLER.columnName(), "getControllerColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setController(Set<UUID> controller) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("controller", "setController", "1.0.0");
    super.setDataHandler(columndesc, controller);
}
#method_after
public void setController(Set<UUID> controller) {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.CONTROLLER.columnName(), "setController", VersionNum.VERSION100);
    super.setDataHandler(columndesc, controller);
}
#end_block

#method_before
public Column getProtocolsColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("protocols", "getProtocolsColumn", "6.11.1");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getProtocolsColumn() {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.PROTOCOLS.columnName(), "getProtocolsColumn", VersionNum.VERSION6111);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setProtocols(Set<String> protocols) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("protocols", "setProtocols", "6.11.1");
    super.setDataHandler(columndesc, protocols);
}
#method_after
public void setProtocols(Set<String> protocols) {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.PROTOCOLS.columnName(), "setProtocols", VersionNum.VERSION6111);
    super.setDataHandler(columndesc, protocols);
}
#end_block

#method_before
public Column getFailModeColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("fail_mode", "getFailModeColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getFailModeColumn() {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.FAILMODE.columnName(), "getFailModeColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setFailMode(Set<String> failMode) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("fail_mode", "setFailMode", "1.0.0");
    super.setDataHandler(columndesc, failMode);
}
#method_after
public void setFailMode(Set<String> failMode) {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.FAILMODE.columnName(), "setFailMode", VersionNum.VERSION100);
    super.setDataHandler(columndesc, failMode);
}
#end_block

#method_before
public Column getStatusColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("status", "getStatusColumn", "6.2.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getStatusColumn() {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.STATUS.columnName(), "getStatusColumn", VersionNum.VERSION620);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setStatus(Map<String, String> status) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("status", "setStatus", "6.2.0");
    super.setDataHandler(columndesc, status);
}
#method_after
public void setStatus(Map<String, String> status) {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.STATUS.columnName(), "setStatus", VersionNum.VERSION620);
    super.setDataHandler(columndesc, status);
}
#end_block

#method_before
public Column getOtherConfigColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("other_config", "getOtherConfigColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getOtherConfigColumn() {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.OTHERCONFIG.columnName(), "getOtherConfigColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setOtherConfig(Map<String, String> otherConfig) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("other_config", "setOtherConfig", "1.0.0");
    super.setDataHandler(columndesc, otherConfig);
}
#method_after
public void setOtherConfig(Map<String, String> otherConfig) {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.OTHERCONFIG.columnName(), "setOtherConfig", VersionNum.VERSION100);
    super.setDataHandler(columndesc, otherConfig);
}
#end_block

#method_before
public Column getExternalIdsColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("external_ids", "getExternalIdsColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getExternalIdsColumn() {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.EXTERNALIDS.columnName(), "getExternalIdsColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setExternalIds(Map<String, String> externalIds) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("external_ids", "setExternalIds", "1.0.0");
    super.setDataHandler(columndesc, externalIds);
}
#method_after
public void setExternalIds(Map<String, String> externalIds) {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.EXTERNALIDS.columnName(), "setExternalIds", VersionNum.VERSION100);
    super.setDataHandler(columndesc, externalIds);
}
#end_block

#method_before
public Column getFloodVlansColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("flood_vlans", "getFloodVlansColumn", "1.0.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getFloodVlansColumn() {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.FLOODVLANS.columnName(), "getFloodVlansColumn", VersionNum.VERSION100);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setFloodVlans(Set<Long> vlans) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("flood_vlans", "setFloodVlans", "1.0.0");
    super.setDataHandler(columndesc, vlans);
}
#method_after
public void setFloodVlans(Set<Long> vlans) {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.FLOODVLANS.columnName(), "setFloodVlans", VersionNum.VERSION100);
    super.setDataHandler(columndesc, vlans);
}
#end_block

#method_before
public Column getFlowTablesColumn() throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("flow_tables", "getFlowTablesColumn", "6.5.0");
    return (Column) super.getColumnHandler(columndesc);
}
#method_after
public Column getFlowTablesColumn() {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.FLOWTABLES.columnName(), "getFlowTablesColumn", VersionNum.VERSION650);
    return (Column) super.getColumnHandler(columndesc);
}
#end_block

#method_before
public void setFlowTables(Map<Long, UUID> flowTables) throws Throwable {
    ColumnDescription columndesc = new ColumnDescription("flow_tables", "setFlowTables", "6.5.0");
    super.setDataHandler(columndesc, flowTables);
}
#method_after
public void setFlowTables(Map<Long, UUID> flowTables) {
    ColumnDescription columndesc = new ColumnDescription(BridgeColumn.FLOWTABLES.columnName(), "setFlowTables", VersionNum.VERSION650);
    super.setDataHandler(columndesc, flowTables);
}
#end_block

#method_before
public static void readToJsonNode(ByteBuf in, List<Object> out, JsonReadContext jrContext) throws Exception {
    int lastReadBytes = jrContext.getLastReadBytes();
    if (lastReadBytes == 0) {
        if (in.readableBytes() < 4) {
            return;
        }
        checkEncoding(in);
    }
    int i = lastReadBytes + in.readerIndex();
    Stack<Byte> bufStack = jrContext.getBufStack();
    for (; i < in.writerIndex(); i++) {
        byte b = in.getByte(i);
        switch(b) {
            case '{':
                if (!isDoubleQuote(bufStack)) {
                    bufStack.push(b);
                    jrContext.setStartMatch(true);
                }
                break;
            case '}':
                if (!isDoubleQuote(bufStack)) {
                    bufStack.pop();
                }
                break;
            case '"':
                if (in.getByte(i - 1) != '\\') {
                    if (!bufStack.isEmpty() && bufStack.peek() != '"') {
                        bufStack.push(b);
                    } else {
                        bufStack.pop();
                    }
                }
                break;
            default:
                break;
        }
        if (jrContext.isStartMatch() && bufStack.isEmpty()) {
            ByteBuf buf = in.readSlice(i - in.readerIndex() + 1);
            JsonParser jf = new MappingJsonFactory().createParser(new ByteBufInputStream(buf));
            JsonNode jsonNode = jf.readValueAsTree();
            out.add(jsonNode);
            lastReadBytes = 0;
            jrContext.setLastReadBytes(lastReadBytes);
            break;
        }
    }
    if (i >= in.writerIndex()) {
        lastReadBytes = in.readableBytes();
        jrContext.setLastReadBytes(lastReadBytes);
    }
}
#method_after
public static void readToJsonNode(ByteBuf in, List<Object> out, JsonReadContext jrContext) throws JsonParseException, IOException {
    int lastReadBytes = jrContext.getLastReadBytes();
    if (lastReadBytes == 0) {
        if (in.readableBytes() < 4) {
            return;
        }
        checkEncoding(in);
    }
    int i = lastReadBytes + in.readerIndex();
    Stack<Byte> bufStack = jrContext.getBufStack();
    for (; i < in.writerIndex(); i++) {
        byte b = in.getByte(i);
        switch(b) {
            case '{':
                if (!isDoubleQuote(bufStack)) {
                    bufStack.push(b);
                    jrContext.setStartMatch(true);
                }
                break;
            case '}':
                if (!isDoubleQuote(bufStack)) {
                    bufStack.pop();
                }
                break;
            case '"':
                if (in.getByte(i - 1) != '\\') {
                    if (!bufStack.isEmpty() && bufStack.peek() != '"') {
                        bufStack.push(b);
                    } else {
                        bufStack.pop();
                    }
                }
                break;
            default:
                break;
        }
        if (jrContext.isStartMatch() && bufStack.isEmpty()) {
            ByteBuf buf = in.readSlice(i - in.readerIndex() + 1);
            JsonParser jf = new MappingJsonFactory().createParser(new ByteBufInputStream(buf));
            JsonNode jsonNode = jf.readValueAsTree();
            out.add(jsonNode);
            lastReadBytes = 0;
            jrContext.setLastReadBytes(lastReadBytes);
            break;
        }
    }
    if (i >= in.writerIndex()) {
        lastReadBytes = in.readableBytes();
        jrContext.setLastReadBytes(lastReadBytes);
    }
}
#end_block

#method_before
private static void checkEncoding(ByteBuf in) throws IOException {
    fliterCharaters(in);
    byte[] buff = new byte[4];
    in.getBytes(in.readerIndex(), buff);
    ByteSourceJsonBootstrapper strapper = new ByteSourceJsonBootstrapper(new IOContext(new BufferRecycler(), null, false), buff, 0, 4);
    JsonEncoding jsonEncoding = strapper.detectEncoding();
    if (!JsonEncoding.UTF8.equals(jsonEncoding)) {
        throw new UnsupportedEncodingException("Only UTF-8 encoding is supported.");
    }
}
#method_after
private static void checkEncoding(ByteBuf in) throws IOException {
    int inputStart = 0;
    int inputLength = 4;
    fliterCharaters(in);
    byte[] buff = new byte[4];
    in.getBytes(in.readerIndex(), buff);
    ByteSourceJsonBootstrapper strapper = new ByteSourceJsonBootstrapper(new IOContext(new BufferRecycler(), null, false), buff, inputStart, inputLength);
    JsonEncoding jsonEncoding = strapper.detectEncoding();
    if (!JsonEncoding.UTF8.equals(jsonEncoding)) {
        throw new UnsupportedEncodingException("Only UTF-8 encoding is supported.");
    }
}
#end_block

#method_before
private boolean isValid() {
    if (dbSchema == null) {
        return false;
    }
    if (!dbSchema.name().equalsIgnoreCase(tabledesc.database())) {
        return false;
    }
    checkTableSchemaVersion();
    return true;
}
#method_after
private boolean isValid() {
    if (dbSchema == null) {
        return false;
    }
    if (!dbSchema.name().equalsIgnoreCase(tableDesc.database())) {
        return false;
    }
    checkTableSchemaVersion();
    return true;
}
#end_block

#method_before
private void checkTableSchemaVersion() {
    String fromVersion = tabledesc.fromVersion();
    String untilVersion = tabledesc.untilVersion();
    String schemaVersion = dbSchema.version();
    checkVersion(schemaVersion, fromVersion, untilVersion);
}
#method_after
private void checkTableSchemaVersion() {
    String fromVersion = tableDesc.fromVersion();
    String untilVersion = tableDesc.untilVersion();
    String schemaVersion = dbSchema.version();
    checkVersion(schemaVersion, fromVersion, untilVersion);
}
#end_block

#method_before
private void checkColumnSchemaVersion(ColumnDescription columndesc) {
    String fromVersion = columndesc.fromVersion();
    String untilVersion = columndesc.untilVersion();
    String schemaVersion = dbSchema.version();
    checkVersion(schemaVersion, fromVersion, untilVersion);
}
#method_after
private void checkColumnSchemaVersion(ColumnDescription columnDesc) {
    String fromVersion = columnDesc.fromVersion();
    String untilVersion = columnDesc.untilVersion();
    String schemaVersion = dbSchema.version();
    checkVersion(schemaVersion, fromVersion, untilVersion);
}
#end_block

#method_before
private TableSchema getTableSchema() {
    String tableName = tabledesc.name();
    return dbSchema.getTableSchema(tableName);
}
#method_after
private TableSchema getTableSchema() {
    String tableName = tableDesc.name();
    return dbSchema.getTableSchema(tableName);
}
#end_block

#method_before
@Override
public Column getColumnHandler(ColumnDescription columndesc) throws Throwable {
    if (!isValid()) {
        return null;
    }
    String columnName = columndesc.name();
    checkColumnSchemaVersion(columndesc);
    if (columnName == null) {
        throw new TypedSchemaException("Error processing GetColumn : " + tabledesc.name() + "." + columndesc.method());
    }
    TableSchema tableSchema = getTableSchema();
    if (tableSchema == null) {
        String message = TableSchemaNotFoundException.createMessage(tabledesc.name(), dbSchema.name());
        throw new TableSchemaNotFoundException(message);
    }
    ColumnSchema columnSchema = getColumnSchema(tableSchema, columnName);
    if (columnSchema == null) {
        String message = ColumnSchemaNotFoundException.createMessage(columnName, tableSchema.name());
        throw new ColumnSchemaNotFoundException(message);
    }
    if (row == null) {
        return new Column(columnSchema, null);
    }
    return row.getColumn(columnSchema);
}
#method_after
@Override
public Column getColumnHandler(ColumnDescription columnDesc) {
    if (!isValid()) {
        return null;
    }
    String columnName = columnDesc.name();
    checkColumnSchemaVersion(columnDesc);
    if (columnName == null) {
        throw new TypedSchemaException("Error processing GetColumn : " + tableDesc.name() + "." + columnDesc.method());
    }
    TableSchema tableSchema = getTableSchema();
    if (tableSchema == null) {
        String message = TableSchemaNotFoundException.createMessage(tableDesc.name(), dbSchema.name());
        throw new TableSchemaNotFoundException(message);
    }
    ColumnSchema columnSchema = getColumnSchema(tableSchema, columnName);
    if (columnSchema == null) {
        String message = ColumnSchemaNotFoundException.createMessage(columnName, tableSchema.name());
        throw new ColumnSchemaNotFoundException(message);
    }
    if (row == null) {
        return new Column(columnSchema, null);
    }
    return row.getColumn(columnSchema);
}
#end_block

#method_before
@Override
public Object getDataHandler(ColumnDescription columndesc) throws Throwable {
    if (!isValid()) {
        return null;
    }
    String columnName = columndesc.name();
    checkColumnSchemaVersion(columndesc);
    if (columnName == null) {
        throw new TypedSchemaException("Error processing GetColumn : " + tabledesc.name() + "." + columndesc.method());
    }
    TableSchema tableSchema = getTableSchema();
    if (tableSchema == null) {
        String message = TableSchemaNotFoundException.createMessage(tabledesc.name(), dbSchema.name());
        throw new TableSchemaNotFoundException(message);
    }
    ColumnSchema columnSchema = getColumnSchema(tableSchema, columnName);
    if (columnSchema == null) {
        String message = ColumnSchemaNotFoundException.createMessage(columnName, tableSchema.name());
        throw new ColumnSchemaNotFoundException(message);
    }
    if (row == null || row.getColumn(columnSchema) == null) {
        return null;
    }
    return row.getColumn(columnSchema).data();
}
#method_after
@Override
public Object getDataHandler(ColumnDescription columnDesc) {
    if (!isValid()) {
        return null;
    }
    String columnName = columnDesc.name();
    checkColumnSchemaVersion(columnDesc);
    if (columnName == null) {
        throw new TypedSchemaException("Error processing GetColumn : " + tableDesc.name() + "." + columnDesc.method());
    }
    TableSchema tableSchema = getTableSchema();
    if (tableSchema == null) {
        String message = TableSchemaNotFoundException.createMessage(tableDesc.name(), dbSchema.name());
        throw new TableSchemaNotFoundException(message);
    }
    ColumnSchema columnSchema = getColumnSchema(tableSchema, columnName);
    if (columnSchema == null) {
        String message = ColumnSchemaNotFoundException.createMessage(columnName, tableSchema.name());
        throw new ColumnSchemaNotFoundException(message);
    }
    if (row == null || row.getColumn(columnSchema) == null) {
        return null;
    }
    return row.getColumn(columnSchema).data();
}
#end_block

#method_before
@Override
public void setDataHandler(ColumnDescription columndesc, Object obj) throws Throwable {
    if (!isValid()) {
        return;
    }
    String columnName = columndesc.name();
    checkColumnSchemaVersion(columndesc);
    if (columnName == null) {
        throw new TypedSchemaException("Unable to locate Column Name for " + tabledesc.name() + "." + columndesc.method());
    }
    TableSchema tableSchema = getTableSchema();
    ColumnSchema columnSchema = getColumnSchema(tableSchema, columnName);
    Column column = new Column(columnSchema, obj);
    row.addColumn(columnName, column);
}
#method_after
@Override
public void setDataHandler(ColumnDescription columnDesc, Object obj) {
    if (!isValid()) {
        return;
    }
    String columnName = columnDesc.name();
    checkColumnSchemaVersion(columnDesc);
    if (columnName == null) {
        throw new TypedSchemaException("Unable to locate Column Name for " + tableDesc.name() + "." + columnDesc.method());
    }
    TableSchema tableSchema = getTableSchema();
    ColumnSchema columnSchema = getColumnSchema(tableSchema, columnName);
    Column column = new Column(columnSchema, obj);
    row.addColumn(columnName, column);
}
#end_block

#method_before
@Override
public UUID getUuid() throws Throwable {
    if (!isValid()) {
        return null;
    }
    ColumnDescription columndesc = new ColumnDescription("_uuid", "getTbUuid");
    return (UUID) getDataHandler(columndesc);
}
#method_after
@Override
public UUID getUuid() {
    if (!isValid()) {
        return null;
    }
    ColumnDescription columnDesc = new ColumnDescription("_uuid", "getTbUuid");
    return (UUID) getDataHandler(columnDesc);
}
#end_block

#method_before
@Override
public Column getUuidColumn() throws Throwable {
    if (!isValid()) {
        return null;
    }
    ColumnDescription columndesc = new ColumnDescription("_uuid", "getTbUuidColumn");
    return (Column) getColumnHandler(columndesc);
}
#method_after
@Override
public Column getUuidColumn() {
    if (!isValid()) {
        return null;
    }
    ColumnDescription columnDesc = new ColumnDescription("_uuid", "getTbUuidColumn");
    return (Column) getColumnHandler(columnDesc);
}
#end_block

#method_before
@Override
public UUID getVersion() throws Throwable {
    if (!isValid()) {
        return null;
    }
    ColumnDescription columndesc = new ColumnDescription("_version", "getTbVersion");
    return (UUID) getDataHandler(columndesc);
}
#method_after
@Override
public UUID getVersion() {
    if (!isValid()) {
        return null;
    }
    ColumnDescription columnDesc = new ColumnDescription("_version", "getTbVersion");
    return (UUID) getDataHandler(columnDesc);
}
#end_block

#method_before
@Override
public Column getVersionColumn() throws Throwable {
    if (!isValid()) {
        return null;
    }
    ColumnDescription columndesc = new ColumnDescription("_version", "getTbVersionColumn");
    return (Column) getColumnHandler(columndesc);
}
#method_after
@Override
public Column getVersionColumn() {
    if (!isValid()) {
        return null;
    }
    ColumnDescription columnDesc = new ColumnDescription("_version", "getTbVersionColumn");
    return (Column) getColumnHandler(columnDesc);
}
#end_block

#method_before
@Override
public void createTunnel(TunnelDescription tunnel) {
    DriverHandler handler = handler();
    OvsdbClientService ovsdbNode = getOvsdbNode(handler);
    IpTunnelEndPoint ipSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf("0:0:0:0"));
    IpTunnelEndPoint ipDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf("0:0:0:0"));
    if (tunnel.src() instanceof IpTunnelEndPoint) {
        ipSrc = (IpTunnelEndPoint) tunnel.src();
    }
    if (tunnel.dst() instanceof IpTunnelEndPoint) {
        ipDst = (IpTunnelEndPoint) tunnel.dst();
    }
    ovsdbNode.createTunnel(ipSrc.ip(), ipDst.ip());
}
#method_after
@Override
public void createTunnel(TunnelDescription tunnel) {
    DriverHandler handler = handler();
    OvsdbClientService ovsdbNode = getOvsdbNode(handler);
    IpTunnelEndPoint ipSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(DEFAULT_ADDRESS));
    IpTunnelEndPoint ipDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(DEFAULT_ADDRESS));
    if (tunnel.src() instanceof IpTunnelEndPoint) {
        ipSrc = (IpTunnelEndPoint) tunnel.src();
    }
    if (tunnel.dst() instanceof IpTunnelEndPoint) {
        ipDst = (IpTunnelEndPoint) tunnel.dst();
    }
    // Even if source point ip or destination point ip equals 0:0:0:0, it is still work-in-progress.
    ovsdbNode.createTunnel(ipSrc.ip(), ipDst.ip());
}
#end_block

#method_before
@Override
public void removeTunnel(TunnelDescription tunnel) {
    DriverHandler handler = handler();
    OvsdbClientService ovsdbNode = getOvsdbNode(handler);
    IpTunnelEndPoint ipSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf("0:0:0:0"));
    IpTunnelEndPoint ipDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf("0:0:0:0"));
    if (tunnel.src() instanceof IpTunnelEndPoint) {
        ipSrc = (IpTunnelEndPoint) tunnel.src();
    }
    if (tunnel.dst() instanceof IpTunnelEndPoint) {
        ipDst = (IpTunnelEndPoint) tunnel.dst();
    }
    ovsdbNode.dropTunnel(ipSrc.ip(), ipDst.ip());
}
#method_after
@Override
public void removeTunnel(TunnelDescription tunnel) {
    DriverHandler handler = handler();
    OvsdbClientService ovsdbNode = getOvsdbNode(handler);
    IpTunnelEndPoint ipSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(DEFAULT_ADDRESS));
    IpTunnelEndPoint ipDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(DEFAULT_ADDRESS));
    if (tunnel.src() instanceof IpTunnelEndPoint) {
        ipSrc = (IpTunnelEndPoint) tunnel.src();
    }
    if (tunnel.dst() instanceof IpTunnelEndPoint) {
        ipDst = (IpTunnelEndPoint) tunnel.dst();
    }
    // Even if source point ip or destination point ip equals 0:0:0:0, it is still work-in-progress.
    ovsdbNode.dropTunnel(ipSrc.ip(), ipDst.ip());
}
#end_block

#method_before
@Test
public void testBaseAttrs() {
    // configs 0 and 1 - port with and without alphanumeric names
    OpticalPortConfig op0 = opcl.get(0);
    OpticalPortConfig op1 = opcl.get(1);
    // config 2 - no name
    OpticalPortConfig op2 = opcl.get(2);
    JsonNode jn0 = testNodes.get(0);
    JsonNode jn1 = testNodes.get(1);
    op0.setPortType(Port.Type.valueOf(jn0.path(TYPE).asText())).setPortName(jn0.path(NAME).asText());
    op1.setPortType(Port.Type.valueOf(jn1.path(TYPE).asText())).setPortNumberName(jn1.path(PORT).asLong());
    assertEquals(Port.Type.OMS, op0.type());
    assertEquals(jn0.path(NAME).asText(), op0.name());
    assertEquals(jn1.path(PORT).asText(), op1.name());
    assertEquals("", op2.name());
}
#method_after
@Test
public void testBaseAttrs() {
    // configs 0 and 1 - port with and without alphanumeric names
    OpticalPortConfig op0 = opcl.get(0);
    OpticalPortConfig op1 = opcl.get(1);
    // config 2 - no name
    OpticalPortConfig op2 = opcl.get(2);
    JsonNode jn0 = testNodes.get(0);
    JsonNode jn1 = testNodes.get(1);
    op0.portType(Port.Type.valueOf(jn0.path(TYPE).asText())).portName(jn0.path(NAME).asText());
    op1.portType(Port.Type.valueOf(jn1.path(TYPE).asText())).portNumberName(jn1.path(PORT).asLong());
    assertEquals(Port.Type.OMS, op0.type());
    assertEquals(jn0.path(NAME).asText(), op0.name());
    assertEquals(jn1.path(PORT).asText(), op1.name());
    assertEquals("", op2.name());
}
#end_block

#method_before
@Test
public void testAdditionalAttrs() {
    // config 1 has no annotations, 2 has predefined ones
    OpticalPortConfig op1 = opcl.get(1);
    OpticalPortConfig op2 = opcl.get(2);
    JsonNode jn2 = testNodes.get(2);
    // see config entity 2 in DEMOTREE
    op2.setStaticLambda(jn2.path("annotations").path(STATIC_LAMBDA).asLong());
    op2.setStaticPort(jn2.path("annotations").path(STATIC_PORT).asText());
    assertEquals(IL, op2.staticLambda().get());
    assertFalse(op1.staticLambda().isPresent());
    assertEquals("1-22-E1_WPORT", op2.staticPort());
    assertEquals("", op1.staticPort());
    op2.setStaticLambda(null);
    assertFalse(op2.staticLambda().isPresent());
}
#method_after
@Test
public void testAdditionalAttrs() {
    // config 1 has no annotations, 2 has predefined ones
    OpticalPortConfig op1 = opcl.get(1);
    OpticalPortConfig op2 = opcl.get(2);
    JsonNode jn2 = testNodes.get(2);
    Long sl = 1L;
    // see config entity 2 in DEMOTREE
    op2.staticLambda(jn2.path("annotations").path(AnnotationKeys.STATIC_LAMBDA).asLong());
    op2.staticPort(jn2.path("annotations").path(AnnotationKeys.STATIC_PORT).asText());
    assertEquals(sl, op2.staticLambda().get());
    assertFalse(op1.staticLambda().isPresent());
    assertEquals("1-22-E1_WPORT", op2.staticPort());
    assertEquals("", op1.staticPort());
    op2.staticLambda(null);
    assertFalse(op2.staticLambda().isPresent());
}
#end_block

#method_before
public String staticPort() {
    return getStringValue(STATIC_PORT);
}
#method_after
public String staticPort() {
    return getStringValue(AnnotationKeys.STATIC_PORT);
}
#end_block

#method_before
public Optional<Lambda> staticLambda() {
    JsonNode sl = node.path(STATIC_LAMBDA);
    if (sl.isMissingNode()) {
        return Optional.empty();
    }
    return Optional.of(Lambda.indexedLambda(sl.asLong()));
}
#method_after
public Optional<Long> staticLambda() {
    JsonNode sl = node.path(AnnotationKeys.STATIC_LAMBDA);
    if (sl.isMissingNode()) {
        return Optional.empty();
    }
    return Optional.of(sl.asLong());
}
#end_block

#method_before
public String staticPort() {
    return getStringValue(STATIC_PORT);
}
#method_after
public OpticalPortConfig staticPort(String name) {
    return (OpticalPortConfig) setOrClear(AnnotationKeys.STATIC_PORT, name);
}
#end_block

#method_before
public Optional<Lambda> staticLambda() {
    JsonNode sl = node.path(STATIC_LAMBDA);
    if (sl.isMissingNode()) {
        return Optional.empty();
    }
    return Optional.of(Lambda.indexedLambda(sl.asLong()));
}
#method_after
public OpticalPortConfig staticLambda(Long index) {
    return (OpticalPortConfig) setOrClear(AnnotationKeys.STATIC_LAMBDA, index);
}
#end_block

#method_before
static int advisor(int priority) {
    return priority;
}
#method_after
static int advisor(int priority) {
    if (priority > 0 && priority <= ADVISOR_MAX) {
        return priority;
    }
    return ADVISOR_MAX;
}
#end_block

#method_before
static int director(int priority) {
    return ADVISOR_MAX + priority;
}
#method_after
static int director(int priority) {
    int overallPriority = ADVISOR_MAX + priority;
    if (overallPriority > ADVISOR_MAX && overallPriority <= DIRECTOR_MAX) {
        return overallPriority;
    }
    return DIRECTOR_MAX;
}
#end_block

#method_before
static int observer(int priority) {
    return DIRECTOR_MAX + priority;
}
#method_after
static int observer(int priority) {
    int overallPriority = DIRECTOR_MAX + priority;
    if (overallPriority > DIRECTOR_MAX && overallPriority <= OBSERVER_MAX) {
        return overallPriority;
    }
    return OBSERVER_MAX;
}
#end_block

#method_before
@Override
public void serialize(Mutation condition, JsonGenerator generator, SerializerProvider provider) throws IOException, JsonProcessingException {
    generator.writeStartArray();
    generator.writeString(condition.getColumn());
    generator.writeString(condition.getMutator().getName());
    generator.writeObject(condition.getValue());
    generator.writeEndArray();
}
#method_after
@Override
public void serialize(Mutation condition, JsonGenerator generator, SerializerProvider provider) throws IOException, JsonProcessingException {
    generator.writeStartArray();
    generator.writeString(condition.getColumn());
    generator.writeString(condition.getMutator().mutator());
    generator.writeObject(condition.getValue());
    generator.writeEndArray();
}
#end_block

#method_before
public static ColumnType getColumnTypeFromJson(JsonNode json) {
    if (json.isObject() && !json.has("value")) {
        return createAtomicColumnType(json);
    } else if (!json.isValueNode() && json.has("value")) {
        return createKeyValuedColumnType(json);
    }
    throw new TypedSchemaException("could not find the right column type :" + ObjectMapperUtil.convertToString(json));
}
#method_after
public static ColumnType getColumnTypeFromJson(JsonNode json) {
    if (json.isObject() && !json.has(Type.VALUE.type())) {
        return createAtomicColumnType(json);
    } else if (!json.isValueNode() && json.has(Type.VALUE.type())) {
        return createKeyValuedColumnType(json);
    }
    throw new TypedSchemaException("could not find the right column type :" + ObjectMapperUtil.convertToString(json));
}
#end_block

#method_before
private static AtomicColumnType createAtomicColumnType(JsonNode json) {
    BaseType baseType = BaseTypeFactory.getBaseTypeFromJson(json, "key");
    int min = 1;
    int max = 1;
    JsonNode node = json.get("min");
    if (node != null) {
        min = node.asInt();
    }
    node = json.get("max");
    if (node != null) {
        if (node.isNumber()) {
            max = node.asInt();
        } else if (node.isTextual() && "unlimited".equals(node.asText())) {
            max = Integer.MAX_VALUE;
        }
    }
    return new AtomicColumnType(baseType, min, max);
}
#method_after
private static AtomicColumnType createAtomicColumnType(JsonNode json) {
    BaseType baseType = BaseTypeFactory.getBaseTypeFromJson(json, Type.KEY.type());
    int min = 1;
    int max = 1;
    JsonNode node = json.get("min");
    if (node != null) {
        min = node.asInt();
    }
    node = json.get("max");
    if (node != null) {
        if (node.isNumber()) {
            max = node.asInt();
        } else if (node.isTextual() && "unlimited".equals(node.asText())) {
            max = Integer.MAX_VALUE;
        }
    }
    return new AtomicColumnType(baseType, min, max);
}
#end_block

#method_before
private static KeyValuedColumnType createKeyValuedColumnType(JsonNode json) {
    BaseType keyType = BaseTypeFactory.getBaseTypeFromJson(json, "key");
    BaseType valueType = BaseTypeFactory.getBaseTypeFromJson(json, "value");
    int min = 1;
    int max = 1;
    JsonNode node = json.get("min");
    if (node != null) {
        min = node.asInt();
    }
    node = json.get("max");
    if (node != null) {
        if (node.isNumber()) {
            max = node.asInt();
        } else if (node.isTextual() && "unlimited".equals(node.asText())) {
            max = Integer.MAX_VALUE;
        }
    }
    return new KeyValuedColumnType(keyType, valueType, min, max);
}
#method_after
private static KeyValuedColumnType createKeyValuedColumnType(JsonNode json) {
    BaseType keyType = BaseTypeFactory.getBaseTypeFromJson(json, Type.KEY.type());
    BaseType valueType = BaseTypeFactory.getBaseTypeFromJson(json, Type.VALUE.type());
    int min = 1;
    int max = 1;
    JsonNode node = json.get("min");
    if (node != null) {
        min = node.asInt();
    }
    node = json.get("max");
    if (node != null) {
        if (node.isNumber()) {
            max = node.asInt();
        } else if (node.isTextual() && "unlimited".equals(node.asText())) {
            max = Integer.MAX_VALUE;
        }
    }
    return new KeyValuedColumnType(keyType, valueType, min, max);
}
#end_block

#method_before
@Override
public void serialize(Condition condition, JsonGenerator generator, SerializerProvider provider) throws IOException, JsonProcessingException {
    generator.writeStartArray();
    generator.writeString(condition.getColumn());
    generator.writeString(condition.getFunction().getName());
    generator.writeObject(condition.getValue());
    generator.writeEndArray();
}
#method_after
@Override
public void serialize(Condition condition, JsonGenerator generator, SerializerProvider provider) throws IOException, JsonProcessingException {
    generator.writeStartArray();
    generator.writeString(condition.getColumn());
    generator.writeString(condition.getFunction().function());
    generator.writeObject(condition.getValue());
    generator.writeEndArray();
}
#end_block

#method_before
public static String convertToString(Object obj) {
    ObjectMapper objectMapper = new ObjectMapper();
    try {
        return objectMapper.writeValueAsString(obj);
    } catch (JsonProcessingException e) {
        throw new RuntimeException(e);
    }
}
#method_after
public static String convertToString(Object obj) {
    ObjectMapper objectMapper = new ObjectMapper();
    try {
        return objectMapper.writeValueAsString(obj);
    } catch (JsonProcessingException e) {
        log.error("JsonProcessingException while converting Entity into string", e);
    }
    return null;
}
#end_block

#method_before
private static UuidBaseType getUuidBaseType(JsonNode type) {
    String refTable = null;
    String refType = RefType.STRONG.getName();
    JsonNode node = type.get("refTable");
    if (node != null) {
        refTable = node.asText();
    }
    node = type.get("refType");
    if (node != null) {
        refType = node.asText();
    }
    return new UuidBaseType(refTable, refType);
}
#method_after
private static UuidBaseType getUuidBaseType(JsonNode type) {
    String refTable = null;
    String refType = RefType.STRONG.refType();
    JsonNode node = type.get("refTable");
    if (node != null) {
        refTable = node.asText();
    }
    node = type.get("refType");
    if (node != null) {
        refType = node.asText();
    }
    return new UuidBaseType(refTable, refType);
}
#end_block

#method_before
@Override
public void addBridge(BridgeName bridgeName) {
    DriverHandler handler = handler();
    OvsdbController ovsController = handler.get(OvsdbController.class);
    DeviceId deviceId = handler.data().deviceId();
    OvsdbNodeId nodeId = changeDeviceIdToNodeId(deviceId);
    OvsdbClientService ovsdbNode = ovsController.getOvsdbClient(nodeId);
    ovsdbNode.createBridge(bridgeName.name());
}
#method_after
@Override
public void addBridge(BridgeName bridgeName) {
    DriverHandler handler = handler();
    OvsdbClientService ovsdbNode = getOvsdbNode(handler);
    ovsdbNode.createBridge(bridgeName.name());
}
#end_block

#method_before
@Override
public void deleteBridge(BridgeName bridgeName) {
    DriverHandler handler = handler();
    OvsdbController ovsController = handler.get(OvsdbController.class);
    DeviceId deviceId = handler.data().deviceId();
    OvsdbNodeId nodeId = changeDeviceIdToNodeId(deviceId);
    OvsdbClientService ovsdbNode = ovsController.getOvsdbClient(nodeId);
    ovsdbNode.dropBridge(bridgeName.name());
}
#method_after
@Override
public void deleteBridge(BridgeName bridgeName) {
    DriverHandler handler = handler();
    OvsdbClientService ovsdbNode = getOvsdbNode(handler);
    ovsdbNode.dropBridge(bridgeName.name());
}
#end_block

#method_before
@Override
public Collection<BridgeDescription> getBridges() {
    DriverHandler handler = handler();
    OvsdbController ovsController = handler.get(OvsdbController.class);
    DeviceId deviceId = handler.data().deviceId();
    OvsdbNodeId nodeId = changeDeviceIdToNodeId(deviceId);
    OvsdbClientService ovsdbNode = ovsController.getOvsdbClient(nodeId);
    Set<OvsdbBridge> ovsdbSet = ovsdbNode.getBridges();
    Collection<BridgeDescription> bridges = Sets.newHashSet();
    ovsdbSet.forEach(o -> {
        BridgeName bridgeName = BridgeName.bridgeName(o.bridgeName().toString());
        DeviceId ownDeviceId = DeviceId.deviceId(o.datapathId().toString());
        BridgeDescription description = new DefaultBridgeDescription(bridgeName, deviceId, ownDeviceId);
        bridges.add(description);
    });
    return bridges;
}
#method_after
@Override
public Collection<BridgeDescription> getBridges() {
    DriverHandler handler = handler();
    DeviceId deviceId = handler.data().deviceId();
    OvsdbClientService ovsdbNode = getOvsdbNode(handler);
    Set<OvsdbBridge> ovsdbSet = ovsdbNode.getBridges();
    Collection<BridgeDescription> bridges = Sets.newHashSet();
    ovsdbSet.forEach(o -> {
        BridgeName bridgeName = BridgeName.bridgeName(o.bridgeName().toString());
        DeviceId ownDeviceId = DeviceId.deviceId(o.datapathId().toString());
        BridgeDescription description = new DefaultBridgeDescription(bridgeName, deviceId, ownDeviceId);
        bridges.add(description);
    });
    return bridges;
}
#end_block

#method_before
@Override
public void addPort(PortDescription port) {
    DriverHandler handler = handler();
    OvsdbController ovsController = handler.get(OvsdbController.class);
    DeviceId deviceId = handler.data().deviceId();
    OvsdbNodeId nodeId = changeDeviceIdToNodeId(deviceId);
    OvsdbClientService ovsdbNode = ovsController.getOvsdbClient(nodeId);
    Set<OvsdbBridge> ovsdbSet = ovsdbNode.getBridges();
    if (ovsdbSet != null && ovsdbSet.size() > 0) {
        OvsdbBridge bridge = ovsdbSet.iterator().next();
        ovsdbNode.createPort(bridge.bridgeName().toString(), port.portNumber().toString());
    }
}
#method_after
@Override
public void addPort(PortDescription port) {
    DriverHandler handler = handler();
    OvsdbClientService ovsdbNode = getOvsdbNode(handler);
    Set<OvsdbBridge> ovsdbSet = ovsdbNode.getBridges();
    if (ovsdbSet != null && ovsdbSet.size() > 0) {
        OvsdbBridge bridge = ovsdbSet.iterator().next();
        ovsdbNode.createPort(bridge.bridgeName().toString(), port.portNumber().toString());
    }
}
#end_block

#method_before
@Override
public void deletePort(PortDescription port) {
    DriverHandler handler = handler();
    OvsdbController ovsController = handler.get(OvsdbController.class);
    DeviceId deviceId = handler.data().deviceId();
    OvsdbNodeId nodeId = changeDeviceIdToNodeId(deviceId);
    OvsdbClientService ovsdbNode = ovsController.getOvsdbClient(nodeId);
    Set<OvsdbBridge> ovsdbSet = ovsdbNode.getBridges();
    if (ovsdbSet != null && ovsdbSet.size() > 0) {
        OvsdbBridge bridge = ovsdbSet.iterator().next();
        ovsdbNode.dropPort(bridge.bridgeName().toString(), port.portNumber().toString());
    }
}
#method_after
@Override
public void deletePort(PortDescription port) {
    DriverHandler handler = handler();
    OvsdbClientService ovsdbNode = getOvsdbNode(handler);
    Set<OvsdbBridge> ovsdbSet = ovsdbNode.getBridges();
    if (ovsdbSet != null && ovsdbSet.size() > 0) {
        OvsdbBridge bridge = ovsdbSet.iterator().next();
        ovsdbNode.dropPort(bridge.bridgeName().toString(), port.portNumber().toString());
    }
}
#end_block

#method_before
@Override
public Collection<PortDescription> getPorts() {
    DriverHandler handler = handler();
    OvsdbController ovsController = handler.get(OvsdbController.class);
    DeviceId deviceId = handler.data().deviceId();
    OvsdbNodeId nodeId = changeDeviceIdToNodeId(deviceId);
    OvsdbClientService ovsdbNode = ovsController.getOvsdbClient(nodeId);
    Set<OvsdbPort> ovsdbSet = ovsdbNode.getPorts();
    Collection<PortDescription> ports = Sets.newHashSet();
    ovsdbSet.forEach(o -> {
        PortNumber port = PortNumber.portNumber(o.portNumber().value());
        PortDescription description = new DefaultPortDescription(port, true);
        ports.add(description);
    });
    return ports;
}
#method_after
@Override
public Collection<PortDescription> getPorts() {
    DriverHandler handler = handler();
    OvsdbClientService ovsdbNode = getOvsdbNode(handler);
    Set<OvsdbPort> ovsdbSet = ovsdbNode.getPorts();
    Collection<PortDescription> ports = Sets.newHashSet();
    ovsdbSet.forEach(o -> {
        PortNumber port = PortNumber.portNumber(o.portNumber().value());
        PortDescription description = new DefaultPortDescription(port, true);
        ports.add(description);
    });
    return ports;
}
#end_block

#method_before
private OvsdbNodeId changeDeviceIdToNodeId(DeviceId deviceId) {
    int lastColon = deviceId.toString().lastIndexOf(":");
    int fistColon = deviceId.toString().indexOf(":");
    String ip = deviceId.toString().substring(fistColon + 1, lastColon - 1);
    String port = deviceId.toString().substring(lastColon + 1);
    IpAddress ipAddress = IpAddress.valueOf(ip);
    long portL = Long.valueOf(port).longValue();
    return new OvsdbNodeId(ipAddress, portL);
}
#method_after
// OvsdbNodeId(IP:port) is used in the adaptor while DeviceId(ovsdb:IP:port)
private OvsdbNodeId changeDeviceIdToNodeId(DeviceId deviceId) {
    int lastColon = deviceId.toString().lastIndexOf(":");
    int fistColon = deviceId.toString().indexOf(":");
    String ip = deviceId.toString().substring(fistColon + 1, lastColon - 1);
    String port = deviceId.toString().substring(lastColon + 1);
    IpAddress ipAddress = IpAddress.valueOf(ip);
    long portL = Long.valueOf(port).longValue();
    return new OvsdbNodeId(ipAddress, portL);
}
#end_block

#method_before
@Override
public void handle(OvsdbEvent<EventSubject> event) {
    OvsdbEventSubject subject = null;
    if (event.subject() instanceof OvsdbEventSubject) {
        subject = (OvsdbEventSubject) event.subject();
    }
    checkNotNull(subject, "EventSubject is not null");
    // If ifaceid is null,it indicates this is not a vm port.
    if (subject.ifaceid() == null) {
        return;
    }
    switch(event.type()) {
        case PORT_ADDED:
            HostId hostId = HostId.hostId(subject.hwAddress(), null);
            DeviceId deviceId = DeviceId.deviceId(uri(subject.dpid()));
            PortNumber portNumber = PortNumber.portNumber(subject.portNumber(), subject.portName());
            HostLocation loaction = new HostLocation(deviceId, portNumber, 0L);
            DefaultAnnotations annotations = DefaultAnnotations.builder().set("ifaceid", subject.ifaceid()).build();
            HostDescription hostDescription = new DefaultHostDescription(subject.hwAddress(), VlanId.vlanId(), loaction, annotations);
            providerService.hostDetected(hostId, hostDescription);
            break;
        case PORT_REMOVED:
            HostId host = HostId.hostId(subject.hwAddress(), null);
            providerService.hostVanished(host);
            break;
        default:
            break;
    }
}
#method_after
@Override
public void handle(OvsdbEvent<EventSubject> event) {
    OvsdbEventSubject subject = null;
    if (event.subject() instanceof OvsdbEventSubject) {
        subject = (OvsdbEventSubject) event.subject();
    }
    checkNotNull(subject, "EventSubject is not null");
    // If ifaceid is null,it indicates this is not a vm port.
    if (subject.ifaceid() == null) {
        return;
    }
    switch(event.type()) {
        case PORT_ADDED:
            HostId hostId = HostId.hostId(subject.hwAddress(), null);
            DeviceId deviceId = DeviceId.deviceId(uri(subject.dpid().value()));
            PortNumber portNumber = PortNumber.portNumber(subject.portNumber().value(), subject.portName().value());
            HostLocation loaction = new HostLocation(deviceId, portNumber, 0L);
            DefaultAnnotations annotations = DefaultAnnotations.builder().set("ifaceid", subject.ifaceid().value()).build();
            HostDescription hostDescription = new DefaultHostDescription(subject.hwAddress(), VlanId.vlanId(), loaction, annotations);
            providerService.hostDetected(hostId, hostDescription);
            break;
        case PORT_REMOVED:
            HostId host = HostId.hostId(subject.hwAddress(), null);
            providerService.hostVanished(host);
            break;
        default:
            break;
    }
}
#end_block

#method_before
public URI uri(long value) {
    try {
        return new URI("of", toHex(value), null);
    } catch (URISyntaxException e) {
        return null;
    }
}
#method_after
public URI uri(String value) {
    try {
        return new URI("of", toHex(Long.valueOf(value)), null);
    } catch (URISyntaxException e) {
        return null;
    }
}
#end_block

#method_before
@Override
public String portName() {
    return portname;
}
#method_after
@Override
public OvsdbPortName portName() {
    return portname;
}
#end_block

#method_before
@Override
public long portNumber() {
    return portnumber;
}
#method_after
@Override
public OvsdbPortNumber portNumber() {
    return portnumber;
}
#end_block

#method_before
@Override
public String portType() {
    return portType;
}
#method_after
@Override
public OvsdbPortType portType() {
    return portType;
}
#end_block

#method_before
@Override
public long dpid() {
    return dpid;
}
#method_after
@Override
public OvsdbDatapathId dpid() {
    return dpid;
}
#end_block

#method_before
@Override
public String ifaceid() {
    return ifaceid;
}
#method_after
@Override
public OvsdbIfaceId ifaceid() {
    return ifaceid;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(mac, portname, portnumber, dpid, portType);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(mac, portname, portnumber, dpid, portType, ifaceid);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultEventSubject) {
        final DefaultEventSubject other = (DefaultEventSubject) obj;
        return Objects.equals(this.mac, other.mac) && Objects.equals(this.portname, other.portname) && Objects.equals(this.portnumber, other.portnumber) && Objects.equals(this.dpid, other.dpid) && Objects.equals(this.portType, other.portType);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultEventSubject) {
        final DefaultEventSubject other = (DefaultEventSubject) obj;
        return Objects.equals(this.mac, other.mac) && Objects.equals(this.portname, other.portname) && Objects.equals(this.portnumber, other.portnumber) && Objects.equals(this.dpid, other.dpid) && Objects.equals(this.portType, other.portType) && Objects.equals(this.ifaceid, other.ifaceid);
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("mac", mac).add("portname", portname).add("portnumber", portnumber).add("portType", portType).add("ipAddresses", ips).add("dpid", dpid).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("mac", mac).add("portname", portname).add("portnumber", portnumber).add("portType", portType).add("ipAddresses", ips).add("dpid", dpid).add("ifaceid", ifaceid).toString();
}
#end_block

#method_before
@Test
public void portAdded() {
    DefaultEventSubject eventSubject = new DefaultEventSubject(MAC, null, "portName", 0L, 10002L, "vxlan", "102345");
    controller.ovsdbEventListener.handle(new OvsdbEvent<EventSubject>(OvsdbEvent.Type.PORT_ADDED, eventSubject));
    assertNotNull("never went throught the provider service", providerService.added);
}
#method_after
@Test
public void portAdded() {
    DefaultEventSubject eventSubject = new DefaultEventSubject(MAC, null, new OvsdbPortName("portName"), new OvsdbPortNumber(0L), new OvsdbDatapathId("10002"), new OvsdbPortType("vxlan"), new OvsdbIfaceId("102345"));
    controller.ovsdbEventListener.handle(new OvsdbEvent<EventSubject>(OvsdbEvent.Type.PORT_ADDED, eventSubject));
    assertNotNull("never went throught the provider service", providerService.added);
}
#end_block

#method_before
@Test
public void portRemoved() {
    DefaultEventSubject eventSubject = new DefaultEventSubject(MAC, null, "portName", 0L, 10002L, "vxlan", "102345");
    controller.ovsdbEventListener.handle(new OvsdbEvent<EventSubject>(OvsdbEvent.Type.PORT_REMOVED, eventSubject));
    assertEquals("port status unhandled", 1, providerService.removeCount);
}
#method_after
@Test
public void portRemoved() {
    DefaultEventSubject eventSubject = new DefaultEventSubject(MAC, null, new OvsdbPortName("portName"), new OvsdbPortNumber(0L), new OvsdbDatapathId("10002"), new OvsdbPortType("vxlan"), new OvsdbIfaceId("102345"));
    controller.ovsdbEventListener.handle(new OvsdbEvent<EventSubject>(OvsdbEvent.Type.PORT_REMOVED, eventSubject));
    assertEquals("port status unhandled", 1, providerService.removeCount);
}
#end_block

#method_before
@Override
public List<ResourceAllocation<?, ?>> allocate(ResourceConsumer consumer, List<? extends Resource<?, ?>> resources) {
    checkNotNull(consumer);
    checkNotNull(resources);
    if (resources.stream().anyMatch(x -> !inRange(x))) {
        return ImmutableList.of();
    }
    // TODO: implement support of resource hierarchy
    // allocation for a particular resource implies allocations for all of the sub-resources need to be done
    boolean success = store.allocate(resources, consumer);
    if (!success) {
        return ImmutableList.of();
    }
    return resources.stream().map(x -> new DefaultResourceAllocation<>(x.subject(), x.resource(), consumer)).collect(Collectors.toList());
}
#method_after
@Override
public List<ResourceAllocation<?, ?>> allocate(ResourceConsumer consumer, List<? extends Resource<?, ?>> resources) {
    checkNotNull(consumer);
    checkNotNull(resources);
    if (resources.stream().anyMatch(x -> !isValid(x))) {
        return ImmutableList.of();
    }
    // TODO: implement support of resource hierarchy
    // allocation for a particular resource implies allocations for all of the sub-resources need to be done
    boolean success = store.allocate(resources, consumer);
    if (!success) {
        return ImmutableList.of();
    }
    return resources.stream().map(x -> new DefaultResourceAllocation<>(x.subject(), x.resource(), consumer)).collect(Collectors.toList());
}
#end_block

#method_before
@Override
public boolean release(List<? extends Resource<?, ?>> resources, List<ResourceConsumer> consumers) {
    checkNotNull(resources);
    checkNotNull(consumers);
    checkArgument(resources.size() == consumers.size());
    TransactionContext tx = service.transactionContextBuilder().build();
    tx.begin();
    try {
        TransactionalMap<Resource<?, ?>, ResourceConsumer> txMap = tx.getTransactionalMap(MAP_NAME, SERIALIZER);
        Iterator<? extends Resource<?, ?>> resourceIte = resources.iterator();
        Iterator<ResourceConsumer> consumerIte = consumers.iterator();
        while (resourceIte.hasNext() && consumerIte.hasNext()) {
            Resource<?, ?> resource = resourceIte.next();
            ResourceConsumer consumer = consumerIte.next();
            // the whole release fails
            if (!txMap.remove(resource, consumer)) {
                tx.abort();
                return false;
            }
        }
        return true;
    } catch (Exception e) {
        log.error("Exception thrown, abort the transaction", e);
        tx.abort();
        return false;
    }
}
#method_after
@Override
public boolean release(List<? extends Resource<?, ?>> resources, List<ResourceConsumer> consumers) {
    checkNotNull(resources);
    checkNotNull(consumers);
    checkArgument(resources.size() == consumers.size());
    TransactionContext tx = service.transactionContextBuilder().build();
    tx.begin();
    try {
        TransactionalMap<Resource<?, ?>, ResourceConsumer> txMap = tx.getTransactionalMap(MAP_NAME, SERIALIZER);
        Iterator<? extends Resource<?, ?>> resourceIte = resources.iterator();
        Iterator<ResourceConsumer> consumerIte = consumers.iterator();
        while (resourceIte.hasNext() && consumerIte.hasNext()) {
            Resource<?, ?> resource = resourceIte.next();
            ResourceConsumer consumer = consumerIte.next();
            // the whole release fails
            if (!txMap.remove(resource, consumer)) {
                tx.abort();
                return false;
            }
        }
        return true;
    } catch (TransactionException e) {
        log.error("Exception thrown, abort the transaction", e);
        tx.abort();
        return false;
    }
}
#end_block

#method_before
@Override
public void triggerProbe(DeviceId deviceId) {
    log.info("Triggering probe on device {}", deviceId);
}
#method_after
@Override
public void triggerProbe(DeviceId deviceId) {
    // TODO: This will be implemented later.
    log.info("Triggering probe on device {}", deviceId);
}
#end_block

#method_before
@Override
public void roleChanged(DeviceId deviceId, MastershipRole newRole) {
}
#method_after
@Override
public void roleChanged(DeviceId deviceId, MastershipRole newRole) {
// TODO: This will be implemented later.
}
#end_block

#method_before
@Override
public void nodeAdded(OvsdbNodeId nodeId) {
    checkNotNull(nodeId, ISNOTNULL);
    DeviceId deviceId = DeviceId.deviceId(nodeId.toString());
    URI uri = URI.create(nodeId.toString());
    ChassisId cid = new ChassisId();
    String ipAddress = nodeId.getIpAddress();
    SparseAnnotations annotations = DefaultAnnotations.builder().set("ipaddress", ipAddress).build();
    DeviceDescription deviceDescription = new DefaultDeviceDescription(uri, Device.Type.CONTROLLER, "", "", "", "", cid, annotations);
    providerService.deviceConnected(deviceId, deviceDescription);
}
#method_after
@Override
public void nodeAdded(OvsdbNodeId nodeId) {
    checkNotNull(nodeId, ISNOTNULL);
    DeviceId deviceId = DeviceId.deviceId(nodeId.toString());
    URI uri = URI.create(nodeId.toString());
    ChassisId cid = new ChassisId();
    String ipAddress = nodeId.getIpAddress();
    SparseAnnotations annotations = DefaultAnnotations.builder().set("ipaddress", ipAddress).build();
    DeviceDescription deviceDescription = new DefaultDeviceDescription(uri, Device.Type.CONTROLLER, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cid, annotations);
    providerService.deviceConnected(deviceId, deviceDescription);
}
#end_block

#method_before
@Test
public void testConstruction() {
    assertThat(event1.type(), is(PUT));
    assertThat(event1.key(), is("k1"));
    assertThat(event1.value(), is("v1"));
    assertThat(event1.name(), is("event1"));
}
#method_after
@Test
public void testConstruction() {
    assertThat(event1.type(), is(PUT));
    assertThat(event1.key(), is("k1"));
    assertThat(event1.value(), is("v1"));
    assertThat(event1.name(), is("map1"));
}
#end_block

#method_before
@Override
public Ip4Address suggestIP(MacAddress macID) {
    IPAssignment assignmentInfo;
    if (allocationMap.containsKey(macID)) {
        assignmentInfo = allocationMap.get(macID).value();
        return assignmentInfo.ipAddress();
    } else {
        Ip4Address nextIPAddr = fetchNextIP();
        assignmentInfo = IPAssignment.builder().withIPAddress(nextIPAddr).withTimestamp(new Date()).withLeasePeriod(timeoutForPendingAssignments).withAssignmentStatus(IPAssignment.AssignmentStatus.Option_Requested).build();
        allocationMap.put(macID, assignmentInfo);
        return nextIPAddr;
    }
}
#method_after
@Override
public Ip4Address suggestIP(MacAddress macID) {
    IPAssignment assignmentInfo;
    if (allocationMap.containsKey(macID)) {
        assignmentInfo = allocationMap.get(macID).value();
        return assignmentInfo.ipAddress();
    } else {
        Ip4Address nextIPAddr = fetchNextIP();
        assignmentInfo = IPAssignment.builder().ipAddress(nextIPAddr).timestamp(new Date()).leasePeriod(timeoutForPendingAssignments).assignmentStatus(IPAssignment.AssignmentStatus.Option_Requested).build();
        allocationMap.put(macID, assignmentInfo);
        return nextIPAddr;
    }
}
#end_block

#method_before
@Override
public boolean assignIP(MacAddress macID, Ip4Address ipAddr, int leaseTime) {
    IPAssignment assignmentInfo;
    if (allocationMap.containsKey(macID)) {
        assignmentInfo = allocationMap.get(macID).value();
        if (assignmentInfo.ipAddress().toInt() == ipAddr.toInt()) {
            assignmentInfo = IPAssignment.builder().withIPAddress(ipAddr).withTimestamp(new Date()).withLeasePeriod(leaseTime).withAssignmentStatus(IPAssignment.AssignmentStatus.Option_Assigned).build();
            allocationMap.put(macID, assignmentInfo);
            return true;
        }
    } else if (freeIPPool.contains(ipAddr)) {
        assignmentInfo = IPAssignment.builder().withIPAddress(ipAddr).withTimestamp(new Date()).withLeasePeriod(leaseTime).withAssignmentStatus(IPAssignment.AssignmentStatus.Option_Assigned).build();
        if (freeIPPool.remove(ipAddr)) {
            allocationMap.put(macID, assignmentInfo);
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean assignIP(MacAddress macID, Ip4Address ipAddr, int leaseTime) {
    IPAssignment assignmentInfo;
    if (allocationMap.containsKey(macID)) {
        assignmentInfo = allocationMap.get(macID).value();
        if (assignmentInfo.ipAddress().toInt() == ipAddr.toInt()) {
            assignmentInfo = IPAssignment.builder().ipAddress(ipAddr).timestamp(new Date()).leasePeriod(leaseTime).assignmentStatus(IPAssignment.AssignmentStatus.Option_Assigned).build();
            allocationMap.put(macID, assignmentInfo);
            return true;
        }
    } else if (freeIPPool.contains(ipAddr)) {
        assignmentInfo = IPAssignment.builder().ipAddress(ipAddr).timestamp(new Date()).leasePeriod(leaseTime).assignmentStatus(IPAssignment.AssignmentStatus.Option_Assigned).build();
        if (freeIPPool.remove(ipAddr)) {
            allocationMap.put(macID, assignmentInfo);
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.TEXT_PLAIN)
public Response createAndAddHost(InputStream stream) {
    try {
        // parse the input stream
        ObjectNode root = (ObjectNode) mapper().readTree(stream);
        // valueOf(root.get("mac").asText());
        MacAddress mac = MacAddress.BROADCAST;
        VlanId vlanId = VlanId.vlanId(((short) root.get("vlan").asInt((VlanId.UNTAGGED))));
        JsonNode location = root.get("location");
        String deviceAndPort = location.get("elementId").asText() + "/" + location.get("port").asText();
        HostLocation hostLocation = new HostLocation(connectPoint(deviceAndPort), 0);
        Iterator<JsonNode> ipStrings = root.get("ipAddresses").elements();
        Set<IpAddress> ips = new HashSet<>();
        while (ipStrings.hasNext()) {
            ips.add(IpAddress.valueOf(ipStrings.next().asText()));
        }
        // add annotations
        SparseAnnotations annotations = annotations(root);
        // update host inventory
        HostId hostId = HostId.hostId(mac, vlanId);
        DefaultHostDescription desc = new DefaultHostDescription(mac, vlanId, hostLocation, ips, annotations);
        // returns 503-service not found . . .
        HostProviderService hostProviderService = get(HostProviderService.class);
        hostProviderService.hostDetected(hostId, desc);
    } catch (IOException | IllegalArgumentException ex) {
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
    }
    return Response.ok().build();
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createAndAddHost(InputStream stream) {
    URI location;
    try {
        // Parse the input stream
        ObjectNode root = (ObjectNode) mapper().readTree(stream);
        HostProviderRegistry hostProviderRegistry = get(HostProviderRegistry.class);
        InternalHostProvider hostProvider = new InternalHostProvider(hostProviderRegistry);
        hostProvider.register();
        HostId hostId = hostProvider.parseHost(root);
        UriBuilder locationBuilder = uriInfo.getBaseUriBuilder().path("hosts").path(hostId.mac().toString()).path(hostId.vlanId().toString());
        location = locationBuilder.build();
        hostProvider.unregister();
    } catch (IOException ex) {
        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
    }
    return Response.created(location).build();
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{appId}/{key}")
public Response getIntentById(@PathParam("appId") Short appId, @PathParam("key") String key) {
    final ApplicationId app = get(CoreService.class).getAppId(appId);
    Intent intent = get(IntentService.class).getIntent(Key.of(key, app));
    if (intent == null) {
        long numericalKey = Long.decode(key);
        intent = get(IntentService.class).getIntent(Key.of(numericalKey, app));
    }
    nullIsNotFound(intent, INTENT_NOT_FOUND);
    final ObjectNode root;
    if (intent instanceof HostToHostIntent) {
        root = codec(HostToHostIntent.class).encode((HostToHostIntent) intent, this);
    } else if (intent instanceof PointToPointIntent) {
        root = codec(PointToPointIntent.class).encode((PointToPointIntent) intent, this);
    } else {
        root = codec(Intent.class).encode(intent, this);
    }
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{appId}/{key}")
public Response getIntentById(@PathParam("appId") String appId, @PathParam("key") String key) {
    final ApplicationId app = get(CoreService.class).getAppId(appId);
    Intent intent = get(IntentService.class).getIntent(Key.of(key, app));
    if (intent == null) {
        long numericalKey = Long.decode(key);
        intent = get(IntentService.class).getIntent(Key.of(numericalKey, app));
    }
    nullIsNotFound(intent, INTENT_NOT_FOUND);
    final ObjectNode root;
    if (intent instanceof HostToHostIntent) {
        root = codec(HostToHostIntent.class).encode((HostToHostIntent) intent, this);
    } else if (intent instanceof PointToPointIntent) {
        root = codec(PointToPointIntent.class).encode((PointToPointIntent) intent, this);
    } else {
        root = codec(Intent.class).encode(intent, this);
    }
    return ok(root).build();
}
#end_block

#method_before
@DELETE
@Path("{appId}/{key}")
public void deleteIntentById(@PathParam("appId") Short appId, @PathParam("key") String keyString) {
    final ApplicationId app = get(CoreService.class).getAppId(appId);
    Intent intent = get(IntentService.class).getIntent(Key.of(keyString, app));
    IntentService service = get(IntentService.class);
    if (intent == null) {
        intent = service.getIntent(Key.of(Long.parseLong(keyString), app));
    }
    if (intent == null) {
        // in this case.
        return;
    }
    Key key = intent.key();
    // set up latch and listener to track uninstall progress
    CountDownLatch latch = new CountDownLatch(1);
    IntentListener listener = new DeleteListener(key, latch);
    service.addListener(listener);
    try {
        // request the withdraw
        service.withdraw(intent);
        try {
            latch.await(WITHDRAW_EVENT_TIMEOUT_SECONDS, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.info("REST Delete operation timed out waiting for intent {}", key);
        }
        // double check the state
        IntentState state = service.getIntentState(key);
        if (state == WITHDRAWN || state == FAILED) {
            service.purge(intent);
        }
    } finally {
        // clean up the listener
        service.removeListener(listener);
    }
}
#method_after
@DELETE
@Path("{appId}/{key}")
public void deleteIntentById(@PathParam("appId") String appId, @PathParam("key") String keyString) {
    final ApplicationId app = get(CoreService.class).getAppId(appId);
    Intent intent = get(IntentService.class).getIntent(Key.of(keyString, app));
    IntentService service = get(IntentService.class);
    if (intent == null) {
        intent = service.getIntent(Key.of(Long.parseLong(keyString), app));
    }
    if (intent == null) {
        // in this case.
        return;
    }
    Key key = intent.key();
    // set up latch and listener to track uninstall progress
    CountDownLatch latch = new CountDownLatch(1);
    IntentListener listener = new DeleteListener(key, latch);
    service.addListener(listener);
    try {
        // request the withdraw
        service.withdraw(intent);
        try {
            latch.await(WITHDRAW_EVENT_TIMEOUT_SECONDS, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.info("REST Delete operation timed out waiting for intent {}", key);
        }
        // double check the state
        IntentState state = service.getIntentState(key);
        if (state == WITHDRAWN || state == FAILED) {
            service.purge(intent);
        }
    } finally {
        // clean up the listener
        service.removeListener(listener);
    }
}
#end_block

#method_before
@Override
public boolean matchesSafely(JsonNode jsonIntent, Description description) {
    // check id
    final String jsonId = jsonIntent.get("id").asText();
    final String id = intent.id().toString();
    if (!jsonId.equals(id)) {
        description.appendText("id was " + jsonId);
        return false;
    }
    // check application id
    final JsonNode jsonAppIdNode = jsonIntent.get("appId");
    final String jsonAppId = jsonAppIdNode.get("id").asText();
    final String appId = Short.toString(intent.appId().id());
    if (!jsonAppId.equals(appId)) {
        description.appendText("appId was " + jsonAppId);
        return false;
    }
    // check intent type
    final String jsonType = jsonIntent.get("type").asText();
    final String type = intent.getClass().getSimpleName();
    if (!jsonType.equals(type)) {
        description.appendText("type was " + jsonType);
        return false;
    }
    // check resources array
    final JsonNode jsonResources = jsonIntent.get("resources");
    if (intent.resources() != null) {
        if (intent.resources().size() != jsonResources.size()) {
            description.appendText("resources array size was " + Integer.toString(jsonResources.size()));
            return false;
        }
        for (final NetworkResource resource : intent.resources()) {
            boolean resourceFound = false;
            final String resourceString = resource.toString();
            for (int resourceIndex = 0; resourceIndex < jsonResources.size(); resourceIndex++) {
                final JsonNode value = jsonResources.get(resourceIndex);
                if (value.asText().equals(resourceString)) {
                    resourceFound = true;
                }
            }
            if (!resourceFound) {
                description.appendText("resource missing " + resourceString);
                return false;
            }
        }
    } else if (jsonResources.size() != 0) {
        description.appendText("resources array empty");
        return false;
    }
    if (intent instanceof ConnectivityIntent) {
        return matchConnectivityIntent(jsonIntent, description);
    } else {
        description.appendText("class of intent is unknown");
        return false;
    }
}
#method_after
@Override
public boolean matchesSafely(JsonNode jsonIntent, Description description) {
    // check id
    final String jsonId = jsonIntent.get("id").asText();
    final String id = intent.id().toString();
    if (!jsonId.equals(id)) {
        description.appendText("id was " + jsonId);
        return false;
    }
    // check application id
    final JsonNode jsonAppIdNode = jsonIntent.get("appId");
    final String jsonAppId = jsonAppIdNode.asText();
    final String appId = intent.appId().name();
    if (!jsonAppId.equals(appId)) {
        description.appendText("appId was " + jsonAppId);
        return false;
    }
    // check intent type
    final String jsonType = jsonIntent.get("type").asText();
    final String type = intent.getClass().getSimpleName();
    if (!jsonType.equals(type)) {
        description.appendText("type was " + jsonType);
        return false;
    }
    // check resources array
    final JsonNode jsonResources = jsonIntent.get("resources");
    if (intent.resources() != null) {
        if (intent.resources().size() != jsonResources.size()) {
            description.appendText("resources array size was " + Integer.toString(jsonResources.size()));
            return false;
        }
        for (final NetworkResource resource : intent.resources()) {
            boolean resourceFound = false;
            final String resourceString = resource.toString();
            for (int resourceIndex = 0; resourceIndex < jsonResources.size(); resourceIndex++) {
                final JsonNode value = jsonResources.get(resourceIndex);
                if (value.asText().equals(resourceString)) {
                    resourceFound = true;
                }
            }
            if (!resourceFound) {
                description.appendText("resource missing " + resourceString);
                return false;
            }
        }
    } else if (jsonResources.size() != 0) {
        description.appendText("resources array empty");
        return false;
    }
    if (intent instanceof ConnectivityIntent) {
        return matchConnectivityIntent(jsonIntent, description);
    } else {
        description.appendText("class of intent is unknown");
        return false;
    }
}
#end_block

#method_before
@Override
public boolean matchesSafely(JsonObject jsonIntent) {
    // check id
    final String jsonId = jsonIntent.get("id").asString();
    if (!jsonId.equals(intent.id().toString())) {
        reason = "id " + intent.id().toString();
        return false;
    }
    // check application id
    final JsonObject jsonAppIdNode = jsonIntent.get("appId").asObject();
    final short jsonAppId = (short) (jsonAppIdNode.get("id").asInt());
    final short appId = intent.appId().id();
    if (jsonAppId != appId) {
        reason = "appId was " + jsonAppId;
        return false;
    }
    // check intent type
    final String jsonType = jsonIntent.get("type").asString();
    if (!jsonType.equals("MockIntent")) {
        reason = "type MockIntent";
        return false;
    }
    // check state field
    final String jsonState = jsonIntent.get("state").asString();
    if (!jsonState.equals("INSTALLED")) {
        reason = "state INSTALLED";
        return false;
    }
    // check resources array
    final JsonArray jsonResources = jsonIntent.get("resources").asArray();
    if (intent.resources() != null) {
        if (intent.resources().size() != jsonResources.size()) {
            reason = "resources array size of " + Integer.toString(intent.resources().size());
            return false;
        }
        for (final NetworkResource resource : intent.resources()) {
            boolean resourceFound = false;
            final String resourceString = resource.toString();
            for (int resourceIndex = 0; resourceIndex < jsonResources.size(); resourceIndex++) {
                final JsonValue value = jsonResources.get(resourceIndex);
                if (value.asString().equals(resourceString)) {
                    resourceFound = true;
                }
            }
            if (!resourceFound) {
                reason = "resource " + resourceString;
                return false;
            }
        }
    } else if (jsonResources.size() != 0) {
        reason = "resources array empty";
        return false;
    }
    return true;
}
#method_after
@Override
public boolean matchesSafely(JsonObject jsonIntent) {
    // check id
    final String jsonId = jsonIntent.get("id").asString();
    if (!jsonId.equals(intent.id().toString())) {
        reason = "id " + intent.id().toString();
        return false;
    }
    // check application id
    final String jsonAppId = jsonIntent.get("appId").asString();
    final String appId = intent.appId().name();
    if (!jsonAppId.equals(appId)) {
        reason = "appId was " + jsonAppId;
        return false;
    }
    // check intent type
    final String jsonType = jsonIntent.get("type").asString();
    if (!jsonType.equals("MockIntent")) {
        reason = "type MockIntent";
        return false;
    }
    // check state field
    final String jsonState = jsonIntent.get("state").asString();
    if (!jsonState.equals("INSTALLED")) {
        reason = "state INSTALLED";
        return false;
    }
    // check resources array
    final JsonArray jsonResources = jsonIntent.get("resources").asArray();
    if (intent.resources() != null) {
        if (intent.resources().size() != jsonResources.size()) {
            reason = "resources array size of " + Integer.toString(intent.resources().size());
            return false;
        }
        for (final NetworkResource resource : intent.resources()) {
            boolean resourceFound = false;
            final String resourceString = resource.toString();
            for (int resourceIndex = 0; resourceIndex < jsonResources.size(); resourceIndex++) {
                final JsonValue value = jsonResources.get(resourceIndex);
                if (value.asString().equals(resourceString)) {
                    resourceFound = true;
                }
            }
            if (!resourceFound) {
                reason = "resource " + resourceString;
                return false;
            }
        }
    } else if (jsonResources.size() != 0) {
        reason = "resources array empty";
        return false;
    }
    return true;
}
#end_block

#method_before
@Test
public void testIntentsSingle() {
    final HashSet<NetworkResource> resources = new HashSet<>();
    resources.add(new MockResource(1));
    resources.add(new MockResource(2));
    resources.add(new MockResource(3));
    final Intent intent = new MockIntent(3L, resources);
    intents.add(intent);
    expect(mockIntentService.getIntent(Key.of(0, APP_ID))).andReturn(intent).anyTimes();
    expect(mockIntentService.getIntent(Key.of("0", APP_ID))).andReturn(intent).anyTimes();
    replay(mockIntentService);
    expect(mockCoreService.getAppId(APP_ID.id())).andReturn(APP_ID).anyTimes();
    replay(mockCoreService);
    final WebResource rs = resource();
    final String response = rs.path("intents/1/0").get(String.class);
    final JsonObject result = JsonObject.readFrom(response);
    assertThat(result, matchesIntent(intent));
}
#method_after
@Test
public void testIntentsSingle() {
    final HashSet<NetworkResource> resources = new HashSet<>();
    resources.add(new MockResource(1));
    resources.add(new MockResource(2));
    resources.add(new MockResource(3));
    final Intent intent = new MockIntent(3L, resources);
    intents.add(intent);
    expect(mockIntentService.getIntent(Key.of(0, APP_ID))).andReturn(intent).anyTimes();
    expect(mockIntentService.getIntent(Key.of("0", APP_ID))).andReturn(intent).anyTimes();
    replay(mockIntentService);
    expect(mockCoreService.getAppId(APP_ID.name())).andReturn(APP_ID).anyTimes();
    replay(mockCoreService);
    final WebResource rs = resource();
    final String response = rs.path("intents/" + APP_ID.name() + "/0").get(String.class);
    final JsonObject result = JsonObject.readFrom(response);
    assertThat(result, matchesIntent(intent));
}
#end_block

#method_before
@Test
public void testPost() {
    expect(mockCoreService.getAppId((short) 2)).andReturn(new DefaultApplicationId(2, "app"));
    replay(mockCoreService);
    mockIntentService.submit(anyObject());
    expectLastCall();
    replay(mockIntentService);
    InputStream jsonStream = IntentsResourceTest.class.getResourceAsStream("post-intent.json");
    WebResource rs = resource();
    ClientResponse response = rs.path("intents").type(MediaType.APPLICATION_JSON_TYPE).post(ClientResponse.class, jsonStream);
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_CREATED));
    String location = response.getLocation().getPath();
    assertThat(location, Matchers.startsWith("/intents/2/"));
}
#method_after
@Test
public void testPost() {
    ApplicationId testId = new DefaultApplicationId(2, "myApp");
    expect(mockCoreService.getAppId("myApp")).andReturn(testId);
    replay(mockCoreService);
    mockIntentService.submit(anyObject());
    expectLastCall();
    replay(mockIntentService);
    InputStream jsonStream = IntentsResourceTest.class.getResourceAsStream("post-intent.json");
    WebResource rs = resource();
    ClientResponse response = rs.path("intents").type(MediaType.APPLICATION_JSON_TYPE).post(ClientResponse.class, jsonStream);
    assertThat(response.getStatus(), is(HttpURLConnection.HTTP_CREATED));
    String location = response.getLocation().getPath();
    assertThat(location, Matchers.startsWith("/intents/2/"));
}
#end_block

#method_before
@Override
public ObjectNode encode(Intent intent, CodecContext context) {
    checkNotNull(intent, "Intent cannot be null");
    JsonNode appIdNode = context.codec(ApplicationId.class).encode(intent.appId(), context);
    final ObjectNode result = context.mapper().createObjectNode().put(TYPE, intent.getClass().getSimpleName()).put(ID, intent.id().toString());
    result.set(APP_ID, appIdNode);
    final ArrayNode jsonResources = result.putArray(RESOURCES);
    for (final NetworkResource resource : intent.resources()) {
        jsonResources.add(resource.toString());
    }
    IntentService service = context.getService(IntentService.class);
    IntentState state = service.getIntentState(intent.key());
    if (state != null) {
        result.put(STATE, state.toString());
    }
    return result;
}
#method_after
@Override
public ObjectNode encode(Intent intent, CodecContext context) {
    checkNotNull(intent, "Intent cannot be null");
    final ObjectNode result = context.mapper().createObjectNode().put(TYPE, intent.getClass().getSimpleName()).put(ID, intent.id().toString()).put(APP_ID, UrlEscapers.urlPathSegmentEscaper().escape(intent.appId().name()));
    final ArrayNode jsonResources = result.putArray(RESOURCES);
    for (final NetworkResource resource : intent.resources()) {
        jsonResources.add(resource.toString());
    }
    IntentService service = context.getService(IntentService.class);
    IntentState state = service.getIntentState(intent.key());
    if (state != null) {
        result.put(STATE, state.toString());
    }
    return result;
}
#end_block

#method_before
public static void intentAttributes(ObjectNode json, CodecContext context, Intent.Builder builder) {
    short appId = (short) nullIsIllegal(json.get(IntentCodec.APP_ID), IntentCodec.TYPE + IntentCodec.MISSING_MEMBER_MESSAGE).asInt();
    CoreService service = context.getService(CoreService.class);
    builder.appId(service.getAppId(appId));
    JsonNode priorityJson = json.get(IntentCodec.PRIORITY);
    if (priorityJson != null) {
        builder.priority(priorityJson.asInt());
    }
}
#method_after
public static void intentAttributes(ObjectNode json, CodecContext context, Intent.Builder builder) {
    String appId = nullIsIllegal(json.get(IntentCodec.APP_ID), IntentCodec.APP_ID + IntentCodec.MISSING_MEMBER_MESSAGE).asText();
    CoreService service = context.getService(CoreService.class);
    builder.appId(service.getAppId(appId));
    JsonNode priorityJson = json.get(IntentCodec.PRIORITY);
    if (priorityJson != null) {
        builder.priority(priorityJson.asInt());
    }
}
#end_block

#method_before
private void fixBlackhole(ConnectPoint egress) {
    Set<FlowEntry> rules = getFlowRulesFrom(egress);
    Set<SrcDstPair> pairs = findSrcDstPairs(rules);
    Map<DeviceId, Set<Path>> srcPaths = new HashMap<>();
    for (SrcDstPair sd : pairs) {
        // get the edge deviceID for the src host
        DeviceId srcId = hostService.getHost(HostId.hostId(sd.src)).location().deviceId();
        DeviceId dstId = hostService.getHost(HostId.hostId(sd.dst)).location().deviceId();
        log.trace("SRC ID is " + srcId + ", DST ID is " + dstId);
        cleanFlowRules(sd, egress.deviceId());
        Set<Path> shortestPaths = srcPaths.get(srcId);
        if (shortestPaths == null) {
            shortestPaths = topologyService.getPaths(topologyService.currentTopology(), egress.deviceId(), srcId);
            srcPaths.put(srcId, shortestPaths);
            log.trace("Didn't find a shortest path back to the src for SRC=" + sd.src);
        } else {
            log.trace("Found a shortest path back to the src for SRC=" + sd.src);
        }
        backTrackBadNodes(shortestPaths, dstId, sd);
    }
}
#method_after
private void fixBlackhole(ConnectPoint egress) {
    Set<FlowEntry> rules = getFlowRulesFrom(egress);
    Set<SrcDstPair> pairs = findSrcDstPairs(rules);
    Map<DeviceId, Set<Path>> srcPaths = new HashMap<>();
    for (SrcDstPair sd : pairs) {
        // get the edge deviceID for the src host
        DeviceId srcId = hostService.getHost(HostId.hostId(sd.src)).location().deviceId();
        DeviceId dstId = hostService.getHost(HostId.hostId(sd.dst)).location().deviceId();
        log.trace("SRC ID is " + srcId + ", DST ID is " + dstId);
        cleanFlowRules(sd, egress.deviceId());
        Set<Path> shortestPaths = srcPaths.get(srcId);
        if (shortestPaths == null) {
            shortestPaths = topologyService.getPaths(topologyService.currentTopology(), egress.deviceId(), srcId);
            srcPaths.put(srcId, shortestPaths);
        }
        backTrackBadNodes(shortestPaths, dstId, sd);
    }
}
#end_block

#method_before
@Override
public Result<V, E> search(Graph<V, E> graph, V src, V dst, EdgeWeight<V, E> weight, int maxPaths) {
    if (maxPaths == ALL_PATHS) {
        maxPaths = POPSIZE;
    }
    if (useSuurballe) {
        return new SuurballeGraphSearch<V, E>().search(graph, src, dst, weight, ALL_PATHS);
    }
    if (weight == null) {
        weight = new EdgeWeight<V, E>() {

            public double weight(E edge) {
                return 1;
            }
        };
    }
    checkArguments(graph, src, dst);
    orig = graph;
    this.src = src;
    this.dst = dst;
    this.weight = weight;
    List<Subset> best = new GAPopulation<Subset>().runGA(ITERATIONS, POPSIZE, maxPaths, new Subset(new boolean[numGroups]));
    Set<DisjointPathPair> dpps = new HashSet<DisjointPathPair>();
    for (Subset s : best) {
        dpps.addAll(s.buildPaths());
    }
    Result<V, E> firstDijkstra = new DijkstraGraphSearch<V, E>().search(orig, src, dst, weight, 1);
    return new Result<V, E>() {

        final DefaultResult search = (DefaultResult) firstDijkstra;

        public V src() {
            return src;
        }

        public V dst() {
            return dst;
        }

        public Set<Path<V, E>> paths() {
            Set<Path<V, E>> pathsD = new HashSet<>();
            for (DisjointPathPair<V, E> path : dpps) {
                pathsD.add((Path<V, E>) path);
            }
            return pathsD;
        }

        public Map<V, Double> costs() {
            return search.costs();
        }

        public Map<V, Set<E>> parents() {
            return search.parents();
        }
    };
}
#method_after
@Override
public Result<V, E> search(Graph<V, E> graph, V src, V dst, EdgeWeight<V, E> weight, int maxPaths) {
    if (maxPaths == ALL_PATHS) {
        maxPaths = POPSIZE;
    }
    if (useSuurballe) {
        return new SuurballeGraphSearch<V, E>().search(graph, src, dst, weight, ALL_PATHS);
    }
    if (weight == null) {
        weight = edge -> 1;
    }
    checkArguments(graph, src, dst);
    orig = graph;
    this.src = src;
    this.dst = dst;
    this.weight = weight;
    List<Subset> best = new GAPopulation<Subset>().runGA(ITERATIONS, POPSIZE, maxPaths, new Subset(new boolean[numGroups]));
    Set<DisjointPathPair> dpps = new HashSet<DisjointPathPair>();
    for (Subset s : best) {
        dpps.addAll(s.buildPaths());
    }
    Result<V, E> firstDijkstra = new DijkstraGraphSearch<V, E>().search(orig, src, dst, weight, 1);
    return new Result<V, E>() {

        final DefaultResult search = (DefaultResult) firstDijkstra;

        public V src() {
            return src;
        }

        public V dst() {
            return dst;
        }

        public Set<Path<V, E>> paths() {
            Set<Path<V, E>> pathsD = new HashSet<>();
            for (DisjointPathPair<V, E> path : dpps) {
                pathsD.add(path);
            }
            return pathsD;
        }

        public Map<V, Double> costs() {
            return search.costs();
        }

        public Map<V, Set<E>> parents() {
            return search.parents();
        }
    };
}
#end_block

#method_before
public Result<V, E> findShortestPathFromSubset(boolean[] subset) {
    MutableGraph<V, E> graph = new MutableAdjacencyListsGraph<V, E>(orig.getVertexes(), new HashSet<E>());
    for (E edge : orig.getEdges()) {
        if (subset[riskGrouping.get(edge)]) {
            graph.addEdge(edge);
        }
    }
    Result<V, E> res = new DijkstraGraphSearch<V, E>().search(graph, src, dst, weight, 1);
    return res;
}
#method_after
private Result<V, E> findShortestPathFromSubset(boolean[] subset) {
    Graph<V, E> graph = orig;
    EdgeWeight<V, E> modified = new EdgeWeight<V, E>() {

        final boolean[] subsetF = subset;

        @Override
        public double weight(E edge) {
            if (subsetF[riskGrouping.get(edge)]) {
                return weight.weight(edge);
            }
            return INF;
        }
    };
    Result<V, E> res = new DijkstraGraphSearch<V, E>().search(graph, src, dst, modified, 1);
    return res;
}
#end_block

#method_before
public double fitness() {
    Set<Path<V, E>> paths1 = findShortestPathFromSubset(subset).paths();
    Set<Path<V, E>> paths2 = findShortestPathFromSubset(not).paths();
    if (paths1.size() == 0 || paths2.size() == 0) {
        return INF;
    }
    return paths1.iterator().next().cost() + paths2.iterator().next().cost();
}
#method_after
@Override
public double fitness() {
    Set<Path<V, E>> paths1 = findShortestPathFromSubset(subset).paths();
    Set<Path<V, E>> paths2 = findShortestPathFromSubset(not).paths();
    if (paths1.size() == 0 || paths2.size() == 0) {
        return INF;
    }
    return paths1.iterator().next().cost() + paths2.iterator().next().cost();
}
#end_block

#method_before
public void mutate() {
    int turns = r.nextInt((int) Math.sqrt(subset.length));
    while (turns > 0) {
        int choose = r.nextInt(subset.length);
        subset[choose] = !subset[choose];
        not[choose] = !not[choose];
        turns--;
    }
}
#method_after
@Override
public void mutate() {
    int turns = r.nextInt((int) Math.sqrt(subset.length));
    while (turns > 0) {
        int choose = r.nextInt(subset.length);
        subset[choose] = !subset[choose];
        not[choose] = !not[choose];
        turns--;
    }
}
#end_block

#method_before
public GAOrganism crossWith(GAOrganism org) {
    if (!(org.type().equals("Subset"))) {
        return this;
    }
    Subset other = (Subset) (org);
    boolean[] sub = new boolean[subset.length];
    for (int i = 0; i < subset.length; i++) {
        sub[i] = subset[i];
        if (r.nextBoolean()) {
            sub[i] = other.subset[i];
        }
    }
    return new Subset(sub);
}
#method_after
@Override
public GAOrganism crossWith(GAOrganism org) {
    if (!(org.getClass().equals(getClass()))) {
        return this;
    }
    Subset other = (Subset) (org);
    boolean[] sub = new boolean[subset.length];
    for (int i = 0; i < subset.length; i++) {
        sub[i] = subset[i];
        if (r.nextBoolean()) {
            sub[i] = other.subset[i];
        }
    }
    return new Subset(sub);
}
#end_block

#method_before
public GAOrganism random() {
    boolean[] sub = new boolean[subset.length];
    for (int i = 0; i < sub.length; i++) {
        sub[i] = r.nextBoolean();
    }
    return new Subset(sub);
}
#method_after
@Override
public GAOrganism random() {
    boolean[] sub = new boolean[subset.length];
    for (int i = 0; i < sub.length; i++) {
        sub[i] = r.nextBoolean();
    }
    return new Subset(sub);
}
#end_block

#method_before
public Set<DisjointPathPair> buildPaths() {
    Set<DisjointPathPair> dpps = new HashSet<DisjointPathPair>();
    for (Path<V, E> path1 : findShortestPathFromSubset(subset).paths()) {
        for (Path<V, E> path2 : findShortestPathFromSubset(not).paths()) {
            DisjointPathPair<V, E> dpp = new DisjointPathPair<V, E>(path1, path2);
            dpps.add(dpp);
        }
    }
    return dpps;
}
#method_after
public Set<DisjointPathPair> buildPaths() {
    Set<DisjointPathPair> dpps = new HashSet<>();
    for (Path<V, E> path1 : findShortestPathFromSubset(subset).paths()) {
        if (path1.cost() >= INF) {
            continue;
        }
        for (Path<V, E> path2 : findShortestPathFromSubset(not).paths()) {
            if (path2.cost() >= INF) {
                continue;
            }
            DisjointPathPair<V, E> dpp = new DisjointPathPair<>(path1, path2);
            dpps.add(dpp);
        }
    }
    return dpps;
}
#end_block

#method_before
void step() {
    Collections.sort(this, new Comparator<Organism>() {

        public int compare(Organism org1, Organism org2) {
            double d = org1.fitness() - org2.fitness();
            if (d < 0) {
                return -1;
            } else if (d == 0) {
                return 0;
            }
            return 1;
        }
    });
    int maxSize = size();
    for (int i = size() - 1; i > maxSize / 4; i--) {
        remove(i);
    }
    for (Organism org : this) {
        if (r.nextBoolean()) {
            org.mutate();
        }
    }
    while (size() < maxSize * 4 / 5) {
        Organism org1 = get(r.nextInt(size()));
        Organism org2 = get(r.nextInt(size()));
        add((Organism) org1.crossWith(org2));
    }
    while (size() < maxSize) {
        Organism org1 = get(r.nextInt(size()));
        add((Organism) org1.random());
    }
}
#method_after
void step() {
    Collections.sort(this, (org1, org2) -> {
        double d = org1.fitness() - org2.fitness();
        if (d < 0) {
            return -1;
        } else if (d == 0) {
            return 0;
        }
        return 1;
    });
    int maxSize = size();
    for (int i = size() - 1; i > maxSize / 4; i--) {
        remove(i);
    }
    for (Organism org : this) {
        if (r.nextBoolean()) {
            org.mutate();
        }
    }
    while (size() < maxSize * 4 / 5) {
        Organism org1 = get(r.nextInt(size()));
        Organism org2 = get(r.nextInt(size()));
        add((Organism) org1.crossWith(org2));
    }
    while (size() < maxSize) {
        Organism org1 = get(r.nextInt(size()));
        add((Organism) org1.random());
    }
}
#end_block

#method_before
List<Organism> runGA(int generations, int populationSize, int sample, Organism template) {
    for (int i = 0; i < populationSize; i++) {
        add((Organism) template.random());
    }
    for (int i = 0; i < generations; i++) {
        step();
    }
    for (int i = size() - 1; i >= sample; i--) {
        remove(i);
    }
    return new ArrayList<Organism>(this);
}
#method_after
List<Organism> runGA(int generations, int populationSize, int sample, Organism template) {
    for (int i = 0; i < populationSize; i++) {
        add((Organism) template.random());
    }
    for (int i = 0; i < generations; i++) {
        step();
    }
    for (int i = size() - 1; i >= sample; i--) {
        remove(i);
    }
    return new ArrayList<>(this);
}
#end_block

#method_before
public void checkIsDisjoint(Path<TestVertex, TestEdge> p, Map<TestEdge, Integer> risks) {
    assertTrue("The path is not a DisjointPathPair", (p instanceof DisjointPathPair));
    DisjointPathPair<TestVertex, TestEdge> q = (DisjointPathPair) p;
    Set<Integer> p1Risks = new HashSet<Integer>();
    Set<Integer> p2Risks = new HashSet<Integer>();
    for (TestEdge e : q.edges()) {
        p1Risks.add(risks.get(e));
    }
    if (!q.hasBackup()) {
        return;
    }
    q.useBackup();
    for (TestEdge e : q.edges()) {
        assertTrue("The paths are not disjoint", !p1Risks.contains(risks.get(e)));
    }
}
#method_after
public void checkIsDisjoint(Path<TestVertex, TestEdge> p, Map<TestEdge, Integer> risks) {
    assertTrue("The path is not a DisjointPathPair", (p instanceof DisjointPathPair));
    DisjointPathPair<TestVertex, TestEdge> q = (DisjointPathPair) p;
    Set<Integer> p1Risks = new HashSet<Integer>();
    Set<Integer> p2Risks = new HashSet<Integer>();
    for (TestEdge e : q.edges()) {
        p1Risks.add(risks.get(e));
    }
    if (!q.hasBackup()) {
        return;
    }
    Path<TestVertex, TestEdge> pq = q.path2;
    for (TestEdge e : pq.edges()) {
        assertTrue("The paths are not disjoint", !p1Risks.contains(risks.get(e)));
    }
}
#end_block

#method_before
@Test
public void onePath() {
    setDefaultWeights();
    TestEdge aB = new TestEdge(A, B, 1);
    TestEdge bC = new TestEdge(B, C, 1);
    TestEdge aD = new TestEdge(A, D, 1);
    TestEdge dC = new TestEdge(D, C, 1);
    Graph<TestVertex, TestEdge> graph = new AdjacencyListsGraph<>(of(A, B, C, D), of(aB, bC, aD, dC));
    Map<TestEdge, Integer> riskProfile = new HashMap<TestEdge, Integer>();
    riskProfile.put(aB, 0);
    riskProfile.put(bC, 0);
    riskProfile.put(aD, 1);
    riskProfile.put(dC, 0);
    SRLGGraphSearch<TestVertex, TestEdge> search = new SRLGGraphSearch<TestVertex, TestEdge>(2, riskProfile);
    Set<Path<TestVertex, TestEdge>> paths = search.search(graph, A, C, weight, GraphPathSearch.ALL_PATHS).paths();
    assertTrue("no disjoint path pairs found", paths.size() == 0);
}
#method_after
@Test
public void onePath() {
    setDefaultWeights();
    TestEdge aB = new TestEdge(A, B, 1);
    TestEdge bC = new TestEdge(B, C, 1);
    TestEdge aD = new TestEdge(A, D, 1);
    TestEdge dC = new TestEdge(D, C, 1);
    Graph<TestVertex, TestEdge> graph = new AdjacencyListsGraph<>(of(A, B, C, D), of(aB, bC, aD, dC));
    Map<TestEdge, Integer> riskProfile = new HashMap<TestEdge, Integer>();
    riskProfile.put(aB, 0);
    riskProfile.put(bC, 0);
    riskProfile.put(aD, 1);
    riskProfile.put(dC, 0);
    SRLGGraphSearch<TestVertex, TestEdge> search = new SRLGGraphSearch<TestVertex, TestEdge>(2, riskProfile);
    Set<Path<TestVertex, TestEdge>> paths = search.search(graph, A, C, weight, GraphPathSearch.ALL_PATHS).paths();
    System.out.println(paths);
    assertTrue("no disjoint path pairs found", paths.size() == 0);
}
#end_block

#method_before
private PortDescription buildPortDescription(Port port, PortType portType) {
    PortDescription portDescripton = null;
    switch(portType) {
        case OCH_PORT:
            OchPort ochp = (OchPort) port;
            portDescripton = new OchPortDescription(ochp.number(), ochp.isEnabled(), ochp.signalType(), ochp.isTunable(), ochp.lambda());
            break;
        case ODU_PORT:
            OduCltPort odup = (OduCltPort) port;
            portDescripton = new OduCltPortDescription(odup.number(), odup.isEnabled(), odup.signalType());
            break;
        case OMS_PORT:
            OmsPort op = (OmsPort) port;
            portDescripton = new OmsPortDescription(op.number(), op.isEnabled(), op.minFrequency(), op.maxFrequency(), op.grid());
            break;
        default:
            portDescripton = new DefaultPortDescription(port.number(), port.isEnabled());
            break;
    }
    return portDescripton;
}
#method_after
private PortDescription buildPortDescription(Port port, PortType portType) {
    PortDescription portDescription;
    switch(portType) {
        case OCH_PORT:
            OchPort ochp = (OchPort) port;
            portDescription = new OchPortDescription(ochp.number(), ochp.isEnabled(), ochp.signalType(), ochp.isTunable(), ochp.lambda());
            break;
        case ODU_PORT:
            OduCltPort odup = (OduCltPort) port;
            portDescription = new OduCltPortDescription(odup.number(), odup.isEnabled(), odup.signalType());
            break;
        case OMS_PORT:
            OmsPort op = (OmsPort) port;
            portDescription = new OmsPortDescription(op.number(), op.isEnabled(), op.minFrequency(), op.maxFrequency(), op.grid());
            break;
        default:
            portDescription = new DefaultPortDescription(port.number(), port.isEnabled());
            break;
    }
    return portDescription;
}
#end_block

#method_before
private LinkDescription buildLinkDescription(PcepLink pceLink) {
    LinkDescription ld;
    DeviceId srcDeviceID = deviceId(uri(pceLink.linkSrcDeviceID()));
    DeviceId dstDeviceID = deviceId(uri(pceLink.linkDstDeviceId()));
    deviceProviderService.updatePorts(srcDeviceID, buildPortDescriptions(pceLink.linkSrcDeviceID(), pceLink.linkSrcPort(), pceLink.portType()));
    deviceProviderService.updatePorts(dstDeviceID, buildPortDescriptions(pceLink.linkDstDeviceId(), pceLink.linkDstPort(), pceLink.portType()));
    ConnectPoint src = new ConnectPoint(srcDeviceID, pceLink.linkSrcPort().number());
    ConnectPoint dst = new ConnectPoint(dstDeviceID, pceLink.linkDstPort().number());
    DefaultAnnotations extendedAttributes = buildLinkAnnotations(pceLink);
    // construct the link
    ld = new DefaultLinkDescription(src, dst, Type.OPTICAL, extendedAttributes);
    return ld;
}
#method_after
private LinkDescription buildLinkDescription(PcepLink pceLink) {
    LinkDescription ld;
    checkNotNull(pceLink);
    DeviceId srcDeviceID = deviceId(uri(pceLink.linkSrcDeviceID()));
    DeviceId dstDeviceID = deviceId(uri(pceLink.linkDstDeviceId()));
    deviceProviderService.updatePorts(srcDeviceID, buildPortDescriptions(pceLink.linkSrcDeviceID(), pceLink.linkSrcPort(), pceLink.portType()));
    deviceProviderService.updatePorts(dstDeviceID, buildPortDescriptions(pceLink.linkDstDeviceId(), pceLink.linkDstPort(), pceLink.portType()));
    ConnectPoint src = new ConnectPoint(srcDeviceID, pceLink.linkSrcPort().number());
    ConnectPoint dst = new ConnectPoint(dstDeviceID, pceLink.linkDstPort().number());
    DefaultAnnotations extendedAttributes = DefaultAnnotations.builder().set("subType", String.valueOf(pceLink.linkSubType())).set("workState", pceLink.linkState()).set("distance", String.valueOf(pceLink.linkDistance())).set("capType", pceLink.linkCapacityType().toLowerCase()).set("avail_" + pceLink.linkCapacityType().toLowerCase(), String.valueOf(pceLink.linkAvailValue())).set("max_" + pceLink.linkCapacityType().toLowerCase(), String.valueOf(pceLink.linkMaxValue())).build();
    // construct the link
    ld = new DefaultLinkDescription(src, dst, Type.OPTICAL, extendedAttributes);
    return ld;
}
#end_block

#method_before
@Override
public void switchAdded(PcepDpid dpid) {
    if (deviceProviderService == null) {
        return;
    }
    DeviceId devicdId = deviceId(uri(dpid));
    PcepSwitch sw = controller.getSwitch(dpid);
    checkNotNull(sw, "device should not null.");
    // The default device type is switch.
    ChassisId cId = new ChassisId(dpid.value());
    Device.Type deviceType = null;
    switch(sw.getDeviceType()) {
        case ROADM:
            deviceType = Device.Type.ROADM;
            break;
        case OTN:
            deviceType = Device.Type.SWITCH;
            break;
        case ROUTER:
            deviceType = Device.Type.ROUTER;
            break;
        default:
            deviceType = Device.Type.OTHER;
    }
    DeviceDescription description = new DefaultDeviceDescription(devicdId.uri(), deviceType, sw.manufacturerDescription(), sw.hardwareDescription(), sw.softwareDescription(), sw.serialNumber(), cId);
    deviceProviderService.deviceConnected(devicdId, description);
}
#method_after
@Override
public void switchAdded(PcepDpid dpid) {
    if (deviceProviderService == null) {
        return;
    }
    DeviceId deviceId = deviceId(uri(dpid));
    PcepSwitch sw = controller.getSwitch(dpid);
    checkNotNull(sw, "device should not null.");
    // The default device type is switch.
    ChassisId cId = new ChassisId(dpid.value());
    Device.Type deviceType;
    switch(sw.getDeviceType()) {
        case ROADM:
            deviceType = Device.Type.ROADM;
            break;
        case OTN:
            deviceType = Device.Type.SWITCH;
            break;
        case ROUTER:
            deviceType = Device.Type.ROUTER;
            break;
        default:
            deviceType = Device.Type.OTHER;
    }
    DeviceDescription description = new DefaultDeviceDescription(deviceId.uri(), deviceType, sw.manufacturerDescription(), sw.hardwareDescription(), sw.softwareDescription(), sw.serialNumber(), cId);
    deviceProviderService.deviceConnected(deviceId, description);
}
#end_block

#method_before
@Override
public void handlePCEPlink(PcepLink link) {
    OperationType operType = link.getOperationType();
    LinkDescription ld = buildLinkDescription(link);
    if (ld == null) {
        log.error("Invalid link info.");
        return;
    }
    switch(operType) {
        case ADD:
            linkProviderService.linkDetected(ld);
            break;
        case UPDATE:
            processLinkUpdate(ld);
            break;
        case DELETE:
            linkProviderService.linkVanished(ld);
            break;
        default:
            break;
    }
}
#method_after
@Override
public void handlePCEPlink(PcepLink link) {
    OperationType operType = link.getOperationType();
    LinkDescription ld = buildLinkDescription(link);
    if (ld == null) {
        log.error("Invalid link info.");
        return;
    }
    switch(operType) {
        case ADD:
        case UPDATE:
            linkProviderService.linkDetected(ld);
            break;
        case DELETE:
            linkProviderService.linkVanished(ld);
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.segmentrouting");
    kryoBuilder = new KryoNamespace.Builder().register(NeighborSetNextObjectiveStoreKey.class, NeighborSet.class, DeviceId.class, URI.class, WallClockTimestamp.class, org.onosproject.cluster.NodeId.class, HashSet.class, Tunnel.class, DefaultTunnel.class, Policy.class, TunnelPolicy.class, Policy.Type.class);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(kryoBuilder).withClockService(new WallclockClockManager<>()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(kryoBuilder).withClockService(new WallclockClockManager<>()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(kryoBuilder).withClockService(new WallclockClockManager<>()).build();
    networkConfigService.init();
    deviceConfiguration = new DeviceConfiguration(networkConfigService);
    arpHandler = new ArpHandler(this);
    icmpHandler = new IcmpHandler(this);
    ipHandler = new IpHandler(this);
    routingRulePopulator = new RoutingRulePopulator(this);
    defaultRoutingHandler = new DefaultRoutingHandler(this);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    packetService.addProcessor(processor, PacketProcessor.ADVISOR_MAX + 2);
    linkService.addListener(new InternalLinkListener());
    deviceService.addListener(new InternalDeviceListener());
    for (Device device : deviceService.getDevices()) {
        // Irrespective whether the local is a MASTER or not for this device,
        // create group handler instance and push default TTP flow rules.
        // Because in a multi-instance setup, instances can initiate
        // groups for any devices. Also the default TTP rules are needed
        // to be pushed before inserting any IP table entries for any device
        DefaultGroupHandler groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore);
        groupHandlerMap.put(device.id(), groupHandler);
        defaultRoutingHandler.populateTtpRules(device.id());
    }
    defaultRoutingHandler.startPopulationProcess();
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication("org.onosproject.segmentrouting");
    kryoBuilder = new KryoNamespace.Builder().register(NeighborSetNextObjectiveStoreKey.class, NeighborSet.class, DeviceId.class, URI.class, WallClockTimestamp.class, org.onosproject.cluster.NodeId.class, HashSet.class, Tunnel.class, DefaultTunnel.class, Policy.class, TunnelPolicy.class, Policy.Type.class);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<NeighborSetNextObjectiveStoreKey, Integer> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    nsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", nsNextObjStore.size());
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(kryoBuilder).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    networkConfigService.init();
    deviceConfiguration = new DeviceConfiguration(networkConfigService);
    arpHandler = new ArpHandler(this);
    icmpHandler = new IcmpHandler(this);
    ipHandler = new IpHandler(this);
    routingRulePopulator = new RoutingRulePopulator(this);
    defaultRoutingHandler = new DefaultRoutingHandler(this);
    tunnelHandler = new TunnelHandler(linkService, deviceConfiguration, groupHandlerMap, tunnelStore);
    policyHandler = new PolicyHandler(appId, deviceConfiguration, flowObjectiveService, tunnelHandler, policyStore);
    packetService.addProcessor(processor, PacketProcessor.ADVISOR_MAX + 2);
    linkService.addListener(new InternalLinkListener());
    deviceService.addListener(new InternalDeviceListener());
    for (Device device : deviceService.getDevices()) {
        // Irrespective whether the local is a MASTER or not for this device,
        // create group handler instance and push default TTP flow rules.
        // Because in a multi-instance setup, instances can initiate
        // groups for any devices. Also the default TTP rules are needed
        // to be pushed before inserting any IP table entries for any device
        DefaultGroupHandler groupHandler = DefaultGroupHandler.createGroupHandler(device.id(), appId, deviceConfiguration, linkService, flowObjectiveService, nsNextObjStore);
        groupHandlerMap.put(device.id(), groupHandler);
        defaultRoutingHandler.populateTtpRules(device.id());
    }
    defaultRoutingHandler.startPopulationProcess();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    packetService.removeProcessor(processor);
    TrafficSelector.Builder selectorServer = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_UDP).matchUdpDst(UDP.DHCP_SERVER_PORT).matchUdpSrc(UDP.DHCP_CLIENT_PORT);
    packetService.cancelPackets(selectorServer.build(), PacketPriority.CONTROL, appId);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    // can't do any more to it.
    if (context.isHandled()) {
        return;
    }
    Ethernet packet = context.inPacket().parsed();
    if (packet == null) {
        return;
    }
    if (packet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) packet.getPayload();
        if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_UDP) {
            UDP udpPacket = (UDP) ipv4Packet.getPayload();
            if (udpPacket.getDestinationPort() == UDP.DHCP_SERVER_PORT && udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT) {
                // This is meant for the dhcp server so process the packet here.
                DHCP dhcpPayload = (DHCP) udpPacket.getPayload();
                boolean flagIfRequestedIP = false;
                boolean flagIfServerIP = false;
                Ip4Address requestedIP = Ip4Address.valueOf("0.0.0.0");
                Ip4Address serverIP = Ip4Address.valueOf("0.0.0.0");
                if (dhcpPayload != null) {
                    byte incomingPacketType = 0;
                    for (DHCPOption temp : dhcpPayload.getOptions()) {
                        if (temp.getCode() == DHCP.DHCPOptionCode.OptionCode_MessageType.getValue()) {
                            byte[] data = temp.getData();
                            incomingPacketType = data[0];
                        }
                        if (temp.getCode() == DHCP.DHCPOptionCode.OptionCode_RequestedIP.getValue()) {
                            byte[] data = temp.getData();
                            requestedIP = Ip4Address.valueOf(data);
                            flagIfRequestedIP = true;
                        }
                        if (temp.getCode() == DHCP.DHCPOptionCode.OptionCode_DHCPServerIp.getValue()) {
                            byte[] data = temp.getData();
                            serverIP = Ip4Address.valueOf(data);
                            flagIfServerIP = true;
                        }
                    }
                    String ipOffered = "";
                    byte outgoingPacketType = 0;
                    MacAddress clientMAC = new MacAddress(dhcpPayload.getClientHardwareAddress());
                    if (incomingPacketType == DHCP.DHCPMessageType.MessageType_Discover.getValue()) {
                        outgoingPacketType = DHCP.DHCPMessageType.MessageType_Offer.getValue();
                        ipOffered = dhcpStore.suggestIP(clientMAC).toString();
                        Ethernet ethReply = buildReply(packet, ipOffered, outgoingPacketType);
                        sendReply(context, ethReply);
                    } else if (incomingPacketType == DHCP.DHCPMessageType.MessageType_Request.getValue()) {
                        outgoingPacketType = DHCP.DHCPMessageType.MessageType_ACK.getValue();
                        if (flagIfServerIP && flagIfRequestedIP) {
                            // SELECTING state
                            if (MY_IP.equals(serverIP.toString()) && dhcpStore.assignIP(clientMAC, requestedIP, leaseTime)) {
                                Ethernet ethReply = buildReply(packet, requestedIP.toString(), outgoingPacketType);
                                sendReply(context, ethReply);
                            }
                        } else if (flagIfRequestedIP) {
                            // INIT-REBOOT state
                            if (dhcpStore.assignIP(clientMAC, requestedIP, leaseTime)) {
                                Ethernet ethReply = buildReply(packet, requestedIP.toString(), outgoingPacketType);
                                sendReply(context, ethReply);
                            }
                        } else {
                            // RENEWING and REBINDING state
                            int ciaadr = dhcpPayload.getClientIPAddress();
                            if (ciaadr != 0) {
                                Ip4Address clientIaddr = Ip4Address.valueOf(ciaadr);
                                if (dhcpStore.assignIP(clientMAC, clientIaddr, leaseTime)) {
                                    Ethernet ethReply = buildReply(packet, clientIaddr.toString(), outgoingPacketType);
                                    sendReply(context, ethReply);
                                }
                            }
                        }
                    } else if (incomingPacketType == DHCP.DHCPMessageType.MessageType_Release.getValue()) {
                        dhcpStore.releaseIP(clientMAC);
                    }
                }
            }
        }
    }
}
#method_after
@Override
public void process(PacketContext context) {
    // can't do any more to it.
    if (context.isHandled()) {
        return;
    }
    Ethernet packet = context.inPacket().parsed();
    if (packet == null) {
        return;
    }
    if (packet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) packet.getPayload();
        if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_UDP) {
            UDP udpPacket = (UDP) ipv4Packet.getPayload();
            if (udpPacket.getDestinationPort() == UDP.DHCP_SERVER_PORT && udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT) {
                // This is meant for the dhcp server so process the packet here.
                DHCP dhcpPayload = (DHCP) udpPacket.getPayload();
                processDHCPPacket(context, dhcpPayload);
            }
        }
    }
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    timeout.cancel();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public Ip4Address suggestIP(MacAddress macID) {
    IPAssignment assignmentInfo;
    if (allocationMap.containsKey(macID)) {
        assignmentInfo = allocationMap.get(macID).value();
        return assignmentInfo.getIpAddress();
    } else {
        Ip4Address nextIPAddr = fetchNextIP();
        assignmentInfo = new IPAssignment(nextIPAddr, defaultTimeout, IPAssignment.AssignmentStatus.Option_Requested);
        allocationMap.put(macID, assignmentInfo);
        return nextIPAddr;
    }
}
#method_after
@Override
public Ip4Address suggestIP(MacAddress macID) {
    IPAssignment assignmentInfo;
    if (allocationMap.containsKey(macID)) {
        assignmentInfo = allocationMap.get(macID).value();
        return assignmentInfo.getIpAddress();
    } else {
        Ip4Address nextIPAddr = fetchNextIP();
        assignmentInfo = new IPAssignment(nextIPAddr, timeoutForPendingAssignments, IPAssignment.AssignmentStatus.Option_Requested);
        allocationMap.put(macID, assignmentInfo);
        return nextIPAddr;
    }
}
#end_block

#method_before
@Override
public boolean assignIP(MacAddress macID, Ip4Address ipAddr, long leaseTime) {
    IPAssignment assignmentInfo;
    if (allocationMap.containsKey(macID)) {
        assignmentInfo = allocationMap.get(macID).value();
        if (assignmentInfo.getIpAddress().toInt() == ipAddr.toInt()) {
            assignmentInfo.setAssignmentStatus(IPAssignment.AssignmentStatus.Option_Assigned);
            assignmentInfo.setTimestamp(new Date());
            assignmentInfo.setLeasePeriodinSeconds(leaseTime);
            allocationMap.put(macID, assignmentInfo);
            return true;
        }
    } else if (freeIPPool.contains(ipAddr)) {
        assignmentInfo = new IPAssignment(ipAddr, leaseTime, IPAssignment.AssignmentStatus.Option_Assigned);
        freeIPPool.remove(ipAddr);
        allocationMap.put(macID, assignmentInfo);
        return true;
    }
    return false;
}
#method_after
@Override
public boolean assignIP(MacAddress macID, Ip4Address ipAddr, long leaseTime) {
    IPAssignment assignmentInfo;
    if (allocationMap.containsKey(macID)) {
        assignmentInfo = allocationMap.get(macID).value();
        if (assignmentInfo.getIpAddress().toInt() == ipAddr.toInt()) {
            assignmentInfo.setAssignmentStatus(IPAssignment.AssignmentStatus.Option_Assigned);
            assignmentInfo.setTimestamp(new Date());
            assignmentInfo.setLeasePeriodinSeconds(leaseTime);
            allocationMap.put(macID, assignmentInfo);
            return true;
        }
    } else if (freeIPPool.contains(ipAddr)) {
        assignmentInfo = new IPAssignment(ipAddr, leaseTime, IPAssignment.AssignmentStatus.Option_Assigned);
        if (freeIPPool.remove(ipAddr)) {
            allocationMap.put(macID, assignmentInfo);
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void setDefaultTimeoutForPurge(long timeInSeconds) {
    defaultTimeout = timeInSeconds;
}
#method_after
@Override
public void setDefaultTimeoutForPurge(long timeInSeconds) {
    timeoutForPendingAssignments = timeInSeconds;
}
#end_block

#method_before
private Ip4Address fetchNextIP() {
    if (!freeIPPool.isEmpty()) {
        Ip4Address freeIP = freeIPPool.iterator().next();
        freeIPPool.remove(freeIP);
        return freeIP;
    }
    return null;
}
#method_after
private Ip4Address fetchNextIP() {
    for (Ip4Address freeIP : freeIPPool) {
        if (freeIPPool.remove(freeIP)) {
            return freeIP;
        }
    }
    return null;
}
#end_block

