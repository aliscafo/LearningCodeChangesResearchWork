616
#method_before
@Override
public void startMonitoring() {
    allVmStatsOnlyRefresher.startMonitoring();
    final String hostname = vdsManager.getVdsHostname();
    resourceManager.subscribe(new EventSubscriber(hostname + "|*|VM_status|*") {

        @Override
        public void onSubscribe(Subscription sub) {
            subscription = sub;
            subscription.request(1);
        }

        @Override
        public void onNext(Map<String, Object> map) {
            try {
                long fetchTime = System.nanoTime();
                printEventInDebug(map);
                List<Pair<VmDynamic, VdsmVm>> vms = convertEvent(map);
                if (!vms.isEmpty()) {
                    getVmsMonitoring().perform(vms, fetchTime, vdsManager, false);
                    processDevices(vms.stream().map(Pair::getSecond), fetchTime);
                }
            } finally {
                subscription.request(1);
            }
        }

        private void printEventInDebug(Map<String, Object> map) {
            if (!log.isDebugEnabled()) {
                return;
            }
            StringBuilder sb = new StringBuilder();
            XmlRpcObjectDescriptor.toStringBuilder(map, sb);
            log.debug("processing event for host {} data:\n{}", vdsManager.getVdsName(), sb);
        }

        @SuppressWarnings("unchecked")
        private List<Pair<VmDynamic, VdsmVm>> convertEvent(Map<String, Object> map) {
            Double notifyTime = VdsBrokerObjectsBuilder.removeNotifyTimeFromVmStatusEvent(map);
            return map.entrySet().stream().map(idToMap -> toMonitoredVm(new Guid(idToMap.getKey()), (Map<String, Object>) idToMap.getValue(), notifyTime)).collect(Collectors.toList());
        }

        private Pair<VmDynamic, VdsmVm> toMonitoredVm(Guid vmId, Map<String, Object> vmMap, Double notifyTime) {
            VmDynamic dbVm = vmDynamicDao.get(vmId);
            VdsmVm vdsmVm = dbVm == null ? createVdsmVm(vmId, vmMap, notifyTime) : createVdsmVm(dbVm, vmMap, notifyTime);
            return new Pair<>(dbVm, vdsmVm);
        }

        private VdsmVm createVdsmVm(Guid vmId, Map<String, Object> xmlRpcStruct, Double notifyTime) {
            VmDynamic fakeVm = new VmDynamic();
            fakeVm.setId(vmId);
            return createVdsmVm(fakeVm, xmlRpcStruct, notifyTime);
        }

        private VdsmVm createVdsmVm(VmDynamic dbVmDyanmic, Map<String, Object> xmlRpcStruct, Double notifyTime) {
            // send a clone of vm dynamic to be overridden with new data
            VmDynamic clonedVmDynamic = new VmDynamic(dbVmDyanmic);
            VdsBrokerObjectsBuilder.updateVMDynamicData(clonedVmDynamic, xmlRpcStruct, vdsManager.getCopyVds());
            return new VdsmVm(notifyTime).setVmDynamic(clonedVmDynamic).setDevicesHash(VdsBrokerObjectsBuilder.getVmDevicesHash(xmlRpcStruct));
        }

        @Override
        public void onError(Throwable t) {
            // communication issue is delivered as a message so we need to request for more
            subscription.request(1);
        }

        @Override
        public void onComplete() {
        }
    });
}
#method_after
@Override
public void startMonitoring() {
    allVmStatsOnlyRefresher.startMonitoring();
    final String hostname = vdsManager.getVdsHostname();
    resourceManager.subscribe(new EventSubscriber(hostname + "|*|VM_status|*") {

        @Override
        public void onSubscribe(Subscription sub) {
            subscription = sub;
            subscription.request(1);
        }

        @Override
        public void onNext(Map<String, Object> map) {
            try {
                long fetchTime = System.nanoTime();
                printEventInDebug(map);
                List<Pair<VmDynamic, VdsmVm>> vms = convertEvent(map);
                if (!vms.isEmpty()) {
                    getVmsMonitoring().perform(vms, fetchTime, vdsManager, false);
                    processDevices(vms.stream().map(Pair::getSecond), fetchTime);
                }
            } finally {
                subscription.request(1);
            }
        }

        private void printEventInDebug(Map<String, Object> map) {
            if (!log.isDebugEnabled()) {
                return;
            }
            StringBuilder sb = new StringBuilder();
            XmlRpcObjectDescriptor.toStringBuilder(map, sb);
            log.debug("processing event for host {} data:\n{}", vdsManager.getVdsName(), sb);
        }

        @SuppressWarnings("unchecked")
        private List<Pair<VmDynamic, VdsmVm>> convertEvent(Map<String, Object> map) {
            Double notifyTime = VdsBrokerObjectsBuilder.removeNotifyTimeFromVmStatusEvent(map);
            return map.entrySet().stream().map(idToMap -> toMonitoredVm(new Guid(idToMap.getKey()), (Map<String, Object>) idToMap.getValue(), notifyTime)).collect(Collectors.toList());
        }

        private Pair<VmDynamic, VdsmVm> toMonitoredVm(Guid vmId, Map<String, Object> vmMap, Double notifyTime) {
            VmDynamic dbVm = vmDynamicDao.get(vmId);
            VdsmVm vdsmVm = dbVm == null ? createVdsmVm(vmId, vmMap, notifyTime) : createVdsmVm(dbVm, vmMap, notifyTime);
            return new Pair<>(dbVm, vdsmVm);
        }

        private VdsmVm createVdsmVm(Guid vmId, Map<String, Object> xmlRpcStruct, Double notifyTime) {
            VmDynamic fakeVm = new VmDynamic();
            fakeVm.setId(vmId);
            return createVdsmVm(fakeVm, xmlRpcStruct, notifyTime);
        }

        private VdsmVm createVdsmVm(VmDynamic dbVmDynamic, Map<String, Object> xmlRpcStruct, Double notifyTime) {
            // send a clone of vm dynamic to be overridden with new data
            VmDynamic clonedVmDynamic = new VmDynamic(dbVmDynamic);
            VdsBrokerObjectsBuilder.updateVMDynamicData(clonedVmDynamic, xmlRpcStruct, vdsManager.getCopyVds());
            return new VdsmVm(notifyTime).setVmDynamic(clonedVmDynamic).setDevicesHash(VdsBrokerObjectsBuilder.getVmDevicesHash(xmlRpcStruct));
        }

        @Override
        public void onError(Throwable t) {
            // communication issue is delivered as a message so we need to request for more
            subscription.request(1);
        }

        @Override
        public void onComplete() {
        }
    });
}
#end_block

#method_before
@Override
public void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    Integer pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = vmInfoBuildUtils.getVmDeviceByDiskId(disk.getId(), vm.getId());
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        // skip unmanaged devices (handled separately)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(dve.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    pinToIoThreads(vmDevice, pinnedDriveIndex);
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    if (FeatureSupported.virtioScsiIoThread(vm.getCompatibilityVersion())) {
                        pinToIoThreads(vmDevice, pinnedDriveIndex);
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && dve.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            vmInfoBuildUtils.addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), vmInfoBuildUtils.loadStorageQos(diskImage));
                    }
                    vmInfoBuildUtils.handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    vmInfoBuildUtils.buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            vmInfoBuildUtils.addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#method_after
@Override
public void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = vmInfoBuildUtils.getVmDeviceByDiskId(disk.getId(), vm.getId());
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        // skip unmanaged devices (handled separately)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(dve.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    pinnedDriveIndex = pinToIoThreads(vmDevice, pinnedDriveIndex);
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    if (FeatureSupported.virtioScsiIoThread(vm.getCompatibilityVersion())) {
                        pinnedDriveIndex = pinToIoThreads(vmDevice, pinnedDriveIndex);
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && dve.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            vmInfoBuildUtils.addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), vmInfoBuildUtils.loadStorageQos(diskImage));
                    }
                    vmInfoBuildUtils.handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    vmInfoBuildUtils.buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            vmInfoBuildUtils.addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
private void pinToIoThreads(VmDevice vmDevice, Integer pinnedDriveIndex) {
    if (vm.getNumOfIoThreads() != 0) {
        // simple round robin e.g. for 2 threads and 4 disks it will be pinned like this:
        // disk 0 -> iothread 1
        // disk 1 -> iothread 2
        // disk 2 -> iothread 1
        // disk 3 -> iothread 2
        int pinTo = pinnedDriveIndex % vm.getNumOfIoThreads() + 1;
        pinnedDriveIndex++;
        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinTo);
    }
}
#method_after
private int pinToIoThreads(VmDevice vmDevice, int pinnedDriveIndex) {
    if (vm.getNumOfIoThreads() != 0) {
        // simple round robin e.g. for 2 threads and 4 disks it will be pinned like this:
        // disk 0 -> iothread 1
        // disk 1 -> iothread 2
        // disk 2 -> iothread 1
        // disk 3 -> iothread 2
        int pinTo = pinnedDriveIndex % vm.getNumOfIoThreads() + 1;
        pinnedDriveIndex++;
        vmDevice.getSpecParams().put(VdsProperties.pinToIoThread, pinTo);
    }
    return pinnedDriveIndex;
}
#end_block

#method_before
private boolean validateUnregisteredEntity(VmTemplate entityFromConfiguration, OvfEntityData ovfEntityData) {
    if (ovfEntityData == null && !getParameters().isImportAsNewEntity()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_OVF);
    }
    if (entityFromConfiguration == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED);
    }
    if (getImages().size() > 0 && !ImagesHandler.isImagesExists(getImages(), getStoragePool().getId())) {
        return failValidation(EngineMessage.TEMPLATE_IMAGE_NOT_EXIST);
    }
    for (DiskImage image : getImages()) {
        StorageDomain sd = getStorageDomainDao().getForStoragePool(image.getStorageIds().get(0), getStoragePool().getId());
        if (!validate(new StorageDomainValidator(sd).isDomainExistAndActive())) {
            return false;
        }
    }
    if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED, String.format("$domainId %1$s", getParameters().getStorageDomainId()), String.format("$domainType %1$s", getStorageDomain().getStorageDomainType()));
    }
    return true;
}
#method_after
private boolean validateUnregisteredEntity(VmTemplate entityFromConfiguration, OvfEntityData ovfEntityData) {
    if (ovfEntityData == null && !getParameters().isImportAsNewEntity()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_OVF);
    }
    if (entityFromConfiguration == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED);
    }
    if (!ImagesHandler.isImagesExists(getImages(), getStoragePool().getId())) {
        return failValidation(EngineMessage.TEMPLATE_IMAGE_NOT_EXIST);
    }
    for (DiskImage image : getImages()) {
        StorageDomain sd = getStorageDomainDao().getForStoragePool(image.getStorageIds().get(0), getStoragePool().getId());
        if (!validate(new StorageDomainValidator(sd).isDomainExistAndActive())) {
            return false;
        }
    }
    if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED, String.format("$domainId %1$s", getParameters().getStorageDomainId()), String.format("$domainType %1$s", getStorageDomain().getStorageDomainType()));
    }
    return true;
}
#end_block

#method_before
@Test
public void validateFailsNullParameterForIsoFile() {
    mockVdsWithOsVersion(VALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(null);
    UpgradeOvirtNodeInternalCommand<InstallVdsParameters> command = createCommand(param);
    command.validate();
    ValidateTestUtils.assertValidationMessages("Validation should fail when a null ISO file is supplied.", command, EngineMessage.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
}
#method_after
@Test
public void validateFailsNullParameterForIsoFile() {
    mockVdsWithOsVersion(VALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(null);
    UpgradeOvirtNodeInternalCommand<InstallVdsParameters> command = createCommand(param);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
}
#end_block

#method_before
@Test
public void validateFailsMissingIsoFile() {
    mockVdsWithOsVersion(VALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(INVALID_VERSION_OVIRT_ISO_FILENAME);
    UpgradeOvirtNodeInternalCommand<InstallVdsParameters> command = createCommand(param);
    command.validate();
    ValidateTestUtils.assertValidationMessages("Validation should fail if ISO file is missing.", command, EngineMessage.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
}
#method_after
@Test
public void validateFailsMissingIsoFile() {
    mockVdsWithOsVersion(VALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(INVALID_VERSION_OVIRT_ISO_FILENAME);
    UpgradeOvirtNodeInternalCommand<InstallVdsParameters> command = createCommand(param);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
}
#end_block

#method_before
@Test
public void validateFailsIsoVersionNotCompatible() {
    mockVdsWithOsVersion(INVALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(VALID_VERSION_OVIRT_ISO_FILENAME);
    UpgradeOvirtNodeInternalCommand<InstallVdsParameters> command = createCommand(param);
    command.validate();
    ValidateTestUtils.assertValidationMessages("Validation should fail if VDS is not compatible with ISO version.", command, EngineMessage.VDS_CANNOT_UPGRADE_BETWEEN_MAJOR_VERSION);
}
#method_after
@Test
public void validateFailsIsoVersionNotCompatible() {
    mockVdsWithOsVersion(INVALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(VALID_VERSION_OVIRT_ISO_FILENAME);
    UpgradeOvirtNodeInternalCommand<InstallVdsParameters> command = createCommand(param);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VDS_CANNOT_UPGRADE_BETWEEN_MAJOR_VERSION);
}
#end_block

#method_before
private VM createVmForTesting(String initrd, String kernel) {
    mockVm(command);
    // Set parameter
    command.getVm().setInitrdUrl(initrd);
    command.getVm().setKernelUrl(kernel);
    command.createVm();
    // Check Vm
    return vmDao.get(command.getParameters().getVmId());
}
#method_after
private VM createVmForTesting(String initrd, String kernel) {
    mockVm(command);
    // Set parameter
    command.getVm().setInitrdUrl(initrd);
    command.getVm().setKernelUrl(kernel);
    command.createVm();
    return vmDao.get(command.getParameters().getVmId());
}
#end_block

#method_before
private RunVmValidator mockSuccessfulRunVmValidator() {
    RunVmValidator runVmValidator = mock(RunVmValidator.class);
    when(runVmValidator.canRunVm(Matchers.anyListOf(String.class), any(StoragePool.class), Matchers.anyListOf(Guid.class), Matchers.anyListOf(Guid.class), Matchers.anyListOf(Guid.class), any(Cluster.class))).thenReturn(true);
    when(runVmValidator.validateNetworkInterfaces()).thenReturn(ValidationResult.VALID);
    doReturn(runVmValidator).when(command).getRunVmValidator();
    return runVmValidator;
}
#method_after
private RunVmValidator mockSuccessfulRunVmValidator() {
    RunVmValidator runVmValidator = mock(RunVmValidator.class);
    when(runVmValidator.canRunVm(anyListOf(String.class), any(StoragePool.class), anyListOf(Guid.class), anyListOf(Guid.class), anyListOf(Guid.class), any(Cluster.class))).thenReturn(true);
    when(runVmValidator.validateNetworkInterfaces()).thenReturn(ValidationResult.VALID);
    doReturn(runVmValidator).when(command).getRunVmValidator();
    return runVmValidator;
}
#end_block

#method_before
private RunVmValidator mockSuccessfulRunVmValidator() {
    RunVmValidator runVmValidator = mock(RunVmValidator.class);
    when(runVmValidator.canRunVm(Matchers.anyListOf(String.class), any(StoragePool.class), Matchers.anyListOf(Guid.class), Matchers.anyListOf(Guid.class), Matchers.anyListOf(Guid.class), any(Cluster.class))).thenReturn(true);
    when(runVmValidator.validateNetworkInterfaces()).thenReturn(ValidationResult.VALID);
    doReturn(runVmValidator).when(command).getRunVmValidator();
    return runVmValidator;
}
#method_after
private RunVmValidator mockSuccessfulRunVmValidator() {
    RunVmValidator runVmValidator = mock(RunVmValidator.class);
    when(runVmValidator.canRunVm(anyListOf(String.class), any(StoragePool.class), anyListOf(Guid.class), anyListOf(Guid.class), anyListOf(Guid.class), any(Cluster.class))).thenReturn(true);
    when(runVmValidator.validateNetworkInterfaces()).thenReturn(ValidationResult.VALID);
    doReturn(runVmValidator).when(command).getRunVmValidator();
    return runVmValidator;
}
#end_block

#method_before
@Test
public void testGetAvailableValues() {
    setSomeValue("Anakin");
    Map<String, String> values = new HashMap<>();
    Set<String> properties = new HashSet<>(Collections.singletonList("somevalue"));
    TypeCompat.getPropertyValues(this, properties, values);
    assertFalse(properties.isEmpty());
    assertEquals("Standard", "Anakin", values.get("somevalue"));
}
#method_after
@Test
public void testGetAvailableValues() {
    setSomeValue("Anakin");
    Map<String, String> values = new HashMap<>();
    Set<String> properties = Collections.singleton("somevalue");
    TypeCompat.getPropertyValues(this, properties, values);
    assertFalse(properties.isEmpty());
    assertEquals("Standard", "Anakin", values.get("somevalue"));
}
#end_block

#method_before
public void testCannotUpdateOSNotSupportVirtioScsi() {
    prepareVmToPassValidate();
    group.setCompatibilityVersion(Version.v4_0);
    when(command.isVirtioScsiEnabledForVm(any(Guid.class))).thenReturn(true);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Collections.singletonList("VirtIO")));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#method_after
public void testCannotUpdateOSNotSupportVirtioScsi() {
    prepareVmToPassValidate();
    group.setCompatibilityVersion(Version.v4_0);
    when(command.isVirtioScsiEnabledForVm(any(Guid.class))).thenReturn(true);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(Collections.singletonList("VirtIO"));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#end_block

#method_before
@Before
public void setUp() throws UnableToCompleteException {
    when(logger.branch(any(TreeLogger.Type.class), anyString(), any(Throwable.class), any(HelpInfo.class))).thenReturn(logger);
    tested = new ElementIdTypeParser(logger, interfaceType) {

        @Override
        JClassType resolveOwnerType(JClassType interfaceToImplement) throws UnableToCompleteException {
            return ownerType;
        }
    };
    // $NON-NLS-1$
    stubPassingField(field, mock(JClassType.class), "field");
    JClassType ownerTypeParent = mock(JClassType.class);
    Set<? extends JClassType> ownerTypeFlattenedSupertypeHierarchy = new HashSet<>(Arrays.asList(ownerType, ownerTypeParent));
    doReturn(ownerTypeFlattenedSupertypeHierarchy).when(ownerType).getFlattenedSupertypeHierarchy();
    when(ownerType.getFields()).thenReturn(new JField[] { ownerTypeField1, ownerTypeField2 });
    when(ownerTypeParent.getFields()).thenReturn(new JField[] { ownerTypeParentField });
    // $NON-NLS-1$
    when(ownerType.getName()).thenReturn("OwnerTypeName");
    // $NON-NLS-1$
    JClassType ownerTypeParentFieldType = mock(JClassType.class, "ownerTypeParentFieldType");
    // $NON-NLS-1$
    stubPassingField(ownerTypeField1, mock(JClassType.class), "ownerTypeField1");
    // $NON-NLS-1$
    stubPassingField(ownerTypeField2, mock(JClassType.class), "ownerTypeField2");
    // $NON-NLS-1$
    stubPassingField(ownerTypeParentField, ownerTypeParentFieldType, "ownerTypeParentField");
    Set<? extends JClassType> ownerTypeParentFieldTypeFlattenedSupertypeHierarchy = new HashSet<>(Collections.singletonList(ownerTypeParentFieldType));
    doReturn(ownerTypeParentFieldTypeFlattenedSupertypeHierarchy).when(ownerTypeParentFieldType).getFlattenedSupertypeHierarchy();
    when(ownerTypeParentFieldType.getFields()).thenReturn(new JField[] { ownerTypeParentFieldTypeSubField1, ownerTypeParentFieldTypeSubField2 });
    stubPassingField(ownerTypeParentFieldTypeSubField1, ownerTypeParentFieldTypeSubField1Type, // $NON-NLS-1$
    "ownerTypeParentFieldTypeSubField1");
    stubPassingField(ownerTypeParentFieldTypeSubField2, mock(JClassType.class), // $NON-NLS-1$
    "ownerTypeParentFieldTypeSubField2");
}
#method_after
@Before
public void setUp() throws UnableToCompleteException {
    when(logger.branch(any(TreeLogger.Type.class), anyString(), any(Throwable.class), any(HelpInfo.class))).thenReturn(logger);
    tested = new ElementIdTypeParser(logger, interfaceType) {

        @Override
        JClassType resolveOwnerType(JClassType interfaceToImplement) throws UnableToCompleteException {
            return ownerType;
        }
    };
    // $NON-NLS-1$
    stubPassingField(field, mock(JClassType.class), "field");
    JClassType ownerTypeParent = mock(JClassType.class);
    Set<? extends JClassType> ownerTypeFlattenedSupertypeHierarchy = new HashSet<>(Arrays.asList(ownerType, ownerTypeParent));
    doReturn(ownerTypeFlattenedSupertypeHierarchy).when(ownerType).getFlattenedSupertypeHierarchy();
    when(ownerType.getFields()).thenReturn(new JField[] { ownerTypeField1, ownerTypeField2 });
    when(ownerTypeParent.getFields()).thenReturn(new JField[] { ownerTypeParentField });
    // $NON-NLS-1$
    when(ownerType.getName()).thenReturn("OwnerTypeName");
    // $NON-NLS-1$
    JClassType ownerTypeParentFieldType = mock(JClassType.class, "ownerTypeParentFieldType");
    // $NON-NLS-1$
    stubPassingField(ownerTypeField1, mock(JClassType.class), "ownerTypeField1");
    // $NON-NLS-1$
    stubPassingField(ownerTypeField2, mock(JClassType.class), "ownerTypeField2");
    // $NON-NLS-1$
    stubPassingField(ownerTypeParentField, ownerTypeParentFieldType, "ownerTypeParentField");
    Set<? extends JClassType> ownerTypeParentFieldTypeFlattenedSupertypeHierarchy = Collections.singleton(ownerTypeParentFieldType);
    doReturn(ownerTypeParentFieldTypeFlattenedSupertypeHierarchy).when(ownerTypeParentFieldType).getFlattenedSupertypeHierarchy();
    when(ownerTypeParentFieldType.getFields()).thenReturn(new JField[] { ownerTypeParentFieldTypeSubField1, ownerTypeParentFieldTypeSubField2 });
    stubPassingField(ownerTypeParentFieldTypeSubField1, ownerTypeParentFieldTypeSubField1Type, // $NON-NLS-1$
    "ownerTypeParentFieldTypeSubField1");
    stubPassingField(ownerTypeParentFieldTypeSubField2, mock(JClassType.class), // $NON-NLS-1$
    "ownerTypeParentFieldTypeSubField2");
}
#end_block

#method_before
@Test(expected = UnableToCompleteException.class)
public void doParse_unhandledFieldTypeRecursion() throws UnableToCompleteException {
    Set<? extends JClassType> ownerTypeParentFieldTypeSubField1TypeFlattenedSupertypeHierarchy = new HashSet<>(Collections.singletonList(ownerTypeParentFieldTypeSubField1Type));
    doReturn(ownerTypeParentFieldTypeSubField1TypeFlattenedSupertypeHierarchy).when(ownerTypeParentFieldTypeSubField1Type).getFlattenedSupertypeHierarchy();
    when(ownerTypeParentFieldTypeSubField1Type.getFields()).thenReturn(new JField[] { ownerTypeParentField });
    // $NON-NLS-1$ //$NON-NLS-2$
    tested.doParse(ownerType, new ArrayList<JClassType>(), ".", "IdPrefix");
}
#method_after
@Test(expected = UnableToCompleteException.class)
public void doParse_unhandledFieldTypeRecursion() throws UnableToCompleteException {
    Set<? extends JClassType> ownerTypeParentFieldTypeSubField1TypeFlattenedSupertypeHierarchy = Collections.singleton(ownerTypeParentFieldTypeSubField1Type);
    doReturn(ownerTypeParentFieldTypeSubField1TypeFlattenedSupertypeHierarchy).when(ownerTypeParentFieldTypeSubField1Type).getFlattenedSupertypeHierarchy();
    when(ownerTypeParentFieldTypeSubField1Type.getFields()).thenReturn(new JField[] { ownerTypeParentField });
    // $NON-NLS-1$ //$NON-NLS-2$
    tested.doParse(ownerType, new ArrayList<JClassType>(), ".", "IdPrefix");
}
#end_block

#method_before
@Test
public void doParse_handledFieldTypeRecursion() throws UnableToCompleteException {
    Set<? extends JClassType> ownerTypeParentFieldTypeSubField1TypeFlattenedSupertypeHierarchy = new HashSet<>(Collections.singletonList(ownerTypeParentFieldTypeSubField1Type));
    doReturn(ownerTypeParentFieldTypeSubField1TypeFlattenedSupertypeHierarchy).when(ownerTypeParentFieldTypeSubField1Type).getFlattenedSupertypeHierarchy();
    when(ownerTypeParentFieldTypeSubField1Type.getFields()).thenReturn(new JField[] { ownerTypeParentField });
    // $NON-NLS-1$
    stubFieldIdAnnotation(ownerTypeParentField, "", false);
    // $NON-NLS-1$ //$NON-NLS-2$
    tested.doParse(ownerType, new ArrayList<JClassType>(), ".", "IdPrefix");
    List<ElementIdStatement> expected = Arrays.asList(// $NON-NLS-1$ //$NON-NLS-2$
    getExpectedStatement("ownerTypeParentField", "IdPrefix_ownerTypeParentField"), // $NON-NLS-1$ //$NON-NLS-2$
    getExpectedStatement("ownerTypeField1", "IdPrefix_ownerTypeField1"), // $NON-NLS-1$ //$NON-NLS-2$
    getExpectedStatement("ownerTypeField2", "IdPrefix_ownerTypeField2"));
    assertThat(tested.statements.size(), is(equalTo(expected.size())));
    assertThat(tested.statements.containsAll(expected), is(equalTo(true)));
}
#method_after
@Test
public void doParse_handledFieldTypeRecursion() throws UnableToCompleteException {
    Set<? extends JClassType> ownerTypeParentFieldTypeSubField1TypeFlattenedSupertypeHierarchy = Collections.singleton(ownerTypeParentFieldTypeSubField1Type);
    doReturn(ownerTypeParentFieldTypeSubField1TypeFlattenedSupertypeHierarchy).when(ownerTypeParentFieldTypeSubField1Type).getFlattenedSupertypeHierarchy();
    when(ownerTypeParentFieldTypeSubField1Type.getFields()).thenReturn(new JField[] { ownerTypeParentField });
    // $NON-NLS-1$
    stubFieldIdAnnotation(ownerTypeParentField, "", false);
    // $NON-NLS-1$ //$NON-NLS-2$
    tested.doParse(ownerType, new ArrayList<JClassType>(), ".", "IdPrefix");
    List<ElementIdStatement> expected = Arrays.asList(// $NON-NLS-1$ //$NON-NLS-2$
    getExpectedStatement("ownerTypeParentField", "IdPrefix_ownerTypeParentField"), // $NON-NLS-1$ //$NON-NLS-2$
    getExpectedStatement("ownerTypeField1", "IdPrefix_ownerTypeField1"), // $NON-NLS-1$ //$NON-NLS-2$
    getExpectedStatement("ownerTypeField2", "IdPrefix_ownerTypeField2"));
    assertThat(tested.statements.size(), is(equalTo(expected.size())));
    assertThat(tested.statements.containsAll(expected), is(equalTo(true)));
}
#end_block

#method_before
private void mockJobSubjectEntityDao(Guid jobId) {
    when(jobSubjectEntityDao.getJobSubjectEntityByJobId(eq(jobId))).thenReturn(JOB_SUBJECT_ENTITIES_MAP);
    when(jobSubjectEntityDao.getJobIdByEntityId(any(Guid.class))).thenReturn(Collections.<Guid>singletonList(jobId));
}
#method_after
private void mockJobSubjectEntityDao(Guid jobId) {
    when(jobSubjectEntityDao.getJobSubjectEntityByJobId(eq(jobId))).thenReturn(JOB_SUBJECT_ENTITIES_MAP);
    when(jobSubjectEntityDao.getJobIdByEntityId(any(Guid.class))).thenReturn(Collections.singletonList(jobId));
}
#end_block

#method_before
@Parameterized.Parameters
public static Collection<Object[]> ipAddressParams() {
    return Arrays.asList(new Object[][] { { new HashSet<String>(), true }, { null, true }, { new HashSet<>(Collections.singletonList("abc")), true }, { new HashSet<>(Arrays.asList("abc", "xyz")), true }, { new HashSet<>(Collections.singletonList("abc-_sc")), true }, { new HashSet<>(Collections.singletonList("")), false }, { new HashSet<>(Collections.singletonList(" ")), false }, { new HashSet<>(Collections.singletonList("abc*")), false }, { new HashSet<>(Arrays.asList("aaa", "abc*")), false } });
}
#method_after
@Parameterized.Parameters
public static Collection<Object[]> ipAddressParams() {
    return Arrays.asList(new Object[][] { { Collections.emptySet(), true }, { null, true }, { Collections.singleton("abc"), true }, { new HashSet<>(Arrays.asList("abc", "xyz")), true }, { Collections.singleton("abc-_sc"), true }, { Collections.singleton(""), false }, { Collections.singleton(" "), false }, { Collections.singleton("abc*"), false }, { new HashSet<>(Arrays.asList("aaa", "abc*")), false } });
}
#end_block

#method_before
@Test
public void statusSetInMap() {
    Guid storageDomainId = Guid.newGuid();
    Guid poolId = Guid.newGuid();
    AttachStorageDomainToPoolParameters params = new AttachStorageDomainToPoolParameters(storageDomainId, poolId);
    AttachStorageDomainToPoolCommand<AttachStorageDomainToPoolParameters> cmd = spy(new AttachStorageDomainToPoolCommand<>(params, CommandContext.createContext(params.getSessionId())));
    doNothing().when(cmd).attemptToActivateDomain();
    doReturn(Collections.emptyList()).when(cmd).connectHostsInUpToDomainStorageServer();
    doReturn(isoMapDao).when(cmd).getStoragePoolIsoMapDao();
    doReturn(storagePoolDao).when(cmd).getStoragePoolDao();
    doReturn(vdsDao).when(cmd).getVdsDao();
    doReturn(storageDomainDao).when(cmd).getStorageDomainDao();
    doReturn(storageDomainStaticDao).when(cmd).getStorageDomainStaticDao();
    doReturn(diskImageDao).when(cmd).getDiskImageDao();
    doReturn(vdsBrokerFrontend).when(cmd).getVdsBroker();
    StoragePool pool = new StoragePool();
    pool.setId(poolId);
    pool.setStatus(StoragePoolStatus.Up);
    when(storagePoolDao.get(any(Guid.class))).thenReturn(pool);
    when(isoMapDao.get(any(StoragePoolIsoMapId.class))).thenReturn(map);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(new StorageDomain());
    when(diskImageDao.getAllForStorageDomain(any(Guid.class))).thenReturn(Collections.<org.ovirt.engine.core.common.businessentities.storage.DiskImage>emptyList());
    when(storageDomainStaticDao.get(any(Guid.class))).thenReturn(new StorageDomainStatic());
    doReturn(pool.getId()).when(cmd).getStoragePoolIdFromVds();
    doReturn(backendInternal).when(cmd).getBackend();
    VdcReturnValueBase vdcReturnValue = new VdcReturnValueBase();
    vdcReturnValue.setSucceeded(true);
    when(backendInternal.runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class), any(CommandContext.class))).thenReturn(vdcReturnValue);
    StorageDomainStatic storageDomain = new StorageDomainStatic();
    storageDomain.setId(Guid.newGuid());
    storageDomain.setStorageDomainType(StorageDomainType.ImportExport);
    mockGetStorageDomainInfoVdsCommand(storageDomain);
    mockAttachStorageDomainVdsCommand();
    when(vdsDao.get(any(Guid.class))).thenReturn(vds);
    doReturn(Collections.emptyList()).when(cmd).getEntitiesFromStorageOvfDisk(storageDomainId, pool.getId());
    doReturn(Collections.emptyList()).when(cmd).getAllOVFDisks(storageDomainId, pool.getId());
    doAnswer(new Answer<Object>() {

        @Override
        public Object answer(InvocationOnMock invocation) throws Throwable {
            map = (StoragePoolIsoMap) invocation.getArguments()[0];
            return null;
        }
    }).when(isoMapDao).save(any(StoragePoolIsoMap.class));
    cmd.setCompensationContext(mock(CompensationContext.class));
    cmd.executeCommand();
    assertNotNull(map);
    assertEquals(StorageDomainStatus.Maintenance, map.getStatus());
}
#method_after
@Test
public void statusSetInMap() {
    Guid storageDomainId = Guid.newGuid();
    Guid poolId = Guid.newGuid();
    AttachStorageDomainToPoolParameters params = new AttachStorageDomainToPoolParameters(storageDomainId, poolId);
    AttachStorageDomainToPoolCommand<AttachStorageDomainToPoolParameters> cmd = spy(new AttachStorageDomainToPoolCommand<>(params, CommandContext.createContext(params.getSessionId())));
    doNothing().when(cmd).attemptToActivateDomain();
    doReturn(Collections.emptyList()).when(cmd).connectHostsInUpToDomainStorageServer();
    doReturn(isoMapDao).when(cmd).getStoragePoolIsoMapDao();
    doReturn(storagePoolDao).when(cmd).getStoragePoolDao();
    doReturn(vdsDao).when(cmd).getVdsDao();
    doReturn(storageDomainDao).when(cmd).getStorageDomainDao();
    doReturn(storageDomainStaticDao).when(cmd).getStorageDomainStaticDao();
    doReturn(diskImageDao).when(cmd).getDiskImageDao();
    doReturn(vdsBrokerFrontend).when(cmd).getVdsBroker();
    StoragePool pool = new StoragePool();
    pool.setId(poolId);
    pool.setStatus(StoragePoolStatus.Up);
    when(storagePoolDao.get(any(Guid.class))).thenReturn(pool);
    when(isoMapDao.get(any(StoragePoolIsoMapId.class))).thenReturn(map);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(new StorageDomain());
    when(diskImageDao.getAllForStorageDomain(any(Guid.class))).thenReturn(Collections.emptyList());
    when(storageDomainStaticDao.get(any(Guid.class))).thenReturn(new StorageDomainStatic());
    doReturn(pool.getId()).when(cmd).getStoragePoolIdFromVds();
    doReturn(backendInternal).when(cmd).getBackend();
    VdcReturnValueBase vdcReturnValue = new VdcReturnValueBase();
    vdcReturnValue.setSucceeded(true);
    when(backendInternal.runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class), any(CommandContext.class))).thenReturn(vdcReturnValue);
    StorageDomainStatic storageDomain = new StorageDomainStatic();
    storageDomain.setId(Guid.newGuid());
    storageDomain.setStorageDomainType(StorageDomainType.ImportExport);
    mockGetStorageDomainInfoVdsCommand(storageDomain);
    mockAttachStorageDomainVdsCommand();
    when(vdsDao.get(any(Guid.class))).thenReturn(vds);
    doReturn(Collections.emptyList()).when(cmd).getEntitiesFromStorageOvfDisk(storageDomainId, pool.getId());
    doReturn(Collections.emptyList()).when(cmd).getAllOVFDisks(storageDomainId, pool.getId());
    doAnswer(new Answer<Object>() {

        @Override
        public Object answer(InvocationOnMock invocation) throws Throwable {
            map = (StoragePoolIsoMap) invocation.getArguments()[0];
            return null;
        }
    }).when(isoMapDao).save(any(StoragePoolIsoMap.class));
    cmd.setCompensationContext(mock(CompensationContext.class));
    cmd.executeCommand();
    assertNotNull(map);
    assertEquals(StorageDomainStatus.Maintenance, map.getStatus());
}
#end_block

#method_before
public void testCannotUpdateOSNotSupportVirtioScsi() {
    prepareVmToPassValidate();
    group.setCompatibilityVersion(Version.v4_0);
    when(command.isVirtioScsiEnabledForVm(any(Guid.class))).thenReturn(true);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Collections.singletonList("VirtIO")));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#method_after
public void testCannotUpdateOSNotSupportVirtioScsi() {
    prepareVmToPassValidate();
    group.setCompatibilityVersion(Version.v4_0);
    when(command.isVirtioScsiEnabledForVm(any(Guid.class))).thenReturn(true);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(Collections.singletonList("VirtIO"));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#end_block

#method_before
private void mockGetImagesList() {
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setReturnValue(new ArrayList<Guid>());
    when(vdsBrokerFrontend.runVdsCommand(eq(VDSCommandType.GetImagesList), Matchers.any(VDSParametersBase.class))).thenReturn(returnValue);
}
#method_after
private void mockGetImagesList() {
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setReturnValue(new ArrayList<Guid>());
    when(vdsBrokerFrontend.runVdsCommand(eq(VDSCommandType.GetImagesList), any(VDSParametersBase.class))).thenReturn(returnValue);
}
#end_block

#method_before
private void mockDiskImageDao() {
    when(diskImageDao.getSnapshotById(Matchers.any(Guid.class))).thenReturn(getDiskImageList().get(0));
}
#method_after
private void mockDiskImageDao() {
    when(diskImageDao.getSnapshotById(any(Guid.class))).thenReturn(getDiskImageList().get(0));
}
#end_block

#method_before
@Test
public void validateCoherentNicIdentificationTest() {
    NicLabelValidator validator = spy(createNicLabelValidator());
    ValidationResult validationReuslt = new ValidationResult(EngineMessage.Unassigned);
    doReturn(validationReuslt).when(validator).validateCoherentIdentification(any(String.class), any(Guid.class), any(String.class), any(EngineMessage.class), Matchers.<BusinessEntityMap<VdsNetworkInterface>>any());
    assertEquals(validationReuslt, validator.validateCoherentNicIdentification(new NicLabel()));
}
#method_after
@Test
public void validateCoherentNicIdentificationTest() {
    NicLabelValidator validator = spy(createNicLabelValidator());
    ValidationResult validationReuslt = new ValidationResult(EngineMessage.Unassigned);
    doReturn(validationReuslt).when(validator).validateCoherentIdentification(any(String.class), any(Guid.class), any(String.class), any(EngineMessage.class), any(BusinessEntityMap.class));
    assertEquals(validationReuslt, validator.validateCoherentNicIdentification(new NicLabel()));
}
#end_block

#method_before
private void evaluateMaintenanceHostCommandProgress(MaintenanceVdsCommand<MaintenanceVdsParameters> maintenanceCommand) {
    MaintenanceVdsParameters parameters = (MaintenanceVdsParameters) maintenanceCommand.getParameters();
    VdsDynamic host = DbFacade.getInstance().getVdsDynamicDao().get(parameters.getVdsId());
    switch(host.getStatus()) {
        // Wait till moving to maintenance ends
        case PreparingForMaintenance:
            break;
        // Stop Gluster processes
        case Maintenance:
            log.info("Host '{}' is on maintenance mode. Stoping all gluster services.", getHostName(parameters.getVdsId()));
            stopGlusterServices(parameters.getVdsId());
            maintenanceCommand.setCommandStatus(CommandStatus.SUCCEEDED);
            break;
        // Any other status implies maintenance action failed, and the callback cannot proceed with stopping gluster's services
        default:
            if (isMaintenanceCommandExecuted(maintenanceCommand)) {
                log.info("Host '{}' failed to move to maintenance mode. Could not stop Gluster services.", getHostName(parameters.getVdsId()));
                maintenanceCommand.setCommandStatus(CommandStatus.FAILED);
            }
            break;
    }
}
#method_after
private void evaluateMaintenanceHostCommandProgress(MaintenanceVdsCommand<MaintenanceVdsParameters> maintenanceCommand) {
    MaintenanceVdsParameters parameters = maintenanceCommand.getParameters();
    VdsDynamic host = vdsDynamicDao.get(parameters.getVdsId());
    switch(host.getStatus()) {
        // Wait till moving to maintenance ends
        case PreparingForMaintenance:
            break;
        // Stop Gluster processes
        case Maintenance:
            log.info("Host '{}' is on maintenance mode. Stoping all gluster services.", getHostName(parameters.getVdsId()));
            stopGlusterServices(parameters.getVdsId());
            maintenanceCommand.setCommandStatus(CommandStatus.SUCCEEDED);
            break;
        // Any other status implies maintenance action failed, and the callback cannot proceed with stopping gluster's services
        default:
            if (isMaintenanceCommandExecuted(maintenanceCommand)) {
                log.info("Host '{}' failed to move to maintenance mode. Could not stop Gluster services.", getHostName(parameters.getVdsId()));
                maintenanceCommand.setCommandStatus(CommandStatus.FAILED);
            }
            break;
    }
}
#end_block

#method_before
private void stopGlusterServices(Guid vdsId) {
    ResourceManager resourceManager = ResourceManager.getInstance();
    GlusterBrickDao glusterBrickDao = DbFacade.getInstance().getGlusterBrickDao();
    // Stop glusterd service first
    boolean succeeded = resourceManager.runVdsCommand(VDSCommandType.ManageGlusterService, new GlusterServiceVDSParameters(vdsId, Arrays.asList("glusterd"), "stop")).getSucceeded();
    if (succeeded) {
        // Stop other gluster related processes on the node
        succeeded = resourceManager.runVdsCommand(VDSCommandType.StopGlusterProcesses, new VdsIdVDSCommandParametersBase(vdsId)).getSucceeded();
        // Mark the bricks as DOWN on this node
        if (succeeded) {
            List<GlusterBrickEntity> bricks = glusterBrickDao.getGlusterVolumeBricksByServerId(vdsId);
            bricks.stream().forEach(brick -> brick.setStatus(GlusterStatus.DOWN));
            glusterBrickDao.updateBrickStatuses(bricks);
        }
    }
    if (!succeeded) {
        log.error("Failed to stop gluster services while moving the host '{}' to maintenance", getHostName(vdsId));
    }
}
#method_after
private void stopGlusterServices(Guid vdsId) {
    // Stop glusterd service first
    boolean succeeded = resourceManager.runVdsCommand(VDSCommandType.ManageGlusterService, new GlusterServiceVDSParameters(vdsId, Arrays.asList("glusterd"), "stop")).getSucceeded();
    if (succeeded) {
        // Stop other gluster related processes on the node
        succeeded = resourceManager.runVdsCommand(VDSCommandType.StopGlusterProcesses, new VdsIdVDSCommandParametersBase(vdsId)).getSucceeded();
        // Mark the bricks as DOWN on this node
        if (succeeded) {
            List<GlusterBrickEntity> bricks = glusterBrickDao.getGlusterVolumeBricksByServerId(vdsId);
            bricks.stream().forEach(brick -> brick.setStatus(GlusterStatus.DOWN));
            glusterBrickDao.updateBrickStatuses(bricks);
        }
    }
    if (!succeeded) {
        log.error("Failed to stop gluster services while moving the host '{}' to maintenance", getHostName(vdsId));
    }
}
#end_block

#method_before
private String getHostName(Guid hostId) {
    if (hostName == null) {
        VdsStatic host = DbFacade.getInstance().getVdsStaticDao().get(hostId);
        hostName = host == null ? null : host.getName();
    }
    return hostName;
}
#method_after
private String getHostName(Guid hostId) {
    if (hostName == null) {
        VdsStatic host = vdsStaticDao.get(hostId);
        hostName = host == null ? null : host.getName();
    }
    return hostName;
}
#end_block

#method_before
@Override
public DiskAttachments list() {
    DiskAttachments attachments = new DiskAttachments();
    attachments.getDiskAttachments().addAll(parent.getDiskMap().values().stream().map(d -> map(d.getDiskVmElementForVm(parent.vm.getId()))).collect(Collectors.toList()));
    return attachments;
}
#method_after
// TODO: Currently we don't add links as the they are wrongly pointing to /vms/{vm_id}/diskattachemnts
// instead of /storagedomains/{storage_id}/vms/{vm_id}/diskattachments
@Override
public DiskAttachments list() {
    DiskAttachments attachments = new DiskAttachments();
    attachments.getDiskAttachments().addAll(parent.getDiskMap().values().stream().map(d -> map(d.getDiskVmElementForVm(parent.vm.getId()))).collect(Collectors.toList()));
    return attachments;
}
#end_block

#method_before
@Override
public StorageDomainVmDiskAttachmentResource getAttachmentResource(@PathParam("id") String id) {
    return inject(new BackendExportDomainDiskAttachmentResource(id, this));
}
#method_after
@Override
public StorageDomainVmDiskAttachmentResource getAttachmentResource(String id) {
    return inject(new BackendExportDomainDiskAttachmentResource(id, this));
}
#end_block

#method_before
@Override
public DiskAttachment get() {
    DiskVmElement dve = parent.getDiskAttachment(asGuid(attachmentId));
    if (dve == null) {
        return notFound();
    }
    return map(dve);
}
#method_after
@Override
public DiskAttachment get() {
    DiskVmElement dve = parent.getDiskAttachment(asGuid(attachmentId));
    if (dve == null) {
        return notFound();
    }
    // this needs to be added once the problem is solved
    return map(dve);
}
#end_block

#method_before
public void updateHostStatusAfterSuccessfulUpgrade() {
    VdsDynamic dynamicHostData = hostDao.get(getVdsId());
    dynamicHostData.setUpdateAvailable(false);
    hostDao.update(dynamicHostData);
    if (getVds().getVdsType() == VDSType.VDS) {
        reestablishConnectionIfNeeded();
        if (getParameters().getInitialStatus() == VDSStatus.Maintenance) {
            setVdsStatus(VDSStatus.Maintenance);
        } else {
            if (getVds().getHighlyAvailableIsConfigured()) {
                SetHaMaintenanceModeVDSCommandParameters param = new SetHaMaintenanceModeVDSCommandParameters(getVds(), HaMaintenanceMode.LOCAL, false);
                if (!runVdsCommand(VDSCommandType.SetHaMaintenanceMode, param).getSucceeded()) {
                    log.error("Failed to set local maintenance mode to none for host '{}' after upgrade has ended.", getVdsName());
                }
            }
            setVdsStatus(VDSStatus.Initializing);
        }
    }
}
#method_after
public void updateHostStatusAfterSuccessfulUpgrade() {
    VdsDynamic dynamicHostData = hostDao.get(getVdsId());
    dynamicHostData.setUpdateAvailable(false);
    hostDao.update(dynamicHostData);
    if (getVds().getVdsType() == VDSType.VDS) {
        reestablishConnectionIfNeeded();
        if (getParameters().getInitialStatus() == VDSStatus.Maintenance) {
            setVdsStatus(VDSStatus.Maintenance);
        } else {
            if (getVds().getHighlyAvailableIsConfigured()) {
                haMaintenanceFailed = !hostedEngineHelper.updateHaLocalMaintenanceMode(getVds(), false);
            }
            setVdsStatus(VDSStatus.Initializing);
        }
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.HOST_UPGRADE_FINISHED : AuditLogType.HOST_UPGRADE_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        return haMaintenanceFailed ? AuditLogType.HOST_UPGRADE_FINISHED_MANUAL_HA : AuditLogType.HOST_UPGRADE_FINISHED;
    }
    return AuditLogType.HOST_UPGRADE_FAILED;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    executeInNewTransaction(() -> {
        setStorageDomainStatus(StorageDomainStatus.Locked, getCompensationContext());
        getCompensationContext().stateChanged();
        return null;
    });
    runVdsCommand(VDSCommandType.ExtendStorageDomain, new ExtendStorageDomainVDSCommandParameters(getStoragePoolId(), getStorageDomain().getId(), getParameters().getLunIds(), getParameters().isForce()));
    getParameters().setLunsList(getVgInfo());
    executeInNewTransaction(() -> {
        for (LUNs lun : getParameters().getLunsList()) {
            proceedLUNInDb(lun, getStorageDomain().getStorageType(), getStorageDomain().getStorage());
        }
        setStorageDomainStatus(StorageDomainStatus.Active, null);
        getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
        return null;
    });
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    executeInNewTransaction(() -> {
        setStorageDomainStatus(StorageDomainStatus.Locked, getCompensationContext());
        getCompensationContext().stateChanged();
        return null;
    });
    runVdsCommand(VDSCommandType.ExtendStorageDomain, new ExtendStorageDomainVDSCommandParameters(getStoragePoolId(), getStorageDomain().getId(), getParameters().getLunIds(), getParameters().isForce()));
    updateLunsList();
    executeInNewTransaction(() -> {
        for (LUNs lun : getParameters().getLunsList()) {
            proceedLUNInDb(lun, getStorageDomain().getStorageType(), getStorageDomain().getStorage());
        }
        setStorageDomainStatus(StorageDomainStatus.Active, null);
        getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
        return null;
    });
    setSucceeded(true);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected boolean validate() {
    super.validate();
    if (isLunsAlreadyInUse(getParameters().getLunIds())) {
        return false;
    }
    if (!(checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getStorageDomain().getStorageType().isBlockDomain()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        return false;
    }
    final ConnectAllHostsToLunCommandReturnValue connectResult = (ConnectAllHostsToLunCommandReturnValue) runInternalAction(VdcActionType.ConnectAllHostsToLun, new ExtendSANStorageDomainParameters(getParameters().getStorageDomainId(), getParameters().getLunIds()));
    if (!connectResult.getSucceeded()) {
        addValidationMessage(EngineMessage.ERROR_CANNOT_EXTEND_CONNECTION_FAILED);
        if (connectResult.getFailedVds() != null) {
            getReturnValue().getValidationMessages().add(String.format("$hostName %1s", connectResult.getFailedVds().getName()));
        }
        String lunId = connectResult.getFailedLun() != null ? connectResult.getFailedLun().getLUNId() : "";
        getReturnValue().getValidationMessages().add(String.format("$lun %1s", lunId));
        return false;
    }
    return true;
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected boolean validate() {
    super.validate();
    if (isLunsAlreadyInUse(getParameters().getLunIds())) {
        return false;
    }
    if (!(checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getStorageDomain().getStorageType().isBlockDomain()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        return false;
    }
    final ConnectAllHostsToLunCommandReturnValue connectResult = (ConnectAllHostsToLunCommandReturnValue) runInternalAction(VdcActionType.ConnectAllHostsToLun, new ExtendSANStorageDomainParameters(getParameters().getStorageDomainId(), getParameters().getLunIds()));
    if (!connectResult.getSucceeded()) {
        addValidationMessage(EngineMessage.ERROR_CANNOT_EXTEND_CONNECTION_FAILED);
        if (connectResult.getFailedVds() != null) {
            getReturnValue().getValidationMessages().add(String.format("$hostName %1s", connectResult.getFailedVds().getName()));
        }
        String lunId = connectResult.getFailedLun() != null ? connectResult.getFailedLun().getLUNId() : "";
        getReturnValue().getValidationMessages().add(String.format("$lun %1s", lunId));
        return false;
    } else {
        // use luns list from connect command
        getParameters().setLunsList(connectResult.getActionReturnValue());
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final List<LUNs> lunsFromVgInfo = (List<LUNs>) runVdsCommand(VDSCommandType.GetVGInfo, new GetVGInfoVDSCommandParameters(getVds().getId(), getStorageDomain().getStorage())).getReturnValue();
    final List<LUNs> lunsFromDb = getLunDao().getAllForVolumeGroup(getStorageDomain().getStorage());
    List<LUNs> lunsToUpdateInDb = getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb);
    if (!lunsToUpdateInDb.isEmpty()) {
        TransactionSupport.executeInNewTransaction(() -> {
            updateLunsInDb(lunsToUpdateInDb);
            refreshLunsConnections(lunsFromVgInfo);
            cleanupLunsFromDb(lunsFromVgInfo, lunsFromDb);
            return null;
        });
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final List<LUNs> lunsFromVgInfo = (List<LUNs>) runVdsCommand(VDSCommandType.GetVGInfo, new GetVGInfoVDSCommandParameters(getVds().getId(), getStorageDomain().getStorage())).getReturnValue();
    final List<LUNs> lunsFromDb = getLunDao().getAllForVolumeGroup(getStorageDomain().getStorage());
    Map<Consumer<List<LUNs>>, List<LUNs>> lunsToUpdateInDb = getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb);
    boolean dbShouldBeUpdated = // There are existing luns that should be updated.
    lunsToUpdateInDb.containsKey(updateExistingLuns) || // There are new luns that should be saved.
    lunsToUpdateInDb.containsKey(saveNewLuns);
    if (dbShouldBeUpdated) {
        TransactionSupport.executeInNewTransaction(() -> {
            updateLunsInDb(lunsToUpdateInDb);
            refreshLunsConnections(lunsFromVgInfo);
            cleanupLunsFromDb(lunsFromVgInfo, lunsFromDb);
            return null;
        });
    }
    setSucceeded(true);
}
#end_block

#method_before
protected List<LUNs> getLunsToUpdateInDb(List<LUNs> lunsFromVgInfo, List<LUNs> lunsFromDb) {
    List<LUNs> lunsToUpdateInDb = new LinkedList<>();
    Map<String, LUNs> lunsFromDbLunIdMap = lunsFromDb.stream().collect(Collectors.toMap(LUNs::getLUNId, Function.identity()));
    Map<String, LUNs> lunsFromDbPvIdMap = lunsFromDb.stream().collect(Collectors.toMap(LUNs::getPhysicalVolumeId, Function.identity()));
    for (LUNs lunFromVgInfo : lunsFromVgInfo) {
        boolean lunIdExistsInDb = lunsFromDbLunIdMap.containsKey(lunFromVgInfo.getLUNId());
        boolean pvIdExistsInDb = lunsFromDbPvIdMap.containsKey(lunFromVgInfo.getPhysicalVolumeId());
        if (lunIdExistsInDb && pvIdExistsInDb) {
            // Existing lun, check if it should be updated.
            LUNs lunFromDb = lunsFromDbLunIdMap.get(lunFromVgInfo.getLUNId());
            if (lunFromDb.getDeviceSize() != lunFromVgInfo.getDeviceSize()) {
                lunsToUpdateInDb.add(lunFromVgInfo);
            }
        } else {
            // !lunIdExistsInDb && !pvIdExistsInDb -> new lun.
            // lunIdExistsInDb && !pvIdExistsInDb -> old pv id.
            // !lunIdExistsInDb && pvIdExistsInDb -> using storage from backup.
            lunsToUpdateInDb.add(lunFromVgInfo);
        }
    }
    return lunsToUpdateInDb;
}
#method_after
protected Map<Consumer<List<LUNs>>, List<LUNs>> getLunsToUpdateInDb(List<LUNs> lunsFromVgInfo, List<LUNs> lunsFromDb) {
    Map<String, LUNs> lunsFromDbMap = lunsFromDb.stream().collect(Collectors.toMap(LUNs::getLUNId, Function.identity()));
    return lunsFromVgInfo.stream().collect(Collectors.groupingBy(lunFromVgInfo -> {
        LUNs lunFromDb = lunsFromDbMap.get(lunFromVgInfo.getLUNId());
        if (lunFromDb == null) {
            // 2. lunFromDb has the same pv id and a different lun id -> using storage from backup.
            return saveNewLuns;
        }
        boolean lunFromDbHasSamePvId = Objects.equals(lunFromDb.getPhysicalVolumeId(), lunFromVgInfo.getPhysicalVolumeId());
        if (lunFromDbHasSamePvId) {
            // Existing lun, check if it should be updated.
            if (lunFromDb.getDeviceSize() != lunFromVgInfo.getDeviceSize()) {
                return updateExistingLuns;
            }
            // Existing lun is up to date.
            return noOp;
        }
        // lunFromDb has the same lun id and a different pv id -> old pv id.
        return updateExistingLuns;
    }));
}
#end_block

#method_before
protected void updateLunsInDb(List<LUNs> lunsToUpdateInDb) {
    for (LUNs lunToUpdateInDb : lunsToUpdateInDb) {
        LUNs lunFromDB = getLunDao().get(lunToUpdateInDb.getLUNId());
        if (lunFromDB == null) {
            getLunDao().save(lunToUpdateInDb);
            log.info("New LUN discovered, ID '{}'", lunToUpdateInDb.getLUNId());
        } else {
            if (lunFromDB.getDeviceSize() != lunToUpdateInDb.getDeviceSize()) {
                log.info("Updated LUN device size - ID '{}', previous size {}, new size {}.", lunToUpdateInDb.getLUNId(), lunFromDB.getDeviceSize(), lunToUpdateInDb.getDeviceSize());
            } else {
                log.info("Updated LUN information, ID '{}'.", lunToUpdateInDb.getLUNId());
            }
            getLunDao().update(lunToUpdateInDb);
        }
    }
}
#method_after
protected void updateLunsInDb(Map<Consumer<List<LUNs>>, List<LUNs>> lunsToUpdateInDb) {
    lunsToUpdateInDb.entrySet().stream().forEach(entry -> entry.getKey().accept(entry.getValue()));
}
#end_block

#method_before
@Before
public void setUp() {
    parameters = new StorageDomainParametersBase(Guid.newGuid());
    parameters.setVdsId(Guid.newGuid());
    command = spy(new SyncLunsInfoForBlockStorageDomainCommand<>(parameters, null));
    doReturn(lunDao).when(command).getLunDao();
}
#method_after
@Before
public void setUp() {
    parameters = new StorageDomainParametersBase(Guid.newGuid());
    parameters.setVdsId(Guid.newGuid());
    command = spy(new SyncLunsInfoForBlockStorageDomainCommand<>(parameters, null));
}
#end_block

#method_before
@Test
public void testGetLunsToUpdateInDbDiffLunIdDiffPvId() {
    Guid lunFromVgLunId = Guid.newGuid();
    List<LUNs> lunsToUpdateInDb = getLunsToUpdateInDb(lunFromVgLunId, Guid.newGuid(), Guid.newGuid(), Guid.newGuid());
    assertTrue(Objects.equals(lunsToUpdateInDb.stream().map(LUNs::getLUNId).findFirst().orElse(null), lunFromVgLunId.toString()));
}
#method_after
@Test
public void testGetLunsToUpdateInDbDiffLunIdDiffPvId() {
    Guid lunFromVgLunId = Guid.newGuid();
    List<LUNs> newLunsToSaveInDb = getLunsToUpdateInDb(lunFromVgLunId, Guid.newGuid(), Guid.newGuid(), Guid.newGuid()).get(command.saveNewLuns);
    assertLunIdInList(newLunsToSaveInDb, lunFromVgLunId);
}
#end_block

#method_before
@Test
public void testGetLunsToUpdateInDbSameLunIdDiffPvId() {
    Guid lunId = Guid.newGuid();
    List<LUNs> lunsToUpdateInDb = getLunsToUpdateInDb(lunId, lunId, Guid.newGuid(), Guid.newGuid());
    assertTrue(Objects.equals(lunsToUpdateInDb.stream().map(LUNs::getLUNId).findFirst().orElse(null), lunId.toString()));
}
#method_after
@Test
public void testGetLunsToUpdateInDbSameLunIdDiffPvId() {
    Guid lunId = Guid.newGuid();
    List<LUNs> existingLunsToUpdateInDb = getLunsToUpdateInDb(lunId, lunId, Guid.newGuid(), Guid.newGuid()).get(command.updateExistingLuns);
    assertLunIdInList(existingLunsToUpdateInDb, lunId);
}
#end_block

#method_before
@Test
public void testGetLunsToUpdateInDbDiffLunIdSamePvId() {
    Guid pvID = Guid.newGuid();
    List<LUNs> lunsToUpdateInDb = getLunsToUpdateInDb(Guid.newGuid(), Guid.newGuid(), pvID, pvID);
    assertTrue(Objects.equals(lunsToUpdateInDb.stream().map(LUNs::getPhysicalVolumeId).findFirst().orElse(null), pvID.toString()));
}
#method_after
@Test
public void testGetLunsToUpdateInDbDiffLunIdSamePvId() {
    Guid pvID = Guid.newGuid();
    Guid lunFromVgLunId = Guid.newGuid();
    List<LUNs> newLunsToSaveInDb = getLunsToUpdateInDb(lunFromVgLunId, Guid.newGuid(), pvID, pvID).get(command.saveNewLuns);
    assertLunIdInList(newLunsToSaveInDb, lunFromVgLunId);
}
#end_block

#method_before
private List<LUNs> getLunsToUpdateInDb(Guid lunFromVgLunId, Guid lunFromDbLunId, Guid lunFromVgPvId, Guid lunFromDbPvId) {
    LUNs lunFromVG = new LUNs();
    lunFromVG.setLUNId(lunFromVgLunId.toString());
    lunFromVG.setPhysicalVolumeId(lunFromVgPvId.toString());
    LUNs lunFromDB = new LUNs();
    lunFromDB.setLUNId(lunFromDbLunId.toString());
    lunFromDB.setPhysicalVolumeId(lunFromDbPvId.toString());
    return getLunsToUpdateInDb(lunFromVG, lunFromDB);
}
#method_after
private Map<Consumer<List<LUNs>>, List<LUNs>> getLunsToUpdateInDb(Guid lunFromVgLunId, Guid lunFromDbLunId, Guid lunFromVgPvId, Guid lunFromDbPvId) {
    LUNs lunFromVG = new LUNs();
    lunFromVG.setLUNId(lunFromVgLunId.toString());
    lunFromVG.setPhysicalVolumeId(lunFromVgPvId.toString());
    LUNs lunFromDB = new LUNs();
    lunFromDB.setLUNId(lunFromDbLunId.toString());
    lunFromDB.setPhysicalVolumeId(lunFromDbPvId.toString());
    return getLunsToUpdateInDb(lunFromVG, lunFromDB);
}
#end_block

#method_before
@Test
public void testGetLunsToUpdateInDbForSameLun() {
    LUNs lun = new LUNs();
    lun.setLUNId(Guid.newGuid().toString());
    lun.setPhysicalVolumeId(Guid.newGuid().toString());
    List<LUNs> lunsToUpdateInDb = getLunsToUpdateInDb(lun, lun);
    assertTrue(lunsToUpdateInDb.isEmpty());
}
#method_after
@Test
public void testGetLunsToUpdateInDbForSameLun() {
    LUNs lun = new LUNs();
    Guid lunId = Guid.newGuid();
    lun.setLUNId(lunId.toString());
    lun.setPhysicalVolumeId(Guid.newGuid().toString());
    List<LUNs> upToDateLuns = getLunsToUpdateInDb(lun, lun).get(command.noOp);
    assertLunIdInList(upToDateLuns, lunId);
}
#end_block

#method_before
@Test
public void testGetLunsToUpdateInDbDiffDeviceSize() {
    Guid pvID = Guid.newGuid();
    Guid lunID = Guid.newGuid();
    LUNs lunFromVG = new LUNs();
    lunFromVG.setLUNId(lunID.toString());
    lunFromVG.setPhysicalVolumeId(pvID.toString());
    lunFromVG.setDeviceSize(20);
    LUNs lunFromDB = new LUNs();
    lunFromDB.setLUNId(lunID.toString());
    lunFromDB.setPhysicalVolumeId(pvID.toString());
    lunFromDB.setDeviceSize(10);
    List<LUNs> lunsToUpdateInDb = getLunsToUpdateInDb(lunFromVG, lunFromDB);
    assertTrue(Objects.equals(lunsToUpdateInDb.stream().map(LUNs::getLUNId).findFirst().orElse(null), lunID.toString()));
}
#method_after
@Test
public void testGetLunsToUpdateInDbDiffDeviceSize() {
    Guid pvID = Guid.newGuid();
    Guid lunID = Guid.newGuid();
    LUNs lunFromVG = new LUNs();
    lunFromVG.setLUNId(lunID.toString());
    lunFromVG.setPhysicalVolumeId(pvID.toString());
    lunFromVG.setDeviceSize(20);
    LUNs lunFromDB = new LUNs();
    lunFromDB.setLUNId(lunID.toString());
    lunFromDB.setPhysicalVolumeId(pvID.toString());
    lunFromDB.setDeviceSize(10);
    List<LUNs> existingLunsToUpdateInDb = getLunsToUpdateInDb(lunFromVG, lunFromDB).get(command.updateExistingLuns);
    assertLunIdInList(existingLunsToUpdateInDb, lunID);
}
#end_block

#method_before
private List<LUNs> getLunsToUpdateInDb(LUNs lunFromVG, LUNs lunFromDB) {
    List<LUNs> lunsFromVgInfo = Collections.singletonList(lunFromVG);
    List<LUNs> lunsFromDb = Collections.singletonList(lunFromDB);
    return command.getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb);
}
#method_after
private Map<Consumer<List<LUNs>>, List<LUNs>> getLunsToUpdateInDb(LUNs lunFromVG, LUNs lunFromDB) {
    List<LUNs> lunsFromVgInfo = Collections.singletonList(lunFromVG);
    List<LUNs> lunsFromDb = Collections.singletonList(lunFromDB);
    return command.getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb);
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        serviceLoader.loadService(PmHealthCheckManager.class);
        serviceLoader.loadService(EngineBackupAwarenessManager.class);
        CommandCoordinatorUtil.initAsyncTaskManager();
        serviceLoader.loadService(CommandCallbacksPoller.class);
        serviceLoader.loadService(ResourceManager.class);
        serviceLoader.loadService(IrsProxyManager.class);
        OvfDataUpdater.getInstance().initOvfDataUpdater();
        StoragePoolStatusHandler.init();
        GlusterJobsManager.init();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        serviceLoader.loadService(SchedulingManager.class);
        sessionDataContainer.cleanupEngineSessionsOnStartup();
        serviceLoader.loadService(HostDeviceManager.class);
        serviceLoader.loadService(DwhHeartBeat.class);
        if (Config.<Boolean>getValue(ConfigValues.AffinityRulesEnforcementManagerEnabled)) {
            serviceLoader.loadService(AffinityRulesEnforcementManager.class);
        }
        serviceLoader.loadService(CertificationValidityChecker.class);
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#method_after
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        serviceLoader.load(PmHealthCheckManager.class);
        serviceLoader.load(EngineBackupAwarenessManager.class);
        CommandCoordinatorUtil.initAsyncTaskManager();
        serviceLoader.load(CommandCallbacksPoller.class);
        serviceLoader.load(ResourceManager.class);
        OvfDataUpdater.getInstance().initOvfDataUpdater();
        StoragePoolStatusHandler.init();
        GlusterJobsManager.init();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        serviceLoader.load(SchedulingManager.class);
        sessionDataContainer.cleanupEngineSessionsOnStartup();
        serviceLoader.load(HostDeviceManager.class);
        serviceLoader.load(DwhHeartBeat.class);
        if (Config.<Boolean>getValue(ConfigValues.AffinityRulesEnforcementManagerEnabled)) {
            serviceLoader.load(AffinityRulesEnforcementManager.class);
        }
        serviceLoader.load(CertificationValidityChecker.class);
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#end_block

#method_before
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // save host that HE VM was running on prior to engine startup
    serviceLoader.loadService(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.loadService(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.loadService(CpuFlagsManagerHandler.class);
    serviceLoader.loadService(AuditLogCleanupManager.class);
    serviceLoader.loadService(CommandEntityCleanupManager.class);
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.loadService(JobRepositoryCleanupManager.class);
    serviceLoader.loadService(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(sessionDataContainer, "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.loadService(VmsMonitoring.class);
    serviceLoader.loadService(VmDevicesMonitoring.class);
    serviceLoader.loadService(VmPoolHandler.class);
    serviceLoader.loadService(VmPoolMonitor.class);
    serviceLoader.loadService(HaAutoStartVmsRunner.class);
    serviceLoader.loadService(QuotaManager.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    registerIconDefaultsProvider();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#method_after
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(sessionDataContainer, "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmsMonitoring.class);
    serviceLoader.load(VmDevicesMonitoring.class);
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    registerIconDefaultsProvider();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
public static ValidationResult setAndValidateCpuProfile(VmBase vmBase, Guid userId) {
    if (vmBase.getCpuProfileId() == null) {
        return assignFirstCpuProfile(vmBase, userId);
    }
    CpuProfileValidator validator = new CpuProfileValidator(vmBase.getCpuProfileId());
    ValidationResult result = validator.isParentEntityValid(vmBase.getClusterId());
    if (!result.isValid()) {
        return result;
    }
    if (!checkPermissions(vmBase.getCpuProfileId(), userId)) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_NO_PERMISSION_TO_ASSIGN_CPU_PROFILE, String.format("$cpuProfileId %s", vmBase.getCpuProfileId()), String.format("$cpuProfileName %s", validator.getProfile().getName()));
    }
    return ValidationResult.VALID;
}
#method_after
public static ValidationResult setAndValidateCpuProfile(VmBase vmBase, Guid userId) {
    if (vmBase.getCpuProfileId() == null) {
        return assignFirstCpuProfile(vmBase, userId);
    }
    CpuProfileValidator validator = new CpuProfileValidator(vmBase.getCpuProfileId());
    ValidationResult result = validator.isParentEntityValid(vmBase.getClusterId());
    if (!result.isValid()) {
        return result;
    }
    if (!isProfilePermitted(vmBase.getCpuProfileId(), userId)) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_NO_PERMISSION_TO_ASSIGN_CPU_PROFILE, String.format("$cpuProfileId %s", vmBase.getCpuProfileId()), String.format("$cpuProfileName %s", validator.getProfile().getName()));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new HostedEngineEditNotifier(getVm()));
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new HostedEngineEditNotifier(getVm()));
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#end_block

#method_before
private boolean updateVm(VM vm, Version oldClusterVersion) {
    VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
    updateParams.setClusterLevelChangeFromVersion(oldClusterVersion);
    VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
    if (!result.getSucceeded()) {
        getReturnValue().setFault(result.getFault());
        return false;
    }
    return true;
}
#method_after
private boolean updateVm(VM vm, Version oldClusterVersion) {
    VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
    updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
    updateParams.setClusterLevelChangeFromVersion(oldClusterVersion);
    VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
    if (!result.getSucceeded()) {
        getReturnValue().setFault(result.getFault());
        return false;
    }
    return true;
}
#end_block

#method_before
@OnTimerMethodAnnotation("startFailedAutoStartVms")
public void startFailedAutoStartVms() {
    LinkedList<AutoStartVmToRestart> vmsToRemove = new LinkedList<>();
    final DateTime iterationStartTime = DateTime.getNow();
    final Date nextTimeOfRetryToRun = iterationStartTime.addSeconds(RETRY_TO_RUN_AUTO_START_VM_INTERVAL);
    final Date delayedTimeOfRetryToRun = iterationStartTime.addSeconds(DELAY_TO_RUN_AUTO_START_VM_INTERVAL);
    for (AutoStartVmToRestart autoStartVmToRestart : autoStartVmsToRestart) {
        // (we'll try again in the next iteration)
        if (!autoStartVmToRestart.isTimeToRun(iterationStartTime)) {
            continue;
        }
        Guid vmId = autoStartVmToRestart.getVmId();
        if (isNextRunConfiguration(vmId)) {
            // if the NextRun config exists then give the ProcessDownVmCommand time to apply it
            log.debug("NextRun config found for '{}' vm, the RunVm will be delayed", vmId);
            if (autoStartVmToRestart.delayNextTimeToRun(delayedTimeOfRetryToRun)) {
                // The priority is to run the VM even if the NextRun fails to be applied
                continue;
            }
            // Waiting for NextRun config is over, let's run the VM even with the non-applied Next-Run
            log.warn("Failed to wait for the NextRun config to be applied on vm '{}', trying to run the VM anyway", vmId);
            // start from the beginning if this attempt ro run fails
            autoStartVmToRestart.clearSkipCounter();
        }
        EngineLock runVmLock = createEngineLockForRunVm(vmId);
        // acquired, skip for now  and we'll try again in the next iteration
        if (!acquireLock(runVmLock)) {
            log.debug("Could not acquire lock for auto starting VM '{}'", vmId);
            continue;
        }
        if (!isVmNeedsToBeAutoStarted(vmId)) {
            // if the VM doesn't need to be auto started anymore, release the lock and
            // remove the VM from the collection of VMs that should be auto started
            releaseLock(runVmLock);
            vmsToRemove.add(autoStartVmToRestart);
            continue;
        }
        if (runVm(vmId, runVmLock)) {
            // the VM reached WaitForLunch, so from now on this job is not responsible
            // to auto start it, future failures will be detected by the monitoring
            vmsToRemove.add(autoStartVmToRestart);
        } else {
            logFailedAttemptToRestartVm(vmId);
            if (!autoStartVmToRestart.scheduleNextTimeToRun(nextTimeOfRetryToRun)) {
                // if we could not schedule the next time to run the VM, it means
                // that we reached the maximum number of tried so don't try anymore
                vmsToRemove.add(autoStartVmToRestart);
                logFailureToRestartVm(vmId);
            }
        }
    }
    autoStartVmsToRestart.removeAll(vmsToRemove);
}
#method_after
@OnTimerMethodAnnotation("startFailedAutoStartVms")
public void startFailedAutoStartVms() {
    LinkedList<AutoStartVmToRestart> vmsToRemove = new LinkedList<>();
    final DateTime iterationStartTime = DateTime.getNow();
    final Date nextTimeOfRetryToRun = iterationStartTime.addSeconds(RETRY_TO_RUN_AUTO_START_VM_INTERVAL);
    final Date delayedTimeOfRetryToRun = iterationStartTime.addSeconds(DELAY_TO_RUN_AUTO_START_VM_INTERVAL);
    for (AutoStartVmToRestart autoStartVmToRestart : autoStartVmsToRestart) {
        // (we'll try again in the next iteration)
        if (!autoStartVmToRestart.isTimeToRun(iterationStartTime)) {
            continue;
        }
        Guid vmId = autoStartVmToRestart.getVmId();
        if (isNextRunConfiguration(vmId)) {
            // if the NextRun config exists then give the ProcessDownVmCommand time to apply it
            log.debug("NextRun config found for '{}' vm, the RunVm will be delayed", vmId);
            if (autoStartVmToRestart.delayNextTimeToRun(delayedTimeOfRetryToRun)) {
                // The priority is to run the VM even if the NextRun fails to be applied
                continue;
            }
            // Waiting for NextRun config is over, let's run the VM even with the non-applied Next-Run
            log.warn("Failed to wait for the NextRun config to be applied on vm '{}', trying to run the VM anyway", vmId);
        }
        EngineLock runVmLock = createEngineLockForRunVm(vmId);
        // acquired, skip for now  and we'll try again in the next iteration
        if (!acquireLock(runVmLock)) {
            log.debug("Could not acquire lock for auto starting VM '{}'", vmId);
            continue;
        }
        if (!isVmNeedsToBeAutoStarted(vmId)) {
            // if the VM doesn't need to be auto started anymore, release the lock and
            // remove the VM from the collection of VMs that should be auto started
            releaseLock(runVmLock);
            vmsToRemove.add(autoStartVmToRestart);
            continue;
        }
        if (runVm(vmId, runVmLock)) {
            // the VM reached WaitForLunch, so from now on this job is not responsible
            // to auto start it, future failures will be detected by the monitoring
            vmsToRemove.add(autoStartVmToRestart);
        } else {
            logFailedAttemptToRestartVm(vmId);
            if (!autoStartVmToRestart.scheduleNextTimeToRun(nextTimeOfRetryToRun)) {
                // if we could not schedule the next time to run the VM, it means
                // that we reached the maximum number of tried so don't try anymore
                vmsToRemove.add(autoStartVmToRestart);
                logFailureToRestartVm(vmId);
            }
        }
    }
    autoStartVmsToRestart.removeAll(vmsToRemove);
}
#end_block

#method_before
boolean delayNextTimeToRun(Date timeToRunTheVm) {
    this.timeToRunTheVm = timeToRunTheVm;
    return ++numOfSkips < MAXIMUM_NUM_OF_SKIPS_BEFORE_AUTO_START_VM;
}
#method_after
boolean delayNextTimeToRun(Date timeToRunTheVm) {
    this.timeToRunTheVm = timeToRunTheVm;
    numOfSkips++;
    numOfSkips %= MAXIMUM_NUM_OF_SKIPS_BEFORE_AUTO_START_VM;
    return numOfSkips != 0;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.api.model.Cluster.class, to = Cluster.class)
public static Cluster map(org.ovirt.engine.api.model.Cluster model, Cluster template) {
    Cluster entity = template != null ? template : new Cluster();
    if (model.isSetSwitchType()) {
        entity.setRequiredSwitchTypeForCluster(SwitchTypeMapper.mapFromModel(model.getSwitchType()));
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCpu() && model.getCpu().isSetType()) {
        entity.setCpuName(model.getCpu().getType());
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        entity.setArchitecture(CPUMapper.map(model.getCpu().getArchitecture(), null));
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setCompatibilityVersion(VersionMapper.map(model.getVersion()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    SchedulingPolicy schedulingPolicy = model.getSchedulingPolicy();
    if (schedulingPolicy != null) {
        if (schedulingPolicy.isSetName()) {
            entity.setClusterPolicyName(schedulingPolicy.getName());
        }
        if (schedulingPolicy.isSetId()) {
            entity.setClusterPolicyId(GuidUtils.asGuid(schedulingPolicy.getId()));
        }
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetTrustedService()) {
        entity.setTrustedService(model.isTrustedService());
    }
    if (model.isSetHaReservation()) {
        entity.setHaReservation(model.isHaReservation());
    }
    if (model.isSetOptionalReason()) {
        entity.setOptionalReasonRequired(model.isOptionalReason());
    }
    if (model.isSetMaintenanceReasonRequired()) {
        entity.setMaintenanceReasonRequired(model.isMaintenanceReasonRequired());
    }
    if (model.isSetBallooningEnabled()) {
        entity.setEnableBallooning(model.isBallooningEnabled());
    }
    if (model.isSetKsm()) {
        if (model.getKsm().isSetEnabled()) {
            entity.setEnableKsm(model.getKsm().isEnabled());
        }
        if (model.getKsm().isSetMergeAcrossNodes()) {
            entity.setKsmMergeAcrossNumaNodes(model.getKsm().isMergeAcrossNodes());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    if (model.isSetRequiredRngSources()) {
        entity.getRequiredRngSources().clear();
        entity.getRequiredRngSources().addAll(RngDeviceMapper.mapRngSources(model.getRequiredRngSources().getRequiredRngSources()));
    }
    if (model.isSetFencingPolicy()) {
        entity.setFencingPolicy(FencingPolicyMapper.map(model.getFencingPolicy(), null));
    }
    if (model.isSetMigration()) {
        ClusterMigrationOptionsMapper.copyMigrationOptions(model.getMigration(), entity);
    }
    if (model.isSetMacPool() && model.getMacPool().isSetId()) {
        entity.setMacPoolId(GuidUtils.asGuid(model.getMacPool().getId()));
    }
    if (entity.getClusterPolicyProperties() == null && model.isSetCustomSchedulingPolicyProperties()) {
        entity.setClusterPolicyProperties(new LinkedHashMap<String, String>());
    }
    // properties will override thresholds
    if (model.isSetCustomSchedulingPolicyProperties()) {
        Map<String, String> properties = CustomPropertiesParser.toMap(model.getCustomSchedulingPolicyProperties());
        entity.getClusterPolicyProperties().putAll(properties);
    }
    return entity;
}
#method_after
@Mapping(from = org.ovirt.engine.api.model.Cluster.class, to = Cluster.class)
public static Cluster map(org.ovirt.engine.api.model.Cluster model, Cluster template) {
    Cluster entity = template != null ? template : new Cluster();
    if (model.isSetSwitchType()) {
        entity.setRequiredSwitchTypeForCluster(SwitchTypeMapper.mapFromModel(model.getSwitchType()));
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCpu() && model.getCpu().isSetType()) {
        entity.setCpuName(model.getCpu().getType());
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        entity.setArchitecture(CPUMapper.map(model.getCpu().getArchitecture(), null));
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setCompatibilityVersion(VersionMapper.map(model.getVersion()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    SchedulingPolicy schedulingPolicy = model.getSchedulingPolicy();
    if (schedulingPolicy != null) {
        if (schedulingPolicy.isSetName()) {
            entity.setClusterPolicyName(schedulingPolicy.getName());
        }
        if (schedulingPolicy.isSetId()) {
            entity.setClusterPolicyId(GuidUtils.asGuid(schedulingPolicy.getId()));
        }
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetTrustedService()) {
        entity.setTrustedService(model.isTrustedService());
    }
    if (model.isSetHaReservation()) {
        entity.setHaReservation(model.isHaReservation());
    }
    if (model.isSetOptionalReason()) {
        entity.setOptionalReasonRequired(model.isOptionalReason());
    }
    if (model.isSetMaintenanceReasonRequired()) {
        entity.setMaintenanceReasonRequired(model.isMaintenanceReasonRequired());
    }
    if (model.isSetBallooningEnabled()) {
        entity.setEnableBallooning(model.isBallooningEnabled());
    }
    if (model.isSetKsm()) {
        if (model.getKsm().isSetEnabled()) {
            entity.setEnableKsm(model.getKsm().isEnabled());
        }
        if (model.getKsm().isSetMergeAcrossNodes()) {
            entity.setKsmMergeAcrossNumaNodes(model.getKsm().isMergeAcrossNodes());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    if (model.isSetRequiredRngSources()) {
        entity.getRequiredRngSources().clear();
        entity.getRequiredRngSources().addAll(RngDeviceMapper.mapRngSources(model.getRequiredRngSources().getRequiredRngSources()));
    }
    if (model.isSetFencingPolicy()) {
        entity.setFencingPolicy(FencingPolicyMapper.map(model.getFencingPolicy(), null));
    }
    if (model.isSetMigration()) {
        ClusterMigrationOptionsMapper.copyMigrationOptions(model.getMigration(), entity);
    }
    if (model.isSetMacPool() && model.getMacPool().isSetId()) {
        entity.setMacPoolId(GuidUtils.asGuid(model.getMacPool().getId()));
    }
    // properties will override thresholds
    if (model.isSetCustomSchedulingPolicyProperties()) {
        Map<String, String> properties = entity.getClusterPolicyProperties();
        if (properties == null) {
            properties = new HashMap<>();
            entity.setClusterPolicyProperties(properties);
        }
        Map<String, String> customProperties = CustomPropertiesParser.toMap(model.getCustomSchedulingPolicyProperties());
        properties.putAll(customProperties);
    }
    return entity;
}
#end_block

#method_before
private void edit() {
    StorageDomain storage = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editDomainTitle());
    model.setHelpTag(HelpTag.edit_domain);
    // $NON-NLS-1$
    model.setHashName("edit_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.setStorage(storage);
    model.getName().setEntity(storage.getStorageName());
    model.getDescription().setEntity(storage.getDescription());
    model.getComment().setEntity(storage.getComment());
    model.setOriginalName(storage.getStorageName());
    model.getDataCenter().setIsChangeable(false);
    model.getFormat().setIsChangeable(false);
    boolean isStorageNameEditable = model.isStorageActive() || model.isNewStorage();
    boolean isStorageInMaintenance = !model.isNewStorage() && model.getStorage().getStatus() == StorageDomainStatus.Maintenance;
    model.getHost().setIsChangeable(false);
    model.getName().setIsChangeable(isStorageNameEditable);
    // set the field domain type to non editable
    model.getAvailableStorageTypeItems().setIsChangeable(false);
    model.getAvailableStorageDomainTypeItems().setIsChangeable(false);
    model.setIsChangeable((isStorageNameEditable) && !isStorageInMaintenance);
    model.getWarningLowSpaceIndicator().setEntity(storage.getWarningLowSpaceIndicator());
    model.getWarningLowSpaceSize().setEntity(ConstantsManager.getInstance().getMessages().bracketsWithGB(storage.getWarningLowSpaceSize()));
    model.getWarningLowSpaceSize().setIsAvailable(true);
    model.getCriticalSpaceActionBlocker().setEntity(storage.getCriticalSpaceActionBlocker());
    IStorageModel item = prepareStorageForEdit(storage, model);
    model.setStorageModels(new ArrayList<>(Arrays.asList(new IStorageModel[] { item })));
    model.setCurrentStorageItem(item);
    model.initialize();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        model.getName().setIsChangeable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    UICommand command;
    // $NON-NLS-1$
    command = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#method_after
private void edit() {
    StorageDomain storage = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editDomainTitle());
    model.setHelpTag(HelpTag.edit_domain);
    // $NON-NLS-1$
    model.setHashName("edit_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.setStorage(storage);
    model.getName().setEntity(storage.getStorageName());
    model.getDescription().setEntity(storage.getDescription());
    model.getComment().setEntity(storage.getComment());
    model.setOriginalName(storage.getStorageName());
    model.getDataCenter().setIsChangeable(false);
    model.getFormat().setIsChangeable(false);
    boolean isStorageNameEditable = model.isStorageActive() || model.isNewStorage();
    boolean isStorageInMaintenance = !model.isNewStorage() && model.getStorage().getStatus() == StorageDomainStatus.Maintenance;
    model.getHost().setIsChangeable(false);
    model.getName().setIsChangeable(isStorageNameEditable);
    // set the field domain type to non editable
    model.getAvailableStorageTypeItems().setIsChangeable(false);
    model.getAvailableStorageDomainTypeItems().setIsChangeable(false);
    model.setIsChangeable(isStorageNameEditable && !isStorageInMaintenance);
    model.getWarningLowSpaceIndicator().setEntity(storage.getWarningLowSpaceIndicator());
    model.getWarningLowSpaceSize().setEntity(ConstantsManager.getInstance().getMessages().bracketsWithGB(storage.getWarningLowSpaceSize()));
    model.getWarningLowSpaceSize().setIsAvailable(true);
    model.getCriticalSpaceActionBlocker().setEntity(storage.getCriticalSpaceActionBlocker());
    IStorageModel item = prepareStorageForEdit(storage, model);
    model.setStorageModels(new ArrayList<>(Arrays.asList(new IStorageModel[] { item })));
    model.setCurrentStorageItem(item);
    model.initialize();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        model.getName().setIsChangeable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    UICommand command;
    // $NON-NLS-1$
    command = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#end_block

#method_before
private static boolean compareGuidArrays(Guid[] guidsArrayToBeChecked, VmStatic[] vmStaticArrayInDescOrder) {
    boolean returnValue = true;
    if (guidsArrayToBeChecked.length == vmStaticArrayInDescOrder.length) {
        for (int i = 0; i < guidsArrayToBeChecked.length; i++) {
            if (!guidsArrayToBeChecked[i].equals(vmStaticArrayInDescOrder[i].getId())) {
                returnValue = false;
                break;
            }
        }
    }
    return returnValue;
}
#method_after
private static boolean compareGuidArrays(Guid[] guidsArrayToBeChecked, VmStatic[] vmStaticArrayInDescOrder) {
    return guidsArrayToBeChecked.length == vmStaticArrayInDescOrder.length && IntStream.range(0, guidsArrayToBeChecked.length).allMatch(i -> guidsArrayToBeChecked[i].equals(vmStaticArrayInDescOrder[i].getId()));
}
#end_block

#method_before
private String formProfileUrl(String clusterId, String volumeId, boolean isBrickProfileSelected) {
    // $NON-NLS-1$//$NON-NLS-2$
    String apiMatrixParam = !isBrickProfileSelected ? ";nfsStatistics=true" : "";
    // $NON-NLS-1$
    return StringFormat.format("/ovirt-engine/api/clusters/%s/glustervolumes/%s/profilestatistics%s?accept=text/plain", clusterId, volumeId, apiMatrixParam);
}
#method_after
private String formProfileUrl(String clusterId, String volumeId, boolean isBrickProfileSelected) {
    // $NON-NLS-1$//$NON-NLS-2$
    String apiMatrixParam = !isBrickProfileSelected ? ";nfsStatistics=true" : "";
    // $NON-NLS-1$
    return StringFormat.format("/ovirt-engine/api/clusters/%s/glustervolumes/%s/profilestatistics%s?accept=application/json", clusterId, volumeId, apiMatrixParam);
}
#end_block

#method_before
@PostConstruct
private void init() {
    // init the singleton. TODO remove once all code is using CDI
    setInstance(this);
}
#method_after
@PostConstruct
private void init() {
    // init the singleton. TODO remove once all code is using CDI
    setInstance(this);
    log.info("Start initializing {}", getClass().getSimpleName());
    populateVdsAndVmsList();
    // Populate the VDS dictionary
    final List<VDS> allVdsList = hostDao.getAll();
    for (VDS curVds : allVdsList) {
        addVds(curVds, true);
    }
    IrsBrokerCommand.init();
    log.info("Finished initializing {}", getClass().getSimpleName());
}
#end_block

#method_before
public void addVds(VDS vds, boolean isInternal) {
    VdsManager vdsManager = VdsManager.forVds(vds);
    if (isInternal) {
        VDSStatus status = vds.getStatus();
        switch(vds.getStatus()) {
            case Error:
                status = VDSStatus.Up;
                break;
            case Reboot:
            case NonResponsive:
            case Connecting:
            case Installing:
                status = VDSStatus.Unassigned;
                break;
        }
        if (status != vds.getStatus()) {
            vdsManager.setStatus(status, vds);
            vdsManager.updateStatisticsData(vds.getStatisticsData());
        }
        // set pending to 0
        vds.setPendingVcpusCount(0);
        vdsManager.updateDynamicData(vds.getDynamicData());
    }
    vdsManager.scheduleJobs();
    vdsManagersDict.put(vds.getId(), vdsManager);
    log.info("VDS '{}' was added to the Resource Manager", vds.getId());
}
#method_after
public void addVds(VDS vds, boolean isInternal) {
    VdsManager vdsManager = vdsManagerFactory.create(vds, this);
    if (isInternal) {
        VDSStatus status = vds.getStatus();
        switch(vds.getStatus()) {
            case Error:
                status = VDSStatus.Up;
                break;
            case Reboot:
            case NonResponsive:
            case Connecting:
            case Installing:
                status = VDSStatus.Unassigned;
                break;
        }
        if (status != vds.getStatus()) {
            vdsManager.setStatus(status, vds);
            vdsManager.updateStatisticsData(vds.getStatisticsData());
        }
        // set pending to 0
        vds.setPendingVcpusCount(0);
        vdsManager.updateDynamicData(vds.getDynamicData());
    }
    vdsManager.scheduleJobs();
    vdsManagersDict.put(vds.getId(), vdsManager);
    log.info("VDS '{}' was added to the Resource Manager", vds.getId());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final List<LUNs> lunsFromVgInfo = (List<LUNs>) runVdsCommand(VDSCommandType.GetVGInfo, new GetVGInfoVDSCommandParameters(getVds().getId(), getStorageDomain().getStorage())).getReturnValue();
    final List<LUNs> lunsFromDb = getLunDao().getAllForVolumeGroup(getStorageDomain().getStorage());
    if (isLunsInfoMismatch(lunsFromVgInfo, lunsFromDb)) {
        TransactionSupport.executeInNewTransaction(() -> {
            refreshLunsInfo(lunsFromVgInfo, lunsFromDb);
            return null;
        });
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final List<LUNs> lunsFromVgInfo = (List<LUNs>) runVdsCommand(VDSCommandType.GetVGInfo, new GetVGInfoVDSCommandParameters(getVds().getId(), getStorageDomain().getStorage())).getReturnValue();
    final List<LUNs> lunsFromDb = getLunDao().getAllForVolumeGroup(getStorageDomain().getStorage());
    List<LUNs> lunsToUpdateInDb = getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb);
    if (lunsFromDb.size() != lunsFromVgInfo.size() || !lunsToUpdateInDb.isEmpty()) {
        TransactionSupport.executeInNewTransaction(() -> {
            updateLunsInDb(lunsToUpdateInDb);
            refreshLunsConnections(lunsFromVgInfo);
            cleanupLunsFromDb(lunsFromVgInfo, lunsFromDb);
            return null;
        });
    }
    setSucceeded(true);
}
#end_block

#method_before
@Test
public void lunsMismatchWrongId() {
    Guid pvID = Guid.newGuid();
    LUNs lunFromVG = new LUNs();
    lunFromVG.setLUNId(Guid.newGuid().toString());
    lunFromVG.setPhysicalVolumeId(pvID.toString());
    LUNs lunFromDB = new LUNs();
    lunFromDB.setLUNId(Guid.newGuid().toString());
    lunFromDB.setPhysicalVolumeId(pvID.toString());
    List<LUNs> lunsFromVgInfo = Collections.singletonList(lunFromVG);
    List<LUNs> lunsFromDb = Collections.singletonList(lunFromDB);
    boolean isMismatch = command.isLunsInfoMismatch(lunsFromVgInfo, lunsFromDb);
    assertTrue(isMismatch);
}
#method_after
@Test
public void lunsMismatchWrongId() {
    Guid pvID = Guid.newGuid();
    LUNs lunFromVG = new LUNs();
    lunFromVG.setLUNId(Guid.newGuid().toString());
    lunFromVG.setPhysicalVolumeId(pvID.toString());
    LUNs lunFromDB = new LUNs();
    lunFromDB.setLUNId(Guid.newGuid().toString());
    lunFromDB.setPhysicalVolumeId(pvID.toString());
    List<LUNs> lunsFromVgInfo = Collections.singletonList(lunFromVG);
    List<LUNs> lunsFromDb = Collections.singletonList(lunFromDB);
    boolean isMatch = command.getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb).isEmpty();
    assertFalse(isMatch);
}
#end_block

#method_before
@Test
public void lunsMatch() {
    LUNs lun = new LUNs();
    lun.setLUNId(Guid.newGuid().toString());
    lun.setPhysicalVolumeId(Guid.newGuid().toString());
    List<LUNs> lunsFromVgInfo = Arrays.asList(lun, lun);
    List<LUNs> lunsFromDb = Arrays.asList(lun, lun);
    boolean isMismatch = command.isLunsInfoMismatch(lunsFromVgInfo, lunsFromDb);
    assertFalse(isMismatch);
}
#method_after
@Test
public void lunsMatch() {
    LUNs lun = new LUNs();
    lun.setLUNId(Guid.newGuid().toString());
    lun.setPhysicalVolumeId(Guid.newGuid().toString());
    List<LUNs> lunsFromVgInfo = Arrays.asList(lun, lun);
    List<LUNs> lunsFromDb = Arrays.asList(lun, lun);
    boolean isMatch = command.getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb).isEmpty();
    assertTrue(isMatch);
}
#end_block

#method_before
@Test
public void lunsMismatchDeviceSize() {
    Guid pvID = Guid.newGuid();
    Guid lunID = Guid.newGuid();
    LUNs lunFromVG = new LUNs();
    lunFromVG.setLUNId(lunID.toString());
    lunFromVG.setPhysicalVolumeId(pvID.toString());
    lunFromVG.setDeviceSize(20);
    LUNs lunFromDB = new LUNs();
    lunFromDB.setLUNId(lunID.toString());
    lunFromDB.setPhysicalVolumeId(pvID.toString());
    lunFromDB.setDeviceSize(10);
    List<LUNs> lunsFromVgInfo = Collections.singletonList(lunFromVG);
    List<LUNs> lunsFromDb = Collections.singletonList(lunFromDB);
    assertTrue(command.isLunsInfoMismatch(lunsFromVgInfo, lunsFromDb));
}
#method_after
@Test
public void lunsMismatchDeviceSize() {
    Guid pvID = Guid.newGuid();
    Guid lunID = Guid.newGuid();
    LUNs lunFromVG = new LUNs();
    lunFromVG.setLUNId(lunID.toString());
    lunFromVG.setPhysicalVolumeId(pvID.toString());
    lunFromVG.setDeviceSize(20);
    LUNs lunFromDB = new LUNs();
    lunFromDB.setLUNId(lunID.toString());
    lunFromDB.setPhysicalVolumeId(pvID.toString());
    lunFromDB.setDeviceSize(10);
    List<LUNs> lunsFromVgInfo = Collections.singletonList(lunFromVG);
    List<LUNs> lunsFromDb = Collections.singletonList(lunFromDB);
    assertFalse(command.getLunsToUpdateInDb(lunsFromVgInfo, lunsFromDb).isEmpty());
}
#end_block

#method_before
@Test
public void lunsWithSameIdMismatch() {
    LunDao lunDao = mock(LunDao.class);
    doReturn(lunDao).when(command).getLunDao();
    LUNs luns = new LUNs();
    doReturn(luns).when(lunDao).get(anyString());
    command.updateLunInDb(luns);
    verify(lunDao, times(1)).update(any(LUNs.class));
}
#method_after
@Test
public void lunsWithSameIdMismatch() {
    LunDao lunDao = mock(LunDao.class);
    doReturn(lunDao).when(command).getLunDao();
    LUNs luns = new LUNs();
    doReturn(luns).when(lunDao).get(anyString());
    command.updateLunsInDb(Collections.singletonList(luns));
    verify(lunDao, times(1)).update(any(LUNs.class));
}
#end_block

#method_before
@Override
protected void init() {
    updateMigrateOnError();
    oldCluster = getClusterDao().get(getCluster().getId());
}
#method_after
@Override
protected void init() {
    updateMigrateOnError();
    oldCluster = getClusterDao().get(getCluster().getId());
    if (oldCluster != null && !Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        vmsLockedForUpdate = filterVmsInClusterNeedUpdate();
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oldMacPoolId = getOldMacPoolId();
    Guid newMacPoolId = getNewMacPoolId();
    this.moveMacsOfUpdatedCluster.moveMacsOfUpdatedCluster(oldMacPoolId, newMacPoolId, getClusterId(), getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != getPrevCluster().isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != getPrevCluster().isEnableKsm());
    getClusterDao().update(getParameters().getCluster());
    addOrUpdateAddtionalClusterFeatures();
    if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
        // update gluster parameters on all hosts
        if (!updateGlusterHosts()) {
            setSucceeded(false);
            return;
        }
    }
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        getNetworkClusterDao().save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    if (isKsmPolicyChanged) {
        momPolicyUpdatedEvent.fire(getCluster());
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    if (!updateVms()) {
        setSucceeded(false);
        return;
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid oldMacPoolId = getOldMacPoolId();
    Guid newMacPoolId = getNewMacPoolId();
    this.moveMacsOfUpdatedCluster.moveMacsOfUpdatedCluster(oldMacPoolId, newMacPoolId, getClusterId(), getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != getPrevCluster().isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != getPrevCluster().isEnableKsm());
    getClusterDao().update(getParameters().getCluster());
    addOrUpdateAddtionalClusterFeatures();
    if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
        // update gluster parameters on all hosts
        updateGlusterHosts();
    }
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        getNetworkClusterDao().save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    if (isKsmPolicyChanged) {
        momPolicyUpdatedEvent.fire(getCluster());
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    if (!updateVms()) {
        setSucceeded(false);
        return;
    }
    setSucceeded(true);
}
#end_block

#method_before
private boolean updateVms() {
    for (VM vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeToVersion(getParameters().getCluster().getCompatibilityVersion());
        VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            getReturnValue().setFault(result.getFault());
            return false;
        }
    }
    return true;
}
#method_after
private boolean updateVms() {
    for (VmStatic vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        upgradeGraphicsDevices(vm, updateParams);
        VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            getReturnValue().setFault(result.getFault());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean updateGlusterHosts() {
    for (VDS vds : allForCluster) {
        HostStoragePoolParametersBase parameters = new HostStoragePoolParametersBase(vds);
        VdcReturnValueBase result = runInternalAction(VdcActionType.InitVdsOnUp, parameters, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            getReturnValue().setFault(result.getFault());
            return false;
        }
    }
    return true;
}
#method_after
private void updateGlusterHosts() {
    allForCluster.stream().forEach(glusterCommandHelper::initGlusterHost);
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldCluster == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldCluster.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = getVdsDao().getAllForCluster(oldCluster.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldCluster, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldCluster.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForCluster(oldCluster.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldCluster);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getClusterDao().getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldCluster);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    if (result && Version.v3_6.compareTo(getCluster().getCompatibilityVersion()) <= 0) {
        List<String> names = new ArrayList<>();
        for (VDS host : allForCluster) {
            if (VdsProtocol.XML == host.getProtocol()) {
                names.add(host.getName());
            }
        }
        if (!names.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_WRONG_PROTOCOL_FOR_CLUSTER_VERSION);
        }
    }
    return result;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldCluster == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldCluster.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = getVdsDao().getAllForCluster(oldCluster.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_CLUSTER_WITH_HOSTS_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldCluster, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldCluster.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForCluster(oldCluster.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result && !oldCluster.getCompatibilityVersion().equals(getCluster().getCompatibilityVersion())) {
        for (VM vm : vmList) {
            if (vm.isPreviewSnapshot()) {
                // can't change cluster version when a VM is in preview
                if (result) {
                    addValidationMessage(EngineMessage.CLUSTER_VERSION_CHANGE_VM_PREVIEW);
                    // and continue with adding validation messages
                    result = false;
                }
                addValidationMessage(vm.getName());
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldCluster);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getClusterDao().getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldCluster);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    if (result && Version.v3_6.compareTo(getCluster().getCompatibilityVersion()) <= 0) {
        List<String> names = new ArrayList<>();
        for (VDS host : allForCluster) {
            if (VdsProtocol.XML == host.getProtocol()) {
                names.add(host.getName());
            }
        }
        if (!names.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_WRONG_PROTOCOL_FOR_CLUSTER_VERSION);
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    final boolean versionChanged = !Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion());
    if (!versionChanged) {
        return null;
    }
    final String lockMessage = EngineMessage.ACTION_TYPE_FAILED_CLUSTER_IS_BEING_UPDATED.name() + ReplacementUtils.createSetVariableString("clusterName", oldCluster.getName());
    vmsLockedForUpdate = getVmDao().getAllForCluster(oldCluster.getId()).stream().filter(vm -> !vm.isExternalVm() && !vm.isHostedEngine()).filter(// no need for VM device update
    vm -> vm.getCustomCompatibilityVersion() == null).collect(Collectors.toList());
    return vmsLockedForUpdate.stream().collect(Collectors.toMap(vm -> vm.getId().toString(), vm -> LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, lockMessage)));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    final LockMessage lockMessage = new LockMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_IS_BEING_UPDATED).with("clusterName", oldCluster.getName());
    return vmsLockedForUpdate.stream().collect(Collectors.toMap(vm -> vm.getId().toString(), vm -> LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, lockMessage)));
}
#end_block

#method_before
private void generateReadList(StructMember member, String variable) {
    ListType type = (ListType) member.getType();
    Type elementType = type.getElementType();
    if (elementType instanceof PrimitiveType) {
        buffer.addLine("empty = reader.empty_element()");
        buffer.addLine("reader.read()");
        buffer.addLine("if not empty:");
        buffer.startBlock();
        buffer.addLine("%1$s = List()", variable);
        buffer.addLine("while reader.forward():");
        buffer.startBlock();
        buffer.addLine("%1$s.append(Reader.read_string(reader))", variable);
        buffer.endBlock();
        buffer.addLine("reader.read()");
        buffer.endBlock();
    } else if (elementType instanceof StructType) {
        PythonClassName readerName = pythonNames.getReaderName(elementType);
        buffer.addLine("%1$s = %2$s.read_many(reader)", variable, readerName.getClassName());
    } else {
        buffer.addLine("reader.next_element()");
    }
}
#method_after
private void generateReadList(StructMember member, String variable) {
    ListType type = (ListType) member.getType();
    Type elementType = type.getElementType();
    if (elementType instanceof PrimitiveType) {
        generateReadPrimitives((PrimitiveType) elementType, variable);
    } else if (elementType instanceof EnumType) {
        generateReadEnums((EnumType) elementType, variable);
    } else if (elementType instanceof StructType) {
        PythonClassName readerName = pythonNames.getReaderName(elementType);
        buffer.addLine("%1$s = %2$s.read_many(reader)", variable, readerName.getClassName());
    } else {
        buffer.addLine("reader.next_element()");
    }
}
#end_block

#method_before
private void initVmSnapshots() {
    AsyncDataProvider.getInstance().getVmSnapshotList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            SnapshotModel snapshotModel = (SnapshotModel) target;
            ArrayList<Snapshot> snapshots = (ArrayList<Snapshot>) returnValue;
            if (snapshotModel.showWarningForByVmSnapshotsValidation(snapshots)) {
                UICommand closeCommand = getCancelCommand().setTitle(ConstantsManager.getInstance().getConstants().close());
                snapshotModel.getCommands().add(closeCommand);
                snapshotModel.stopProgress();
            } else {
                snapshotModel.initVmDisks();
            }
        }
    }), vm.getId());
}
#method_after
private void initVmSnapshots() {
    AsyncDataProvider.getInstance().getVmSnapshotList(new AsyncQuery<>(new AsyncCallback<List<Snapshot>>() {

        @Override
        public void onSuccess(List<Snapshot> snapshots) {
            if (showWarningForByVmSnapshotsValidation(snapshots)) {
                UICommand closeCommand = getCancelCommand().setTitle(ConstantsManager.getInstance().getConstants().close());
                getCommands().add(closeCommand);
                stopProgress();
            } else {
                initVmDisks();
            }
        }
    }), vm.getId());
}
#end_block

#method_before
private void initVmDisks() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            SnapshotModel snapshotModel = (SnapshotModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            updateSnapshotDisks(disks);
            VmModelHelper.sendWarningForNonExportableDisks(snapshotModel, disks, VmModelHelper.WarningType.VM_SNAPSHOT);
            snapshotModel.getCommands().add(getOnSaveCommand());
            snapshotModel.getCommands().add(getCancelCommand());
            snapshotModel.stopProgress();
        }
    }), vm.getId());
}
#method_after
private void initVmDisks() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery<>(new AsyncCallback<List<Disk>>() {

        @Override
        public void onSuccess(List<Disk> disks) {
            updateSnapshotDisks(disks);
            VmModelHelper.sendWarningForNonExportableDisks(SnapshotModel.this, disks, VmModelHelper.WarningType.VM_SNAPSHOT);
            getCommands().add(getOnSaveCommand());
            getCommands().add(getCancelCommand());
            stopProgress();
        }
    }), vm.getId());
}
#end_block

#method_before
private void updateSnapshotDisks(ArrayList<Disk> disks) {
    ArrayList<DiskImage> diskImages = Linq.toList(Linq.<DiskImage>filterNonSnapableDisks(disks));
    Collections.sort(diskImages, new DiskByDiskAliasComparator());
    getSnapshotDisks().setItems(diskImages);
}
#method_after
private void updateSnapshotDisks(List<Disk> disks) {
    ArrayList<DiskImage> diskImages = Linq.toList(Linq.<DiskImage>filterNonSnapableDisks(disks));
    Collections.sort(diskImages, new DiskByDiskAliasComparator());
    getSnapshotDisks().setItems(diskImages);
}
#end_block

#method_before
public void updateVmConfiguration(final INewAsyncCallback onUpdateAsyncCallback) {
    Snapshot snapshot = getEntity();
    if (snapshot == null) {
        return;
    }
    AsyncDataProvider.getInstance().getVmConfigurationBySnapshot(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            SnapshotModel snapshotModel = (SnapshotModel) target;
            Snapshot snapshot = snapshotModel.getEntity();
            VM vm = (VM) returnValue;
            if (vm != null && snapshot != null) {
                snapshotModel.setVm(vm);
                snapshotModel.setDisks(vm.getDiskList());
                snapshotModel.setNics(vm.getInterfaces());
                snapshotModel.setApps(Arrays.asList(snapshot.getAppList() != null ? snapshot.getAppList().split(",") : // $NON-NLS-1$
                new String[] {}));
                Collections.sort(snapshotModel.getDisks(), new DiskByDiskAliasComparator());
                Collections.sort(snapshotModel.getNics(), new LexoNumericNameableComparator<>());
            }
            onUpdateAsyncCallback.onSuccess(snapshotModel, null);
        }
    }), snapshot.getId());
}
#method_after
public void updateVmConfiguration(final AsyncCallback<Void> onUpdateAsyncCallback) {
    Snapshot snapshot = getEntity();
    if (snapshot == null) {
        return;
    }
    AsyncDataProvider.getInstance().getVmConfigurationBySnapshot(new AsyncQuery<>(new AsyncCallback<VM>() {

        @Override
        public void onSuccess(VM vm) {
            Snapshot snapshot = getEntity();
            if (vm != null && snapshot != null) {
                setVm(vm);
                setDisks(vm.getDiskList());
                setNics(vm.getInterfaces());
                setApps(Arrays.asList(snapshot.getAppList() != null ? snapshot.getAppList().split(",") : // $NON-NLS-1$
                new String[] {}));
                Collections.sort(getDisks(), new DiskByDiskAliasComparator());
                Collections.sort(getNics(), new LexoNumericNameableComparator<>());
            }
            onUpdateAsyncCallback.onSuccess(null);
        }
    }), snapshot.getId());
}
#end_block

#method_before
private boolean showWarningForByVmSnapshotsValidation(ArrayList<Snapshot> snapshots) {
    for (Snapshot snapshot : snapshots) {
        if (!validateNewSnapshotByStatus(snapshot.getStatus()) || !validateNewSnapshotByType(snapshot.getType())) {
            getDescription().setIsAvailable(false);
            getMemory().setIsAvailable(false);
            return true;
        }
    }
    return false;
}
#method_after
private boolean showWarningForByVmSnapshotsValidation(List<Snapshot> snapshots) {
    for (Snapshot snapshot : snapshots) {
        if (!validateNewSnapshotByStatus(snapshot.getStatus()) || !validateNewSnapshotByType(snapshot.getType())) {
            getDescription().setIsAvailable(false);
            getMemory().setIsAvailable(false);
            return true;
        }
    }
    return false;
}
#end_block

#method_before
protected VmDeviceDao getVmDeviceDao() {
    return DbFacade.getInstance().getVmDeviceDao();
}
#method_after
protected VmDeviceDao getVmDeviceDao() {
    return vmDeviceDao;
}
#end_block

#method_before
protected BaseDiskDao getBaseDiskDao() {
    return DbFacade.getInstance().getBaseDiskDao();
}
#method_after
protected BaseDiskDao getBaseDiskDao() {
    return baseDiskDao;
}
#end_block

#method_before
protected SnapshotDao getSnapshotDao() {
    return DbFacade.getInstance().getSnapshotDao();
}
#method_after
protected SnapshotDao getSnapshotDao() {
    return snapshotDao;
}
#end_block

#method_before
protected VmDynamicDao getVmDynamicDao() {
    return DbFacade.getInstance().getVmDynamicDao();
}
#method_after
protected VmDynamicDao getVmDynamicDao() {
    return vmDynamicDao;
}
#end_block

#method_before
protected VmStaticDao getVmStaticDao() {
    return DbFacade.getInstance().getVmStaticDao();
}
#method_after
protected VmStaticDao getVmStaticDao() {
    return vmStaticDao;
}
#end_block

#method_before
protected DiskImageDao getDiskImageDao() {
    return DbFacade.getInstance().getDiskImageDao();
}
#method_after
protected DiskImageDao getDiskImageDao() {
    return diskImageDao;
}
#end_block

#method_before
protected DiskDao getDiskDao() {
    return DbFacade.getInstance().getDiskDao();
}
#method_after
protected DiskDao getDiskDao() {
    return diskDao;
}
#end_block

#method_before
protected DiskVmElementDao getDiskVmElementDao() {
    return DbFacade.getInstance().getDiskVmElementDao();
}
#method_after
protected DiskVmElementDao getDiskVmElementDao() {
    return diskVmElementDao;
}
#end_block

#method_before
protected ClusterDao getClusterDao() {
    return DbFacade.getInstance().getClusterDao();
}
#method_after
protected ClusterDao getClusterDao() {
    return clusterDao;
}
#end_block

#method_before
protected VmTemplateDao getVmTemplateDao() {
    return DbFacade.getInstance().getVmTemplateDao();
}
#method_after
protected VmTemplateDao getVmTemplateDao() {
    return vmTemplateDao;
}
#end_block

#method_before
protected VmNetworkInterfaceDao getVmNetworkInterfaceDao() {
    return DbFacade.getInstance().getVmNetworkInterfaceDao();
}
#method_after
protected VmNetworkInterfaceDao getVmNetworkInterfaceDao() {
    return vmNetworkInterfaceDao;
}
#end_block

#method_before
protected QuotaDao getQuotaDao() {
    return DbFacade.getInstance().getQuotaDao();
}
#method_after
protected QuotaDao getQuotaDao() {
    return quotaDao;
}
#end_block

#method_before
protected int getMaxVolumeChain() {
    return Config.<Integer>getValue(ConfigValues.MaxImagesInChain);
}
#method_after
protected int getMaxVolumeChain() {
    return Config.getValue(ConfigValues.MaxImagesInChain);
}
#end_block

#method_before
private void getAttachedTagsToSelectedVMs(TagListModel model) {
    ArrayList<Guid> vmIds = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    attachedTagsToEntities = new HashMap<>();
    allAttachedTags = new ArrayList<>();
    selectedItemsCounter = 0;
    for (Guid id : vmIds) {
        AsyncDataProvider.getInstance().getAttachedTagsToVm(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                VmListModel<Void> vmListModel = (VmListModel<Void>) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                vmListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                vmListModel.selectedItemsCounter++;
                if (vmListModel.selectedItemsCounter == vmListModel.getSelectedItems().size()) {
                    postGetAttachedTags(vmListModel, tagListModel);
                }
            }
        }), id);
    }
}
#method_after
private void getAttachedTagsToSelectedVMs(final TagListModel model) {
    ArrayList<Guid> vmIds = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    attachedTagsToEntities = new HashMap<>();
    allAttachedTags = new ArrayList<>();
    selectedItemsCounter = 0;
    for (Guid id : vmIds) {
        AsyncDataProvider.getInstance().getAttachedTagsToVm(new AsyncQuery<>(new AsyncCallback<List<Tags>>() {

            @Override
            public void onSuccess(List<Tags> returnValue) {
                allAttachedTags.addAll(returnValue);
                selectedItemsCounter++;
                if (selectedItemsCounter == getSelectedItems().size()) {
                    postGetAttachedTags(model);
                }
            }
        }), id);
    }
}
#end_block

#method_before
private void postGetAttachedTags(VmListModel<Void> vmListModel, TagListModel tagListModel) {
    if (vmListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(vmListModel.allAttachedTags, new TagsEqualityComparer());
        for (Tags tag : attachedTags) {
            int count = 0;
            for (Tags tag2 : vmListModel.allAttachedTags) {
                if (tag2.getTagId().equals(tag.getTagId())) {
                    count++;
                }
            }
            vmListModel.attachedTagsToEntities.put(tag.getTagId(), count == vmListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(vmListModel.attachedTagsToEntities);
    } else if ("OnAssignTags".equals(vmListModel.getLastExecutedCommand().getName())) {
        // $NON-NLS-1$
        vmListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#method_after
private void postGetAttachedTags(TagListModel tagListModel) {
    if (getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(allAttachedTags, new TagsEqualityComparer());
        for (Tags tag : attachedTags) {
            int count = 0;
            for (Tags tag2 : allAttachedTags) {
                if (tag2.getTagId().equals(tag.getTagId())) {
                    count++;
                }
            }
            attachedTagsToEntities.put(tag.getTagId(), count == getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(attachedTagsToEntities);
    } else if ("OnAssignTags".equals(getLastExecutedCommand().getName())) {
        // $NON-NLS-1$
        postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#end_block

#method_before
private void guide() {
    VmGuideModel model = new VmGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVirtualMachineGuideMeTitle());
    model.setHelpTag(HelpTag.new_virtual_machine___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_virtual_machine_-_guide_me");
    if (getGuideContext() == null) {
        VM vm = getSelectedItem();
        setGuideContext(vm.getId());
    }
    AsyncDataProvider.getInstance().getVmById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel<Void> vmListModel = (VmListModel<Void>) target;
            VmGuideModel model = (VmGuideModel) vmListModel.getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", vmListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
private void guide() {
    VmGuideModel model = new VmGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVirtualMachineGuideMeTitle());
    model.setHelpTag(HelpTag.new_virtual_machine___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_virtual_machine_-_guide_me");
    if (getGuideContext() == null) {
        VM vm = getSelectedItem();
        setGuideContext(vm.getId());
    }
    AsyncDataProvider.getInstance().getVmById(new AsyncQuery<>(new AsyncCallback<VM>() {

        @Override
        public void onSuccess(VM returnValue) {
            VmGuideModel model = (VmGuideModel) getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", VmListModel.this);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
private void edit() {
    VM vm = getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            editedVm = (VM) result;
            vmInitLoaded(editedVm);
        }
    };
    if (vm.isNextRunConfigurationExists()) {
        AsyncDataProvider.getInstance().getVmNextRunConfiguration(getVmInitQuery, vm.getId());
    } else {
        AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
    }
}
#method_after
private void edit() {
    VM vm = getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    // populating VMInit
    AsyncQuery<VM> getVmInitQuery = new AsyncQuery<>(new AsyncCallback<VM>() {

        @Override
        public void onSuccess(VM result) {
            editedVm = result;
            vmInitLoaded(editedVm);
        }
    });
    if (vm.isNextRunConfigurationExists()) {
        AsyncDataProvider.getInstance().getVmNextRunConfiguration(getVmInitQuery, vm.getId());
    } else {
        AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
    }
}
#end_block

#method_before
private void getTemplatesNotPresentOnExportDomain() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel<Void> vmListModel = (VmListModel<Void>) target;
            ArrayList<StoragePool> storagePools = (ArrayList<StoragePool>) returnValue;
            StoragePool storagePool = storagePools.size() > 0 ? storagePools.get(0) : null;
            vmListModel.postGetTemplatesNotPresentOnExportDomain(storagePool);
        }
    }), storageDomainId);
}
#method_after
private void getTemplatesNotPresentOnExportDomain() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery<>(new AsyncCallback<List<StoragePool>>() {

        @Override
        public void onSuccess(List<StoragePool> storagePools) {
            StoragePool storagePool = storagePools.size() > 0 ? storagePools.get(0) : null;
            postGetTemplatesNotPresentOnExportDomain(storagePool);
        }
    }), storageDomainId);
}
#end_block

#method_before
private void postGetTemplatesNotPresentOnExportDomain(StoragePool storagePool) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    if (storagePool != null) {
        AsyncDataProvider.getInstance().getAllTemplatesFromExportDomain(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel<Void> vmListModel = (VmListModel<Void>) target;
                HashMap<VmTemplate, ArrayList<DiskImage>> templatesDiskSet = (HashMap<VmTemplate, ArrayList<DiskImage>>) returnValue;
                HashMap<String, ArrayList<String>> templateDic = new HashMap<>();
                // check if relevant templates are already there
                for (Object selectedItem : vmListModel.getSelectedItems()) {
                    VM vm = (VM) selectedItem;
                    boolean hasMatch = false;
                    for (VmTemplate a : templatesDiskSet.keySet()) {
                        if (vm.getVmtGuid().equals(a.getId())) {
                            hasMatch = true;
                            break;
                        }
                    }
                    if (!vm.getVmtGuid().equals(Guid.Empty) && !hasMatch) {
                        if (!templateDic.containsKey(vm.getVmtName())) {
                            templateDic.put(vm.getVmtName(), new ArrayList<String>());
                        }
                        templateDic.get(vm.getVmtName()).add(vm.getName());
                    }
                }
                String tempStr;
                ArrayList<String> tempList;
                ArrayList<String> missingTemplates = new ArrayList<>();
                for (Map.Entry<String, ArrayList<String>> keyValuePair : templateDic.entrySet()) {
                    tempList = keyValuePair.getValue();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    StringBuilder sb = new StringBuilder("Template " + keyValuePair.getKey() + " (for ");
                    int i;
                    for (i = 0; i < tempList.size() - 1; i++) {
                        sb.append(tempList.get(i));
                        // $NON-NLS-1$
                        sb.append(", ");
                    }
                    sb.append(tempList.get(i));
                    // $NON-NLS-1$
                    sb.append(")");
                    missingTemplates.add(sb.toString());
                }
                vmListModel.postExportGetMissingTemplates(missingTemplates);
            }
        }), storagePool.getId(), storageDomainId);
    }
}
#method_after
private void postGetTemplatesNotPresentOnExportDomain(StoragePool storagePool) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    if (storagePool != null) {
        AsyncDataProvider.getInstance().getAllTemplatesFromExportDomain(new AsyncQuery<>(new AsyncCallback<Map<VmTemplate, ArrayList<DiskImage>>>() {

            @Override
            public void onSuccess(Map<VmTemplate, ArrayList<DiskImage>> templatesDiskSet) {
                HashMap<String, ArrayList<String>> templateDic = new HashMap<>();
                // check if relevant templates are already there
                for (VM vm : getSelectedItems()) {
                    boolean hasMatch = false;
                    for (VmTemplate a : templatesDiskSet.keySet()) {
                        if (vm.getVmtGuid().equals(a.getId())) {
                            hasMatch = true;
                            break;
                        }
                    }
                    if (!vm.getVmtGuid().equals(Guid.Empty) && !hasMatch) {
                        if (!templateDic.containsKey(vm.getVmtName())) {
                            templateDic.put(vm.getVmtName(), new ArrayList<String>());
                        }
                        templateDic.get(vm.getVmtName()).add(vm.getName());
                    }
                }
                ArrayList<String> tempList;
                ArrayList<String> missingTemplates = new ArrayList<>();
                for (Map.Entry<String, ArrayList<String>> keyValuePair : templateDic.entrySet()) {
                    tempList = keyValuePair.getValue();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    StringBuilder sb = new StringBuilder("Template " + keyValuePair.getKey() + " (for ");
                    int i;
                    for (i = 0; i < tempList.size() - 1; i++) {
                        sb.append(tempList.get(i));
                        // $NON-NLS-1$
                        sb.append(", ");
                    }
                    sb.append(tempList.get(i));
                    // $NON-NLS-1$
                    sb.append(")");
                    missingTemplates.add(sb.toString());
                }
                postExportGetMissingTemplates(missingTemplates);
            }
        }), storagePool.getId(), storageDomainId);
    }
}
#end_block

#method_before
@Override
protected void sendWarningForNonExportableDisks(VM entity) {
    // load VM disks and check if there is one which doesn't allow snapshot
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(getWindow(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final ExportVmModel model = (ExportVmModel) target;
            @SuppressWarnings("unchecked")
            final ArrayList<Disk> vmDisks = (ArrayList<Disk>) returnValue;
            VmModelHelper.sendWarningForNonExportableDisks(model, vmDisks, VmModelHelper.WarningType.VM_EXPORT);
        }
    }), entity.getId());
}
#method_after
@Override
protected void sendWarningForNonExportableDisks(VM entity) {
    // load VM disks and check if there is one which doesn't allow snapshot
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery<>(new AsyncCallback<List<Disk>>() {

        @Override
        public void onSuccess(List<Disk> vmDisks) {
            final ExportVmModel model = (ExportVmModel) getWindow();
            VmModelHelper.sendWarningForNonExportableDisks(model, vmDisks, VmModelHelper.WarningType.VM_EXPORT);
        }
    }), entity.getId());
}
#end_block

#method_before
private void runOnce() {
    VM vm = getSelectedItem();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            RunOnceModel runOnceModel = new WebadminRunOnceModel((VM) result, VmListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    };
    AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
}
#method_after
private void runOnce() {
    VM vm = getSelectedItem();
    // populating VMInit
    AsyncDataProvider.getInstance().getVmById(new AsyncQuery<>(new AsyncCallback<VM>() {

        @Override
        public void onSuccess(VM result) {
            RunOnceModel runOnceModel = new WebadminRunOnceModel(result, VmListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    }), vm.getId());
}
#end_block

#method_before
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel<Void> vmListModel = (VmListModel<Void>) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                    VmModel.fireValidationCompleteEvent();
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    }
}
#method_after
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery<>(new AsyncCallback<Boolean>() {

            @Override
            public void onSuccess(Boolean isNameUnique) {
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                    VmModel.fireValidationCompleteEvent();
                } else {
                    postNameUniqueCheck();
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    }
}
#end_block

#method_before
private void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    VM newVm = buildVmOnNewTemplate(model, vm);
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    BuilderExecutor.build(model, addVmTemplateParameters, new UnitToAddVmTemplateParametersBuilder());
    model.startProgress();
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel<Void> vmListModel = (VmListModel<Void>) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#method_after
private void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    VM newVm = buildVmOnNewTemplate(model, vm);
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    BuilderExecutor.build(model, addVmTemplateParameters, new UnitToAddVmTemplateParametersBuilder());
    model.startProgress();
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                cancel();
            }
        }
    }, this);
}
#end_block

#method_before
private void powerAction(final String actionName, final String title, final String message) {
    Guid clusterId = getClusterIdOfSelectedVms();
    if (clusterId == null) {
        powerAction(actionName, title, message, false);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Cluster cluster = (Cluster) returnValue;
                if (cluster != null) {
                    powerAction(actionName, title, message, cluster.isOptionalReasonRequired());
                }
            }
        }), clusterId);
    }
}
#method_after
private void powerAction(final String actionName, final String title, final String message) {
    Guid clusterId = getClusterIdOfSelectedVms();
    if (clusterId == null) {
        powerAction(actionName, title, message, false);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(new AsyncCallback<Cluster>() {

            @Override
            public void onSuccess(Cluster cluster) {
                if (cluster != null) {
                    powerAction(actionName, title, message, cluster.isOptionalReasonRequired());
                }
            }
        }), clusterId);
    }
}
#end_block

#method_before
private void changeCD() {
    final VM vm = getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrNull(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel<Void> vmListModel2 = (VmListModel<Void>) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrNull(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    };
    AsyncDataProvider.getInstance().getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnChangeCD", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
private void changeCD() {
    final VM vm = getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrNull(images1));
    AsyncDataProvider.getInstance().getIrsImageList(new AsyncQuery<>(new AsyncCallback<List<String>>() {

        @Override
        public void onSuccess(List<String> images) {
            AttachCdModel _attachCdModel = (AttachCdModel) getWindow();
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrNull(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    }), vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnChangeCD", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void updateVM(final UnitVmModel model) {
    final VM selectedItem = getSelectedItem();
    // explicitly pass non-editable field from the original VM
    getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
    getcurrentVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    if (selectedItem.isRunningOrPaused() && !selectedItem.isHostedEngine()) {
        AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object thisModel, Object returnValue) {
                List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                // provide warnings if isVmUnpinned()
                if (!changedFields.isEmpty() || isVmUnpinned()) {
                    VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                    if (isVmUnpinned()) {
                        confirmModel.setVmUnpinned();
                    }
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                    confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_next_run_configuration");
                    confirmModel.setChangedFields(changedFields);
                    confirmModel.setCpuPluggable(VmCommonUtils.isCpusToBeHotplugged(selectedItem, getcurrentVm()));
                    boolean isMemoryHotUnplugSupported = AsyncDataProvider.getInstance().isMemoryHotUnplugSupported(getcurrentVm());
                    confirmModel.setMemoryPluggable(VmCommonUtils.isMemoryToBeHotplugged(selectedItem, getcurrentVm(), isMemoryHotUnplugSupported));
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", VmListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    updateExistingVm(false);
                }
            }

            private boolean isVmUnpinned() {
                if (selectedItem.isRunning()) {
                    if (selectedItem.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && getcurrentVm().getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
                        return true;
                    }
                }
                return false;
            }
        }));
    } else {
        updateExistingVm(false);
    }
}
#method_after
@Override
protected void updateVM(final UnitVmModel model) {
    final VM selectedItem = getSelectedItem();
    // explicitly pass non-editable field from the original VM
    getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
    getcurrentVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    if (selectedItem.isRunningOrPaused() && !selectedItem.isHostedEngine()) {
        AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

            @Override
            public void onSuccess(VdcQueryReturnValue returnValue) {
                List<String> changedFields = returnValue.getReturnValue();
                // provide warnings if isVmUnpinned()
                if (!changedFields.isEmpty() || isVmUnpinned()) {
                    VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                    if (isVmUnpinned()) {
                        confirmModel.setVmUnpinned();
                    }
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                    confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_next_run_configuration");
                    confirmModel.setChangedFields(changedFields);
                    confirmModel.setCpuPluggable(VmCommonUtils.isCpusToBeHotplugged(selectedItem, getcurrentVm()));
                    boolean isMemoryHotUnplugSupported = AsyncDataProvider.getInstance().isMemoryHotUnplugSupported(getcurrentVm());
                    confirmModel.setMemoryPluggable(VmCommonUtils.isMemoryToBeHotplugged(selectedItem, getcurrentVm(), isMemoryHotUnplugSupported));
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", VmListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    updateExistingVm(false);
                }
            }

            private boolean isVmUnpinned() {
                if (selectedItem.isRunning()) {
                    if (selectedItem.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && getcurrentVm().getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
                        return true;
                    }
                }
                return false;
            }
        }));
    } else {
        updateExistingVm(false);
    }
}
#end_block

#method_before
private void importVms() {
    if (getWindow() != null) {
        return;
    }
    final ImportVmsModel model = importVmsModelProvider.get();
    model.init();
    setWindow(model);
    model.getCommands().add(new UICommand(CMD_CONFIGURE_VMS_TO_IMPORT, this).setIsExecutionAllowed(false).setTitle(ConstantsManager.getInstance().getConstants().next()).setIsDefault(true));
    model.getCommands().add(new UICommand(CMD_CANCEL, this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
    model.initImportModels(new UICommand(CMD_IMPORT, new BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand uiCommand) {
            model.onRestoreVms(new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    setWindow(null);
                }
            });
        }
    }).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true), new UICommand(CMD_BACK, new BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand uiCommand) {
            // remove current window first
            setWindow(null);
            model.clearVmModelsExceptItems();
            setWindow(model);
        }
    }).setTitle(ConstantsManager.getInstance().getConstants().back()), new UICommand(CMD_CANCEL, this).setIsCancel(true).setTitle(ConstantsManager.getInstance().getConstants().cancel()));
}
#method_after
private void importVms() {
    if (getWindow() != null) {
        return;
    }
    final ImportVmsModel model = importVmsModelProvider.get();
    model.init();
    setWindow(model);
    model.getCommands().add(new UICommand(CMD_CONFIGURE_VMS_TO_IMPORT, this).setIsExecutionAllowed(false).setTitle(ConstantsManager.getInstance().getConstants().next()).setIsDefault(true));
    model.getCommands().add(new UICommand(CMD_CANCEL, this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
    model.initImportModels(new UICommand(CMD_IMPORT, new BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand uiCommand) {
            model.onRestoreVms(new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    boolean isAllValidatePassed = true;
                    for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                        if (!returnValueBase.isValid()) {
                            isAllValidatePassed = false;
                            break;
                        }
                    }
                    if (isAllValidatePassed) {
                        setWindow(null);
                    }
                }
            });
        }
    }).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true), new UICommand(CMD_BACK, new BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand uiCommand) {
            // remove current window first
            setWindow(null);
            model.clearVmModelsExceptItems();
            setWindow(model);
        }
    }).setTitle(ConstantsManager.getInstance().getConstants().back()), new UICommand(CMD_CANCEL, this).setIsCancel(true).setTitle(ConstantsManager.getInstance().getConstants().cancel()));
}
#end_block

#method_before
private void onConfigureVmsToImport() {
    final ImportVmsModel importVmsModel = (ImportVmsModel) getWindow();
    if (importVmsModel == null) {
        return;
    }
    if (!importVmsModel.validateArchitectures()) {
        return;
    }
    final ImportVmModel model = importVmsModel.getSpecificImportModel();
    // remove import-vms window first
    setWindow(null);
    setWindow(model);
}
#method_after
private void onConfigureVmsToImport() {
    final ImportVmsModel importVmsModel = (ImportVmsModel) getWindow();
    if (importVmsModel == null) {
        return;
    }
    boolean vmsToImportHaveFullInfo = importVmsModel.vmsToImportHaveFullInfo();
    if (vmsToImportHaveFullInfo && !importVmsModel.validateArchitectures(importVmsModel.getVmsToImport())) {
        return;
    }
    final ImportVmModel model = importVmsModel.getSpecificImportModel(vmsToImportHaveFullInfo);
    if (vmsToImportHaveFullInfo) {
        // remove import-vms window first
        setWindow(null);
        setWindow(model);
    } else {
        initImportModelForVmsToImportNamesOnly(importVmsModel, model);
    }
}
#end_block

#method_before
protected void updateUserCdImage(Guid storagePoolId) {
    AsyncDataProvider.getInstance().getIrsImageList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            List<String> images = (List<String>) returnValue;
            setImagesToModel(model, images);
        }
    }), storagePoolId);
}
#method_after
protected void updateUserCdImage(Guid storagePoolId) {
    AsyncDataProvider.getInstance().getIrsImageList(new AsyncQuery<>(new AsyncCallback<List<String>>() {

        @Override
        public void onSuccess(List<String> images) {
            setImagesToModel(getModel(), images);
        }
    }), storagePoolId);
}
#end_block

#method_before
protected void updateCdImage(boolean forceRefresh) {
    StoragePool dataCenter = getModel().getSelectedDataCenter();
    if (dataCenter == null) {
        return;
    }
    AsyncDataProvider.getInstance().getIrsImageList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            ArrayList<String> images = (ArrayList<String>) returnValue;
            setImagesToModel(model, images);
        }
    }), dataCenter.getId(), forceRefresh);
}
#method_after
protected void updateCdImage(boolean forceRefresh) {
    StoragePool dataCenter = getModel().getSelectedDataCenter();
    if (dataCenter == null) {
        return;
    }
    AsyncDataProvider.getInstance().getIrsImageList(asyncQuery(new AsyncCallback<List<String>>() {

        @Override
        public void onSuccess(List<String> images) {
            setImagesToModel(getModel(), images);
        }
    }), dataCenter.getId(), forceRefresh);
}
#end_block

#method_before
protected void updateDefaultHost() {
    Cluster cluster = getModel().getSelectedCluster();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (cluster == null) {
        getModel().getDefaultHost().setItems(new ArrayList<VDS>());
        getModel().getDefaultHost().setSelectedItems(new ArrayList<VDS>());
        return;
    }
    AsyncQuery query = new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            List<VDS> hosts = null;
            if (returnValue instanceof List) {
                hosts = (List<VDS>) returnValue;
            } else if (returnValue instanceof VdcQueryReturnValue && ((VdcQueryReturnValue) returnValue).getReturnValue() instanceof List) {
                hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                // $NON-NLS-1$
                throw new IllegalArgumentException("The return value should be List<VDS> or VdcQueryReturnValue with return value List<VDS>");
            }
            List<VDS> oldDefaultHosts = model.getDefaultHost().getSelectedItems();
            if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (VDS vds : hosts) {
                    if (host.getId().equals(vds.getId())) {
                        model.getDefaultHost().setItems(new ArrayList<>(Collections.singletonList(vds)));
                        model.getDefaultHost().setSelectedItems(Collections.singletonList(vds));
                        model.getDefaultHost().setIsChangeable(false);
                        model.getDefaultHost().setChangeProhibitionReason(constants.cannotChangeHostInTreeContext());
                        break;
                    }
                }
            } else {
                model.getDefaultHost().setItems(hosts);
                // attempt to preserve selection as much as possible
                if (oldDefaultHosts != null && !oldDefaultHosts.isEmpty()) {
                    Set<VDS> oldSelectedIntersectionNewHosts = new HashSet<>(oldDefaultHosts);
                    oldSelectedIntersectionNewHosts.retainAll(hosts);
                    oldDefaultHosts = new ArrayList<>(oldSelectedIntersectionNewHosts);
                }
                List<VDS> hostsToSelect = oldDefaultHosts != null && !oldDefaultHosts.isEmpty() ? oldDefaultHosts : !hosts.isEmpty() ? Collections.singletonList(hosts.get(0)) : Collections.<VDS>emptyList();
                model.getDefaultHost().setSelectedItems(hostsToSelect);
            }
            changeDefaultHost();
        }
    });
    getHostListByCluster(cluster, query);
}
#method_after
protected void updateDefaultHost() {
    Cluster cluster = getModel().getSelectedCluster();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (cluster == null) {
        getModel().getDefaultHost().setItems(new ArrayList<VDS>());
        getModel().getDefaultHost().setSelectedItems(new ArrayList<VDS>());
        return;
    }
    getHostListByCluster(cluster, asyncQuery(new AsyncCallback() {

        @Override
        public void onSuccess(Object returnValue) {
            List<VDS> hosts = null;
            if (returnValue instanceof List) {
                hosts = (List<VDS>) returnValue;
            } else if (returnValue instanceof VdcQueryReturnValue && ((VdcQueryReturnValue) returnValue).getReturnValue() instanceof List) {
                hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                // $NON-NLS-1$
                throw new IllegalArgumentException("The return value should be List<VDS> or VdcQueryReturnValue with return value List<VDS>");
            }
            List<VDS> oldDefaultHosts = getModel().getDefaultHost().getSelectedItems();
            if (getModel().getBehavior().getSystemTreeSelectedItem() != null && getModel().getBehavior().getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                VDS host = (VDS) getModel().getBehavior().getSystemTreeSelectedItem().getEntity();
                for (VDS vds : hosts) {
                    if (host.getId().equals(vds.getId())) {
                        getModel().getDefaultHost().setItems(new ArrayList<>(Collections.singletonList(vds)));
                        getModel().getDefaultHost().setSelectedItems(Collections.singletonList(vds));
                        getModel().getDefaultHost().setIsChangeable(false);
                        getModel().getDefaultHost().setChangeProhibitionReason(constants.cannotChangeHostInTreeContext());
                        break;
                    }
                }
            } else {
                getModel().getDefaultHost().setItems(hosts);
                // attempt to preserve selection as much as possible
                if (oldDefaultHosts != null && !oldDefaultHosts.isEmpty()) {
                    Set<VDS> oldSelectedIntersectionNewHosts = new HashSet<>(oldDefaultHosts);
                    oldSelectedIntersectionNewHosts.retainAll(hosts);
                    oldDefaultHosts = new ArrayList<>(oldSelectedIntersectionNewHosts);
                }
                List<VDS> hostsToSelect = oldDefaultHosts != null && !oldDefaultHosts.isEmpty() ? oldDefaultHosts : !hosts.isEmpty() ? Collections.singletonList(hosts.get(0)) : Collections.<VDS>emptyList();
                getModel().getDefaultHost().setSelectedItems(hostsToSelect);
            }
            changeDefaultHost();
        }
    }));
}
#end_block

#method_before
protected void getHostListByCluster(Cluster cluster, AsyncQuery query) {
    AsyncDataProvider.getInstance().getHostListByCluster(query, cluster.getName());
}
#method_after
protected void getHostListByCluster(Cluster cluster, AsyncQuery<List<VDS>> query) {
    AsyncDataProvider.getInstance().getHostListByCluster(query, cluster.getName());
}
#end_block

#method_before
public void updataMaxVmsInPool() {
    AsyncDataProvider.getInstance().getMaxVmsInPool(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = (VmModelBehaviorBase) target;
            behavior.setMaxVmsInPool((Integer) returnValue);
            behavior.updateMaxNumOfVmCpus();
        }
    }));
}
#method_after
public void updataMaxVmsInPool() {
    AsyncDataProvider.getInstance().getMaxVmsInPool(asyncQuery(new AsyncCallback<Integer>() {

        @Override
        public void onSuccess(Integer returnValue) {
            setMaxVmsInPool(returnValue);
            updateMaxNumOfVmCpus();
        }
    }));
}
#end_block

#method_before
public void updateMaxNumOfVmCpus() {
    String version = getCompatibilityVersion().toString();
    AsyncDataProvider.getInstance().getMaxNumOfVmCpus(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = VmModelBehaviorBase.this;
            behavior.maxCpus = (Integer) returnValue;
            behavior.postUpdateNumOfSockets2();
        }
    }), version);
}
#method_after
public void updateMaxNumOfVmCpus() {
    String version = getCompatibilityVersion().toString();
    AsyncDataProvider.getInstance().getMaxNumOfVmCpus(asyncQuery(new AsyncCallback<Integer>() {

        @Override
        public void onSuccess(Integer returnValue) {
            maxCpus = returnValue;
            postUpdateNumOfSockets2();
        }
    }), version);
}
#end_block

#method_before
public void postUpdateNumOfSockets2() {
    String version = getCompatibilityVersion().toString();
    AsyncDataProvider.getInstance().getMaxNumOfCPUsPerSocket(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = VmModelBehaviorBase.this;
            behavior.maxCpusPerSocket = (Integer) returnValue;
            behavior.postUpdateNumOfSockets3();
        }
    }), version);
}
#method_after
public void postUpdateNumOfSockets2() {
    String version = getCompatibilityVersion().toString();
    AsyncDataProvider.getInstance().getMaxNumOfCPUsPerSocket(asyncQuery(new AsyncCallback<Integer>() {

        @Override
        public void onSuccess(Integer returnValue) {
            maxCpusPerSocket = returnValue;
            postUpdateNumOfSockets3();
        }
    }), version);
}
#end_block

#method_before
public void postUpdateNumOfSockets3() {
    String version = getCompatibilityVersion().toString();
    AsyncDataProvider.getInstance().getMaxNumOfThreadsPerCpu(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = VmModelBehaviorBase.this;
            behavior.maxThreadsPerCore = (Integer) returnValue;
            behavior.totalCpuCoresChanged();
        }
    }), version);
}
#method_after
public void postUpdateNumOfSockets3() {
    String version = getCompatibilityVersion().toString();
    AsyncDataProvider.getInstance().getMaxNumOfThreadsPerCpu(asyncQuery(new AsyncCallback<Integer>() {

        @Override
        public void onSuccess(Integer returnValue) {
            maxThreadsPerCore = returnValue;
            totalCpuCoresChanged();
        }
    }), version);
}
#end_block

#method_before
public void initDisks() {
    VmTemplate template = getModel().getTemplateWithVersion().getSelectedItem().getTemplateVersion();
    AsyncDataProvider.getInstance().getTemplateDiskList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            initTemplateDisks((List<DiskImage>) returnValue);
        }
    }), template.getId());
}
#method_after
public void initDisks() {
    VmTemplate template = getModel().getTemplateWithVersion().getSelectedItem().getTemplateVersion();
    AsyncDataProvider.getInstance().getTemplateDiskList(asyncQuery(new AsyncCallback<List<DiskImage>>() {

        @Override
        public void onSuccess(List<DiskImage> returnValue) {
            initTemplateDisks(returnValue);
        }
    }), template.getId());
}
#end_block

#method_before
protected void postInitStorageDomains() {
    if (getModel().getDisks() == null) {
        return;
    }
    ActionGroup actionGroup = getModel().isCreateInstanceOnly() ? ActionGroup.CREATE_INSTANCE : ActionGroup.CREATE_VM;
    StoragePool dataCenter = getModel().getSelectedDataCenter();
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = VmModelBehaviorBase.this;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> activeStorageDomains = filterStorageDomains(storageDomains);
            boolean provisioning = behavior.getModel().getProvisioning().getEntity();
            ArrayList<DiskModel> disks = (ArrayList<DiskModel>) behavior.getModel().getDisks();
            Collections.sort(activeStorageDomains, new NameableComparator());
            ArrayList<DiskModel> diskImages = Linq.filterDisksByType(disks, DiskStorageType.IMAGE);
            for (DiskModel diskModel : diskImages) {
                ArrayList<StorageDomain> availableDiskStorageDomains;
                diskModel.getQuota().setItems(behavior.getModel().getQuota().getItems());
                ArrayList<Guid> storageIds = ((DiskImage) diskModel.getDisk()).getStorageIds();
                // Active storage domains that the disk resides on
                ArrayList<StorageDomain> activeDiskStorageDomains = Linq.getStorageDomainsByIds(storageIds, activeStorageDomains);
                // Set target storage domains
                availableDiskStorageDomains = provisioning ? activeStorageDomains : activeDiskStorageDomains;
                Collections.sort(availableDiskStorageDomains, new NameableComparator());
                diskModel.getStorageDomain().setItems(availableDiskStorageDomains);
                diskModel.getStorageDomain().setChangeProhibitionReason(constants.noActiveTargetStorageDomainAvailableMsg());
                diskModel.getStorageDomain().setIsChangeable(!availableDiskStorageDomains.isEmpty());
            }
            ArrayList<DiskModel> cinderDisks = Linq.filterDisksByType(disks, DiskStorageType.CINDER);
            Collection<StorageDomain> cinderStorageDomains = Linq.filterStorageDomainsByStorageType(storageDomains, StorageType.CINDER);
            initStorageDomainsForCinderDisks(cinderDisks, cinderStorageDomains);
        }
    }), dataCenter.getId(), actionGroup);
}
#method_after
protected void postInitStorageDomains() {
    if (getModel().getDisks() == null) {
        return;
    }
    ActionGroup actionGroup = getModel().isCreateInstanceOnly() ? ActionGroup.CREATE_INSTANCE : ActionGroup.CREATE_VM;
    StoragePool dataCenter = getModel().getSelectedDataCenter();
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

        @Override
        public void onSuccess(List<StorageDomain> storageDomains) {
            ArrayList<StorageDomain> activeStorageDomains = filterStorageDomains(storageDomains);
            boolean provisioning = getModel().getProvisioning().getEntity();
            ArrayList<DiskModel> disks = (ArrayList<DiskModel>) getModel().getDisks();
            Collections.sort(activeStorageDomains, new NameableComparator());
            ArrayList<DiskModel> diskImages = Linq.filterDisksByType(disks, DiskStorageType.IMAGE);
            for (DiskModel diskModel : diskImages) {
                ArrayList<StorageDomain> availableDiskStorageDomains;
                diskModel.getQuota().setItems(getModel().getQuota().getItems());
                ArrayList<Guid> storageIds = ((DiskImage) diskModel.getDisk()).getStorageIds();
                // Active storage domains that the disk resides on
                ArrayList<StorageDomain> activeDiskStorageDomains = Linq.getStorageDomainsByIds(storageIds, activeStorageDomains);
                // Set target storage domains
                availableDiskStorageDomains = provisioning ? activeStorageDomains : activeDiskStorageDomains;
                Collections.sort(availableDiskStorageDomains, new NameableComparator());
                diskModel.getStorageDomain().setItems(availableDiskStorageDomains);
                diskModel.getStorageDomain().setChangeProhibitionReason(constants.noActiveTargetStorageDomainAvailableMsg());
                diskModel.getStorageDomain().setIsChangeable(!availableDiskStorageDomains.isEmpty());
            }
            ArrayList<DiskModel> cinderDisks = Linq.filterDisksByType(disks, DiskStorageType.CINDER);
            Collection<StorageDomain> cinderStorageDomains = Linq.filterStorageDomainsByStorageType(storageDomains, StorageType.CINDER);
            initStorageDomainsForCinderDisks(cinderDisks, cinderStorageDomains);
        }
    }), dataCenter.getId(), actionGroup);
}
#end_block

#method_before
public ArrayList<StorageDomain> filterStorageDomains(ArrayList<StorageDomain> storageDomains) {
    // filter only the Active storage domains (Active regarding the relevant storage pool).
    ArrayList<StorageDomain> list = new ArrayList<>();
    for (StorageDomain a : storageDomains) {
        if (Linq.isDataActiveStorageDomain(a)) {
            list.add(a);
        }
    }
    // Filter according to system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        StorageDomain selectStorage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        StorageDomain sd = Linq.firstOrNull(list, new Linq.IdPredicate<>(selectStorage.getId()));
        list = new ArrayList<>(Arrays.asList(new StorageDomain[] { sd }));
    }
    return list;
}
#method_after
public ArrayList<StorageDomain> filterStorageDomains(List<StorageDomain> storageDomains) {
    // filter only the Active storage domains (Active regarding the relevant storage pool).
    ArrayList<StorageDomain> list = new ArrayList<>();
    for (StorageDomain a : storageDomains) {
        if (Linq.isDataActiveStorageDomain(a)) {
            list.add(a);
        }
    }
    // Filter according to system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        StorageDomain selectStorage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        StorageDomain sd = Linq.firstOrNull(list, new Linq.IdPredicate<>(selectStorage.getId()));
        list = new ArrayList<>(Arrays.asList(new StorageDomain[] { sd }));
    }
    return list;
}
#end_block

#method_before
protected void updateQuotaByCluster(final Guid defaultQuota, final String quotaName) {
    if (getModel().getQuota().getIsAvailable()) {
        Cluster cluster = getModel().getSelectedCluster();
        if (cluster == null) {
            return;
        }
        AsyncDataProvider.getInstance().getAllRelevantQuotasForClusterSorted(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                UnitVmModel vmModel = (UnitVmModel) model;
                List<Quota> quotaList = (List<Quota>) returnValue;
                if (quotaList == null) {
                    return;
                }
                if (!quotaList.isEmpty()) {
                    vmModel.getQuota().setItems(quotaList);
                }
                if (defaultQuota != null && !Guid.Empty.equals(defaultQuota)) {
                    boolean hasQuotaInList = false;
                    if (!quotaList.isEmpty()) {
                        hasQuotaInList = defaultQuota.equals(quotaList.get(0).getId());
                    }
                    // Add the quota to the list only in edit mode
                    if (!hasQuotaInList && !getModel().getIsNew()) {
                        Quota quota = new Quota();
                        quota.setId(defaultQuota);
                        quota.setQuotaName(quotaName);
                        quotaList.add(0, quota);
                        vmModel.getQuota().setItems(quotaList);
                        vmModel.getQuota().setSelectedItem(quota);
                    }
                }
            }
        }), cluster.getId(), defaultQuota);
    }
}
#method_after
protected void updateQuotaByCluster(final Guid defaultQuota, final String quotaName) {
    if (getModel().getQuota().getIsAvailable()) {
        Cluster cluster = getModel().getSelectedCluster();
        if (cluster == null) {
            return;
        }
        AsyncDataProvider.getInstance().getAllRelevantQuotasForClusterSorted(new AsyncQuery<>(new AsyncCallback<List<Quota>>() {

            @Override
            public void onSuccess(List<Quota> quotaList) {
                UnitVmModel vmModel = getModel();
                if (quotaList == null) {
                    return;
                }
                if (!quotaList.isEmpty()) {
                    vmModel.getQuota().setItems(quotaList);
                }
                if (defaultQuota != null && !Guid.Empty.equals(defaultQuota)) {
                    boolean hasQuotaInList = false;
                    if (!quotaList.isEmpty()) {
                        hasQuotaInList = defaultQuota.equals(quotaList.get(0).getId());
                    }
                    // Add the quota to the list only in edit mode
                    if (!hasQuotaInList && !getModel().getIsNew()) {
                        Quota quota = new Quota();
                        quota.setId(defaultQuota);
                        quota.setQuotaName(quotaName);
                        quotaList.add(0, quota);
                        vmModel.getQuota().setItems(quotaList);
                        vmModel.getQuota().setSelectedItem(quota);
                    }
                }
            }
        }), cluster.getId(), defaultQuota);
    }
}
#end_block

#method_before
protected void setupTemplateWithVersion(final Guid templateId, final boolean useLatest, final boolean isVersionChangeable) {
    AsyncDataProvider.getInstance().getTemplateById(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object nothing, Object returnValue) {
            VmTemplate rawTemplate = (VmTemplate) returnValue;
            if (isVersionChangeable) {
                // only used by pools therefore query is limited to admin-portal permissions.
                AsyncDataProvider.getInstance().getVmTemplatesByBaseTemplateId(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        ArrayList<VmTemplate> templatesChain = new ArrayList<>((List<VmTemplate>) returnValue);
                        initTemplateWithVersion(templatesChain, templateId, useLatest);
                    }
                }), rawTemplate.getBaseTemplateId());
            } else {
                final VmTemplate template = useLatest ? new LatestVmTemplate(rawTemplate) : rawTemplate;
                if (template.isBaseTemplate()) {
                    TemplateWithVersion templateCouple = new TemplateWithVersion(template, template);
                    setReadOnlyTemplateWithVersion(templateCouple);
                } else {
                    AsyncDataProvider.getInstance().getTemplateById(new AsyncQuery(null, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object nothing, Object returnValue) {
                            VmTemplate baseTemplate = (VmTemplate) returnValue;
                            TemplateWithVersion templateCouple = new TemplateWithVersion(baseTemplate, template);
                            setReadOnlyTemplateWithVersion(templateCouple);
                        }
                    }), template.getBaseTemplateId());
                }
            }
        }
    }), templateId);
}
#method_after
protected void setupTemplateWithVersion(final Guid templateId, final boolean useLatest, final boolean isVersionChangeable) {
    AsyncDataProvider.getInstance().getTemplateById(new AsyncQuery<>(new AsyncCallback<VmTemplate>() {

        @Override
        public void onSuccess(VmTemplate rawTemplate) {
            if (isVersionChangeable) {
                // only used by pools therefore query is limited to admin-portal permissions.
                AsyncDataProvider.getInstance().getVmTemplatesByBaseTemplateId(new AsyncQuery<>(new AsyncCallback<List<VmTemplate>>() {

                    @Override
                    public void onSuccess(List<VmTemplate> templatesChain) {
                        initTemplateWithVersion(templatesChain, templateId, useLatest);
                    }
                }), rawTemplate.getBaseTemplateId());
            } else {
                final VmTemplate template = useLatest ? new LatestVmTemplate(rawTemplate) : rawTemplate;
                if (template.isBaseTemplate()) {
                    TemplateWithVersion templateCouple = new TemplateWithVersion(template, template);
                    setReadOnlyTemplateWithVersion(templateCouple);
                } else {
                    AsyncDataProvider.getInstance().getTemplateById(new AsyncQuery<>(new AsyncCallback<VmTemplate>() {

                        @Override
                        public void onSuccess(VmTemplate baseTemplate) {
                            TemplateWithVersion templateCouple = new TemplateWithVersion(baseTemplate, template);
                            setReadOnlyTemplateWithVersion(templateCouple);
                        }
                    }), template.getBaseTemplateId());
                }
            }
        }
    }), templateId);
}
#end_block

#method_before
public void updateUseHostCpuAvailability() {
    if (canUseHostCpuAvailability()) {
        getModel().getHostCpu().setIsChangeable(true);
    } else {
        getModel().getHostCpu().setEntity(false);
        getModel().getHostCpu().setChangeProhibitionReason(constants.hosCPUUnavailable());
        getModel().getHostCpu().setIsChangeable(false);
    }
}
#method_after
public void updateUseHostCpuAvailability() {
    boolean clusterSupportsHostCpu = getCompatibilityVersion() != null;
    boolean vmIsNonMigratable = MigrationSupport.PINNED_TO_HOST == getModel().getMigrationMode().getSelectedItem();
    if (clusterSupportsHostCpu && !clusterHasPpcArchitecture() && vmIsNonMigratable) {
        getModel().getHostCpu().setIsChangeable(true);
    } else {
        getModel().getHostCpu().setEntity(false);
        getModel().getHostCpu().setChangeProhibitionReason(constants.hosCPUUnavailable());
        getModel().getHostCpu().setIsChangeable(false);
    }
}
#end_block

#method_before
protected void updateNumOfSockets() {
    Version version = getCompatibilityVersion();
    if (version == null) {
        return;
    }
    AsyncDataProvider.getInstance().getMaxNumOfVmSockets(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = VmModelBehaviorBase.this;
            behavior.maxNumOfSockets = (Integer) returnValue;
            behavior.updataMaxVmsInPool();
        }
    }), version.toString());
}
#method_after
protected void updateNumOfSockets() {
    Version version = getCompatibilityVersion();
    if (version == null) {
        return;
    }
    AsyncDataProvider.getInstance().getMaxNumOfVmSockets(asyncQuery(new AsyncCallback<Integer>() {

        @Override
        public void onSuccess(Integer returnValue) {
            maxNumOfSockets = returnValue;
            updataMaxVmsInPool();
        }
    }), version.toString());
}
#end_block

#method_before
protected void updateEmulatedMachines() {
    Cluster cluster = getModel().getSelectedCluster();
    if (cluster == null) {
        return;
    }
    AsyncDataProvider.getInstance().getEmulatedMachinesByClusterID(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                Set<String> emulatedSet = new TreeSet<>((HashSet<String>) returnValue);
                // $NON-NLS-1$
                emulatedSet.add("");
                String oldVal = getModel().getEmulatedMachine().getSelectedItem();
                getModel().getEmulatedMachine().setItems(emulatedSet);
                getModel().getEmulatedMachine().setSelectedItem(oldVal);
            }
        }
    }), cluster.getId());
}
#method_after
protected void updateEmulatedMachines() {
    Cluster cluster = getModel().getSelectedCluster();
    if (cluster == null) {
        return;
    }
    AsyncDataProvider.getInstance().getEmulatedMachinesByClusterID(new AsyncQuery<>(new AsyncCallback<Set<String>>() {

        @Override
        public void onSuccess(Set<String> returnValue) {
            if (returnValue != null) {
                Set<String> emulatedSet = new TreeSet<>(returnValue);
                // $NON-NLS-1$
                emulatedSet.add("");
                String oldVal = getModel().getEmulatedMachine().getSelectedItem();
                getModel().getEmulatedMachine().setItems(emulatedSet);
                getModel().getEmulatedMachine().setSelectedItem(oldVal);
            }
        }
    }), cluster.getId());
}
#end_block

#method_before
/*
     * Updates the cpu model combobox after a cluster change occurs
     */
protected void updateCustomCpu() {
    Cluster cluster = getModel().getSelectedCluster();
    if (cluster == null || cluster.getCpuName() == null) {
        return;
    }
    AsyncDataProvider.getInstance().getSupportedCpuList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                List<String> cpuList = new ArrayList<>();
                // $NON-NLS-1$
                cpuList.add("");
                for (ServerCpu cpu : (List<ServerCpu>) returnValue) {
                    cpuList.add(cpu.getVdsVerbData());
                }
                String oldVal = getModel().getCustomCpu().getSelectedItem();
                getModel().getCustomCpu().setItems(cpuList);
                getModel().getCustomCpu().setSelectedItem(oldVal);
            }
        }
    }), cluster.getCpuName());
}
#method_after
/*
     * Updates the cpu model combobox after a cluster change occurs
     */
protected void updateCustomCpu() {
    Cluster cluster = getModel().getSelectedCluster();
    if (cluster == null || cluster.getCpuName() == null) {
        return;
    }
    AsyncDataProvider.getInstance().getSupportedCpuList(new AsyncQuery<>(new AsyncCallback<List<ServerCpu>>() {

        @Override
        public void onSuccess(List<ServerCpu> returnValue) {
            if (returnValue != null) {
                List<String> cpuList = new ArrayList<>();
                // $NON-NLS-1$
                cpuList.add("");
                for (ServerCpu cpu : returnValue) {
                    cpuList.add(cpu.getVdsVerbData());
                }
                String oldVal = getModel().getCustomCpu().getSelectedItem();
                getModel().getCustomCpu().setItems(cpuList);
                getModel().getCustomCpu().setSelectedItem(oldVal);
            }
        }
    }), cluster.getCpuName());
}
#end_block

#method_before
protected void updateConsoleDevice(Guid vmId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetConsoleDevices, new IdQueryParameters(vmId), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<String> consoleDevices = ((VdcQueryReturnValue) returnValue).getReturnValue();
            getModel().getIsConsoleDeviceEnabled().setEntity(!consoleDevices.isEmpty());
        }
    }));
}
#method_after
protected void updateConsoleDevice(Guid vmId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetConsoleDevices, new IdQueryParameters(vmId), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            List<String> consoleDevices = returnValue.getReturnValue();
            getModel().getIsConsoleDeviceEnabled().setEntity(!consoleDevices.isEmpty());
        }
    }));
}
#end_block

#method_before
protected void updateRngDevice(Guid templateId) {
    if (!getModel().getIsRngEnabled().getIsChangable()) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(templateId), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            @SuppressWarnings("unchecked")
            List<VmRngDevice> devs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            getModel().getIsRngEnabled().setEntity(!devs.isEmpty());
            getModel().setRngDevice(devs.isEmpty() ? new VmRngDevice() : devs.get(0));
        }
    }));
}
#method_after
protected void updateRngDevice(Guid templateId) {
    if (!getModel().getIsRngEnabled().getIsChangable()) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(templateId), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            @SuppressWarnings("unchecked")
            List<VmRngDevice> devs = returnValue.getReturnValue();
            getModel().getIsRngEnabled().setEntity(!devs.isEmpty());
            getModel().setRngDevice(devs.isEmpty() ? new VmRngDevice() : devs.get(0));
        }
    }));
}
#end_block

#method_before
protected void updateCompatibilityVersion() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    final StoragePool dataCenter = dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    AsyncQuery asyncQuery = new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            List<Version> versions = (List<Version>) result;
            versions.add(0, null);
            Version selectedVersion;
            selectedVersion = getModel().getCustomCompatibilityVersion().getSelectedItem();
            if (selectedVersion != null && versions.contains(selectedVersion)) {
                getModel().getCustomCompatibilityVersion().setItems(versions, selectedVersion);
            } else {
                getModel().getCustomCompatibilityVersion().setItems(versions);
            }
        }
    });
    AsyncDataProvider.getInstance().getDataCenterVersions(asyncQuery, dataCenter.getId());
}
#method_after
protected void updateCompatibilityVersion() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    final StoragePool dataCenter = dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    AsyncDataProvider.getInstance().getDataCenterVersions(new AsyncQuery<>(new AsyncCallback<List<Version>>() {

        @Override
        public void onSuccess(List<Version> versions) {
            versions.add(0, null);
            Version selectedVersion;
            selectedVersion = getModel().getCustomCompatibilityVersion().getSelectedItem();
            if (selectedVersion != null && versions.contains(selectedVersion)) {
                getModel().getCustomCompatibilityVersion().setItems(versions, selectedVersion);
            } else {
                getModel().getCustomCompatibilityVersion().setItems(versions);
            }
        }
    }), dataCenter.getId());
}
#end_block

#method_before
private void fetchCpuProfiles(Guid clusterId, final Guid cpuProfileId) {
    if (clusterId == null) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetCpuProfilesByClusterId, new IdQueryParameters(clusterId), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<CpuProfile> cpuProfiles = ((VdcQueryReturnValue) returnValue).getReturnValue();
            getModel().getCpuProfiles().setItems(cpuProfiles);
            if (cpuProfiles != null) {
                for (CpuProfile cpuProfile : cpuProfiles) {
                    if (cpuProfile.getId().equals(cpuProfileId)) {
                        getModel().getCpuProfiles().setSelectedItem(cpuProfile);
                        break;
                    }
                }
            }
        }
    }));
}
#method_after
private void fetchCpuProfiles(Guid clusterId, final Guid cpuProfileId) {
    if (clusterId == null) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetCpuProfilesByClusterId, new IdQueryParameters(clusterId), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            List<CpuProfile> cpuProfiles = returnValue.getReturnValue();
            getModel().getCpuProfiles().setItems(cpuProfiles);
            if (cpuProfiles != null) {
                for (CpuProfile cpuProfile : cpuProfiles) {
                    if (cpuProfile.getId().equals(cpuProfileId)) {
                        getModel().getCpuProfiles().setSelectedItem(cpuProfile);
                        break;
                    }
                }
            }
        }
    }));
}
#end_block

#method_before
protected void updateGraphics(Guid id) {
    AsyncQuery callback = new AsyncQuery();
    callback.setModel(getModel());
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue retVal = (VdcQueryReturnValue) returnValue;
            List<VmDevice> graphicsVmDevs = retVal.getReturnValue();
            List<GraphicsType> graphicsTypes = new ArrayList<>();
            for (VmDevice graphicsVmDev : graphicsVmDevs) {
                graphicsTypes.add(GraphicsType.fromString(graphicsVmDev.getDevice()));
            }
            boolean hasSpiceAndVnc = graphicsTypes.size() == 2 && graphicsTypes.containsAll(Arrays.asList(GraphicsType.SPICE, GraphicsType.VNC));
            boolean canBeSelected = getModel().getGraphicsType().getItems().contains(UnitVmModel.GraphicsTypes.SPICE_AND_VNC);
            if (hasSpiceAndVnc && canBeSelected) {
                getModel().getGraphicsType().setSelectedItem(UnitVmModel.GraphicsTypes.SPICE_AND_VNC);
            } else if (graphicsVmDevs.size() == 1) {
                GraphicsType type = GraphicsType.fromString(graphicsVmDevs.get(0).getDevice());
                getModel().getGraphicsType().setSelectedItem(UnitVmModel.GraphicsTypes.fromGraphicsType(type));
            }
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGraphicsDevices, new IdQueryParameters(id), callback);
}
#method_after
protected void updateGraphics(Guid id) {
    Frontend.getInstance().runQuery(VdcQueryType.GetGraphicsDevices, new IdQueryParameters(id), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            List<VmDevice> graphicsVmDevs = returnValue.getReturnValue();
            List<GraphicsType> graphicsTypes = new ArrayList<>();
            for (VmDevice graphicsVmDev : graphicsVmDevs) {
                graphicsTypes.add(GraphicsType.fromString(graphicsVmDev.getDevice()));
            }
            boolean hasSpiceAndVnc = graphicsTypes.size() == 2 && graphicsTypes.containsAll(Arrays.asList(GraphicsType.SPICE, GraphicsType.VNC));
            boolean canBeSelected = getModel().getGraphicsType().getItems().contains(UnitVmModel.GraphicsTypes.SPICE_AND_VNC);
            if (hasSpiceAndVnc && canBeSelected) {
                getModel().getGraphicsType().setSelectedItem(UnitVmModel.GraphicsTypes.SPICE_AND_VNC);
            } else if (graphicsVmDevs.size() == 1) {
                GraphicsType type = GraphicsType.fromString(graphicsVmDevs.get(0).getDevice());
                getModel().getGraphicsType().setSelectedItem(UnitVmModel.GraphicsTypes.fromGraphicsType(type));
            }
        }
    }));
}
#end_block

#method_before
private ArrayList<VdcActionParametersBase> prepareSetupNetworksParameters() {
    ArrayList<VdcActionParametersBase> parameters = syncNetworkParametersBuilder.buildParameters(getNetwork(), getOldNetwork());
    reportFailedChildHostOperationsUtil.updateParentCommandId(parameters, this);
    HostSetupNetworksParametersBuilder.updateParametersSequencing(parameters);
    return parameters;
}
#method_after
private ArrayList<VdcActionParametersBase> prepareSetupNetworksParameters() {
    ArrayList<VdcActionParametersBase> parameters = syncNetworkParametersBuilder.buildParameters(getNetwork(), getOldNetwork());
    setParentCommandInfo(parameters);
    HostSetupNetworksParametersBuilder.updateParametersSequencing(parameters);
    return parameters;
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    reportFailedChildHostOperationsUtil.reportFailedHosts(this);
}
#method_after
@Override
protected void endWithFailure() {
    reportFailedChildHostOperationsUtil.setFailedHosts(this);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.NETWORK_UPDATE_NETWORK : AuditLogType.NETWORK_UPDATE_NETWORK_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return getSucceeded() ? AuditLogType.NETWORK_UPDATE_NETWORK_STARTED : AuditLogType.NETWORK_UPDATE_NETWORK_FAILED;
        case END_FAILURE:
            return hasChildCommands() ? AuditLogType.UPDATE_NETWORK_ON_HOSTS_FAILED : super.getAuditLogTypeValue();
        case END_SUCCESS:
            return AuditLogType.NETWORK_UPDATE_NETWORK_FINISHED;
    }
    return super.getAuditLogTypeValue();
}
#end_block

#method_before
private void processSingleClusterChanges(ManageNetworkClustersParameters param) {
    final NetworkClustersToSetupNetworksParametersTransformer networkClustersToSetupNetworksParametersTransformer = networkClustersToSetupNetworksParametersTransformerFactory.createNetworkClustersToSetupNetworksParametersTransformer(getContext());
    final ArrayList<VdcActionParametersBase> setupNetworksParams = new ArrayList<>();
    setupNetworksParams.addAll(networkClustersToSetupNetworksParametersTransformer.transform(param.getAttachments(), param.getDetachments()));
    reportFailedChildHostOperationsUtil.updateParentCommandId(setupNetworksParams, this);
    HostSetupNetworksParametersBuilder.updateParametersSequencing(setupNetworksParams);
    runInternalMultipleActions(VdcActionType.PersistentHostSetupNetworks, setupNetworksParams);
}
#method_after
private void processSingleClusterChanges(ManageNetworkClustersParameters param) {
    final NetworkClustersToSetupNetworksParametersTransformer networkClustersToSetupNetworksParametersTransformer = networkClustersToSetupNetworksParametersTransformerFactory.createNetworkClustersToSetupNetworksParametersTransformer(getContext());
    final ArrayList<VdcActionParametersBase> setupNetworksParams = new ArrayList<>();
    setupNetworksParams.addAll(networkClustersToSetupNetworksParametersTransformer.transform(param.getAttachments(), param.getDetachments()));
    HostSetupNetworksParametersBuilder.updateParametersSequencing(setupNetworksParams);
    setParentCommandInfo(setupNetworksParams);
    runInternalMultipleActions(VdcActionType.PersistentHostSetupNetworks, setupNetworksParams);
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    getAuditLogDirector().log(this);
}
#method_after
@Override
protected void endSuccessfully() {
    super.endSuccessfully();
    // The log should be done here as this command is internal so it wouldn't be logged otherwise.
    log();
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    reportFailedChildHostOperationsUtil.reportFailedHosts(this);
}
#method_after
@Override
protected void endWithFailure() {
    reportFailedChildHostOperationsUtil.setFailedHosts(this);
    // The log should be done here as this command is internal so it wouldn't be logged otherwise.
    log();
}
#end_block

#method_before
public static List<? extends CommandBase> findChildCommands(Guid commandId) {
    final List<CommandBase> failedCommands = new ArrayList<>();
    final List<Guid> childCommandIds = getChildCommandIds(commandId);
    for (Guid childCommandId : childCommandIds) {
        final CommandBase<?> childCommand = retrieveCommand(childCommandId);
        failedCommands.add(childCommand);
    }
    return failedCommands;
}
#method_after
public static List<CommandEntity> findChildCommands(Guid commandId) {
    final List<Guid> childCommandIds = getChildCommandIds(commandId);
    final List<CommandEntity> childCommands = LinqUtils.transformToList(childCommandIds, new Function<Guid, CommandEntity>() {

        @Override
        public CommandEntity eval(Guid guid) {
            return CommandCoordinatorUtil.getCommandEntity(guid);
        }
    });
    return childCommands;
}
#end_block

#method_before
@Test
public void testCommandMandatoryConstructorsExistence() {
    Predicate<Constructor<?>> classForcesCompensation = constructor -> constructor.getDeclaringClass().isAnnotationPresent(NonTransactiveCommandAttribute.class) && constructor.getDeclaringClass().getAnnotation(NonTransactiveCommandAttribute.class).forceCompensation();
    Predicate<Class<CommandBase<? extends VdcActionParametersBase>>> classLacksParamsAndContextCtor = getPredicateForNoCtorMatchesGivenPredicate(parametersAndContextConstructorSignature);
    Predicate<Class<CommandBase<? extends VdcActionParametersBase>>> classLacksGuidCtor = getPredicateForNoCtorMatchesGivenPredicate(classForcesCompensation.negate().or(guidConstructorSignature));
    List<String> commandsWithoutMandatoryConstructor = commandClasses.stream().filter(classLacksParamsAndContextCtor.or(classLacksGuidCtor)).map(Class::getSimpleName).sorted().collect(Collectors.toList());
    assertThat("There are commands that don't contain at least one of the mandatory constructors:" + System.lineSeparator() + "1. A constructor that receives parameters and context objects." + System.lineSeparator() + "2. A constructor that receives a Guid object, its class is annotated with " + "'NonTransactiveCommandAttribute' and the annotation's 'forceCompensation' attribute is set to true.", commandsWithoutMandatoryConstructor, empty());
}
#method_after
@Test
public void testCommandMandatoryConstructorsExistence() {
    Predicate<Constructor<?>> classForcesCompensation = constructor -> constructor.getDeclaringClass().isAnnotationPresent(NonTransactiveCommandAttribute.class) && constructor.getDeclaringClass().getAnnotation(NonTransactiveCommandAttribute.class).forceCompensation();
    Predicate<Class<CommandBase<? extends VdcActionParametersBase>>> classLacksParamsAndContextCtor = getPredicateForNoCtorMatchesGivenPredicate(parametersAndContextConstructorSignature);
    Predicate<Class<CommandBase<? extends VdcActionParametersBase>>> classLacksGuidCtor = getPredicateForNoCtorMatchesGivenPredicate(classForcesCompensation.negate().or(guidConstructorSignature));
    List<String> commandsWithoutMandatoryConstructor = commandClasses.stream().filter(classLacksParamsAndContextCtor.or(classLacksGuidCtor)).map(Class::getSimpleName).sorted().collect(Collectors.toList());
    assertThat("There are commands that don't contain at least one of the mandatory constructors:" + System.lineSeparator() + "1. A constructor that receives parameters and context objects." + System.lineSeparator() + "2. A constructor that receives a Guid object, its class is annotated with '" + NonTransactiveCommandAttribute.class.getSimpleName() + "' and the annotation's 'forceCompensation' " + "attribute is set to true.", commandsWithoutMandatoryConstructor, empty());
}
#end_block

#method_before
private boolean checkLunsInStorageDomain(List<String> lunIds) {
    // Get LUNs from DB
    List<LUNs> lunsFromDb = getLunDao().getAllForVolumeGroup(getStorageDomain().getStorage());
    Set<String> lunsSet = new HashSet<>(lunIds);
    for (LUNs lun : lunsFromDb) {
        if (lunsSet.contains(lun.getLUNId())) {
            // LUN is part of the storage domain
            lunsSet.remove(lun.getLUNId());
        }
    }
    return lunsSet.isEmpty();
}
#method_after
private boolean checkLunsInStorageDomain(List<String> lunIds) {
    // Get LUNs from DB
    getParameters().setLunsList(new ArrayList<>(getLunDao().getAllForVolumeGroup(getStorageDomain().getStorage())));
    Set<String> lunsSet = new HashSet<>(lunIds);
    for (LUNs lun : getParameters().getLunsList()) {
        if (lunsSet.contains(lun.getLUNId())) {
            // LUN is part of the storage domain
            lunsSet.remove(lun.getLUNId());
        }
    }
    return lunsSet.isEmpty();
}
#end_block

#method_before
private void updateLunsInDb(List<LUNs> lunsToUpdateInDb) {
    TransactionSupport.executeInNewTransaction(() -> {
        lunsToUpdateInDb.stream().forEach(lun -> getLunDao().update(lun));
        return null;
    });
    log.debug("LUNs with IDs: [" + lunsToUpdateInDb.stream().map(LUNs::getLUNId).collect(Collectors.joining(", ")) + "] were updated in the DB.");
}
#method_after
private void updateLunsInDb(List<LUNs> lunsToUpdateInDb) {
    TransactionSupport.executeInNewTransaction(() -> {
        CompensationContext context = getCompensationContext();
        context.snapshotEntities(getParameters().getLunsList());
        getLunDao().updateAllInBatch(lunsToUpdateInDb);
        context.stateChanged();
        return null;
    });
    log.debug("LUNs with IDs: [" + lunsToUpdateInDb.stream().map(LUNs::getLUNId).collect(Collectors.joining(", ")) + "] were updated in the DB.");
}
#end_block

#method_before
protected void updateStorageDomain(final StorageDomain storageDomainToUpdate) {
    executeInNewTransaction(() -> {
        CompensationContext context = getCompensationContext();
        context.snapshotEntity(storageDomainToUpdate.getStorageDynamicData());
        getDbFacade().getStorageDomainDynamicDao().update(storageDomainToUpdate.getStorageDynamicData());
        getCompensationContext().stateChanged();
        return null;
    });
}
#method_after
protected void updateStorageDomain(final StorageDomain storageDomainToUpdate) {
    executeInNewTransaction(() -> {
        CompensationContext context = getCompensationContext();
        context.snapshotEntity(getStorageDomain().getStorageDynamicData());
        getDbFacade().getStorageDomainDynamicDao().update(storageDomainToUpdate.getStorageDynamicData());
        getCompensationContext().stateChanged();
        return null;
    });
}
#end_block

#method_before
@Override
public void importVms(IFrontendMultipleActionAsyncCallback callback) {
    Frontend.getInstance().runMultipleAction(VdcActionType.ImportVmFromExternalProvider, buildImportVmFromExternalProviderParameters(), callback);
}
#method_after
@Override
public void importVms(IFrontendMultipleActionAsyncCallback callback) {
    Frontend.getInstance().runMultipleAction(VdcActionType.ImportVmFromExternalProvider, buildImportVmFromExternalProviderParameters(), true, callback, null);
}
#end_block

#method_before
private void checkImageTarget() {
    // can be larger then the actual size.
    if (getVm().getOrigin() == OriginType.KVM && getActionState() == CommandActionState.EXECUTE) {
        for (DiskImage image : getVm().getImages()) {
            StorageDomain domain = storageDomainDao.get(getStorageDomainId());
            if (domain.getStorageType().isBlockDomain()) {
                image.setActualSizeInBytes(image.getSize());
            }
        }
    }
}
#method_after
private void checkImageTarget() {
    // can be larger then the actual size.
    if (getVm().getOrigin() == OriginType.KVM && getActionState() == CommandActionState.EXECUTE) {
        StorageDomain domain = storageDomainDao.get(getStorageDomainId());
        if (domain.getStorageType().isBlockDomain()) {
            getVm().getImages().forEach(image -> image.setActualSizeInBytes(image.getSize()));
        }
    }
}
#end_block

#method_before
private ArrayList<VdcActionParametersBase> prepareSetupNetworksParameters() {
    ArrayList<VdcActionParametersBase> parameters = syncNetworkParametersBuilder.buildParameters(getNetwork(), getOldNetwork());
    reportFailedChildHostOperationsUtil.updateParentCommandId(parameters, this);
    HostSetupNetworksParametersBuilder.updateParametersSequencing(parameters);
    return parameters;
}
#method_after
private ArrayList<VdcActionParametersBase> prepareSetupNetworksParameters() {
    ArrayList<VdcActionParametersBase> parameters = syncNetworkParametersBuilder.buildParameters(getNetwork(), getOldNetwork());
    setParentCommandInfo(parameters);
    HostSetupNetworksParametersBuilder.updateParametersSequencing(parameters);
    return parameters;
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    reportFailedChildHostOperationsUtil.reportFailedHosts(this);
}
#method_after
@Override
protected void endWithFailure() {
    reportFailedChildHostOperationsUtil.setFailedHosts(this);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (onlyPermittedFieldsChanged() && allowedNetworkLabelManipulation()) {
        return true;
    }
    final NetworkValidator validatorNew = new NetworkValidator(vmDao, getNetwork());
    final UpdateNetworkValidator validatorOld = new UpdateNetworkValidator(getOldNetwork(), vmNetworkInterfaceDao, clusterDao, vmDao);
    return validate(validatorNew.dataCenterExists()) && validate(validatorNew.stpForVmNetworkOnly()) && validate(validatorNew.mtuValid()) && validate(validatorNew.networkPrefixValid()) && validate(validatorNew.vlanIdNotUsed()) && validate(validatorNew.qosExistsInDc()) && validate(validatorOld.networkIsSet(getNetwork().getId())) && validate(validatorOld.notChangingDataCenterId(getNetwork().getDataCenterId())) && validate(validatorNew.networkNameNotUsed()) && validate(validatorOld.nonVmNetworkNotUsedByVms(getNetwork())) && validate(validatorOld.nonVmNetworkNotUsedByTemplates(getNetwork())) && validate(validatorOld.notRenamingUsedNetwork(getNetworkName())) && validate(validatorOld.notRenamingLabel(getNetwork().getLabel())) && (oldAndNewNetworkIsNotExternal() || validate(validatorOld.externalNetworkDetailsUnchanged(getNetwork())));
}
#method_after
@Override
protected boolean validate() {
    if (onlyPermittedFieldsChanged() && allowedNetworkLabelManipulation()) {
        return true;
    }
    final NetworkValidator validatorNew = new NetworkValidator(vmDao, getNetwork());
    final UpdateNetworkValidator validatorOld = new UpdateNetworkValidator(getOldNetwork(), vmDao);
    return validate(validatorNew.dataCenterExists()) && validate(validatorNew.stpForVmNetworkOnly()) && validate(validatorNew.mtuValid()) && validate(validatorNew.networkPrefixValid()) && validate(validatorNew.vlanIdNotUsed()) && validate(validatorNew.qosExistsInDc()) && validate(validatorOld.networkIsSet(getNetwork().getId())) && validate(validatorOld.notChangingDataCenterId(getNetwork().getDataCenterId())) && validate(validatorNew.networkNameNotUsed()) && validate(validatorOld.nonVmNetworkNotUsedByVms(getNetwork())) && validate(validatorOld.nonVmNetworkNotUsedByTemplates(getNetwork())) && validate(validatorOld.notRenamingUsedNetwork(getNetworkName())) && validate(validatorOld.notRenamingLabel(getNetwork().getLabel())) && (oldAndNewNetworkIsNotExternal() || validate(validatorOld.externalNetworkDetailsUnchanged(getNetwork())));
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.NETWORK_UPDATE_NETWORK : AuditLogType.NETWORK_UPDATE_NETWORK_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return getSucceeded() ? AuditLogType.NETWORK_UPDATE_NETWORK_STARTED : AuditLogType.NETWORK_UPDATE_NETWORK_FAILED;
        case END_FAILURE:
            return hasChildCommands() ? AuditLogType.UPDATE_NETWORK_ON_HOSTS_FAILED : super.getAuditLogTypeValue();
        case END_SUCCESS:
            return AuditLogType.NETWORK_UPDATE_NETWORK_FINISHED;
    }
    return super.getAuditLogTypeValue();
}
#end_block

#method_before
public static List<? extends CommandBase> findChildCommands(Guid commandId) {
    final List<CommandBase> childCommands = new ArrayList<>();
    final List<Guid> childCommandIds = getChildCommandIds(commandId);
    for (Guid childCommandId : childCommandIds) {
        final CommandBase<?> childCommand = retrieveCommand(childCommandId);
        childCommands.add(childCommand);
    }
    return childCommands;
}
#method_after
public static List<CommandEntity> findChildCommands(Guid commandId) {
    final List<Guid> childCommandIds = getChildCommandIds(commandId);
    final List<CommandEntity> childCommands = childCommandIds.stream().map(CommandCoordinatorUtil::getCommandEntity).collect(Collectors.toList());
    return childCommands;
}
#end_block

#method_before
private void processSingleClusterChanges(ManageNetworkClustersParameters param) {
    final NetworkClustersToSetupNetworksParametersTransformer networkClustersToSetupNetworksParametersTransformer = networkClustersToSetupNetworksParametersTransformerFactory.createNetworkClustersToSetupNetworksParametersTransformer(getContext());
    final ArrayList<VdcActionParametersBase> setupNetworksParams = new ArrayList<>();
    setupNetworksParams.addAll(networkClustersToSetupNetworksParametersTransformer.transform(param.getAttachments(), param.getDetachments()));
    reportFailedChildHostOperationsUtil.updateParentCommandId(setupNetworksParams, this);
    HostSetupNetworksParametersBuilder.updateParametersSequencing(setupNetworksParams);
    runInternalMultipleActions(VdcActionType.PersistentHostSetupNetworks, setupNetworksParams);
}
#method_after
private void processSingleClusterChanges(ManageNetworkClustersParameters param) {
    final NetworkClustersToSetupNetworksParametersTransformer networkClustersToSetupNetworksParametersTransformer = networkClustersToSetupNetworksParametersTransformerFactory.createNetworkClustersToSetupNetworksParametersTransformer(getContext());
    final ArrayList<VdcActionParametersBase> setupNetworksParams = new ArrayList<>();
    setupNetworksParams.addAll(networkClustersToSetupNetworksParametersTransformer.transform(param.getAttachments(), param.getDetachments()));
    HostSetupNetworksParametersBuilder.updateParametersSequencing(setupNetworksParams);
    setParentCommandInfo(setupNetworksParams);
    runInternalMultipleActions(VdcActionType.PersistentHostSetupNetworks, setupNetworksParams);
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    getAuditLogDirector().log(this);
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    super.endSuccessfully();
    // The log should be done here as this command is internal so it wouldn't be logged otherwise.
    log();
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    reportFailedChildHostOperationsUtil.reportFailedHosts(this);
}
#method_after
@Override
protected void endWithFailure() {
    reportFailedChildHostOperationsUtil.setFailedHosts(this);
    // The log should be done here as this command is internal so it wouldn't be logged otherwise.
    log();
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.PROPAGATE_NETWORK_CHANGE_FINISHED : AuditLogType.PROPAGATE_NETWORK_CHANGE_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return AuditLogType.PROPAGATE_NETWORK_CHANGES_STARTED;
        case END_FAILURE:
            return AuditLogType.PROPAGATE_NETWORK_CHANGE_FAILED;
        case END_SUCCESS:
            return AuditLogType.PROPAGATE_NETWORK_CHANGE_FINISHED;
    }
    return super.getAuditLogTypeValue();
}
#end_block

#method_before
@Before
public void setUp() {
    host = createHost();
    Mockito.when(vdsDao.get(hostId)).thenReturn(host);
}
#method_after
@Before
public void setUp() {
    host = createHost();
    Mockito.when(vdsStaticDao.get(hostId)).thenReturn(host);
}
#end_block

#method_before
@Test
public void testApplyHostNotFound() {
    Mockito.when(vdsDao.get(hostId)).thenReturn(null);
    final String actual = underTest.apply(hostId);
    assertThat(actual, is(hostId.toString()));
}
#method_after
@Test
public void testApplyHostNotFound() {
    Mockito.when(vdsStaticDao.get(hostId)).thenReturn(null);
    final String actual = underTest.apply(hostId);
    assertThat(actual, is(hostId.toString()));
}
#end_block

#method_before
@Test
public void testApplyNullName() {
    host.setVdsName(null);
    final String actual = underTest.apply(hostId);
    assertThat(actual, is(hostId.toString()));
}
#method_after
@Test
public void testApplyNullName() {
    host.setName(null);
    final String actual = underTest.apply(hostId);
    assertThat(actual, is(hostId.toString()));
}
#end_block

#method_before
private VDS createHost() {
    final VDS host = new VDS();
    host.setVdsName(HOST_NAME);
    return host;
}
#method_after
private VdsStatic createHost() {
    final VdsStatic host = new VdsStatic();
    host.setName(HOST_NAME);
    return host;
}
#end_block

#method_before
@Override
public String apply(Guid hostId) {
    final VDS host = vdsDao.get(hostId);
    final Object result;
    if (host != null) {
        if (StringUtils.isEmpty(host.getName())) {
            result = hostId;
        } else {
            result = host.getName();
        }
    } else {
        result = hostId;
    }
    return String.valueOf(result);
}
#method_after
@Override
public String apply(Guid hostId) {
    final Optional<VdsStatic> nullableHost = Optional.ofNullable(vdsStaticDao.get(hostId));
    final Optional<String> nullableHostName = nullableHost.map(VdsStatic::getName);
    return nullableHostName.orElseGet(() -> String.valueOf(hostId));
}
#end_block

#method_before
private void loadExternalBrokers() {
    brokerMap.clear();
    for (ExternalSchedulerBroker broker : externalBrokers) {
        brokerMap.put(broker.getId(), broker);
    }
}
#method_after
private void loadExternalBrokers() {
    for (ExternalSchedulerBroker broker : externalBrokers) {
        brokerMap.put(broker.getId(), broker);
    }
}
#end_block

#method_before
private void loadExternalScheduler() {
    if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler discovery thread");
        /* Disable all external units, this is needed in case an external scheduler broker
               implementation is missing, because nobody would then disable units that
               were registered by the missing broker */
        exSchedulerDiscovery.markAllExternalPoliciesAsDisabled();
        ThreadPoolUtil.execute(() -> {
            if (exSchedulerDiscovery.discover()) {
                reloadPolicyUnits();
            }
        });
    } else {
        exSchedulerDiscovery.markAllExternalPoliciesAsDisabled();
        log.info("External scheduler disabled, discovery skipped");
    }
}
#method_after
private void loadExternalScheduler() {
    if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler discovery thread");
        ThreadPoolUtil.execute(() -> {
            if (exSchedulerDiscovery.discover()) {
                reloadPolicyUnits();
            }
        });
    } else {
        exSchedulerDiscovery.markAllExternalPoliciesAsDisabled();
        log.info("External scheduler disabled, discovery skipped");
    }
}
#end_block

#method_before
private List<VDS> runExternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, List<String> messages, String correlationId, SchedulingResult result) {
    if (filters != null) {
        List<Guid> hostIDs = new ArrayList<>();
        for (VDS host : hostList) {
            hostIDs.add(host.getId());
        }
        for (final ExternalSchedulerBroker broker : externalBrokers) {
            List<String> filterNames = filters.stream().filter(f -> f.getPolicyUnit().getBroker().equals(broker.getId())).map(f -> f.getPolicyUnit().getName()).collect(Collectors.toList());
            List<Guid> filteredIDs = broker.runFilters(filterNames, hostIDs, vm.getId(), parameters);
            if (filteredIDs != null) {
                logFilterActions(hostList, new HashSet<>(filteredIDs), EngineMessage.VAR__FILTERTYPE__EXTERNAL, Arrays.toString(filterNames.toArray()), result, correlationId);
                hostList = intersectHosts(hostList, filteredIDs);
            }
        }
    }
    return hostList;
}
#method_after
private List<VDS> runExternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, List<String> messages, String correlationId, SchedulingResult result) {
    List<Guid> filteredIDs = null;
    if (filters != null) {
        List<Guid> hostIDs = new ArrayList<>();
        for (VDS host : hostList) {
            hostIDs.add(host.getId());
        }
        for (final ExternalSchedulerBroker broker : externalBrokers) {
            List<String> filterNames = filters.stream().filter(f -> f.getPolicyUnit().getBroker().equals(broker.getId())).map(f -> f.getPolicyUnit().getName()).collect(Collectors.toList());
            filteredIDs = broker.runFilters(filterNames, hostIDs, vm.getId(), parameters);
            if (filteredIDs != null) {
                logFilterActions(hostList, new HashSet<>(filteredIDs), EngineMessage.VAR__FILTERTYPE__EXTERNAL, Arrays.toString(filterNames.toArray()), result, correlationId);
            }
        }
    }
    return intersectHosts(hostList, filteredIDs);
}
#end_block

#method_before
public boolean discover() {
    boolean dbUpdated = false;
    for (ExternalSchedulerBroker broker : externalBrokers) {
        ExternalSchedulerDiscoveryResult discoveryResult = broker.runDiscover();
        if (discoveryResult != null) {
            updateDB(broker, discoveryResult);
            log.info("PolicyUnits updated for broker {}", broker.getId());
            dbUpdated = true;
        } else {
            AuditLogableBase loggable = new AuditLogableBase();
            new AuditLogDirector().log(loggable, AuditLogType.FAILED_TO_CONNECT_TO_SCHEDULER_PROXY);
            log.warn("Discovery returned empty result when talking to broker {} disabling its units", broker.getId());
            List<PolicyUnit> failingPolicyUnits = policyUnitDao.getAll().stream().filter(unit -> broker.getId().equals(unit.getBroker())).collect(Collectors.toList());
            markExternalPoliciesAsDisabled(failingPolicyUnits);
            dbUpdated = true;
        }
    }
    return dbUpdated;
}
#method_after
public boolean discover() {
    boolean dbUpdated = false;
    for (ExternalSchedulerBroker broker : externalBrokers) {
        ExternalSchedulerDiscoveryResult discoveryResult = broker.runDiscover();
        if (discoveryResult != null) {
            updateDB(discoveryResult);
            log.info("PolicyUnits updated");
            dbUpdated = true;
        } else {
            AuditLogableBase loggable = new AuditLogableBase();
            new AuditLogDirector().log(loggable, AuditLogType.FAILED_TO_CONNECT_TO_SCHEDULER_PROXY);
            markAllExternalPoliciesAsDisabled();
            log.warn("Discovery returned empty result, disabled external policy units");
        }
    }
    return dbUpdated;
}
#end_block

#method_before
private void updateDB(ExternalSchedulerBroker broker, ExternalSchedulerDiscoveryResult discoveryResult) {
    List<PolicyUnit> allPolicyUnits = policyUnitDao.getAll();
    Set<PolicyUnit> foundInBoth = new HashSet<>();
    for (ExternalSchedulerDiscoveryUnit unit : discoveryResult.getFilters()) {
        PolicyUnit found = compareToDB(broker, allPolicyUnits, unit, PolicyUnitType.FILTER);
        foundInBoth.add(found);
    }
    for (ExternalSchedulerDiscoveryUnit unit : discoveryResult.getScores()) {
        PolicyUnit found = compareToDB(broker, allPolicyUnits, unit, PolicyUnitType.WEIGHT);
        foundInBoth.add(found);
    }
    for (ExternalSchedulerDiscoveryUnit unit : discoveryResult.getBalance()) {
        PolicyUnit found = compareToDB(broker, allPolicyUnits, unit, PolicyUnitType.LOAD_BALANCING);
        foundInBoth.add(found);
    }
    // found in the db for the current broker, but not found in discovery, mark as such
    markExternalPoliciesAsDisabled(allPolicyUnits.stream().filter(unit -> !foundInBoth.contains(unit)).filter(unit -> broker.getId().equals(unit.getBroker())).collect(Collectors.toList()));
}
#method_after
private void updateDB(ExternalSchedulerDiscoveryResult discoveryResult) {
    List<PolicyUnit> allPolicyUnits = policyUnitDao.getAll();
    List<PolicyUnit> foundInBoth = new LinkedList<>();
    for (ExternalSchedulerDiscoveryUnit unit : discoveryResult.getFilters()) {
        PolicyUnit found = compareToDB(allPolicyUnits, unit, PolicyUnitType.FILTER);
        if (found != null) {
            foundInBoth.add(found);
        }
    }
    for (ExternalSchedulerDiscoveryUnit unit : discoveryResult.getScores()) {
        PolicyUnit found = compareToDB(allPolicyUnits, unit, PolicyUnitType.WEIGHT);
        if (found != null) {
            foundInBoth.add(found);
        }
    }
    for (ExternalSchedulerDiscoveryUnit unit : discoveryResult.getBalance()) {
        PolicyUnit found = compareToDB(allPolicyUnits, unit, PolicyUnitType.LOAD_BALANCING);
        if (found != null) {
            foundInBoth.add(found);
        }
    }
    allPolicyUnits.removeAll(foundInBoth);
    // found in the db but not found in discovery, mark as such
    markExternalPoliciesAsDisabled(allPolicyUnits);
}
#end_block

#method_before
private void markExternalPoliciesAsDisabled(List<PolicyUnit> units) {
    for (PolicyUnit policyUnit : units) {
        if (!policyUnit.isInternal()) {
            policyUnit.setEnabled(false);
            policyUnit.setBroker(null);
            policyUnitDao.update(policyUnit);
        }
    }
}
#method_after
private void markExternalPoliciesAsDisabled(List<PolicyUnit> units) {
    for (PolicyUnit policyUnit : units) {
        if (!policyUnit.isInternal()) {
            policyUnit.setEnabled(false);
            policyUnitDao.update(policyUnit);
        }
    }
}
#end_block

#method_before
@NotNull
private PolicyUnit compareToDB(ExternalSchedulerBroker broker, List<PolicyUnit> dbEntries, ExternalSchedulerDiscoveryUnit discoveryUnit, PolicyUnitType type) {
    for (PolicyUnit policyUnit : dbEntries) {
        if (policyUnit.isInternal()) {
            continue;
        }
        if (policyUnit.getPolicyUnitType() != type) {
            continue;
        }
        if (!policyUnit.getName().equals(discoveryUnit.getName())) {
            continue;
        }
        Map<String, String> discoveryPropMap = StringUtils.isEmpty(discoveryUnit.getRegex()) ? new LinkedHashMap<>() : SimpleCustomPropertiesUtil.getInstance().convertProperties(discoveryUnit.getRegex());
        if (!discoveryPropMap.equals(policyUnit.getParameterRegExMap()) || !discoveryUnit.getDescription().equals(policyUnit.getDescription()) || !policyUnit.isEnabled() || !broker.getId().equals(policyUnit.getBroker())) {
            sendToDb(broker, discoveryUnit, policyUnit, type);
        }
        return policyUnit;
    }
    return sendToDb(broker, discoveryUnit, null, type);
}
#method_after
private PolicyUnit compareToDB(List<PolicyUnit> dbEnteries, ExternalSchedulerDiscoveryUnit discoveryUnit, PolicyUnitType type) {
    for (PolicyUnit policyUnit : dbEnteries) {
        if (policyUnit.isInternal()) {
            continue;
        }
        if (policyUnit.getPolicyUnitType() != type) {
            continue;
        }
        if (!policyUnit.getName().equals(discoveryUnit.getName())) {
            continue;
        }
        Map<String, String> discoveryPropMap = StringUtils.isEmpty(discoveryUnit.getRegex()) ? new LinkedHashMap<>() : SimpleCustomPropertiesUtil.getInstance().convertProperties(discoveryUnit.getRegex());
        if (!discoveryPropMap.equals(policyUnit.getParameterRegExMap()) || !discoveryUnit.getDescription().equals(policyUnit.getDescription()) || !policyUnit.isEnabled()) {
            sendToDb(discoveryUnit, policyUnit.getId(), type);
        }
        return policyUnit;
    }
    sendToDb(discoveryUnit, null, type);
    return null;
}
#end_block

#method_before
@NotNull
private PolicyUnit sendToDb(ExternalSchedulerBroker broker, ExternalSchedulerDiscoveryUnit discovery, PolicyUnit policyUnit, PolicyUnitType type) {
    PolicyUnit policy = createFromDiscoveryUnit(discovery, type);
    if (policyUnit != null && policyUnit.getBroker() != null) {
        log.warn("Policy unit {} already reported by broker {}", policyUnit.getName(), broker.getId());
    }
    policy.setBroker(broker.getId());
    if (policyUnit != null && policyUnit.getId() != null) {
        policy.setId(policyUnit.getId());
        policyUnitDao.update(policy);
    } else {
        policy.setId(Guid.newGuid());
        policyUnitDao.save(policy);
    }
    return policy;
}
#method_after
private void sendToDb(ExternalSchedulerDiscoveryUnit discovery, Guid policyUnitId, PolicyUnitType type) {
    PolicyUnit policy = createFromDiscoveryUnit(discovery, type);
    if (policyUnitId != null) {
        policy.setId(policyUnitId);
        policyUnitDao.update(policy);
    } else {
        policy.setId(Guid.newGuid());
        policyUnitDao.save(policy);
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(policyUnitType, description, id, internal, name, parameterRegExMap, enabled, broker);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(policyUnitType, description, id, internal, name, parameterRegExMap, enabled);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof PolicyUnit)) {
        return false;
    }
    PolicyUnit other = (PolicyUnit) obj;
    return Objects.equals(description, other.description) && Objects.equals(id, other.id) && internal == other.internal && Objects.equals(name, other.name) && Objects.equals(parameterRegExMap, other.parameterRegExMap) && policyUnitType == other.policyUnitType && enabled == other.enabled && broker == other.broker;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof PolicyUnit)) {
        return false;
    }
    PolicyUnit other = (PolicyUnit) obj;
    return Objects.equals(description, other.description) && Objects.equals(id, other.id) && internal == other.internal && Objects.equals(name, other.name) && Objects.equals(parameterRegExMap, other.parameterRegExMap) && policyUnitType == other.policyUnitType && enabled == other.enabled;
}
#end_block

#method_before
protected ValidationResult validateStatelessVm(VM vm, Boolean stateless) {
    // if the VM is not stateless, there is nothing to check
    if (stateless != null ? !stateless : !vm.isStateless()) {
        return ValidationResult.VALID;
    }
    ValidationResult previewValidation = getSnapshotValidator().vmNotInPreview(vm.getId());
    if (!previewValidation.isValid()) {
        return previewValidation;
    }
    // if the VM itself is stateless or run once as stateless
    if (vm.isAutoStartup()) {
        return new ValidationResult(EngineMessage.VM_CANNOT_RUN_STATELESS_HA);
    }
    ValidationResult hasSpaceValidation = hasSpaceForSnapshots();
    if (!hasSpaceValidation.isValid()) {
        return hasSpaceValidation;
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult validateStatelessVm(VM vm, Boolean stateless) {
    // if the VM is not stateless, there is nothing to check
    if (stateless != null ? !stateless : !vm.isStateless()) {
        return ValidationResult.VALID;
    }
    ValidationResult previewValidation = getSnapshotValidator().vmNotInPreview(vm.getId());
    if (!previewValidation.isValid()) {
        return previewValidation;
    }
    // if the VM itself is stateless or run once as stateless
    if (vm.isAutoStartup()) {
        return new ValidationResult(EngineMessage.VM_CANNOT_RUN_STATELESS_HA);
    }
    ValidationResult hasSpaceValidation = hasSpaceForSnapshots();
    if (!hasSpaceValidation.isValid()) {
        return hasSpaceValidation;
    }
    return isImagesExceededVolumesInImageChain();
}
#end_block

#method_before
private void removeVmStatlessImages() {
    runInternalAction(VdcActionType.ProcessDownVm, new ProcessDownVmParameters(getVm().getId(), true), ExecutionHandler.createDefaultContextForTasks(getContext(), getLock()));
    // setting lock to null in order not to release lock twice
    setLock(null);
    setSucceeded(true);
}
#method_after
private void removeVmStatlessImages() {
    runInternalAction(VdcActionType.ProcessDownVm, new ProcessDownVmParameters(getVm().getId(), true), executionHandler.createDefaultContextForTasks(getContext(), getLock()));
    // setting lock to null in order not to release lock twice
    setLock(null);
    setSucceeded(true);
}
#end_block

#method_before
private CommandContext createContextForRunStatelessVm() {
    Step step = getExecutionContext().getStep();
    if (step == null) {
        return cloneContextAndDetachFromParent();
    }
    // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
    // at this is a new instance of the command is used
    // (comparing with the execution state) so all information on the job and steps should be retrieved.
    Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
    Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
    // We would like to to set the run stateless step as substep of executing step
    setInternalExecution(true);
    ExecutionContext runStatelessVmCtx = new ExecutionContext();
    // The internal command should be monitored for tasks
    runStatelessVmCtx.setMonitored(true);
    Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
    // This is needed in order to end the job upon execution of the steps of the child command
    runStatelessVmCtx.setShouldEndJob(true);
    runStatelessVmCtx.setJob(job);
    // Since run stateless step involves invocation of command, we should set the run stateless vm step as
    // the "beginning step" of the child command.
    runStatelessVmCtx.setStep(runStatelessStep);
    return cloneContextAndDetachFromParent().withExecutionContext(runStatelessVmCtx);
}
#method_after
private CommandContext createContextForRunStatelessVm() {
    Step step = getExecutionContext().getStep();
    if (step == null) {
        return cloneContextAndDetachFromParent();
    }
    // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
    // at this is a new instance of the command is used
    // (comparing with the execution state) so all information on the job and steps should be retrieved.
    Job job = jobRepository.getJobWithSteps(step.getJobId());
    Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
    // We would like to to set the run stateless step as substep of executing step
    setInternalExecution(true);
    ExecutionContext runStatelessVmCtx = new ExecutionContext();
    // The internal command should be monitored for tasks
    runStatelessVmCtx.setMonitored(true);
    Step runStatelessStep = executionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
    // This is needed in order to end the job upon execution of the steps of the child command
    runStatelessVmCtx.setShouldEndJob(true);
    runStatelessVmCtx.setJob(job);
    // Since run stateless step involves invocation of command, we should set the run stateless vm step as
    // the "beginning step" of the child command.
    runStatelessVmCtx.setStep(runStatelessStep);
    return cloneContextAndDetachFromParent().withExecutionContext(runStatelessVmCtx);
}
#end_block

#method_before
@Override
protected void endExecutionMonitoring() {
    if (getVm().isRunAndPause() && getVmDynamicDao().get(getVmId()).getStatus() == VMStatus.Paused) {
        final ExecutionContext executionContext = getExecutionContext();
        executionContext.setShouldEndJob(true);
        ExecutionHandler.endJob(executionContext, true);
    } else {
        super.endExecutionMonitoring();
    }
}
#method_after
@Override
protected void endExecutionMonitoring() {
    if (getVm().isRunAndPause() && getVmDynamicDao().get(getVmId()).getStatus() == VMStatus.Paused) {
        final ExecutionContext executionContext = getExecutionContext();
        executionContext.setShouldEndJob(true);
        executionHandler.endJob(executionContext, true);
    } else {
        super.endExecutionMonitoring();
    }
}
#end_block

#method_before
private void freeLockForValidationPassedCommands() {
    for (CommandBase<?> command : getCommands()) {
        if (command.getReturnValue().isValid()) {
            command.freeLock();
        }
    }
}
#method_after
private void freeLockForValidationPassedCommands() {
    getCommands().stream().filter(command -> command.getReturnValue().isValid()).forEach(command -> command.freeLock());
}
#end_block

#method_before
public static OS fromPackageVersionString(String packageVersionString) {
    if (packageVersionString == null) {
        return new OS();
    }
    String[] os = packageVersionString.split(OS_DELIMITER, 3);
    if (os.length < 2) {
        return new OS();
    }
    final String name = os[0].trim();
    final Matcher versionMatcher = versionPattern.matcher(os[1].trim());
    final Version version;
    if (versionMatcher.find()) {
        version = new Version(versionMatcher.group());
    } else if (os.length == 3 && os[2].contains("el6")) {
        version = new Version(6, -1);
    } else if (os.length == 3 && os[2].contains("el7")) {
        version = new Version(7, -1);
    } else {
        version = new Version();
    }
    final String fullVersion = StringUtils.join(Arrays.copyOfRange(os, 1, os.length), OS_DELIMITER);
    return new OS(name, version, fullVersion);
}
#method_after
public static OS fromPackageVersionString(String packageVersionString) {
    if (packageVersionString == null) {
        return new OS();
    }
    String[] os = packageVersionString.split(OS_DELIMITER, 3);
    if (os.length < 2) {
        return new OS();
    }
    final String name = os[0].trim();
    final Matcher versionMatcher = versionPattern.matcher(os[1].trim());
    final Version version;
    if (versionMatcher.find()) {
        if (name != null && name.toLowerCase().startsWith("fedora")) {
            int major = extractVersionPart(versionMatcher.group());
            int minor = extractVersionPart(os[2].trim());
            version = new Version(major, minor);
        } else {
            version = new Version(versionMatcher.group());
        }
    } else if (os.length == 3 && os[2].contains("el6")) {
        version = new Version(6, -1);
    } else if (os.length == 3 && os[2].contains("el7")) {
        version = new Version(7, -1);
    } else {
        version = new Version();
    }
    final String fullVersion = StringUtils.join(Arrays.copyOfRange(os, 1, os.length), OS_DELIMITER);
    return new OS(name, version, fullVersion);
}
#end_block

#method_before
public String getValue() {
    final StringBuilder val = new StringBuilder();
    if (this.major > -1) {
        val.append(this.major);
    }
    appendVersionComponent(val, this.minor);
    appendVersionComponent(val, this.build);
    appendVersionComponent(val, this.revision);
    return val.toString();
}
#method_after
public String getValue() {
    final StringBuilder val = new StringBuilder();
    if (this.major > VERSION_NOT_SET) {
        val.append(this.major);
    }
    appendVersionComponent(val, this.minor);
    appendVersionComponent(val, this.build);
    appendVersionComponent(val, this.revision);
    return val.toString();
}
#end_block

#method_before
private static void appendVersionComponent(StringBuilder val, int versionNumber) {
    if (versionNumber > -1) {
        if (val.length() != 0) {
            val.append('.');
        }
        val.append(versionNumber);
    }
}
#method_after
private static void appendVersionComponent(StringBuilder val, int versionNumber) {
    if (versionNumber > VERSION_NOT_SET) {
        if (val.length() != 0) {
            val.append('.');
        }
        val.append(versionNumber);
    }
}
#end_block

#method_before
public void setValue(String value) {
    if (value == null || value.isEmpty() || value.equals("*")) {
        major = minor = build = revision = -1;
    } else {
        String[] partialVersions = value.split("\\.");
        switch(partialVersions.length) {
            case 4:
                revision = Integer.parseInt(partialVersions[3]);
            case 3:
                build = Integer.parseInt(partialVersions[2]);
            case 2:
                minor = Integer.parseInt(partialVersions[1]);
            case 1:
                major = Integer.parseInt(partialVersions[0]);
        }
    }
}
#method_after
public void setValue(String value) {
    if (value == null || value.isEmpty() || value.equals("*")) {
        major = minor = build = revision = VERSION_NOT_SET;
    } else {
        String[] partialVersions = value.split("\\.");
        switch(partialVersions.length) {
            case 4:
                revision = Integer.parseInt(partialVersions[3]);
            case 3:
                build = Integer.parseInt(partialVersions[2]);
            case 2:
                minor = Integer.parseInt(partialVersions[1]);
            case 1:
                major = Integer.parseInt(partialVersions[0]);
        }
    }
}
#end_block

#method_before
public boolean isNotValid() {
    return major == -1 && minor == -1 && revision == -1 && build == -1;
}
#method_after
public boolean isNotValid() {
    return major == VERSION_NOT_SET && minor == VERSION_NOT_SET && revision == VERSION_NOT_SET && build == VERSION_NOT_SET;
}
#end_block

#method_before
@Parameterized.Parameters
public static Collection<Object[]> namesParams() {
    return Arrays.asList(new Object[][] { { "RHEL - 7.2 - 9.el7", 7, 2, -1, -1, "7.2 - 9.el7" }, { "RHEL - 7 - 1.1503.el7.centos.2.8", 7, -1, -1, -1, "7 - 1.1503.el7.centos.2.8" }, { "oVirt Node - 3.6 - 0.999.201608161021.el7.centos", 3, 6, -1, -1, "3.6 - 0.999.201608161021.el7.centos" }, { "RHEV Hypervisor - 7.2 - 20160711.0.el7ev", 7, 2, -1, -1, "7.2 - 20160711.0.el7ev" } });
}
#method_after
@Parameterized.Parameters
public static Collection<Object[]> namesParams() {
    return Arrays.asList(new Object[][] { { "RHEL - 7.2 - 9.el7", 7, 2, -1, -1, "7.2 - 9.el7" }, { "RHEL - 7 - 1.1503.el7.centos.2.8", 7, -1, -1, -1, "7 - 1.1503.el7.centos.2.8" }, { "oVirt Node - 3.6 - 0.999.201608161021.el7.centos", 3, 6, -1, -1, "3.6 - 0.999.201608161021.el7.centos" }, { "RHEV Hypervisor - 7.2 - 20160711.0.el7ev", 7, 2, -1, -1, "7.2 - 20160711.0.el7ev" }, { "Fedora - 19 - 1", 19, 1, -1, -1, "19 - 1" } });
}
#end_block

#method_before
private static OperatingSystem mapOperatingSystem(VDS entity) {
    final OperatingSystem model = new OperatingSystem();
    if (StringUtils.isNotBlank(entity.getHostOs())) {
        OS hostOs = OS.fromPackageVersionString(entity.getHostOs());
        Version version = new Version();
        version.setMajor(hostOs.getVersion().getMajor());
        if (hostOs.getVersion().getMinor() != org.ovirt.engine.core.compat.Version.VERSION_NOT_SET) {
            version.setMinor(hostOs.getVersion().getMinor());
        }
        if (hostOs.getVersion().getBuild() != org.ovirt.engine.core.compat.Version.VERSION_NOT_SET) {
            version.setBuild(hostOs.getVersion().getBuild());
        }
        version.setFullVersion(hostOs.getFullVersion());
        model.setVersion(version);
        model.setType(hostOs.getName());
    }
    model.setCustomKernelCmdline(Objects.toString(entity.getCurrentKernelCmdline(), ""));
    model.setReportedKernelCmdline(entity.getKernelArgs());
    return model;
}
#method_after
private static OperatingSystem mapOperatingSystem(VDS entity) {
    final OperatingSystem model = new OperatingSystem();
    if (StringUtils.isNotBlank(entity.getHostOs())) {
        OS hostOs = OS.fromPackageVersionString(entity.getHostOs());
        Version version = new Version();
        if (hostOs.getVersion().getMajor() != VERSION_NOT_SET) {
            version.setMajor(hostOs.getVersion().getMajor());
        }
        if (hostOs.getVersion().getMinor() != VERSION_NOT_SET) {
            version.setMinor(hostOs.getVersion().getMinor());
        }
        if (hostOs.getVersion().getBuild() != VERSION_NOT_SET) {
            version.setBuild(hostOs.getVersion().getBuild());
        }
        version.setFullVersion(hostOs.getFullVersion());
        model.setVersion(version);
        model.setType(hostOs.getName());
    }
    model.setCustomKernelCmdline(Objects.toString(entity.getCurrentKernelCmdline(), ""));
    model.setReportedKernelCmdline(entity.getKernelArgs());
    return model;
}
#end_block

#method_before
@Override
protected void init() {
    T parameters = getParameters();
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getMasterVm(), getMasterVmCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(false);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        VmHandler.updateDefaultTimeZone(parameterMasterVm);
        VmHandler.autoSelectUsbPolicy(getParameters().getMasterVm());
        VmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        VmHandler.autoSelectGraphicsDevice(getVmId(), parameterMasterVm, getCluster(), getParameters().getGraphicsDevices(), getMasterVmCompatibilityVersion());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#method_after
@Override
protected void init() {
    T parameters = getParameters();
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (VmDeviceUtils.shouldOverrideSoundDevice(getParameters().getMasterVm(), getMasterVmCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(false);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        VmHandler.updateDefaultTimeZone(parameterMasterVm);
        VmHandler.autoSelectUsbPolicy(getParameters().getMasterVm());
        VmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        VmHandler.autoSelectGraphicsDevice(getVmId(), parameterMasterVm, getCluster(), getParameters().getGraphicsDevices(), getMasterVmCompatibilityVersion());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#end_block

#method_before
protected void updateVmDevices() {
    getVmDeviceUtils().setVmDevices(getVm().getStaticData());
}
#method_after
protected void updateVmDevices() {
    VmDeviceUtils.setVmDevices(getVm().getStaticData());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (!isVmStatusValid(vmDynamic.getStatus())) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (!StringUtils.isEmpty(jobId)) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                getSchedulUtil().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(() -> {
        addVmTemplateToDb();
        getCompensationContext().stateChanged();
        return null;
    });
    if (getVm() != null && !addVmTemplateCinderDisks(srcDeviceIdToTargetDeviceIdMapping)) {
        // Error cloning Cinder disks for template
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addPermission();
        addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
        addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
        Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
        if (isVmInDb) {
            getVmDeviceUtils().copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getVmDeviceUtils().hasMemoryBalloon(getVmId()), graphicsToSkip, false);
        } else {
            // for instance type and new template without a VM
            getVmDeviceUtils().copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), Boolean.TRUE.equals(getParameters().isBalloonEnabled()), graphicsToSkip, false);
        }
        updateWatchdog(getVmTemplateId());
        updateRngDevice(getVmTemplateId());
        addGraphicsDevice();
        setSucceeded(true);
        return null;
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVm().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (!isVmStatusValid(vmDynamic.getStatus())) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (!StringUtils.isEmpty(jobId)) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                getSchedulUtil().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(() -> {
        addVmTemplateToDb();
        getCompensationContext().stateChanged();
        return null;
    });
    if (getVm() != null && !addVmTemplateCinderDisks(srcDeviceIdToTargetDeviceIdMapping)) {
        // Error cloning Cinder disks for template
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addPermission();
        addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
        addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
        Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
        if (isVmInDb) {
            VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.hasMemoryBalloon(getVmId()), graphicsToSkip, false);
        } else {
            // for instance type and new template without a VM
            VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), Boolean.TRUE.equals(getParameters().isBalloonEnabled()), graphicsToSkip, false);
        }
        updateWatchdog(getVmTemplateId());
        updateRngDevice(getVmTemplateId());
        addGraphicsDevice();
        setSucceeded(true);
        return null;
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVm().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the display type is supported
    Guid srcId = isVmInDb ? getVmId() : VmTemplateHandler.BLANK_VM_TEMPLATE_ID;
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getMasterVm().getOsId(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(srcId), getParameters().getGraphicsDevices()), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getValidationMessages(), getVm().getCompatibilityVersion())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVm().getCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    if (!VmPropertiesUtils.getInstance().validateVmProperties(getVm().getCompatibilityVersion(), getParameters().getMasterVm().getCustomProperties(), getReturnValue().getValidationMessages())) {
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getThreadsPerCpu(), getVm().getCompatibilityVersion().toString(), getReturnValue().getValidationMessages());
}
#method_after
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the display type is supported
    Guid srcId = isVmInDb ? getVmId() : VmTemplateHandler.BLANK_VM_TEMPLATE_ID;
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getMasterVm().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(srcId), getParameters().getGraphicsDevices()), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getValidationMessages(), getVm().getCompatibilityVersion())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVm().getCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    if (!VmPropertiesUtils.getInstance().validateVmProperties(getVm().getCompatibilityVersion(), getParameters().getMasterVm().getCustomProperties(), getReturnValue().getValidationMessages())) {
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getThreadsPerCpu(), getVm().getCompatibilityVersion().toString(), getReturnValue().getValidationMessages());
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!isFloatingDisk() && !validate(new VmValidator(getVm()).isVmExists()) && !validateDiskVmData()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (vm != null) {
        if (!validateDiskVmData() || !canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        if (getDiskVmElement().isBoot() && !validate(diskValidator.isVmNotContainsBootDisk(vm))) {
            return false;
        }
        // if user sent drive check that its not in use
        if (!isDiskPassPciAndIdeLimit()) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface(getDiskVmElement()))) {
        return false;
    }
    if (!validateQuota()) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Collections.singletonList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!isFloatingDisk() && !validate(new VmValidator(getVm()).isVmExists()) && !validateDiskVmData()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (vm != null) {
        if (!validateDiskVmData() || !canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        if (getDiskVmElement().isBoot() && !validate(diskValidator.isVmNotContainsBootDisk(vm))) {
            return false;
        }
        // if user sent drive check that its not in use
        if (!isDiskPassPciAndIdeLimit()) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface(getDiskVmElement()))) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Collections.singletonList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#end_block

#method_before
private VmDevice addManagedDeviceForDisk(Guid diskId, Boolean isUsingScsiReservation) {
    return getVmDeviceUtils().addDiskDevice(getVmId(), diskId, shouldDiskBePlugged(), Boolean.TRUE.equals(getParameters().getDiskInfo().getReadOnly()), Boolean.TRUE.equals(isUsingScsiReservation));
}
#method_after
private VmDevice addManagedDeviceForDisk(Guid diskId, Boolean isUsingScsiReservation) {
    return VmDeviceUtils.addDiskDevice(getVmId(), diskId, shouldDiskBePlugged(), Boolean.TRUE.equals(getParameters().getDiskInfo().getReadOnly()), Boolean.TRUE.equals(isUsingScsiReservation));
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isDiskExistAndAttachedToVm(getOldDisk()) || !validateDiskVmData()) {
        return false;
    }
    boolean isDiskImageOrCinder = DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() || DiskStorageType.CINDER == getOldDisk().getDiskStorageType();
    if (isDiskImageOrCinder) {
        ValidationResult imagesNotLocked = new DiskImagesValidator(Collections.singletonList((DiskImage) getOldDisk())).diskImagesNotLocked();
        if (!imagesNotLocked.isValid()) {
            return validate(imagesNotLocked);
        }
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    boolean isDiskInterfaceUpdated = getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface();
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDiskVmElement().isBoot() && getDiskVmElement().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(oldDiskValidator.isVmNotContainsBootDisk(getVm()))) {
            return false;
        }
        if (isDiskInterfaceUpdated && !isDiskPassPciAndIdeLimit()) {
            return false;
        }
    }
    if (isDiskImageOrCinder && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validateVmPoolProperties() && validateQuota() && validate(diskValidator.isVirtIoScsiValid(getVm(), getDiskVmElement())) && (!isDiskInterfaceUpdated || validate(diskValidator.isDiskInterfaceSupported(getVm(), getDiskVmElement()))) && setAndValidateDiskProfiles();
}
#method_after
@Override
protected boolean validate() {
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isDiskExistAndAttachedToVm(getOldDisk()) || !validateDiskVmData()) {
        return false;
    }
    boolean isDiskImageOrCinder = DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() || DiskStorageType.CINDER == getOldDisk().getDiskStorageType();
    if (isDiskImageOrCinder) {
        ValidationResult imagesNotLocked = new DiskImagesValidator(Collections.singletonList((DiskImage) getOldDisk())).diskImagesNotLocked();
        if (!imagesNotLocked.isValid()) {
            return validate(imagesNotLocked);
        }
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    boolean isDiskInterfaceUpdated = getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface();
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDiskVmElement().isBoot() && getDiskVmElement().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(oldDiskValidator.isVmNotContainsBootDisk(getVm()))) {
            return false;
        }
        if (isDiskInterfaceUpdated && !isDiskPassPciAndIdeLimit()) {
            return false;
        }
    }
    if (isDiskImageOrCinder && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validateVmPoolProperties() && validate(diskValidator.isVirtIoScsiValid(getVm(), getDiskVmElement())) && (!isDiskInterfaceUpdated || validate(diskValidator.isDiskInterfaceSupported(getVm(), getDiskVmElement()))) && setAndValidateDiskProfiles();
}
#end_block

#method_before
protected void performDiskUpdate(final boolean unlockImage) {
    if (shouldPerformMetadataUpdate()) {
        updateMetaDataDescription((DiskImage) getNewDisk());
    }
    final Disk diskForUpdate = getDiskDao().get(getParameters().getDiskInfo().getId());
    final DiskVmElement diskVmElementForUpdate = getDiskVmElementDao().get(new VmDeviceId(getOldDisk().getId(), getVmId()));
    applyUserChanges(diskForUpdate, diskVmElementForUpdate);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDao().incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            getBaseDiskDao().update(diskForUpdate);
            getDiskVmElementDao().update(diskVmElementForUpdate);
            switch(diskForUpdate.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) diskForUpdate;
                    diskImage.setQuotaId(getQuotaId());
                    if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                        diskImage.setImageStatus(ImageStatus.OK);
                    }
                    getImageDao().update(diskImage.getImage());
                    updateQuota(diskImage);
                    updateDiskProfile();
                    break;
                case CINDER:
                    CinderDisk cinderDisk = (CinderDisk) diskForUpdate;
                    cinderDisk.setQuotaId(getQuotaId());
                    setStorageDomainId(cinderDisk.getStorageIds().get(0));
                    getCinderBroker().updateDisk(cinderDisk);
                    if (unlockImage && cinderDisk.getImageStatus() == ImageStatus.LOCKED) {
                        cinderDisk.setImageStatus(ImageStatus.OK);
                    }
                    getImageDao().update(cinderDisk.getImage());
                    updateQuota(cinderDisk);
                    break;
                case LUN:
                    updateLunProperties((LunDisk) getNewDisk());
                    break;
            }
            reloadDisks();
            updateBootOrder();
            setSucceeded(true);
            // If necessary set the new Storage QoS values on running VMs asynchronously
            liveUpdateDiskProfile();
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                getVmDeviceDao().update(vmDeviceForVm);
            }
            if (getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface()) {
                vmDeviceForVm.setAddress("");
                getVmDeviceDao().clearDeviceAddress(getOldDisk().getId());
            }
        }

        private void updateLunProperties(LunDisk lunDisk) {
            if (updateIsUsingScsiReservationRequested(lunDisk)) {
                vmDeviceForVm.setUsingScsiReservation(lunDisk.isUsingScsiReservation());
                getVmDeviceDao().update(vmDeviceForVm);
            }
        }
    });
}
#method_after
protected void performDiskUpdate(final boolean unlockImage) {
    if (shouldPerformMetadataUpdate()) {
        updateMetaDataDescription((DiskImage) getNewDisk());
    }
    final Disk diskForUpdate = getDiskDao().get(getParameters().getDiskInfo().getId());
    final DiskVmElement diskVmElementForUpdate = getDiskVmElementDao().get(new VmDeviceId(getOldDisk().getId(), getVmId()));
    applyUserChanges(diskForUpdate, diskVmElementForUpdate);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDao().incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            getBaseDiskDao().update(diskForUpdate);
            getDiskVmElementDao().update(diskVmElementForUpdate);
            switch(diskForUpdate.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) diskForUpdate;
                    diskImage.setQuotaId(getQuotaId());
                    if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                        diskImage.setImageStatus(ImageStatus.OK);
                    }
                    getImageDao().update(diskImage.getImage());
                    updateQuota(diskImage);
                    updateDiskProfile();
                    break;
                case CINDER:
                    CinderDisk cinderDisk = (CinderDisk) diskForUpdate;
                    cinderDisk.setQuotaId(getQuotaId());
                    setStorageDomainId(cinderDisk.getStorageIds().get(0));
                    getCinderBroker().updateDisk(cinderDisk);
                    if (unlockImage && cinderDisk.getImageStatus() == ImageStatus.LOCKED) {
                        cinderDisk.setImageStatus(ImageStatus.OK);
                    }
                    getImageDao().update(cinderDisk.getImage());
                    updateQuota(cinderDisk);
                    break;
                case LUN:
                    updateLunProperties((LunDisk) getNewDisk());
                    break;
            }
            reloadDisks();
            updateBootOrder();
            setSucceeded(true);
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                getVmDeviceDao().update(vmDeviceForVm);
            }
            if (getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface()) {
                vmDeviceForVm.setAddress("");
                getVmDeviceDao().clearDeviceAddress(getOldDisk().getId());
            }
        }

        private void updateLunProperties(LunDisk lunDisk) {
            if (updateIsUsingScsiReservationRequested(lunDisk)) {
                vmDeviceForVm.setUsingScsiReservation(lunDisk.isUsingScsiReservation());
                getVmDeviceDao().update(vmDeviceForVm);
            }
        }
    });
}
#end_block

#method_before
protected void updateBootOrder() {
    getVmDeviceUtils().updateBootOrder(getVm().getId());
}
#method_after
protected void updateBootOrder() {
    VmDeviceUtils.updateBootOrder(getVm().getId());
}
#end_block

#method_before
private VdcActionParametersBase buildExtendCinderDiskParameters(CinderDisk newCinderDisk) {
    VmDiskOperationParameterBase parameters = new VmDiskOperationParameterBase(DiskVmElement.copyOf(getOldDiskVmElement()), newCinderDisk);
    parameters.setParametersCurrentUser(getParameters().getParametersCurrentUser());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return parameters;
}
#method_after
private VdcActionParametersBase buildExtendCinderDiskParameters(CinderDisk newCinderDisk) {
    VmDiskOperationParameterBase parameters = new VmDiskOperationParameterBase(new DiskVmElement(newCinderDisk.getId(), getVmId()), newCinderDisk);
    parameters.setParametersCurrentUser(getParameters().getParametersCurrentUser());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return parameters;
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for validate to run with correct values, has to come before init-disks
    updateVmObject();
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    VmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
    if (vmDisksSource != null) {
        parameters.setUseCinderCommandCallback(!vmDisksSource.getDiskTemplateMap().isEmpty());
    }
}
#method_after
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (VmDeviceUtils.shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for validate to run with correct values, has to come before init-disks
    updateVmObject();
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    VmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
    if (vmDisksSource != null) {
        parameters.setUseCinderCommandCallback(!vmDisksSource.getDiskTemplateMap().isEmpty());
    }
}
#end_block

#method_before
protected boolean validateAddVmCommand() {
    return areParametersLegal(getReturnValue().getValidationMessages()) && checkNumberOfMonitors() && checkSingleQxlDisplay() && validate(VmValidator.checkPciAndIdeLimit(getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getDiskVmElements(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled())) && canAddVm(getReturnValue().getValidationMessages(), destStorages.values()) && hostToRunExist();
}
#method_after
protected boolean validateAddVmCommand() {
    return areParametersLegal(getReturnValue().getValidationMessages()) && checkNumberOfMonitors() && checkSingleQxlDisplay() && checkPciAndIdeLimit(getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getDiskVmElements(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getValidationMessages()) && canAddVm(getReturnValue().getValidationMessages(), destStorages.values()) && hostToRunExist();
}
#end_block

#method_before
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    macPool = getMacPool();
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == VdcActionType.AddVmPool) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!VmTemplateCommand.isVmTemplateImagesReady(vmDisksSource, storage.getId(), reasons, false, false, true, true, storageToDisksMap.get(storage.getId()))) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == VdcActionType.AddVmPoolWithVms) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!VmTemplateCommand.isVmTemplateImagesReady(vmDisksSource, storage.getId(), reasons, false, false, true, true, storageToDisksMap.get(storage.getId()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void updateSmartCardDevices() {
    // if vm smartcard settings is different from device source's
    // add or remove the smartcard according to user request
    boolean smartcardOnDeviceSource = getInstanceTypeId() != null ? getInstanceType().isSmartcardEnabled() : getVmTemplate().isSmartcardEnabled();
    if (getVm().isSmartcardEnabled() != smartcardOnDeviceSource) {
        getVmDeviceUtils().updateSmartcardDevice(getVm().getId(), getVm().isSmartcardEnabled());
    }
}
#method_after
private void updateSmartCardDevices() {
    // if vm smartcard settings is different from device source's
    // add or remove the smartcard according to user request
    boolean smartcardOnDeviceSource = getInstanceTypeId() != null ? getInstanceType().isSmartcardEnabled() : getVmTemplate().isSmartcardEnabled();
    if (getVm().isSmartcardEnabled() != smartcardOnDeviceSource) {
        VmDeviceUtils.updateSmartcardDevice(getVm().getId(), getVm().isSmartcardEnabled());
    }
}
#end_block

#method_before
protected void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        VdcActionType actionType = getVmDeviceUtils().hasWatchdog(getVmTemplateId()) ? VdcActionType.UpdateWatchdog : VdcActionType.AddWatchdog;
        runInternalAction(actionType, buildWatchdogParameters(vmWatchdog), cloneContextAndDetachFromParent());
    }
}
#method_after
protected void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        VdcActionType actionType = VmDeviceUtils.hasWatchdog(getVmTemplateId()) ? VdcActionType.UpdateWatchdog : VdcActionType.AddWatchdog;
        runInternalAction(actionType, buildWatchdogParameters(vmWatchdog), cloneContextAndDetachFromParent());
    }
}
#end_block

#method_before
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        getVmDeviceUtils().addManagedDevice(new VmDeviceId(Guid.newGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
    }
}
#method_after
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
    }
}
#end_block

#method_before
protected void copyVmDevices() {
    getVmDeviceUtils().copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), getParameters().getGraphicsDevices().keySet(), false);
    if (getInstanceTypeId() != null) {
        copyDiskDevicesFromTemplate();
    }
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), getParameters().getGraphicsDevices().keySet(), false);
    if (getInstanceTypeId() != null) {
        copyDiskDevicesFromTemplate();
    }
}
#end_block

#method_before
private void copyDiskDevicesFromTemplate() {
    List<VmDevice> disks = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmDisksSource.getId(), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName());
    getVmDeviceUtils().copyDiskDevices(getVmId(), disks, getSrcDeviceIdToTargetDeviceIdMapping());
}
#method_after
private void copyDiskDevicesFromTemplate() {
    List<VmDevice> disks = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmDisksSource.getId(), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName());
    VmDeviceUtils.copyDiskDevices(getVmId(), disks, getSrcDeviceIdToTargetDeviceIdMapping());
}
#end_block

#method_before
void addVmStatistics() {
    VmStatistics stats = new VmStatistics(getVmId());
    DbFacade.getInstance().getVmStatisticsDao().save(stats);
    getCompensationContext().snapshotNewEntity(stats);
}
#method_after
void addVmStatistics() {
    VmStatistics stats = new VmStatistics();
    stats.setId(getVmId());
    DbFacade.getInstance().getVmStatisticsDao().save(stats);
    getCompensationContext().snapshotNewEntity(stats);
}
#end_block

#method_before
protected boolean isVirtioScsiControllerAttached(Guid vmId) {
    return getVmDeviceUtils().hasVirtioScsiController(vmId);
}
#method_after
protected boolean isVirtioScsiControllerAttached(Guid vmId) {
    return VmDeviceUtils.hasVirtioScsiController(vmId);
}
#end_block

#method_before
protected boolean checkNumberOfMonitors() {
    Collection<GraphicsType> graphicsTypes = VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices());
    int numOfMonitors = getParameters().getVmStaticData().getNumOfMonitors();
    return VmHandler.isNumOfMonitorsLegal(graphicsTypes, numOfMonitors, getReturnValue().getValidationMessages());
}
#method_after
protected boolean checkNumberOfMonitors() {
    Collection<GraphicsType> graphicsTypes = VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices());
    int numOfMonitors = getParameters().getVmStaticData().getNumOfMonitors();
    return VmHandler.isNumOfMonitorsLegal(graphicsTypes, numOfMonitors, getReturnValue().getValidationMessages());
}
#end_block

#method_before
public VdcReturnValueBase executeAction() {
    getSessionDataContainer().updateSessionLastActiveTime(getParameters().getSessionId());
    determineExecutionReason();
    actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        if (parentHasCallback()) {
            persistCommand(getParameters().getParentCommand());
        }
        actionAllowed = getReturnValue().isValid() || internalValidate();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setValid(false);
        }
    } finally {
        updateCommandIfNeeded();
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase executeAction() {
    getSessionDataContainer().updateSessionLastActiveTime(getParameters().getSessionId());
    determineExecutionReason();
    actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        if (getCallback() != null || parentHasCallback()) {
            persistCommand(getParameters().getParentCommand());
            CommandCoordinatorUtil.persistCommandAssociatedEntities(getCommandId(), getSubjectEntities());
        }
        actionAllowed = getReturnValue().isValid() || internalValidate();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setValid(false);
        }
    } finally {
        persistCommandIfNeeded();
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#end_block

#method_before
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setValid(true);
    getReturnValue().setIsSyncronious(true);
    if (shouldPersistCommand()) {
        persistCommandIfNeeded();
        CommandCoordinatorUtil.persistCommandAssociatedEntities(getCommandId(), getSubjectEntities());
    }
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("Transaction was aborted in '{}'", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
            if (getSucceeded()) {
                if (getCommandShouldBeLogged()) {
                    logRenamedEntity();
                }
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (noAsyncOperations() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#method_after
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setValid(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("Transaction was aborted in '{}'", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
            if (getSucceeded()) {
                if (getCommandShouldBeLogged()) {
                    logRenamedEntity();
                }
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (noAsyncOperations() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#end_block

#method_before
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addValidationMessages(validationResult.getMessages());
        validationResult.getVariableReplacements().forEach(this::addValidationMessage);
    }
    return validationResult.isValid();
}
#method_after
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addValidationMessage(validationResult.getMessage());
        validationResult.getVariableReplacements().forEach(this::addValidationMessage);
    }
    return validationResult.isValid();
}
#end_block

#method_before
protected final boolean failValidation(EngineMessage message, String... variableReplacements) {
    return failValidation(Collections.singletonList(message), variableReplacements);
}
#method_after
protected final boolean failValidation(EngineMessage message, String... variableReplacements) {
    addValidationMessage(message);
    for (String variableReplacement : variableReplacements) {
        addValidationMessage(variableReplacement);
    }
    return false;
}
#end_block

#method_before
public Map<String, String> getJobMessageProperties() {
    jobProperties = new HashMap<>();
    List<PermissionSubject> subjects = getPermissionCheckSubjects();
    if (!subjects.isEmpty()) {
        VdcObjectType entityType;
        Guid entityId;
        String value;
        for (PermissionSubject permSubject : subjects) {
            entityType = permSubject.getObjectType();
            entityId = permSubject.getObjectId();
            if (entityType != null && entityId != null) {
                value = entityDao.getEntityNameByIdAndType(entityId, entityType);
                if (value == null) {
                    value = entityId.toString();
                }
                jobProperties.put(entityType.name().toLowerCase(), value);
            }
        }
    }
    return jobProperties;
}
#method_after
public Map<String, String> getJobMessageProperties() {
    jobProperties = new HashMap<>();
    List<PermissionSubject> subjects = getPermissionCheckSubjects();
    if (!subjects.isEmpty()) {
        VdcObjectType entityType;
        Guid entityId;
        String value;
        for (PermissionSubject permSubject : subjects) {
            entityType = permSubject.getObjectType();
            entityId = permSubject.getObjectId();
            if (entityType != null && entityId != null) {
                value = DbFacade.getInstance().getEntityNameByIdAndType(entityId, entityType);
                if (value == null) {
                    value = entityId.toString();
                }
                jobProperties.put(entityType.name().toLowerCase(), value);
            }
        }
    }
    return jobProperties;
}
#end_block

#method_before
public Guid defaultQuotaIfNull(Guid quotaId) {
    if (quotaId == null || Guid.Empty.equals(quotaId)) {
        quotaId = quotaManager.getDefaultQuotaId(getStoragePoolId());
    }
    return quotaId;
}
#method_after
protected Guid defaultQuotaIfNull(Guid quotaId) {
    if (quotaId == null || Guid.Empty.equals(quotaId)) {
        quotaId = getStoragePool().getDefaultQuotaId();
    }
    return quotaId;
}
#end_block

#method_before
protected void persistCommandIfNeeded() {
    if (shouldPersistCommand()) {
        persistCommand(getParameters().getParentCommand());
    }
}
#method_after
protected void persistCommandIfNeeded() {
    if (getCallback() != null || parentHasCallback()) {
        persistCommand(getParameters().getParentCommand());
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new HostedEngineEditNotifier(getVm()));
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private boolean updateRngDevice() {
    // do not update if this flag is not set
    if (getParameters().isUpdateRngDevice()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
        List<VmRngDevice> rngDevs = query.getReturnValue();
        VdcReturnValueBase rngCommandResult = null;
        if (rngDevs.isEmpty()) {
            if (getParameters().getRngDevice() != null) {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                rngCommandResult = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
            }
        } else {
            if (getParameters().getRngDevice() == null) {
                RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
                rngCommandResult = runInternalAction(VdcActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
            } else {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
                rngCommandResult = runInternalAction(VdcActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
            }
        }
        if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean updateRngDevice() {
    // do not update if this flag is not set
    if (getParameters().isUpdateRngDevice()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
        @SuppressWarnings("unchecked")
        List<VmRngDevice> rngDevs = query.getReturnValue();
        VdcReturnValueBase rngCommandResult = null;
        if (rngDevs.isEmpty()) {
            if (getParameters().getRngDevice() != null) {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                rngCommandResult = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
            }
        } else {
            if (getParameters().getRngDevice() == null) {
                RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
                rngCommandResult = runInternalAction(VdcActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
            } else {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
                rngCommandResult = runInternalAction(VdcActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
            }
        }
        if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void createNextRunSnapshot() {
    // first remove existing snapshot
    Snapshot runSnap = getSnapshotDao().get(getVmId(), Snapshot.SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
    }
    VM vm = new VM();
    vm.setStaticData(getParameters().getVmStaticData());
    // create new snapshot with new configuration
    new SnapshotsManager().addSnapshot(Guid.newGuid(), "Next Run configuration snapshot", Snapshot.SnapshotStatus.OK, Snapshot.SnapshotType.NEXT_RUN, vm, true, StringUtils.EMPTY, Collections.<DiskImage>emptyList(), getVmDeviceUtils().getVmDevicesForNextRun(getVm(), getParameters()), getCompensationContext());
}
#method_after
private void createNextRunSnapshot() {
    // first remove existing snapshot
    Snapshot runSnap = getSnapshotDao().get(getVmId(), Snapshot.SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
    }
    VM vm = new VM();
    vm.setStaticData(getParameters().getVmStaticData());
    // create new snapshot with new configuration
    new SnapshotsManager().addSnapshot(Guid.newGuid(), "Next Run configuration snapshot", Snapshot.SnapshotStatus.OK, Snapshot.SnapshotType.NEXT_RUN, vm, true, StringUtils.EMPTY, Collections.<DiskImage>emptyList(), VmDeviceUtils.getVmDevicesForNextRun(getVm(), getParameters()), getCompensationContext());
}
#end_block

#method_before
protected void updateVmPayload() {
    VmDeviceDao dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            getVmDeviceUtils().addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
        }
    }
}
#method_after
protected void updateVmPayload() {
    VmDeviceDao dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(Injector.get(InClusterUpgradeValidator.class).isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<DiskVmElement> diskVmElements = getDbFacade().getDiskVmElementDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return validate(VmValidator.checkPciAndIdeLimit(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), vmFromParams.getNumOfMonitors(), interfaces, diskVmElements, isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled()));
}
#method_after
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<DiskVmElement> diskVmElements = getDbFacade().getDiskVmElementDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), vmFromParams.getNumOfMonitors(), interfaces, diskVmElements, isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getValidationMessages());
}
#end_block

#method_before
private boolean isRunningConfigurationNeeded() {
    if (getVm().isHostedEngine()) {
        // Hosted Engine never uses the next run configuration
        return false;
    }
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters()) || isClusterLevelChange();
}
#method_after
private boolean isRunningConfigurationNeeded() {
    if (getVm().isHostedEngine()) {
        // Hosted Engine never uses the next run configuration
        return false;
    }
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    // When updating, please also update UpdateClusterCommand#getExclusiveLocks
    if (!StringUtils.isBlank(getParameters().getVm().getName())) {
        return Collections.singletonMap(getParameters().getVm().getName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_NAME, EngineMessage.ACTION_TYPE_FAILED_VM_IS_BEING_UPDATED));
    }
    return null;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getName())) {
        return Collections.singletonMap(getParameters().getVm().getName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_NAME, EngineMessage.ACTION_TYPE_FAILED_VM_IS_BEING_UPDATED));
    }
    return null;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    // When updating, please also update UpdateClusterCommand#getSharedLocks
    return Collections.singletonMap(getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_VM_IS_BEING_UPDATED));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    return Collections.singletonMap(getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_VM_IS_BEING_UPDATED));
}
#end_block

#method_before
public boolean isVirtioScsiEnabledForVm(Guid vmId) {
    return getVmDeviceUtils().hasVirtioScsiController(vmId);
}
#method_after
public boolean isVirtioScsiEnabledForVm(Guid vmId) {
    return VmDeviceUtils.hasVirtioScsiController(vmId);
}
#end_block

#method_before
protected boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : getVmDeviceUtils().hasMemoryBalloon(getVmId());
}
#method_after
protected boolean isBalloonEnabled() {
    Boolean balloonEnabled = getParameters().isBalloonEnabled();
    return balloonEnabled != null ? balloonEnabled : VmDeviceUtils.hasMemoryBalloon(getVmId());
}
#end_block

#method_before
protected boolean isSoundDeviceEnabled() {
    Boolean soundDeviceEnabled = getParameters().isSoundDeviceEnabled();
    return soundDeviceEnabled != null ? soundDeviceEnabled : getVmDeviceUtils().hasSoundDevice(getVmId());
}
#method_after
protected boolean isSoundDeviceEnabled() {
    Boolean soundDeviceEnabled = getParameters().isSoundDeviceEnabled();
    return soundDeviceEnabled != null ? soundDeviceEnabled : VmDeviceUtils.hasSoundDevice(getVmId());
}
#end_block

#method_before
private void setDetailList(final StorageEventListModel storageEventListModel, final PermissionListModel<StorageDomain> permissionListModel) {
    generalModel.setIsAvailable(false);
    dcListModel.setIsAvailable(false);
    this.vmBackupModel.setIsAvailable(false);
    this.templateBackupModel.setIsAvailable(false);
    vmRegisterListModel.setIsAvailable(false);
    templateRegisterListModel.setIsAvailable(false);
    vmListModel.setIsAvailable(false);
    templateListModel.setIsAvailable(false);
    isoListModel.setIsAvailable(false);
    diskListModel.setIsAvailable(false);
    registerDiskListModel.setIsAvailable(false);
    snapshotListModel.setIsAvailable(false);
    this.diskProfileListModel.setIsAvailable(false);
    List<HasEntity<StorageDomain>> list = new ArrayList<>();
    list.add(generalModel);
    list.add(dcListModel);
    list.add(vmBackupModel);
    list.add(templateBackupModel);
    list.add(vmRegisterListModel);
    list.add(templateRegisterListModel);
    list.add(vmListModel);
    list.add(templateListModel);
    list.add(isoListModel);
    list.add(diskListModel);
    list.add(registerDiskListModel);
    list.add(snapshotListModel);
    list.add(this.diskProfileListModel);
    list.add(storageEventListModel);
    list.add(permissionListModel);
    setDetailModels(list);
}
#method_after
private void setDetailList(final StorageEventListModel storageEventListModel, final PermissionListModel<StorageDomain> permissionListModel) {
    generalModel.setIsAvailable(false);
    dcListModel.setIsAvailable(false);
    this.vmBackupModel.setIsAvailable(false);
    this.templateBackupModel.setIsAvailable(false);
    vmRegisterListModel.setIsAvailable(false);
    templateRegisterListModel.setIsAvailable(false);
    diskImageRegisterListModel.setIsAvailable(false);
    vmListModel.setIsAvailable(false);
    templateListModel.setIsAvailable(false);
    isoListModel.setIsAvailable(false);
    diskListModel.setIsAvailable(false);
    registerDiskListModel.setIsAvailable(false);
    snapshotListModel.setIsAvailable(false);
    this.diskProfileListModel.setIsAvailable(false);
    List<HasEntity<StorageDomain>> list = new ArrayList<>();
    list.add(generalModel);
    list.add(dcListModel);
    list.add(vmBackupModel);
    list.add(templateBackupModel);
    list.add(vmRegisterListModel);
    list.add(templateRegisterListModel);
    list.add(diskImageRegisterListModel);
    list.add(vmListModel);
    list.add(templateListModel);
    list.add(isoListModel);
    list.add(diskListModel);
    list.add(registerDiskListModel);
    list.add(snapshotListModel);
    list.add(this.diskProfileListModel);
    list.add(storageEventListModel);
    list.add(permissionListModel);
    setDetailModels(list);
}
#end_block

#method_before
public void storageNameValidation() {
    StorageModel model = (StorageModel) getWindow();
    String name = model.getName().getEntity();
    model.getName().setIsValid(true);
    AsyncDataProvider.getInstance().isStorageDomainNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageListModel storageListModel = (StorageListModel) target;
            StorageModel storageModel = (StorageModel) storageListModel.getWindow();
            String name1 = storageModel.getName().getEntity();
            String tempVar = storageModel.getOriginalName();
            // $NON-NLS-1$
            String originalName = (tempVar != null) ? tempVar : "";
            boolean isNameUnique = (Boolean) returnValue;
            if (!isNameUnique && name1.compareToIgnoreCase(originalName) != 0) {
                storageModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                storageModel.getName().setIsValid(false);
                storageListModel.postStorageNameValidation();
            } else {
                AsyncDataProvider.getInstance().getStorageDomainMaxNameLength(new AsyncQuery(storageListModel, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target1, Object returnValue1) {
                        StorageListModel storageListModel1 = (StorageListModel) target1;
                        StorageModel storageModel1 = (StorageModel) storageListModel1.getWindow();
                        int nameMaxLength = (Integer) returnValue1;
                        RegexValidation tempVar2 = new RegexValidation();
                        // $NON-NLS-1$ //$NON-NLS-2$
                        tempVar2.setExpression("^[A-Za-z0-9_-]{1," + nameMaxLength + "}$");
                        tempVar2.setMessage(ConstantsManager.getInstance().getMessages().nameCanContainOnlyMsg(nameMaxLength));
                        storageModel1.getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar2 });
                        storageListModel1.postStorageNameValidation();
                    }
                }));
            }
        }
    }), name);
}
#method_after
public void storageNameValidation() {
    StorageModel model = (StorageModel) getWindow();
    String name = model.getName().getEntity();
    model.getName().setIsValid(true);
    AsyncDataProvider.getInstance().isStorageDomainNameUnique(new AsyncQuery<>(new AsyncCallback<Boolean>() {

        @Override
        public void onSuccess(Boolean isNameUnique) {
            final StorageModel storageModel = (StorageModel) getWindow();
            String name1 = storageModel.getName().getEntity();
            String tempVar = storageModel.getOriginalName();
            // $NON-NLS-1$
            String originalName = (tempVar != null) ? tempVar : "";
            if (!isNameUnique && name1.compareToIgnoreCase(originalName) != 0) {
                storageModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                storageModel.getName().setIsValid(false);
                postStorageNameValidation();
            } else {
                AsyncDataProvider.getInstance().getStorageDomainMaxNameLength(new AsyncQuery<>(new AsyncCallback<Integer>() {

                    @Override
                    public void onSuccess(Integer nameMaxLength) {
                        RegexValidation tempVar2 = new RegexValidation();
                        // $NON-NLS-1$ //$NON-NLS-2$
                        tempVar2.setExpression("^[A-Za-z0-9_-]{1," + nameMaxLength + "}$");
                        tempVar2.setMessage(ConstantsManager.getInstance().getMessages().nameCanContainOnlyMsg(nameMaxLength));
                        storageModel.getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar2 });
                        postStorageNameValidation();
                    }
                }));
            }
        }
    }), name);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    model.setHelpTag(HelpTag.remove_storage);
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    StorageDomain storage = getSelectedItem();
    boolean localFsOnly = storage.getStorageType() == StorageType.LOCALFS;
    AsyncDataProvider.getInstance().getHostsForStorageOperation(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            List<VDS> hosts = (List<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrNull(hosts));
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = UICommand.createDefaultOkUiCommand("OnRemove", StorageListModel.this);
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), null, localFsOnly);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    final RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    model.setHelpTag(HelpTag.remove_storage);
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    StorageDomain storage = getSelectedItem();
    boolean localFsOnly = storage.getStorageType() == StorageType.LOCALFS;
    AsyncDataProvider.getInstance().getHostsForStorageOperation(new AsyncQuery<>(new AsyncCallback<List<VDS>>() {

        @Override
        public void onSuccess(List<VDS> hosts) {
            model.getHostList().setItems(hosts);
            model.getHostList().setSelectedItem(Linq.firstOrNull(hosts));
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                model.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = UICommand.createDefaultOkUiCommand("OnRemove", StorageListModel.this);
                model.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                model.getCommands().add(command);
            }
        }
    }), null, localFsOnly);
}
#end_block

#method_before
private void saveSanStorage() {
    StorageModel storageModel = (StorageModel) getWindow();
    final SanStorageModel sanStorageModel = (SanStorageModel) storageModel.getCurrentStorageItem();
    Map<LunStatus, List<LUNs>> lunsMapByStatus = sanStorageModel.getLunsMapByStatus(sanStorageModel.getAddedLuns());
    if (!lunsMapByStatus.get(LunStatus.Unknown).isEmpty()) {
        Guid hostId = sanStorageModel.getContainer().getHost().getSelectedItem().getId();
        Model target = getWidgetModel() != null ? getWidgetModel() : sanStorageModel.getContainer();
        List<String> unkownStatusLuns = new ArrayList<>();
        for (LUNs lun : lunsMapByStatus.get(LunStatus.Unknown)) {
            unkownStatusLuns.add(lun.getLUNId());
        }
        Frontend.getInstance().runQuery(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, sanStorageModel.getType(), true, unkownStatusLuns), new AsyncQuery(target, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
                if (response.getSucceeded()) {
                    List<LUNs> checkedLuns = (ArrayList<LUNs>) response.getReturnValue();
                    postGetLunsMessages(sanStorageModel.getUsedLunsMessages(checkedLuns));
                } else {
                    sanStorageModel.setGetLUNsFailure(ConstantsManager.getInstance().getConstants().couldNotRetrieveLUNsLunsFailure());
                }
            }
        }, true));
    } else {
        postGetLunsMessages(sanStorageModel.getUsedLunsMessages(lunsMapByStatus.get(LunStatus.Used)));
    }
}
#method_after
private void saveSanStorage() {
    StorageModel storageModel = (StorageModel) getWindow();
    final SanStorageModel sanStorageModel = (SanStorageModel) storageModel.getCurrentStorageItem();
    Guid hostId = sanStorageModel.getContainer().getHost().getSelectedItem().getId();
    if (sanStorageModel.getAddedLuns().isEmpty()) {
        onSaveSanStorage();
        return;
    }
    List<String> unkownStatusLuns = new ArrayList<>();
    for (LunModel lunModel : sanStorageModel.getAddedLuns()) {
        unkownStatusLuns.add(lunModel.getLunId());
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId, sanStorageModel.getType(), true, unkownStatusLuns), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue response) {
            if (response.getSucceeded()) {
                List<LUNs> checkedLuns = (ArrayList<LUNs>) response.getReturnValue();
                postGetLunsMessages(sanStorageModel.getUsedLunsMessages(checkedLuns));
            } else {
                sanStorageModel.setGetLUNsFailure(ConstantsManager.getInstance().getConstants().couldNotRetrieveLUNsLunsFailure());
            }
        }
    }, true));
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    if (getSelectedItem() != null) {
        StorageDomain storage = getSelectedItem();
        boolean isBackupStorage = storage.getStorageDomainType() == StorageDomainType.ImportExport;
        boolean isDataStorage = storage.getStorageDomainType().isDataDomain();
        boolean isImageStorage = storage.getStorageDomainType() == StorageDomainType.Image || storage.getStorageDomainType() == StorageDomainType.ISO;
        boolean isDataCenterAvailable = storage.getStorageType() != StorageType.GLANCE;
        boolean isGeneralAvailable = storage.getStorageType() != StorageType.GLANCE;
        boolean isCinderStorage = storage.getStorageType().isCinderDomain();
        boolean isRegsiterEntityListModelSelected = getActiveDetailModel() == vmRegisterListModel || getActiveDetailModel() == templateRegisterListModel;
        boolean isRegisterSubtabsAvailable = isDataStorage && (storage.isContainsUnregisteredEntities() || isRegsiterEntityListModelSelected);
        generalModel.setIsAvailable(isGeneralAvailable);
        dcListModel.setIsAvailable(isDataCenterAvailable);
        vmBackupModel.setIsAvailable(isBackupStorage);
        templateBackupModel.setIsAvailable(isBackupStorage);
        vmListModel.setIsAvailable(isDataStorage);
        templateListModel.setIsAvailable(isDataStorage);
        vmRegisterListModel.setIsAvailable(isRegisterSubtabsAvailable);
        templateRegisterListModel.setIsAvailable(isRegisterSubtabsAvailable);
        diskListModel.setIsAvailable(isDataStorage || isCinderStorage);
        registerDiskListModel.setIsAvailable(isCinderStorage);
        snapshotListModel.setIsAvailable(isDataStorage || isCinderStorage);
        diskProfileListModel.setIsAvailable(isDataStorage);
        isoListModel.setIsAvailable(isImageStorage);
    }
}
#method_after
@Override
protected void updateDetailsAvailability() {
    if (getSelectedItem() != null) {
        StorageDomain storage = getSelectedItem();
        boolean isBackupStorage = storage.getStorageDomainType() == StorageDomainType.ImportExport;
        boolean isDataStorage = storage.getStorageDomainType().isDataDomain();
        boolean isImageStorage = storage.getStorageDomainType() == StorageDomainType.Image || storage.getStorageDomainType() == StorageDomainType.ISO;
        boolean isDataCenterAvailable = storage.getStorageType() != StorageType.GLANCE;
        boolean isGeneralAvailable = storage.getStorageType() != StorageType.GLANCE;
        boolean isCinderStorage = storage.getStorageType().isCinderDomain();
        boolean isRegsiterEntityListModelSelected = getActiveDetailModel() == vmRegisterListModel || getActiveDetailModel() == templateRegisterListModel || getActiveDetailModel() == diskImageRegisterListModel;
        boolean isRegisterSubtabsAvailable = isDataStorage && storage.getStatus() != StorageDomainStatus.Unattached && (storage.isContainsUnregisteredEntities() || isRegsiterEntityListModelSelected);
        generalModel.setIsAvailable(isGeneralAvailable);
        dcListModel.setIsAvailable(isDataCenterAvailable);
        vmBackupModel.setIsAvailable(isBackupStorage);
        templateBackupModel.setIsAvailable(isBackupStorage);
        vmListModel.setIsAvailable(isDataStorage);
        templateListModel.setIsAvailable(isDataStorage);
        vmRegisterListModel.setIsAvailable(isRegisterSubtabsAvailable);
        templateRegisterListModel.setIsAvailable(isRegisterSubtabsAvailable);
        diskImageRegisterListModel.setIsAvailable(isRegisterSubtabsAvailable);
        diskListModel.setIsAvailable(isDataStorage || isCinderStorage);
        registerDiskListModel.setIsAvailable(isCinderStorage);
        snapshotListModel.setIsAvailable(isDataStorage || isCinderStorage);
        diskProfileListModel.setIsAvailable(isDataStorage);
        isoListModel.setIsAvailable(isImageStorage);
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<StorageDomain> items = getSelectedItems() != null ? Linq.<StorageDomain>cast(getSelectedItems()) : new ArrayList<StorageDomain>();
    StorageDomain item = getSelectedItem();
    getNewDomainCommand().setIsAvailable(true);
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && isEditAvailable(item));
    getRemoveCommand().setIsExecutionAllowed(items.size() == 1 && !items.get(0).getStorageType().isOpenStackDomain() && Linq.findAllStorageDomainsBySharedStatus(items, StorageDomainSharedStatus.Unattached).size() == items.size());
    getDestroyCommand().setIsExecutionAllowed(item != null && items.size() == 1 && !items.get(0).getStorageType().isOpenStackDomain() && item.getStatus() != StorageDomainStatus.Active);
    getUpdateOvfsCommand().setIsExecutionAllowed(item != null && items.size() == 1 && !items.get(0).getStorageType().isOpenStackDomain() && item.getStatus() == StorageDomainStatus.Active);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage);
    getNewDomainCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    getDestroyCommand().setIsAvailable(isAvailable);
    getUpdateOvfsCommand().setIsAvailable(isAvailable);
}
#method_after
private void updateActionAvailability() {
    ArrayList<StorageDomain> items = getSelectedItems() != null ? Linq.<StorageDomain>cast(getSelectedItems()) : new ArrayList<StorageDomain>();
    StorageDomain item = getSelectedItem();
    getNewDomainCommand().setIsAvailable(true);
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && isEditAvailable(item));
    getRemoveCommand().setIsExecutionAllowed(items.size() == 1 && !items.get(0).getStorageType().isOpenStackDomain() && Linq.findAllStorageDomainsBySharedStatus(items, StorageDomainSharedStatus.Unattached).size() == items.size());
    getDestroyCommand().setIsExecutionAllowed(item != null && items.size() == 1 && !items.get(0).getStorageType().isOpenStackDomain() && item.getStatus() != StorageDomainStatus.Active);
    getScanDisksCommand().setIsExecutionAllowed(item != null && items.size() == 1 && !items.get(0).getStorageType().isOpenStackDomain() && item.getStatus() == StorageDomainStatus.Active && item.getStorageDomainType().isDataDomain());
    getUpdateOvfsCommand().setIsExecutionAllowed(item != null && items.size() == 1 && item.getStorageDomainType().isDataDomain() && item.getStatus() == StorageDomainStatus.Active);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage);
    getNewDomainCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    getDestroyCommand().setIsAvailable(isAvailable);
    getScanDisksCommand().setIsAvailable(isAvailable);
    getUpdateOvfsCommand().setIsAvailable(isAvailable);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewDomainCommand()) {
        newDomain();
    } else if (command == getImportDomainCommand()) {
        importDomain();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getUpdateOvfsCommand()) {
        updateOvfs();
    } else if (command == getDestroyCommand()) {
        destroy();
    } else if ("OnSave".equals(command.getName())) {
        // $NON-NLS-1$
        onSave();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("CancelConfirm".equals(command.getName())) {
        // $NON-NLS-1$
        cancelConfirm();
    } else if ("CancelImportConfirm".equals(command.getName())) {
        // $NON-NLS-1$
        cancelImportConfirm();
    } else if ("OnImport".equals(command.getName())) {
        // $NON-NLS-1$
        onImport();
    } else if ("OnImportFile".equals(command.getName())) {
        // $NON-NLS-1$
        if (getConfirmWindow() != null && !((ConfirmationModel) getConfirmWindow()).validate()) {
            return;
        }
        cancelConfirm();
        getExistingStorageDomainList();
    } else if ("OnImportSan".equals(command.getName())) {
        // $NON-NLS-1$
        if (getConfirmWindow() != null && !((ConfirmationModel) getConfirmWindow()).validate()) {
            return;
        }
        cancelConfirm();
        onImportSanDomainApprove();
    } else if ("OnRemove".equals(command.getName())) {
        // $NON-NLS-1$
        onRemove();
    } else if ("OnDestroy".equals(command.getName())) {
        // $NON-NLS-1$
        onDestroy();
    } else if ("OnSaveSanStorage".equals(command.getName())) {
        // $NON-NLS-1$
        onSaveSanStorage();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewDomainCommand()) {
        newDomain();
    } else if (command == getImportDomainCommand()) {
        importDomain();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getUpdateOvfsCommand()) {
        updateOvfs();
    } else if (command == getDestroyCommand()) {
        destroy();
    } else if (command == getScanDisksCommand()) {
        scanDisks();
    } else if ("OnSave".equals(command.getName())) {
        // $NON-NLS-1$
        onSave();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("CancelConfirm".equals(command.getName())) {
        // $NON-NLS-1$
        cancelConfirm();
    } else if ("CancelImportConfirm".equals(command.getName())) {
        // $NON-NLS-1$
        cancelImportConfirm();
    } else if ("OnImport".equals(command.getName())) {
        // $NON-NLS-1$
        onImport();
    } else if ("OnImportFile".equals(command.getName())) {
        // $NON-NLS-1$
        if (getConfirmWindow() != null && !((ConfirmationModel) getConfirmWindow()).validate()) {
            return;
        }
        cancelConfirm();
        getExistingStorageDomainList();
    } else if ("OnImportSan".equals(command.getName())) {
        // $NON-NLS-1$
        if (getConfirmWindow() != null && !((ConfirmationModel) getConfirmWindow()).validate()) {
            return;
        }
        cancelConfirm();
        onImportSanDomainApprove();
    } else if ("OnRemove".equals(command.getName())) {
        // $NON-NLS-1$
        onRemove();
    } else if ("OnDestroy".equals(command.getName())) {
        // $NON-NLS-1$
        onDestroy();
    } else if ("OnSaveSanStorage".equals(command.getName())) {
        // $NON-NLS-1$
        onSaveSanStorage();
    }
}
#end_block

#method_before
private void savePosixStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
    path = posixModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewPosixStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#method_after
private void savePosixStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
    path = posixModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

            @Override
            public void onSuccess(List<StorageDomain> storages) {
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storages);
                } else {
                    saveNewPosixStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#end_block

#method_before
private void saveNfsStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
    path = nfsModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewNfsStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#method_after
private void saveNfsStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
    path = nfsModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

            @Override
            public void onSuccess(List<StorageDomain> storages) {
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storages);
                } else {
                    saveNewNfsStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#end_block

#method_before
private void saveLocalStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    VDS host = model.getHost().getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    LocalStorageModel localModel = (LocalStorageModel) storageModel;
    path = localModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewLocalStorage();
                }
            }
        }), host.getStoragePoolId(), path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#method_after
private void saveLocalStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    VDS host = model.getHost().getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    LocalStorageModel localModel = (LocalStorageModel) storageModel;
    path = localModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

            @Override
            public void onSuccess(List<StorageDomain> storages) {
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storages);
                } else {
                    saveNewLocalStorage();
                }
            }
        }), host.getStoragePoolId(), path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#end_block

#method_before
private void handleDomainAlreadyExists(StorageListModel storageListModel, ArrayList<StorageDomain> storages) {
    String storageName = storages.get(0).getStorageName();
    onFinish(storageListModel.context, false, storageListModel.storageModel, ConstantsManager.getInstance().getMessages().createFailedDomainAlreadyExistStorageMsg(storageName));
}
#method_after
private void handleDomainAlreadyExists(List<StorageDomain> storages) {
    String storageName = storages.get(0).getStorageName();
    onFinish(context, false, storageModel, ConstantsManager.getInstance().getMessages().createFailedDomainAlreadyExistStorageMsg(storageName));
}
#end_block

#method_before
public void importFileStoragePostInit() {
    Guid storagePoolId = null;
    StoragePool dataCenter = storageModel.getContainer().getDataCenter().getSelectedItem();
    if (dataCenter != null && !dataCenter.getId().equals(Guid.Empty)) {
        storagePoolId = dataCenter.getId();
    }
    // Check storage domain existence
    AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageListModel storageListModel = (StorageListModel) target;
            ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
            if (storages != null && storages.size() > 0) {
                String storageName = storages.get(0).getStorageName();
                onFinish(storageListModel.context, false, storageListModel.storageModel, ConstantsManager.getInstance().getMessages().importFailedDomainAlreadyExistStorageMsg(storageName));
            } else {
                StorageServerConnections tempVar = new StorageServerConnections();
                storageModel = storageListModel.storageModel;
                tempVar.setConnection(storageListModel.path);
                tempVar.setStorageType(storageListModel.storageType);
                if (storageModel instanceof NfsStorageModel) {
                    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
                    if (isConnectionOverriden()) {
                        tempVar.setNfsVersion((NfsVersion) ((EntityModel) nfsModel.getVersion().getSelectedItem()).getEntity());
                        tempVar.setNfsRetrans(nfsModel.getRetransmissions().asConvertible().nullableShort());
                        tempVar.setNfsTimeo(nfsModel.getTimeout().asConvertible().nullableShort());
                    }
                }
                if (storageModel instanceof PosixStorageModel) {
                    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
                    tempVar.setVfsType(posixModel.getVfsType().getEntity());
                    tempVar.setMountOptions(posixModel.getMountOptions().getEntity());
                }
                storageListModel.fileConnection = tempVar;
                importFileStorageConnect();
            }
        }
    }), storagePoolId, path);
}
#method_after
public void importFileStoragePostInit() {
    Guid storagePoolId = null;
    StoragePool dataCenter = storageModel.getContainer().getDataCenter().getSelectedItem();
    if (dataCenter != null && !dataCenter.getId().equals(Guid.Empty)) {
        storagePoolId = dataCenter.getId();
    }
    // Check storage domain existence
    AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

        @Override
        public void onSuccess(List<StorageDomain> storages) {
            if (storages != null && storages.size() > 0) {
                String storageName = storages.get(0).getStorageName();
                onFinish(context, false, storageModel, ConstantsManager.getInstance().getMessages().importFailedDomainAlreadyExistStorageMsg(storageName));
            } else {
                StorageServerConnections tempVar = new StorageServerConnections();
                tempVar.setConnection(path);
                tempVar.setStorageType(storageType);
                if (storageModel instanceof NfsStorageModel) {
                    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
                    if (isConnectionOverriden()) {
                        tempVar.setNfsVersion((NfsVersion) ((EntityModel) nfsModel.getVersion().getSelectedItem()).getEntity());
                        tempVar.setNfsRetrans(nfsModel.getRetransmissions().asConvertible().nullableShort());
                        tempVar.setNfsTimeo(nfsModel.getTimeout().asConvertible().nullableShort());
                    }
                }
                if (storageModel instanceof PosixStorageModel) {
                    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
                    tempVar.setVfsType(posixModel.getVfsType().getEntity());
                    tempVar.setMountOptions(posixModel.getMountOptions().getEntity());
                }
                fileConnection = tempVar;
                importFileStorageConnect();
            }
        }
    }), storagePoolId, path);
}
#end_block

#method_before
private void getExistingStorageDomainList() {
    AsyncDataProvider.getInstance().getExistingStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageListModel storageListModel = (StorageListModel) target;
            ArrayList<StorageDomain> domains = (ArrayList<StorageDomain>) returnValue;
            if (domains != null && !domains.isEmpty()) {
                storageListModel.storageDomainsToAdd = domains;
                addExistingFileStorageDomain();
            } else {
                String errorMessage = domains == null ? ConstantsManager.getInstance().getConstants().failedToRetrieveExistingStorageDomainInformationMsg() : ConstantsManager.getInstance().getConstants().thereIsNoStorageDomainUnderTheSpecifiedPathMsg();
                postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, errorMessage);
                storageListModel.cleanConnection(storageListModel.fileConnection, storageListModel.hostId);
            }
        }
    }), hostId, domainType, storageType, path);
}
#method_after
private void getExistingStorageDomainList() {
    AsyncDataProvider.getInstance().getExistingStorageDomainList(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

        @Override
        public void onSuccess(List<StorageDomain> domains) {
            if (domains != null && !domains.isEmpty()) {
                storageDomainsToAdd = domains;
                addExistingFileStorageDomain();
            } else {
                String errorMessage = domains == null ? ConstantsManager.getInstance().getConstants().failedToRetrieveExistingStorageDomainInformationMsg() : ConstantsManager.getInstance().getConstants().thereIsNoStorageDomainUnderTheSpecifiedPathMsg();
                postImportFileStorage(context, false, storageModel, errorMessage);
                cleanConnection(fileConnection, hostId);
            }
        }
    }), hostId, domainType, storageType, path);
}
#end_block

#method_before
private void checkDomainAttachedToDc(String commandName, List<StorageDomain> storageDomains, StorageServerConnections storageServerConnections) {
    final StorageModel storageModel = (StorageModel) getWindow();
    StoragePool storagePool = storageModel.getDataCenter().getSelectedItem();
    final UICommand okCommand = UICommand.createDefaultOkUiCommand(commandName, this);
    if (storagePool.getId().equals(Guid.Empty)) {
        okCommand.execute();
        return;
    }
    VDS host = storageModel.getHost().getSelectedItem();
    AsyncDataProvider.getInstance().getStorageDomainsWithAttachedStoragePoolGuid(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<StorageDomainStatic> attachedStorageDomains = (List<StorageDomainStatic>) returnValue;
            if (!attachedStorageDomains.isEmpty()) {
                ConfirmationModel model = new ConfirmationModel();
                setConfirmWindow(model);
                model.setTitle(ConstantsManager.getInstance().getConstants().storageDomainsAttachedToDataCenterWarningTitle());
                model.setMessage(ConstantsManager.getInstance().getConstants().storageDomainsAttachedToDataCenterWarningMessage());
                model.setHelpTag(HelpTag.import_storage_domain_confirmation);
                // $NON-NLS-1$
                model.setHashName("import_storage_domain_confirmation");
                List<String> stoageDomainNames = new ArrayList<>();
                for (StorageDomainStatic domain : attachedStorageDomains) {
                    stoageDomainNames.add(domain.getStorageName());
                }
                model.setItems(stoageDomainNames);
                // $NON-NLS-1$
                UICommand cancelCommand = createCancelCommand("CancelImportConfirm");
                model.getCommands().add(okCommand);
                model.getCommands().add(cancelCommand);
            } else {
                okCommand.execute();
            }
        }
    }), storagePool, storageDomains, storageServerConnections, host.getId());
}
#method_after
private void checkDomainAttachedToDc(String commandName, List<StorageDomain> storageDomains, StorageServerConnections storageServerConnections) {
    final StorageModel storageModel = (StorageModel) getWindow();
    StoragePool storagePool = storageModel.getDataCenter().getSelectedItem();
    final UICommand okCommand = UICommand.createDefaultOkUiCommand(commandName, this);
    if (storagePool.getId().equals(Guid.Empty)) {
        okCommand.execute();
        return;
    }
    VDS host = storageModel.getHost().getSelectedItem();
    AsyncDataProvider.getInstance().getStorageDomainsWithAttachedStoragePoolGuid(new AsyncQuery<>(new AsyncCallback<List<StorageDomainStatic>>() {

        @Override
        public void onSuccess(List<StorageDomainStatic> attachedStorageDomains) {
            if (!attachedStorageDomains.isEmpty()) {
                ConfirmationModel model = new ConfirmationModel();
                setConfirmWindow(model);
                model.setTitle(ConstantsManager.getInstance().getConstants().storageDomainsAttachedToDataCenterWarningTitle());
                model.setMessage(ConstantsManager.getInstance().getConstants().storageDomainsAttachedToDataCenterWarningMessage());
                model.setHelpTag(HelpTag.import_storage_domain_confirmation);
                // $NON-NLS-1$
                model.setHashName("import_storage_domain_confirmation");
                List<String> stoageDomainNames = new ArrayList<>();
                for (StorageDomainStatic domain : attachedStorageDomains) {
                    stoageDomainNames.add(domain.getStorageName());
                }
                model.setItems(stoageDomainNames);
                // $NON-NLS-1$
                UICommand cancelCommand = createCancelCommand("CancelImportConfirm");
                model.getCommands().add(okCommand);
                model.getCommands().add(cancelCommand);
            } else {
                okCommand.execute();
            }
        }
    }), storagePool, storageDomains, storageServerConnections, host.getId());
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    StorageDomainSharedStatusColumn sharedStatusColumn = new StorageDomainSharedStatusColumn();
    sharedStatusColumn.setContextMenuTitle(constants.sharedStatusStorage());
    // $NON-NLS-1$
    getTable().addColumn(sharedStatusColumn, constants.empty(), "30px");
    StorageDomainAdditionalStatusColumn additionalStatusColumn = new StorageDomainAdditionalStatusColumn();
    additionalStatusColumn.setContextMenuTitle(constants.additionalStatusStorage());
    // $NON-NLS-1$
    getTable().addColumn(additionalStatusColumn, constants.empty(), "30px");
    AbstractTextColumn<StorageDomain> nameColumn = new AbstractTextColumn<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            return object.getStorageName();
        }
    };
    nameColumn.makeSortable(StorageDomainFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.domainNameStorage(), "150px");
    CommentColumn<StorageDomain> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<StorageDomain> domainTypeColumn = new AbstractEnumColumn<StorageDomain, StorageDomainType>() {

        @Override
        protected StorageDomainType getRawValue(StorageDomain object) {
            return object.getStorageDomainType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(domainTypeColumn, constants.domainTypeStorage(), "150px");
    AbstractTextColumn<StorageDomain> storageTypeColumn = new AbstractEnumColumn<StorageDomain, StorageType>() {

        @Override
        protected StorageType getRawValue(StorageDomain object) {
            return object.getStorageType();
        }
    };
    storageTypeColumn.makeSortable(StorageDomainFieldAutoCompleter.TYPE);
    // $NON-NLS-1$
    getTable().addColumn(storageTypeColumn, constants.storageTypeStorage(), "150px");
    AbstractTextColumn<StorageDomain> formatColumn = new AbstractEnumColumn<StorageDomain, StorageFormatType>() {

        @Override
        protected StorageFormatType getRawValue(StorageDomain object) {
            return object.getStorageFormat();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(formatColumn, constants.formatStorage(), "140px");
    AbstractTextColumn<StorageDomain> crossDataCenterStatusColumn = new AbstractTextColumn<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            if (object.getStorageDomainType() == StorageDomainType.ISO) {
                return EnumTranslator.getInstance().translate(object.getStorageDomainSharedStatus());
            } else {
                return EnumTranslator.getInstance().translate(object.getStatus());
            }
        }
    };
    crossDataCenterStatusColumn.makeSortable(StorageDomainFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(crossDataCenterStatusColumn, constants.crossDcStatusStorage(), "210px");
    AbstractStorageSizeColumn<StorageDomain> totalSpaceColumn = new AbstractStorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            Integer totalSpace = object.getTotalDiskSize();
            return totalSpace == null ? null : Long.valueOf(totalSpace);
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(totalSpaceColumn, constants.totalSpaceStorage(), "130px");
    AbstractStorageSizeColumn<StorageDomain> freeSpaceColumn = new AbstractStorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            Integer availableDiskSize = object.getAvailableDiskSize();
            return availableDiskSize == null ? null : Long.valueOf(availableDiskSize);
        }
    };
    freeSpaceColumn.makeSortable(StorageDomainFieldAutoCompleter.SIZE);
    // $NON-NLS-1$
    getTable().addColumn(freeSpaceColumn, constants.freeSpaceStorage(), "130px");
    AbstractTextColumn<StorageDomain> descriptionColumn = new AbstractTextColumn<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(StorageDomainFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.domainDescriptionStorage(), "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.newDomainStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewDomainCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.importDomainStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getImportDomainCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.editStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.removeStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.updateOvfsForStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getUpdateOvfsCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.destroyStorage(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getDestroyCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        updateReportsAvailability();
    } else {
        getMainModel().getReportsAvailabilityEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                updateReportsAvailability();
            }
        });
    }
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    StorageDomainSharedStatusColumn sharedStatusColumn = new StorageDomainSharedStatusColumn();
    sharedStatusColumn.setContextMenuTitle(constants.sharedStatusStorage());
    // $NON-NLS-1$
    getTable().addColumn(sharedStatusColumn, constants.empty(), "30px");
    StorageDomainAdditionalStatusColumn additionalStatusColumn = new StorageDomainAdditionalStatusColumn();
    additionalStatusColumn.setContextMenuTitle(constants.additionalStatusStorage());
    // $NON-NLS-1$
    getTable().addColumn(additionalStatusColumn, constants.empty(), "30px");
    AbstractTextColumn<StorageDomain> nameColumn = new AbstractTextColumn<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            return object.getStorageName();
        }
    };
    nameColumn.makeSortable(StorageDomainFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.domainNameStorage(), "150px");
    CommentColumn<StorageDomain> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<StorageDomain> domainTypeColumn = new AbstractEnumColumn<StorageDomain, StorageDomainType>() {

        @Override
        protected StorageDomainType getRawValue(StorageDomain object) {
            return object.getStorageDomainType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(domainTypeColumn, constants.domainTypeStorage(), "150px");
    AbstractTextColumn<StorageDomain> storageTypeColumn = new AbstractEnumColumn<StorageDomain, StorageType>() {

        @Override
        protected StorageType getRawValue(StorageDomain object) {
            return object.getStorageType();
        }
    };
    storageTypeColumn.makeSortable(StorageDomainFieldAutoCompleter.TYPE);
    // $NON-NLS-1$
    getTable().addColumn(storageTypeColumn, constants.storageTypeStorage(), "150px");
    AbstractTextColumn<StorageDomain> formatColumn = new AbstractEnumColumn<StorageDomain, StorageFormatType>() {

        @Override
        protected StorageFormatType getRawValue(StorageDomain object) {
            return object.getStorageFormat();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(formatColumn, constants.formatStorage(), "140px");
    AbstractTextColumn<StorageDomain> crossDataCenterStatusColumn = new AbstractTextColumn<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            if (object.getStorageDomainType() == StorageDomainType.ISO) {
                return EnumTranslator.getInstance().translate(object.getStorageDomainSharedStatus());
            } else {
                return EnumTranslator.getInstance().translate(object.getStatus());
            }
        }
    };
    crossDataCenterStatusColumn.makeSortable(StorageDomainFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(crossDataCenterStatusColumn, constants.crossDcStatusStorage(), "210px");
    AbstractStorageSizeColumn<StorageDomain> totalSpaceColumn = new AbstractStorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            Integer totalSpace = object.getTotalDiskSize();
            return totalSpace == null ? null : Long.valueOf(totalSpace);
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(totalSpaceColumn, constants.totalSpaceStorage(), "130px");
    AbstractStorageSizeColumn<StorageDomain> freeSpaceColumn = new AbstractStorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            Integer availableDiskSize = object.getAvailableDiskSize();
            return availableDiskSize == null ? null : Long.valueOf(availableDiskSize);
        }
    };
    freeSpaceColumn.makeSortable(StorageDomainFieldAutoCompleter.SIZE);
    // $NON-NLS-1$
    getTable().addColumn(freeSpaceColumn, constants.freeSpaceStorage(), "130px");
    AbstractTextColumn<StorageDomain> descriptionColumn = new AbstractTextColumn<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(StorageDomainFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.domainDescriptionStorage(), "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.newDomainStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewDomainCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.importDomainStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getImportDomainCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.editStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.removeStorage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.updateOvfsForStorage(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getUpdateOvfsCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.destroyStorage(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getDestroyCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomain>(constants.scanDisksStorage(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getScanDisksCommand();
        }
    });
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!getParameters().isSkipDomainChecks()) {
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomain());
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!getParameters().isSkipDomainChecks()) {
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomain());
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(storageDomainValidator.isDataDomain());
    }
    return true;
}
#end_block

#method_before
private boolean performOvfUpdateForDomain(byte[] ovfData, StorageDomainOvfInfo storageDomainOvfInfo, DiskImage ovfDisk, List<Guid> vmAndTemplatesIds) {
    Guid storagePoolId = ovfDisk.getStoragePoolId();
    Guid storageDomainId = ovfDisk.getStorageIds().get(0);
    Guid diskId = ovfDisk.getId();
    Guid volumeId = ovfDisk.getImageId();
    storageDomainOvfInfo.setStoredOvfIds(null);
    try {
        setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, generateOvfStoreDescription(storageDomainOvfInfo.getLastUpdated(), false, null));
        getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(ovfData);
        Long size = Long.valueOf(ovfData.length);
        UploadStreamParameters uploadStreamParameters = new UploadStreamParameters(storagePoolId, storageDomainId, diskId, volumeId, byteArrayInputStream, size);
        uploadStreamParameters.setParentCommand(getActionType());
        uploadStreamParameters.setParentParameters(getParameters());
        uploadStreamParameters.setShouldBeEndedByParent(false);
        VdcReturnValueBase vdcReturnValueBase = runInternalActionWithTasksContext(VdcActionType.UploadStream, uploadStreamParameters);
        if (vdcReturnValueBase.getSucceeded()) {
            storageDomainOvfInfo.setStatus(StorageDomainOvfInfoStatus.UPDATED);
            storageDomainOvfInfo.setStoredOvfIds(vmAndTemplatesIds);
            storageDomainOvfInfo.setLastUpdated(updateDate);
            setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, getPostUpdateOvfStoreDescription(size));
            getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
            return true;
        }
    } catch (EngineException e) {
        log.warn("failed to update domain '{}' ovf store disk '{}'", storageDomainId, diskId);
    }
    failedOvfDisks.add(diskId);
    return false;
}
#method_after
private boolean performOvfUpdateForDomain(byte[] ovfData, StorageDomainOvfInfo storageDomainOvfInfo, DiskImage ovfDisk, List<Guid> vmAndTemplatesIds) {
    Guid storagePoolId = ovfDisk.getStoragePoolId();
    Guid storageDomainId = ovfDisk.getStorageIds().get(0);
    Guid diskId = ovfDisk.getId();
    Guid volumeId = ovfDisk.getImageId();
    storageDomainOvfInfo.setStoredOvfIds(null);
    try {
        setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, generateOvfStoreDescription(storageDomainOvfInfo.getLastUpdated(), false, null));
        getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(ovfData);
        Long size = Long.valueOf(ovfData.length);
        UploadStreamParameters uploadStreamParameters = new UploadStreamParameters(storagePoolId, storageDomainId, diskId, volumeId, byteArrayInputStream, size);
        uploadStreamParameters.setParentCommand(getActionType());
        uploadStreamParameters.setParentParameters(getParameters());
        uploadStreamParameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
        VdcReturnValueBase vdcReturnValueBase = runInternalActionWithTasksContext(VdcActionType.UploadStream, uploadStreamParameters);
        if (vdcReturnValueBase.getSucceeded()) {
            storageDomainOvfInfo.setStatus(StorageDomainOvfInfoStatus.UPDATED);
            storageDomainOvfInfo.setStoredOvfIds(vmAndTemplatesIds);
            storageDomainOvfInfo.setLastUpdated(updateDate);
            setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, getPostUpdateOvfStoreDescription(size));
            getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
            return true;
        }
    } catch (EngineException e) {
        log.warn("failed to update domain '{}' ovf store disk '{}'", storageDomainId, diskId);
    }
    failedOvfDisks.add(diskId);
    return false;
}
#end_block

#method_before
public CreateOvfVolumeForStorageDomainCommandParameters createCreateOvfVolumeForStorageDomainParams() {
    CreateOvfVolumeForStorageDomainCommandParameters parameters = new CreateOvfVolumeForStorageDomainCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId());
    parameters.setSkipDomainChecks(getParameters().isSkipDomainChecks());
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setShouldBeEndedByParent(false);
    return parameters;
}
#method_after
public CreateOvfVolumeForStorageDomainCommandParameters createCreateOvfVolumeForStorageDomainParams() {
    CreateOvfVolumeForStorageDomainCommandParameters parameters = new CreateOvfVolumeForStorageDomainCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId());
    parameters.setSkipDomainChecks(getParameters().isSkipDomainChecks());
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return parameters;
}
#end_block

#method_before
@Override
public StorageDomain update(StorageDomain incoming) {
    validateEnums(StorageDomain.class, incoming);
    QueryIdResolver<Guid> storageDomainResolver = new QueryIdResolver<>(VdcQueryType.GetStorageDomainById, IdQueryParameters.class);
    org.ovirt.engine.core.common.businessentities.StorageDomain entity = getEntity(storageDomainResolver, true);
    StorageDomain model = map(entity, new StorageDomain());
    StorageType storageType = entity.getStorageType();
    if (storageType != null) {
        switch(storageType) {
            case ISCSI:
            case FCP:
                extendStorageDomain(incoming, model, storageType);
                break;
            default:
                break;
        }
    }
    return addLinks(performUpdate(incoming, entity, model, storageDomainResolver, VdcActionType.UpdateStorageDomain, new UpdateParametersProvider()), new String[] { "templates", "vms" });
}
#method_after
@Override
public StorageDomain update(StorageDomain incoming) {
    QueryIdResolver<Guid> storageDomainResolver = new QueryIdResolver<>(VdcQueryType.GetStorageDomainById, IdQueryParameters.class);
    org.ovirt.engine.core.common.businessentities.StorageDomain entity = getEntity(storageDomainResolver, true);
    StorageDomain model = map(entity, new StorageDomain());
    StorageType storageType = entity.getStorageType();
    if (storageType != null) {
        switch(storageType) {
            case ISCSI:
            case FCP:
                extendStorageDomain(incoming, model, storageType);
                break;
            default:
                break;
        }
    }
    return addLinks(performUpdate(incoming, entity, model, storageDomainResolver, VdcActionType.UpdateStorageDomain, new UpdateParametersProvider()), new String[] { "templates", "vms" });
}
#end_block

#method_before
@Override
public Response remove() {
    String host = QueryHelper.getMatrixConstraint(uriInfo, HOST);
    if (host == null) {
        Fault fault = new Fault();
        fault.setReason("host parameter is missing");
        throw new WebApplicationException(Response.status(Status.BAD_REQUEST).entity(fault).build());
    }
    get();
    Guid hostId = getHostId(host);
    boolean destroy = QueryHelper.getBooleanMatrixParameter(uriInfo, DESTROY, true, false);
    boolean format = QueryHelper.getBooleanMatrixParameter(uriInfo, FORMAT, true, false);
    if (destroy) {
        StorageDomainParametersBase parameters = new StorageDomainParametersBase(guid);
        parameters.setVdsId(hostId);
        return performAction(VdcActionType.ForceRemoveStorageDomain, parameters);
    } else {
        RemoveStorageDomainParameters parameters = new RemoveStorageDomainParameters(guid);
        parameters.setVdsId(hostId);
        parameters.setDoFormat(format);
        return performAction(VdcActionType.RemoveStorageDomain, parameters);
    }
}
#method_after
@Override
public Response remove() {
    String host = ParametersHelper.getParameter(httpHeaders, uriInfo, HOST);
    if (host == null) {
        Fault fault = new Fault();
        fault.setReason("host parameter is missing");
        throw new WebApplicationException(Response.status(Status.BAD_REQUEST).entity(fault).build());
    }
    get();
    Guid hostId = getHostId(host);
    boolean destroy = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, DESTROY, true, false);
    boolean format = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, FORMAT, true, false);
    if (destroy) {
        StorageDomainParametersBase parameters = new StorageDomainParametersBase(guid);
        parameters.setVdsId(hostId);
        return performAction(VdcActionType.ForceRemoveStorageDomain, parameters);
    } else {
        RemoveStorageDomainParameters parameters = new RemoveStorageDomainParameters(guid);
        parameters.setVdsId(hostId);
        parameters.setDoFormat(format);
        return performAction(VdcActionType.RemoveStorageDomain, parameters);
    }
}
#end_block

#method_before
@Override
public Response isAttached(Action action) {
    validateParameters(action, "host.id|name");
    Guid hostId = getHostId(action);
    org.ovirt.engine.core.common.businessentities.StorageDomain storageDomainToAttach = getEntity(org.ovirt.engine.core.common.businessentities.StorageDomain.class, VdcQueryType.GetStorageDomainById, new IdQueryParameters(guid), guid.toString());
    StorageDomainsAndStoragePoolIdQueryParameters parameters = new StorageDomainsAndStoragePoolIdQueryParameters(storageDomainToAttach, null, hostId);
    parameters.setCheckStoragePoolStatus(false);
    List<StorageDomainStatic> attachedStorageDomains = getEntity(List.class, VdcQueryType.GetStorageDomainsWithAttachedStoragePoolGuid, parameters, guid.toString(), true);
    // This is an atypical action, as it doesn't invoke a backend action, but a query. As a result we need to
    // create and populate the returned action object so that it looks like a real action result.
    Action result = new Action();
    result.setIsAttached(!attachedStorageDomains.isEmpty());
    result.setStatus(StatusUtils.create(CreationStatus.COMPLETE));
    return Response.ok().entity(result).build();
}
#method_after
@Override
public Response isAttached(Action action) {
    validateParameters(action, "host.id|name");
    Guid hostId = getHostId(action);
    org.ovirt.engine.core.common.businessentities.StorageDomain storageDomainToAttach = getEntity(org.ovirt.engine.core.common.businessentities.StorageDomain.class, VdcQueryType.GetStorageDomainById, new IdQueryParameters(guid), guid.toString());
    StorageDomainsAndStoragePoolIdQueryParameters parameters = new StorageDomainsAndStoragePoolIdQueryParameters(storageDomainToAttach, null, hostId);
    parameters.setCheckStoragePoolStatus(false);
    List<StorageDomainStatic> attachedStorageDomains = getEntity(List.class, VdcQueryType.GetStorageDomainsWithAttachedStoragePoolGuid, parameters, guid.toString(), true);
    // This is an atypical action, as it doesn't invoke a backend action, but a query. As a result we need to
    // create and populate the returned action object so that it looks like a real action result.
    Action result = new Action();
    result.setIsAttached(!attachedStorageDomains.isEmpty());
    result.setStatus(CreationStatus.COMPLETE.value());
    return Response.ok().entity(result).build();
}
#end_block

#method_before
public static synchronized boolean isIsoDomain(StorageDomain storageDomain) {
    StorageDomainType type = StorageDomainType.fromValue(storageDomain.getType());
    return type != null && type == StorageDomainType.ISO ? true : false;
}
#method_after
public static synchronized boolean isIsoDomain(StorageDomain storageDomain) {
    StorageDomainType type = storageDomain.getType();
    return type != null && type == StorageDomainType.ISO ? true : false;
}
#end_block

#method_before
public static synchronized boolean isExportDomain(StorageDomain storageDomain) {
    StorageDomainType type = StorageDomainType.fromValue(storageDomain.getType());
    return type != null && type == StorageDomainType.EXPORT ? true : false;
}
#method_after
public static synchronized boolean isExportDomain(StorageDomain storageDomain) {
    StorageDomainType type = storageDomain.getType();
    return type != null && type == StorageDomainType.EXPORT ? true : false;
}
#end_block

#method_before
public static synchronized boolean isImageDomain(StorageDomain storageDomain) {
    StorageDomainType type = StorageDomainType.fromValue(storageDomain.getType());
    return type != null && type == StorageDomainType.IMAGE;
}
#method_after
public static synchronized boolean isImageDomain(StorageDomain storageDomain) {
    StorageDomainType type = storageDomain.getType();
    return type != null && type == StorageDomainType.IMAGE;
}
#end_block

#method_before
@Override
protected StorageDomain deprecatedPopulate(StorageDomain model, org.ovirt.engine.core.common.businessentities.StorageDomain entity) {
    if (StorageDomainSharedStatus.Unattached.equals(entity.getStorageDomainSharedStatus())) {
        model.setStatus(StatusUtils.create(StorageDomainStatus.UNATTACHED));
    } else {
        model.setStatus(null);
    }
    return super.deprecatedPopulate(model, entity);
}
#method_after
@Override
protected StorageDomain deprecatedPopulate(StorageDomain model, org.ovirt.engine.core.common.businessentities.StorageDomain entity) {
    if (StorageDomainSharedStatus.Unattached.equals(entity.getStorageDomainSharedStatus())) {
        model.setStatus(StorageDomainStatus.UNATTACHED);
    } else {
        model.setStatus(null);
    }
    return super.deprecatedPopulate(model, entity);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!getParameters().isSkipDomainChecks()) {
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomain());
        if (!validate(storageDomainValidator.isDomainExistAndActive()) || !validate(storageDomainValidator.isDataDomain())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!getParameters().isSkipDomainChecks()) {
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomain());
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(storageDomainValidator.isDataDomain());
    }
    return true;
}
#end_block

#method_before
private boolean performOvfUpdateForDomain(byte[] ovfData, StorageDomainOvfInfo storageDomainOvfInfo, DiskImage ovfDisk, List<Guid> vmAndTemplatesIds) {
    Guid storagePoolId = ovfDisk.getStoragePoolId();
    Guid storageDomainId = ovfDisk.getStorageIds().get(0);
    Guid diskId = ovfDisk.getId();
    Guid volumeId = ovfDisk.getImageId();
    storageDomainOvfInfo.setStoredOvfIds(null);
    try {
        setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, generateOvfStoreDescription(storageDomainOvfInfo.getLastUpdated(), false, null));
        getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(ovfData);
        Long size = Long.valueOf(ovfData.length);
        UploadStreamParameters uploadStreamParameters = new UploadStreamParameters(storagePoolId, storageDomainId, diskId, volumeId, byteArrayInputStream, size);
        uploadStreamParameters.setParentCommand(getActionType());
        uploadStreamParameters.setParentParameters(getParameters());
        uploadStreamParameters.setShouldBeEndedByParent(false);
        VdcReturnValueBase vdcReturnValueBase = runInternalActionWithTasksContext(VdcActionType.UploadStream, uploadStreamParameters);
        if (vdcReturnValueBase.getSucceeded()) {
            storageDomainOvfInfo.setStatus(StorageDomainOvfInfoStatus.UPDATED);
            storageDomainOvfInfo.setStoredOvfIds(vmAndTemplatesIds);
            storageDomainOvfInfo.setLastUpdated(updateDate);
            setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, getPostUpdateOvfStoreDescription(size));
            getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
            return true;
        }
    } catch (EngineException e) {
        log.warn("failed to update domain '{}' ovf store disk '{}'", storageDomainId, diskId);
    }
    failedOvfDisks.add(diskId);
    return false;
}
#method_after
private boolean performOvfUpdateForDomain(byte[] ovfData, StorageDomainOvfInfo storageDomainOvfInfo, DiskImage ovfDisk, List<Guid> vmAndTemplatesIds) {
    Guid storagePoolId = ovfDisk.getStoragePoolId();
    Guid storageDomainId = ovfDisk.getStorageIds().get(0);
    Guid diskId = ovfDisk.getId();
    Guid volumeId = ovfDisk.getImageId();
    storageDomainOvfInfo.setStoredOvfIds(null);
    try {
        setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, generateOvfStoreDescription(storageDomainOvfInfo.getLastUpdated(), false, null));
        getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(ovfData);
        Long size = Long.valueOf(ovfData.length);
        UploadStreamParameters uploadStreamParameters = new UploadStreamParameters(storagePoolId, storageDomainId, diskId, volumeId, byteArrayInputStream, size);
        uploadStreamParameters.setParentCommand(getActionType());
        uploadStreamParameters.setParentParameters(getParameters());
        uploadStreamParameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
        VdcReturnValueBase vdcReturnValueBase = runInternalActionWithTasksContext(VdcActionType.UploadStream, uploadStreamParameters);
        if (vdcReturnValueBase.getSucceeded()) {
            storageDomainOvfInfo.setStatus(StorageDomainOvfInfoStatus.UPDATED);
            storageDomainOvfInfo.setStoredOvfIds(vmAndTemplatesIds);
            storageDomainOvfInfo.setLastUpdated(updateDate);
            setOvfVolumeDescription(storagePoolId, storageDomainId, diskId, volumeId, getPostUpdateOvfStoreDescription(size));
            getStorageDomainOvfInfoDao().update(storageDomainOvfInfo);
            return true;
        }
    } catch (EngineException e) {
        log.warn("failed to update domain '{}' ovf store disk '{}'", storageDomainId, diskId);
    }
    failedOvfDisks.add(diskId);
    return false;
}
#end_block

#method_before
public CreateOvfVolumeForStorageDomainCommandParameters createCreateOvfVolumeForStorageDomainParams() {
    CreateOvfVolumeForStorageDomainCommandParameters parameters = new CreateOvfVolumeForStorageDomainCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId());
    parameters.setSkipDomainChecks(getParameters().isSkipDomainChecks());
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setShouldBeEndedByParent(false);
    return parameters;
}
#method_after
public CreateOvfVolumeForStorageDomainCommandParameters createCreateOvfVolumeForStorageDomainParams() {
    CreateOvfVolumeForStorageDomainCommandParameters parameters = new CreateOvfVolumeForStorageDomainCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId());
    parameters.setSkipDomainChecks(getParameters().isSkipDomainChecks());
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return parameters;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    AuditLogableBase auditLogableBase = new AuditLogableBase();
    auditLogableBase.addCustomValue("StorageDomainName", getStorageDomain().getName());
    auditLogableBase.setUserName(getUserName());
    if (getActionState() == CommandActionState.EXECUTE && !getSucceeded()) {
        return AuditLogType.UPDATE_OVF_FOR_STORAGE_DOMAIN_FAILED;
    }
    if ("SYSTEM".equals(auditLogableBase.getUserName())) {
        return AuditLogType.SYSTEM_UPDATE_OVF_STORE;
    }
    return AuditLogType.USER_UPDATE_OVF_STORE;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    AuditLogableBase auditLogableBase = new AuditLogableBase();
    auditLogableBase.addCustomValue("StorageDomainName", getStorageDomain().getName());
    auditLogableBase.setUserName(getUserName());
    if (getActionState() == CommandActionState.EXECUTE) {
        if (!getSucceeded()) {
            return AuditLogType.UPDATE_OVF_FOR_STORAGE_DOMAIN_FAILED;
        }
        if (!SYSTEM_USER_NAME.equals(auditLogableBase.getUserName())) {
            return AuditLogType.USER_UPDATE_OVF_STORE;
        }
    }
    return super.getAuditLogTypeValue();
}
#end_block

#method_before
protected VDS getUpServer() {
    return getClusterUtils().getRandomUpServer(getClusterId());
}
#method_after
protected VDS getUpServer() {
    return getGlusterUtils().getRandomUpServer(getClusterId());
}
#end_block

#method_before
protected boolean validateNotSameServer(List<GlusterBrickEntity> newBricks, int replicaCount) {
    Set<Guid> brickServers = new HashSet<>();
    int count = 0;
    for (GlusterBrickEntity brick : newBricks) {
        count++;
        if (brickServers.contains(brick.getServerId())) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_REPLICASET_SAME_SERVER);
            addValidationMessageVariable("brick", brick.getQualifiedName());
            return false;
        }
        brickServers.add(brick.getServerId());
        if (count == replicaCount) {
            count = 0;
            brickServers.clear();
        }
    }
    return true;
}
#method_after
protected boolean validateNotSameServer(List<GlusterBrickEntity> newBricks, GlusterVolumeEntity glusterVolume, int newReplicaCount) {
    if (newReplicaCount <= 1) {
        // no validation required for non-replicated volume types
        return true;
    }
    if (glusterVolume.getReplicaCount() == newReplicaCount) {
        return validateNotSameServer(newBricks, newReplicaCount);
    }
    List<Guid> existingServerList = glusterVolume.getBricks().stream().map(GlusterBrickEntity::getServerId).collect(Collectors.toList());
    Set<Guid> brickServers = new HashSet<>();
    int incCount = newReplicaCount - glusterVolume.getReplicaCount();
    for (int i = 0, j = 0; i <= existingServerList.size() - glusterVolume.getReplicaCount(); i += glusterVolume.getReplicaCount(), j += incCount) {
        brickServers.addAll(existingServerList.subList(i, i + glusterVolume.getReplicaCount()));
        List<Guid> subVolNewServers = newBricks.subList(j, j + incCount).stream().map(GlusterBrickEntity::getServerId).collect(Collectors.toList());
        for (Guid serverId : subVolNewServers) {
            if (brickServers.contains(serverId)) {
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_REPLICASET_SAME_SERVER);
                return false;
            }
        }
        brickServers.clear();
    }
    return true;
}
#end_block

#method_before
protected boolean validateNotSameServer(List<GlusterBrickEntity> newBricks, int replicaCount) {
    Set<Guid> brickServers = new HashSet<>();
    int count = 0;
    for (GlusterBrickEntity brick : newBricks) {
        count++;
        if (brickServers.contains(brick.getServerId())) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_REPLICASET_SAME_SERVER);
            addValidationMessageVariable("brick", brick.getQualifiedName());
            return false;
        }
        brickServers.add(brick.getServerId());
        if (count == replicaCount) {
            count = 0;
            brickServers.clear();
        }
    }
    return true;
}
#method_after
protected boolean validateNotSameServer(List<GlusterBrickEntity> newBricks, int replicaCount) {
    if (replicaCount <= 1) {
        // no validation required for non-replicated volume types
        return true;
    }
    for (int count = 0; count <= newBricks.size() - replicaCount; count += replicaCount) {
        Set<Guid> brickServers = newBricks.subList(count, count + replicaCount).stream().map(GlusterBrickEntity::getServerId).collect(Collectors.toSet());
        if (brickServers.size() < replicaCount) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_REPLICASET_SAME_SERVER);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (getParameters().getBricks() == null || getParameters().getBricks().size() == 0) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    if (getGlusterVolume().getVolumeType().isReplicatedType()) {
        if (getParameters().getReplicaCount() > getGlusterVolume().getReplicaCount() + 1) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_REPLICA_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getReplicaCount() < getGlusterVolume().getReplicaCount()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_REPLICA_COUNT);
        }
    }
    if (getGlusterVolume().getVolumeType().isStripedType()) {
        if (getParameters().getStripeCount() > getGlusterVolume().getStripeCount() + 1) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_STRIPE_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getStripeCount() < getGlusterVolume().getStripeCount()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_STRIPE_COUNT);
        }
    }
    if (getGlusterVolume().getVolumeType().isDispersedType()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_ADD_BRICK_TO_DISPERSE_VOLUME_NOT_SUPPORTED);
        return false;
    }
    boolean ret = updateBrickServerAndInterfaceNames(getParameters().getBricks(), true) && validateDuplicateBricks(getParameters().getBricks());
    // only validate bricks are not from same server for HC clusters.
    if (getCluster().supportsGlusterService() && getCluster().supportsVirtService()) {
        ret = ret && validateNotSameServer(getParameters().getBricks(), getParameters().getReplicaCount());
    }
    return ret;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (getParameters().getBricks() == null || getParameters().getBricks().size() == 0) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
    }
    if (getGlusterVolume().getVolumeType().isReplicatedType()) {
        if (getParameters().getReplicaCount() > getGlusterVolume().getReplicaCount() + 1) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_REPLICA_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getReplicaCount() < getGlusterVolume().getReplicaCount()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_REPLICA_COUNT);
        }
    }
    if (getGlusterVolume().getVolumeType().isStripedType()) {
        if (getParameters().getStripeCount() > getGlusterVolume().getStripeCount() + 1) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_STRIPE_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getStripeCount() < getGlusterVolume().getStripeCount()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_STRIPE_COUNT);
        }
    }
    if (getGlusterVolume().getVolumeType().isDispersedType()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ADD_BRICK_TO_DISPERSE_VOLUME_NOT_SUPPORTED);
    }
    boolean ret = updateBrickServerAndInterfaceNames(getParameters().getBricks(), true) && validateDuplicateBricks(getParameters().getBricks());
    // only validate bricks are not from same server for HC clusters.
    if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && getGlusterVolume().getVolumeType().isReplicatedType()) {
        ret = ret && validateNotSameServer(getParameters().getBricks(), getGlusterVolume(), getParameters().getReplicaCount());
    }
    return ret;
}
#end_block

#method_before
private void postAddBrickHandleGeoRepCase(final List<GlusterBrickEntity> bricksList, final Set<Guid> newServerIds) {
    // newServerIds is the set of ids of the servers that were not part of the volume before this attempt of brick
    // addition.
    final GlusterVolumeEntity volume = getGlusterVolume();
    List<GlusterGeoRepSession> sessions = new ArrayList<>();
    // Get all sessions for which the volume is a master
    List<GlusterGeoRepSession> geoRepSessionsForVolumeAsMaster = getDbFacade().getGlusterGeoRepDao().getGeoRepSessions(volume.getId());
    if (geoRepSessionsForVolumeAsMaster != null && !geoRepSessionsForVolumeAsMaster.isEmpty()) {
        sessions.addAll(geoRepSessionsForVolumeAsMaster);
    }
    // Get session for which the volume is a slave
    GlusterGeoRepSession geoRepSessionForVolumeAsSlave = getDbFacade().getGlusterGeoRepDao().getGeoRepSessionBySlaveVolume(volume.getId());
    if (geoRepSessionForVolumeAsSlave != null) {
        sessions.add(geoRepSessionForVolumeAsSlave);
    }
    // If this volume is empty, nothing to do.
    if (sessions.isEmpty()) {
        return;
    }
    List<Callable<Boolean>> perSessionCallables = new ArrayList<>();
    for (final GlusterGeoRepSession currentSession : sessions) {
        perSessionCallables.add(() -> {
            // Ids of servers on which steps like mount broker setup and/or passwordless ssh need to be done.
            Set<Guid> serverIdsToPrep = new HashSet<>(newServerIds);
            // Assume current volume as master volume of current session
            GlusterVolumeEntity masterVolume = volume;
            boolean succeeded = true;
            addCustomValue(GlusterConstants.VOLUME_NAME, currentSession.getMasterVolumeName());
            addCustomValue(GlusterConstants.GEO_REP_SLAVE_VOLUME_NAME, currentSession.getSlaveVolumeName());
            addCustomValue(GlusterConstants.GEO_REP_USER, currentSession.getUserName());
            if (currentSession.getMasterVolumeId().equals(volume.getId())) {
                /*
                     * If the volume is master, and there are any new servers, serverIdsToPrep is a set of all slave
                     * servers. This is bcoz the new server's keys also need to be updated to all slave servers.
                     */
                serverIdsToPrep = getSlaveNodesSet(currentSession);
            } else {
                // If its slave and non-root session, do partial mount broker setup
                if (!currentSession.getUserName().equalsIgnoreCase("root")) {
                    succeeded = evaluateReturnValue(errorType, getBackend().runInternalAction(VdcActionType.SetupGlusterGeoRepMountBrokerInternal, new SetUpMountBrokerParameters(volume.getClusterId(), serverIdsToPrep, volume.getName(), currentSession.getUserName())));
                    if (succeeded) {
                        auditLogDirector.log(AddBricksToGlusterVolumeCommand.this, AuditLogType.GLUSTER_SETUP_GEOREP_MOUNT_BROKER);
                    }
                }
                /*
                     * If the assumption that current volume is master, is invalid, which will be known here, update
                     * master volume correctly.
                     */
                masterVolume = getGlusterVolumeDao().getById(currentSession.getMasterVolumeId());
            }
            if (succeeded) {
                succeeded = evaluateReturnValue(errorType, runInternalAction(VdcActionType.SetUpPasswordLessSSHInternal, new SetUpPasswordLessSSHParameters(masterVolume.getClusterId(), serverIdsToPrep, currentSession.getUserName())));
            }
            if (succeeded) {
                auditLogDirector.log(AddBricksToGlusterVolumeCommand.this, AuditLogType.SET_UP_PASSWORDLESS_SSH);
                succeeded = evaluateReturnValue(errorType, runVdsCommand(VDSCommandType.CreateGlusterVolumeGeoRepSession, new GlusterVolumeGeoRepSessionVDSParameters(getClusterUtils().getRandomUpServer(masterVolume.getClusterId()).getId(), currentSession.getMasterVolumeName(), currentSession.getSlaveHostName(), currentSession.getSlaveVolumeName(), currentSession.getUserName(), true)));
            }
            if (currentSession.getStatus() == GeoRepSessionStatus.ACTIVE || currentSession.getStatus() == GeoRepSessionStatus.INITIALIZING) {
                succeeded = evaluateReturnValue(errorType, runInternalAction(VdcActionType.StartGlusterVolumeGeoRep, new GlusterVolumeGeoRepSessionParameters(currentSession.getMasterVolumeId(), currentSession.getId(), true)));
            }
            return succeeded;
        });
    }
    ThreadPoolUtil.invokeAll(perSessionCallables);
}
#method_after
private void postAddBrickHandleGeoRepCase(final List<GlusterBrickEntity> bricksList, final Set<Guid> newServerIds) {
    // newServerIds is the set of ids of the servers that were not part of the volume before this attempt of brick
    // addition.
    final GlusterVolumeEntity volume = getGlusterVolume();
    List<GlusterGeoRepSession> sessions = new ArrayList<>();
    // Get all sessions for which the volume is a master
    List<GlusterGeoRepSession> geoRepSessionsForVolumeAsMaster = getDbFacade().getGlusterGeoRepDao().getGeoRepSessions(volume.getId());
    if (geoRepSessionsForVolumeAsMaster != null && !geoRepSessionsForVolumeAsMaster.isEmpty()) {
        sessions.addAll(geoRepSessionsForVolumeAsMaster);
    }
    // Get session for which the volume is a slave
    GlusterGeoRepSession geoRepSessionForVolumeAsSlave = getDbFacade().getGlusterGeoRepDao().getGeoRepSessionBySlaveVolume(volume.getId());
    if (geoRepSessionForVolumeAsSlave != null) {
        sessions.add(geoRepSessionForVolumeAsSlave);
    }
    // If this volume is empty, nothing to do.
    if (sessions.isEmpty()) {
        return;
    }
    List<Callable<Boolean>> perSessionCallables = new ArrayList<>();
    for (final GlusterGeoRepSession currentSession : sessions) {
        perSessionCallables.add(() -> {
            // Ids of servers on which steps like mount broker setup and/or passwordless ssh need to be done.
            Set<Guid> serverIdsToPrep = new HashSet<>(newServerIds);
            // Assume current volume as master volume of current session
            GlusterVolumeEntity masterVolume = volume;
            boolean succeeded = true;
            addCustomValue(GlusterConstants.VOLUME_NAME, currentSession.getMasterVolumeName());
            addCustomValue(GlusterConstants.GEO_REP_SLAVE_VOLUME_NAME, currentSession.getSlaveVolumeName());
            addCustomValue(GlusterConstants.GEO_REP_USER, currentSession.getUserName());
            if (currentSession.getMasterVolumeId().equals(volume.getId())) {
                /*
                     * If the volume is master, and there are any new servers, serverIdsToPrep is a set of all slave
                     * servers. This is bcoz the new server's keys also need to be updated to all slave servers.
                     */
                serverIdsToPrep = getSlaveNodesSet(currentSession);
            } else {
                // If its slave and non-root session, do partial mount broker setup
                if (!currentSession.getUserName().equalsIgnoreCase("root")) {
                    succeeded = evaluateReturnValue(errorType, getBackend().runInternalAction(VdcActionType.SetupGlusterGeoRepMountBrokerInternal, new SetUpMountBrokerParameters(volume.getClusterId(), serverIdsToPrep, volume.getName(), currentSession.getUserName())));
                    if (succeeded) {
                        auditLogDirector.log(AddBricksToGlusterVolumeCommand.this, AuditLogType.GLUSTER_SETUP_GEOREP_MOUNT_BROKER);
                    }
                }
                /*
                     * If the assumption that current volume is master, is invalid, which will be known here, update
                     * master volume correctly.
                     */
                masterVolume = getGlusterVolumeDao().getById(currentSession.getMasterVolumeId());
            }
            if (succeeded) {
                succeeded = evaluateReturnValue(errorType, runInternalAction(VdcActionType.SetUpPasswordLessSSHInternal, new SetUpPasswordLessSSHParameters(masterVolume.getClusterId(), serverIdsToPrep, currentSession.getUserName())));
            }
            if (succeeded) {
                auditLogDirector.log(AddBricksToGlusterVolumeCommand.this, AuditLogType.SET_UP_PASSWORDLESS_SSH);
                succeeded = evaluateReturnValue(errorType, runVdsCommand(VDSCommandType.CreateGlusterVolumeGeoRepSession, new GlusterVolumeGeoRepSessionVDSParameters(getGlusterUtils().getRandomUpServer(masterVolume.getClusterId()).getId(), currentSession.getMasterVolumeName(), currentSession.getSlaveHostName(), currentSession.getSlaveVolumeName(), currentSession.getUserName(), true)));
            }
            if (currentSession.getStatus() == GeoRepSessionStatus.ACTIVE || currentSession.getStatus() == GeoRepSessionStatus.INITIALIZING) {
                succeeded = evaluateReturnValue(errorType, runInternalAction(VdcActionType.StartGlusterVolumeGeoRep, new GlusterVolumeGeoRepSessionParameters(currentSession.getMasterVolumeId(), currentSession.getId(), true)));
            }
            return succeeded;
        });
    }
    ThreadPoolUtil.invokeAll(perSessionCallables);
}
#end_block

#method_before
@Override
protected void init() {
    updateMigrateOnError();
    oldCluster = getClusterDao().get(getCluster().getId());
}
#method_after
@Override
protected void init() {
    updateMigrateOnError();
    oldCluster = getClusterDao().get(getCluster().getId());
    if (oldCluster != null && !Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        vmsLockedForUpdate = filterVmsInClusterNeedUpdate();
    }
}
#end_block

#method_before
private boolean updateVms() {
    for (VM vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        upgradeGraphicsDevices(vm, updateParams);
        VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            getReturnValue().setFault(result.getFault());
            return false;
        }
    }
    return true;
}
#method_after
private boolean updateVms() {
    for (VmStatic vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        upgradeGraphicsDevices(vm, updateParams);
        VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            getReturnValue().setFault(result.getFault());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void upgradeGraphicsDevices(VM vm, VmManagementParametersBase updateParams) {
    Version oldVersion = updateParams.getClusterLevelChangeFromVersion();
    if (vm.getCustomCompatibilityVersion() == null && Version.v4_0.greater(oldVersion)) {
        VmStatic dbVm = vm.getStaticData();
        VmStatic paramVm = updateParams.getVmStaticData();
        if (dbVm.getDefaultDisplayType() == DisplayType.cirrus) {
            paramVm.setDefaultDisplayType(DisplayType.vga);
        }
    }
}
#method_after
private void upgradeGraphicsDevices(VmStatic dbVm, VmManagementParametersBase updateParams) {
    Version oldVersion = updateParams.getClusterLevelChangeFromVersion();
    if (Version.v4_0.greater(oldVersion)) {
        VmStatic paramVm = updateParams.getVmStaticData();
        if (dbVm.getDefaultDisplayType() == DisplayType.cirrus) {
            paramVm.setDefaultDisplayType(DisplayType.vga);
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldCluster == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldCluster.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = getVdsDao().getAllForCluster(oldCluster.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_CLUSTER_WITH_HOSTS_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldCluster, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldCluster.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForCluster(oldCluster.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldCluster);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getClusterDao().getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldCluster);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    if (result && Version.v3_6.compareTo(getCluster().getCompatibilityVersion()) <= 0) {
        List<String> names = new ArrayList<>();
        for (VDS host : allForCluster) {
            if (VdsProtocol.XML == host.getProtocol()) {
                names.add(host.getName());
            }
        }
        if (!names.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_WRONG_PROTOCOL_FOR_CLUSTER_VERSION);
        }
    }
    return result;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldCluster == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldCluster.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = getVdsDao().getAllForCluster(oldCluster.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_CLUSTER_WITH_HOSTS_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldCluster, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldCluster.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForCluster(oldCluster.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result && !oldCluster.getCompatibilityVersion().equals(getCluster().getCompatibilityVersion())) {
        for (VM vm : vmList) {
            if (vm.isPreviewSnapshot()) {
                // can't change cluster version when a VM is in preview
                if (result) {
                    addValidationMessage(EngineMessage.CLUSTER_VERSION_CHANGE_VM_PREVIEW);
                    // and continue with adding validation messages
                    result = false;
                }
                addValidationMessage(vm.getName());
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldCluster);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getClusterDao().getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldCluster);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    if (result && Version.v3_6.compareTo(getCluster().getCompatibilityVersion()) <= 0) {
        List<String> names = new ArrayList<>();
        for (VDS host : allForCluster) {
            if (VdsProtocol.XML == host.getProtocol()) {
                names.add(host.getName());
            }
        }
        if (!names.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_WRONG_PROTOCOL_FOR_CLUSTER_VERSION);
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    final boolean versionChanged = !Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion());
    if (!versionChanged) {
        return null;
    }
    final LockMessage lockMessage = new LockMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_IS_BEING_UPDATED).with("clusterName", oldCluster.getName());
    vmsLockedForUpdate = getVmDao().getAllForCluster(oldCluster.getId()).stream().filter(vm -> !vm.isExternalVm() && !vm.isHostedEngine()).filter(// no need for VM device update
    vm -> vm.getCustomCompatibilityVersion() == null).collect(Collectors.toList());
    return vmsLockedForUpdate.stream().collect(Collectors.toMap(vm -> vm.getId().toString(), vm -> LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, lockMessage)));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    final LockMessage lockMessage = new LockMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_IS_BEING_UPDATED).with("clusterName", oldCluster.getName());
    return vmsLockedForUpdate.stream().collect(Collectors.toMap(vm -> vm.getId().toString(), vm -> LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, lockMessage)));
}
#end_block

#method_before
@Test
public void vmsAreUpdatedByTheOrderOfTheirIds() {
    createSimpleCommand();
    VmStatic vm1 = new VmStatic();
    vm1.setId(new Guid("77296e00-0cad-4e5a-9299-008a7b6f4355"));
    VmStatic vm2 = new VmStatic();
    vm2.setId(new Guid("87296e00-0cad-4e5a-9299-008a7b6f4355"));
    VmStatic vm3 = new VmStatic();
    vm3.setId(new Guid("67296e00-0cad-4e5a-9299-008a7b6f4355"));
    when(vmStaticDao.getAllByCluster(any())).thenReturn(Arrays.asList(vm1, vm2, vm3));
    // the VMs ordered by Guids: v2, v3, v1
    assertEquals(Arrays.asList(vm2, vm3, vm1), cmd.filterVmsInClusterNeedUpdate());
}
#method_after
@Test
public void vmsAreUpdatedByTheOrderOfTheirIds() {
    createSimpleCommand();
    VmStatic vm1 = new VmStatic();
    vm1.setId(VM_ID1);
    VmStatic vm2 = new VmStatic();
    vm2.setId(VM_ID2);
    VmStatic vm3 = new VmStatic();
    vm3.setId(VM_ID3);
    when(vmStaticDao.getAllByCluster(any())).thenReturn(Arrays.asList(vm1, vm2, vm3));
    // the VMs ordered by Guids: v2, v3, v1
    assertEquals(Arrays.asList(vm2, vm3, vm1), cmd.filterVmsInClusterNeedUpdate());
}
#end_block

#method_before
public void updateAll() {
    final Guid selectedInstanceTypeId = getSelectedInstanceTypeId();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllInstanceTypes, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue res = (VdcQueryReturnValue) returnValue;
            if (res == null || !res.getSucceeded()) {
                return;
            }
            List<InstanceType> instanceTypes = new ArrayList<>();
            // add this only if the user is allowed to
            if (!getModel().isCreateInstanceOnly()) {
                instanceTypes.add(CustomInstanceType.INSTANCE);
            }
            for (InstanceType instanceType : (Iterable<InstanceType>) res.getReturnValue()) {
                instanceTypes.add(instanceType);
            }
            getModel().getInstanceTypes().setItems(instanceTypes);
            for (InstanceType instanceType : instanceTypes) {
                if ((instanceType instanceof CustomInstanceType) && selectedInstanceTypeId == null) {
                    getModel().getInstanceTypes().setSelectedItem(CustomInstanceType.INSTANCE);
                    break;
                }
                if (instanceType.getId() == null || selectedInstanceTypeId == null) {
                    continue;
                }
                if (instanceType.getId().equals(selectedInstanceTypeId)) {
                    getModel().getInstanceTypes().setSelectedItem(instanceType);
                    break;
                }
            }
            if (getModel().getInstanceTypes().getSelectedItem() instanceof CustomInstanceType) {
                // detach if the instance type is "custom"
                getModel().getAttachedToInstanceType().setEntity(false);
            }
            updateFields();
        }
    }));
}
#method_after
public void updateAll() {
    final Guid selectedInstanceTypeId = getSelectedInstanceTypeId();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllInstanceTypes, new VdcQueryParametersBase(), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            if (returnValue == null || !returnValue.getSucceeded()) {
                return;
            }
            List<InstanceType> instanceTypes = new ArrayList<>();
            // add this only if the user is allowed to
            if (!getModel().isCreateInstanceOnly()) {
                instanceTypes.add(CustomInstanceType.INSTANCE);
            }
            for (InstanceType instanceType : (Iterable<InstanceType>) returnValue.getReturnValue()) {
                instanceTypes.add(instanceType);
            }
            getModel().getInstanceTypes().setItems(instanceTypes);
            for (InstanceType instanceType : instanceTypes) {
                if ((instanceType instanceof CustomInstanceType) && selectedInstanceTypeId == null) {
                    getModel().getInstanceTypes().setSelectedItem(CustomInstanceType.INSTANCE);
                    break;
                }
                if (instanceType.getId() == null || selectedInstanceTypeId == null) {
                    continue;
                }
                if (instanceType.getId().equals(selectedInstanceTypeId)) {
                    getModel().getInstanceTypes().setSelectedItem(instanceType);
                    break;
                }
            }
            if (getModel().getInstanceTypes().getSelectedItem() instanceof CustomInstanceType) {
                // detach if the instance type is "custom"
                getModel().getAttachedToInstanceType().setEntity(false);
            }
            updateFields();
        }
    }));
}
#end_block

#method_before
protected void doUpdateManagedFieldsFrom(final VmBase vmBase) {
    if (vmBase == null) {
        model.stopProgress();
        return;
    }
    deactivate();
    maybeSetEntity(model.getMemSize(), vmBase.getMemSizeMb());
    maybeSetEntity(model.getIoThreadsEnabled(), vmBase.getNumOfIoThreads() != 0);
    maybeSetEntity(model.getNumOfIoThreads(), vmBase.getNumOfIoThreads());
    maybeSetEntity(model.getMemSize(), vmBase.getMemSizeMb());
    maybeSetEntity(model.getTotalCPUCores(), Integer.toString(vmBase.getNumOfCpus()));
    model.setBootSequence(vmBase.getDefaultBootSequence());
    List<MigrationSupport> supportedModes = (List<MigrationSupport>) getModel().getMigrationMode().getItems();
    if (supportedModes.contains(vmBase.getMigrationSupport())) {
        maybeSetSelectedItem(getModel().getMigrationMode(), vmBase.getMigrationSupport());
    }
    maybeSetEntity(model.getIsHighlyAvailable(), vmBase.isAutoStartup());
    maybeSetSelectedItem(model.getNumOfSockets(), vmBase.getNumOfSockets());
    maybeSetSelectedItem(model.getCoresPerSocket(), vmBase.getCpuPerSocket());
    maybeSetSelectedItem(model.getThreadsPerCore(), vmBase.getThreadsPerCpu());
    maybeSetSelectedItem(model.getEmulatedMachine(), vmBase.getCustomEmulatedMachine());
    maybeSetSelectedItem(model.getCustomCpu(), vmBase.getCustomCpuName());
    model.setSelectedMigrationDowntime(vmBase.getMigrationDowntime());
    model.selectMigrationPolicy(vmBase.getMigrationPolicyId());
    priorityUtil.initPriority(vmBase.getPriority(), new PriorityUtil.PriorityUpdatingCallbacks() {

        @Override
        public void beforeUpdates() {
            deactivate();
        }

        @Override
        public void afterUpdates() {
            activate();
        }
    });
    updateDefaultDisplayRelatedFields(vmBase);
    if (vmBase.getMinAllocatedMem() != 0) {
        model.getMinAllocatedMemory().setEntity(vmBase.getMinAllocatedMem());
    }
    activate();
    AsyncDataProvider.getInstance().isSoundcardEnabled(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            deactivate();
            getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
            activate();
            Frontend.getInstance().runQuery(VdcQueryType.GetConsoleDevices, new IdQueryParameters(vmBase.getId()), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    deactivate();
                    List<String> consoleDevices = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    getModel().getIsConsoleDeviceEnabled().setEntity(!consoleDevices.isEmpty());
                    activate();
                    postDoUpdateManagedFieldsFrom(vmBase);
                }
            }));
        }
    }), vmBase.getId());
}
#method_after
protected void doUpdateManagedFieldsFrom(final VmBase vmBase) {
    if (vmBase == null) {
        model.stopProgress();
        return;
    }
    deactivate();
    maybeSetEntity(model.getMemSize(), vmBase.getMemSizeMb());
    maybeSetEntity(model.getIoThreadsEnabled(), vmBase.getNumOfIoThreads() != 0);
    maybeSetEntity(model.getNumOfIoThreads(), vmBase.getNumOfIoThreads());
    maybeSetEntity(model.getMemSize(), vmBase.getMemSizeMb());
    maybeSetEntity(model.getTotalCPUCores(), Integer.toString(vmBase.getNumOfCpus()));
    model.setBootSequence(vmBase.getDefaultBootSequence());
    List<MigrationSupport> supportedModes = (List<MigrationSupport>) getModel().getMigrationMode().getItems();
    if (supportedModes.contains(vmBase.getMigrationSupport())) {
        maybeSetSelectedItem(getModel().getMigrationMode(), vmBase.getMigrationSupport());
    }
    maybeSetEntity(model.getIsHighlyAvailable(), vmBase.isAutoStartup());
    maybeSetSelectedItem(model.getNumOfSockets(), vmBase.getNumOfSockets());
    maybeSetSelectedItem(model.getCoresPerSocket(), vmBase.getCpuPerSocket());
    maybeSetSelectedItem(model.getThreadsPerCore(), vmBase.getThreadsPerCpu());
    maybeSetSelectedItem(model.getEmulatedMachine(), vmBase.getCustomEmulatedMachine());
    maybeSetSelectedItem(model.getCustomCpu(), vmBase.getCustomCpuName());
    model.setSelectedMigrationDowntime(vmBase.getMigrationDowntime());
    model.selectMigrationPolicy(vmBase.getMigrationPolicyId());
    priorityUtil.initPriority(vmBase.getPriority(), new PriorityUtil.PriorityUpdatingCallbacks() {

        @Override
        public void beforeUpdates() {
            deactivate();
        }

        @Override
        public void afterUpdates() {
            activate();
        }
    });
    updateDefaultDisplayRelatedFields(vmBase);
    if (vmBase.getMinAllocatedMem() != 0) {
        model.getMinAllocatedMemory().setEntity(vmBase.getMinAllocatedMem());
    }
    activate();
    AsyncDataProvider.getInstance().isSoundcardEnabled(new AsyncQuery<>(new AsyncCallback<Boolean>() {

        @Override
        public void onSuccess(Boolean returnValue) {
            deactivate();
            getModel().getIsSoundcardEnabled().setEntity(returnValue);
            activate();
            Frontend.getInstance().runQuery(VdcQueryType.GetConsoleDevices, new IdQueryParameters(vmBase.getId()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

                @Override
                public void onSuccess(VdcQueryReturnValue returnValue) {
                    deactivate();
                    List<String> consoleDevices = returnValue.getReturnValue();
                    getModel().getIsConsoleDeviceEnabled().setEntity(!consoleDevices.isEmpty());
                    activate();
                    postDoUpdateManagedFieldsFrom(vmBase);
                }
            }));
        }
    }), vmBase.getId());
}
#end_block

#method_before
private void updateWatchdog(final VmBase vmBase, final boolean continueWithNext) {
    AsyncDataProvider.getInstance().getWatchdogByVmId(new AsyncQuery(this.getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            deactivate();
            UnitVmModel model = (UnitVmModel) target;
            VdcQueryReturnValue val = (VdcQueryReturnValue) returnValue;
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = val.getReturnValue();
            if (watchdogs.size() == 0) {
                model.getWatchdogAction().setSelectedItem(model.getWatchdogAction().getItems().iterator().next());
                model.getWatchdogModel().setSelectedItem(model.getWatchdogModel().getItems().iterator().next());
            }
            for (VmWatchdog watchdog : watchdogs) {
                if (watchdogAvailable(watchdog.getModel())) {
                    model.getWatchdogAction().setSelectedItem(watchdog.getAction() == null ? null : watchdog.getAction());
                    model.getWatchdogModel().setSelectedItem(// $NON-NLS-1$
                    watchdog.getModel() == null ? // $NON-NLS-1$
                    null : watchdog.getModel());
                }
            }
            activate();
            if (continueWithNext) {
                updateBalloon(vmBase, true);
            }
        }
    }), vmBase.getId());
}
#method_after
private void updateWatchdog(final VmBase vmBase, final boolean continueWithNext) {
    AsyncDataProvider.getInstance().getWatchdogByVmId(new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            deactivate();
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = returnValue.getReturnValue();
            if (watchdogs.size() == 0) {
                model.getWatchdogAction().setSelectedItem(model.getWatchdogAction().getItems().iterator().next());
                model.getWatchdogModel().setSelectedItem(model.getWatchdogModel().getItems().iterator().next());
            }
            for (VmWatchdog watchdog : watchdogs) {
                if (watchdogAvailable(watchdog.getModel())) {
                    model.getWatchdogAction().setSelectedItem(watchdog.getAction() == null ? null : watchdog.getAction());
                    model.getWatchdogModel().setSelectedItem(// $NON-NLS-1$
                    watchdog.getModel() == null ? // $NON-NLS-1$
                    null : watchdog.getModel());
                }
            }
            activate();
            if (continueWithNext) {
                updateBalloon(vmBase, true);
            }
        }
    }), vmBase.getId());
}
#end_block

#method_before
protected void updateBalloon(final VmBase vmBase, final boolean continueWithNext) {
    if (model.getMemoryBalloonDeviceEnabled().getIsChangable() && model.getMemoryBalloonDeviceEnabled().getIsAvailable()) {
        Frontend.getInstance().runQuery(VdcQueryType.IsBalloonEnabled, new IdQueryParameters(vmBase.getId()), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object parenModel, Object returnValue) {
                deactivate();
                getModel().getMemoryBalloonDeviceEnabled().setEntity((Boolean) ((VdcQueryReturnValue) returnValue).getReturnValue());
                activate();
                if (continueWithNext) {
                    updateRngDevice(vmBase);
                }
            }
        }));
    } else if (continueWithNext) {
        updateRngDevice(vmBase);
    }
}
#method_after
protected void updateBalloon(final VmBase vmBase, final boolean continueWithNext) {
    if (model.getMemoryBalloonDeviceEnabled().getIsChangable() && model.getMemoryBalloonDeviceEnabled().getIsAvailable()) {
        Frontend.getInstance().runQuery(VdcQueryType.IsBalloonEnabled, new IdQueryParameters(vmBase.getId()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

            @Override
            public void onSuccess(VdcQueryReturnValue returnValue) {
                deactivate();
                getModel().getMemoryBalloonDeviceEnabled().setEntity((Boolean) returnValue.getReturnValue());
                activate();
                if (continueWithNext) {
                    updateRngDevice(vmBase);
                }
            }
        }));
    } else if (continueWithNext) {
        updateRngDevice(vmBase);
    }
}
#end_block

#method_before
protected void updateRngDevice(final VmBase vmBase) {
    if (model.getIsRngEnabled().getIsChangable() && model.getIsRngEnabled().getIsAvailable()) {
        if (!isNextRunConfigurationExists()) {
            Frontend.getInstance().runQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(vmBase.getId()), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    deactivate();
                    List<VmDevice> rngDevices = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    getModel().getIsRngEnabled().setEntity(!rngDevices.isEmpty());
                    if (!rngDevices.isEmpty()) {
                        VmRngDevice rngDevice = new VmRngDevice(rngDevices.get(0));
                        getModel().setRngDevice(rngDevice);
                    }
                    activate();
                    updateVirtioScsi(vmBase);
                }
            }));
        } else {
            deactivate();
            VmDevice rngDevice = VmDeviceCommonUtils.findVmDeviceByGeneralType(vmBase.getManagedDeviceMap(), VmDeviceGeneralType.RNG);
            getModel().getIsRngEnabled().setEntity(rngDevice != null);
            if (rngDevice != null) {
                getModel().setRngDevice(new VmRngDevice(rngDevice));
            }
            activate();
            updateVirtioScsi(vmBase);
        }
    } else {
        updateVirtioScsi(vmBase);
    }
}
#method_after
protected void updateRngDevice(final VmBase vmBase) {
    if (model.getIsRngEnabled().getIsChangable() && model.getIsRngEnabled().getIsAvailable()) {
        if (!isNextRunConfigurationExists()) {
            Frontend.getInstance().runQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(vmBase.getId()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

                @Override
                public void onSuccess(VdcQueryReturnValue returnValue) {
                    deactivate();
                    List<VmDevice> rngDevices = returnValue.getReturnValue();
                    getModel().getIsRngEnabled().setEntity(!rngDevices.isEmpty());
                    if (!rngDevices.isEmpty()) {
                        VmRngDevice rngDevice = new VmRngDevice(rngDevices.get(0));
                        getModel().setRngDevice(rngDevice);
                    }
                    activate();
                    updateVirtioScsi(vmBase);
                }
            }));
        } else {
            deactivate();
            VmDevice rngDevice = VmDeviceCommonUtils.findVmDeviceByGeneralType(vmBase.getManagedDeviceMap(), VmDeviceGeneralType.RNG);
            getModel().getIsRngEnabled().setEntity(rngDevice != null);
            if (rngDevice != null) {
                getModel().setRngDevice(new VmRngDevice(rngDevice));
            }
            activate();
            updateVirtioScsi(vmBase);
        }
    } else {
        updateVirtioScsi(vmBase);
    }
}
#end_block

#method_before
protected void updateDefaultDisplayRelatedFields(final VmBase vmBase) {
    // Update display protocol selected item
    final Collection<DisplayType> displayTypes = model.getDisplayType().getItems();
    if (displayTypes == null || displayTypes.isEmpty()) {
        return;
    }
    // graphics
    Frontend.getInstance().runQuery(VdcQueryType.GetGraphicsDevices, new IdQueryParameters(vmBase.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object modelFromCallback, Object returnValue) {
            deactivate();
            // select display protocol
            // first by default
            DisplayType displayProtocol = displayTypes.iterator().next();
            if (displayTypes.contains(vmBase.getDefaultDisplayType())) {
                // if display types contain DT of a vm, pick this one
                displayProtocol = vmBase.getDefaultDisplayType();
            }
            maybeSetSelectedItem(model.getDisplayType(), displayProtocol);
            Set<GraphicsType> graphicsTypes = new HashSet<>();
            List<GraphicsDevice> graphicsDevices = ((VdcQueryReturnValue) returnValue).getReturnValue();
            for (GraphicsDevice graphicsDevice : graphicsDevices) {
                graphicsTypes.add(graphicsDevice.getGraphicsType());
            }
            UnitVmModel.GraphicsTypes selected = UnitVmModel.GraphicsTypes.fromGraphicsTypes(graphicsTypes);
            if (selected != null && getModel().getGraphicsType().getItems().contains(selected)) {
                maybeSetSelectedItem(getModel().getGraphicsType(), selected);
            }
            maybeSetSelectedItem(model.getNumOfMonitors(), vmBase.getNumOfMonitors());
            maybeSetSelectedItem(model.getUsbPolicy(), vmBase.getUsbPolicy());
            maybeSetEntity(model.getIsSmartcardEnabled(), vmBase.isSmartcardEnabled());
            maybeSetSingleQxlPci(vmBase);
            activate();
        }
    }));
}
#method_after
protected void updateDefaultDisplayRelatedFields(final VmBase vmBase) {
    // Update display protocol selected item
    final Collection<DisplayType> displayTypes = model.getDisplayType().getItems();
    if (displayTypes == null || displayTypes.isEmpty()) {
        return;
    }
    // graphics
    Frontend.getInstance().runQuery(VdcQueryType.GetGraphicsDevices, new IdQueryParameters(vmBase.getId()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            deactivate();
            // select display protocol
            // first by default
            DisplayType displayProtocol = displayTypes.iterator().next();
            if (displayTypes.contains(vmBase.getDefaultDisplayType())) {
                // if display types contain DT of a vm, pick this one
                displayProtocol = vmBase.getDefaultDisplayType();
            }
            maybeSetSelectedItem(model.getDisplayType(), displayProtocol);
            Set<GraphicsType> graphicsTypes = new HashSet<>();
            List<GraphicsDevice> graphicsDevices = returnValue.getReturnValue();
            for (GraphicsDevice graphicsDevice : graphicsDevices) {
                graphicsTypes.add(graphicsDevice.getGraphicsType());
            }
            UnitVmModel.GraphicsTypes selected = UnitVmModel.GraphicsTypes.fromGraphicsTypes(graphicsTypes);
            if (selected != null && getModel().getGraphicsType().getItems().contains(selected)) {
                maybeSetSelectedItem(getModel().getGraphicsType(), selected);
            }
            maybeSetSelectedItem(model.getNumOfMonitors(), vmBase.getNumOfMonitors());
            maybeSetSelectedItem(model.getUsbPolicy(), vmBase.getUsbPolicy());
            maybeSetEntity(model.getIsSmartcardEnabled(), vmBase.isSmartcardEnabled());
            maybeSetSingleQxlPci(vmBase);
            activate();
        }
    }));
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    locks.put(getVmPoolId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_POOL, getVmPoolIsBeingRemovedMessage()));
    for (VM vm : getCachedVmsInPool()) {
        addVmLocks(vm, locks);
    }
    return locks;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    locks.put(getVmPoolId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_POOL, new LockMessage(EngineMessage.ACTION_TYPE_FAILED_VM_POOL_IS_BEING_REMOVED).withOptional("VmPoolName", getVmPool() != null ? getVmPool().getName() : null)));
    for (VM vm : getCachedVmsInPool()) {
        addVmLocks(vm, locks);
    }
    return locks;
}
#end_block

#method_before
private String getVmIsBeingRemovedMessage(VM vm) {
    StringBuilder builder = new StringBuilder(EngineMessage.ACTION_TYPE_FAILED_VM_POOL_IS_BEING_REMOVED_WITH_VM.name());
    if (getVmPool() != null) {
        builder.append(String.format("$VmPoolName %1$s $VmName %2$s", getVmPool().getName(), vm.getName()));
    }
    return builder.toString();
}
#method_after
private LockMessage getVmIsBeingRemovedMessage(VM vm) {
    return new LockMessage(EngineMessage.ACTION_TYPE_FAILED_VM_POOL_IS_BEING_REMOVED_WITH_VM).withOptional("VmPoolName", getVmPool() != null ? getVmPool().getName() : null).withOptional("VmName", getVmPool() != null ? vm.getName() : null);
}
#end_block

#method_before
private boolean canRemoveVmPool(Guid vmPoolId) {
    return getVmPoolDao().getVmPoolsMapByVmPoolId(vmPoolId).size() == 0;
}
#method_after
private boolean canRemoveVmPool(Guid vmPoolId) {
    return getVmPoolDao().getVmPoolsMapByVmPoolId(vmPoolId).isEmpty();
}
#end_block

#method_before
private CommandContext createRemoveVmStepContext(VM vm) {
    CommandContext commandCtx = null;
    try {
        Map<String, String> values = Collections.singletonMap(VdcObjectType.VM.name().toLowerCase(), vm.getName());
        Step removeVmStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.REMOVING_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.REMOVING_VM, values));
        ExecutionContext ctx = new ExecutionContext();
        ctx.setStep(removeVmStep);
        ctx.setMonitored(true);
        Map<String, Pair<String, String>> locks = new HashMap<>();
        addVmLocks(vm, locks);
        EngineLock engineLock = new EngineLock(locks, null);
        commandCtx = cloneContext().withoutCompensationContext().withExecutionContext(ctx).withLock(engineLock);
    } catch (RuntimeException e) {
        log.error("Failed to create command context of removing VM '{}' that was in Pool '{}': {}", vm.getName(), getVmPoolName(), e.getMessage());
        log.debug("Exception", e);
    }
    return commandCtx;
}
#method_after
private CommandContext createRemoveVmStepContext(VM vm) {
    CommandContext commandCtx = null;
    try {
        Map<String, String> values = Collections.singletonMap(VdcObjectType.VM.name().toLowerCase(), vm.getName());
        Step removeVmStep = executionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.REMOVING_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.REMOVING_VM, values));
        ExecutionContext ctx = new ExecutionContext();
        ctx.setStep(removeVmStep);
        ctx.setMonitored(true);
        Map<String, Pair<String, String>> locks = new HashMap<>();
        addVmLocks(vm, locks);
        EngineLock engineLock = new EngineLock(locks, null);
        commandCtx = cloneContext().withoutCompensationContext().withExecutionContext(ctx).withLock(engineLock);
    } catch (RuntimeException e) {
        log.error("Failed to create command context of removing VM '{}' that was in Pool '{}': {}", vm.getName(), getVmPoolName(), e.getMessage());
        log.debug("Exception", e);
    }
    return commandCtx;
}
#end_block

#method_before
private Stream<Guid> selectVms(Guid vmPoolId, VMStatus vmStatus, Predicate<Guid> vmIdFilter, boolean leaveLocked) {
    List<VmPoolMap> vmPoolMaps = getVmPoolDao().getVmMapsInVmPoolByVmPoolIdAndStatus(vmPoolId, vmStatus);
    if (vmPoolMaps == null) {
        return Stream.empty();
    }
    return vmPoolMaps.stream().map(VmPoolMap::getVmId).filter(vmIdFilter).map(vmId -> acquireVm(vmId, leaveLocked)).filter(vmId -> !Guid.Empty.equals(vmId));
}
#method_after
private Stream<Guid> selectVms(Guid vmPoolId, VMStatus vmStatus, Predicate<Guid> vmIdFilter, boolean leaveLocked) {
    List<VmPoolMap> vmPoolMaps = vmPoolDao.getVmMapsInVmPoolByVmPoolIdAndStatus(vmPoolId, vmStatus);
    if (vmPoolMaps == null) {
        return Stream.empty();
    }
    return vmPoolMaps.stream().map(VmPoolMap::getVmId).filter(vmIdFilter).map(vmId -> acquireVm(vmId, leaveLocked)).filter(vmId -> !Guid.Empty.equals(vmId));
}
#end_block

#method_before
public boolean isNonPrestartedVmFree(Guid vmId, ErrorProcessor errorProcessor) {
    List<String> messages = new ArrayList<>();
    // check that there is no user already attached to this VM
    if (vmAssignedToUser(vmId, messages)) {
        return failVmFree(errorProcessor, vmId, messages);
    }
    // check that VN can be run
    if (!canRunPoolVm(vmId, messages)) {
        return failVmFree(errorProcessor, vmId, messages);
    }
    // check VM images
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vmId);
    if (!vmDuringSnapshotResult.isValid()) {
        return failVmFree(errorProcessor, vmId, vmDuringSnapshotResult.getMessagesAsStrings());
    }
    ValidationResult vmInPreviewResult = snapshotsValidator.vmNotInPreview(vmId);
    if (!vmInPreviewResult.isValid()) {
        return failVmFree(errorProcessor, vmId, vmInPreviewResult.getMessagesAsStrings());
    }
    List<Disk> disks = getDiskDao().getAllForVm(vmId);
    List<DiskImage> vmImages = ImagesHandler.filterImageDisks(disks, true, true, false);
    VM vm = getVmDao().get(vmId);
    StoragePool sp = getStoragePoolDao().get(vm.getStoragePoolId());
    ValidationResult spUpResult = new StoragePoolValidator(sp).isUp();
    if (!spUpResult.isValid()) {
        return failVmFree(errorProcessor, vmId, spUpResult.getMessagesAsStrings());
    }
    Guid storageDomainId = vmImages.size() > 0 ? vmImages.get(0).getStorageIds().get(0) : Guid.Empty;
    if (!Guid.Empty.equals(storageDomainId)) {
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomainDao().getForStoragePool(storageDomainId, sp.getId()));
        ValidationResult domainActiveResult = storageDomainValidator.isDomainExistAndActive();
        if (!domainActiveResult.isValid()) {
            return failVmFree(errorProcessor, vmId, domainActiveResult.getMessagesAsStrings());
        }
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(vmImages);
    ValidationResult disksNotLockedResult = diskImagesValidator.diskImagesNotLocked();
    if (!disksNotLockedResult.isValid()) {
        messages.addAll(disksNotLockedResult.getMessagesAsStrings());
        messages.addAll(disksNotLockedResult.getVariableReplacements());
        return failVmFree(errorProcessor, vmId, messages);
    }
    ValidationResult vmNotLockResult = new VmValidator(vm).vmNotLocked();
    if (!vmNotLockResult.isValid()) {
        return failVmFree(errorProcessor, vmId, vmNotLockResult.getMessagesAsStrings());
    }
    return true;
}
#method_after
public boolean isNonPrestartedVmFree(Guid vmId, ErrorProcessor errorProcessor) {
    List<String> messages = new ArrayList<>();
    // check that there is no user already attached to this VM
    if (vmAssignedToUser(vmId, messages)) {
        return failVmFree(errorProcessor, vmId, messages);
    }
    // check that VN can be run
    if (!canRunPoolVm(vmId, messages)) {
        return failVmFree(errorProcessor, vmId, messages);
    }
    // check VM images
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vmId);
    if (!vmDuringSnapshotResult.isValid()) {
        return failVmFree(errorProcessor, vmId, vmDuringSnapshotResult.getMessagesAsStrings());
    }
    ValidationResult vmInPreviewResult = snapshotsValidator.vmNotInPreview(vmId);
    if (!vmInPreviewResult.isValid()) {
        return failVmFree(errorProcessor, vmId, vmInPreviewResult.getMessagesAsStrings());
    }
    List<Disk> disks = diskDao.getAllForVm(vmId);
    List<DiskImage> vmImages = ImagesHandler.filterImageDisks(disks, true, true, false);
    VM vm = vmDao.get(vmId);
    StoragePool sp = storagePoolDao.get(vm.getStoragePoolId());
    ValidationResult spUpResult = new StoragePoolValidator(sp).isUp();
    if (!spUpResult.isValid()) {
        return failVmFree(errorProcessor, vmId, spUpResult.getMessagesAsStrings());
    }
    Guid storageDomainId = vmImages.size() > 0 ? vmImages.get(0).getStorageIds().get(0) : Guid.Empty;
    if (!Guid.Empty.equals(storageDomainId)) {
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomainDao.getForStoragePool(storageDomainId, sp.getId()));
        ValidationResult domainActiveResult = storageDomainValidator.isDomainExistAndActive();
        if (!domainActiveResult.isValid()) {
            return failVmFree(errorProcessor, vmId, domainActiveResult.getMessagesAsStrings());
        }
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(vmImages);
    ValidationResult disksNotLockedResult = diskImagesValidator.diskImagesNotLocked();
    if (!disksNotLockedResult.isValid()) {
        messages.addAll(disksNotLockedResult.getMessagesAsStrings());
        messages.addAll(disksNotLockedResult.getVariableReplacements());
        return failVmFree(errorProcessor, vmId, messages);
    }
    ValidationResult vmNotLockResult = new VmValidator(vm).vmNotLocked();
    if (!vmNotLockResult.isValid()) {
        return failVmFree(errorProcessor, vmId, vmNotLockResult.getMessagesAsStrings());
    }
    return true;
}
#end_block

#method_before
private boolean vmIsStartedByRunOnce(Guid vmId) {
    VmDynamic vmDynamic = getVmDynamicDao().get(vmId);
    return vmDynamic != null && vmDynamic.isRunOnce();
}
#method_after
private boolean vmIsStartedByRunOnce(Guid vmId) {
    VmDynamic vmDynamic = vmDynamicDao.get(vmId);
    return vmDynamic != null && vmDynamic.isRunOnce();
}
#end_block

#method_before
private boolean vmIsRunningStateless(Guid vmId) {
    return getSnapshotDao().exists(vmId, Snapshot.SnapshotType.STATELESS);
}
#method_after
private boolean vmIsRunningStateless(Guid vmId) {
    return snapshotDao.exists(vmId, Snapshot.SnapshotType.STATELESS);
}
#end_block

#method_before
private boolean vmAssignedToUser(Guid vmId, List<String> messages) {
    if (getDbUserDao().getAllForVm(vmId).size() > 0) {
        messages.add(EngineMessage.VM_POOL_CANNOT_ADD_VM_WITH_USERS_ATTACHED_TO_POOL.toString());
        return true;
    }
    return false;
}
#method_after
private boolean vmAssignedToUser(Guid vmId, List<String> messages) {
    if (dbUserDao.getAllForVm(vmId).size() > 0) {
        messages.add(EngineMessage.VM_POOL_CANNOT_ADD_VM_WITH_USERS_ATTACHED_TO_POOL.toString());
        return true;
    }
    return false;
}
#end_block

#method_before
private boolean canRunPoolVm(Guid vmId, List<String> messages) {
    VM vm = getVmDao().get(vmId);
    if (vm == null) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND.name());
        return false;
    }
    // TODO: This is done to keep consistency with VmDao.getById.
    // It can probably be removed, but that requires some more research
    VmHandler.updateNetworkInterfacesFromDb(vm);
    RunVmParams runVmParams = new RunVmParams(vmId);
    return new RunVmValidator(vm, runVmParams, false, findActiveISODomain(vm.getStoragePoolId())).canRunVm(messages, fetchStoragePool(vm.getStoragePoolId()), Collections.<Guid>emptyList(), null, null, getClusterDao().get(vm.getClusterId()));
}
#method_after
private boolean canRunPoolVm(Guid vmId, List<String> messages) {
    VM vm = vmDao.get(vmId);
    if (vm == null) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND.name());
        return false;
    }
    // TODO: This is done to keep consistency with VmDao.getById.
    // It can probably be removed, but that requires some more research
    VmHandler.updateNetworkInterfacesFromDb(vm);
    RunVmParams runVmParams = new RunVmParams(vmId);
    return new RunVmValidator(vm, runVmParams, false, findActiveISODomain(vm.getStoragePoolId())).canRunVm(messages, fetchStoragePool(vm.getStoragePoolId()), Collections.<Guid>emptyList(), null, null, clusterDao.get(vm.getClusterId()));
}
#end_block

#method_before
private StoragePool fetchStoragePool(Guid storagePoolId) {
    return getStoragePoolDao().get(storagePoolId);
}
#method_after
private StoragePool fetchStoragePool(Guid storagePoolId) {
    return storagePoolDao.get(storagePoolId);
}
#end_block

#method_before
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // save host that HE VM was running on prior to engine startup
    loadService(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    loadService(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    loadService(CpuFlagsManagerHandler.class);
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    // Initialize the CommandEntityCleanupManager
    CommandEntityCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(sessionDataContainer, "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    loadService(VmsMonitoring.class);
    loadService(VmDevicesMonitoring.class);
    loadService(VmPoolHandler.class);
    loadService(VmPoolMonitor.class);
    loadService(HaAutoStartVmsRunner.class);
    loadService(QuotaManager.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    registerIconDefaultsProvider();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#method_after
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // save host that HE VM was running on prior to engine startup
    loadService(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    loadService(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    loadService(CpuFlagsManagerHandler.class);
    loadService(AuditLogCleanupManager.class);
    loadService(CommandEntityCleanupManager.class);
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    loadService(JobRepositoryCleanupManager.class);
    loadService(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(sessionDataContainer, "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    loadService(VmsMonitoring.class);
    loadService(VmDevicesMonitoring.class);
    loadService(VmPoolHandler.class);
    loadService(VmPoolMonitor.class);
    loadService(HaAutoStartVmsRunner.class);
    loadService(QuotaManager.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    registerIconDefaultsProvider();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
private void initJobRepository() {
    try {
        JobRepositoryFactory.getJobRepository().finalizeJobs();
    } catch (Exception e) {
        log.error("Failed to finalize running Jobs", e);
    }
}
#method_after
private void initJobRepository() {
    try {
        jobRepository.finalizeJobs();
    } catch (Exception e) {
        log.error("Failed to finalize running Jobs", e);
    }
}
#end_block

#method_before
protected VdcReturnValueBase runAction(CommandBase<?> command, boolean runAsInternal) {
    VdcReturnValueBase returnValue = evaluateCorrelationId(command);
    if (returnValue != null) {
        return returnValue;
    }
    command.setInternalExecution(runAsInternal);
    ExecutionHandler.prepareCommandForMonitoring(command, command.getActionType(), runAsInternal);
    returnValue = actionExecutor.get().execute(command);
    returnValue.setCorrelationId(command.getParameters().getCorrelationId());
    returnValue.setJobId(command.getJobId());
    return returnValue;
}
#method_after
protected VdcReturnValueBase runAction(CommandBase<?> command, boolean runAsInternal) {
    VdcReturnValueBase returnValue = evaluateCorrelationId(command);
    if (returnValue != null) {
        return returnValue;
    }
    command.setInternalExecution(runAsInternal);
    executionHandler.prepareCommandForMonitoring(command, command.getActionType(), runAsInternal);
    returnValue = actionExecutor.get().execute(command);
    returnValue.setCorrelationId(command.getParameters().getCorrelationId());
    returnValue.setJobId(command.getJobId());
    return returnValue;
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    if (Guid.Empty.equals(getParameters().getVmId())) {
        boolean vmPrestarted = true;
        Guid vmToAttach = vmPoolHandler.selectPrestartedVm(getVmPoolId(), getVmPool().isStateful(), (vmId, errors) -> getReturnValue().getValidationMessages().addAll(errors));
        if (Guid.Empty.equals(vmToAttach)) {
            vmPrestarted = false;
            vmToAttach = vmPoolHandler.selectNonPrestartedVm(getVmPoolId(), (vmId, errors) -> getReturnValue().getValidationMessages().addAll(errors));
        }
        getParameters().setVmId(vmToAttach);
        getParameters().setVmPrestarted(vmPrestarted);
    }
    setVmId(getParameters().getVmId());
}
#method_after
@Override
protected void init() {
    super.init();
    if (Guid.Empty.equals(getParameters().getVmId()) && getVmPool() != null) {
        boolean vmPrestarted = true;
        Guid vmToAttach = vmPoolHandler.selectPrestartedVm(getVmPoolId(), getVmPool().isStateful(), (vmId, errors) -> getReturnValue().getValidationMessages().addAll(errors));
        if (Guid.Empty.equals(vmToAttach)) {
            vmPrestarted = false;
            vmToAttach = vmPoolHandler.selectNonPrestartedVm(getVmPoolId(), (vmId, errors) -> getReturnValue().getValidationMessages().addAll(errors));
        }
        getParameters().setVmId(vmToAttach);
        getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, vmToAttach));
        getParameters().setVmPrestarted(vmPrestarted);
    }
    setVmId(getParameters().getVmId());
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean returnValue = true;
    if (Guid.Empty.equals(getVmId())) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_NO_AVAILABLE_POOL_VMS);
        returnValue = false;
    }
    // check user isn't already attached to maximum number of vms from this pool
    if (returnValue) {
        List<VM> vmsForUser = getVmDao().getAllForUser(getAdUserId());
        int vmCount = 0;
        for (VM vm : vmsForUser) {
            if (vm.getVmPoolId() != null && getVmPoolId().equals(vm.getVmPoolId())) {
                vmCount++;
            }
        }
        int limit = getVmPool().getMaxAssignedVmsPerUser();
        if (vmCount >= limit) {
            addValidationMessage(EngineMessage.VM_POOL_CANNOT_ATTACH_TO_MORE_VMS_FROM_POOL);
            returnValue = false;
        }
    }
    if (!returnValue) {
        setActionMessageParameters();
        vmPoolHandler.releaseVm(getVmId(), !isVmPrestarted());
    }
    return returnValue;
}
#method_after
@Override
protected boolean validate() {
    boolean returnValue = true;
    if (getVmPool() == null) {
        addValidationMessage(EngineMessage.VM_POOL_NOT_FOUND);
        returnValue = false;
    }
    if (returnValue && Guid.Empty.equals(getVmId())) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_NO_AVAILABLE_POOL_VMS);
        returnValue = false;
    }
    // check user isn't already attached to maximum number of vms from this pool
    if (returnValue) {
        List<VM> vmsForUser = getVmDao().getAllForUser(getAdUserId());
        int vmCount = 0;
        for (VM vm : vmsForUser) {
            if (vm.getVmPoolId() != null && getVmPoolId().equals(vm.getVmPoolId())) {
                vmCount++;
            }
        }
        int limit = getVmPool().getMaxAssignedVmsPerUser();
        if (vmCount >= limit) {
            addValidationMessage(EngineMessage.VM_POOL_CANNOT_ATTACH_TO_MORE_VMS_FROM_POOL);
            returnValue = false;
        }
    }
    if (!returnValue) {
        setActionMessageParameters();
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    initPoolUser();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    VdcReturnValueBase vdcReturnValue = attachUserToVm();
    if (!vdcReturnValue.getSucceeded()) {
        log.info("Failed to give user '{}' permission to Vm '{}'", getAdUserId(), getVmId());
        setActionReturnValue(vdcReturnValue);
        vmPoolHandler.releaseVm(getVmId(), !isVmPrestarted());
        return;
    } else {
        log.info("Succeeded giving user '{}' permission to Vm '{}'", getAdUserId(), getVmId());
    }
    if (!isVmPrestarted()) {
        // Only when using a VM that is not prestarted we need to run the VM
        vdcReturnValue = runVm();
        setSucceeded(vdcReturnValue.getSucceeded());
        getReturnValue().getVdsmTaskIdList().addAll(getReturnValue().getInternalVdsmTaskIdList());
    } else {
        // No need to start, just return it
        setSucceeded(true);
    }
    setActionReturnValue(getVmId());
}
#method_after
@Override
protected void executeCommand() {
    initPoolUser();
    VdcReturnValueBase vdcReturnValue = attachUserToVm();
    if (!vdcReturnValue.getSucceeded()) {
        log.info("Failed to give user '{}' permission to Vm '{}'", getAdUserId(), getVmId());
        setActionReturnValue(vdcReturnValue);
        return;
    } else {
        log.info("Succeeded giving user '{}' permission to Vm '{}'", getAdUserId(), getVmId());
    }
    if (!isVmPrestarted()) {
        // Only when using a VM that is not prestarted we need to run the VM
        vdcReturnValue = runVm();
        setSucceeded(vdcReturnValue.getSucceeded());
        getReturnValue().getVdsmTaskIdList().addAll(getReturnValue().getInternalVdsmTaskIdList());
    } else {
        // No need to start, just return it
        setSucceeded(true);
    }
    setActionReturnValue(getVmId());
}
#end_block

#method_before
private ExecutionContext createRunVmContext() {
    ExecutionContext ctx = new ExecutionContext();
    try {
        Step step = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.TAKING_VM_FROM_POOL, ExecutionMessageDirector.resolveStepMessage(StepEnum.TAKING_VM_FROM_POOL, Collections.singletonMap(VdcObjectType.VM.name().toLowerCase(), getVmName())));
        ctx.setStep(step);
        ctx.setMonitored(true);
        ctx.setShouldEndJob(true);
    } catch (RuntimeException e) {
        log.error("Error when creating executing context for running stateless VM", e);
    }
    return ctx;
}
#method_after
private ExecutionContext createRunVmContext() {
    ExecutionContext ctx = new ExecutionContext();
    try {
        Step step = executionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.TAKING_VM_FROM_POOL, ExecutionMessageDirector.resolveStepMessage(StepEnum.TAKING_VM_FROM_POOL, Collections.singletonMap(VdcObjectType.VM.name().toLowerCase(), getVmName())));
        ctx.setStep(step);
        ctx.setMonitored(true);
        ctx.setShouldEndJob(true);
    } catch (RuntimeException e) {
        log.error("Error when creating executing context for running stateless VM", e);
    }
    return ctx;
}
#end_block

#method_before
private VdcReturnValueBase runVm() {
    RunVmParams runVmParams = new RunVmParams(getVmId());
    runVmParams.setSessionId(getParameters().getSessionId());
    runVmParams.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    runVmParams.setParentCommand(getActionType());
    runVmParams.setParentParameters(getParameters());
    runVmParams.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    runVmParams.setRunAsStateless(!getVmPool().isStateful());
    ExecutionContext runVmContext = createRunVmContext();
    VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RunVm, runVmParams, cloneContext().withExecutionContext(runVmContext).withLock(vmPoolHandler.createLock(getVmId())).withCompensationContext(null));
    getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
    return vdcReturnValue;
}
#method_after
private VdcReturnValueBase runVm() {
    RunVmParams runVmParams = new RunVmParams(getVmId());
    runVmParams.setSessionId(getParameters().getSessionId());
    runVmParams.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    runVmParams.setParentCommand(getActionType());
    runVmParams.setParentParameters(getParameters());
    runVmParams.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    runVmParams.setRunAsStateless(!getVmPool().isStateful());
    ExecutionContext runVmContext = createRunVmContext();
    VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RunVm, runVmParams, cloneContext().withExecutionContext(runVmContext).withCompensationContext(null));
    getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
    return vdcReturnValue;
}
#end_block

#method_before
@OnTimerMethodAnnotation("managePrestartedVmsInAllVmPools")
public void managePrestartedVmsInAllVmPools() {
    getVmPoolDao().getAll().stream().filter(pool -> pool.getPrestartedVms() > 0).forEach(this::managePrestartedVmsInPool);
}
#method_after
@OnTimerMethodAnnotation("managePrestartedVmsInAllVmPools")
public void managePrestartedVmsInAllVmPools() {
    vmPoolDao.getAll().stream().filter(pool -> pool.getPrestartedVms() > 0).forEach(this::managePrestartedVmsInPool);
}
#end_block

#method_before
private int getNumOfPrestartedVmsInPool(VmPool pool) {
    // TODO move to VmPoolHandler and rewrite
    List<VM> vmsInPool = getVmDao().getAllForVmPool(pool.getVmPoolId());
    return vmsInPool == null ? 0 : vmsInPool.stream().filter(vm -> vm.isStartingOrUp() && vmPoolHandler.isPrestartedVmFree(vm.getId(), pool.isStateful(), null)).collect(Collectors.counting()).intValue();
}
#method_after
private int getNumOfPrestartedVmsInPool(VmPool pool) {
    // TODO move to VmPoolHandler and rewrite. Worth to consider using a query that uses vms_monitoring_view
    List<VM> vmsInPool = vmDao.getAllForVmPool(pool.getVmPoolId());
    return vmsInPool == null ? 0 : vmsInPool.stream().filter(vm -> vm.isStartingOrUp() && vmPoolHandler.isPrestartedVmFree(vm.getId(), pool.isStateful(), null)).collect(Collectors.counting()).intValue();
}
#end_block

#method_before
private void prestartVms(VmPool vmPool, int numOfVmsToPrestart) {
    AtomicInteger failedAttempts = new AtomicInteger(0);
    AtomicInteger prestartedVmsCounter = new AtomicInteger(0);
    int maxFailedAttempts = Config.<Integer>getValue(ConfigValues.VmPoolMonitorMaxAttempts);
    Map<String, Set<Guid>> failureReasons = new HashMap<>();
    Iterator<Guid> iterator = vmPoolHandler.selectNonPrestartedVms(vmPool.getVmPoolId(), (vmId, messages) -> collectVmPrestartFailureReasons(vmId, failureReasons, messages)).iterator();
    while (failedAttempts.intValue() < maxFailedAttempts && prestartedVmsCounter.intValue() < numOfVmsToPrestart && iterator.hasNext()) {
        Guid vmId = iterator.next();
        if (prestartVm(vmId, !vmPool.isStateful(), vmPool.getName())) {
            prestartedVmsCounter.incrementAndGet();
            failedAttempts.set(0);
        } else {
            failedAttempts.incrementAndGet();
        }
    }
    logResultOfPrestartVms(prestartedVmsCounter.intValue(), numOfVmsToPrestart, vmPool.getVmPoolId(), failureReasons);
    if (prestartedVmsCounter.intValue() == 0) {
        log.info("No VMs available for prestarting");
    }
}
#method_after
private void prestartVms(VmPool vmPool, int numOfVmsToPrestart) {
    int failedAttempts = 0;
    int prestartedVms = 0;
    int maxFailedAttempts = Config.<Integer>getValue(ConfigValues.VmPoolMonitorMaxAttempts);
    Map<String, Set<Guid>> failureReasons = new HashMap<>();
    Iterator<Guid> iterator = vmPoolHandler.selectNonPrestartedVms(vmPool.getVmPoolId(), (vmId, messages) -> collectVmPrestartFailureReasons(vmId, failureReasons, messages)).iterator();
    while (failedAttempts < maxFailedAttempts && prestartedVms < numOfVmsToPrestart && iterator.hasNext()) {
        Guid vmId = iterator.next();
        if (prestartVm(vmId, !vmPool.isStateful(), vmPool.getName())) {
            prestartedVms++;
            failedAttempts = 0;
        } else {
            failedAttempts++;
        }
    }
    logResultOfPrestartVms(prestartedVms, numOfVmsToPrestart, vmPool.getVmPoolId(), failureReasons);
    if (prestartedVms == 0) {
        log.info("No VMs available for prestarting");
    }
}
#end_block

#method_before
private boolean prestartVm(Guid vmGuid, boolean runAsStateless, String poolName) {
    VmStatic vmToPrestart = getVmStaticDao().get(vmGuid);
    return runVmFromPool(vmToPrestart, runAsStateless, poolName);
}
#method_after
private boolean prestartVm(Guid vmGuid, boolean runAsStateless, String poolName) {
    VmStatic vmToPrestart = vmStaticDao.get(vmGuid);
    return runVmFromPool(vmToPrestart, runAsStateless, poolName);
}
#end_block

#method_before
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    CommandEntity commandEntity = CommandCoordinatorUtil.getCommandEntity(cmdId);
    StorageJobCommandParameters cmdParams = (StorageJobCommandParameters) commandEntity.getCommandParameters();
    Guid job = cmdParams.getStorageJobId();
    Guid vdsId = cmdParams.getVdsRunningOn();
    HostJobStatus jobStatus = null;
    VDS vds = getVdsDao().get(vdsId);
    if (vds.getStatus() == VDSStatus.Up) {
        try {
            jobStatus = pollStorageJob(job, vdsId);
        } catch (Exception e) {
            log.error("Failed to poll job '{}' for command '{}' (id: '{}'), will retry soon", job, commandEntity.getCommandType(), cmdId);
            return;
        }
    } else {
        log.error("Can't poll the status of job '{}' as Host '{}' (id: '{}') isn't in status UP", job, vds.getName(), vds.getId());
    }
    // (it might have already been deleted from the vdsm job caching)
    if (jobStatus == null) {
        try {
            jobStatus = pollEntityIfSupported(getCommand(cmdId));
        } catch (Exception e) {
            log.error("Failed to poll entity for command '{}' (id: '{}'), will retry soon", commandEntity.getCommandType(), cmdId);
            return;
        }
    }
    if (jobStatus == null) {
        log.info("Couldn't get status of job '{}' running on Host '{}' of '{}' (id: '{}'), Assuming its still " + "running", job, vdsId, commandEntity.getCommandType(), cmdId);
        return;
    }
    if (jobStatus.isAlive()) {
        log.info("Waiting on vdsm job: '{}' running on Host '{}' of '{}' (id: '{}') to complete", job, vdsId, commandEntity.getCommandType(), cmdId);
        return;
    }
    log.info("Command '{}' id: '{}' job '{}' execution was completed with VDSM job status '{}'", commandEntity.getCommandType(), cmdId, job, jobStatus);
    CommandBase<?> command = getCommand(cmdId);
    CommandExecutionStatus status = CommandCoordinatorUtil.getCommandExecutionStatus(cmdId);
    command.getParameters().setTaskGroupSuccess(status == CommandExecutionStatus.EXECUTED && jobStatus == HostJobStatus.done);
    command.setCommandStatus(command.getParameters().getTaskGroupSuccess() ? CommandStatus.SUCCEEDED : CommandStatus.FAILED);
    log.info("Command '{}' (id: '{}') execution was completed, the command status is '{}'", command.getActionType(), command.getCommandId(), command.getCommandStatus());
}
#method_after
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    CommandEntity commandEntity = CommandCoordinatorUtil.getCommandEntity(cmdId);
    StorageJobCommandParameters cmdParams = (StorageJobCommandParameters) commandEntity.getCommandParameters();
    Guid job = cmdParams.getStorageJobId();
    Guid vdsId = cmdParams.getVdsRunningOn();
    HostJobStatus jobStatus = null;
    VDS vds = getVdsDao().get(vdsId);
    if (vds.getStatus() == VDSStatus.Up) {
        try {
            jobStatus = pollStorageJob(job, vdsId);
        } catch (Exception e) {
            // We shouldn't get an error when polling the host job (as it access the local storage only).
            // If we got an error, it will usually be a network error - so the host will either move
            // to Non Responsive or the polling will succeed on the next attempt.
            log.warn("Command {} id: '{}': Failed to poll the job '{}' on host '{}' (id: '{}'), will retry soon", commandEntity.getCommandType(), cmdId, job, vds.getName(), vdsId);
            return;
        }
    } else {
        log.warn("Can't poll the status of job '{}' as Host '{}' (id: '{}') isn't in status UP", job, vds.getName(), vds.getId());
    }
    // (it might have already been deleted from the vdsm job caching)
    if (jobStatus == null) {
        jobStatus = pollEntityIfSupported(getCommand(cmdId));
    }
    if (jobStatus == null) {
        log.info("Couldn't get status of job '{}' running on Host '{}' of '{}' (id: '{}'), Assuming it's still " + "running", job, vdsId, commandEntity.getCommandType(), cmdId);
        return;
    }
    if (jobStatus.isAlive()) {
        log.info("Waiting on vdsm job: '{}' of '{}' (id: '{}') to complete", job, commandEntity.getCommandType(), cmdId);
        return;
    }
    log.info("Command '{}' id: '{}' job '{}' execution was completed with VDSM job status '{}'", commandEntity.getCommandType(), cmdId, job, jobStatus);
    CommandBase<?> command = getCommand(cmdId);
    CommandExecutionStatus status = CommandCoordinatorUtil.getCommandExecutionStatus(cmdId);
    command.getParameters().setTaskGroupSuccess(status == CommandExecutionStatus.EXECUTED && jobStatus == HostJobStatus.done);
    command.setCommandStatus(command.getParameters().getTaskGroupSuccess() ? CommandStatus.SUCCEEDED : CommandStatus.FAILED);
    log.info("Command '{}' (id: '{}') execution was completed, the command status is '{}'", command.getActionType(), command.getCommandId(), command.getCommandStatus());
}
#end_block

#method_before
public static Collection<String> replaceWith(String propertyName, Collection<?> items, String separator, int maxNumberOfPrintedItems) {
    Validate.isTrue(maxNumberOfPrintedItems >= 1);
    Validate.isTrue(StringUtils.isNotEmpty(separator));
    int maxNumOfItems = Math.min(maxNumberOfPrintedItems, items.size());
    List<String> printedItems = new ArrayList<>(maxNumOfItems);
    String itemPrefix = (separator.equals(DEFAULT_SEPARATOR)) ? "\t" : " ";
    for (Object item : items) {
        if (--maxNumOfItems < 0) {
            break;
        }
        printedItems.add(String.format("%s%s", itemPrefix, String.valueOf(item)));
    }
    if (items.size() > maxNumberOfPrintedItems) {
        printedItems.add(String.format("%s...", itemPrefix));
    }
    ArrayList<String> replacements = new ArrayList<>();
    replacements.add(createSetVariableString(propertyName, StringUtils.join(printedItems, separator)));
    replacements.add(createSetVariableString(propertyName + COUNTER_SUFFIX, items.size()));
    return replacements;
}
#method_after
public static Collection<String> replaceWith(String propertyName, Collection<?> items, String separator, int maxNumberOfPrintedItems) {
    Validate.isTrue(maxNumberOfPrintedItems >= 1);
    Validate.isTrue(StringUtils.isNotEmpty(separator));
    int maxNumOfItems = Math.min(maxNumberOfPrintedItems, items.size());
    List<String> printedItems = new ArrayList<>(maxNumOfItems);
    String itemPrefix = separator.equals(DEFAULT_SEPARATOR) ? "\t" : " ";
    for (Object item : items) {
        if (--maxNumOfItems < 0) {
            break;
        }
        printedItems.add(String.format("%s%s", itemPrefix, String.valueOf(item)));
    }
    if (items.size() > maxNumberOfPrintedItems) {
        printedItems.add(String.format("%s...", itemPrefix));
    }
    ArrayList<String> replacements = new ArrayList<>();
    replacements.add(createSetVariableString(propertyName, StringUtils.join(printedItems, separator)));
    replacements.add(createSetVariableString(propertyName + COUNTER_SUFFIX, items.size()));
    return replacements;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    host = new VDS();
    host.setId(Guid.newGuid());
    host.setClusterCompatibilityVersion(Version.v3_5);
    final VdsDynamic vdsDynamic = new VdsDynamic();
    vdsDynamic.setSupportedClusterLevels(TEST_VERSION);
    host.setDynamicData(vdsDynamic);
    bond = new Bond();
    bond.setId(Guid.newGuid());
    when(mockNetworkExclusivenessValidatorResolver.resolveNetworkExclusivenessValidator(TEST_SUPPORTED_VERSIONS)).thenReturn(mockNetworkExclusivenessValidator);
    when(mockNetworkAttachmentIpConfigurationValidator.validateNetworkAttachmentIpConfiguration(any())).thenReturn(ValidationResult.VALID);
}
#method_after
@Before
public void setUp() throws Exception {
    host = new VDS();
    host.setId(Guid.newGuid());
    final VdsDynamic vdsDynamic = new VdsDynamic();
    host.setDynamicData(vdsDynamic);
    bond = new Bond();
    bond.setId(Guid.newGuid());
    when(mockNetworkExclusivenessValidatorResolver.resolveNetworkExclusivenessValidator()).thenReturn(mockNetworkExclusivenessValidator);
    when(mockNetworkAttachmentIpConfigurationValidator.validateNetworkAttachmentIpConfiguration(any())).thenReturn(ValidationResult.VALID);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenUsedByVms() throws Exception {
    String nameOfNetworkA = "networkA";
    String nameOfNetworkB = "networkB";
    Network networkA = createNetworkWithName(nameOfNetworkA);
    Network networkB = createNetworkWithName(nameOfNetworkB);
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setNicId(nicA.getId());
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setNicId(nicB.getId());
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedNetworkAttachments(networkAttachmentA, networkAttachmentB).build()).addExistingInterfaces(Arrays.asList(nicA, nicB)).addExistingAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB)).addNetworks(Arrays.asList(networkA, networkB)).build());
    VmInterfaceManager vmInterfaceManagerMock = mock(VmInterfaceManager.class);
    doReturn(vmInterfaceManagerMock).when(validator).getVmInterfaceManager();
    List<String> vmNames = Arrays.asList("vmName1", "vmName2");
    when(vmInterfaceManagerMock.findActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(vmNames);
    final int MAX_NUMBER_OF_PRINTED_ITEMS = 5;
    final String SEPARATOR = ",";
    final List<String> errorNetworkNames = Arrays.asList(nameOfNetworkA, nameOfNetworkB);
    EngineMessage engineMessage = EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS;
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), failsWith(engineMessage, Stream.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAMES, errorNetworkNames, SEPARATOR, MAX_NUMBER_OF_PRINTED_ITEMS).stream(), ReplacementUtils.replaceWith(VAR_VM_NAMES, vmNames, SEPARATOR, MAX_NUMBER_OF_PRINTED_ITEMS).stream()).collect(Collectors.toList())));
    ArgumentCaptor<Collection> collectionArgumentCaptor = ArgumentCaptor.forClass(Collection.class);
    verify(vmInterfaceManagerMock).findActiveVmsUsingNetworks(eq(host.getId()), collectionArgumentCaptor.capture());
    assertThat(collectionArgumentCaptor.getValue().size(), is(2));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkA), is(true));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkB), is(true));
}
#method_after
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenUsedByVms() {
    String nameOfNetworkA = "networkA";
    Network networkA = createNetworkWithName(nameOfNetworkA);
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    VdsNetworkInterface nicA = createNic("nicA");
    networkAttachmentA.setNicId(nicA.getId());
    final HostSetupNetworksValidator underTest = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedNetworkAttachments(networkAttachmentA).build()).addExistingInterfaces(Arrays.asList(nicA)).addExistingAttachments(Arrays.asList(networkAttachmentA)).addNetworks(Arrays.asList(networkA)).build();
    List<String> vmNames = Arrays.asList("vmName1", "vmName2");
    when(findActiveVmsUsingNetwork.findNamesOfActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(vmNames);
    final List<String> removedNetworkNames = Collections.singletonList(nameOfNetworkA);
    assertThat(underTest.validateNotRemovingUsedNetworkByVms(nameOfNetworkA), failsWith(EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, Stream.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAME, removedNetworkNames, SEPARATOR).stream(), ReplacementUtils.replaceWith(VAR_VM_NAMES, vmNames, SEPARATOR).stream()).collect(Collectors.toList())));
    verify(findActiveVmsUsingNetwork).findNamesOfActiveVmsUsingNetworks(eq(host.getId()), collectionArgumentCaptor.capture());
    assertThat(collectionArgumentCaptor.getValue(), contains(nameOfNetworkA));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenNotUsedByVms() throws Exception {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().build());
    VmInterfaceManager vmInterfaceManagerMock = mock(VmInterfaceManager.class);
    doReturn(vmInterfaceManagerMock).when(validator).getVmInterfaceManager();
    when(vmInterfaceManagerMock.findActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Collections.<String>emptyList());
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), isValid());
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenNotUsedByVms() throws Exception {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().build());
    when(findActiveVmsUsingNetwork.findNamesOfActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Collections.<String>emptyList());
    assertThat(validator.validateNotRemovingUsedNetworkByVms("removedNet"), isValid());
}
#end_block

#method_before
private void doTestValidModifiedBonds(CreateOrUpdateBond createOrUpdateBond, ValidationResult interfaceIsBondValidationResult, ValidationResult expectedValidationResult, ValidationResult slavesValidationValidationResult) {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(createOrUpdateBond)).addExistingInterfaces((List<VdsNetworkInterface>) null).addExistingAttachments((List<NetworkAttachment>) null).addNetworks((Collection<Network>) null).build());
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationValidationResult).when(validator).validateModifiedBondSlaves(any(CreateOrUpdateBond.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessage(), expectedValidationResult.getVariableReplacements()));
    }
}
#method_after
private void doTestValidModifiedBonds(CreateOrUpdateBond createOrUpdateBond, ValidationResult interfaceIsBondValidationResult, ValidationResult expectedValidationResult, ValidationResult slavesValidationValidationResult) {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(createOrUpdateBond)).addExistingInterfaces((List<VdsNetworkInterface>) null).addExistingAttachments((List<NetworkAttachment>) null).addNetworks((Collection<Network>) null).build());
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationValidationResult).when(validator).validateModifiedBondSlaves(any(CreateOrUpdateBond.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessages(), expectedValidationResult.getVariableReplacements()));
    }
}
#end_block

#method_before
@Test
public void testValidateQosOverriddenInterfacesWhenAttachmentHasQosOverriddenAndRequiredValuesNotPresent() {
    EngineMessage hostNetworkQosValidatorFailure = EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_MISSING_VALUES;
    host.setClusterCompatibilityVersion(Version.v3_6);
    Network network = createNetworkWithName("network");
    HostSetupNetworksValidator validator = createValidatorForTestingValidateQosOverridden(network);
    HostSetupNetworksValidator validatorSpy = spy(validator);
    HostNetworkQosValidator hostNetworkQosValidatorMock = mock(HostNetworkQosValidator.class);
    when(hostNetworkQosValidatorMock.requiredQosValuesPresentForOverriding(eq(network.getName()))).thenReturn(new ValidationResult(hostNetworkQosValidatorFailure));
    doReturn(hostNetworkQosValidatorMock).when(validatorSpy).createHostNetworkQosValidator(any(HostNetworkQos.class));
    assertThat(validatorSpy.validateQosOverriddenInterfaces(), ValidationResultMatchers.failsWith(hostNetworkQosValidatorFailure));
    verify(hostNetworkQosValidatorMock).requiredQosValuesPresentForOverriding(eq(network.getName()));
    verifyNoMoreInteractions(hostNetworkQosValidatorMock);
}
#method_after
@Test
public void testValidateQosOverriddenInterfacesWhenAttachmentHasQosOverriddenAndRequiredValuesNotPresent() {
    EngineMessage hostNetworkQosValidatorFailure = EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_MISSING_VALUES;
    Network network = createNetworkWithName("network");
    HostSetupNetworksValidator validator = createValidatorForTestingValidateQosOverridden(network);
    HostSetupNetworksValidator validatorSpy = spy(validator);
    HostNetworkQosValidator hostNetworkQosValidatorMock = mock(HostNetworkQosValidator.class);
    when(hostNetworkQosValidatorMock.requiredQosValuesPresentForOverriding(eq(network.getName()))).thenReturn(new ValidationResult(hostNetworkQosValidatorFailure));
    doReturn(hostNetworkQosValidatorMock).when(validatorSpy).createHostNetworkQosValidator(any(HostNetworkQos.class));
    assertThat(validatorSpy.validateQosOverriddenInterfaces(), ValidationResultMatchers.failsWith(hostNetworkQosValidatorFailure));
    verify(hostNetworkQosValidatorMock).requiredQosValuesPresentForOverriding(eq(network.getName()));
    verifyNoMoreInteractions(hostNetworkQosValidatorMock);
}
#end_block

#method_before
@Test
public void testValidateQosOverriddenInterfacesWhenAttachmentHasQosOverriddenAndRequiredValuesPresentButInconsistent() {
    EngineMessage hostNetworkQosValidatorFailure = EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_INCONSISTENT_VALUES;
    host.setClusterCompatibilityVersion(Version.v3_6);
    Network network = createNetworkWithName("network");
    HostSetupNetworksValidator validator = createValidatorForTestingValidateQosOverridden(network);
    HostSetupNetworksValidator validatorSpy = spy(validator);
    HostNetworkQosValidator hostNetworkQosValidatorMock = mock(HostNetworkQosValidator.class);
    when(hostNetworkQosValidatorMock.requiredQosValuesPresentForOverriding(eq(network.getName()))).thenReturn(ValidationResult.VALID);
    when(hostNetworkQosValidatorMock.valuesConsistent(eq(network.getName()))).thenReturn(new ValidationResult(hostNetworkQosValidatorFailure));
    doReturn(hostNetworkQosValidatorMock).when(validatorSpy).createHostNetworkQosValidator(any(HostNetworkQos.class));
    assertThat(validatorSpy.validateQosOverriddenInterfaces(), ValidationResultMatchers.failsWith(hostNetworkQosValidatorFailure));
    verify(hostNetworkQosValidatorMock).requiredQosValuesPresentForOverriding(eq(network.getName()));
    verify(hostNetworkQosValidatorMock).valuesConsistent(eq(network.getName()));
    verifyNoMoreInteractions(hostNetworkQosValidatorMock);
}
#method_after
@Test
public void testValidateQosOverriddenInterfacesWhenAttachmentHasQosOverriddenAndRequiredValuesPresentButInconsistent() {
    EngineMessage hostNetworkQosValidatorFailure = EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_INCONSISTENT_VALUES;
    Network network = createNetworkWithName("network");
    HostSetupNetworksValidator validator = createValidatorForTestingValidateQosOverridden(network);
    HostSetupNetworksValidator validatorSpy = spy(validator);
    HostNetworkQosValidator hostNetworkQosValidatorMock = mock(HostNetworkQosValidator.class);
    when(hostNetworkQosValidatorMock.requiredQosValuesPresentForOverriding(eq(network.getName()))).thenReturn(ValidationResult.VALID);
    when(hostNetworkQosValidatorMock.valuesConsistent(eq(network.getName()))).thenReturn(new ValidationResult(hostNetworkQosValidatorFailure));
    doReturn(hostNetworkQosValidatorMock).when(validatorSpy).createHostNetworkQosValidator(any(HostNetworkQos.class));
    assertThat(validatorSpy.validateQosOverriddenInterfaces(), ValidationResultMatchers.failsWith(hostNetworkQosValidatorFailure));
    verify(hostNetworkQosValidatorMock).requiredQosValuesPresentForOverriding(eq(network.getName()));
    verify(hostNetworkQosValidatorMock).valuesConsistent(eq(network.getName()));
    verifyNoMoreInteractions(hostNetworkQosValidatorMock);
}
#end_block

#method_before
private void testValidateQosNotPartiallyConfigured(boolean networkAttachment1HasQos, boolean networkAttachment2HasQos, Matcher<ValidationResult> matcher) {
    VdsNetworkInterface baseNic = createNic("baseNic");
    VdsNetworkInterface vlanNic1 = createVlanNic(baseNic, "vlanNic1", 10);
    VdsNetworkInterface vlanNic2 = createVlanNic(baseNic, "vlanNic2", 11);
    Network network1 = createNetworkWithName("network1");
    Network network2 = createNetworkWithName("network2");
    NetworkAttachment networkAttachment1 = createNetworkAttachment(network1, baseNic);
    NetworkAttachment networkAttachment2 = createNetworkAttachment(network2, baseNic);
    HostNetworkQos qos = createHostNetworkQos(10, 10, 10);
    if (networkAttachment1HasQos) {
        networkAttachment1.setHostNetworkQos(qos);
    }
    if (networkAttachment2HasQos) {
        networkAttachment2.setHostNetworkQos(qos);
    }
    Collection<NetworkAttachment> networkAttachments = Arrays.asList(networkAttachment1, networkAttachment2);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().addNetworks(network1, network2).addExistingInterfaces(baseNic, vlanNic1, vlanNic2).build();
    assertThat(validator.validateQosNotPartiallyConfigured(networkAttachments), matcher);
}
#method_after
private void testValidateQosNotPartiallyConfigured(boolean networkAttachment1HasQos, boolean networkAttachment2HasQos, Matcher<ValidationResult> matcher) {
    VdsNetworkInterface baseNic = createNic("baseNic");
    VdsNetworkInterface vlanNic1 = createVlanNic(baseNic, "vlanNic1", 10);
    VdsNetworkInterface vlanNic2 = createVlanNic(baseNic, "vlanNic2", 11);
    Network network1 = createNetworkWithName("network1");
    Network network2 = createNetworkWithName("network2");
    NetworkAttachment networkAttachment1 = createNetworkAttachment(network1, baseNic);
    NetworkAttachment networkAttachment2 = createNetworkAttachment(network2, baseNic);
    AnonymousHostNetworkQos qos = createHostNetworkQos(10, 10, 10);
    if (networkAttachment1HasQos) {
        networkAttachment1.setHostNetworkQos(qos);
    }
    if (networkAttachment2HasQos) {
        networkAttachment2.setHostNetworkQos(qos);
    }
    Collection<NetworkAttachment> networkAttachments = Arrays.asList(networkAttachment1, networkAttachment2);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().addNetworks(network1, network2).addExistingInterfaces(baseNic, vlanNic1, vlanNic2).build();
    assertThat(validator.validateQosNotPartiallyConfigured(networkAttachments), matcher);
}
#end_block

#method_before
private HostSetupNetworksValidator createValidatorForTestingValidateQosOverridden(Network network) {
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setNetworkId(network.getId());
    networkAttachment.setHostNetworkQos(new HostNetworkQos());
    return new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addNetworkAttachments(networkAttachment)).addNetworks(network).build();
}
#method_after
private HostSetupNetworksValidator createValidatorForTestingValidateQosOverridden(Network network) {
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setNetworkId(network.getId());
    networkAttachment.setHostNetworkQos(new AnonymousHostNetworkQos());
    return new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addNetworkAttachments(networkAttachment)).addNetworks(network).build();
}
#end_block

#method_before
private HostNetworkQos createHostNetworkQos(int outAverageRealtime, int outAverageUpperlimit, int outAverageLinkshare) {
    HostNetworkQos qos = new HostNetworkQos();
    qos.setOutAverageRealtime(outAverageRealtime);
    qos.setOutAverageUpperlimit(outAverageUpperlimit);
    qos.setOutAverageLinkshare(outAverageLinkshare);
    return qos;
}
#method_after
private AnonymousHostNetworkQos createHostNetworkQos(int outAverageRealtime, int outAverageUpperlimit, int outAverageLinkshare) {
    AnonymousHostNetworkQos qos = new AnonymousHostNetworkQos();
    qos.setOutAverageRealtime(outAverageRealtime);
    qos.setOutAverageUpperlimit(outAverageUpperlimit);
    qos.setOutAverageLinkshare(outAverageLinkshare);
    return qos;
}
#end_block

#method_before
public HostSetupNetworksValidator build() {
    return new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, new BusinessEntityMap<>(networks), networkClusterDaoMock, networkDaoMock, vdsDaoMock, new HostSetupNetworksValidatorHelper(), vmDao, mockNetworkExclusivenessValidatorResolver, mockNetworkAttachmentIpConfigurationValidator, new UnmanagedNetworkValidator());
}
#method_after
public HostSetupNetworksValidator build() {
    return new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, new BusinessEntityMap<>(networks), networkClusterDaoMock, networkDaoMock, vdsDaoMock, findActiveVmsUsingNetwork, new HostSetupNetworksValidatorHelper(), vmDao, mockNetworkExclusivenessValidatorResolver, mockNetworkAttachmentIpConfigurationValidator, new UnmanagedNetworkValidator());
}
#end_block

#method_before
ValidationResult validateQosOverriddenInterfaces() {
    for (NetworkAttachment networkAttachment : params.getNetworkAttachments()) {
        if (networkAttachment.isQosOverridden()) {
            Network network = getNetworkRelatedToAttachment(networkAttachment);
            String networkName = network.getName();
            if (!hostNetworkQosSupported) {
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, networkName));
            }
            HostNetworkQos hostNetworkQos = networkAttachment.getHostNetworkQos();
            HostNetworkQosValidator qosValidator = createHostNetworkQosValidator(hostNetworkQos);
            ValidationResult requiredValuesPresent = qosValidator.requiredQosValuesPresentForOverriding(networkName);
            if (!requiredValuesPresent.isValid()) {
                return requiredValuesPresent;
            }
            ValidationResult valuesConsistent = qosValidator.valuesConsistent(networkName);
            if (!valuesConsistent.isValid()) {
                return valuesConsistent;
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validateQosOverriddenInterfaces() {
    for (NetworkAttachment networkAttachment : params.getNetworkAttachments()) {
        if (networkAttachment.isQosOverridden()) {
            Network network = getNetworkRelatedToAttachment(networkAttachment);
            String networkName = network.getName();
            HostNetworkQos hostNetworkQos = HostNetworkQos.fromAnonymousHostNetworkQos(networkAttachment.getHostNetworkQos());
            HostNetworkQosValidator qosValidator = createHostNetworkQosValidator(hostNetworkQos);
            ValidationResult requiredValuesPresent = qosValidator.requiredQosValuesPresentForOverriding(networkName);
            if (!requiredValuesPresent.isValid()) {
                return requiredValuesPresent;
            }
            ValidationResult valuesConsistent = qosValidator.valuesConsistent(networkName);
            if (!valuesConsistent.isValid()) {
                return valuesConsistent;
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
ValidationResult validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
        removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
    }
    final List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    if (vmNames.isEmpty()) {
        return ValidationResult.VALID;
    } else {
        final int MAX_NUMBER_OF_PRINTED_ITEMS = 5;
        final String SEPARATOR = ",";
        final List<String> sortedRemovedNetworks = new ArrayList<>(removedNetworks);
        Collections.sort(sortedRemovedNetworks);
        EngineMessage engineMessage = EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS;
        return new ValidationResult(engineMessage, Stream.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAMES, sortedRemovedNetworks, SEPARATOR, MAX_NUMBER_OF_PRINTED_ITEMS).stream(), ReplacementUtils.replaceWith(VAR_VM_NAMES, vmNames, SEPARATOR, MAX_NUMBER_OF_PRINTED_ITEMS).stream()).collect(Collectors.toList()));
    }
}
#method_after
@SuppressWarnings("unchecked")
ValidationResult validateNotRemovingUsedNetworkByVms(String removedNetworkName) {
    final List<String> removedNetworkNames = Collections.singletonList(removedNetworkName);
    final List<String> vmsNames = findActiveVmsUsingNetwork.findNamesOfActiveVmsUsingNetworks(host.getId(), removedNetworkNames);
    if (vmsNames.isEmpty()) {
        return ValidationResult.VALID;
    }
    EngineMessage engineMessage = EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS;
    return new ValidationResult(engineMessage, Stream.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAME, removedNetworkNames, SEPARATOR).stream(), ReplacementUtils.replaceWith(VAR_VM_NAMES, vmsNames, SEPARATOR).stream()).collect(Collectors.toList()));
}
#end_block

#method_before
private ValidationResult validateSlaveHasNoNetworks(String slaveName) {
    for (NetworkAttachment attachment : getAttachmentsToConfigure()) {
        if (Objects.equals(attachment.getNicName(), slaveName)) {
            if (attachment.getId() == null) {
                EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, attachment.getNetworkName()));
            } else {
                EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, attachment.getNetworkName()));
            }
        }
    }
    for (VdsNetworkInterface iface : existingInterfaces) {
        if (slaveName.equals(NetworkUtils.stripVlan(iface))) {
            if (iface.getNetworkImplementationDetails() != null && !iface.getNetworkImplementationDetails().isManaged()) {
                return new ValidationResult(EngineMessage.NETWORK_INTERFACE_WITH_UNMANAGED_NETWORK_CANNOT_BE_SLAVE, ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, iface.getNetworkName()), ReplacementUtils.createSetVariableString(VAR_NIC_NAME, slaveName));
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult validateSlaveHasNoNetworks(String slaveName) {
    for (NetworkAttachment attachment : getAttachmentsToConfigure()) {
        if (Objects.equals(attachment.getNicName(), slaveName)) {
            if (attachment.getId() == null) {
                EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, attachment.getNetworkName()));
            } else {
                EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, attachment.getNetworkName()));
            }
        }
    }
    for (VdsNetworkInterface iface : existingInterfaces) {
        if (slaveName.equals(NetworkCommonUtils.stripVlan(iface))) {
            if (iface.getNetworkImplementationDetails() != null && !iface.getNetworkImplementationDetails().isManaged()) {
                return new ValidationResult(EngineMessage.NETWORK_INTERFACE_WITH_UNMANAGED_NETWORK_CANNOT_BE_SLAVE, ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, iface.getNetworkName()), ReplacementUtils.createSetVariableString(VAR_NIC_NAME, slaveName));
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : referencedNetworkAttachmentActuallyExists(attachment.getId());
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : validateCoherentNetworkIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : modifiedAttachmentNotRemoved(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentNotReferenceVlanDevice(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentAndNicReferenceSameLabelNotConflict(attachment);
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForRoleNetwork();
        vr = skipValidation(vr) ? vr : validator.nicNameIsSet();
        vr = skipValidation(vr) ? vr : nicActuallyExistsOrReferencesNewBond(attachment);
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfacesMap);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(attachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : networkAttachmentIpConfigurationValidator.validateNetworkAttachmentIpConfiguration(params.getNetworkAttachments());
        boolean attachmentUpdated = !isNewAttachment(attachment.getId());
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : validator.networkNotUsedByVms();
            vr = skipValidation(vr) ? vr : notMovingLabeledNetworkToDifferentNic(attachment);
        }
    }
    return vr;
}
#method_after
ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : referencedNetworkAttachmentActuallyExists(attachment.getId());
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : validateCoherentNetworkIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : modifiedAttachmentNotRemoved(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentNotReferenceVlanDevice(attachment);
        vr = skipValidation(vr) ? vr : validator.existingAttachmentIsReused(existingAttachmentsByNetworkId);
        vr = skipValidation(vr) ? vr : validateAttachmentAndNicReferenceSameLabelNotConflict(attachment);
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForRoleNetwork();
        vr = skipValidation(vr) ? vr : validator.nicNameIsSet();
        vr = skipValidation(vr) ? vr : nicActuallyExistsOrReferencesNewBond(attachment);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(existingAttachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : networkAttachmentIpConfigurationValidator.validateNetworkAttachmentIpConfiguration(params.getNetworkAttachments());
        boolean attachmentUpdated = !isNewAttachment(attachment.getId());
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : notMovingLabeledNetworkToDifferentNic(attachment);
        }
    }
    return vr;
}
#end_block

#method_before
private ValidationResult validRemovedNetworkAttachments() {
    List<Guid> invalidIds = Entities.idsNotReferencingExistingRecords(params.getRemovedNetworkAttachments(), existingAttachments);
    if (!invalidIds.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENTS_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, invalidIds));
    }
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = removedNetworkAttachments.iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachmentToValidate);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.notRemovingManagementNetwork();
        vr = skipValidation(vr) ? vr : notRemovingLabeledNetworks(attachment);
        vr = skipValidation(vr) ? vr : validateNotRemovingUsedNetworkByVms();
    }
    return vr;
}
#method_after
private ValidationResult validRemovedNetworkAttachments() {
    List<Guid> invalidIds = Entities.idsNotReferencingExistingRecords(params.getRemovedNetworkAttachments(), existingAttachments);
    if (!invalidIds.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENTS_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, invalidIds));
    }
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = removedNetworkAttachments.iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.notRemovingManagementNetwork();
        vr = skipValidation(vr) ? vr : notRemovingLabeledNetworks(attachment);
        vr = skipValidation(vr) ? vr : validateNotRemovingUsedNetworkByVms(attachment.getNetworkName());
    }
    return vr;
}
#end_block

#method_before
private NetworkAttachmentValidator createNetworkAttachmentValidator(NetworkAttachment attachmentToValidate) {
    return new NetworkAttachmentValidator(attachmentToValidate, host, new VmInterfaceManager(), networkClusterDao, networkDao, vdsDao, vmDao);
}
#method_after
private NetworkAttachmentValidator createNetworkAttachmentValidator(NetworkAttachment attachmentToValidate) {
    return new NetworkAttachmentValidator(attachmentToValidate, host, networkClusterDao, networkDao, vdsDao, vmDao);
}
#end_block

#method_before
ValidationResult notRemovingLabeledNetworks(NetworkAttachment attachment) {
    Network removedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return ValidationResult.VALID;
    }
    boolean networkAttachedToNicByAnotherAttachment = networkAttachmentsByNetworkId.get(removedNetwork.getId()) != null;
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, removedNetwork.getName())).when(!networkAttachedToNicByAnotherAttachment && isNicToConfigureContainTheLabel(attachment.getNicName(), removedNetwork.getLabel()));
}
#method_after
ValidationResult notRemovingLabeledNetworks(NetworkAttachment attachment) {
    Network removedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return ValidationResult.VALID;
    }
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, removedNetwork.getName())).when(isNicToConfigureContainTheLabel(attachment.getNicName(), removedNetwork.getLabel()));
}
#end_block

#method_before
ValidationResult notMovingLabeledNetworkToDifferentNic(NetworkAttachment attachment) {
    Network movedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(movedNetwork)) {
        return ValidationResult.VALID;
    }
    NetworkAttachment existingAttachment = attachmentsById.get(attachment.getId());
    boolean movedToDifferentNic = !existingAttachment.getNicId().equals(attachment.getNicId());
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, movedNetwork.getName()), ReplacementUtils.getVariableAssignmentString(engineMessage, movedNetwork.getLabel())).when(movedToDifferentNic && isNicToConfigureContainTheLabel(existingAttachment.getNicName(), movedNetwork.getLabel()));
}
#method_after
ValidationResult notMovingLabeledNetworkToDifferentNic(NetworkAttachment newOrModifedAttachmet) {
    Network movedNetwork = existingNetworkRelatedToAttachment(newOrModifedAttachmet);
    if (!NetworkUtils.isLabeled(movedNetwork)) {
        return ValidationResult.VALID;
    }
    NetworkAttachment existingAttachment = existingAttachmentsById.get(newOrModifedAttachmet.getId());
    boolean movedToDifferentNic = !existingAttachment.getNicId().equals(newOrModifedAttachmet.getNicId());
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_MOVE_LABELED_NETWORK_TO_ANOTHER_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, movedNetwork.getName()), ReplacementUtils.getVariableAssignmentString(engineMessage, movedNetwork.getLabel())).when(movedToDifferentNic && isNicToConfigureContainTheLabel(existingAttachment.getNicName(), movedNetwork.getLabel()));
}
#end_block

#method_before
private ValidationResult validateAttachmentNotReferenceVlanDevice(NetworkAttachment attachment) {
    VdsNetworkInterface nic = existingInterfacesMap.get(attachment.getNicName());
    EngineMessage engineMessage = EngineMessage.ATTACHMENT_REFERENCE_VLAN_DEVICE;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, attachment.getNetworkName()), ReplacementUtils.createSetVariableString(VAR_NIC_NAME, attachment.getNicName())).when(nic != null && NetworkUtils.isVlan(nic));
}
#method_after
private ValidationResult validateAttachmentNotReferenceVlanDevice(NetworkAttachment attachment) {
    VdsNetworkInterface nic = existingInterfacesMap.get(attachment.getNicName());
    EngineMessage engineMessage = EngineMessage.ATTACHMENT_REFERENCE_VLAN_DEVICE;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, attachment.getNetworkName()), ReplacementUtils.createSetVariableString(VAR_NIC_NAME, attachment.getNicName())).when(nic != null && NetworkCommonUtils.isVlan(nic));
}
#end_block

#method_before
public boolean flush() {
    if (validate()) {
        diskModel.flush();
        DiskImage diskImage = (DiskImage) getDiskModel().getDisk();
        diskImage.setVolumeFormat(getVolumeFormat().getSelectedItem());
        diskImage.setActualSizeInBytes(getImageSize());
        diskImage.setVolumeType(AsyncDataProvider.getInstance().getVolumeType(getVolumeFormat().getSelectedItem(), getDiskModel().getStorageDomain().getSelectedItem().getStorageType()));
        return true;
    } else {
        setIsValid(false);
    }
    return false;
}
#method_after
public boolean flush() {
    if (validate()) {
        diskModel.flush();
        DiskImage diskImage = (DiskImage) getDiskModel().getDisk();
        diskImage.setActualSizeInBytes(getImageSize());
        diskImage.setVolumeFormat(getImageInfoModel().getFormat());
        diskImage.setVolumeType(AsyncDataProvider.getInstance().getVolumeType(diskImage.getVolumeFormat(), getDiskModel().getStorageDomain().getSelectedItem().getStorageType()));
        return true;
    } else {
        setIsValid(false);
    }
    return false;
}
#end_block

#method_before
public boolean validate() {
    boolean uploadImageIsValid;
    if (getImageSourceLocalEnabled().getEntity()) {
        getImagePath().validateEntity(new IValidation[] { new IValidation() {

            @Override
            public ValidationResult validate(Object value) {
                ValidationResult result = new ValidationResult();
                if (value == null || StringHelper.isNullOrEmpty((String) value)) {
                    result.setSuccess(false);
                    result.getReasons().add(ConstantsManager.getInstance().getConstants().emptyImagePath());
                }
                return result;
            }
        } });
        uploadImageIsValid = getImagePath().getIsValid();
        getInvalidityReasons().addAll(getImagePath().getInvalidityReasons());
    } else {
        // TODO remote/download
        uploadImageIsValid = false;
    }
    return uploadImageIsValid && diskModel.validate();
}
#method_after
public boolean validate() {
    boolean uploadImageIsValid;
    setIsValid(true);
    getInvalidityReasons().clear();
    getImageInfoModel().getInvalidityReasons().clear();
    if (getImageSourceLocalEnabled().getEntity()) {
        getImagePath().validateEntity(new IValidation[] { new IValidation() {

            @Override
            public ValidationResult validate(Object value) {
                ValidationResult result = new ValidationResult();
                if (value == null || StringHelper.isNullOrEmpty((String) value)) {
                    result.setSuccess(false);
                    result.getReasons().add(constants.emptyImagePath());
                }
                return result;
            }
        } });
        if (getImagePath().getIsValid()) {
            getImageInfoModel().validateEntity(new IValidation[] { new IValidation() {

                @Override
                public ValidationResult validate(Object value) {
                    ValidationResult result = new ValidationResult();
                    ImageInfoModel.QemuCompat qcowCompat = getImageInfoModel().getQcowCompat();
                    if (qcowCompat != null && qcowCompat != ImageInfoModel.QemuCompat.V2) {
                        StorageFormatType storageFormatType = getDiskModel().getStorageDomain().getSelectedItem().getStorageFormat();
                        switch(storageFormatType) {
                            case V1:
                            case V2:
                            case V3:
                                result.setSuccess(false);
                                result.getReasons().add(messages.uploadImageQemuCompatUnsupported(qcowCompat.getValue(), storageFormatType.name()));
                                break;
                        }
                    }
                    return result;
                }
            } });
        }
        uploadImageIsValid = getImagePath().getIsValid() && getImageInfoModel().validate();
        getInvalidityReasons().addAll(getImagePath().getInvalidityReasons());
        getInvalidityReasons().addAll(getImageInfoModel().getInvalidityReasons());
    } else {
        // TODO remote/download
        uploadImageIsValid = false;
    }
    return uploadImageIsValid && diskModel.validate();
}
#end_block

#method_before
private void finalizeImageUpload() {
    if (getUploadState() == UploadState.ENGINE_PAUSE) {
        // $NON-NLS-1$
        log.info("Upload paused; stopping model execution");
        return;
    }
    ImageTransferUpdates updates = new ImageTransferUpdates();
    UploadImageStatusParameters statusParameters = new UploadImageStatusParameters(getCommandId(), updates);
    if (getUploadState() == UploadState.SUCCESS) {
        // $NON-NLS-1$
        setProgressStr("Finalizing success...");
        statusParameters.getUpdates().setPhase(ImageTransferPhase.FINALIZING_SUCCESS);
    } else if (getUploadState() == UploadState.CLIENT_ERROR) {
        // $NON-NLS-1$
        setProgressStr("Pausing due to client error");
        statusParameters.getUpdates().setPhase(ImageTransferPhase.PAUSED_SYSTEM);
        statusParameters.setDiskId(getImageId());
        statusParameters.setAuditLogType(auditLogMessage);
    } else {
        // $NON-NLS-1$
        setProgressStr("Finalizing failure...");
        statusParameters.getUpdates().setPhase(ImageTransferPhase.FINALIZING_FAILURE);
    }
    // $NON-NLS-1$
    log.info("Updating status to {}", statusParameters.getUpdates().getPhase());
    Frontend.getInstance().runAction(VdcActionType.UploadImageStatus, statusParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            if (!result.getReturnValue().getSucceeded()) {
                if (++failedFinalizationAttempts < MAX_FAILED_POLL_ATTEMPTS) {
                    finalizeImageUpload();
                } else {
                    setContinuePolling(false);
                    // $NON-NLS-1$
                    setProgressStr("Failed to update upload status on engine");
                }
            }
        }
    });
}
#method_after
private void finalizeImageUpload() {
    if (getUploadState() == UploadState.ENGINE_PAUSE) {
        // $NON-NLS-1$
        log.info("Upload paused; stopping model execution");
        return;
    }
    ImageTransferUpdates updates = new ImageTransferUpdates();
    UploadImageStatusParameters statusParameters = new UploadImageStatusParameters(getCommandId(), updates);
    if (getUploadState() == UploadState.SUCCESS) {
        // $NON-NLS-1$
        setProgressStr("Finalizing success...");
        statusParameters.getUpdates().setPhase(ImageTransferPhase.FINALIZING_SUCCESS);
    } else if (getUploadState() == UploadState.CLIENT_ERROR) {
        // $NON-NLS-1$
        setProgressStr("Pausing due to client error");
        statusParameters.getUpdates().setPhase(ImageTransferPhase.PAUSED_SYSTEM);
        statusParameters.setDiskId(getImageId());
        statusParameters.setAuditLogType(auditLogType);
    } else {
        // $NON-NLS-1$
        setProgressStr("Finalizing failure...");
        statusParameters.getUpdates().setPhase(ImageTransferPhase.FINALIZING_FAILURE);
    }
    // $NON-NLS-1$
    log.info("Updating status to {}", statusParameters.getUpdates().getPhase());
    Frontend.getInstance().runAction(VdcActionType.UploadImageStatus, statusParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            if (!result.getReturnValue().getSucceeded()) {
                if (++failedFinalizationAttempts < MAX_FAILED_POLL_ATTEMPTS) {
                    finalizeImageUpload();
                } else {
                    setContinuePolling(false);
                    // $NON-NLS-1$
                    setProgressStr("Failed to update upload status on engine");
                }
            }
        }
    });
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getParameters().getUploadImageCommandId() == null && getParameters().getDiskId() == null) {
        log.error("Invalid parameters: command or disk id must be specified");
        setSucceeded(false);
    }
    ImageTransfer entity;
    if (getParameters().getUploadImageCommandId() != null) {
        entity = getDbFacade().getImageTransferDao().get(getParameters().getUploadImageCommandId());
    } else {
        entity = getDbFacade().getImageTransferDao().getByDiskId(getParameters().getDiskId());
    }
    if (entity != null) {
        // Always update; this serves as a keepalive
        entity = UploadImageCommand.updateEntity(getParameters().getUpdates(), entity.getId());
    } else {
        // with phase "UNKNOWN" and the UI will know what to do.
        if (getParameters().getUploadImageCommandId() != null) {
            log.info("UploadImageStatus request for missing or removed entity, command id {}", getParameters().getUploadImageCommandId());
        } else {
            log.info("UploadImageStatus request for missing or removed entity, disk id {}", getParameters().getDiskId());
        }
        entity = new ImageTransfer();
        entity.setId(getParameters().getUploadImageCommandId());
        entity.setPhase(ImageTransferPhase.UNKNOWN);
    }
    setSucceeded(true);
    getReturnValue().setActionReturnValue(entity);
}
#method_after
@Override
protected void executeCommand() {
    if (getParameters().getUploadImageCommandId() == null && getParameters().getDiskId() == null) {
        log.error("Invalid parameters: command or disk id must be specified");
        setSucceeded(false);
    }
    ImageTransfer entity;
    if (getParameters().getUploadImageCommandId() != null) {
        entity = imageTransferDao.get(getParameters().getUploadImageCommandId());
    } else {
        entity = imageTransferDao.getByDiskId(getParameters().getDiskId());
    }
    if (entity != null) {
        // Always update; this serves as a keepalive
        entity = imageTransferUpdater.updateEntity(getParameters().getUpdates(), entity.getId());
    } else {
        // with phase "UNKNOWN" and the UI will know what to do.
        if (getParameters().getUploadImageCommandId() != null) {
            log.info("UploadImageStatus request for missing or removed entity, command id {}", getParameters().getUploadImageCommandId());
        } else {
            log.info("UploadImageStatus request for missing or removed entity, disk id {}", getParameters().getDiskId());
        }
        entity = new ImageTransfer();
        entity.setId(getParameters().getUploadImageCommandId());
        entity.setPhase(ImageTransferPhase.UNKNOWN);
    }
    setSucceeded(true);
    getReturnValue().setActionReturnValue(entity);
}
#end_block

#method_before
public boolean consume(QuotaConsumptionParametersWrapper parameters) throws InvalidQuotaParametersException {
    Pair<AuditLogType, AuditLogableBase> auditLogPair = new Pair<>();
    auditLogPair.setSecond(parameters.getAuditLogable());
    StoragePool storagePool = parameters.getAuditLogable().getStoragePool();
    if (storagePool == null) {
        throw new InvalidQuotaParametersException("Null storage pool passed to QuotaManager");
    }
    lock.writeLock().lock();
    try {
        if (!storagePoolQuotaMap.containsKey(storagePool.getId())) {
            storagePoolQuotaMap.put(storagePool.getId(), new HashMap<>());
        }
    } finally {
        lock.writeLock().unlock();
    }
    boolean isQuotaEnabled = parameters.getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED;
    boolean result = true;
    lock.readLock().lock();
    try {
        if (isQuotaEnabled) {
            synchronized (storagePoolQuotaMap.get(storagePool.getId())) {
                result = validateAndCompleteParameters(parameters, auditLogPair) && internalConsumeAndReleaseHandler(parameters, auditLogPair);
            }
        }
    } finally {
        lock.readLock().unlock();
        getQuotaManagerAuditLogger().auditLog(auditLogPair.getFirst(), auditLogPair.getSecond());
    }
    return result;
}
#method_after
public boolean consume(QuotaConsumptionParametersWrapper parameters) throws InvalidQuotaParametersException {
    Pair<AuditLogType, AuditLogableBase> auditLogPair = new Pair<>();
    auditLogPair.setSecond(parameters.getAuditLogable());
    StoragePool storagePool = parameters.getAuditLogable().getStoragePool();
    if (storagePool == null) {
        throw new InvalidQuotaParametersException("Null storage pool passed to QuotaManager");
    }
    lock.writeLock().lock();
    try {
        if (!storagePoolQuotaMap.containsKey(storagePool.getId())) {
            storagePoolQuotaMap.put(storagePool.getId(), new HashMap<>());
        }
    } finally {
        lock.writeLock().unlock();
    }
    lock.readLock().lock();
    try {
        if (parameters.getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
            synchronized (storagePoolQuotaMap.get(storagePool.getId())) {
                return validateAndCompleteParameters(parameters, auditLogPair) && internalConsumeAndReleaseHandler(parameters, auditLogPair);
            }
        }
    } finally {
        lock.readLock().unlock();
        getQuotaManagerAuditLogger().auditLog(auditLogPair.getFirst(), auditLogPair.getSecond());
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!checkQuotaValidationCommon(getParameters().getQuota())) {
        return false;
    }
    if (getQuotaDao().getById(getParameters().getQuota().getId()) == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    return validateQuotaNotDefault(getParameters().getQuota().getId());
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (getQuotaDao().getById(getParameters().getQuota().getId()) == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    return validateQuotaNotDefault(getParameters().getQuota().getId());
}
#end_block

#method_before
public void perform(List<Pair<VM, VdsmVm>> monitoredVms, long fetchTime, VdsManager vdsManager, boolean updateStatistics) {
    if (monitoredVms.isEmpty()) {
        return;
    }
    ArrayList<VmAnalyzer> vmAnalyzers = new ArrayList<>();
    try {
        analyzeVms(monitoredVms, fetchTime, vdsManager, updateStatistics, vmAnalyzers);
        // It is important to add the unmanaged VMs before flushing the dynamic data into the database
        addUnmanagedVms(vmAnalyzers, vdsManager.getVdsId());
        flush(vmAnalyzers);
        postFlush(vmAnalyzers, vdsManager);
        vdsManager.vmsMonitoringInitFinished();
    } catch (RuntimeException ex) {
        log.error("Failed during vms monitoring on host {} error is: {}", vdsManager.getVdsName(), ex);
        log.error("Exception:", ex);
    } finally {
        unlockVms(vmAnalyzers);
    }
}
#method_after
public void perform(List<Pair<VmDynamic, VdsmVm>> monitoredVms, long fetchTime, VdsManager vdsManager, boolean updateStatistics) {
    if (monitoredVms.isEmpty()) {
        return;
    }
    List<VmAnalyzer> vmAnalyzers = Collections.emptyList();
    try {
        vmAnalyzers = analyzeVms(monitoredVms, fetchTime, vdsManager, updateStatistics);
        // It is important to add the unmanaged VMs before flushing the dynamic data into the database
        addUnmanagedVms(vmAnalyzers, vdsManager.getVdsId());
        flush(vmAnalyzers);
        postFlush(vmAnalyzers, vdsManager);
        vdsManager.vmsMonitoringInitFinished();
    } catch (RuntimeException ex) {
        log.error("Failed during vms monitoring on host {} error is: {}", vdsManager.getVdsName(), ex);
        log.error("Exception:", ex);
    } finally {
        unlockVms(vmAnalyzers);
    }
}
#end_block

#method_before
private void analyzeVms(List<Pair<VM, VdsmVm>> monitoredVms, long fetchTime, VdsManager vdsManager, boolean updateStatistics, ArrayList<VmAnalyzer> vmAnalyzersOut) {
    VmAnalyzerFactory vmAnalyzerFactory = getVmAnalyzerFactory(vdsManager, updateStatistics);
    vmAnalyzersOut.ensureCapacity(monitoredVms.size());
    monitoredVms.forEach(vm -> {
        // TODO filter out migratingTo VMs if no action is taken on them
        if (shouldAnalyzeVm(vm, fetchTime, vdsManager.getVdsId())) {
            VmAnalyzer vmAnalyzer = vmAnalyzerFactory.getVmAnalyzer(vm);
            vmAnalyzersOut.add(vmAnalyzer);
            vmAnalyzer.analyze();
        }
    });
}
#method_after
private List<VmAnalyzer> analyzeVms(List<Pair<VmDynamic, VdsmVm>> monitoredVms, long fetchTime, VdsManager vdsManager, boolean updateStatistics) {
    VmAnalyzerFactory vmAnalyzerFactory = getVmAnalyzerFactory(vdsManager, updateStatistics);
    List<VmAnalyzer> vmAnalyzers = new ArrayList<>(monitoredVms.size());
    monitoredVms.forEach(vm -> {
        // TODO filter out migratingTo VMs if no action is taken on them
        if (shouldAnalyzeVm(vm, fetchTime, vdsManager.getVdsId())) {
            try {
                VmAnalyzer vmAnalyzer = vmAnalyzerFactory.getVmAnalyzer(vm);
                vmAnalyzer.analyze();
                vmAnalyzers.add(vmAnalyzer);
            } catch (RuntimeException ex) {
                Guid vmId = getVmId(vm.getFirst(), vm.getSecond());
                VmManager vmManager = resourceManager.getVmManager(vmId);
                vmManager.unlock();
                log.error("Failed during monitoring vm: {} , error is: {}", vmId, ex);
                log.error("Exception:", ex);
            }
        }
    });
    return vmAnalyzers;
}
#end_block

#method_before
protected VmAnalyzerFactory getVmAnalyzerFactory(VdsManager vdsManager, boolean statistics) {
    return new VmAnalyzerFactory(vdsManager, statistics, auditLogDirector, resourceManager, vmDao, vmNetworkInterfaceDao, vdsDynamicDao, vdsNumaNodeDao, vmNumaNodeDao);
}
#method_after
protected VmAnalyzerFactory getVmAnalyzerFactory(VdsManager vdsManager, boolean statistics) {
    return new VmAnalyzerFactory(vdsManager, statistics, auditLogDirector, resourceManager, vmDynamicDao, vmNetworkInterfaceDao, vdsDynamicDao, vdsNumaNodeDao, vmNumaNodeDao);
}
#end_block

#method_before
private boolean shouldAnalyzeVm(Pair<VM, VdsmVm> pair, long fetchTime, Guid vdsId) {
    Guid vmId = getVmId(pair.getFirst(), pair.getSecond());
    VmManager vmManager = resourceManager.getVmManager(vmId);
    if (!vmManager.trylock()) {
        log.debug("skipping VM '{}' from this monitoring cycle" + " - the VM is locked by its VmManager ", vmId);
        return false;
    }
    if (!vmManager.isLatestData(pair.getSecond(), vdsId)) {
        log.warn("skipping VM '{}' from this monitoring cycle" + " - newer VM data was already processed", vmId);
        vmManager.unlock();
        return false;
    }
    if (vmManager.getVmDataChangedTime() != null && fetchTime - vmManager.getVmDataChangedTime() <= 0) {
        log.warn("skipping VM '{}' from this monitoring cycle" + " - the VM data has changed since fetching the data", vmId);
        vmManager.unlock();
        return false;
    }
    return true;
}
#method_after
private boolean shouldAnalyzeVm(Pair<VmDynamic, VdsmVm> pair, long fetchTime, Guid vdsId) {
    Guid vmId = getVmId(pair.getFirst(), pair.getSecond());
    VmManager vmManager = resourceManager.getVmManager(vmId);
    if (!vmManager.trylock()) {
        log.debug("skipping VM '{}' from this monitoring cycle" + " - the VM is locked by its VmManager ", vmId);
        return false;
    }
    if (!vmManager.isLatestData(pair.getSecond(), vdsId)) {
        log.warn("skipping VM '{}' from this monitoring cycle" + " - newer VM data was already processed", vmId);
        vmManager.unlock();
        return false;
    }
    if (vmManager.getVmDataChangedTime() != null && fetchTime - vmManager.getVmDataChangedTime() <= 0) {
        log.warn("skipping VM '{}' from this monitoring cycle" + " - the VM data has changed since fetching the data", vmId);
        vmManager.unlock();
        return false;
    }
    return true;
}
#end_block

#method_before
// ***** Helpers and sub-methods *****
static Guid getVmId(VM dbVm, VdsmVm vdsmVm) {
    return dbVm != null ? dbVm.getId() : vdsmVm.getVmDynamic().getId();
}
#method_after
// ***** Helpers and sub-methods *****
static Guid getVmId(VmDynamic dbVm, VdsmVm vdsmVm) {
    return dbVm != null ? dbVm.getId() : vdsmVm.getVmDynamic().getId();
}
#end_block

#method_before
private ImageTransfer updateEntity(ImageTransferUpdates updates) {
    return updateEntity(updates, getCommandId(), imageTransferDao);
}
#method_after
private ImageTransfer updateEntity(ImageTransferUpdates updates) {
    return imageTransferUpdater.updateEntity(updates, getCommandId());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getParameters().getUploadImageCommandId() == null && getParameters().getDiskId() == null) {
        log.error("Invalid parameters: command or disk id must be specified");
        setSucceeded(false);
    }
    ImageTransfer entity;
    if (getParameters().getUploadImageCommandId() != null) {
        entity = imageTransferDao.get(getParameters().getUploadImageCommandId());
    } else {
        entity = imageTransferDao.getByDiskId(getParameters().getDiskId());
    }
    if (entity != null) {
        // Always update; this serves as a keepalive
        entity = UploadImageCommand.updateEntity(getParameters().getUpdates(), entity.getId(), imageTransferDao);
    } else {
        // with phase "UNKNOWN" and the UI will know what to do.
        if (getParameters().getUploadImageCommandId() != null) {
            log.info("UploadImageStatus request for missing or removed entity, command id {}", getParameters().getUploadImageCommandId());
        } else {
            log.info("UploadImageStatus request for missing or removed entity, disk id {}", getParameters().getDiskId());
        }
        entity = new ImageTransfer();
        entity.setId(getParameters().getUploadImageCommandId());
        entity.setPhase(ImageTransferPhase.UNKNOWN);
    }
    setSucceeded(true);
    getReturnValue().setActionReturnValue(entity);
}
#method_after
@Override
protected void executeCommand() {
    if (getParameters().getUploadImageCommandId() == null && getParameters().getDiskId() == null) {
        log.error("Invalid parameters: command or disk id must be specified");
        setSucceeded(false);
    }
    ImageTransfer entity;
    if (getParameters().getUploadImageCommandId() != null) {
        entity = imageTransferDao.get(getParameters().getUploadImageCommandId());
    } else {
        entity = imageTransferDao.getByDiskId(getParameters().getDiskId());
    }
    if (entity != null) {
        // Always update; this serves as a keepalive
        entity = imageTransferUpdater.updateEntity(getParameters().getUpdates(), entity.getId());
    } else {
        // with phase "UNKNOWN" and the UI will know what to do.
        if (getParameters().getUploadImageCommandId() != null) {
            log.info("UploadImageStatus request for missing or removed entity, command id {}", getParameters().getUploadImageCommandId());
        } else {
            log.info("UploadImageStatus request for missing or removed entity, disk id {}", getParameters().getDiskId());
        }
        entity = new ImageTransfer();
        entity.setId(getParameters().getUploadImageCommandId());
        entity.setPhase(ImageTransferPhase.UNKNOWN);
    }
    setSucceeded(true);
    getReturnValue().setActionReturnValue(entity);
}
#end_block

#method_before
private void endAction(CommandBase<?> commandBase, List<Guid> childCmdIds, boolean succeeded) {
    if (shouldExecuteEndMethod(commandBase)) {
        commandBase.getReturnValue().setSucceeded(false);
        VdcReturnValueBase returnVal = commandBase.endAction();
        if (!returnVal.getSucceeded() && shouldRepeatEndMethodsOnFail(returnVal)) {
            throw new EngineException(EngineError.ENGINE, String.format("Command %1$s id: '%2$s' endAction() " + "didn't complete successfully", commandBase.getActionType(), commandBase.getCommandId()));
        }
        if (commandBase.getParameters().getParentCommand() == VdcActionType.Unknown) {
            CommandCoordinatorUtil.removeAllCommandsInHierarchy(commandBase.getCommandId());
        }
        ExecutionHandler.endJob(commandBase.getExecutionContext(), succeeded);
    }
}
#method_after
private void endAction(CommandBase<?> commandBase, List<Guid> childCmdIds, boolean succeeded) {
    if (shouldExecuteEndMethod(commandBase)) {
        commandBase.getReturnValue().setSucceeded(false);
        VdcReturnValueBase returnVal = commandBase.endAction();
        if (!returnVal.getSucceeded()) {
            if (shouldRepeatEndMethodsOnFail(returnVal)) {
                throw new EngineException(EngineError.ENGINE, String.format("Command %1$s id: '%2$s' endAction() " + "didn't complete successfully", commandBase.getActionType(), commandBase.getCommandId()));
            } else {
                log.warn("Command '{}' id: '{}' end method execution failed, as the command isn't marked for " + "endAction() retries silently ignoring", commandBase.getActionType(), commandBase.getCommandId());
            }
        }
        if (commandBase.getParameters().getParentCommand() == VdcActionType.Unknown) {
            CommandCoordinatorUtil.removeAllCommandsInHierarchy(commandBase.getCommandId());
        }
        ExecutionHandler.getInstance().endJob(commandBase.getExecutionContext(), succeeded);
    }
}
#end_block

#method_before
public static void handleCredentials(SsoContext ssoContext, HttpServletRequest request, Credentials credentials, boolean isInteractive) throws Exception {
    log.debug("Entered AuthenticationUtils.handleCredentials");
    if (StringUtils.isEmpty(credentials.getUsername()) || StringUtils.isEmpty(credentials.getProfile())) {
        throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_PROVIDE_USERNAME_PASSWORD_AND_PROFILE, (Locale) request.getAttribute(SsoConstants.LOCALE)));
    }
    SsoSession ssoSession = login(ssoContext, request, credentials, null, isInteractive);
    log.info("User {}@{} successfully logged in with scopes: {}", credentials.getUsername(), credentials.getProfile(), ssoSession.getScope());
}
#method_after
public static void handleCredentials(SsoContext ssoContext, HttpServletRequest request, Credentials credentials, boolean interactive) throws Exception {
    log.debug("Entered AuthenticationUtils.handleCredentials");
    if (StringUtils.isEmpty(credentials.getUsername()) || StringUtils.isEmpty(credentials.getProfile())) {
        throw new AuthenticationException(ssoContext.getLocalizationUtils().localize(SsoConstants.APP_ERROR_PROVIDE_USERNAME_PASSWORD_AND_PROFILE, (Locale) request.getAttribute(SsoConstants.LOCALE)));
    }
    SsoSession ssoSession = login(ssoContext, request, credentials, null, interactive);
    log.info("User {}@{} successfully logged in with scopes: {}", credentials.getUsername(), credentials.getProfile(), ssoSession.getScope());
}
#end_block

#method_before
private static SsoSession login(SsoContext ssoContext, HttpServletRequest request, Credentials credentials, ExtMap authRecord, boolean isInteractive) throws Exception {
    ExtensionProfile profile = getExtensionProfile(ssoContext, credentials.getProfile());
    String user = mapUser(profile, credentials);
    if (authRecord == null) {
        log.debug("AuthenticationUtils.handleCredentials invoking AUTHENTICATE_CREDENTIALS on authn");
        ExtMap outputMap = profile.authn.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS).mput(Authn.InvokeKeys.USER, user).mput(Authn.InvokeKeys.CREDENTIALS, credentials.getPassword()));
        if (outputMap.<Integer>get(Base.InvokeKeys.RESULT) != Base.InvokeResult.SUCCESS || outputMap.<Integer>get(Authn.InvokeKeys.RESULT) != Authn.AuthResult.SUCCESS) {
            if (isInteractive) {
                SsoUtils.getSsoSession(request).setChangePasswdCredentials(credentials);
            }
            log.debug("AuthenticationUtils.handleCredentials AUTHENTICATE_CREDENTIALS on authn failed");
            throw new AuthenticationException(AuthnMessageMapper.mapMessageErrorCode(ssoContext, request, credentials.getProfile(), outputMap));
        }
        log.debug("AuthenticationUtils.handleCredentials AUTHENTICATE_CREDENTIALS on authn succeeded");
        authRecord = outputMap.get(Authn.InvokeKeys.AUTH_RECORD);
    }
    if (profile.mapper != null) {
        log.debug("AuthenticationUtils.handleCredentials invoking MAP_AUTH_RECORD on mapper");
        authRecord = profile.mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord), true).get(Authn.InvokeKeys.AUTH_RECORD, authRecord);
    }
    log.debug("AuthenticationUtils.handleCredentials invoking FETCH_PRINCIPAL_RECORD on authz");
    ExtMap output = profile.authz.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.FETCH_PRINCIPAL_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord).mput(Authz.InvokeKeys.QUERY_FLAGS, Authz.QueryFlags.RESOLVE_GROUPS | Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE));
    log.debug("AuthenticationUtils.handleCredentials saving data in session data");
    return SsoUtils.persistAuthInfoInContextWithToken(request, credentials.getPassword(), credentials.getProfile(), authRecord, output.get(Authz.InvokeKeys.PRINCIPAL_RECORD));
}
#method_after
private static SsoSession login(SsoContext ssoContext, HttpServletRequest request, Credentials credentials, ExtMap authRecord, boolean interactive) throws Exception {
    ExtensionProfile profile = getExtensionProfile(ssoContext, credentials.getProfile());
    String user = mapUser(profile, credentials);
    if (authRecord == null) {
        log.debug("AuthenticationUtils.handleCredentials invoking AUTHENTICATE_CREDENTIALS on authn");
        ExtMap outputMap = profile.authn.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS).mput(Authn.InvokeKeys.USER, user).mput(Authn.InvokeKeys.CREDENTIALS, credentials.getPassword()));
        if (outputMap.<Integer>get(Base.InvokeKeys.RESULT) != Base.InvokeResult.SUCCESS || outputMap.<Integer>get(Authn.InvokeKeys.RESULT) != Authn.AuthResult.SUCCESS) {
            if (interactive) {
                SsoUtils.getSsoSession(request).setChangePasswdCredentials(credentials);
            }
            log.debug("AuthenticationUtils.handleCredentials AUTHENTICATE_CREDENTIALS on authn failed");
            throw new AuthenticationException(AuthnMessageMapper.mapMessageErrorCode(ssoContext, request, credentials.getProfile(), outputMap));
        }
        log.debug("AuthenticationUtils.handleCredentials AUTHENTICATE_CREDENTIALS on authn succeeded");
        authRecord = outputMap.get(Authn.InvokeKeys.AUTH_RECORD);
    }
    if (profile.mapper != null) {
        log.debug("AuthenticationUtils.handleCredentials invoking MAP_AUTH_RECORD on mapper");
        authRecord = profile.mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord), true).get(Authn.InvokeKeys.AUTH_RECORD, authRecord);
    }
    log.debug("AuthenticationUtils.handleCredentials invoking FETCH_PRINCIPAL_RECORD on authz");
    ExtMap output = profile.authz.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.FETCH_PRINCIPAL_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord).mput(Authz.InvokeKeys.QUERY_FLAGS, Authz.QueryFlags.RESOLVE_GROUPS | Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE));
    log.debug("AuthenticationUtils.handleCredentials saving data in session data");
    return SsoUtils.persistAuthInfoInContextWithToken(request, credentials.getPassword(), credentials.getProfile(), authRecord, output.get(Authz.InvokeKeys.PRINCIPAL_RECORD));
}
#end_block

#method_before
@Override
public void onBrowserEvent(Context context, Element parent, GlusterVolumeEntity volume, SafeHtml tooltipContent, NativeEvent event, ValueUpdater<GlusterVolumeEntity> valueUpdater) {
    VolumeStatus status = GlusterVolumeUtils.getVolumeStatus(volume);
    if (BrowserEvents.CLICK.equals(event.getType()) && onClickCommand != null && (status == VolumeStatus.ALL_BRICKS_DOWN || status == VolumeStatus.SOME_BRICKS_DOWN)) {
        onClickCommand.execute();
    } else {
        super.onBrowserEvent(context, parent, volume, tooltipContent, event, valueUpdater);
    }
}
#method_after
@Override
public void onBrowserEvent(Context context, Element parent, GlusterVolumeEntity volume, SafeHtml tooltipContent, NativeEvent event, ValueUpdater<GlusterVolumeEntity> valueUpdater) {
    super.onBrowserEvent(context, parent, volume, tooltipContent, event, valueUpdater);
    VolumeStatus status = GlusterVolumeUtils.getVolumeStatus(volume);
    if (BrowserEvents.CLICK.equals(event.getType()) && onClickCommand != null && (status == VolumeStatus.ALL_BRICKS_DOWN || status == VolumeStatus.SOME_BRICKS_DOWN)) {
        onClickCommand.execute();
    }
}
#end_block

#method_before
private boolean updateVms() {
    for (VM vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeToVersion(getParameters().getCluster().getCompatibilityVersion());
        VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            getReturnValue().setFault(result.getFault());
            return false;
        }
    }
    return true;
}
#method_after
private boolean updateVms() {
    for (VM vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            getReturnValue().setFault(result.getFault());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldCluster == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldCluster.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = getVdsDao().getAllForCluster(oldCluster.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldCluster, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldCluster.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForCluster(oldCluster.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result && !oldCluster.getCompatibilityVersion().equals(getCluster().getCompatibilityVersion())) {
        for (VM vm : vmList) {
            if (vm.isPreviewSnapshot()) {
                // can't change cluster version when a VM is in preview
                if (result) {
                    addValidationMessage(EngineMessage.CLUSTER_VERSION_CHANGE_VM_PREVIEW);
                    // and continue with adding validation messages
                    result = false;
                }
                addValidationMessage(vm.getName());
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldCluster);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getClusterDao().getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldCluster);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    if (result && Version.v3_6.compareTo(getCluster().getCompatibilityVersion()) <= 0) {
        List<String> names = new ArrayList<>();
        for (VDS host : allForCluster) {
            if (VdsProtocol.XML == host.getProtocol()) {
                names.add(host.getName());
            }
        }
        if (!names.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_WRONG_PROTOCOL_FOR_CLUSTER_VERSION);
        }
    }
    return result;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldCluster == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldCluster.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = getVdsDao().getAllForCluster(oldCluster.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_CLUSTER_WITH_HOSTS_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldCluster, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldCluster.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForCluster(oldCluster.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result && !oldCluster.getCompatibilityVersion().equals(getCluster().getCompatibilityVersion())) {
        for (VM vm : vmList) {
            if (vm.isPreviewSnapshot()) {
                // can't change cluster version when a VM is in preview
                if (result) {
                    addValidationMessage(EngineMessage.CLUSTER_VERSION_CHANGE_VM_PREVIEW);
                    // and continue with adding validation messages
                    result = false;
                }
                addValidationMessage(vm.getName());
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldCluster);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getClusterDao().getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldCluster);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    if (result && Version.v3_6.compareTo(getCluster().getCompatibilityVersion()) <= 0) {
        List<String> names = new ArrayList<>();
        for (VDS host : allForCluster) {
            if (VdsProtocol.XML == host.getProtocol()) {
                names.add(host.getName());
            }
        }
        if (!names.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_WRONG_PROTOCOL_FOR_CLUSTER_VERSION);
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    final boolean versionChanged = !Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion());
    if (!versionChanged) {
        return null;
    }
    final String lockMessage = EngineMessage.ACTION_TYPE_FAILED_CLUSTER_IS_BEING_UPDATED.name() + ReplacementUtils.createSetVariableString("clusterName", oldCluster.getName());
    vmsLockedForUpdate = getVmDao().getAllForCluster(oldCluster.getId()).stream().filter(vm -> !vm.isExternalVm() && !vm.isHostedEngine()).filter(// no need for VM device update
    vm -> vm.getCustomCompatibilityVersion() == null).collect(Collectors.toList());
    return vmsLockedForUpdate.stream().collect(Collectors.toMap(vm -> vm.getId().toString(), vm -> LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, lockMessage)));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    final boolean versionChanged = !Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion());
    if (!versionChanged) {
        return null;
    }
    final LockMessage lockMessage = new LockMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_IS_BEING_UPDATED).with("clusterName", oldCluster.getName());
    vmsLockedForUpdate = getVmDao().getAllForCluster(oldCluster.getId()).stream().filter(vm -> !vm.isExternalVm() && !vm.isHostedEngine()).filter(// no need for VM device update
    vm -> vm.getCustomCompatibilityVersion() == null).collect(Collectors.toList());
    return vmsLockedForUpdate.stream().collect(Collectors.toMap(vm -> vm.getId().toString(), vm -> LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, lockMessage)));
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
private void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(() -> {
        Deserializer deserializer = SerializationFactory.getDeserializer();
        List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDao().getAllForCommandId(commandId);
        log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
        for (BusinessEntitySnapshot snapshot : entitySnapshots) {
            Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
            Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
            log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString());
            Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
            switch(snapshot.getSnapshotType()) {
                case CHANGED_STATUS_ONLY:
                    EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                    ((StatusAwareDao<Serializable, Enum<?>>) getDaoForEntity(entityClass)).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                    break;
                case DELETED_OR_UPDATED_ENTITY:
                    deletedOrUpdateEntity(entityClass, (BusinessEntity<Serializable>) snapshotData);
                    break;
                case UPDATED_ONLY_ENTITY:
                    getDaoForEntity(entityClass).update((BusinessEntity<Serializable>) snapshotData);
                    break;
                case NEW_ENTITY_ID:
                    getDaoForEntity(entityClass).remove(snapshotData);
                    break;
                case TRANSIENT_ENTITY:
                    objectCompensation.compensate(CommandBase.this, (TransientCompensationBusinessEntity) snapshotData);
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Unknown %s value, unable to compensate value %s.", SnapshotType.class.getName(), snapshot.getSnapshotType()));
            }
        }
        // Clear compensation data only if there is compensation data
        if (!entitySnapshots.isEmpty()) {
            getCompensationContext().afterCompensationCleanup();
        }
        return null;
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
private void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    // If the compensation data is not for the command do not perform compensation.
    if (!commandId.equals(getCompensationContext().getCommandId())) {
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        Deserializer deserializer = SerializationFactory.getDeserializer();
        List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDao().getAllForCommandId(commandId);
        log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
        for (BusinessEntitySnapshot snapshot : entitySnapshots) {
            Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
            Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
            log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString());
            Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
            switch(snapshot.getSnapshotType()) {
                case CHANGED_STATUS_ONLY:
                    EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                    ((StatusAwareDao<Serializable, Enum<?>>) getDaoForEntity(entityClass)).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                    break;
                case DELETED_OR_UPDATED_ENTITY:
                    deletedOrUpdateEntity(entityClass, (BusinessEntity<Serializable>) snapshotData);
                    break;
                case UPDATED_ONLY_ENTITY:
                    getDaoForEntity(entityClass).update((BusinessEntity<Serializable>) snapshotData);
                    break;
                case NEW_ENTITY_ID:
                    getDaoForEntity(entityClass).remove(snapshotData);
                    break;
                case TRANSIENT_ENTITY:
                    objectCompensation.compensate(CommandBase.this, (TransientCompensationBusinessEntity) snapshotData);
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Unknown %s value, unable to compensate value %s.", SnapshotType.class.getName(), snapshot.getSnapshotType()));
            }
        }
        getCompensationContext().afterCompensationCleanup();
        return null;
    });
}
#end_block

#method_before
public ImportVmModel getSpecificImportModel() {
    selectedImportVmModel = null;
    switch(importSources.getSelectedItem()) {
        case EXPORT_DOMAIN:
            importFromExportDomainModel.setEntity(null);
            importFromExportDomainModel.init(getVmsToImport(), exportDomain.getEntity().getId());
            importFromExportDomainModel.setEntity(exportDomain.getEntity().getId());
            selectedImportVmModel = importFromExportDomainModel;
            break;
        case VMWARE:
            importFromExternalSourceModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            importFromExternalSourceModel.setUrl(getUrl());
            importFromExternalSourceModel.setUsername(getUsername().getEntity());
            importFromExternalSourceModel.setPassword(getPassword().getEntity());
            importFromExternalSourceModel.setProxyHostId(getProxyHosts().getSelectedItem() != null ? getProxyHosts().getSelectedItem().getId() : null);
            selectedImportVmModel = importFromExternalSourceModel;
            break;
        case OVA:
            importFromOvaModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            importFromOvaModel.setIsoName(getOvaPath().getEntity());
            importFromOvaModel.setHostId(getHosts().getSelectedItem().getId());
            selectedImportVmModel = importFromOvaModel;
            break;
        case XEN:
            importFromExternalSourceModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            importFromExternalSourceModel.setUrl(getXenUri().getEntity());
            // $NON-NLS-1$
            importFromExternalSourceModel.setUsername("");
            // $NON-NLS-1$
            importFromExternalSourceModel.setPassword("");
            importFromExternalSourceModel.setProxyHostId(getXenProxyHosts().getSelectedItem() != null ? getXenProxyHosts().getSelectedItem().getId() : null);
            selectedImportVmModel = importFromExternalSourceModel;
            break;
        case KVM:
            importFromExternalSourceModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            importFromExternalSourceModel.setUrl(getKvmUri().getEntity());
            importFromExternalSourceModel.setUsername(getKvmUsername().getEntity());
            importFromExternalSourceModel.setPassword(getKvmPassword().getEntity());
            importFromExternalSourceModel.setProxyHostId(getKvmProxyHosts().getSelectedItem() != null ? getKvmProxyHosts().getSelectedItem().getId() : null);
            selectedImportVmModel = importFromExternalSourceModel;
            break;
        default:
    }
    return selectedImportVmModel;
}
#method_after
public ImportVmModel getSpecificImportModel(boolean vmsToImportHaveFullInfo) {
    selectedImportVmModel = null;
    switch(importSources.getSelectedItem()) {
        case EXPORT_DOMAIN:
            importFromExportDomainModel.setEntity(null);
            importFromExportDomainModel.init(getVmsToImport(), exportDomain.getEntity().getId());
            importFromExportDomainModel.setEntity(exportDomain.getEntity().getId());
            selectedImportVmModel = importFromExportDomainModel;
            break;
        case VMWARE:
            if (vmsToImportHaveFullInfo) {
                importFromExternalSourceModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            }
            importFromExternalSourceModel.setUrl(getUrl());
            importFromExternalSourceModel.setUsername(getUsername().getEntity());
            importFromExternalSourceModel.setPassword(getPassword().getEntity());
            importFromExternalSourceModel.setProxyHostId(getProxyHosts().getSelectedItem() != null ? getProxyHosts().getSelectedItem().getId() : null);
            selectedImportVmModel = importFromExternalSourceModel;
            break;
        case OVA:
            importFromOvaModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            importFromOvaModel.setIsoName(getOvaPath().getEntity());
            importFromOvaModel.setHostId(getHosts().getSelectedItem().getId());
            selectedImportVmModel = importFromOvaModel;
            break;
        case XEN:
            if (vmsToImportHaveFullInfo) {
                importFromExternalSourceModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            }
            importFromExternalSourceModel.setUrl(getXenUri().getEntity());
            // $NON-NLS-1$
            importFromExternalSourceModel.setUsername("");
            // $NON-NLS-1$
            importFromExternalSourceModel.setPassword("");
            importFromExternalSourceModel.setProxyHostId(getXenProxyHosts().getSelectedItem() != null ? getXenProxyHosts().getSelectedItem().getId() : null);
            selectedImportVmModel = importFromExternalSourceModel;
            break;
        case KVM:
            if (vmsToImportHaveFullInfo) {
                importFromExternalSourceModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            }
            importFromExternalSourceModel.setUrl(getKvmUri().getEntity());
            importFromExternalSourceModel.setUsername(getKvmUsername().getEntity());
            importFromExternalSourceModel.setPassword(getKvmPassword().getEntity());
            importFromExternalSourceModel.setProxyHostId(getKvmProxyHosts().getSelectedItem() != null ? getKvmProxyHosts().getSelectedItem().getId() : null);
            selectedImportVmModel = importFromExternalSourceModel;
            break;
        default:
    }
    return selectedImportVmModel;
}
#end_block

#method_before
public void loadVmsFromKvm() {
    clearForLoad();
    if (!validateKvmConfiguration()) {
        return;
    }
    if (!getKvmRequiresAuthentication().getEntity()) {
        getKvmUsername().setEntity(null);
        getKvmPassword().setEntity(null);
    }
    Guid proxyId = getXenProxyHosts().getSelectedItem() != null ? getXenProxyHosts().getSelectedItem().getId() : null;
    loadVMsFromExternalProvider(OriginType.KVM, getKvmUri().getEntity(), getKvmUsername().getEntity(), getKvmPassword().getEntity(), proxyId);
}
#method_after
public void loadVmsFromKvm() {
    clearForLoad();
    if (!validateKvmConfiguration()) {
        return;
    }
    if (!getKvmRequiresAuthentication().getEntity()) {
        getKvmUsername().setEntity(null);
        getKvmPassword().setEntity(null);
    }
    Guid proxyId = getKvmProxyHosts().getSelectedItem() != null ? getKvmProxyHosts().getSelectedItem().getId() : null;
    loadVMsFromExternalProvider(OriginType.KVM, getKvmUri().getEntity(), getKvmUsername().getEntity(), getKvmPassword().getEntity(), proxyId);
}
#end_block

#method_before
private void loadVMsFromExternalProvider(final OriginType type, String uri, String username, String password, Guid proxyId) {
    startProgress();
    AsyncQuery query = new AsyncQuery(new AsyncCallback() {

        @Override
        public void onSuccess(Object returnValue) {
            if (returnValue instanceof VdcQueryReturnValue) {
                setError(messages.providerFailure());
                stopProgress();
            } else {
                List<VM> remoteVms = (List<VM>) returnValue;
                List<VM> remoteDownVms = new ArrayList<>();
                for (VM vm : remoteVms) {
                    if (vm.isDown()) {
                        remoteDownVms.add(vm);
                    }
                }
                if (remoteVms.size() != remoteDownVms.size()) {
                    setWarning(constants.runningVmsWereFilteredOnImportVm());
                }
                updateVms(remoteDownVms);
            }
        }
    });
    query.setHandleFailure(true);
    AsyncDataProvider.getInstance().getVmsFromExternalServer(query, getDataCenters().getSelectedItem().getId(), proxyId, uri, username, password, type);
}
#method_after
private void loadVMsFromExternalProvider(final OriginType type, String uri, String username, String password, Guid proxyId) {
    startProgress();
    AsyncQuery query = new AsyncQuery(new AsyncCallback() {

        @Override
        public void onSuccess(Object returnValue) {
            if (returnValue instanceof VdcQueryReturnValue) {
                setError(messages.providerFailure());
                stopProgress();
            } else {
                List<VM> remoteVms = (List<VM>) returnValue;
                List<VM> remoteDownVms = new ArrayList<>();
                for (VM vm : remoteVms) {
                    if (vm.isDown()) {
                        remoteDownVms.add(vm);
                    }
                }
                if (remoteVms.size() != remoteDownVms.size()) {
                    setWarning(constants.runningVmsWereFilteredOnImportVm());
                }
                updateVms(remoteDownVms);
            }
        }
    });
    query.setHandleFailure(true);
    AsyncDataProvider.getInstance().getVmsFromExternalServer(query, getDataCenters().getSelectedItem().getId(), proxyId, uri, username, password, type, null);
}
#end_block

#method_before
public boolean validateArchitectures() {
    final List<VM> vmsToImport = getVmsToImport();
    final StoragePool dataCenter = getDataCenters().getSelectedItem();
    if (vmsToImport.isEmpty() || dataCenter == null) {
        return false;
    }
    return validateSameArchitecture(vmsToImport) && validateClusterExistsForArchitecture(vmsToImport.get(0).getClusterArch(), dataCenter);
}
#method_after
public boolean validateArchitectures(List<VM> vmsToImport) {
    final StoragePool dataCenter = getDataCenters().getSelectedItem();
    if (vmsToImport.isEmpty() || dataCenter == null) {
        return false;
    }
    return validateSameArchitecture(vmsToImport) && validateClusterExistsForArchitecture(vmsToImport.get(0).getClusterArch(), dataCenter);
}
#end_block

#method_before
void initEntityModelCellTables() {
    externalVms.addColumn(new AbstractTextColumn<EntityModel<VM>>() {

        @Override
        public String getValue(EntityModel<VM> externalVmModel) {
            return toCellString(externalVmModel);
        }
    }, constants.name());
    importedVms.addColumn(new AbstractTextColumn<EntityModel<VM>>() {

        @Override
        public String getValue(EntityModel<VM> externalVmModel) {
            return toCellString(externalVmModel);
        }
    }, constants.name());
}
#method_after
void initEntityModelCellTables() {
    externalVms.addColumn(new AbstractTextColumn<EntityModel<VM>>() {

        @Override
        public String getValue(EntityModel<VM> externalVmModel) {
            return externalVmModel.getEntity().getName();
        }
    }, constants.name());
    importedVms.addColumn(new AbstractTextColumn<EntityModel<VM>>() {

        @Override
        public String getValue(EntityModel<VM> externalVmModel) {
            return externalVmModel.getEntity().getName();
        }
    }, constants.name());
}
#end_block

#method_before
@PostConstruct
private void handleUnmanagedCommands() {
    List<AsyncTask> asyncTasks = asyncTaskDao.getAll();
    Set<Guid> asyncTaskManagerManagedCommands = asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getRootCommandId()).collect(Collectors.toSet());
    asyncTaskManagerManagedCommands.addAll(asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getCommandId()).collect(Collectors.toSet()));
    // this will update all the commands that aren't managed by callback/async task manager and are active
    // and will set their status to ENDED_WITH_FAILURE.
    getCommands(false).stream().filter(x -> !x.isCallbackEnabled()).filter(x -> x.getCommandStatus() == CommandStatus.ACTIVE).filter(x -> !asyncTaskManagerManagedCommands.contains(x.getId())).forEach(x -> commandsCache.updateCommandStatus(x.getId(), CommandStatus.ENDED_WITH_FAILURE));
    // active commands managed by callbacks and not managed by async task manager need to reacquire locks
    // on engine restart
    getCommands(false).stream().filter(x -> x.isCallbackEnabled()).filter(x -> !x.isCallbackNotified()).filter(x -> x.getCommandStatus().isDuringExecution()).filter(x -> !asyncTaskManagerManagedCommands.contains(x.getId())).forEach(x -> {
        CommandBase<?> cmd = retrieveCommand(x.getId());
        if (cmd != null) {
            cmd.reacquireLocks();
        }
    });
}
#method_after
@PostConstruct
private void handleUnmanagedCommands() {
    List<AsyncTask> asyncTasks = asyncTaskDao.getAll();
    Set<Guid> asyncTaskManagerManagedCommands = asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getRootCommandId()).collect(Collectors.toSet());
    asyncTaskManagerManagedCommands.addAll(asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getCommandId()).collect(Collectors.toSet()));
    // this will update all the commands that aren't managed by callback/async task manager and are active
    // and will set their status to ENDED_WITH_FAILURE.
    getCommands(false).stream().filter(x -> !x.isCallbackEnabled()).filter(x -> x.getCommandStatus() == CommandStatus.ACTIVE).filter(x -> !asyncTaskManagerManagedCommands.contains(x.getId())).forEach(x -> commandsCache.updateCommandStatus(x.getId(), CommandStatus.ENDED_WITH_FAILURE));
    // active commands managed by callbacks and not managed by async task manager need to reacquire locks
    // on engine restart
    getCommands(false).stream().filter(x -> x.isCallbackEnabled()).filter(x -> !x.isCallbackNotified()).filter(x -> x.getCommandStatus().isDuringExecution()).filter(x -> !asyncTaskManagerManagedCommands.contains(x.getId())).map(x -> retrieveCommand(x.getId())).filter(Objects::nonNull).forEach(CommandBase::reacquireLocks);
}
#end_block

#method_before
private CommandBase<?> retrieveCommand(CommandEntity cmdEntity, CommandContext cmdContext) {
    CommandBase<?> command = null;
    if (cmdEntity != null) {
        if (cmdContext == null) {
            cmdContext = new CommandContext(new EngineContext()).withExecutionContext(new ExecutionContext());
        }
        command = CommandsFactory.createCommand(cmdEntity.getCommandType(), cmdEntity.getCommandParameters(), cmdContext);
        if (command == null) {
            log.info("Unable to reconstruct command '{}' using parameters '{}'.", cmdEntity.getCommandType(), cmdEntity.getCommandParameters());
        } else {
            command.setCommandStatus(cmdEntity.getCommandStatus(), false);
            command.setCommandData(cmdEntity.getData());
            command.setReturnValue(cmdEntity.getReturnValue());
            if (!Guid.isNullOrEmpty(cmdEntity.getParentCommandId()) && !cmdEntity.getParentCommandId().equals(cmdEntity.getId()) && command.getParameters().getParentParameters() == null) {
                CommandBase<?> parentCommand = retrieveCommand(cmdEntity.getParentCommandId());
                if (parentCommand != null) {
                    command.getParameters().setParentParameters(parentCommand.getParameters());
                }
            }
        }
    }
    return command;
}
#method_after
private CommandBase<?> retrieveCommand(CommandEntity cmdEntity, CommandContext cmdContext) {
    CommandBase<?> command = null;
    if (cmdEntity != null) {
        if (cmdContext == null) {
            cmdContext = new CommandContext(new EngineContext()).withExecutionContext(new ExecutionContext());
        }
        command = CommandsFactory.createCommand(cmdEntity.getCommandType(), cmdEntity.getCommandParameters(), cmdContext);
        if (command != null) {
            command.setCommandStatus(cmdEntity.getCommandStatus(), false);
            command.setCommandData(cmdEntity.getData());
            command.setReturnValue(cmdEntity.getReturnValue());
            if (!Guid.isNullOrEmpty(cmdEntity.getParentCommandId()) && !cmdEntity.getParentCommandId().equals(cmdEntity.getId()) && command.getParameters().getParentParameters() == null) {
                CommandBase<?> parentCommand = retrieveCommand(cmdEntity.getParentCommandId());
                if (parentCommand != null) {
                    command.getParameters().setParentParameters(parentCommand.getParameters());
                }
            }
        }
    }
    return command;
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldCluster == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldCluster.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = getVdsDao().getAllForCluster(oldCluster.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldCluster, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldCluster.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForCluster(oldCluster.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldCluster);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getClusterDao().getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldCluster);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    if (result && Version.v3_6.compareTo(getCluster().getCompatibilityVersion()) <= 0) {
        List<String> names = new ArrayList<>();
        for (VDS host : allForCluster) {
            if (VdsProtocol.XML == host.getProtocol()) {
                names.add(host.getName());
            }
        }
        if (!names.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_WRONG_PROTOCOL_FOR_CLUSTER_VERSION);
        }
    }
    return result;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    if (oldCluster == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldCluster.getName(), getCluster().getName())) {
        if (!isClusterUnique(getCluster().getName())) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        addValidationMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForCluster = getVdsDao().getAllForCluster(oldCluster.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_CLUSTER_WITH_HOSTS_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldCluster, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getCluster().supportsVirtService() && (oldCluster.getCpuName() != null || getCluster().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForCluster(oldCluster.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
            addValidationMessage(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
                result = false;
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldCluster);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("Cluster", getParameters().getCluster().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getClusterDao().getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                getReturnValue().getValidationMessages().add(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                addValidationMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        if (!(getCluster().supportsGlusterService() || getCluster().supportsVirtService())) {
            addValidationMessage(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addValidationMessage(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getCluster().supportsVirtService()) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getCluster().getId());
        if (volumes != null && volumes.size() > 0) {
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addValidationMessage(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy(oldCluster);
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                addValidationMessage(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    if (result && Version.v3_6.compareTo(getCluster().getCompatibilityVersion()) <= 0) {
        List<String> names = new ArrayList<>();
        for (VDS host : allForCluster) {
            if (VdsProtocol.XML == host.getProtocol()) {
                names.add(host.getName());
            }
        }
        if (!names.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_WRONG_PROTOCOL_FOR_CLUSTER_VERSION);
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    final boolean versionChanged = !Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion());
    if (!versionChanged) {
        return null;
    }
    final String lockMessage = EngineMessage.ACTION_TYPE_FAILED_CLUSTER_IS_BEING_UPDATED.name() + ReplacementUtils.createSetVariableString("clusterName", oldCluster.getName());
    vmsLockedForUpdate = getVmDao().getAllForCluster(oldCluster.getId()).stream().filter(vm -> !vm.isExternalVm() && !vm.isHostedEngine()).filter(// no need for VM device update
    vm -> vm.getCustomCompatibilityVersion() == null).collect(Collectors.toList());
    return vmsLockedForUpdate.stream().collect(Collectors.toMap(vm -> vm.getId().toString(), vm -> LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, lockMessage)));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    final boolean versionChanged = !Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion());
    if (!versionChanged) {
        return null;
    }
    final LockMessage lockMessage = new LockMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_IS_BEING_UPDATED).with("clusterName", oldCluster.getName());
    vmsLockedForUpdate = getVmDao().getAllForCluster(oldCluster.getId()).stream().filter(vm -> !vm.isExternalVm() && !vm.isHostedEngine()).filter(// no need for VM device update
    vm -> vm.getCustomCompatibilityVersion() == null).collect(Collectors.toList());
    return vmsLockedForUpdate.stream().collect(Collectors.toMap(vm -> vm.getId().toString(), vm -> LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, lockMessage)));
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new HostedEngineEditNotifier(getVm()));
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
        if (isClusterLevelChange() && newVmStatic.getCustomCompatibilityVersion() == null) {
            // For backward compatibility after cluster version change: keep version until VM reboot
            // Set temporarily custom compatibility version till the NextRun is applied
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new HostedEngineEditNotifier(getVm()));
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
        if (isClusterLevelChange()) {
            // For backward compatibility after cluster version change: keep version until VM reboot
            // Set temporarily custom compatibility version till the NextRun is applied
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#end_block

#method_before
private void createNextRunSnapshot() {
    // first remove existing snapshot
    Snapshot runSnap = getSnapshotDao().get(getVmId(), Snapshot.SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
    }
    VM vm = new VM();
    vm.setStaticData(getParameters().getVmStaticData());
    // create new snapshot with new configuration
    new SnapshotsManager().addSnapshot(Guid.newGuid(), "Next Run configuration snapshot", Snapshot.SnapshotStatus.OK, Snapshot.SnapshotType.NEXT_RUN, vm, true, StringUtils.EMPTY, Collections.emptyList(), getVmDeviceUtils().getVmDevicesForNextRun(getVm(), getParameters()), getCompensationContext());
}
#method_after
private void createNextRunSnapshot() {
    // first remove existing snapshot
    Snapshot runSnap = getSnapshotDao().get(getVmId(), Snapshot.SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
    }
    VM vm = new VM();
    vm.setStaticData(getParameters().getVmStaticData());
    // create new snapshot with new configuration
    getSnapshotsManager().addSnapshot(Guid.newGuid(), "Next Run configuration snapshot", Snapshot.SnapshotStatus.OK, Snapshot.SnapshotType.NEXT_RUN, vm, true, StringUtils.EMPTY, Collections.emptyList(), getVmDeviceUtils().getVmDevicesForNextRun(getVm(), getParameters()), getCompensationContext());
}
#end_block

#method_before
private static String getIommu(CpuVendor cpuVendor, boolean iommu) {
    if (!iommu) {
        return "";
    }
    switch(cpuVendor) {
        case AMD:
            // $NON-NLS-1$
            return "amd_iommu=1 ";
        case INTEL:
            // $NON-NLS-1$
            return "intel_iommu=1 ";
        case IBM:
            return "";
        default:
            // $NON-NLS-1$
            throw new RuntimeException("Unknown CpuType: " + cpuVendor);
    }
}
#method_after
private static String getIommu(CpuVendor cpuVendor, boolean iommu) {
    if (!iommu) {
        return "";
    }
    switch(cpuVendor) {
        case AMD:
            // $NON-NLS-1$
            return "amd_iommu=on ";
        case INTEL:
            // $NON-NLS-1$
            return "intel_iommu=on ";
        case IBM:
            return "";
        default:
            // $NON-NLS-1$
            throw new RuntimeException("Unknown CpuType: " + cpuVendor);
    }
}
#end_block

#method_before
@Override
protected void init() {
    if (getCluster() == null) {
        return;
    }
    setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getParameters().getVmStaticData(), this::getCluster));
    Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
    // if set to use latest version, get it from db and use it as template
    if (getParameters().getVmStaticData().isUseLatestVersion()) {
        VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
        if (latest != null) {
            // as it may have different set of disks
            if (!templateIdToUse.equals(latest.getId())) {
                getParameters().setDiskInfoDestinationMap(null);
            }
            setVmTemplate(latest);
            templateIdToUse = latest.getId();
            getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
        }
    }
    setVmTemplateId(templateIdToUse);
    initTemplate();
    ensureDestinationImageMap();
    nameForVmInPoolGenerator = new NameForVmInPoolGenerator(getParameters().getVmPool().getName());
}
#method_after
@Override
protected void init() {
    if (getCluster() == null) {
        return;
    }
    setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getParameters().getVmStaticData(), this::getCluster));
    Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
    // if set to use latest version, get it from db and use it as template
    if (getParameters().getVmStaticData().isUseLatestVersion()) {
        VmTemplate latest = getVmTemplateDao().getTemplateWithLatestVersionInChain(templateIdToUse);
        if (latest != null) {
            // as it may have different set of disks
            if (!templateIdToUse.equals(latest.getId())) {
                getParameters().setDiskInfoDestinationMap(null);
            }
            setVmTemplate(latest);
            templateIdToUse = latest.getId();
            getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
        }
    }
    setVmTemplateId(templateIdToUse);
    initTemplate();
    if (getVmPool().isAutoStorageSelect()) {
        initTargetDomains();
    }
    ensureDestinationImageMap();
    nameForVmInPoolGenerator = new NameForVmInPoolGenerator(getParameters().getVmPool().getName());
}
#end_block

#method_before
private AddVmParameters buildAddVmParameters(String vmName) {
    VmStatic currVm = new VmStatic(getParameters().getVmStaticData());
    currVm.setName(vmName);
    currVm.setStateless(!getVmPool().isStateful());
    if (getParameters().getVmLargeIcon() != null) {
        final VmIconIdSizePair iconIds = IconUtils.ensureIconPairInDatabase(getParameters().getVmLargeIcon());
        currVm.setSmallIconId(iconIds.getSmall());
        currVm.setLargeIconId(iconIds.getLarge());
    }
    AddVmParameters parameters = new AddVmParameters(currVm);
    parameters.setPoolId(getVmPool().getVmPoolId());
    parameters.setDiskInfoDestinationMap(diskInfoDestinationMap);
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        parameters.setParametersCurrentUser(getCurrentUser());
    } else {
        parameters.setSessionId(getParameters().getSessionId());
    }
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    // check if device is enabled or we need to override it to true
    parameters.setSoundDeviceEnabled(Boolean.TRUE.equals(getParameters().isSoundDeviceEnabled()) || vmDeviceUtils.shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled()));
    parameters.setConsoleEnabled(getParameters().isConsoleEnabled());
    parameters.setVirtioScsiEnabled(getParameters().isVirtioScsiEnabled());
    parameters.setBalloonEnabled(getParameters().isBalloonEnabled());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    VmRngDevice rngDevice = getParameters().getRngDevice();
    if (rngDevice != null) {
        parameters.setUpdateRngDevice(true);
        parameters.setRngDevice(rngDevice);
    }
    parameters.getGraphicsDevices().putAll(getParameters().getGraphicsDevices());
    return parameters;
}
#method_after
private AddVmParameters buildAddVmParameters(String vmName) {
    VmStatic currVm = new VmStatic(getParameters().getVmStaticData());
    currVm.setName(vmName);
    currVm.setStateless(!getVmPool().isStateful());
    if (getParameters().getVmLargeIcon() != null) {
        final VmIconIdSizePair iconIds = IconUtils.ensureIconPairInDatabase(getParameters().getVmLargeIcon());
        currVm.setSmallIconId(iconIds.getSmall());
        currVm.setLargeIconId(iconIds.getLarge());
    }
    AddVmParameters parameters = new AddVmParameters(currVm);
    parameters.setPoolId(getVmPool().getVmPoolId());
    if (getVmPool().isAutoStorageSelect()) {
        parameters.setDiskInfoDestinationMap(autoSelectTargetDomain());
    } else {
        parameters.setDiskInfoDestinationMap(diskInfoDestinationMap);
    }
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        parameters.setParametersCurrentUser(getCurrentUser());
    } else {
        parameters.setSessionId(getParameters().getSessionId());
    }
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    // check if device is enabled or we need to override it to true
    parameters.setSoundDeviceEnabled(Boolean.TRUE.equals(getParameters().isSoundDeviceEnabled()) || vmDeviceUtils.shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled()));
    parameters.setConsoleEnabled(getParameters().isConsoleEnabled());
    parameters.setVirtioScsiEnabled(getParameters().isVirtioScsiEnabled());
    parameters.setBalloonEnabled(getParameters().isBalloonEnabled());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    VmRngDevice rngDevice = getParameters().getRngDevice();
    if (rngDevice != null) {
        parameters.setUpdateRngDevice(true);
        parameters.setRngDevice(rngDevice);
    }
    parameters.getGraphicsDevices().putAll(getParameters().getGraphicsDevices());
    return parameters;
}
#end_block

#method_before
private CommandContext createAddVmStepContext(String currentVmName) {
    CommandContext commandCtx = null;
    try {
        Map<String, String> values = new HashMap<>();
        values.put(VdcObjectType.VM.name().toLowerCase(), currentVmName);
        Step addVmStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.ADD_VM_TO_POOL, ExecutionMessageDirector.resolveStepMessage(StepEnum.ADD_VM_TO_POOL, values));
        ExecutionContext ctx = new ExecutionContext();
        ctx.setStep(addVmStep);
        ctx.setMonitored(true);
        commandCtx = cloneContextAndDetachFromParent().withExecutionContext(ctx);
    } catch (RuntimeException e) {
        log.error("Failed to create command context of adding VM '{}' to Pool '{}': {}", currentVmName, getParameters().getVmPool().getName(), e.getMessage());
        log.debug("Exception", e);
    }
    return commandCtx;
}
#method_after
private CommandContext createAddVmStepContext(String currentVmName) {
    CommandContext commandCtx = null;
    try {
        Map<String, String> values = new HashMap<>();
        values.put(VdcObjectType.VM.name().toLowerCase(), currentVmName);
        Step addVmStep = executionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.ADD_VM_TO_POOL, ExecutionMessageDirector.resolveStepMessage(StepEnum.ADD_VM_TO_POOL, values));
        ExecutionContext ctx = new ExecutionContext();
        ctx.setStep(addVmStep);
        ctx.setMonitored(true);
        commandCtx = cloneContextAndDetachFromParent().withExecutionContext(ctx);
    } catch (RuntimeException e) {
        log.error("Failed to create command context of adding VM '{}' to Pool '{}': {}", currentVmName, getParameters().getVmPool().getName(), e.getMessage());
        log.debug("Exception", e);
    }
    return commandCtx;
}
#end_block

#method_before
private Guid findAvailableStorageDomain(List<StorageDomain> domains) {
    StorageDomain dest = domains.get(0);
    for (StorageDomain domain : domains) {
        if (domain.getAvailableDiskSizeInBytes() != null && dest.getAvailableDiskSizeInBytes() != null && domain.getAvailableDiskSizeInBytes() > dest.getAvailableDiskSizeInBytes()) {
            dest = domain;
        }
    }
    return dest.getId();
}
#method_after
private Guid findAvailableStorageDomain(long diskSize, List<Guid> storageIds) {
    Guid dest = storageIds.get(0);
    for (Guid storageId : storageIds) {
        if (targetDomainsSize.get(storageId) > targetDomainsSize.get(dest)) {
            dest = storageId;
        }
    }
    long destSize = targetDomainsSize.get(dest);
    targetDomainsSize.put(dest, destSize - diskSize);
    return dest;
}
#end_block

#method_before
private void ensureDestinationImageMap() {
    if (getVmPool().isAutoStorageSelect()) {
        autoSelectStorage();
    } else if (MapUtils.isEmpty(getParameters().getDiskInfoDestinationMap())) {
        diskInfoDestinationMap = new HashMap<>();
        if (getVmTemplate() == null) {
            return;
        }
        if (!Guid.isNullOrEmpty(getParameters().getStorageDomainId())) {
            Guid storageId = getParameters().getStorageDomainId();
            ArrayList<Guid> storageIds = new ArrayList<>();
            storageIds.add(storageId);
            for (DiskImage image : getVmTemplate().getDiskTemplateMap().values()) {
                image.setStorageIds(storageIds);
                diskInfoDestinationMap.put(image.getId(), image);
            }
        } else {
            ImagesHandler.fillImagesMapBasedOnTemplate(getVmTemplate(), diskInfoDestinationMap, destStorages);
        }
    } else {
        diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    }
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getVmTemplate().getDiskTemplateMap().values(), diskInfoDestinationMap);
}
#method_after
private void ensureDestinationImageMap() {
    if (getVmPool().isAutoStorageSelect() || MapUtils.isEmpty(getParameters().getDiskInfoDestinationMap())) {
        diskInfoDestinationMap = new HashMap<>();
        if (getVmTemplate() == null) {
            return;
        }
        if (!Guid.isNullOrEmpty(getParameters().getStorageDomainId()) && !getVmPool().isAutoStorageSelect()) {
            Guid storageId = getParameters().getStorageDomainId();
            ArrayList<Guid> storageIds = new ArrayList<>();
            storageIds.add(storageId);
            for (DiskImage image : getVmTemplate().getDiskTemplateMap().values()) {
                image.setStorageIds(storageIds);
                diskInfoDestinationMap.put(image.getId(), image);
            }
        } else {
            ImagesHandler.fillImagesMapBasedOnTemplate(getVmTemplate(), diskInfoDestinationMap, destStorages);
        }
    } else {
        diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    }
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getVmTemplate().getDiskTemplateMap().values(), diskInfoDestinationMap);
}
#end_block

#method_before
@Override
public void save(VmPool pool) {
    Guid id = pool.getVmPoolId();
    if (Guid.isNullOrEmpty(id)) {
        id = Guid.newGuid();
        pool.setVmPoolId(id);
    }
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_description", pool.getVmPoolDescription()).addValue("vm_pool_comment", pool.getComment()).addValue("vm_pool_id", pool.getVmPoolId()).addValue("vm_pool_name", pool.getName()).addValue("vm_pool_type", pool.getVmPoolType()).addValue("stateful", pool.isStateful()).addValue("parameters", pool.getParameters()).addValue("prestarted_vms", pool.getPrestartedVms()).addValue("cluster_id", pool.getClusterId()).addValue("max_assigned_vms_per_user", pool.getMaxAssignedVmsPerUser()).addValue("spice_proxy", pool.getSpiceProxy()).addValue("is_being_destroyed", pool.isBeingDestroyed());
    getCallsHandler().executeModification("InsertVm_pools", parameterSource);
}
#method_after
@Override
public void save(VmPool pool) {
    Guid id = pool.getVmPoolId();
    if (Guid.isNullOrEmpty(id)) {
        id = Guid.newGuid();
        pool.setVmPoolId(id);
    }
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_description", pool.getVmPoolDescription()).addValue("vm_pool_comment", pool.getComment()).addValue("vm_pool_id", pool.getVmPoolId()).addValue("vm_pool_name", pool.getName()).addValue("vm_pool_type", pool.getVmPoolType()).addValue("stateful", pool.isStateful()).addValue("parameters", pool.getParameters()).addValue("prestarted_vms", pool.getPrestartedVms()).addValue("cluster_id", pool.getClusterId()).addValue("max_assigned_vms_per_user", pool.getMaxAssignedVmsPerUser()).addValue("spice_proxy", pool.getSpiceProxy()).addValue("is_being_destroyed", pool.isBeingDestroyed()).addValue("is_auto_storage_select", pool.isAutoStorageSelect());
    getCallsHandler().executeModification("InsertVm_pools", parameterSource);
}
#end_block

#method_before
@Override
public void update(VmPool pool) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_description", pool.getVmPoolDescription()).addValue("vm_pool_comment", pool.getComment()).addValue("vm_pool_id", pool.getVmPoolId()).addValue("vm_pool_name", pool.getName()).addValue("vm_pool_type", pool.getVmPoolType()).addValue("stateful", pool.isStateful()).addValue("parameters", pool.getParameters()).addValue("prestarted_vms", pool.getPrestartedVms()).addValue("cluster_id", pool.getClusterId()).addValue("max_assigned_vms_per_user", pool.getMaxAssignedVmsPerUser()).addValue("spice_proxy", pool.getSpiceProxy()).addValue("is_being_destroyed", pool.isBeingDestroyed());
    getCallsHandler().executeModification("UpdateVm_pools", parameterSource);
}
#method_after
@Override
public void update(VmPool pool) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_description", pool.getVmPoolDescription()).addValue("vm_pool_comment", pool.getComment()).addValue("vm_pool_id", pool.getVmPoolId()).addValue("vm_pool_name", pool.getName()).addValue("vm_pool_type", pool.getVmPoolType()).addValue("stateful", pool.isStateful()).addValue("parameters", pool.getParameters()).addValue("prestarted_vms", pool.getPrestartedVms()).addValue("cluster_id", pool.getClusterId()).addValue("max_assigned_vms_per_user", pool.getMaxAssignedVmsPerUser()).addValue("spice_proxy", pool.getSpiceProxy()).addValue("is_being_destroyed", pool.isBeingDestroyed()).addValue("is_auto_storage_select", pool.isAutoStorageSelect());
    getCallsHandler().executeModification("UpdateVm_pools", parameterSource);
}
#end_block

#method_before
@Override
public VmPool mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VmPool entity = new VmPool();
    entity.setVmPoolDescription(rs.getString("vm_pool_description"));
    entity.setVmPoolId(getGuidDefaultEmpty(rs, "vm_pool_id"));
    entity.setComment(rs.getString("vm_pool_comment"));
    entity.setName(rs.getString("vm_pool_name"));
    entity.setVmPoolType(VmPoolType.forValue(rs.getInt("vm_pool_type")));
    entity.setStateful(rs.getBoolean("stateful"));
    entity.setParameters(rs.getString("parameters"));
    entity.setPrestartedVms(rs.getInt("prestarted_vms"));
    entity.setClusterId(getGuidDefaultEmpty(rs, "cluster_id"));
    entity.setClusterName(rs.getString("cluster_name"));
    entity.setAssignedVmsCount(rs.getInt("assigned_vm_count"));
    entity.setRunningVmsCount(rs.getInt("vm_running_count"));
    entity.setMaxAssignedVmsPerUser(rs.getInt("max_assigned_vms_per_user"));
    entity.setSpiceProxy(rs.getString("spice_proxy"));
    entity.setBeingDestroyed(rs.getBoolean("is_being_destroyed"));
    entity.setAutoStorageSelect(rs.getBoolean("auto_storage_select"));
    return entity;
}
#method_after
@Override
public VmPool mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VmPool entity = new VmPool();
    entity.setVmPoolDescription(rs.getString("vm_pool_description"));
    entity.setVmPoolId(getGuidDefaultEmpty(rs, "vm_pool_id"));
    entity.setComment(rs.getString("vm_pool_comment"));
    entity.setName(rs.getString("vm_pool_name"));
    entity.setVmPoolType(VmPoolType.forValue(rs.getInt("vm_pool_type")));
    entity.setStateful(rs.getBoolean("stateful"));
    entity.setParameters(rs.getString("parameters"));
    entity.setPrestartedVms(rs.getInt("prestarted_vms"));
    entity.setClusterId(getGuidDefaultEmpty(rs, "cluster_id"));
    entity.setClusterName(rs.getString("cluster_name"));
    entity.setAssignedVmsCount(rs.getInt("assigned_vm_count"));
    entity.setRunningVmsCount(rs.getInt("vm_running_count"));
    entity.setMaxAssignedVmsPerUser(rs.getInt("max_assigned_vms_per_user"));
    entity.setSpiceProxy(rs.getString("spice_proxy"));
    entity.setBeingDestroyed(rs.getBoolean("is_being_destroyed"));
    entity.setAutoStorageSelect(rs.getBoolean("is_auto_storage_select"));
    return entity;
}
#end_block

#method_before
@Override
public VmPool mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VmPool entity = new VmPool();
    entity.setVmPoolDescription(rs.getString("vm_pool_description"));
    entity.setVmPoolId(getGuidDefaultEmpty(rs, "vm_pool_id"));
    entity.setComment(rs.getString("vm_pool_comment"));
    entity.setName(rs.getString("vm_pool_name"));
    entity.setVmPoolType(VmPoolType.forValue(rs.getInt("vm_pool_type")));
    entity.setStateful(rs.getBoolean("stateful"));
    entity.setParameters(rs.getString("parameters"));
    entity.setPrestartedVms(rs.getInt("prestarted_vms"));
    entity.setClusterId(getGuidDefaultEmpty(rs, "cluster_id"));
    entity.setClusterName(rs.getString("cluster_name"));
    entity.setMaxAssignedVmsPerUser(rs.getInt("max_assigned_vms_per_user"));
    entity.setSpiceProxy(rs.getString("spice_proxy"));
    entity.setBeingDestroyed(rs.getBoolean("is_being_destroyed"));
    entity.setAutoStorageSelect(rs.getBoolean("auto_storage_select"));
    return entity;
}
#method_after
@Override
public VmPool mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VmPool entity = new VmPool();
    entity.setVmPoolDescription(rs.getString("vm_pool_description"));
    entity.setVmPoolId(getGuidDefaultEmpty(rs, "vm_pool_id"));
    entity.setComment(rs.getString("vm_pool_comment"));
    entity.setName(rs.getString("vm_pool_name"));
    entity.setVmPoolType(VmPoolType.forValue(rs.getInt("vm_pool_type")));
    entity.setStateful(rs.getBoolean("stateful"));
    entity.setParameters(rs.getString("parameters"));
    entity.setPrestartedVms(rs.getInt("prestarted_vms"));
    entity.setClusterId(getGuidDefaultEmpty(rs, "cluster_id"));
    entity.setClusterName(rs.getString("cluster_name"));
    entity.setMaxAssignedVmsPerUser(rs.getInt("max_assigned_vms_per_user"));
    entity.setSpiceProxy(rs.getString("spice_proxy"));
    entity.setBeingDestroyed(rs.getBoolean("is_being_destroyed"));
    entity.setAutoStorageSelect(rs.getBoolean("is_auto_storage_select"));
    return entity;
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    if (!StringHelper.isNullOrEmpty(pool.getVmPoolSpiceProxy())) {
        getModel().getSpiceProxyEnabled().setEntity(true);
        getModel().getSpiceProxy().setEntity(pool.getVmPoolSpiceProxy());
        getModel().getSpiceProxy().setIsChangeable(true);
    }
    instanceTypeManager = new ExistingPoolInstanceTypeManager(getModel(), pool);
    instanceTypeManager.setAlwaysEnabledFieldUpdate(true);
    getModel().getCustomProperties().setIsChangeable(false);
    getModel().getCustomPropertySheet().setIsChangeable(false);
    getModel().getDiskAllocationTargetEnabled().setIsAvailable(Boolean.TRUE);
    getModel().getDiskAllocationTargetEnabled().setIsChangeable(Boolean.FALSE);
    getModel().getDiskAllocationTargetEnabled().setEntity(actualPool.isAutoStorageSelect());
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    if (!StringHelper.isNullOrEmpty(pool.getVmPoolSpiceProxy())) {
        getModel().getSpiceProxyEnabled().setEntity(true);
        getModel().getSpiceProxy().setEntity(pool.getVmPoolSpiceProxy());
        getModel().getSpiceProxy().setIsChangeable(true);
    }
    instanceTypeManager = new ExistingPoolInstanceTypeManager(getModel(), pool);
    instanceTypeManager.setAlwaysEnabledFieldUpdate(true);
    getModel().getCustomProperties().setIsChangeable(false);
    getModel().getCustomPropertySheet().setIsChangeable(false);
}
#end_block

#method_before
@Override
protected void postInitStorageDomains() {
    ArrayList<DiskModel> disks = (ArrayList<DiskModel>) getModel().getDisks();
    if (disks == null) {
        return;
    }
    ActionGroup actionGroup = getModel().isCreateInstanceOnly() ? ActionGroup.CREATE_INSTANCE : ActionGroup.CREATE_VM;
    StoragePool dataCenter = getModel().getSelectedDataCenter();
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmModelBehaviorBase behavior = ExistingPoolModelBehavior.this;
            ArrayList<DiskModel> disks = (ArrayList<DiskModel>) behavior.getModel().getDisks();
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> activeStorageDomains = filterStorageDomains(storageDomains);
            DisksAllocationModel disksAllocationModel = behavior.getModel().getDisksAllocationModel();
            disksAllocationModel.setActiveStorageDomains(activeStorageDomains);
            behavior.getModel().getStorageDomain().setItems(activeStorageDomains);
            for (DiskModel diskModel : disks) {
                // Setting Quota
                diskModel.getQuota().setItems(behavior.getModel().getQuota().getItems());
                diskModel.getQuota().setIsChangeable(false);
                ArrayList<Guid> storageIds = null;
                for (DiskImage disk : pool.getDiskList()) {
                    if (diskModel.getDisk() instanceof DiskImage && ((DiskImage) diskModel.getDisk()).getImageId().equals(disk.getParentId())) {
                        storageIds = new ArrayList<>(disk.getStorageIds());
                        break;
                    }
                }
                if (storageIds == null || storageIds.size() == 0) {
                    continue;
                }
                Guid storageId = storageIds.get(0);
                StorageDomain storageDomain = Linq.getStorageById(storageId, activeStorageDomains);
                List<StorageDomain> diskStorageDomains = new ArrayList<>();
                diskStorageDomains.add(storageDomain);
                diskModel.getStorageDomain().setItems(diskStorageDomains);
                diskModel.getStorageDomain().setIsChangeable(false);
            }
        }
    }), dataCenter.getId(), actionGroup);
}
#method_after
@Override
protected void postInitStorageDomains() {
    ArrayList<DiskModel> disks = (ArrayList<DiskModel>) getModel().getDisks();
    if (disks == null) {
        return;
    }
    ActionGroup actionGroup = getModel().isCreateInstanceOnly() ? ActionGroup.CREATE_INSTANCE : ActionGroup.CREATE_VM;
    StoragePool dataCenter = getModel().getSelectedDataCenter();
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(asyncQuery(new AsyncCallback<List<StorageDomain>>() {

        @Override
        public void onSuccess(List<StorageDomain> storageDomains) {
            ArrayList<DiskModel> disks = (ArrayList<DiskModel>) getModel().getDisks();
            ArrayList<StorageDomain> activeStorageDomains = filterStorageDomains(storageDomains);
            DisksAllocationModel disksAllocationModel = getModel().getDisksAllocationModel();
            disksAllocationModel.setActiveStorageDomains(activeStorageDomains);
            getModel().getStorageDomain().setItems(activeStorageDomains);
            for (DiskModel diskModel : disks) {
                // Setting Quota
                diskModel.getQuota().setItems(getModel().getQuota().getItems());
                diskModel.getQuota().setIsChangeable(false);
                ArrayList<Guid> storageIds = null;
                for (DiskImage disk : pool.getDiskList()) {
                    if (diskModel.getDisk() instanceof DiskImage && ((DiskImage) diskModel.getDisk()).getImageId().equals(disk.getParentId())) {
                        storageIds = new ArrayList<>(disk.getStorageIds());
                        break;
                    }
                }
                if (storageIds == null || storageIds.size() == 0) {
                    continue;
                }
                Guid storageId = storageIds.get(0);
                StorageDomain storageDomain = Linq.getStorageById(storageId, activeStorageDomains);
                List<StorageDomain> diskStorageDomains = new ArrayList<>();
                diskStorageDomains.add(storageDomain);
                diskModel.getStorageDomain().setItems(diskStorageDomains);
                diskModel.getStorageDomain().setIsChangeable(false);
            }
        }
    }), dataCenter.getId(), actionGroup);
    getModel().getDisksAllocationModel().initializeAutoSelectTarget(false, actualPool.isAutoStorageSelect());
}
#end_block

#method_before
protected void setDefaultVolumeInformationSelection(List<DiskModel> diskModels) {
    final Map<Guid, DiskModel> diskModelsMap = new HashMap<>();
    for (DiskModel diskModel : diskModels) {
        diskModelsMap.put(((DiskImage) diskModel.getDisk()).getImageId(), diskModel);
    }
    Model model = getContainer() != null ? getContainer() : this;
    AsyncDataProvider.getInstance().getAncestorImagesByImagesIds(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Map<Guid, DiskImage> imagesAncestors = (Map<Guid, DiskImage>) returnValue;
            for (Map.Entry<Guid, DiskImage> entry : imagesAncestors.entrySet()) {
                DiskModel diskModel = diskModelsMap.get(entry.getKey());
                diskModel.getVolumeType().setSelectedItem(entry.getValue().getVolumeType());
                diskModel.getVolumeFormat().setSelectedItem(entry.getValue().getVolumeFormat());
                updateStorageDomainsAvailability();
            }
        }
    }), new ArrayList<>(diskModelsMap.keySet()));
}
#method_after
protected void setDefaultVolumeInformationSelection(List<DiskModel> diskModels) {
    final Map<Guid, DiskModel> diskModelsMap = new HashMap<>();
    for (DiskModel diskModel : diskModels) {
        diskModelsMap.put(((DiskImage) diskModel.getDisk()).getImageId(), diskModel);
    }
    AsyncDataProvider.getInstance().getAncestorImagesByImagesIds(new AsyncQuery<>(new AsyncCallback<Map<Guid, DiskImage>>() {

        @Override
        public void onSuccess(Map<Guid, DiskImage> imagesAncestors) {
            for (Map.Entry<Guid, DiskImage> entry : imagesAncestors.entrySet()) {
                DiskModel diskModel = diskModelsMap.get(entry.getKey());
                diskModel.getVolumeType().setSelectedItem(entry.getValue().getVolumeType());
                diskModel.getVolumeFormat().setSelectedItem(entry.getValue().getVolumeFormat());
                updateStorageDomainsAvailability();
            }
        }
    }), new ArrayList<>(diskModelsMap.keySet()));
}
#end_block

#method_before
private void updateQuota(Guid storageDomainId, final ListModel<Quota> isItem, final Guid diskQuotaId) {
    if (getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && storageDomainId != null) {
        AsyncDataProvider.getInstance().getAllRelevantQuotasForStorageSorted(new AsyncQuery(new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<Quota> list = (List<Quota>) returnValue;
                if (list == null) {
                    return;
                }
                if (isItem == null) {
                    for (DiskModel diskModel : getDisks()) {
                        diskModel.getQuota().setItems(list);
                        if (diskModel.getDisk() instanceof DiskImage) {
                            DiskImage diskImage = (DiskImage) diskModel.getDisk();
                            for (Quota quota : list) {
                                if (quota.getId().equals(diskImage.getQuotaId())) {
                                    diskModel.getQuota().setSelectedItem(quota);
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    Guid selectedQuota = isItem.getSelectedItem() != null ? isItem.getSelectedItem().getId() : null;
                    selectedQuota = selectedQuota != null ? selectedQuota : diskQuotaId;
                    isItem.setItems(list);
                    if (selectedQuota != null && list.size() > 1) {
                        for (Quota quota : list) {
                            if (quota.getId().equals(selectedQuota)) {
                                isItem.setSelectedItem(quota);
                                break;
                            }
                        }
                    }
                }
            }
        }), storageDomainId, null);
    }
}
#method_after
private void updateQuota(Guid storageDomainId, final ListModel<Quota> isItem, final Guid diskQuotaId) {
    if (getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && storageDomainId != null) {
        AsyncDataProvider.getInstance().getAllRelevantQuotasForStorageSorted(new AsyncQuery<>(new AsyncCallback<List<Quota>>() {

            @Override
            public void onSuccess(List<Quota> list) {
                if (list == null) {
                    return;
                }
                if (isItem == null) {
                    for (DiskModel diskModel : getDisks()) {
                        diskModel.getQuota().setItems(list);
                        if (diskModel.getDisk() instanceof DiskImage) {
                            DiskImage diskImage = (DiskImage) diskModel.getDisk();
                            for (Quota quota : list) {
                                if (quota.getId().equals(diskImage.getQuotaId())) {
                                    diskModel.getQuota().setSelectedItem(quota);
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    Guid selectedQuota = isItem.getSelectedItem() != null ? isItem.getSelectedItem().getId() : null;
                    selectedQuota = selectedQuota != null ? selectedQuota : diskQuotaId;
                    isItem.setItems(list);
                    if (selectedQuota != null && list.size() > 1) {
                        for (Quota quota : list) {
                            if (quota.getId().equals(selectedQuota)) {
                                isItem.setSelectedItem(quota);
                                break;
                            }
                        }
                    }
                }
            }
        }), storageDomainId, null);
    }
}
#end_block

#method_before
private void updateDiskProfile(Guid storageDomainId, final ListModel<DiskProfile> diskProfiles) {
    Frontend.getInstance().runQuery(VdcQueryType.GetDiskProfilesByStorageDomainId, new IdQueryParameters(storageDomainId), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<DiskProfile> fetchedDiskProfiles = ((VdcQueryReturnValue) returnValue).getReturnValue();
            DisksAllocationModel.this.setDiskProfilesList(diskProfiles, fetchedDiskProfiles);
        }
    }));
}
#method_after
private void updateDiskProfile(Guid storageDomainId, final ListModel<DiskProfile> diskProfiles) {
    Frontend.getInstance().runQuery(VdcQueryType.GetDiskProfilesByStorageDomainId, new IdQueryParameters(storageDomainId), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            List<DiskProfile> fetchedDiskProfiles = returnValue.getReturnValue();
            DisksAllocationModel.this.setDiskProfilesList(diskProfiles, fetchedDiskProfiles);
        }
    }));
}
#end_block

#method_before
private void updateImageToDestinationDomainMap() {
    if (disks == null) {
        return;
    }
    for (DiskModel diskModel : disks) {
        StorageDomain storageDomain = diskModel.getStorageDomain().getSelectedItem();
        DiskImage diskImage = (DiskImage) diskModel.getDisk();
        diskImage.setStorageIds(new ArrayList<>(Arrays.asList(storageDomain.getId())));
        diskImage.setDiskAlias(diskModel.getAlias().getEntity());
        DiskProfile diskProfile = diskModel.getDiskProfile().getSelectedItem();
        diskImage.setDiskProfileId(diskProfile != null ? diskProfile.getId() : null);
        if (diskModel.getQuota().getSelectedItem() != null) {
            diskImage.setQuotaId(diskModel.getQuota().getSelectedItem().getId());
        }
        if (diskModel.getVolumeFormat().getIsAvailable()) {
            VolumeFormat volumeFormat = diskModel.getVolumeFormat().getSelectedItem();
            diskImage.setVolumeFormat(volumeFormat);
            diskImage.setVolumeType(AsyncDataProvider.getInstance().getTemplateVolumeType(volumeFormat, storageDomain.getStorageType()));
        } else if (diskModel.getVolumeType().getIsAvailable()) {
            VolumeType volumeType = diskModel.getVolumeType().getSelectedItem();
            diskImage.setVolumeType(volumeType);
            diskImage.setVolumeFormat(AsyncDataProvider.getInstance().getDiskVolumeFormat(volumeType, storageDomain.getStorageType()));
        }
        imageToDestinationDomainMap.put(diskImage.getId(), diskImage);
    }
}
#method_after
private void updateImageToDestinationDomainMap() {
    if (disks == null) {
        return;
    }
    for (DiskModel diskModel : disks) {
        StorageDomain storageDomain = diskModel.getStorageDomain().getSelectedItem();
        DiskImage diskImage = (DiskImage) diskModel.getDisk();
        diskImage.setStorageIds(new ArrayList<>(Arrays.asList(storageDomain.getId())));
        diskImage.setDiskAlias(diskModel.getAlias().getEntity());
        DiskProfile diskProfile = diskModel.getDiskProfile().getSelectedItem();
        diskImage.setDiskProfileId(diskProfile != null ? diskProfile.getId() : null);
        if (diskModel.getQuota().getSelectedItem() != null) {
            diskImage.setQuotaId(diskModel.getQuota().getSelectedItem().getId());
        }
        if (diskModel.getVolumeFormat().getIsAvailable()) {
            VolumeFormat volumeFormat = diskModel.getVolumeFormat().getSelectedItem();
            diskImage.setVolumeFormat(volumeFormat);
            diskImage.setVolumeType(AsyncDataProvider.getInstance().getVolumeType(volumeFormat, storageDomain.getStorageType()));
        } else if (diskModel.getVolumeType().getIsAvailable()) {
            VolumeType volumeType = diskModel.getVolumeType().getSelectedItem();
            diskImage.setVolumeType(volumeType);
            diskImage.setVolumeFormat(AsyncDataProvider.getInstance().getDiskVolumeFormat(volumeType, storageDomain.getStorageType()));
        }
        imageToDestinationDomainMap.put(diskImage.getId(), diskImage);
    }
}
#end_block

#method_before
public void updateTargetChangeable(boolean enabled) {
    if (disks != null) {
        for (DiskModel diskModel : disks) {
            diskModel.getStorageDomain().setIsChangeable(enabled);
        }
    }
}
#method_after
public void updateTargetChangeable(boolean enabled) {
    if (disks != null) {
        for (DiskModel diskModel : disks) {
            diskModel.getStorageDomain().setIsChangeable(enabled);
            diskModel.getDiskProfile().setIsChangeable(enabled);
        }
    }
}
#end_block

#method_before
public boolean isSourceAvailable() {
    return isSourceAvailable;
}
#method_after
public boolean isSourceAvailable() {
    return isSourceStorageDomainAvailable || isSourceStorageDomainNameAvailable;
}
#end_block

#method_before
public void edit() {
    final VmPool pool = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final PoolListModel poolListModel = this;
    Frontend.getInstance().runQuery(VdcQueryType.GetVmDataByPoolId, new IdQueryParameters(pool.getVmPoolId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object modell, Object result) {
            final VM vm = ((VdcQueryReturnValue) result).getReturnValue();
            final ExistingPoolModelBehavior behavior = new ExistingPoolModelBehavior(vm, pool);
            behavior.getPoolModelBehaviorInitializedEvent().addListener(new IEventListener<EventArgs>() {

                @Override
                public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                    final PoolModel model = behavior.getModel();
                    for (EntityModel<VmPoolType> item : model.getPoolType().getItems()) {
                        if (item.getEntity() == pool.getVmPoolType()) {
                            model.getPoolType().setSelectedItem(item);
                            break;
                        }
                    }
                    String cdImage = null;
                    if (vm != null) {
                        model.getDataCenterWithClustersList().setSelectedItem(null);
                        model.getDataCenterWithClustersList().setSelectedItem(Linq.firstOrNull(model.getDataCenterWithClustersList().getItems(), new Linq.DataCenterWithClusterPredicate(vm.getStoragePoolId(), vm.getClusterId())));
                        model.getTemplateWithVersion().setIsChangeable(false);
                        cdImage = vm.getIsoPath();
                        model.getVmType().setSelectedItem(vm.getVmType());
                    } else {
                        model.getDataCenterWithClustersList().setSelectedItem(Linq.firstOrNull(model.getDataCenterWithClustersList().getItems()));
                    }
                    model.getDataCenterWithClustersList().setIsChangeable(vm == null);
                    boolean hasCd = !StringHelper.isNullOrEmpty(cdImage);
                    model.getCdImage().setIsChangeable(hasCd);
                    model.getCdAttached().setEntity(hasCd);
                    if (hasCd) {
                        model.getCdImage().setSelectedItem(cdImage);
                    }
                    model.getProvisioning().setIsChangeable(false);
                    model.getStorageDomain().setIsChangeable(false);
                }
            });
            PoolModel model = new PoolModel(behavior);
            model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
            // $NON-NLS-1$
            model.setIsAdvancedModeLocalStorageKey("wa_pool_dialog");
            setWindow(model);
            VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
            switchModeCommand.init(model);
            model.getCommands().add(switchModeCommand);
            // $NON-NLS-1$
            UICommand command = UICommand.createDefaultOkUiCommand("OnSave", poolListModel);
            model.getCommands().add(command);
            // $NON-NLS-1$
            model.getCommands().add(UICommand.createCancelUiCommand("Cancel", poolListModel));
            model.setTitle(ConstantsManager.getInstance().getConstants().editPoolTitle());
            model.setHelpTag(HelpTag.edit_pool);
            // $NON-NLS-1$
            model.setHashName("edit_pool");
            model.initialize(getSystemTreeSelectedItem());
            model.getName().setEntity(pool.getName());
            model.getDescription().setEntity(pool.getVmPoolDescription());
            model.getComment().setEntity(pool.getComment());
            model.getPoolStateful().setEntity(pool.isStateful());
            model.getAssignedVms().setEntity(pool.getAssignedVmsCount());
            model.getPrestartedVms().setEntity(pool.getPrestartedVms());
            // $NON-NLS-1$
            model.setPrestartedVmsHint("0-" + pool.getAssignedVmsCount());
            model.getMaxAssignedVmsPerUser().setEntity(pool.getMaxAssignedVmsPerUser());
        }
    }));
}
#method_after
public void edit() {
    final VmPool pool = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final PoolListModel poolListModel = this;
    Frontend.getInstance().runQuery(VdcQueryType.GetVmDataByPoolId, new IdQueryParameters(pool.getVmPoolId()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue result) {
            final VM vm = result.getReturnValue();
            final ExistingPoolModelBehavior behavior = new ExistingPoolModelBehavior(vm, pool);
            behavior.getPoolModelBehaviorInitializedEvent().addListener(new IEventListener<EventArgs>() {

                @Override
                public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                    final PoolModel model = behavior.getModel();
                    for (EntityModel<VmPoolType> item : model.getPoolType().getItems()) {
                        if (item.getEntity() == pool.getVmPoolType()) {
                            model.getPoolType().setSelectedItem(item);
                            break;
                        }
                    }
                    String cdImage = null;
                    if (vm != null) {
                        model.getDataCenterWithClustersList().setSelectedItem(null);
                        model.getDataCenterWithClustersList().setSelectedItem(Linq.firstOrNull(model.getDataCenterWithClustersList().getItems(), new Linq.DataCenterWithClusterPredicate(vm.getStoragePoolId(), vm.getClusterId())));
                        model.getTemplateWithVersion().setIsChangeable(false);
                        cdImage = vm.getIsoPath();
                        model.getVmType().setSelectedItem(vm.getVmType());
                    } else {
                        model.getDataCenterWithClustersList().setSelectedItem(Linq.firstOrNull(model.getDataCenterWithClustersList().getItems()));
                    }
                    model.getDataCenterWithClustersList().setIsChangeable(vm == null);
                    boolean hasCd = !StringHelper.isNullOrEmpty(cdImage);
                    model.getCdImage().setIsChangeable(hasCd);
                    model.getCdAttached().setEntity(hasCd);
                    if (hasCd) {
                        model.getCdImage().setSelectedItem(cdImage);
                    }
                    model.getProvisioning().setIsChangeable(false);
                    model.getStorageDomain().setIsChangeable(false);
                }
            });
            PoolModel model = new PoolModel(behavior);
            model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
            // $NON-NLS-1$
            model.setIsAdvancedModeLocalStorageKey("wa_pool_dialog");
            setWindow(model);
            VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
            switchModeCommand.init(model);
            model.getCommands().add(switchModeCommand);
            // $NON-NLS-1$
            UICommand command = UICommand.createDefaultOkUiCommand("OnSave", poolListModel);
            model.getCommands().add(command);
            // $NON-NLS-1$
            model.getCommands().add(UICommand.createCancelUiCommand("Cancel", poolListModel));
            model.setTitle(ConstantsManager.getInstance().getConstants().editPoolTitle());
            model.setHelpTag(HelpTag.edit_pool);
            // $NON-NLS-1$
            model.setHashName("edit_pool");
            model.initialize(getSystemTreeSelectedItem());
            model.getName().setEntity(pool.getName());
            model.getDescription().setEntity(pool.getVmPoolDescription());
            model.getComment().setEntity(pool.getComment());
            model.getPoolStateful().setEntity(pool.isStateful());
            model.getAssignedVms().setEntity(pool.getAssignedVmsCount());
            model.getPrestartedVms().setEntity(pool.getPrestartedVms());
            // $NON-NLS-1$
            model.setPrestartedVmsHint("0-" + pool.getAssignedVmsCount());
            model.getMaxAssignedVmsPerUser().setEntity(pool.getMaxAssignedVmsPerUser());
        }
    }));
}
#end_block

#method_before
public void onSave() {
    final PoolModel model = (PoolModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.getIsNew() && getSelectedItem() == null) {
        cancel();
        return;
    }
    if (!model.validate()) {
        return;
    }
    setCurrentPool(model.getIsNew() ? new VmPool() : (VmPool) Cloner.clone(getSelectedItem()));
    final String name = model.getName().getEntity();
    // Check name unicitate.
    AsyncDataProvider.getInstance().isPoolNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Boolean isUnique = (Boolean) returnValue;
            if ((model.getIsNew() && !isUnique) || (!model.getIsNew() && !isUnique && name.compareToIgnoreCase(getCurrentPool().getName()) != 0)) {
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setValidTab(TabName.GENERAL_TAB, false);
                model.fireValidationCompleteEvent();
                return;
            }
            String selectedCpu = model.getCustomCpu().getSelectedItem();
            if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
                ConfirmationModel confirmModel = new ConfirmationModel();
                confirmModel.setTitle(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuTitle());
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuMessage());
                confirmModel.setHelpTag(HelpTag.edit_unsupported_cpu);
                // $NON-NLS-1$
                confirmModel.setHashName("edit_unsupported_cpu");
                confirmModel.getCommands().add(// $NON-NLS-1$
                new UICommand("OnSave_Phase2", PoolListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                confirmModel.getCommands().add(// $NON-NLS-1$
                UICommand.createCancelUiCommand(// $NON-NLS-1$
                "CancelConfirmation", PoolListModel.this));
                setConfirmWindow(confirmModel);
            } else {
                savePoolPostValidation();
            }
        }
    }), name);
}
#method_after
public void onSave() {
    final PoolModel model = (PoolModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.getIsNew() && getSelectedItem() == null) {
        cancel();
        return;
    }
    if (!model.validate()) {
        return;
    }
    setCurrentPool(model.getIsNew() ? new VmPool() : (VmPool) Cloner.clone(getSelectedItem()));
    final String name = model.getName().getEntity();
    // Check name unicitate.
    AsyncDataProvider.getInstance().isPoolNameUnique(new AsyncQuery<>(new AsyncCallback<Boolean>() {

        @Override
        public void onSuccess(Boolean isUnique) {
            if ((model.getIsNew() && !isUnique) || (!model.getIsNew() && !isUnique && name.compareToIgnoreCase(getCurrentPool().getName()) != 0)) {
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setValidTab(TabName.GENERAL_TAB, false);
                model.fireValidationCompleteEvent();
                return;
            }
            String selectedCpu = model.getCustomCpu().getSelectedItem();
            if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
                ConfirmationModel confirmModel = new ConfirmationModel();
                confirmModel.setTitle(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuTitle());
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuMessage());
                confirmModel.setHelpTag(HelpTag.edit_unsupported_cpu);
                // $NON-NLS-1$
                confirmModel.setHashName("edit_unsupported_cpu");
                confirmModel.getCommands().add(// $NON-NLS-1$
                new UICommand("OnSave_Phase2", PoolListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                confirmModel.getCommands().add(// $NON-NLS-1$
                UICommand.createCancelUiCommand(// $NON-NLS-1$
                "CancelConfirmation", PoolListModel.this));
                setConfirmWindow(confirmModel);
            } else {
                savePoolPostValidation();
            }
        }
    }), name);
}
#end_block

#method_before
public void savePoolPostValidation() {
    final PoolModel model = (PoolModel) getWindow();
    VmPool pool = getCurrentPool();
    // Save changes.
    pool.setName(model.getName().getEntity());
    pool.setVmPoolDescription(model.getDescription().getEntity());
    pool.setClusterId(model.getSelectedCluster().getId());
    pool.setComment(model.getComment().getEntity());
    pool.setStateful(model.getPoolStateful().getEntity());
    pool.setPrestartedVms(model.getPrestartedVms().getEntity());
    pool.setMaxAssignedVmsPerUser(model.getMaxAssignedVmsPerUser().getEntity());
    pool.setAutoStorageSelect(model.getDiskAllocationTargetEnabled().getEntity());
    EntityModel<VmPoolType> poolTypeSelectedItem = model.getPoolType().getSelectedItem();
    pool.setVmPoolType(poolTypeSelectedItem.getEntity());
    if (model.getSpiceProxyEnabled().getEntity()) {
        pool.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    VM vm = buildVmOnSave(model);
    vm.setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    vm.setBalloonEnabled(model.getMemoryBalloonDeviceEnabled().getEntity());
    vm.setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    vm.setStateless(false);
    vm.setInstanceTypeId(model.getInstanceTypes().getSelectedItem().getId());
    AddVmPoolParameters param = new AddVmPoolParameters(pool, vm, model.getNumOfDesktops().getEntity());
    param.setStorageDomainId(Guid.Empty);
    param.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    param.setRngDevice(model.getIsRngEnabled().getEntity() ? model.generateRngDevice() : null);
    param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    param.setBalloonEnabled(model.getMemoryBalloonDeviceEnabled().getEntity());
    BuilderExecutor.build(model, param, new UnitToGraphicsDeviceParamsBuilder());
    if (model.getQuota().getSelectedItem() != null) {
        vm.setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    model.startProgress();
    if (model.getIsNew()) {
        if (model.getIcon().getEntity().isCustom()) {
            param.setVmLargeIcon(model.getIcon().getEntity().getIcon());
        }
        Frontend.getInstance().runMultipleAction(VdcActionType.AddVmPool, new ArrayList<>(Arrays.asList(new VdcActionParametersBase[] { param })), new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                cancel();
                stopProgress();
            }
        }, this);
    } else {
        Frontend.getInstance().runMultipleAction(VdcActionType.UpdateVmPool, new ArrayList<>(Arrays.asList(new VdcActionParametersBase[] { param })), new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                cancel();
                stopProgress();
            }
        }, this);
    }
}
#method_after
public void savePoolPostValidation() {
    final PoolModel model = (PoolModel) getWindow();
    VmPool pool = getCurrentPool();
    // Save changes.
    pool.setName(model.getName().getEntity());
    pool.setVmPoolDescription(model.getDescription().getEntity());
    pool.setClusterId(model.getSelectedCluster().getId());
    pool.setComment(model.getComment().getEntity());
    pool.setStateful(model.getPoolStateful().getEntity());
    pool.setPrestartedVms(model.getPrestartedVms().getEntity());
    pool.setMaxAssignedVmsPerUser(model.getMaxAssignedVmsPerUser().getEntity());
    pool.setAutoStorageSelect(model.getDisksAllocationModel().getDiskAllocationTargetEnabled().getEntity());
    EntityModel<VmPoolType> poolTypeSelectedItem = model.getPoolType().getSelectedItem();
    pool.setVmPoolType(poolTypeSelectedItem.getEntity());
    if (model.getSpiceProxyEnabled().getEntity()) {
        pool.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    VM vm = buildVmOnSave(model);
    vm.setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    vm.setBalloonEnabled(model.getMemoryBalloonDeviceEnabled().getEntity());
    vm.setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    vm.setStateless(false);
    vm.setInstanceTypeId(model.getInstanceTypes().getSelectedItem().getId());
    AddVmPoolParameters param = new AddVmPoolParameters(pool, vm, model.getNumOfDesktops().getEntity());
    param.setStorageDomainId(Guid.Empty);
    param.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    param.setRngDevice(model.getIsRngEnabled().getEntity() ? model.generateRngDevice() : null);
    param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    param.setBalloonEnabled(model.getMemoryBalloonDeviceEnabled().getEntity());
    BuilderExecutor.build(model, param, new UnitToGraphicsDeviceParamsBuilder());
    if (model.getQuota().getSelectedItem() != null) {
        vm.setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    model.startProgress();
    if (model.getIsNew()) {
        if (model.getIcon().getEntity().isCustom()) {
            param.setVmLargeIcon(model.getIcon().getEntity().getIcon());
        }
        Frontend.getInstance().runMultipleAction(VdcActionType.AddVmPool, new ArrayList<>(Arrays.asList(new VdcActionParametersBase[] { param })), new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                cancel();
                stopProgress();
            }
        }, this);
    } else {
        Frontend.getInstance().runMultipleAction(VdcActionType.UpdateVmPool, new ArrayList<>(Arrays.asList(new VdcActionParametersBase[] { param })), new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                cancel();
                stopProgress();
            }
        }, this);
    }
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmType().setIsChangeable(true);
    getModel().getPoolStateful().setIsChangeable(true);
    templateValidate();
    instanceTypeManager = new NewPoolInstanceTypeManager(getModel());
    getModel().getVmInitModel().init(null);
    getModel().getDiskAllocationTargetEnabled().setIsAvailable(Boolean.TRUE);
    getModel().getDiskAllocationTargetEnabled().setIsChangeable(Boolean.TRUE);
    getModel().getDiskAllocationTargetEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getModel().getDisksAllocationModel().updateTargetChangeable(!getModel().getDiskAllocationTargetEnabled().getEntity());
        }
    });
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmType().setIsChangeable(true);
    getModel().getPoolStateful().setIsChangeable(true);
    templateValidate();
    instanceTypeManager = new NewPoolInstanceTypeManager(getModel());
    getModel().getVmInitModel().init(null);
    getModel().getDisksAllocationModel().initializeAutoSelectTarget(true, false);
}
#end_block

#method_before
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    super.postDataCenterWithClusterSelectedItemChanged();
    final DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = getModel().getSelectedDataCenter();
    if (dataCenter == null) {
        return;
    }
    AsyncDataProvider.getInstance().getTemplateListByDataCenter(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target1, Object returnValue1) {
            List<VmTemplate> templatesByDataCenter = (List<VmTemplate>) returnValue1;
            List<VmTemplate> properArchitectureTemplates = AsyncDataProvider.getInstance().filterTemplatesByArchitecture(templatesByDataCenter, dataCenterWithCluster.getCluster().getArchitecture());
            List<VmTemplate> templatesWithoutBlank = new ArrayList<>();
            for (VmTemplate template : properArchitectureTemplates) {
                final boolean isBlankOrVersionOfBlank = template.getId().equals(Guid.Empty) || template.getBaseTemplateId().equals(Guid.Empty);
                if (!isBlankOrVersionOfBlank) {
                    templatesWithoutBlank.add(template);
                }
            }
            initTemplateWithVersion(templatesWithoutBlank, null, false);
        }
    }), dataCenter.getId());
    instanceTypeManager.updateAll();
}
#method_after
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    super.postDataCenterWithClusterSelectedItemChanged();
    final DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = getModel().getSelectedDataCenter();
    if (dataCenter == null) {
        return;
    }
    AsyncDataProvider.getInstance().getTemplateListByDataCenter(asyncQuery(new AsyncCallback<List<VmTemplate>>() {

        @Override
        public void onSuccess(List<VmTemplate> templatesByDataCenter) {
            List<VmTemplate> properArchitectureTemplates = AsyncDataProvider.getInstance().filterTemplatesByArchitecture(templatesByDataCenter, dataCenterWithCluster.getCluster().getArchitecture());
            List<VmTemplate> templatesWithoutBlank = new ArrayList<>();
            for (VmTemplate template : properArchitectureTemplates) {
                final boolean isBlankOrVersionOfBlank = template.getId().equals(Guid.Empty) || template.getBaseTemplateId().equals(Guid.Empty);
                if (!isBlankOrVersionOfBlank) {
                    templatesWithoutBlank.add(template);
                }
            }
            initTemplateWithVersion(templatesWithoutBlank, null, false);
        }
    }), dataCenter.getId());
    instanceTypeManager.updateAll();
}
#end_block

#method_before
private void templateValidate() {
    AsyncDataProvider.getInstance().countAllTemplates(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            int count = (Integer) returnValue;
            if (count <= 1) {
                getModel().disableEditing(ConstantsManager.getInstance().getConstants().notAvailableWithNoTemplates());
            }
        }
    }));
}
#method_after
private void templateValidate() {
    AsyncDataProvider.getInstance().countAllTemplates(asyncQuery(new AsyncCallback<Integer>() {

        @Override
        public void onSuccess(Integer count) {
            if (count <= 1) {
                getModel().disableEditing(ConstantsManager.getInstance().getConstants().notAvailableWithNoTemplates());
            }
        }
    }));
}
#end_block

#method_before
private SafeHtml createBondTooltipMessage(HostInterfaceLineModel lineModel, InterfaceStatus interfaceStatus) {
    Bond bond = (Bond) lineModel.getInterface();
    SafeHtml bondProperties = templates.plainTextAsSafeHtml(messages.bondStatus(interfaceStatus.toString()));
    if (!InterfaceStatus.UP.equals(interfaceStatus)) {
        return bondProperties;
    }
    String adPartnerMac = Objects.toString(bond.getAdPartnerMac(), "");
    bondProperties = templates.addLineBreak(bondProperties, messages.bondAdPartnerMac(adPartnerMac));
    String adAgregatorId = Objects.toString(bond.getAdAggregatorId(), "");
    bondProperties = templates.addLineBreak(bondProperties, messages.bondAdAggregatorId(adAgregatorId));
    for (HostInterface nic : lineModel.getInterfaces()) {
        String nicName = nic.getName();
        String nicAggregatorId = Objects.toString(nic.getInterface().getAdAggregatorId());
        bondProperties = templates.addLineBreak(bondProperties, messages.bondSlaveAdAggregatorId(nicName, nicAggregatorId));
    }
    return bondProperties;
}
#method_after
private SafeHtml createBondTooltipMessage(HostInterfaceLineModel lineModel, InterfaceStatus interfaceStatus) {
    Bond bond = (Bond) lineModel.getInterface();
    StringBuilder bondProperties = new StringBuilder(messages.bondStatus(interfaceStatus.toString()));
    boolean isBond4 = BondMode.BOND4.equals(BondMode.parseBondMode(bond.getBondOptions()));
    if (InterfaceStatus.UP.equals(interfaceStatus) && isBond4) {
        // $NON-NLS-1$
        bondProperties.append("\n").append(createActiveBondTooltipMessage(bond, lineModel));
    }
    return new SafeHtmlBuilder().appendEscapedLines(bondProperties.toString()).toSafeHtml();
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc copyData(Map src, Map dst, boolean collapse) {
    JsonRpcRequest request = new RequestBuilder("SDM.copyData").withParameter("srcImage", src).withParameter("dstImage", dst).withParameter("collapse", collapse).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc copyData(String jobId, Map src, Map dst) {
    JsonRpcRequest request = new RequestBuilder("SDM.copy_data").withParameter("source", src).withParameter("destination", dst).withParameter("job_id", jobId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public VMListReturnForXmlRpc getExternalVmList(String uri, String username, String password, List<String> vmsNames) {
    JsonRpcRequest request;
    if (vmsNames == null) {
        request = new RequestBuilder("Host.getExternalVMs").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).build();
    } else {
        request = new RequestBuilder("Host.getExternalVMs").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).withParameter("vm_names", vmsNames).build();
    }
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturnForXmlRpc(response);
}
#method_after
@Override
public VMListReturnForXmlRpc getExternalVmList(String uri, String username, String password, List<String> vmsNames) {
    RequestBuilder requestBuilder = new RequestBuilder("Host.getExternalVMs").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).withOptionalParameterAsList("vm_names", vmsNames);
    JsonRpcRequest request = requestBuilder.build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturnForXmlRpc(response);
}
#end_block

#method_before
private void getAttachedTagsToSelectedVMs(TagListModel model) {
    ArrayList<Guid> vmIds = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    attachedTagsToEntities = new HashMap<>();
    allAttachedTags = new ArrayList<>();
    selectedItemsCounter = 0;
    for (Guid id : vmIds) {
        AsyncDataProvider.getInstance().getAttachedTagsToVm(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                VmListModel<Void> vmListModel = (VmListModel<Void>) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                vmListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                vmListModel.selectedItemsCounter++;
                if (vmListModel.selectedItemsCounter == vmListModel.getSelectedItems().size()) {
                    postGetAttachedTags(vmListModel, tagListModel);
                }
            }
        }), id);
    }
}
#method_after
private void getAttachedTagsToSelectedVMs(final TagListModel model) {
    ArrayList<Guid> vmIds = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    attachedTagsToEntities = new HashMap<>();
    allAttachedTags = new ArrayList<>();
    selectedItemsCounter = 0;
    for (Guid id : vmIds) {
        AsyncDataProvider.getInstance().getAttachedTagsToVm(new AsyncQuery<>(new AsyncCallback<List<Tags>>() {

            @Override
            public void onSuccess(List<Tags> returnValue) {
                allAttachedTags.addAll(returnValue);
                selectedItemsCounter++;
                if (selectedItemsCounter == getSelectedItems().size()) {
                    postGetAttachedTags(model);
                }
            }
        }), id);
    }
}
#end_block

#method_before
private void postGetAttachedTags(VmListModel<Void> vmListModel, TagListModel tagListModel) {
    if (vmListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(vmListModel.allAttachedTags, new TagsEqualityComparer());
        for (Tags tag : attachedTags) {
            int count = 0;
            for (Tags tag2 : vmListModel.allAttachedTags) {
                if (tag2.getTagId().equals(tag.getTagId())) {
                    count++;
                }
            }
            vmListModel.attachedTagsToEntities.put(tag.getTagId(), count == vmListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(vmListModel.attachedTagsToEntities);
    } else if ("OnAssignTags".equals(vmListModel.getLastExecutedCommand().getName())) {
        // $NON-NLS-1$
        vmListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#method_after
private void postGetAttachedTags(TagListModel tagListModel) {
    if (getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(allAttachedTags, new TagsEqualityComparer());
        for (Tags tag : attachedTags) {
            int count = 0;
            for (Tags tag2 : allAttachedTags) {
                if (tag2.getTagId().equals(tag.getTagId())) {
                    count++;
                }
            }
            attachedTagsToEntities.put(tag.getTagId(), count == getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(attachedTagsToEntities);
    } else if ("OnAssignTags".equals(getLastExecutedCommand().getName())) {
        // $NON-NLS-1$
        postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#end_block

#method_before
private void guide() {
    VmGuideModel model = new VmGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVirtualMachineGuideMeTitle());
    model.setHelpTag(HelpTag.new_virtual_machine___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_virtual_machine_-_guide_me");
    if (getGuideContext() == null) {
        VM vm = getSelectedItem();
        setGuideContext(vm.getId());
    }
    AsyncDataProvider.getInstance().getVmById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel<Void> vmListModel = (VmListModel<Void>) target;
            VmGuideModel model = (VmGuideModel) vmListModel.getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", vmListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
private void guide() {
    VmGuideModel model = new VmGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVirtualMachineGuideMeTitle());
    model.setHelpTag(HelpTag.new_virtual_machine___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_virtual_machine_-_guide_me");
    if (getGuideContext() == null) {
        VM vm = getSelectedItem();
        setGuideContext(vm.getId());
    }
    AsyncDataProvider.getInstance().getVmById(new AsyncQuery<>(new AsyncCallback<VM>() {

        @Override
        public void onSuccess(VM returnValue) {
            VmGuideModel model = (VmGuideModel) getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", VmListModel.this);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
private void edit() {
    VM vm = getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            editedVm = (VM) result;
            vmInitLoaded(editedVm);
        }
    };
    if (vm.isNextRunConfigurationExists()) {
        AsyncDataProvider.getInstance().getVmNextRunConfiguration(getVmInitQuery, vm.getId());
    } else {
        AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
    }
}
#method_after
private void edit() {
    VM vm = getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    // populating VMInit
    AsyncQuery<VM> getVmInitQuery = new AsyncQuery<>(new AsyncCallback<VM>() {

        @Override
        public void onSuccess(VM result) {
            editedVm = result;
            vmInitLoaded(editedVm);
        }
    });
    if (vm.isNextRunConfigurationExists()) {
        AsyncDataProvider.getInstance().getVmNextRunConfiguration(getVmInitQuery, vm.getId());
    } else {
        AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
    }
}
#end_block

#method_before
private void getTemplatesNotPresentOnExportDomain() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel<Void> vmListModel = (VmListModel<Void>) target;
            ArrayList<StoragePool> storagePools = (ArrayList<StoragePool>) returnValue;
            StoragePool storagePool = storagePools.size() > 0 ? storagePools.get(0) : null;
            vmListModel.postGetTemplatesNotPresentOnExportDomain(storagePool);
        }
    }), storageDomainId);
}
#method_after
private void getTemplatesNotPresentOnExportDomain() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery<>(new AsyncCallback<List<StoragePool>>() {

        @Override
        public void onSuccess(List<StoragePool> storagePools) {
            StoragePool storagePool = storagePools.size() > 0 ? storagePools.get(0) : null;
            postGetTemplatesNotPresentOnExportDomain(storagePool);
        }
    }), storageDomainId);
}
#end_block

#method_before
private void postGetTemplatesNotPresentOnExportDomain(StoragePool storagePool) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    if (storagePool != null) {
        AsyncDataProvider.getInstance().getAllTemplatesFromExportDomain(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel<Void> vmListModel = (VmListModel<Void>) target;
                HashMap<VmTemplate, ArrayList<DiskImage>> templatesDiskSet = (HashMap<VmTemplate, ArrayList<DiskImage>>) returnValue;
                HashMap<String, ArrayList<String>> templateDic = new HashMap<>();
                // check if relevant templates are already there
                for (Object selectedItem : vmListModel.getSelectedItems()) {
                    VM vm = (VM) selectedItem;
                    boolean hasMatch = false;
                    for (VmTemplate a : templatesDiskSet.keySet()) {
                        if (vm.getVmtGuid().equals(a.getId())) {
                            hasMatch = true;
                            break;
                        }
                    }
                    if (!vm.getVmtGuid().equals(Guid.Empty) && !hasMatch) {
                        if (!templateDic.containsKey(vm.getVmtName())) {
                            templateDic.put(vm.getVmtName(), new ArrayList<String>());
                        }
                        templateDic.get(vm.getVmtName()).add(vm.getName());
                    }
                }
                String tempStr;
                ArrayList<String> tempList;
                ArrayList<String> missingTemplates = new ArrayList<>();
                for (Map.Entry<String, ArrayList<String>> keyValuePair : templateDic.entrySet()) {
                    tempList = keyValuePair.getValue();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    StringBuilder sb = new StringBuilder("Template " + keyValuePair.getKey() + " (for ");
                    int i;
                    for (i = 0; i < tempList.size() - 1; i++) {
                        sb.append(tempList.get(i));
                        // $NON-NLS-1$
                        sb.append(", ");
                    }
                    sb.append(tempList.get(i));
                    // $NON-NLS-1$
                    sb.append(")");
                    missingTemplates.add(sb.toString());
                }
                vmListModel.postExportGetMissingTemplates(missingTemplates);
            }
        }), storagePool.getId(), storageDomainId);
    }
}
#method_after
private void postGetTemplatesNotPresentOnExportDomain(StoragePool storagePool) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = model.getStorage().getSelectedItem().getId();
    if (storagePool != null) {
        AsyncDataProvider.getInstance().getAllTemplatesFromExportDomain(new AsyncQuery<>(new AsyncCallback<Map<VmTemplate, ArrayList<DiskImage>>>() {

            @Override
            public void onSuccess(Map<VmTemplate, ArrayList<DiskImage>> templatesDiskSet) {
                HashMap<String, ArrayList<String>> templateDic = new HashMap<>();
                // check if relevant templates are already there
                for (VM vm : getSelectedItems()) {
                    boolean hasMatch = false;
                    for (VmTemplate a : templatesDiskSet.keySet()) {
                        if (vm.getVmtGuid().equals(a.getId())) {
                            hasMatch = true;
                            break;
                        }
                    }
                    if (!vm.getVmtGuid().equals(Guid.Empty) && !hasMatch) {
                        if (!templateDic.containsKey(vm.getVmtName())) {
                            templateDic.put(vm.getVmtName(), new ArrayList<String>());
                        }
                        templateDic.get(vm.getVmtName()).add(vm.getName());
                    }
                }
                ArrayList<String> tempList;
                ArrayList<String> missingTemplates = new ArrayList<>();
                for (Map.Entry<String, ArrayList<String>> keyValuePair : templateDic.entrySet()) {
                    tempList = keyValuePair.getValue();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    StringBuilder sb = new StringBuilder("Template " + keyValuePair.getKey() + " (for ");
                    int i;
                    for (i = 0; i < tempList.size() - 1; i++) {
                        sb.append(tempList.get(i));
                        // $NON-NLS-1$
                        sb.append(", ");
                    }
                    sb.append(tempList.get(i));
                    // $NON-NLS-1$
                    sb.append(")");
                    missingTemplates.add(sb.toString());
                }
                postExportGetMissingTemplates(missingTemplates);
            }
        }), storagePool.getId(), storageDomainId);
    }
}
#end_block

#method_before
@Override
protected void sendWarningForNonExportableDisks(VM entity) {
    // load VM disks and check if there is one which doesn't allow snapshot
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(getWindow(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final ExportVmModel model = (ExportVmModel) target;
            @SuppressWarnings("unchecked")
            final ArrayList<Disk> vmDisks = (ArrayList<Disk>) returnValue;
            VmModelHelper.sendWarningForNonExportableDisks(model, vmDisks, VmModelHelper.WarningType.VM_EXPORT);
        }
    }), entity.getId());
}
#method_after
@Override
protected void sendWarningForNonExportableDisks(VM entity) {
    // load VM disks and check if there is one which doesn't allow snapshot
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery<>(new AsyncCallback<List<Disk>>() {

        @Override
        public void onSuccess(List<Disk> vmDisks) {
            final ExportVmModel model = (ExportVmModel) getWindow();
            VmModelHelper.sendWarningForNonExportableDisks(model, vmDisks, VmModelHelper.WarningType.VM_EXPORT);
        }
    }), entity.getId());
}
#end_block

#method_before
private void runOnce() {
    VM vm = getSelectedItem();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            RunOnceModel runOnceModel = new WebadminRunOnceModel((VM) result, VmListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    };
    AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
}
#method_after
private void runOnce() {
    VM vm = getSelectedItem();
    // populating VMInit
    AsyncDataProvider.getInstance().getVmById(new AsyncQuery<>(new AsyncCallback<VM>() {

        @Override
        public void onSuccess(VM result) {
            RunOnceModel runOnceModel = new WebadminRunOnceModel(result, VmListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    }), vm.getId());
}
#end_block

#method_before
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel<Void> vmListModel = (VmListModel<Void>) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                    VmModel.fireValidationCompleteEvent();
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    }
}
#method_after
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery<>(new AsyncCallback<Boolean>() {

            @Override
            public void onSuccess(Boolean isNameUnique) {
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                    VmModel.fireValidationCompleteEvent();
                } else {
                    postNameUniqueCheck();
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    }
}
#end_block

#method_before
private void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    VM newVm = buildVmOnNewTemplate(model, vm);
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    BuilderExecutor.build(model, addVmTemplateParameters, new UnitToAddVmTemplateParametersBuilder());
    model.startProgress();
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel<Void> vmListModel = (VmListModel<Void>) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#method_after
private void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    VM newVm = buildVmOnNewTemplate(model, vm);
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    BuilderExecutor.build(model, addVmTemplateParameters, new UnitToAddVmTemplateParametersBuilder());
    model.startProgress();
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                cancel();
            }
        }
    }, this);
}
#end_block

#method_before
private void powerAction(final String actionName, final String title, final String message) {
    Guid clusterId = getClusterIdOfSelectedVms();
    if (clusterId == null) {
        powerAction(actionName, title, message, false);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Cluster cluster = (Cluster) returnValue;
                if (cluster != null) {
                    powerAction(actionName, title, message, cluster.isOptionalReasonRequired());
                }
            }
        }), clusterId);
    }
}
#method_after
private void powerAction(final String actionName, final String title, final String message) {
    Guid clusterId = getClusterIdOfSelectedVms();
    if (clusterId == null) {
        powerAction(actionName, title, message, false);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(new AsyncCallback<Cluster>() {

            @Override
            public void onSuccess(Cluster cluster) {
                if (cluster != null) {
                    powerAction(actionName, title, message, cluster.isOptionalReasonRequired());
                }
            }
        }), clusterId);
    }
}
#end_block

#method_before
private void changeCD() {
    final VM vm = getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrNull(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel<Void> vmListModel2 = (VmListModel<Void>) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrNull(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    };
    AsyncDataProvider.getInstance().getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnChangeCD", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
private void changeCD() {
    final VM vm = getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrNull(images1));
    AsyncDataProvider.getInstance().getIrsImageList(new AsyncQuery<>(new AsyncCallback<List<String>>() {

        @Override
        public void onSuccess(List<String> images) {
            AttachCdModel _attachCdModel = (AttachCdModel) getWindow();
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrNull(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    }), vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnChangeCD", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void updateVM(final UnitVmModel model) {
    final VM selectedItem = getSelectedItem();
    // explicitly pass non-editable field from the original VM
    getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
    getcurrentVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    if (selectedItem.isRunningOrPaused() && !selectedItem.isHostedEngine()) {
        AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object thisModel, Object returnValue) {
                List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                // provide warnings if isVmUnpinned()
                if (!changedFields.isEmpty() || isVmUnpinned()) {
                    VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                    if (isVmUnpinned()) {
                        confirmModel.setVmUnpinned();
                    }
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                    confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_next_run_configuration");
                    confirmModel.setChangedFields(changedFields);
                    confirmModel.setCpuPluggable(VmCommonUtils.isCpusToBeHotplugged(selectedItem, getcurrentVm()));
                    boolean isMemoryHotUnplugSupported = AsyncDataProvider.getInstance().isMemoryHotUnplugSupported(getcurrentVm());
                    confirmModel.setMemoryPluggable(VmCommonUtils.isMemoryToBeHotplugged(selectedItem, getcurrentVm(), isMemoryHotUnplugSupported));
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", VmListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    updateExistingVm(false);
                }
            }

            private boolean isVmUnpinned() {
                if (selectedItem.isRunning()) {
                    if (selectedItem.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && getcurrentVm().getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
                        return true;
                    }
                }
                return false;
            }
        }));
    } else {
        updateExistingVm(false);
    }
}
#method_after
@Override
protected void updateVM(final UnitVmModel model) {
    final VM selectedItem = getSelectedItem();
    // explicitly pass non-editable field from the original VM
    getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
    getcurrentVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    if (selectedItem.isRunningOrPaused() && !selectedItem.isHostedEngine()) {
        AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

            @Override
            public void onSuccess(VdcQueryReturnValue returnValue) {
                List<String> changedFields = returnValue.getReturnValue();
                // provide warnings if isVmUnpinned()
                if (!changedFields.isEmpty() || isVmUnpinned()) {
                    VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                    if (isVmUnpinned()) {
                        confirmModel.setVmUnpinned();
                    }
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                    confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_next_run_configuration");
                    confirmModel.setChangedFields(changedFields);
                    confirmModel.setCpuPluggable(VmCommonUtils.isCpusToBeHotplugged(selectedItem, getcurrentVm()));
                    boolean isMemoryHotUnplugSupported = AsyncDataProvider.getInstance().isMemoryHotUnplugSupported(getcurrentVm());
                    confirmModel.setMemoryPluggable(VmCommonUtils.isMemoryToBeHotplugged(selectedItem, getcurrentVm(), isMemoryHotUnplugSupported));
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", VmListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    updateExistingVm(false);
                }
            }

            private boolean isVmUnpinned() {
                if (selectedItem.isRunning()) {
                    if (selectedItem.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && getcurrentVm().getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
                        return true;
                    }
                }
                return false;
            }
        }));
    } else {
        updateExistingVm(false);
    }
}
#end_block

#method_before
private void onConfigureVmsToImport() {
    final ImportVmsModel importVmsModel = (ImportVmsModel) getWindow();
    if (importVmsModel == null) {
        return;
    }
    if (importVmsModel.vmsToImportHaveFullInfo() && !importVmsModel.validateArchitectures(importVmsModel.getVmsToImport())) {
        return;
    }
    final ImportVmModel model = importVmsModel.getSpecificImportModel();
    if (importVmsModel.vmsToImportHaveFullInfo()) {
        // remove import-vms window first
        setWindow(null);
        setWindow(model);
    } else {
        initImportModelforVmsToImportNamesOnly(importVmsModel, model);
    }
}
#method_after
private void onConfigureVmsToImport() {
    final ImportVmsModel importVmsModel = (ImportVmsModel) getWindow();
    if (importVmsModel == null) {
        return;
    }
    boolean vmsToImportHaveFullInfo = importVmsModel.vmsToImportHaveFullInfo();
    if (vmsToImportHaveFullInfo && !importVmsModel.validateArchitectures(importVmsModel.getVmsToImport())) {
        return;
    }
    final ImportVmModel model = importVmsModel.getSpecificImportModel(vmsToImportHaveFullInfo);
    if (vmsToImportHaveFullInfo) {
        // remove import-vms window first
        setWindow(null);
        setWindow(model);
    } else {
        initImportModelForVmsToImportNamesOnly(importVmsModel, model);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc copyData(Map src, Map dst, boolean collapse) {
    Map<String, Object> xmlRpcReturnValue = vdsServer.copyData(src, dst, collapse);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc copyData(String jobId, Map src, Map dst) {
    Map<String, Object> xmlRpcReturnValue = vdsServer.copyData(jobId, src, dst);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
private void fetchCpuProfiles(Guid clusterId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetCpuProfilesByClusterId, new IdQueryParameters(clusterId), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<CpuProfile> cpuProfiles = ((VdcQueryReturnValue) returnValue).getReturnValue();
            getCpuProfiles().setItems(cpuProfiles);
        }
    }));
}
#method_after
private void fetchCpuProfiles(Guid clusterId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetCpuProfilesByClusterId, new IdQueryParameters(clusterId), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            List<CpuProfile> cpuProfiles = returnValue.getReturnValue();
            getCpuProfiles().setItems(cpuProfiles);
        }
    }));
}
#end_block

#method_before
public void setItems(final INewAsyncCallback callback, final List<VM> externalVms) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(createSearchPattern(externalVms), SearchType.VM), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VM> vms = ((VdcQueryReturnValue) returnValue).getReturnValue();
            Set<String> existingNames = new HashSet<>();
            for (VM vm : vms) {
                if (vm.getStoragePoolId().equals(getStoragePool().getId())) {
                    existingNames.add(vm.getName());
                }
            }
            List<ImportVmData> vmDataList = new ArrayList<>();
            for (VM vm : externalVms) {
                ImportVmData vmData = new ImportVmData(vm);
                if (vms.contains(vm)) {
                    vmData.setExistsInSystem(true);
                    vmData.getClone().setEntity(true);
                    vmData.getClone().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().importVMThatExistsInSystemMustClone());
                    vmData.getClone().setIsChangeable(false);
                }
                vmData.setNameExistsInTheSystem(existingNames.contains(vm.getName()));
                vmDataList.add(vmData);
            }
            setItems(vmDataList);
            callback.onSuccess(model, returnValue);
        }
    }));
}
#method_after
public void setItems(final AsyncCallback<VdcQueryReturnValue> callback, final List<VM> externalVms) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(createSearchPattern(externalVms), SearchType.VM), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            List<VM> vms = returnValue.getReturnValue();
            Set<String> existingNames = new HashSet<>();
            for (VM vm : vms) {
                if (vm.getStoragePoolId().equals(getStoragePool().getId())) {
                    existingNames.add(vm.getName());
                }
            }
            List<ImportVmData> vmDataList = new ArrayList<>();
            for (VM vm : externalVms) {
                ImportVmData vmData = new ImportVmData(vm);
                if (vms.contains(vm)) {
                    vmData.setExistsInSystem(true);
                    vmData.getClone().setEntity(true);
                    vmData.getClone().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().importVMThatExistsInSystemMustClone());
                    vmData.getClone().setIsChangeable(false);
                }
                vmData.setNameExistsInTheSystem(existingNames.contains(vm.getName()));
                vmDataList.add(vmData);
            }
            setItems(vmDataList);
            callback.onSuccess(returnValue);
        }
    }));
}
#end_block

#method_before
@Override
protected ToStringBuilder appendAttributes(ToStringBuilder tsb) {
    return super.appendAttributes(tsb).append("url", url).append("username", username).append("originType", originType).append("vmsNames", vmsNames);
}
#method_after
@Override
protected ToStringBuilder appendAttributes(ToStringBuilder tsb) {
    return super.appendAttributes(tsb).append("url", url).append("username", username).append("originType", originType).append("namesOfVms", namesOfVms);
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    vmListReturn = getBroker().getExternalVmList(getParameters().getUrl(), getParameters().getUsername(), getParameters().getPassword(), getParameters().getVmsNames());
    proceedProxyReturnValue();
    List<VM> vms = new ArrayList<>();
    List<VM> notDownVms = new ArrayList<>();
    for (Map<String, Object> map : vmListReturn.vmList) {
        VM vm = VdsBrokerObjectsBuilder.buildVmsDataFromExternalProvider(map);
        if (vm != null) {
            vm.setOrigin(getParameters().getOriginType());
            vms.add(vm);
            // identify vms not in Down status
            if (!vm.isDown()) {
                notDownVms.add(vm);
            }
        }
    }
    logNonDownVms(notDownVms);
    setReturnValue(vms);
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    vmListReturn = getBroker().getExternalVmList(getParameters().getUrl(), getParameters().getUsername(), getParameters().getPassword(), getParameters().getNamesOfVms());
    proceedProxyReturnValue();
    List<VM> vms = new ArrayList<>();
    List<VM> notDownVms = new ArrayList<>();
    for (Map<String, Object> map : vmListReturn.vmList) {
        VM vm = VdsBrokerObjectsBuilder.buildVmsDataFromExternalProvider(map);
        if (vm != null) {
            vm.setOrigin(getParameters().getOriginType());
            vms.add(vm);
            // identify vms not in Down status
            if (!vm.isDown()) {
                notDownVms.add(vm);
            }
        }
    }
    logNonDownVms(notDownVms);
    setReturnValue(vms);
}
#end_block

#method_before
private void logNonDownVms(List<VM> notDownVms) {
    if (!notDownVms.isEmpty()) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.addCustomValue("URL", getParameters().getUrl());
        logable.addCustomValue("Vms", StringUtils.join(notDownVms, ","));
        auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_GET_EXTERNAL_VMS_NOT_IN_DOWN_STATUS);
    }
}
#method_after
private void logNonDownVms(List<VM> notDownVms) {
    if (!notDownVms.isEmpty()) {
        if (shouldLogToAuditLog()) {
            AuditLogableBase logable = new AuditLogableBase();
            logable.addCustomValue("URL", getParameters().getUrl());
            logable.addCustomValue("Vms", StringUtils.join(notDownVms, ","));
            auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_GET_EXTERNAL_VMS_NOT_IN_DOWN_STATUS);
        } else {
            log.warn("The following VMs retrieved from external server '{}' are not in down status and therefore can't be imported: '{}'.", getParameters().getUrl(), StringUtils.join(notDownVms, ","));
        }
    }
}
#end_block

#method_before
private void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private void getDefaultConfigurationVersion(final LoginModel loginModel) {
    AsyncQuery callback = new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
public void initCache(LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initOsDefaultIconIds();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initMemoryHotUnplugSupportMap();
    initCustomPropertiesList();
    initSoundDeviceSupportMap();
    initMigrationPolicies();
    initCpuMap();
}
#method_after
public void initCache(final LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery<>(new AsyncCallback<Map<KeyValuePairCompat<ConfigurationValues, String>, Object>>() {

        @Override
        public void onSuccess(Map<KeyValuePairCompat<ConfigurationValues, String>, Object> returnValue) {
            getDefaultConfigurationVersion(loginModel);
        }
    }));
    initOsNames();
    initOsDefaultIconIds();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initMemoryHotUnplugSupportMap();
    initCustomPropertiesList();
    initSoundDeviceSupportMap();
    initMigrationPolicies();
    initCpuMap();
}
#end_block

#method_before
private void initMigrationPolicies() {
    AsyncQuery aQuery = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            migrationPolicies = (List<MigrationPolicy>) returnValue;
        }
    });
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<MigrationPolicy>();
            }
            Collections.sort((List<MigrationPolicy>) returnValue, new Comparator<MigrationPolicy>() {

                @Override
                public int compare(MigrationPolicy m1, MigrationPolicy m2) {
                    // the empty one is always the first
                    if (NoMigrationPolicy.ID.equals(m1.getId())) {
                        return -1;
                    }
                    return m1.getName().compareTo(m2.getName());
                }
            });
            return returnValue;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllMigrationPolicies, new VdcQueryParametersBase(), aQuery);
}
#method_after
private void initMigrationPolicies() {
    AsyncQuery<List<MigrationPolicy>> aQuery = new AsyncQuery<>(new AsyncCallback<List<MigrationPolicy>>() {

        @Override
        public void onSuccess(List<MigrationPolicy> returnValue) {
            migrationPolicies = returnValue;
        }
    });
    aQuery.converterCallback = new Converter<List<MigrationPolicy>>() {

        @Override
        public List<MigrationPolicy> convert(Object returnValue) {
            if (returnValue == null) {
                return new ArrayList<>();
            }
            List<MigrationPolicy> policies = (List<MigrationPolicy>) returnValue;
            Collections.sort(policies, new Comparator<MigrationPolicy>() {

                @Override
                public int compare(MigrationPolicy m1, MigrationPolicy m2) {
                    // the empty one is always the first
                    if (NoMigrationPolicy.ID.equals(m1.getId())) {
                        return -1;
                    }
                    return m1.getName().compareTo(m2.getName());
                }
            });
            return policies;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllMigrationPolicies, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
private void initCustomPropertiesList() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            customPropertiesList = (Map<Version, Map<String, String>>) returnValue;
        }
    };
    callback.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return (source != null) ? (Map<Version, Map<String, String>>) source : new HashMap<Version, Map<String, String>>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase().withoutRefresh(), callback);
}
#method_after
private void initCustomPropertiesList() {
    AsyncQuery<Map<Version, Map<String, String>>> callback = new AsyncQuery<>(new AsyncCallback<Map<Version, Map<String, String>>>() {

        @Override
        public void onSuccess(Map<Version, Map<String, String>> returnValue) {
            customPropertiesList = returnValue;
        }
    });
    callback.converterCallback = new MapConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase().withoutRefresh(), callback);
}
#end_block

#method_before
public void initDefaultOSes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            defaultOSes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDefaultOSes), callback);
}
#method_after
public void initDefaultOSes() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDefaultOSes), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            defaultOSes = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
public void getStorageDomainsWithAttachedStoragePoolGuid(AsyncQuery aQuery, StoragePool storagePool, List<StorageDomain> storageDomains, StorageServerConnections storageServerConnection, Guid vdsId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source == null ? new ArrayList<StorageDomain>() : (ArrayList<StorageDomain>) source;
        }
    };
    if (storageDomains != null) {
        // Get file storage domains
        StorageDomainsAndStoragePoolIdQueryParameters parameters = new StorageDomainsAndStoragePoolIdQueryParameters(storageDomains, storagePool.getId(), vdsId);
        Frontend.getInstance().runQuery(VdcQueryType.GetBlockStorageDomainsWithAttachedStoragePoolGuid, parameters, aQuery);
    } else {
        // Get block storage domains
        StorageDomainsAndStoragePoolIdQueryParameters parameters = new StorageDomainsAndStoragePoolIdQueryParameters(storageServerConnection, storagePool.getId(), vdsId);
        Frontend.getInstance().runQuery(VdcQueryType.GetFileStorageDomainsWithAttachedStoragePoolGuid, parameters, aQuery);
    }
}
#method_after
public void getStorageDomainsWithAttachedStoragePoolGuid(AsyncQuery<List<StorageDomainStatic>> aQuery, StoragePool storagePool, List<StorageDomain> storageDomains) {
    aQuery.converterCallback = new ListConverter<>();
    StorageDomainsAndStoragePoolIdQueryParameters parameters = new StorageDomainsAndStoragePoolIdQueryParameters(storageDomains, storagePool.getId());
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsWithAttachedStoragePoolGuid, parameters, aQuery);
}
#end_block

#method_before
private void initMigrationSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            migrationSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMigrationSupport), callback);
}
#method_after
private void initMigrationSupportMap() {
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMigrationSupport), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            migrationSupport = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
private void initMemorySnapshotSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            memorySnapshotSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMemorySnapshotSupport), callback);
}
#method_after
private void initMemorySnapshotSupportMap() {
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMemorySnapshotSupport), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            memorySnapshotSupport = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
private void initSuspendSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            suspendSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetSuspendSupport), callback);
}
#method_after
private void initSuspendSupportMap() {
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetSuspendSupport), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            suspendSupport = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
private void initMemoryHotUnplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            memoryHotUnplugSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMemoryHotUnplugSupport), callback);
}
#method_after
private void initMemoryHotUnplugSupportMap() {
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMemoryHotUnplugSupport), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            memoryHotUnplugSupport = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
public void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#method_after
public void initNicHotplugSupportMap() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            nicHotplugSupportMap = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
public void initBalloonSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            balloonSupportMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetBalloonSupportMap), callback);
}
#method_after
public void initBalloonSupportMap() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetBalloonSupportMap), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            balloonSupportMap = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
public void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#method_after
public void initDiskHotpluggableInterfacesMap() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            diskHotpluggableInterfacesMap = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
public void initSoundDeviceSupportMap() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetSoundDeviceSupportMap), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            soundDeviceSupportMap = ((VdcQueryReturnValue) result).getReturnValue();
        }
    }));
}
#method_after
public void initSoundDeviceSupportMap() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetSoundDeviceSupportMap), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue result) {
            soundDeviceSupportMap = result.getReturnValue();
        }
    }));
}
#end_block

#method_before
public void getUserProfile(AsyncQuery aQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.GetUserProfile, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getUserProfile(AsyncQuery<VdcQueryReturnValue> aQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.GetUserProfile, new VdcQueryParametersBase().withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getAAAProfilesListViaPublic(AsyncQuery aQuery, boolean passwordBasedOnly) {
    convertAAAProfilesResult(aQuery, passwordBasedOnly);
    Frontend.getInstance().runPublicQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getAAAProfilesListViaPublic(AsyncQuery<List<String>> aQuery, boolean passwordBasedOnly) {
    convertAAAProfilesResult(aQuery, passwordBasedOnly);
    Frontend.getInstance().runPublicQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void isFloppySupported(AsyncQuery aQuery, Integer osId, Version version) {
    aQuery.converterCallback = new IAsyncConverter<Boolean>() {

        @Override
        public Boolean convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Boolean) source : Boolean.FALSE;
        }
    };
    OsQueryParameters params = new OsQueryParameters(OsRepositoryVerb.GetFloppySupport, osId, version);
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, params, aQuery);
}
#method_after
public static void isFloppySupported(AsyncQuery<Boolean> aQuery, Integer osId, Version version) {
    aQuery.converterCallback = new DefaultValueConverter<>(Boolean.FALSE);
    OsQueryParameters params = new OsQueryParameters(OsRepositoryVerb.GetFloppySupport, osId, version);
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, params, aQuery);
}
#end_block

#method_before
public void getIsoDomainByDataCenterId(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                for (StorageDomain domain : storageDomains) {
                    if (domain.getStorageDomainType() == StorageDomainType.ISO) {
                        return domain;
                    }
                }
            }
            return null;
        }
    };
    IdQueryParameters getIsoParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getIsoParams, aQuery);
}
#method_after
public void getIsoDomainByDataCenterId(AsyncQuery<StorageDomain> aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new Converter<StorageDomain>() {

        @Override
        public StorageDomain convert(Object source) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                for (StorageDomain domain : storageDomains) {
                    if (domain.getStorageDomainType() == StorageDomainType.ISO) {
                        return domain;
                    }
                }
            }
            return null;
        }
    };
    IdQueryParameters getIsoParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getIsoParams, aQuery);
}
#end_block

#method_before
public void getExportDomainByDataCenterId(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
            for (StorageDomain domain : storageDomains) {
                if (domain.getStorageDomainType() == StorageDomainType.ImportExport) {
                    return domain;
                }
            }
            return null;
        }
    };
    IdQueryParameters getExportParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getExportParams, aQuery);
}
#method_after
public void getExportDomainByDataCenterId(AsyncQuery<StorageDomain> aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new Converter<StorageDomain>() {

        @Override
        public StorageDomain convert(Object source) {
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
            for (StorageDomain domain : storageDomains) {
                if (domain.getStorageDomainType() == StorageDomainType.ImportExport) {
                    return domain;
                }
            }
            return null;
        }
    };
    IdQueryParameters getExportParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getExportParams, aQuery);
}
#end_block

#method_before
private void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId, boolean forceRefresh, ImageFileType imageFileType, IAsyncConverter converterCallBack) {
    aQuery.converterCallback = converterCallBack;
    GetImagesListByStoragePoolIdParameters parameters = new GetImagesListByStoragePoolIdParameters(storagePoolId, imageFileType);
    parameters.setForceRefresh(forceRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, parameters, aQuery);
}
#method_after
public void getIrsImageList(AsyncQuery<List<String>> aQuery, Guid storagePoolId) {
    getIrsImageList(aQuery, storagePoolId, false);
}
#end_block

#method_before
public void getFloppyImageList(AsyncQuery aQuery, Guid storagePoolId) {
    getIrsImageList(aQuery, storagePoolId, false, ImageFileType.Floppy);
}
#method_after
public void getFloppyImageList(AsyncQuery<List<String>> aQuery, Guid storagePoolId) {
    getIrsImageList(aQuery, storagePoolId, false, ImageFileType.Floppy);
}
#end_block

#method_before
public void getUnknownImageList(AsyncQuery aQuery, Guid storagePoolId, boolean forceRefresh) {
    getIrsImageList(aQuery, storagePoolId, forceRefresh, ImageFileType.All, new RepoImageToImageFileNameAsyncConverter() {

        @Override
        protected String transform(ArrayList<String> fileNameList, RepoImage repoImage) {
            return ISO_PREFIX + super.transform(fileNameList, repoImage);
        }

        @Override
        protected boolean desiredImage(RepoImage repoImage) {
            return ImageFileType.Unknown == repoImage.getFileType();
        }
    });
}
#method_after
public void getUnknownImageList(AsyncQuery<List<String>> aQuery, Guid storagePoolId, boolean forceRefresh) {
    getIrsImageList(aQuery, storagePoolId, forceRefresh, ImageFileType.All, new RepoImageToImageFileNameAsyncConverter() {

        @Override
        protected String transform(ArrayList<String> fileNameList, RepoImage repoImage) {
            return ISO_PREFIX + super.transform(fileNameList, repoImage);
        }

        @Override
        protected boolean desiredImage(RepoImage repoImage) {
            return ImageFileType.Unknown == repoImage.getFileType();
        }
    });
}
#end_block

#method_before
public void getDefaultManagementNetwork(AsyncQuery aQuery, Guid dataCenterId) {
    runQueryByIdParameter(VdcQueryType.GetDefaultManagementNetwork, aQuery, dataCenterId);
}
#method_after
public void getDefaultManagementNetwork(AsyncQuery<Network> aQuery, Guid dataCenterId) {
    runQueryByIdParameter(VdcQueryType.GetDefaultManagementNetwork, aQuery, dataCenterId);
}
#end_block

#method_before
public void getManagementNetwork(AsyncQuery aQuery, Guid clusterId) {
    runQueryByIdParameter(VdcQueryType.GetManagementNetwork, aQuery, clusterId);
}
#method_after
public void getManagementNetwork(AsyncQuery<Network> aQuery, Guid clusterId) {
    runQueryByIdParameter(VdcQueryType.GetManagementNetwork, aQuery, clusterId);
}
#end_block

#method_before
public void isManagementNetwork(AsyncQuery aQuery, Guid networkId) {
    runQueryByIdParameter(VdcQueryType.IsManagementNetwork, aQuery, networkId);
}
#method_after
public void isManagementNetwork(AsyncQuery<Boolean> aQuery, Guid networkId) {
    runQueryByIdParameter(VdcQueryType.IsManagementNetwork, aQuery, networkId);
}
#end_block

#method_before
public void isClusterEmpty(AsyncQuery aQuery, Guid clusterId) {
    runQueryByIdParameter(VdcQueryType.IsClusterEmpty, aQuery, clusterId);
}
#method_after
public void isClusterEmpty(AsyncQuery<Boolean> aQuery, Guid clusterId) {
    runQueryByIdParameter(VdcQueryType.IsClusterEmpty, aQuery, clusterId);
}
#end_block

#method_before
private void runQueryByIdParameter(VdcQueryType queryType, AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new AsIsAsyncConverter();
    Frontend.getInstance().runQuery(queryType, new IdQueryParameters(id), aQuery);
}
#method_after
private void runQueryByIdParameter(VdcQueryType queryType, AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new CastingConverter();
    Frontend.getInstance().runQuery(queryType, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public void getHostArchitecture(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter<ArchitectureType>() {

        @Override
        public ArchitectureType convert(Object source, AsyncQuery _asyncQuery) {
            return (ArchitectureType) source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostArchitecture, new IdQueryParameters(id), aQuery);
}
#method_after
public void getHostArchitecture(AsyncQuery<ArchitectureType> aQuery, Guid id) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetHostArchitecture, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public void getClusterById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterById, new IdQueryParameters(id), aQuery);
}
#method_after
public void getClusterById(AsyncQuery<Cluster> aQuery, Guid id) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterById, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public void getClusterListByName(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Cluster>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Cluster: name=" + name + " sortby name", SearchType.Cluster), aQuery);
}
#method_after
public void getClusterListByName(AsyncQuery<List<Cluster>> aQuery, String name) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Cluster: name=" + name + " sortby name", SearchType.Cluster), aQuery);
}
#end_block

#method_before
public void getAuthzGroupsByUserId(AsyncQuery aQuery, Guid userId) {
    aQuery.converterCallback = new IAsyncConverter<List<AuthzGroup>>() {

        @Override
        public List<AuthzGroup> convert(Object source, AsyncQuery _asyncQuery) {
            return (List<AuthzGroup>) source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAuthzGroupsByUserId, new IdQueryParameters(userId), aQuery);
}
#method_after
public void getAuthzGroupsByUserId(AsyncQuery<List<AuthzGroup>> aQuery, Guid userId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAuthzGroupsByUserId, new IdQueryParameters(userId), aQuery);
}
#end_block

#method_before
public void getPoolById(AsyncQuery aQuery, Guid poolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmPoolById, new IdQueryParameters(poolId), aQuery);
}
#method_after
public void getPoolById(AsyncQuery<VmPool> aQuery, Guid poolId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmPoolById, new IdQueryParameters(poolId), aQuery);
}
#end_block

#method_before
public void getVmById(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmByVmId, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getVmById(AsyncQuery<VM> aQuery, Guid vmId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmByVmId, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public void getVmNextRunConfiguration(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getVmNextRunConfiguration(AsyncQuery<VM> aQuery, Guid vmId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public void getVmChangedFieldsForNextRun(VM original, VM updated, VmManagementParametersBase updateVmParameters, AsyncQuery aQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmChangedFieldsForNextRun, new GetVmChangedFieldsForNextRunParameters(original, updated, updateVmParameters), aQuery);
}
#method_after
public void getVmChangedFieldsForNextRun(VM original, VM updated, VmManagementParametersBase updateVmParameters, AsyncQuery<VdcQueryReturnValue> aQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmChangedFieldsForNextRun, new GetVmChangedFieldsForNextRunParameters(original, updated, updateVmParameters), aQuery);
}
#end_block

#method_before
public void getDataCenterList(AsyncQuery aQuery, boolean doRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    // $NON-NLS-1$
    SearchParameters params = new SearchParameters("DataCenter: sortby name", SearchType.StoragePool);
    Frontend.getInstance().runQuery(VdcQueryType.Search, doRefresh ? params : params.withoutRefresh(), aQuery);
}
#method_after
public void getDataCenterList(AsyncQuery<List<StoragePool>> aQuery) {
    getDataCenterList(aQuery, true);
}
#end_block

#method_before
public void getDataCenterByClusterServiceList(AsyncQuery aQuery, boolean supportsVirtService, boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            // sort data centers
            final ArrayList<StoragePool> storagePoolList = (ArrayList<StoragePool>) source;
            Collections.sort(storagePoolList, new NameableComparator());
            return source;
        }
    };
    final GetStoragePoolsByClusterServiceParameters parameters = new GetStoragePoolsByClusterServiceParameters();
    parameters.setSupportsVirtService(supportsVirtService);
    parameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByClusterService, parameters, aQuery);
}
#method_after
public void getDataCenterByClusterServiceList(AsyncQuery<List<StoragePool>> aQuery, boolean supportsVirtService, boolean supportsGlusterService) {
    aQuery.converterCallback = new SortListByNameConverter<>();
    final GetStoragePoolsByClusterServiceParameters parameters = new GetStoragePoolsByClusterServiceParameters();
    parameters.setSupportsVirtService(supportsVirtService);
    parameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByClusterService, parameters, aQuery);
}
#end_block

#method_before
public void getDataCenterListByName(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("DataCenter: name=" + name + " sortby name", SearchType.StoragePool), aQuery);
}
#method_after
public void getDataCenterListByName(AsyncQuery<List<StoragePool>> aQuery, String name) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("DataCenter: name=" + name + " sortby name", SearchType.StoragePool), aQuery);
}
#end_block

#method_before
public void getSpiceUsbAutoShare(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source == null || (Boolean) source;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SpiceUsbAutoShare, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getSpiceUsbAutoShare(AsyncQuery<Boolean> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(Boolean.TRUE);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SpiceUsbAutoShare, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getConfigurationValueBoolean(AsyncQuery aQuery, ConfigurationValues configVal) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Boolean) source).booleanValue() : true;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(configVal, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getConfigurationValueBoolean(AsyncQuery<Boolean> aQuery, ConfigurationValues configVal) {
    aQuery.converterCallback = new DefaultValueConverter<>(Boolean.TRUE);
    getConfigFromCache(new GetConfigurationValueParameters(configVal, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getWANColorDepth(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? WanColorDepth.fromInt((Integer) source) : WanColorDepth.depth16;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANColorDepth, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getWANColorDepth(AsyncQuery<WanColorDepth> aQuery) {
    aQuery.converterCallback = new Converter<WanColorDepth>() {

        @Override
        public WanColorDepth convert(Object source) {
            return source != null ? WanColorDepth.fromInt((Integer) source) : WanColorDepth.depth16;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANColorDepth, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getWANDisableEffects(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<WanDisableEffects>();
            }
            List<WanDisableEffects> res = new ArrayList<>();
            String fromDb = (String) source;
            for (String value : fromDb.split(",")) {
                // $NON-NLS-1$
                if (value == null) {
                    continue;
                }
                String trimmedValue = value.trim();
                if ("".equals(trimmedValue)) {
                    continue;
                }
                res.add(WanDisableEffects.fromString(trimmedValue));
            }
            return res;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANDisableEffects, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getWANDisableEffects(AsyncQuery<List<WanDisableEffects>> aQuery) {
    aQuery.converterCallback = new Converter<List<WanDisableEffects>>() {

        @Override
        public List<WanDisableEffects> convert(Object source) {
            if (source == null) {
                return new ArrayList<>();
            }
            List<WanDisableEffects> res = new ArrayList<>();
            String fromDb = (String) source;
            for (String value : fromDb.split(",")) {
                // $NON-NLS-1$
                if (value == null) {
                    continue;
                }
                String trimmedValue = value.trim();
                if ("".equals(trimmedValue)) {
                    continue;
                }
                res.add(WanDisableEffects.fromString(trimmedValue));
            }
            return res;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANDisableEffects, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getMaxVmsInPool(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 1000;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVmsInPool, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getMaxVmsInPool(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(1000);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVmsInPool, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getMaxNumOfVmSockets(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmSockets);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getMaxNumOfVmSockets(AsyncQuery<Integer> aQuery, String version) {
    aQuery.converterCallback = new DefaultValueConverter<>(1);
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmSockets);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public void getMaxNumOfVmCpus(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmCpus);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getMaxNumOfVmCpus(AsyncQuery<Integer> aQuery, String version) {
    aQuery.converterCallback = new DefaultValueConverter<>(1);
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmCpus);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public void getMaxNumOfCPUsPerSocket(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfCpuPerSocket);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getMaxNumOfCPUsPerSocket(AsyncQuery<Integer> aQuery, String version) {
    aQuery.converterCallback = new DefaultValueConverter<>(1);
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfCpuPerSocket);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public void getMaxNumOfThreadsPerCpu(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfThreadsPerCpu);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getMaxNumOfThreadsPerCpu(AsyncQuery<Integer> aQuery, String version) {
    aQuery.converterCallback = new DefaultValueConverter<>(1);
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfThreadsPerCpu);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public void getClusterList(AsyncQuery aQuery, boolean doRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Cluster> list = (ArrayList<Cluster>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<Cluster>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClusters, doRefresh ? new VdcQueryParametersBase() : new VdcQueryParametersBase().withoutRefresh(), aQuery);
}
#method_after
public void getClusterList(AsyncQuery<List<Cluster>> aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new SortListByNameConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetClustersByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public ArrayList<Cluster> getClusterByServiceList(List<Cluster> list, boolean supportsVirtService, boolean supportsGlusterService) {
    final ArrayList<Cluster> filteredList = new ArrayList<>();
    for (Cluster cluster : list) {
        if ((supportsVirtService && cluster.supportsVirtService()) || (supportsGlusterService && cluster.supportsGlusterService())) {
            filteredList.add(cluster);
        }
    }
    // sort by cluster name
    Collections.sort(filteredList, new NameableComparator());
    return filteredList;
}
#method_after
public void getClusterByServiceList(AsyncQuery<List<Cluster>> aQuery, Guid dataCenterId, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new Converter<List<Cluster>>() {

        @Override
        public List<Cluster> convert(Object source) {
            if (source == null) {
                return new ArrayList<>();
            }
            final ArrayList<Cluster> list = (ArrayList<Cluster>) source;
            return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetClustersByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public void isSoundcardEnabled(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void isSoundcardEnabled(AsyncQuery<Boolean> aQuery, Guid vmId) {
    aQuery.converterCallback = new IsNonEmptyCollectionConverter();
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public void isVirtioScsiEnabledForVm(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void isVirtioScsiEnabledForVm(AsyncQuery<Boolean> aQuery, Guid vmId) {
    aQuery.converterCallback = new IsNonEmptyCollectionConverter();
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public void getClusterListByService(AsyncQuery aQuery, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Cluster> list = getClusterByServiceList((ArrayList<Cluster>) source, supportsVirtService, supportsGlusterService);
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<Cluster>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClusters, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getClusterListByService(AsyncQuery<List<Cluster>> aQuery, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new Converter<List<Cluster>>() {

        @Override
        public List<Cluster> convert(Object source) {
            if (source != null) {
                ArrayList<Cluster> list = getClusterByServiceList((ArrayList<Cluster>) source, supportsVirtService, supportsGlusterService);
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClusters, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getClusterList(AsyncQuery aQuery, boolean doRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Cluster> list = (ArrayList<Cluster>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<Cluster>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClusters, doRefresh ? new VdcQueryParametersBase() : new VdcQueryParametersBase().withoutRefresh(), aQuery);
}
#method_after
public void getClusterList(AsyncQuery aQuery, boolean doRefresh) {
    aQuery.converterCallback = new SortListByNameConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClusters, doRefresh ? new VdcQueryParametersBase() : new VdcQueryParametersBase().withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getLabelList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Label> list = (ArrayList<Label>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<Label>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllLabels, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getLabelList(AsyncQuery<List<Label>> aQuery) {
    aQuery.converterCallback = new SortListByNameConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllLabels, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getLabelListByEntityId(AsyncQuery aQuery, Guid entityId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Label> list = (ArrayList<Label>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<Label>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetLabelByEntityId, new IdQueryParameters(entityId), aQuery);
}
#method_after
public void getLabelListByEntityId(AsyncQuery<List<Label>> aQuery, Guid entityId) {
    aQuery.converterCallback = new SortListByNameConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetLabelByEntityId, new IdQueryParameters(entityId), aQuery);
}
#end_block

#method_before
public void getTemplateDiskList(AsyncQuery aQuery, Guid templateId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<DiskImage>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesDisks, new IdQueryParameters(templateId), aQuery);
}
#method_after
public void getTemplateDiskList(AsyncQuery<List<DiskImage>> aQuery, Guid templateId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesDisks, new IdQueryParameters(templateId), aQuery);
}
#end_block

#method_before
public void getTemplateListByDataCenter(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new TemplateConverter();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getTemplateListByDataCenter(AsyncQuery<List<VmTemplate>> aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new TemplateConverter();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public void getTemplateListByStorage(AsyncQuery aQuery, Guid storageId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VmTemplate> list = new ArrayList<>();
            if (source != null) {
                for (VmTemplate template : (ArrayList<VmTemplate>) source) {
                    if (template.getStatus() == VmTemplateStatus.OK) {
                        list.add(template);
                    }
                }
                Collections.sort(list, new NameableComparator());
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesFromStorageDomain, new GetVmTemplatesFromStorageDomainParameters(storageId, false), aQuery);
}
#method_after
public void getTemplateListByStorage(AsyncQuery<List<VmTemplate>> aQuery, Guid storageId) {
    aQuery.converterCallback = new Converter<List<VmTemplate>>() {

        @Override
        public List<VmTemplate> convert(Object source) {
            ArrayList<VmTemplate> list = new ArrayList<>();
            if (source != null) {
                for (VmTemplate template : (ArrayList<VmTemplate>) source) {
                    if (template.getStatus() == VmTemplateStatus.OK) {
                        list.add(template);
                    }
                }
                Collections.sort(list, new NameableComparator());
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesFromStorageDomain, new GetVmTemplatesFromStorageDomainParameters(storageId, false), aQuery);
}
#end_block

#method_before
public void getNumOfMonitorList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Integer> nums = new ArrayList<>();
            if (source != null) {
                Iterable numEnumerable = (Iterable) source;
                Iterator numIterator = numEnumerable.iterator();
                while (numIterator.hasNext()) {
                    nums.add(Integer.parseInt(numIterator.next().toString()));
                }
            }
            return nums;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.ValidNumOfMonitors, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getNumOfMonitorList(AsyncQuery<List<Integer>> aQuery) {
    aQuery.converterCallback = new Converter<List<Integer>>() {

        @Override
        public List<Integer> convert(Object source) {
            ArrayList<Integer> nums = new ArrayList<>();
            if (source != null) {
                Iterable numEnumerable = (Iterable) source;
                Iterator numIterator = numEnumerable.iterator();
                while (numIterator.hasNext()) {
                    nums.add(Integer.parseInt(numIterator.next().toString()));
                }
            }
            return nums;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.ValidNumOfMonitors, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getStorageDomainList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : new ArrayList<StorageDomain>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Storage:", SearchType.StorageDomain);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#method_after
public void getStorageDomainList(AsyncQuery<List<StorageDomain>> aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public int getMaxVmPriority() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.VmPriorityMaxValue, getDefaultConfigurationVersion());
}
#method_after
public void getMaxVmPriority(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(100);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.VmPriorityMaxValue, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getHostById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(id).withoutRefresh(), aQuery);
}
#method_after
public void getHostById(AsyncQuery<VDS> aQuery, Guid id) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(id).withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getHostListByCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((List<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$ //$NON-NLS-2$
    SearchParameters(// $NON-NLS-1$ //$NON-NLS-2$
    "Host: cluster = " + clusterName + " sortby name", SearchType.VDS), aQuery);
}
#method_after
public void getHostListByCluster(AsyncQuery<List<VDS>> aQuery, String clusterName) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$ //$NON-NLS-2$
    SearchParameters(// $NON-NLS-1$ //$NON-NLS-2$
    "Host: cluster = " + clusterName + " sortby name", SearchType.VDS), aQuery);
}
#end_block

#method_before
public void getHostListByClusterId(AsyncQuery aQuery, Guid clusterId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getHostListByClusterId(AsyncQuery<List<VDS>> aQuery, Guid clusterId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
public void getHostListByDataCenter(AsyncQuery aQuery, Guid spId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return Linq.<VDS>cast((List<?>) source);
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsByStoragePool, new IdQueryParameters(spId), aQuery);
}
#method_after
public void getHostListByDataCenter(AsyncQuery<List<VDS>> aQuery, Guid spId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsByStoragePool, new IdQueryParameters(spId), aQuery);
}
#end_block

#method_before
public void getHostDevicesByHostId(AsyncQuery aQuery, Guid hostId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetExtendedHostDevicesByHostId, new IdQueryParameters(hostId), aQuery);
}
#method_after
public void getHostDevicesByHostId(AsyncQuery<List<HostDeviceView>> aQuery, Guid hostId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetExtendedHostDevicesByHostId, new IdQueryParameters(hostId), aQuery);
}
#end_block

#method_before
public void getConfiguredVmHostDevices(AsyncQuery aQuery, Guid vmId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmHostDevices, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getConfiguredVmHostDevices(AsyncQuery<List<VmHostDevice>> aQuery, Guid vmId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmHostDevices, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public void getVmDiskList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Disk> list = new ArrayList<>();
            if (source != null) {
                Iterable listEnumerable = (Iterable) source;
                Iterator listIterator = listEnumerable.iterator();
                while (listIterator.hasNext()) {
                    list.add((Disk) listIterator.next());
                }
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(id).withoutRefresh(), aQuery);
}
#method_after
public void getVmDiskList(AsyncQuery<List<Disk>> aQuery, Guid vmId, boolean isRefresh) {
    aQuery.converterCallback = new ListConverter<>();
    IdQueryParameters params = new IdQueryParameters(vmId);
    params.setRefresh(isRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, params, aQuery);
}
#end_block

#method_before
public void getAAAProfilesList(AsyncQuery aQuery) {
    convertAAAProfilesResult(aQuery, false);
    Frontend.getInstance().runQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getAAAProfilesList(AsyncQuery<List<String>> aQuery) {
    convertAAAProfilesResult(aQuery, false);
    Frontend.getInstance().runQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getAAANamespaces(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (HashMap<String, List<String>>) source : new HashMap<String, List<String>>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAvailableNamespaces, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getAAANamespaces(AsyncQuery<Map<String, List<String>>> aQuery) {
    aQuery.converterCallback = new MapConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAvailableNamespaces, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getAAAProfilesEntriesList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Collection<ProfileEntry>) source : new ArrayList<ProfileEntry>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getAAAProfilesEntriesList(AsyncQuery<List<ProfileEntry>> aQuery) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getRoleList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Role>) source : new ArrayList<Role>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRoles, new MultilevelAdministrationsQueriesParameters(), aQuery);
}
#method_after
public void getRoleList(AsyncQuery<List<Role>> aQuery) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRoles, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getStorageDomainById(AsyncQuery aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (StorageDomain) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainById, new IdQueryParameters(storageDomainId), aQuery);
}
#method_after
public void getStorageDomainById(AsyncQuery<StorageDomain> aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainById, new IdQueryParameters(storageDomainId), aQuery);
}
#end_block

#method_before
public void getStorageDomainByName(AsyncQuery aQuery, String storageDomainName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainByName, new NameQueryParameters(storageDomainName), aQuery);
}
#method_after
public void getStorageDomainByName(AsyncQuery<StorageDomainStatic> aQuery, String storageDomainName) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainByName, new NameQueryParameters(storageDomainName), aQuery);
}
#end_block

#method_before
public void getClusterNetworkList(AsyncQuery aQuery, Guid clusterId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return new ArrayList<Network>();
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworksByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getClusterNetworkList(AsyncQuery<List<Network>> aQuery, Guid clusterId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new ListConverter<>();
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworksByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
public void getAllNetworkQos(Guid dcId, AsyncQuery query) {
    query.converterCallback = new IAsyncConverter<List<NetworkQoS>>() {

        @Override
        public List<NetworkQoS> convert(Object returnValue, AsyncQuery asyncQuery) {
            List<NetworkQoS> qosList = returnValue == null ? new ArrayList<NetworkQoS>() : (List<NetworkQoS>) returnValue;
            qosList.add(0, NetworkQoSModel.EMPTY_QOS);
            return qosList;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, new IdQueryParameters(dcId), query);
}
#method_after
public void getAllNetworkQos(Guid dcId, AsyncQuery<List<NetworkQoS>> query) {
    query.converterCallback = new ListConverter<NetworkQoS>() {

        @Override
        public List<NetworkQoS> convert(Object returnValue) {
            List<NetworkQoS> qosList = super.convert(returnValue);
            qosList.add(0, NetworkQoSModel.EMPTY_QOS);
            return qosList;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, new IdQueryParameters(dcId), query);
}
#end_block

#method_before
public void getAllHostNetworkQos(Guid dcId, AsyncQuery query) {
    query.converterCallback = new IAsyncConverter<List<HostNetworkQos>>() {

        @Override
        public List<HostNetworkQos> convert(Object returnValue, AsyncQuery asyncQuery) {
            List<HostNetworkQos> qosList = (returnValue == null) ? new ArrayList<HostNetworkQos>() : (List<HostNetworkQos>) returnValue;
            qosList.add(0, NetworkModel.EMPTY_HOST_NETWORK_QOS);
            return qosList;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllQosByStoragePoolIdAndType, new QosQueryParameterBase(dcId, QosType.HOSTNETWORK), query);
}
#method_after
public void getAllHostNetworkQos(Guid dcId, AsyncQuery<List<HostNetworkQos>> query) {
    query.converterCallback = new ListConverter<HostNetworkQos>() {

        @Override
        public List<HostNetworkQos> convert(Object returnValue) {
            List<HostNetworkQos> qosList = super.convert(returnValue);
            qosList.add(0, NetworkModel.EMPTY_HOST_NETWORK_QOS);
            return qosList;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllQosByStoragePoolIdAndType, new QosQueryParameterBase(dcId, QosType.HOSTNETWORK), query);
}
#end_block

#method_before
public void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId).withoutRefresh(), aQuery);
}
#method_after
public void getDataCenterById(AsyncQuery<StoragePool> aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getNetworkLabelsByDataCenterId(Guid dataCenterId, AsyncQuery query) {
    query.converterCallback = new IAsyncConverter<SortedSet<String>>() {

        @Override
        public SortedSet<String> convert(Object returnValue, AsyncQuery asyncQuery) {
            SortedSet<String> sortedSet = new TreeSet<>(new LexoNumericComparator());
            sortedSet.addAll((Collection<String>) returnValue);
            return sortedSet;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworkLabelsByDataCenterId, new IdQueryParameters(dataCenterId), query);
}
#method_after
public void getNetworkLabelsByDataCenterId(Guid dataCenterId, AsyncQuery<SortedSet<String>> query) {
    query.converterCallback = new Converter<SortedSet<String>>() {

        @Override
        public SortedSet<String> convert(Object returnValue) {
            SortedSet<String> sortedSet = new TreeSet<>(new LexoNumericComparator());
            sortedSet.addAll((Collection<String>) returnValue);
            return sortedSet;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworkLabelsByDataCenterId, new IdQueryParameters(dataCenterId), query);
}
#end_block

#method_before
public void getTemplateById(AsyncQuery aQuery, Guid templateId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(templateId), aQuery);
}
#method_after
public void getTemplateById(AsyncQuery<VmTemplate> aQuery, Guid templateId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(templateId), aQuery);
}
#end_block

#method_before
public void countAllTemplates(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplateCount, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void countAllTemplates(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplateCount, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getHostList(AsyncQuery aQuery, boolean doRefresh) {
    getHostListByStatus(aQuery, null, doRefresh);
}
#method_after
public void getHostList(AsyncQuery<List<VDS>> aQuery) {
    getHostListByStatus(aQuery, null);
}
#end_block

#method_before
public void getHostListByStatus(AsyncQuery aQuery, VDSStatus status, boolean doRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((Iterable) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: " + (status == null ? "" : ("status=" + status.name())), SearchType.VDS);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, doRefresh ? searchParameters : searchParameters.withoutRefresh(), aQuery);
}
#method_after
public void getHostListByStatus(AsyncQuery<List<VDS>> aQuery, VDSStatus status) {
    getHostListByStatus(aQuery, status, true);
}
#end_block

#method_before
public void getHostsForStorageOperation(AsyncQuery aQuery, Guid storagePoolId, boolean localFsOnly) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return source;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsForStorageOperation, new GetHostsForStorageOperationParameters(storagePoolId, localFsOnly), aQuery);
}
#method_after
public void getHostsForStorageOperation(AsyncQuery<List<VDS>> aQuery, Guid storagePoolId, boolean localFsOnly) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsForStorageOperation, new GetHostsForStorageOperationParameters(storagePoolId, localFsOnly), aQuery);
}
#end_block

#method_before
public void getVolumeList(AsyncQuery aQuery, String clusterName, boolean doRefresh) {
    if ((ApplicationModeHelper.getUiMode().getValue() & ApplicationMode.GlusterOnly.getValue()) == 0) {
        aQuery.asyncCallback.onSuccess(aQuery.model, new ArrayList<GlusterVolumeEntity>());
        return;
    }
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<GlusterVolumeEntity> list = (ArrayList<GlusterVolumeEntity>) source;
                return list;
            }
            return new ArrayList<GlusterVolumeEntity>();
        }
    };
    SearchParameters searchParameters;
    searchParameters = // $NON-NLS-1$
    clusterName == null ? // $NON-NLS-1$
    new SearchParameters("Volumes:", SearchType.GlusterVolume) : // $NON-NLS-1$
    new SearchParameters("Volumes: cluster.name=" + clusterName, SearchType.GlusterVolume);
    searchParameters.setMaxCount(9999);
    if (!doRefresh) {
        searchParameters.withoutRefresh();
    }
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public void getVolumeList(AsyncQuery<List<GlusterVolumeEntity>> aQuery, String clusterName) {
    getVolumeList(aQuery, clusterName, true);
}
#end_block

#method_before
public void getHostFingerprint(AsyncQuery aQuery, String hostAddress) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetServerSSHKeyFingerprint, new ServerParameters(hostAddress), aQuery);
}
#method_after
public void getHostFingerprint(AsyncQuery<String> aQuery, String hostAddress) {
    aQuery.converterCallback = new StringConverter();
    Frontend.getInstance().runQuery(VdcQueryType.GetServerSSHKeyFingerprint, new ServerParameters(hostAddress), aQuery);
}
#end_block

#method_before
public void getEngineSshPublicKey(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetEngineSSHPublicKey, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getEngineSshPublicKey(AsyncQuery<String> aQuery) {
    aQuery.converterCallback = new StringConverter();
    Frontend.getInstance().runQuery(VdcQueryType.GetEngineSSHPublicKey, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getClusterGlusterServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    // Passing empty values for Volume and Brick to get the services of all the volumes/hosts in the cluster
    GlusterVolumeAdvancedDetailsParameters parameters = // $NON-NLS-1$ //$NON-NLS-2$
    new GlusterVolumeAdvancedDetailsParameters(clusterId, null, null, false);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#method_after
public void getClusterGlusterServices(AsyncQuery<GlusterVolumeAdvancedDetails> aQuery, Guid clusterId) {
    aQuery.converterCallback = new CastingConverter<>();
    // Passing empty values for Volume and Brick to get the services of all the volumes/hosts in the cluster
    GlusterVolumeAdvancedDetailsParameters parameters = // $NON-NLS-1$ //$NON-NLS-2$
    new GlusterVolumeAdvancedDetailsParameters(clusterId, null, null, false);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#end_block

#method_before
public void getGlusterHostsNewlyAdded(AsyncQuery aQuery, Guid clusterId, boolean isFingerprintRequired) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAddedGlusterServers, new AddedGlusterServersParameters(clusterId, isFingerprintRequired), aQuery);
}
#method_after
public void getGlusterHostsNewlyAdded(AsyncQuery<Map<String, String>> aQuery, Guid clusterId, boolean isFingerprintRequired) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAddedGlusterServers, new AddedGlusterServersParameters(clusterId, isFingerprintRequired), aQuery);
}
#end_block

#method_before
public void isAnyHostUpInCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null && !((List<?>) source).isEmpty()) {
                return true;
            }
            return false;
        }
    };
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#method_after
public void isAnyHostUpInCluster(AsyncQuery<Boolean> aQuery, String clusterName) {
    aQuery.converterCallback = new IsNonEmptyCollectionConverter();
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#end_block

#method_before
public void getGlusterHooks(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterHookEntity>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHooks, new GlusterParameters(clusterId), aQuery);
}
#method_after
public void getGlusterHooks(AsyncQuery<List<GlusterHookEntity>> aQuery, Guid clusterId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHooks, new GlusterParameters(clusterId), aQuery);
}
#end_block

#method_before
public void getGlusterBricksForServer(AsyncQuery aQuery, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterBrickEntity>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeBricksByServerId, new IdQueryParameters(serverId), aQuery);
}
#method_after
public void getGlusterBricksForServer(AsyncQuery<List<GlusterBrickEntity>> aQuery, Guid serverId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeBricksByServerId, new IdQueryParameters(serverId), aQuery);
}
#end_block

#method_before
public void getGlusterVolumeGeoRepStatusForMasterVolume(AsyncQuery aQuery, Guid masterVolumeId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery asyncQuery) {
            return source != null ? source : new ArrayList<GlusterGeoRepSession>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeGeoRepSessions, new IdQueryParameters(masterVolumeId), aQuery);
}
#method_after
public void getGlusterVolumeGeoRepStatusForMasterVolume(AsyncQuery<List<GlusterGeoRepSession>> aQuery, Guid masterVolumeId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeGeoRepSessions, new IdQueryParameters(masterVolumeId), aQuery);
}
#end_block

#method_before
public void getGlusterVolumeGeoRepRecommendationViolations(AsyncQuery aQuery, Guid masterVolumeId, Guid slaveVolumeId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object returnValue, AsyncQuery asyncQuery) {
            return returnValue == null ? new ArrayList<GlusterGeoRepNonEligibilityReason>() : (List<GlusterGeoRepNonEligibilityReason>) returnValue;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNonEligibilityReasonsOfVolumeForGeoRepSession, new GlusterVolumeGeoRepEligibilityParameters(masterVolumeId, slaveVolumeId), aQuery);
}
#method_after
public void getGlusterVolumeGeoRepRecommendationViolations(AsyncQuery<List<GlusterGeoRepNonEligibilityReason>> aQuery, Guid masterVolumeId, Guid slaveVolumeId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetNonEligibilityReasonsOfVolumeForGeoRepSession, new GlusterVolumeGeoRepEligibilityParameters(masterVolumeId, slaveVolumeId), aQuery);
}
#end_block

#method_before
public void getGlusterVolumeSnapshotsForVolume(AsyncQuery aQuery, Guid volumeId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery asyncQuery) {
            return source != null ? source : new ArrayList<GlusterVolumeSnapshotEntity>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeSnapshotsByVolumeId, new IdQueryParameters(volumeId), aQuery);
}
#method_after
public void getGlusterVolumeSnapshotsForVolume(AsyncQuery<List<GlusterVolumeSnapshotEntity>> aQuery, Guid volumeId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeSnapshotsByVolumeId, new IdQueryParameters(volumeId), aQuery);
}
#end_block

#method_before
public void getVolumeSnapshotSchedule(AsyncQuery aQuery, Guid volumeId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeSnapshotScheduleByVolumeId, new IdQueryParameters(volumeId), aQuery);
}
#method_after
public void getVolumeSnapshotSchedule(AsyncQuery<GlusterVolumeSnapshotSchedule> aQuery, Guid volumeId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeSnapshotScheduleByVolumeId, new IdQueryParameters(volumeId), aQuery);
}
#end_block

#method_before
public void getIsGlusterVolumeSnapshotCliScheduleEnabled(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeSnapshotCliScheduleFlag, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getIsGlusterVolumeSnapshotCliScheduleEnabled(AsyncQuery<Boolean> aQuery, Guid clusterId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeSnapshotCliScheduleFlag, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
public void getGlusterHook(AsyncQuery aQuery, Guid hookId, boolean includeServerHooks) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookById, new GlusterHookQueryParameters(hookId, includeServerHooks), aQuery);
}
#method_after
public void getGlusterHook(AsyncQuery<GlusterHookEntity> aQuery, Guid hookId, boolean includeServerHooks) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookById, new GlusterHookQueryParameters(hookId, includeServerHooks), aQuery);
}
#end_block

#method_before
public void getGlusterHookContent(AsyncQuery aQuery, Guid hookId, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? source : "";
        }
    };
    GlusterHookContentQueryParameters parameters = new GlusterHookContentQueryParameters(hookId);
    parameters.setGlusterServerId(serverId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookContent, parameters, aQuery);
}
#method_after
public void getGlusterHookContent(AsyncQuery<String> aQuery, Guid hookId, Guid serverId) {
    aQuery.converterCallback = new StringConverter();
    GlusterHookContentQueryParameters parameters = new GlusterHookContentQueryParameters(hookId);
    parameters.setGlusterServerId(serverId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookContent, parameters, aQuery);
}
#end_block

#method_before
public void getGlusterSwiftServices(AsyncQuery aQuery, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterServerService>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByServerId, new GlusterServiceQueryParameters(serverId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#method_after
public void getGlusterSwiftServices(AsyncQuery<List<GlusterServerService>> aQuery, Guid serverId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByServerId, new GlusterServiceQueryParameters(serverId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#end_block

#method_before
public void getClusterGlusterSwiftService(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                List<GlusterClusterService> serviceList = (List<GlusterClusterService>) source;
                if (!serviceList.isEmpty()) {
                    return serviceList.get(0);
                }
                return null;
            } else {
                return source;
            }
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterClusterServiceByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#method_after
public void getClusterGlusterSwiftService(AsyncQuery<GlusterClusterService> aQuery, Guid clusterId) {
    aQuery.converterCallback = new GetFirstConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterClusterServiceByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#end_block

#method_before
public void getGlusterSwiftServerServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterServerService>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#method_after
public void getGlusterSwiftServerServices(AsyncQuery<List<GlusterServerService>> aQuery, Guid clusterId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#end_block

#method_before
public void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#method_after
public void getGlusterRebalanceStatus(AsyncQuery<VdcQueryReturnValue> aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#end_block

#method_before
public void getGlusterSnapshotConfig(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeSnapshotConfig, new GlusterVolumeQueriesParameters(clusterId, volumeId), aQuery);
}
#method_after
public void getGlusterSnapshotConfig(AsyncQuery<VdcQueryReturnValue> aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeSnapshotConfig, new GlusterVolumeQueriesParameters(clusterId, volumeId), aQuery);
}
#end_block

#method_before
public void getGlusterVolumeProfilingStatistics(AsyncQuery aQuery, Guid clusterId, Guid volumeId, boolean nfs) {
    aQuery.setHandleFailure(true);
    GlusterVolumeProfileParameters parameters = new GlusterVolumeProfileParameters(clusterId, volumeId, nfs);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeProfileInfo, parameters, aQuery);
}
#method_after
public void getGlusterVolumeProfilingStatistics(AsyncQuery<VdcQueryReturnValue> aQuery, Guid clusterId, Guid volumeId, boolean nfs) {
    aQuery.setHandleFailure(true);
    GlusterVolumeProfileParameters parameters = new GlusterVolumeProfileParameters(clusterId, volumeId, nfs);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeProfileInfo, parameters, aQuery);
}
#end_block

#method_before
public void getGlusterRemoveBricksStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId, List<GlusterBrickEntity> bricks) {
    aQuery.setHandleFailure(true);
    GlusterVolumeRemoveBricksQueriesParameters parameters = new GlusterVolumeRemoveBricksQueriesParameters(clusterId, volumeId, bricks);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRemoveBricksStatus, parameters, aQuery);
}
#method_after
public void getGlusterRemoveBricksStatus(AsyncQuery<VdcQueryReturnValue> aQuery, Guid clusterId, Guid volumeId, List<GlusterBrickEntity> bricks) {
    aQuery.setHandleFailure(true);
    GlusterVolumeRemoveBricksQueriesParameters parameters = new GlusterVolumeRemoveBricksQueriesParameters(clusterId, volumeId, bricks);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRemoveBricksStatus, parameters, aQuery);
}
#end_block

#method_before
public void getSearchResultsLimit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 100;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SearchResultsLimit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getSearchResultsLimit(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(100);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SearchResultsLimit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getPermissionsByAdElementId(AsyncQuery aQuery, Guid userId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Permission>) source : new ArrayList<Permission>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(userId), aQuery);
}
#method_after
public void getPermissionsByAdElementId(AsyncQuery<List<Permission>> aQuery, Guid userId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(userId), aQuery);
}
#end_block

#method_before
public void getRoleActionGroupsByRoleId(AsyncQuery aQuery, Guid roleId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<ActionGroup>) source : new ArrayList<ActionGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetRoleActionGroupsByRoleId, new IdQueryParameters(roleId), aQuery);
}
#method_after
public void getRoleActionGroupsByRoleId(AsyncQuery<List<ActionGroup>> aQuery, Guid roleId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetRoleActionGroupsByRoleId, new IdQueryParameters(roleId), aQuery);
}
#end_block

#method_before
public void isTemplateNameUnique(AsyncQuery aQuery, String templateName, Guid datacenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null && !(Boolean) source;
        }
    };
    NameQueryParameters params = new NameQueryParameters(templateName);
    params.setDatacenterId(datacenterId);
    Frontend.getInstance().runQuery(VdcQueryType.IsVmTemlateWithSameNameExist, params, aQuery);
}
#method_after
public void isTemplateNameUnique(AsyncQuery<Boolean> aQuery, String templateName, Guid datacenterId) {
    aQuery.converterCallback = new Converter<Boolean>() {

        @Override
        public Boolean convert(Object source) {
            return source != null && !(Boolean) source;
        }
    };
    NameQueryParameters params = new NameQueryParameters(templateName);
    params.setDatacenterId(datacenterId);
    Frontend.getInstance().runQuery(VdcQueryType.IsVmTemlateWithSameNameExist, params, aQuery);
}
#end_block

#method_before
public void isVmNameUnique(AsyncQuery aQuery, String name, Guid datacenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null && !(Boolean) source;
        }
    };
    NameQueryParameters params = new NameQueryParameters(name);
    params.setDatacenterId(datacenterId);
    Frontend.getInstance().runQuery(VdcQueryType.IsVmWithSameNameExist, params, aQuery);
}
#method_after
public void isVmNameUnique(AsyncQuery<Boolean> aQuery, String name, Guid datacenterId) {
    aQuery.converterCallback = new Converter<Boolean>() {

        @Override
        public Boolean convert(Object source) {
            return source != null && !(Boolean) source;
        }
    };
    NameQueryParameters params = new NameQueryParameters(name);
    params.setDatacenterId(datacenterId);
    Frontend.getInstance().runQuery(VdcQueryType.IsVmWithSameNameExist, params, aQuery);
}
#end_block

#method_before
public void getDataCentersWithPermittedActionOnClusters(AsyncQuery aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    GetDataCentersWithPermittedActionOnClustersParameters getDataCentersWithPermittedActionOnClustersParameters = new GetDataCentersWithPermittedActionOnClustersParameters();
    getDataCentersWithPermittedActionOnClustersParameters.setActionGroup(actionGroup);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsVirtService(supportsVirtService);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetDataCentersWithPermittedActionOnClusters, getDataCentersWithPermittedActionOnClustersParameters, aQuery);
}
#method_after
public void getDataCentersWithPermittedActionOnClusters(AsyncQuery<List<StoragePool>> aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new ListConverter<>();
    GetDataCentersWithPermittedActionOnClustersParameters getDataCentersWithPermittedActionOnClustersParameters = new GetDataCentersWithPermittedActionOnClustersParameters();
    getDataCentersWithPermittedActionOnClustersParameters.setActionGroup(actionGroup);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsVirtService(supportsVirtService);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetDataCentersWithPermittedActionOnClusters, getDataCentersWithPermittedActionOnClustersParameters, aQuery);
}
#end_block

#method_before
public void getClustersWithPermittedAction(AsyncQuery aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Cluster> list = (ArrayList<Cluster>) source;
                return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
            }
            return new ArrayList<Cluster>();
        }
    };
    GetEntitiesWithPermittedActionParameters getEntitiesWithPermittedActionParameters = new GetEntitiesWithPermittedActionParameters();
    getEntitiesWithPermittedActionParameters.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetClustersWithPermittedAction, getEntitiesWithPermittedActionParameters, aQuery);
}
#method_after
public void getClustersWithPermittedAction(AsyncQuery<List<Cluster>> aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new Converter<List<Cluster>>() {

        @Override
        public List<Cluster> convert(Object source) {
            if (source != null) {
                ArrayList<Cluster> list = (ArrayList<Cluster>) source;
                return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
            }
            return new ArrayList<>();
        }
    };
    GetEntitiesWithPermittedActionParameters getEntitiesWithPermittedActionParameters = new GetEntitiesWithPermittedActionParameters();
    getEntitiesWithPermittedActionParameters.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetClustersWithPermittedAction, getEntitiesWithPermittedActionParameters, aQuery);
}
#end_block

#method_before
public void getClustersHavingHosts(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Cluster> list = (ArrayList<Cluster>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<Cluster>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClustersHavingHosts, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getClustersHavingHosts(AsyncQuery<List<Cluster>> aQuery) {
    aQuery.converterCallback = new SortListByNameConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClustersHavingHosts, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getAllVmTemplates(AsyncQuery aQuery, final boolean refresh) {
    aQuery.converterCallback = new TemplateConverter();
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setRefresh(refresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmTemplates, params, aQuery);
}
#method_after
public void getAllVmTemplates(AsyncQuery<List<VmTemplate>> aQuery, final boolean refresh) {
    aQuery.converterCallback = new TemplateConverter();
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setRefresh(refresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmTemplates, params, aQuery);
}
#end_block

#method_before
public void getStorageConnectionById(AsyncQuery aQuery, String id, boolean isRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (StorageServerConnections) source : null;
        }
    };
    StorageServerConnectionQueryParametersBase params = new StorageServerConnectionQueryParametersBase(id);
    params.setRefresh(isRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageServerConnectionById, params, aQuery);
}
#method_after
public void getStorageConnectionById(AsyncQuery<StorageServerConnections> aQuery, String id, boolean isRefresh) {
    aQuery.converterCallback = new Converter<StorageServerConnections>() {

        @Override
        public StorageServerConnections convert(Object source) {
            return source != null ? (StorageServerConnections) source : null;
        }
    };
    StorageServerConnectionQueryParametersBase params = new StorageServerConnectionQueryParametersBase(id);
    params.setRefresh(isRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageServerConnectionById, params, aQuery);
}
#end_block

#method_before
public void getDataCentersByStorageDomain(AsyncQuery aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StoragePool>) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), aQuery);
}
#method_after
public void getDataCentersByStorageDomain(AsyncQuery<List<StoragePool>> aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), aQuery);
}
#end_block

#method_before
public void getDataCenterVersions(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Version>();
            } else {
                ArrayList<Version> list = (ArrayList<Version>) source;
                Collections.sort(list);
                return list;
            }
        }
    };
    IdQueryParameters tempVar = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAvailableClusterVersionsByStoragePool, tempVar, aQuery);
}
#method_after
public void getDataCenterVersions(AsyncQuery<List<Version>> aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new SortListConverter<>();
    IdQueryParameters tempVar = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAvailableClusterVersionsByStoragePool, tempVar, aQuery);
}
#end_block

#method_before
public void getDataCenterMaxNameLength(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 1;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StoragePoolNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getDataCenterMaxNameLength(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(1);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StoragePoolNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getClusterServerMemoryOverCommit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 0;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommitForServers, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getClusterServerMemoryOverCommit(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(0);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommitForServers, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getClusterDesktopMemoryOverCommit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 0;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getClusterDesktopMemoryOverCommit(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(0);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getAllowClusterWithVirtGlusterEnabled(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : Boolean.TRUE;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.AllowClusterWithVirtGlusterEnabled, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getAllowClusterWithVirtGlusterEnabled(AsyncQuery<Boolean> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(Boolean.TRUE);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.AllowClusterWithVirtGlusterEnabled, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getCPUList(AsyncQuery aQuery, Version version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<ServerCpu>) source : new ArrayList<ServerCpu>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllServerCpuList, new GetAllServerCpuListParameters(version), aQuery);
}
#method_after
public void getCPUList(AsyncQuery<List<ServerCpu>> aQuery, Version version) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllServerCpuList, new GetAllServerCpuListParameters(version), aQuery);
}
#end_block

#method_before
public void getPmTypeList(AsyncQuery aQuery, Version version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<String> list = new ArrayList<>();
            if (source != null) {
                // $NON-NLS-1$
                String[] array = ((String) source).split("[,]", -1);
                for (String item : array) {
                    list.add(item);
                }
            }
            return list;
        }
    };
    GetConfigurationValueParameters param = new GetConfigurationValueParameters(ConfigurationValues.VdsFenceType);
    param.setVersion(version != null ? version.toString() : getDefaultConfigurationVersion());
    Frontend.getInstance().runQuery(VdcQueryType.GetFenceConfigurationValue, param, aQuery);
}
#method_after
public void getPmTypeList(AsyncQuery<List<String>> aQuery, Version version) {
    aQuery.converterCallback = new Converter<List<String>>() {

        @Override
        public List<String> convert(Object source) {
            ArrayList<String> list = new ArrayList<>();
            if (source != null) {
                // $NON-NLS-1$
                String[] array = ((String) source).split("[,]", -1);
                for (String item : array) {
                    list.add(item);
                }
            }
            return list;
        }
    };
    GetConfigurationValueParameters param = new GetConfigurationValueParameters(ConfigurationValues.VdsFenceType);
    param.setVersion(version != null ? version.toString() : getDefaultConfigurationVersion());
    Frontend.getInstance().runQuery(VdcQueryType.GetFenceConfigurationValue, param, aQuery);
}
#end_block

#method_before
public void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.getInstance().runQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#method_after
public void getPmOptions(AsyncQuery<List<String>> aQuery, final String pmType, String version) {
    aQuery.converterCallback = new Converter<List<String>>() {

        @Override
        public List<String> convert(Object source) {
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmType);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
public void getNetworkList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworks, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getNetworkList(AsyncQuery<List<Network>> aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworks, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public void getISOStorageDomainList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> allStorageDomains = (ArrayList<StorageDomain>) source;
                ArrayList<StorageDomain> isoStorageDomains = new ArrayList<>();
                for (StorageDomain storageDomain : allStorageDomains) {
                    if (storageDomain.getStorageDomainType() == StorageDomainType.ISO) {
                        isoStorageDomains.add(storageDomain);
                    }
                }
                return isoStorageDomains;
            }
            return new ArrayList<StorageDomain>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Storage:", SearchType.StorageDomain);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#method_after
public void getISOStorageDomainList(AsyncQuery<List<StorageDomain>> aQuery) {
    aQuery.converterCallback = new Converter<List<StorageDomain>>() {

        @Override
        public List<StorageDomain> convert(Object source) {
            if (source != null) {
                ArrayList<StorageDomain> allStorageDomains = (ArrayList<StorageDomain>) source;
                ArrayList<StorageDomain> isoStorageDomains = new ArrayList<>();
                for (StorageDomain storageDomain : allStorageDomains) {
                    if (storageDomain.getStorageDomainType() == StorageDomainType.ISO) {
                        isoStorageDomains.add(storageDomain);
                    }
                }
                return isoStorageDomains;
            }
            return new ArrayList<>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Storage:", SearchType.StorageDomain);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#end_block

#method_before
public void getLocalStorageHost(AsyncQuery aQuery, String dataCenterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                for (IVdcQueryable item : (List<IVdcQueryable>) source) {
                    return item;
                }
            }
            return null;
        }
    };
    // $NON-NLS-1$
    SearchParameters sp = new SearchParameters("hosts: datacenter=" + dataCenterName, SearchType.VDS);
    Frontend.getInstance().runQuery(VdcQueryType.Search, sp, aQuery);
}
#method_after
public void getLocalStorageHost(AsyncQuery<VDS> aQuery, String dataCenterName) {
    aQuery.converterCallback = new GetFirstConverter<>();
    // $NON-NLS-1$
    SearchParameters sp = new SearchParameters("hosts: datacenter=" + dataCenterName, SearchType.VDS);
    Frontend.getInstance().runQuery(VdcQueryType.Search, sp, aQuery);
}
#end_block

#method_before
public void getStorageDomainsByConnection(AsyncQuery aQuery, Guid storagePoolId, String connectionPath) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : null;
        }
    };
    GetStorageDomainsByConnectionParameters param = new GetStorageDomainsByConnectionParameters();
    param.setConnection(connectionPath);
    if (storagePoolId != null) {
        param.setStoragePoolId(storagePoolId);
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByConnection, param, aQuery);
}
#method_after
public void getStorageDomainsByConnection(AsyncQuery<List<StorageDomain>> aQuery, Guid storagePoolId, String connectionPath) {
    aQuery.converterCallback = new CastingConverter<>();
    GetStorageDomainsByConnectionParameters param = new GetStorageDomainsByConnectionParameters();
    param.setConnection(connectionPath);
    if (storagePoolId != null) {
        param.setStoragePoolId(storagePoolId);
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByConnection, param, aQuery);
}
#end_block

#method_before
public void getExistingStorageDomainList(AsyncQuery aQuery, Guid hostId, StorageDomainType domainType, StorageType storageType, String path) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetExistingStorageDomainList, new GetExistingStorageDomainListParameters(hostId, storageType, domainType, path), aQuery);
}
#method_after
public void getExistingStorageDomainList(AsyncQuery<List<StorageDomain>> aQuery, Guid hostId, StorageDomainType domainType, StorageType storageType, String path) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetExistingStorageDomainList, new GetExistingStorageDomainListParameters(hostId, storageType, domainType, path), aQuery);
}
#end_block

#method_before
public void getStorageDomainMaxNameLength(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 1;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StorageDomainNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getStorageDomainMaxNameLength(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(1);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StorageDomainNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void isStorageDomainNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                return storageDomains.isEmpty();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$
    SearchParameters(// $NON-NLS-1$
    "Storage: name=" + name, SearchType.StorageDomain), aQuery);
}
#method_after
public void isStorageDomainNameUnique(AsyncQuery<Boolean> aQuery, String name) {
    aQuery.converterCallback = new Converter<Boolean>() {

        @Override
        public Boolean convert(Object source) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                return storageDomains.isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$
    SearchParameters(// $NON-NLS-1$
    "Storage: name=" + name, SearchType.StorageDomain), aQuery);
}
#end_block

#method_before
public void getNetworkConnectivityCheckTimeoutInSeconds(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 120;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.NetworkConnectivityCheckTimeoutInSeconds, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getNetworkConnectivityCheckTimeoutInSeconds(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(120);
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.NetworkConnectivityCheckTimeoutInSeconds, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getMaxSpmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 0;
        }
    };
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), 10);
}
#method_after
public void getMaxSpmPriority(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(0);
    aQuery.getAsyncCallback().onSuccess(10);
}
#end_block

#method_before
public void getDefaultSpmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Integer) source : 0;
        }
    };
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), 5);
}
#method_after
public void getDefaultSpmPriority(AsyncQuery<Integer> aQuery) {
    aQuery.converterCallback = new DefaultValueConverter<>(0);
    aQuery.getAsyncCallback().onSuccess(5);
}
#end_block

#method_before
public void getDefaultPmProxyPreferences(AsyncQuery query) {
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.FenceProxyDefaultPreferences, getDefaultConfigurationVersion()), query);
}
#method_after
public void getDefaultPmProxyPreferences(AsyncQuery<String> query) {
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.FenceProxyDefaultPreferences, getDefaultConfigurationVersion()), query);
}
#end_block

#method_before
public void getRootTag(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                Tags tag = (Tags) source;
                Tags root = new Tags(tag.getDescription(), tag.getParentId(), tag.getIsReadonly(), tag.getTagId(), tag.getTagName());
                if (tag.getChildren() != null) {
                    fillTagsRecursive(root, tag.getChildren());
                }
                return root;
            }
            return new Tags();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetRootTag, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getRootTag(AsyncQuery<Tags> aQuery) {
    aQuery.converterCallback = new Converter<Tags>() {

        @Override
        public Tags convert(Object source) {
            if (source != null) {
                Tags tag = (Tags) source;
                Tags root = new Tags(tag.getDescription(), tag.getParentId(), tag.getIsReadonly(), tag.getTagId(), tag.getTagName());
                if (tag.getChildren() != null) {
                    fillTagsRecursive(root, tag.getChildren());
                }
                return root;
            }
            return new Tags();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetRootTag, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
private void setAttachedTagsConverter(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Tags> ret = new ArrayList<>();
                for (Tags tags : (ArrayList<Tags>) source) {
                    if (tags.getType() == TagsType.GeneralTag) {
                        ret.add(tags);
                    }
                }
                return ret;
            }
            return new Tags();
        }
    };
}
#method_after
private void setAttachedTagsConverter(AsyncQuery<List<Tags>> aQuery) {
    aQuery.converterCallback = new Converter<List<Tags>>() {

        @Override
        public List<Tags> convert(Object source) {
            if (source != null) {
                ArrayList<Tags> ret = new ArrayList<>();
                for (Tags tags : (ArrayList<Tags>) source) {
                    if (tags.getType() == TagsType.GeneralTag) {
                        ret.add(tags);
                    }
                }
                return ret;
            }
            return new ArrayList<>();
        }
    };
}
#end_block

#method_before
public void getAttachedTagsToVm(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVmId, new GetTagsByVmIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToVm(AsyncQuery<List<Tags>> aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVmId, new GetTagsByVmIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public void getAttachedTagsToUser(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserId, new GetTagsByUserIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToUser(AsyncQuery<List<Tags>> aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserId, new GetTagsByUserIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public void getAttachedTagsToUserGroup(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserGroupId, new GetTagsByUserGroupIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToUserGroup(AsyncQuery<List<Tags>> aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserGroupId, new GetTagsByUserGroupIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public void getAttachedTagsToHost(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVdsId, new GetTagsByVdsIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToHost(AsyncQuery<List<Tags>> aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVdsId, new GetTagsByVdsIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public void getoVirtISOsList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<>((ArrayList<RpmVersion>) source) : new ArrayList<RpmVersion>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetoVirtISOs, new IdQueryParameters(id), aQuery);
}
#method_after
public void getoVirtISOsList(AsyncQuery<List<RpmVersion>> aQuery, Guid id) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetoVirtISOs, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public void getLunsByVgId(AsyncQuery aQuery, String vgId, Guid vdsId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<LUNs>) source : new ArrayList<LUNs>();
        }
    };
    GetLunsByVgIdParameters params = new GetLunsByVgIdParameters(vgId, vdsId);
    Frontend.getInstance().runQuery(VdcQueryType.GetLunsByVgId, params, aQuery);
}
#method_after
public void getLunsByVgId(AsyncQuery<List<LUNs>> aQuery, String vgId, Guid vdsId) {
    aQuery.converterCallback = new ListConverter<>();
    GetLunsByVgIdParameters params = new GetLunsByVgIdParameters(vgId, vdsId);
    Frontend.getInstance().runQuery(VdcQueryType.GetLunsByVgId, params, aQuery);
}
#end_block

#method_before
public void getAllTemplatesFromExportDomain(AsyncQuery aQuery, Guid storagePoolId, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new HashMap<VmTemplate, ArrayList<DiskImage>>();
        }
    };
    GetAllFromExportDomainQueryParameters getAllFromExportDomainQueryParamenters = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    Frontend.getInstance().runQuery(VdcQueryType.GetTemplatesFromExportDomain, getAllFromExportDomainQueryParamenters, aQuery);
}
#method_after
public void getAllTemplatesFromExportDomain(AsyncQuery<Map<VmTemplate, ArrayList<DiskImage>>> aQuery, Guid storagePoolId, Guid storageDomainId) {
    aQuery.converterCallback = new MapConverter<>();
    GetAllFromExportDomainQueryParameters getAllFromExportDomainQueryParamenters = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    Frontend.getInstance().runQuery(VdcQueryType.GetTemplatesFromExportDomain, getAllFromExportDomainQueryParamenters, aQuery);
}
#end_block

#method_before
public void getUpHostListByCluster(AsyncQuery aQuery, String clusterName, Integer maxCount) {
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: cluster = " + clusterName + " and status = up", SearchType.VDS);
    if (maxCount != null) {
        searchParameters.setMaxCount(maxCount);
    }
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public void getUpHostListByCluster(AsyncQuery<List<VDS>> aQuery, String clusterName) {
    aQuery.converterCallback = new ListConverter<>();
    getUpHostListByCluster(aQuery, clusterName, null);
}
#end_block

#method_before
public void getVmNicList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<>((ArrayList<VmNetworkInterface>) source) : new ArrayList<VmNetworkInterface>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmNicList(AsyncQuery<List<VmNetworkInterface>> aQuery, Guid id) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public void getTemplateNicList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<>((ArrayList<VmNetworkInterface>) source) : new ArrayList<VmNetworkInterface>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetTemplateInterfacesByTemplateId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getTemplateNicList(AsyncQuery<List<VmNetworkInterface>> aQuery, Guid id) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetTemplateInterfacesByTemplateId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public void getVmSnapshotList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Snapshot>) source : new ArrayList<Snapshot>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmSnapshotsByVmId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmSnapshotList(AsyncQuery<List<Snapshot>> aQuery, Guid id) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmSnapshotsByVmId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public void getVmsRunningOnOrMigratingToVds(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VM>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmsRunningOnOrMigratingToVds, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmsRunningOnOrMigratingToVds(AsyncQuery<List<VM>> aQuery, Guid id) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmsRunningOnOrMigratingToVds, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public void getVmFromOva(AsyncQuery aQuery, Guid vdsId, String path) {
    aQuery.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetVmFromOva, new GetVmFromOvaQueryParameters(vdsId, path), aQuery);
}
#method_after
public void getVmFromOva(AsyncQuery<VdcQueryReturnValue> aQuery, Guid vdsId, String path) {
    aQuery.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetVmFromOva, new GetVmFromOvaQueryParameters(vdsId, path), aQuery);
}
#end_block

#method_before
public void getVmListByClusterName(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VM> vms = Linq.<VM>cast((ArrayList<IVdcQueryable>) source);
            return vms;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("Vms: cluster=" + clusterName, SearchType.VM), // $NON-NLS-1$
    aQuery);
}
#method_after
public void getVmListByClusterName(AsyncQuery<List<VM>> aQuery, String clusterName) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("Vms: cluster=" + clusterName, SearchType.VM), // $NON-NLS-1$
    aQuery);
}
#end_block

#method_before
public void getDiskList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<DiskImage>) source : new ArrayList<DiskImage>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Disks:", SearchType.Disk);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#method_after
public void getDiskList(AsyncQuery<List<DiskImage>> aQuery) {
    aQuery.converterCallback = new ListConverter<>();
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Disks:", SearchType.Disk);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#end_block

#method_before
public void getNextAvailableDiskAliasNameByVMId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNextAvailableDiskAliasNameByVMId, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getNextAvailableDiskAliasNameByVMId(AsyncQuery<String> aQuery, Guid vmId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetNextAvailableDiskAliasNameByVMId, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public void isPoolNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !(Boolean) source;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmPoolWithSameNameExists, new NameQueryParameters(name), aQuery);
}
#method_after
public void isPoolNameUnique(AsyncQuery<Boolean> aQuery, String name) {
    aQuery.converterCallback = new Converter<Boolean>() {

        @Override
        public Boolean convert(Object source) {
            if (source != null) {
                return !(Boolean) source;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmPoolWithSameNameExists, new NameQueryParameters(name), aQuery);
}
#end_block

#method_before
public void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId).withoutRefresh(), aQuery);
}
#method_after
public void getVmConfigurationBySnapshot(AsyncQuery<VM> aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getAllAttachableDisks(AsyncQuery aQuery, Guid storagePoolId, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Disk>) source : new ArrayList<Disk>();
        }
    };
    GetAllAttachableDisksForVmQueryParameters params = new GetAllAttachableDisksForVmQueryParameters(storagePoolId);
    params.setVmId(vmId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllAttachableDisksForVm, params, aQuery);
}
#method_after
public void getAllAttachableDisks(AsyncQuery<List<Disk>> aQuery, Guid storagePoolId, Guid vmId) {
    aQuery.converterCallback = new ListConverter<>();
    GetAllAttachableDisksForVmQueryParameters params = new GetAllAttachableDisksForVmQueryParameters(storagePoolId);
    params.setVmId(vmId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllAttachableDisksForVm, params, aQuery);
}
#end_block

#method_before
public void getAncestorImagesByImagesIds(AsyncQuery aQuery, List<Guid> imagesIds) {
    aQuery.converterCallback = new IAsyncConverter<Map<Guid, DiskImage>>() {

        @Override
        public Map<Guid, DiskImage> convert(Object returnValue, AsyncQuery asyncQuery) {
            return (Map<Guid, DiskImage>) returnValue;
        }
    };
    IdsQueryParameters params = new IdsQueryParameters(imagesIds);
    Frontend.getInstance().runQuery(VdcQueryType.GetAncestorImagesByImagesIds, params, aQuery);
}
#method_after
public void getAncestorImagesByImagesIds(AsyncQuery<Map<Guid, DiskImage>> aQuery, List<Guid> imagesIds) {
    aQuery.converterCallback = new CastingConverter<>();
    IdsQueryParameters params = new IdsQueryParameters(imagesIds);
    Frontend.getInstance().runQuery(VdcQueryType.GetAncestorImagesByImagesIds, params, aQuery);
}
#end_block

#method_before
public void getPermittedStorageDomainsByStoragePoolId(AsyncQuery aQuery, Guid dataCenterId, ActionGroup actionGroup) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new java.util.ArrayList<StorageDomain>();
            }
            return source;
        }
    };
    GetPermittedStorageDomainsByStoragePoolIdParameters params = new GetPermittedStorageDomainsByStoragePoolIdParameters();
    params.setStoragePoolId(dataCenterId);
    params.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, params, aQuery);
}
#method_after
public void getPermittedStorageDomainsByStoragePoolId(AsyncQuery<List<StorageDomain>> aQuery, Guid dataCenterId, ActionGroup actionGroup) {
    aQuery.converterCallback = new ListConverter<>();
    GetPermittedStorageDomainsByStoragePoolIdParameters params = new GetPermittedStorageDomainsByStoragePoolIdParameters();
    params.setStoragePoolId(dataCenterId);
    params.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, params, aQuery);
}
#end_block

#method_before
public void getStorageDomainDefaultWipeAfterDelete(AsyncQuery aQuery, StorageType storageType) {
    aQuery.converterCallback = new IAsyncConverter<Boolean>() {

        @Override
        public Boolean convert(Object returnValue, AsyncQuery asyncQuery) {
            return (Boolean) returnValue;
        }
    };
    GetStorageDomainDefaultWipeAfterDeleteParameters params = new GetStorageDomainDefaultWipeAfterDeleteParameters(storageType);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainDefaultWipeAfterDelete, params, aQuery);
}
#method_after
public void getStorageDomainDefaultWipeAfterDelete(AsyncQuery<Boolean> aQuery, StorageType storageType) {
    aQuery.converterCallback = new CastingConverter<>();
    GetStorageDomainDefaultWipeAfterDeleteParameters params = new GetStorageDomainDefaultWipeAfterDeleteParameters(storageType);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainDefaultWipeAfterDelete, params, aQuery);
}
#end_block

#method_before
public void getAllDataCenterNetworks(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new ListAsyncConverter();
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworksByDataCenterId, params, aQuery);
}
#method_after
public void getAllDataCenterNetworks(AsyncQuery<List<Network>> aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new ListConverter<>();
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworksByDataCenterId, params, aQuery);
}
#end_block

#method_before
public void getManagementNetworkCandidates(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new ListAsyncConverter();
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetManagementNetworkCandidates, params, aQuery);
}
#method_after
public void getManagementNetworkCandidates(AsyncQuery<List<Network>> aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new ListConverter<>();
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetManagementNetworkCandidates, params, aQuery);
}
#end_block

#method_before
public void getStorageConnectionsByDataCenterIdAndStorageType(AsyncQuery aQuery, Guid storagePoolId, StorageType storageType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    GetConnectionsByDataCenterAndStorageTypeParameters params = new GetConnectionsByDataCenterAndStorageTypeParameters(storagePoolId, storageType);
    Frontend.getInstance().runQuery(VdcQueryType.GetConnectionsByDataCenterAndStorageType, params, aQuery);
}
#method_after
public void getStorageConnectionsByDataCenterIdAndStorageType(AsyncQuery<List<StorageServerConnections>> aQuery, Guid storagePoolId, StorageType storageType) {
    aQuery.converterCallback = new CastingConverter<>();
    GetConnectionsByDataCenterAndStorageTypeParameters params = new GetConnectionsByDataCenterAndStorageTypeParameters(storagePoolId, storageType);
    Frontend.getInstance().runQuery(VdcQueryType.GetConnectionsByDataCenterAndStorageType, params, aQuery);
}
#end_block

#method_before
private void cacheConfigValues(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object returnValue, AsyncQuery _asyncQuery) {
            if (returnValue != null) {
                cachedConfigValuesPreConvert.putAll((HashMap<KeyValuePairCompat<ConfigurationValues, String>, Object>) returnValue);
            }
            return cachedConfigValuesPreConvert;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetConfigurationValues, new VdcQueryParametersBase(), aQuery);
}
#method_after
private void cacheConfigValues(AsyncQuery<Map<KeyValuePairCompat<ConfigurationValues, String>, Object>> aQuery) {
    aQuery.converterCallback = new Converter<Map<KeyValuePairCompat<ConfigurationValues, String>, Object>>() {

        @Override
        public Map<KeyValuePairCompat<ConfigurationValues, String>, Object> convert(Object returnValue) {
            if (returnValue != null) {
                cachedConfigValuesPreConvert.putAll((HashMap<KeyValuePairCompat<ConfigurationValues, String>, Object>) returnValue);
            }
            return cachedConfigValuesPreConvert;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetConfigurationValues, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public void getConfigFromCache(GetConfigurationValueParameters parameters, AsyncQuery aQuery) {
    // cache key
    final KeyValuePairCompat<ConfigurationValues, String> config_key = new KeyValuePairCompat<>(parameters.getConfigValue(), parameters.getVersion());
    Object returnValue = null;
    if (cachedConfigValues.containsKey(config_key)) {
        // cache hit
        returnValue = cachedConfigValues.get(config_key);
    } else // and call asyncCallback's onSuccess
    if (cachedConfigValuesPreConvert.containsKey(config_key)) {
        returnValue = cachedConfigValuesPreConvert.get(config_key);
        // run converter
        if (aQuery.converterCallback != null) {
            returnValue = aQuery.converterCallback.convert(returnValue, aQuery);
        }
        if (returnValue != null) {
            cachedConfigValues.put(config_key, returnValue);
        }
    }
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), returnValue);
}
#method_after
public <T> void getConfigFromCache(GetConfigurationValueParameters parameters, AsyncQuery<T> aQuery) {
    // cache key
    final KeyValuePairCompat<ConfigurationValues, String> config_key = new KeyValuePairCompat<>(parameters.getConfigValue(), parameters.getVersion());
    T returnValue = null;
    if (cachedConfigValues.containsKey(config_key)) {
        // cache hit
        returnValue = (T) cachedConfigValues.get(config_key);
    } else // and call asyncCallback's onSuccess
    if (cachedConfigValuesPreConvert.containsKey(config_key)) {
        returnValue = (T) cachedConfigValuesPreConvert.get(config_key);
        // run converter
        if (aQuery.converterCallback != null) {
            returnValue = aQuery.converterCallback.convert(returnValue);
        }
        if (returnValue != null) {
            cachedConfigValues.put(config_key, returnValue);
        }
    }
    aQuery.getAsyncCallback().onSuccess(returnValue);
}
#end_block

#method_before
@Override
public Object convert(Object source, AsyncQuery asyncQuery) {
    List<VmTemplate> list = new ArrayList<>();
    if (source != null) {
        VmTemplate blankTemplate = null;
        for (VmTemplate template : (List<VmTemplate>) source) {
            if (template.getId().equals(Guid.Empty)) {
                blankTemplate = template;
            } else if (template.getStatus() == VmTemplateStatus.OK) {
                list.add(template);
            }
        }
        Collections.sort(list, new NameableComparator());
        if (blankTemplate != null) {
            list.add(0, blankTemplate);
        }
    }
    return list;
}
#method_after
@Override
public List<VmTemplate> convert(Object source) {
    List<VmTemplate> list = new ArrayList<>();
    if (source != null) {
        VmTemplate blankTemplate = null;
        for (VmTemplate template : (List<VmTemplate>) source) {
            if (template.getId().equals(Guid.Empty)) {
                blankTemplate = template;
            } else if (template.getStatus() == VmTemplateStatus.OK) {
                list.add(template);
            }
        }
        Collections.sort(list, new NameableComparator());
        if (blankTemplate != null) {
            list.add(0, blankTemplate);
        }
    }
    return list;
}
#end_block

#method_before
public void getExternalProviderHostList(AsyncQuery aQuery, Guid providerId, boolean filterOutExistingHosts, String searchFilter) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDS>();
            }
            return source;
        }
    };
    GetHostListFromExternalProviderParameters params = new GetHostListFromExternalProviderParameters();
    params.setFilterOutExistingHosts(filterOutExistingHosts);
    params.setProviderId(providerId);
    params.setSearchFilter(searchFilter);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostListFromExternalProvider, params, aQuery);
}
#method_after
public void getExternalProviderHostList(AsyncQuery<List<VDS>> aQuery, Guid providerId, boolean filterOutExistingHosts, String searchFilter) {
    aQuery.converterCallback = new ListConverter<>();
    GetHostListFromExternalProviderParameters params = new GetHostListFromExternalProviderParameters();
    params.setFilterOutExistingHosts(filterOutExistingHosts);
    params.setProviderId(providerId);
    params.setSearchFilter(searchFilter);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostListFromExternalProvider, params, aQuery);
}
#end_block

#method_before
public void getExternalProviderDiscoveredHostList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<ExternalDiscoveredHost>();
            }
            return source;
        }
    };
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetDiscoveredHostListFromExternalProvider, params, aQuery);
}
#method_after
public void getExternalProviderDiscoveredHostList(AsyncQuery<List<ExternalDiscoveredHost>> aQuery, Provider provider) {
    aQuery.converterCallback = new ListConverter<>();
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetDiscoveredHostListFromExternalProvider, params, aQuery);
}
#end_block

#method_before
public void getExternalProviderHostGroupList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<ExternalHostGroup>();
            }
            return source;
        }
    };
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostGroupsFromExternalProvider, params, aQuery);
}
#method_after
public void getExternalProviderHostGroupList(AsyncQuery<List<ExternalHostGroup>> aQuery, Provider provider) {
    aQuery.converterCallback = new ListConverter<>();
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostGroupsFromExternalProvider, params, aQuery);
}
#end_block

#method_before
public void getExternalProviderComputeResourceList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<ExternalComputeResource>();
            }
            return source;
        }
    };
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetComputeResourceFromExternalProvider, params, aQuery);
}
#method_after
public void getExternalProviderComputeResourceList(AsyncQuery<List<ExternalComputeResource>> aQuery, Provider provider) {
    aQuery.converterCallback = new ListConverter<>();
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetComputeResourceFromExternalProvider, params, aQuery);
}
#end_block

#method_before
public void getAllProviders(AsyncQuery aQuery, boolean doRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            Collections.sort((List<Provider>) source, new NameableComparator());
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, doRefresh ? new GetAllProvidersParameters() : new GetAllProvidersParameters().withoutRefresh(), aQuery);
}
#method_after
public void getAllProviders(AsyncQuery<List<Provider<?>>> aQuery, boolean doRefresh) {
    aQuery.converterCallback = new SortListByNameConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, doRefresh ? new GetAllProvidersParameters() : new GetAllProvidersParameters().withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new IAsyncConverter<List<Provider>>() {

        @Override
        public List<Provider> convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Collection<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#method_after
public void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new Converter<List<Provider>>() {

        @Override
        public List<Provider> convert(Object returnValue) {
            if (returnValue == null) {
                return new ArrayList<>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Collection<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#end_block

#method_before
public void getAllNetworkProviders(AsyncQuery query) {
    getAllProvidersByProvidedEntity(query, VdcObjectType.Network);
}
#method_after
public void getAllNetworkProviders(AsyncQuery<List<Provider<?>>> query) {
    getAllProvidersByProvidedEntity(query, VdcObjectType.Network);
}
#end_block

#method_before
public void getAllProvidersByType(AsyncQuery aQuery, ProviderType providerType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(providerType), aQuery);
}
#method_after
public void getAllProvidersByType(AsyncQuery<List<Provider<?>>> aQuery, ProviderType providerType) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(providerType), aQuery);
}
#end_block

#method_before
public void getProviderCertificateChain(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return Collections.<CertificateInfo>emptyList();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChain, new ProviderQueryParameters(provider), aQuery);
}
#method_after
public void getProviderCertificateChain(AsyncQuery<List<CertificateInfo>> aQuery, Provider provider) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChain, new ProviderQueryParameters(provider), aQuery);
}
#end_block

#method_before
public void getNicTypeList(final int osId, Version version, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> nics = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<VmInterfaceType> interfaceTypes = new ArrayList<>();
            for (String nic : nics) {
                try {
                    interfaceTypes.add(VmInterfaceType.valueOf(nic));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNetworkDevices, osId, version), asyncQuery);
}
#method_after
public void getNicTypeList(final int osId, Version version, AsyncQuery<List<VmInterfaceType>> asyncQuery) {
    asyncQuery.converterCallback = new Converter<List<VmInterfaceType>>() {

        @Override
        public List<VmInterfaceType> convert(Object returnValue) {
            ArrayList<String> nics = (ArrayList<String>) returnValue;
            List<VmInterfaceType> interfaceTypes = new ArrayList<>();
            for (String nic : nics) {
                try {
                    interfaceTypes.add(VmInterfaceType.valueOf(nic));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            return interfaceTypes;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNetworkDevices, osId, version), asyncQuery);
}
#end_block

#method_before
public void getIsPasswordDelegationPossible(AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            chainedCallback.onSuccess(model, ((VdcQueryReturnValue) returnValue).getReturnValue());
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsPasswordDelegationPossible, new VdcQueryParametersBase(), asyncQuery);
}
#method_after
public void getIsPasswordDelegationPossible(AsyncQuery<Boolean> asyncQuery) {
    asyncQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.IsPasswordDelegationPossible, new VdcQueryParametersBase(), asyncQuery);
}
#end_block

#method_before
public ArrayList<DiskInterface> getDiskInterfaceList() {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI, DiskInterface.SPAPR_VSCSI }));
    return diskInterfaces;
}
#method_after
public void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery<List<DiskInterface>> asyncQuery) {
    asyncQuery.converterCallback = new Converter<List<DiskInterface>>() {

        @Override
        public List<DiskInterface> convert(Object returnValue) {
            ArrayList<String> interfaces = (ArrayList<String>) returnValue;
            List<DiskInterface> interfaceTypes = new ArrayList<>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            return interfaceTypes;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#end_block

#method_before
public void initWindowsOsTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            windowsOsIds = (ArrayList<Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetWindowsOss), callback);
}
#method_after
public void initWindowsOsTypes() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetWindowsOss), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            windowsOsIds = (ArrayList<Integer>) returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
public void initLinuxOsTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            linuxOsIds = (ArrayList<Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetLinuxOss), callback);
}
#method_after
public void initLinuxOsTypes() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetLinuxOss), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            linuxOsIds = (ArrayList<Integer>) returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
public void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependencyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#method_after
public void initUniqueOsNames() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            uniqueOsNames = returnValue.getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependencyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    }));
}
#end_block

#method_before
public void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#method_after
public void initOsNames() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            osNames = returnValue.getReturnValue();
            initOsIds();
        }
    }));
}
#end_block

#method_before
private void initOsDefaultIconIds() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final Map<Integer, VmIconIdSizePair> returnMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (returnMap.get(DEFAULT_OS_ID) == null) {
                // $NON-NLS-1$
                throw new RuntimeException("Engine did not provide icon IDs of default OS.");
            }
            osIdToDefaultIconIdMap = Collections.unmodifiableMap(returnMap);
            initializeLargeToSmallIconMap();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmIconDefaults, new VdcQueryParametersBase(), callback);
}
#method_after
private void initOsDefaultIconIds() {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmIconDefaults, new VdcQueryParametersBase(), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            final Map<Integer, VmIconIdSizePair> returnMap = returnValue.getReturnValue();
            if (returnMap.get(DEFAULT_OS_ID) == null) {
                // $NON-NLS-1$
                throw new RuntimeException("Engine did not provide icon IDs of default OS.");
            }
            osIdToDefaultIconIdMap = Collections.unmodifiableMap(returnMap);
            initializeLargeToSmallIconMap();
        }
    }));
}
#end_block

#method_before
public void initOsArchitecture() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osArchitectures = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsArchitectures), callback);
}
#method_after
public void initOsArchitecture() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsArchitectures), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            osArchitectures = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
private void initDisplayTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            graphicsAndDisplays = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), callback);
}
#method_after
private void initDisplayTypes() {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            graphicsAndDisplays = returnValue.getReturnValue();
        }
    }));
}
#end_block

#method_before
public void getVmWatchdogTypes(int osId, Version version, AsyncQuery asyncQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetVmWatchdogTypes, osId, version), asyncQuery);
}
#method_after
public void getVmWatchdogTypes(int osId, Version version, AsyncQuery<VdcQueryReturnValue> asyncQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetVmWatchdogTypes, osId, version), asyncQuery);
}
#end_block

#method_before
public void getVmGuestAgentInterfacesByVmId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VmGuestAgentInterface>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmGuestAgentInterfacesByVmId, new IdQueryParameters(vmId).withoutRefresh(), aQuery);
}
#method_after
public void getVmGuestAgentInterfacesByVmId(AsyncQuery<List<VmGuestAgentInterface>> aQuery, Guid vmId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmGuestAgentInterfacesByVmId, new IdQueryParameters(vmId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getVnicProfilesByNetworkId(AsyncQuery aQuery, Guid networkId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VnicProfileView>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByNetworkId, new IdQueryParameters(networkId), aQuery);
}
#method_after
public void getVnicProfilesByNetworkId(AsyncQuery<List<VnicProfileView>> aQuery, Guid networkId) {
    aQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByNetworkId, new IdQueryParameters(networkId), aQuery);
}
#end_block

#method_before
public void getVnicProfilesByDcId(AsyncQuery aQuery, Guid dcId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return new ArrayList<VnicProfileView>();
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByDataCenterId, new IdQueryParameters(dcId), aQuery);
}
#method_after
public void getVnicProfilesByDcId(AsyncQuery<List<VnicProfileView>> aQuery, Guid dcId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new ListConverter<>();
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByDataCenterId, new IdQueryParameters(dcId), aQuery);
}
#end_block

#method_before
public void getExternalNetworkMap(AsyncQuery aQuery, Guid providerId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new HashMap<Network, Set<Guid>>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllExternalNetworksOnProvider, new IdQueryParameters(providerId), aQuery);
}
#method_after
public void getExternalNetworkMap(AsyncQuery<Map<Network, Set<Guid>>> aQuery, Guid providerId) {
    aQuery.converterCallback = new MapConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllExternalNetworksOnProvider, new IdQueryParameters(providerId), aQuery);
}
#end_block

#method_before
private static void convertAAAProfilesResult(AsyncQuery aQuery, final boolean passwordBasedOnly) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            List<String> results = new ArrayList<>();
            for (ProfileEntry profileEntry : (Collection<ProfileEntry>) source) {
                if (!passwordBasedOnly || profileEntry.getSupportsPasswordAuthenication()) {
                    results.add(profileEntry.getProfile());
                }
            }
            return results;
        }
    };
}
#method_after
private static void convertAAAProfilesResult(AsyncQuery<List<String>> aQuery, final boolean passwordBasedOnly) {
    aQuery.converterCallback = new Converter<List<String>>() {

        @Override
        public List<String> convert(Object source) {
            List<String> results = new ArrayList<>();
            for (ProfileEntry profileEntry : (Collection<ProfileEntry>) source) {
                if (!passwordBasedOnly || profileEntry.getSupportsPasswordAuthenication()) {
                    results.add(profileEntry.getProfile());
                }
            }
            return results;
        }
    };
}
#end_block

#method_before
public void getHostNumaTopologyByHostId(AsyncQuery asyncQuery, Guid hostId) {
    asyncQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery asyncQuery) {
            if (source == null) {
                return new ArrayList<VdsNumaNode>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsNumaNodesByVdsId, new IdQueryParameters(hostId), asyncQuery);
}
#method_after
public void getHostNumaTopologyByHostId(AsyncQuery<List<VdsNumaNode>> asyncQuery, Guid hostId) {
    asyncQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsNumaNodesByVdsId, new IdQueryParameters(hostId), asyncQuery);
}
#end_block

#method_before
public void getVMsWithVNumaNodesByClusterId(AsyncQuery asyncQuery, Guid clusterId) {
    asyncQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery asyncQuery) {
            if (source == null) {
                return new ArrayList<VM>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmsWithNumaByClusterId, new IdQueryParameters(clusterId), asyncQuery);
}
#method_after
public void getVMsWithVNumaNodesByClusterId(AsyncQuery<List<VM>> asyncQuery, Guid clusterId) {
    asyncQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmsWithNumaByClusterId, new IdQueryParameters(clusterId), asyncQuery);
}
#end_block

#method_before
public void getEmulatedMachinesByClusterID(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> vdsList = Linq.<VDS>cast((List<IVdcQueryable>) source);
                Set<String> emulatedMachineList = new HashSet<>();
                for (VDS host : vdsList) {
                    String hostSupportedMachines = host.getSupportedEmulatedMachines();
                    if (!StringHelper.isNullOrEmpty(hostSupportedMachines)) {
                        // $NON-NLS-1$
                        emulatedMachineList.addAll(Arrays.asList(hostSupportedMachines.split(",")));
                    }
                }
                return emulatedMachineList;
            }
            return null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getEmulatedMachinesByClusterID(AsyncQuery<Set<String>> aQuery, Guid clusterId) {
    aQuery.converterCallback = new Converter<Set<String>>() {

        @Override
        public Set<String> convert(Object source) {
            if (source != null) {
                ArrayList<VDS> vdsList = Linq.cast((List<IVdcQueryable>) source);
                Set<String> emulatedMachineList = new HashSet<>();
                for (VDS host : vdsList) {
                    String hostSupportedMachines = host.getSupportedEmulatedMachines();
                    if (!StringHelper.isNullOrEmpty(hostSupportedMachines)) {
                        // $NON-NLS-1$
                        emulatedMachineList.addAll(Arrays.asList(hostSupportedMachines.split(",")));
                    }
                }
                return emulatedMachineList;
            }
            return null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
public void getSupportedCpuList(AsyncQuery aQuery, String cpuName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<ServerCpu> cpuList = Linq.<ServerCpu>cast((ArrayList<ServerCpu>) source);
                return cpuList;
            }
            return null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSupportedCpuList, new GetSupportedCpuListParameters(cpuName), aQuery);
}
#method_after
public void getSupportedCpuList(AsyncQuery<List<ServerCpu>> aQuery, String cpuName) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetSupportedCpuList, new GetSupportedCpuListParameters(cpuName), aQuery);
}
#end_block

#method_before
public void getStorageDevices(AsyncQuery aQuery, Guid hostId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterStorageDevices, new IdQueryParameters(hostId), aQuery);
}
#method_after
public void getStorageDevices(AsyncQuery<List<StorageDevice>> aQuery, Guid hostId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterStorageDevices, new IdQueryParameters(hostId), aQuery);
}
#end_block

#method_before
public void getClusterEditWarnings(AsyncQuery aQuery, Guid clusterId, Cluster cluster) {
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterEditWarnings, new ClusterEditParameters(cluster), aQuery);
}
#method_after
public void getClusterEditWarnings(AsyncQuery<ClusterEditWarnings> aQuery, Guid clusterId, Cluster cluster) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterEditWarnings, new ClusterEditParameters(cluster), aQuery);
}
#end_block

#method_before
public void getUnusedBricksFromServer(AsyncQuery asyncQuery, Guid hostId) {
    asyncQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    IdQueryParameters parameters = new IdQueryParameters(hostId);
    Frontend.getInstance().runQuery(VdcQueryType.GetUnusedGlusterBricks, parameters, asyncQuery);
}
#method_after
public void getUnusedBricksFromServer(AsyncQuery<List<StorageDevice>> asyncQuery, Guid hostId) {
    asyncQuery.converterCallback = new CastingConverter<>();
    IdQueryParameters parameters = new IdQueryParameters(hostId);
    Frontend.getInstance().runQuery(VdcQueryType.GetUnusedGlusterBricks, parameters, asyncQuery);
}
#end_block

#method_before
public void getCinderVolumeTypesList(AsyncQuery aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter<List<CinderVolumeType>>() {

        @Override
        public List<CinderVolumeType> convert(Object source, AsyncQuery _asyncQuery) {
            return (List<CinderVolumeType>) source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetCinderVolumeTypesByStorageDomainId, new IdQueryParameters(storageDomainId), aQuery);
}
#method_after
public void getCinderVolumeTypesList(AsyncQuery<List<CinderVolumeType>> aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new CastingConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetCinderVolumeTypesByStorageDomainId, new IdQueryParameters(storageDomainId), aQuery);
}
#end_block

#method_before
public void getClusterFeaturesByVersionAndCategory(AsyncQuery aQuery, Version version, ApplicationMode category) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Set<AdditionalFeature>) source : new HashSet<AdditionalFeature>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterFeaturesByVersionAndCategory, new GetClusterFeaturesByVersionAndCategoryParameters(version, category), aQuery);
}
#method_after
public void getClusterFeaturesByVersionAndCategory(AsyncQuery<Set<AdditionalFeature>> aQuery, Version version, ApplicationMode category) {
    aQuery.converterCallback = new SetConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterFeaturesByVersionAndCategory, new GetClusterFeaturesByVersionAndCategoryParameters(version, category), aQuery);
}
#end_block

#method_before
public void getClusterFeaturesByClusterId(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (Set<SupportedAdditionalClusterFeature>) source : new HashSet<SupportedAdditionalClusterFeature>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterFeaturesByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getClusterFeaturesByClusterId(AsyncQuery<Set<SupportedAdditionalClusterFeature>> aQuery, Guid clusterId) {
    aQuery.converterCallback = new SetConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetClusterFeaturesByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
@Override
public Object convert(Object source, AsyncQuery _asyncQuery) {
    if (source != null) {
        ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
        ArrayList<String> fileNameList = new ArrayList<>();
        for (RepoImage repoImage : repoList) {
            if (desiredImage(repoImage)) {
                fileNameList.add(transform(fileNameList, repoImage));
            }
        }
        Collections.sort(fileNameList, new LexoNumericComparator());
        return fileNameList;
    }
    return new ArrayList<String>();
}
#method_after
@Override
public List<String> convert(Object source) {
    if (source != null) {
        ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
        ArrayList<String> fileNameList = new ArrayList<>();
        for (RepoImage repoImage : repoList) {
            if (desiredImage(repoImage)) {
                fileNameList.add(transform(fileNameList, repoImage));
            }
        }
        Collections.sort(fileNameList, new LexoNumericComparator());
        return fileNameList;
    }
    return new ArrayList<>();
}
#end_block

#method_before
public void getVmTemplatesByBaseTemplateId(AsyncQuery asyncQuery, Guid baseTemplate) {
    asyncQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object convert(Object source, AsyncQuery asyncQuery) {
            if (source == null) {
                return new ArrayList<VmTemplate>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesByBaseTemplateId, new GetVmTemplateParameters(baseTemplate), asyncQuery);
}
#method_after
public void getVmTemplatesByBaseTemplateId(AsyncQuery<List<VmTemplate>> asyncQuery, Guid baseTemplate) {
    asyncQuery.converterCallback = new ListConverter<>();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesByBaseTemplateId, new GetVmTemplateParameters(baseTemplate), asyncQuery);
}
#end_block

#method_before
@Override
public List<Quota> convert(Object returnValue, AsyncQuery asyncQuery) {
    List<Quota> quotaList = (List<Quota>) returnValue;
    if (quotaList != null && !quotaList.isEmpty()) {
        Comparator<Quota> comparator = (topId == null) ? QuotaComparator.NAME : QuotaComparator.withTopId(topId, QuotaComparator.NAME);
        Collections.sort(quotaList, comparator);
    }
    return quotaList;
}
#method_after
@Override
public List<Quota> convert(Object returnValue) {
    List<Quota> quotaList = (List<Quota>) returnValue;
    if (quotaList != null && !quotaList.isEmpty()) {
        Comparator<Quota> comparator = (topId == null) ? QuotaComparator.NAME : QuotaComparator.withTopId(topId, QuotaComparator.NAME);
        Collections.sort(quotaList, comparator);
    }
    return quotaList;
}
#end_block

#method_before
public void getAllRelevantQuotasForStorageSorted(AsyncQuery asyncQuery, Guid storageId, Guid topQuotaId) {
    asyncQuery.converterCallback = new QuotaConverter(topQuotaId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRelevantQuotasForStorage, new IdQueryParameters(storageId), asyncQuery);
}
#method_after
public void getAllRelevantQuotasForStorageSorted(AsyncQuery<List<Quota>> asyncQuery, Guid storageId, Guid topQuotaId) {
    asyncQuery.converterCallback = new QuotaConverter(topQuotaId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRelevantQuotasForStorage, new IdQueryParameters(storageId), asyncQuery);
}
#end_block

#method_before
public void getAllRelevantQuotasForClusterSorted(AsyncQuery asyncQuery, Guid clusterId, Guid topQuotaId) {
    asyncQuery.converterCallback = new QuotaConverter(topQuotaId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRelevantQuotasForCluster, new IdQueryParameters(clusterId), asyncQuery);
}
#method_after
public void getAllRelevantQuotasForClusterSorted(AsyncQuery<List<Quota>> asyncQuery, Guid clusterId, Guid topQuotaId) {
    asyncQuery.converterCallback = new QuotaConverter(topQuotaId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRelevantQuotasForCluster, new IdQueryParameters(clusterId), asyncQuery);
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    vmListReturn = getBroker().getExternalVmNamesList(getParameters().getUrl(), getParameters().getUsername(), getParameters().getPassword());
    proceedProxyReturnValue();
    List<VM> vms = new ArrayList<>();
    for (Map<String, Object> map : vmListReturn.vmNamesList) {
        VM vm = new VM();
        if (vm != null) {
            vm.setName((String) map.get(VdsProperties.vm_name));
            vm.setOrigin(getParameters().getOriginType());
            vms.add(vm);
        }
    }
    setReturnValue(vms);
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    vmListReturn = getBroker().getExternalVmNamesList(getParameters().getUrl(), getParameters().getUsername(), getParameters().getPassword());
    proceedProxyReturnValue();
    List<VM> vms = new ArrayList<>();
    for (String vmName : vmListReturn.getNamesList()) {
        VM vm = new VM();
        if (vmName != null) {
            vm.setName(vmName);
            vm.setOrigin(getParameters().getOriginType());
            vms.add(vm);
        }
    }
    setReturnValue(vms);
}
#end_block

#method_before
@Override
protected StatusForXmlRpc getReturnStatus() {
    return vmListReturn.status;
}
#method_after
@Override
protected StatusForXmlRpc getReturnStatus() {
    return vmListReturn.getStatus();
}
#end_block

#method_before
@Override
public void init(final List<VM> externalVms, final Guid dataCenterId) {
    setCloseCommand(new UICommand(null, this).setTitle(ConstantsManager.getInstance().getConstants().close()).setIsDefault(true).setIsCancel(true));
    setTargetArchitecture(externalVms);
    withDataCenterLoaded(dataCenterId, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setItems(new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    doInit();
                }
            }, externalVms);
        }
    });
}
#method_after
@Override
public void init(final List<VM> externalVms, final Guid dataCenterId) {
    setCloseCommand(new UICommand(null, this).setTitle(ConstantsManager.getInstance().getConstants().close()).setIsDefault(true).setIsCancel(true));
    setTargetArchitecture(externalVms);
    withDataCenterLoaded(dataCenterId, new AsyncCallback<StoragePool>() {

        @Override
        public void onSuccess(StoragePool returnValue) {
            setItems(new AsyncCallback<VdcQueryReturnValue>() {

                @Override
                public void onSuccess(VdcQueryReturnValue returnValue) {
                    doInit();
                }
            }, externalVms);
        }
    });
}
#end_block

#method_before
private void withDataCenterLoaded(Guid dataCenterId, final INewAsyncCallback callback) {
    AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setStoragePool((StoragePool) returnValue);
            callback.onSuccess(model, returnValue);
        }
    }), dataCenterId);
}
#method_after
private void withDataCenterLoaded(Guid dataCenterId, final AsyncCallback<StoragePool> callback) {
    AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery<>(new AsyncCallback<StoragePool>() {

        @Override
        public void onSuccess(StoragePool returnValue) {
            setStoragePool(returnValue);
            callback.onSuccess(returnValue);
        }
    }), dataCenterId);
}
#end_block

#method_before
protected void doInit() {
    final StoragePool dataCenter = getStoragePool();
    if (dataCenter == null) {
        return;
    }
    setStoragePool(dataCenter);
    getClusterQuota().setIsAvailable(dataCenter.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED);
    getCluster().getSelectedItemChangedEvent().addListener(clusterChangedListener);
    // get cluster
    getCluster().setItems(null);
    AsyncDataProvider.getInstance().getVnicProfilesByDcId(new AsyncQuery(ImportVmFromExternalProviderModel.this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            networkProfiles = (List<VnicProfileView>) returnValue;
            initNetworksList();
            initClusterAndStorage(dataCenter);
        }
    }), dataCenter.getId());
}
#method_after
protected void doInit() {
    final StoragePool dataCenter = getStoragePool();
    if (dataCenter == null) {
        return;
    }
    setStoragePool(dataCenter);
    getClusterQuota().setIsAvailable(dataCenter.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED);
    getCluster().getSelectedItemChangedEvent().addListener(clusterChangedListener);
    // get cluster
    getCluster().setItems(null);
    AsyncDataProvider.getInstance().getVnicProfilesByDcId(new AsyncQuery<>(new AsyncCallback<List<VnicProfileView>>() {

        @Override
        public void onSuccess(List<VnicProfileView> returnValue) {
            networkProfiles = returnValue;
            initNetworksList();
            initClusterAndStorage(dataCenter);
        }
    }), dataCenter.getId());
}
#end_block

#method_before
private void initClusterAndStorage(StoragePool dataCenter) {
    AsyncDataProvider.getInstance().getClusterByServiceList(new AsyncQuery(ImportVmFromExternalProviderModel.this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<Cluster> clusters = (List<Cluster>) returnValue;
            ArchitectureType targetArch = getTargetArchitecture();
            if (targetArch != null) {
                clusters = AsyncDataProvider.getInstance().filterByArchitecture(clusters, targetArch);
            }
            getCluster().setItems(clusters);
            getCluster().setSelectedItem(Linq.firstOrNull(clusters));
            // get storage domains
            AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(ImportVmFromExternalProviderModel.this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    List<StorageDomain> storageDomains = (List<StorageDomain>) returnValue;
                    // filter storage domains
                    List<StorageDomain> filteredStorageDomains = new ArrayList<>();
                    for (StorageDomain domain : storageDomains) {
                        if (Linq.isDataActiveStorageDomain(domain)) {
                            filteredStorageDomains.add(domain);
                        }
                    }
                    getStorage().setItems(filteredStorageDomains);
                    if (getClusterQuota().getIsAvailable()) {
                        initQuotaForStorageDomains();
                    } else {
                        initDisksStorageDomainsList();
                    }
                }
            }), getStoragePool().getId());
        }
    }), dataCenter.getId(), true, false);
}
#method_after
private void initClusterAndStorage(StoragePool dataCenter) {
    AsyncDataProvider.getInstance().getClusterByServiceList(new AsyncQuery<>(new AsyncCallback<List<Cluster>>() {

        @Override
        public void onSuccess(List<Cluster> clusters) {
            ArchitectureType targetArch = getTargetArchitecture();
            if (targetArch != null) {
                clusters = AsyncDataProvider.getInstance().filterByArchitecture(clusters, targetArch);
            }
            getCluster().setItems(clusters);
            getCluster().setSelectedItem(Linq.firstOrNull(clusters));
            // get storage domains
            AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

                @Override
                public void onSuccess(List<StorageDomain> storageDomains) {
                    // filter storage domains
                    List<StorageDomain> filteredStorageDomains = new ArrayList<>();
                    for (StorageDomain domain : storageDomains) {
                        if (Linq.isDataActiveStorageDomain(domain)) {
                            filteredStorageDomains.add(domain);
                        }
                    }
                    getStorage().setItems(filteredStorageDomains);
                    if (getClusterQuota().getIsAvailable()) {
                        initQuotaForStorageDomains();
                    } else {
                        initDisksStorageDomainsList();
                    }
                }
            }), getStoragePool().getId());
        }
    }), dataCenter.getId(), true, false);
}
#end_block

#method_before
private void initIsoImages() {
    AsyncDataProvider.getInstance().getIrsImageList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<String> images = (List<String>) returnValue;
            getIso().setItems(images);
            getIso().setSelectedItem(tryToFindVirtioTools(images));
        }
    }), getStoragePool().getId(), false);
}
#method_after
private void initIsoImages() {
    AsyncDataProvider.getInstance().getIrsImageList(new AsyncQuery<>(new AsyncCallback<List<String>>() {

        @Override
        public void onSuccess(List<String> images) {
            getIso().setItems(images);
            getIso().setSelectedItem(tryToFindVirtioTools(images));
        }
    }), getStoragePool().getId(), false);
}
#end_block

#method_before
@Override
public String getUrl() {
    return this.url;
}
#method_after
public String getUrl() {
    return url;
}
#end_block

#method_before
@Override
public String getUsername() {
    return this.username;
}
#method_after
public String getUsername() {
    return username;
}
#end_block

#method_before
@Override
public String getPassword() {
    return this.password;
}
#method_after
public String getPassword() {
    return password;
}
#end_block

#method_before
@Override
public Guid getProxyHostId() {
    return this.proxyHostId;
}
#method_after
public Guid getProxyHostId() {
    return proxyHostId;
}
#end_block

#method_before
protected void logFailureToGetVms() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("URL", getParameters().getUrl());
    auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_GET_EXTERNAL_VMS_INFO_FAILED);
}
#method_after
private void logFailureToGetVms() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("URL", getParameters().getUrl());
    auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_GET_EXTERNAL_VMS_INFO_FAILED);
}
#end_block

#method_before
protected GetVmsFromExternalProviderParameters buildGetRemoteVmsInfoParameters() {
    return new GetVmsFromExternalProviderParameters(getProxyHostId(), getParameters().getUrl(), getParameters().getUsername(), getParameters().getPassword(), getParameters().getOriginType(), getParameters().getVmsNames());
}
#method_after
private GetVmsFromExternalProviderParameters buildGetRemoteVmsInfoParameters() {
    return new GetVmsFromExternalProviderParameters(getProxyHostId(), getParameters().getUrl(), getParameters().getUsername(), getParameters().getPassword(), getParameters().getOriginType(), getParameters().getNamesOfVms());
}
#end_block

#method_before
private Guid pickProxyHostFromDataCenter() {
    Guid dataCenterId = (getParameters().getDataCenterId() == null) ? getRandomDataCenter() : getParameters().getDataCenterId();
    List<VDS> vdss = getVdsDao().getAllForStoragePoolAndStatus(dataCenterId, VDSStatus.Up);
    if (vdss.isEmpty()) {
        logNoProxyAvailable(getParameters().getDataCenterId());
        throw new IllegalArgumentException();
    }
    return vdss.get(0).getId();
}
#method_after
private Guid pickProxyHostFromDataCenter() {
    Guid dataCenterId = getParameters().getDataCenterId();
    List<VDS> vdss = getVdsDao().getAllForStoragePoolAndStatus(dataCenterId, VDSStatus.Up);
    if (vdss.isEmpty()) {
        logNoProxyAvailable(dataCenterId);
        throw new IllegalArgumentException();
    }
    return vdss.get(0).getId();
}
#end_block

#method_before
private void logNoProxyAvailable(Guid dataCenterId) {
    AuditLogableBase logable = new AuditLogableBase();
    String dcName = (dataCenterId == null) ? "None" : getDbFacade().getStoragePoolDao().get(dataCenterId).getName();
    logable.addCustomValue("StoragePoolName", dcName);
    auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_NO_PROXY_HOST_AVAILABLE_IN_DC);
}
#method_after
private void logNoProxyAvailable(Guid dataCenterId) {
    AuditLogableBase logable = new AuditLogableBase();
    String dcName = getDbFacade().getStoragePoolDao().get(dataCenterId).getName();
    logable.addCustomValue("StoragePoolName", dcName);
    auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_NO_PROXY_HOST_AVAILABLE_IN_DC);
}
#end_block

#method_before
public ImportVmModel getSpecificImportModel() {
    selectedImportVmModel = null;
    boolean dcSupportsApiForLoadingExternalVmsNamesOnly = getDataCenters().getSelectedItem().getCompatibilityVersion().greaterOrEquals(Version.v4_1);
    switch(importSources.getSelectedItem()) {
        case EXPORT_DOMAIN:
            importFromExportDomainModel.setEntity(null);
            importFromExportDomainModel.init(getVmsToImport(), exportDomain.getEntity().getId());
            importFromExportDomainModel.setEntity(exportDomain.getEntity().getId());
            selectedImportVmModel = importFromExportDomainModel;
            break;
        case VMWARE:
            if (!dcSupportsApiForLoadingExternalVmsNamesOnly) {
                importFromExternalSourceModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            }
            importFromExternalSourceModel.setUrl(getUrl());
            importFromExternalSourceModel.setUsername(getUsername().getEntity());
            importFromExternalSourceModel.setPassword(getPassword().getEntity());
            importFromExternalSourceModel.setProxyHostId(getProxyHosts().getSelectedItem() != null ? getProxyHosts().getSelectedItem().getId() : null);
            selectedImportVmModel = importFromExternalSourceModel;
            break;
        case OVA:
            importFromOvaModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            importFromOvaModel.setIsoName(getOvaPath().getEntity());
            importFromOvaModel.setHostId(getHosts().getSelectedItem().getId());
            selectedImportVmModel = importFromOvaModel;
            break;
        case XEN:
            if (!dcSupportsApiForLoadingExternalVmsNamesOnly) {
                importFromExternalSourceModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            }
            importFromExternalSourceModel.setUrl(getXenUri().getEntity());
            // $NON-NLS-1$
            importFromExternalSourceModel.setUsername("");
            // $NON-NLS-1$
            importFromExternalSourceModel.setPassword("");
            importFromExternalSourceModel.setProxyHostId(getXenProxyHosts().getSelectedItem() != null ? getXenProxyHosts().getSelectedItem().getId() : null);
            selectedImportVmModel = importFromExternalSourceModel;
            break;
        case KVM:
            if (!dcSupportsApiForLoadingExternalVmsNamesOnly) {
                importFromExternalSourceModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            }
            importFromExternalSourceModel.setUrl(getKvmUri().getEntity());
            importFromExternalSourceModel.setUsername(getKvmUsername().getEntity());
            importFromExternalSourceModel.setPassword(getKvmPassword().getEntity());
            importFromExternalSourceModel.setProxyHostId(getKvmProxyHosts().getSelectedItem() != null ? getKvmProxyHosts().getSelectedItem().getId() : null);
            selectedImportVmModel = importFromExternalSourceModel;
            break;
        default:
    }
    return selectedImportVmModel;
}
#method_after
public ImportVmModel getSpecificImportModel(boolean vmsToImportHaveFullInfo) {
    selectedImportVmModel = null;
    switch(importSources.getSelectedItem()) {
        case EXPORT_DOMAIN:
            importFromExportDomainModel.setEntity(null);
            importFromExportDomainModel.init(getVmsToImport(), exportDomain.getEntity().getId());
            importFromExportDomainModel.setEntity(exportDomain.getEntity().getId());
            selectedImportVmModel = importFromExportDomainModel;
            break;
        case VMWARE:
            if (vmsToImportHaveFullInfo) {
                importFromExternalSourceModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            }
            importFromExternalSourceModel.setUrl(getUrl());
            importFromExternalSourceModel.setUsername(getUsername().getEntity());
            importFromExternalSourceModel.setPassword(getPassword().getEntity());
            importFromExternalSourceModel.setProxyHostId(getProxyHosts().getSelectedItem() != null ? getProxyHosts().getSelectedItem().getId() : null);
            selectedImportVmModel = importFromExternalSourceModel;
            break;
        case OVA:
            importFromOvaModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            importFromOvaModel.setIsoName(getOvaPath().getEntity());
            importFromOvaModel.setHostId(getHosts().getSelectedItem().getId());
            selectedImportVmModel = importFromOvaModel;
            break;
        case XEN:
            if (vmsToImportHaveFullInfo) {
                importFromExternalSourceModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            }
            importFromExternalSourceModel.setUrl(getXenUri().getEntity());
            // $NON-NLS-1$
            importFromExternalSourceModel.setUsername("");
            // $NON-NLS-1$
            importFromExternalSourceModel.setPassword("");
            importFromExternalSourceModel.setProxyHostId(getXenProxyHosts().getSelectedItem() != null ? getXenProxyHosts().getSelectedItem().getId() : null);
            selectedImportVmModel = importFromExternalSourceModel;
            break;
        case KVM:
            if (vmsToImportHaveFullInfo) {
                importFromExternalSourceModel.init(getVmsToImport(), getDataCenters().getSelectedItem().getId());
            }
            importFromExternalSourceModel.setUrl(getKvmUri().getEntity());
            importFromExternalSourceModel.setUsername(getKvmUsername().getEntity());
            importFromExternalSourceModel.setPassword(getKvmPassword().getEntity());
            importFromExternalSourceModel.setProxyHostId(getKvmProxyHosts().getSelectedItem() != null ? getKvmProxyHosts().getSelectedItem().getId() : null);
            selectedImportVmModel = importFromExternalSourceModel;
            break;
        default:
    }
    return selectedImportVmModel;
}
#end_block

#method_before
private void initDataCenterCpuArchitectureMap() {
    final AsyncQuery callback = new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object nothing, Object returnValue) {
            List<Cluster> allClusters = ((VdcQueryReturnValue) returnValue).getReturnValue();
            clusterArchitecturesInDataCenters = new HashMap<>();
            for (Cluster cluster : allClusters) {
                if (cluster.supportsVirtService() && cluster.getArchitecture() != null) {
                    addArchitecture(cluster.getStoragePoolId(), cluster.getArchitecture());
                }
            }
        }

        private void addArchitecture(Guid dataCenterId, ArchitectureType architecture) {
            Set<ArchitectureType> architectures = clusterArchitecturesInDataCenters.get(dataCenterId);
            if (architectures == null) {
                architectures = new HashSet<>();
                clusterArchitecturesInDataCenters.put(dataCenterId, architectures);
            }
            architectures.add(architecture);
        }
    });
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClusters, new VdcQueryParametersBase(), callback);
}
#method_after
private void initDataCenterCpuArchitectureMap() {
    final AsyncQuery<VdcQueryReturnValue> callback = new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            List<Cluster> allClusters = returnValue.getReturnValue();
            clusterArchitecturesInDataCenters = new HashMap<>();
            for (Cluster cluster : allClusters) {
                if (cluster.supportsVirtService() && cluster.getArchitecture() != null) {
                    addArchitecture(cluster.getStoragePoolId(), cluster.getArchitecture());
                }
            }
        }

        private void addArchitecture(Guid dataCenterId, ArchitectureType architecture) {
            Set<ArchitectureType> architectures = clusterArchitecturesInDataCenters.get(dataCenterId);
            if (architectures == null) {
                architectures = new HashSet<>();
                clusterArchitecturesInDataCenters.put(dataCenterId, architectures);
            }
            architectures.add(architecture);
        }
    });
    Frontend.getInstance().runQuery(VdcQueryType.GetAllClusters, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
private INewAsyncCallback createGetStorageDomainsByStoragePoolIdCallback(final StoragePool dataCenter) {
    return new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            List<StorageDomain> storageDomains = ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            exportDomain.setEntity(getExportDomain(storageDomains));
            if (exportDomain.getEntity() == null) {
                stopProgress();
            } else {
                setExportName(exportDomain.getEntity().getName());
                setExportDescription(exportDomain.getEntity().getDescription());
                // get export-path
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object ReturnValue) {
                        StorageServerConnections connection = (StorageServerConnections) ReturnValue;
                        setExportPath(connection == null ? null : connection.getConnection());
                        stopProgress();
                    }
                };
                AsyncDataProvider.getInstance().getStorageConnectionById(_asyncQuery, exportDomain.getEntity().getStorage(), true);
            }
            validateSource();
        }
    };
}
#method_after
private AsyncCallback<VdcQueryReturnValue> createGetStorageDomainsByStoragePoolIdCallback() {
    return new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            List<StorageDomain> storageDomains = returnValue.getReturnValue();
            exportDomain.setEntity(getExportDomain(storageDomains));
            if (exportDomain.getEntity() == null) {
                stopProgress();
            } else {
                setExportName(exportDomain.getEntity().getName());
                setExportDescription(exportDomain.getEntity().getDescription());
                // get export-path
                AsyncDataProvider.getInstance().getStorageConnectionById(new AsyncQuery<>(new AsyncCallback<StorageServerConnections>() {

                    @Override
                    public void onSuccess(StorageServerConnections connection) {
                        setExportPath(connection == null ? null : connection.getConnection());
                        stopProgress();
                    }
                }), exportDomain.getEntity().getStorage(), true);
            }
            validateSource();
        }
    };
}
#end_block

#method_before
private void initDataCenters() {
    getDataCenters().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            clearVms();
            exportDomain.setEntity(null);
            StoragePool dataCenter = dataCenters.getSelectedItem();
            Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, new IdQueryParameters(dataCenter.getId()), new AsyncQuery(this, createGetStorageDomainsByStoragePoolIdCallback(dataCenter)));
        }
    });
    dataCenters.getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            AsyncQuery hostsQuery = new AsyncQuery();
            hostsQuery.setModel(ImportVmsModel.this);
            hostsQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    List<VDS> hosts = (List<VDS>) returnValue;
                    List<VDS> upHosts = filterUpHosts(hosts);
                    proxyHosts.setItems(addAnyHostInCluster(upHosts));
                    xenProxyHosts.setItems(addAnyHostInCluster(upHosts));
                    kvmProxyHosts.setItems(addAnyHostInCluster(upHosts));
                    ImportVmsModel.this.hosts.setItems(upHosts);
                    stopProgress();
                }
            };
            AsyncDataProvider.getInstance().getHostListByDataCenter(hostsQuery, dataCenters.getSelectedItem().getId());
        }

        private List<VDS> filterUpHosts(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>();
            for (VDS host : hosts) {
                if (host.getStatus() == VDSStatus.Up) {
                    result.add(host);
                }
            }
            return result;
        }

        private List<VDS> addAnyHostInCluster(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>(hosts);
            // Any host in the cluster
            result.add(0, null);
            return result;
        }
    });
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final List<StoragePool> dataCenters = new ArrayList<>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (dataCenters.isEmpty()) {
                getDataCenters().setIsChangeable(false);
                getImportSources().setIsChangeable(false);
                setError(constants.notAvailableWithNoUpDC());
                stopProgress();
                return;
            }
            Collections.sort(dataCenters, new NameableComparator());
            ImportVmsModel.this.dataCenters.setItems(dataCenters);
        }
    }));
}
#method_after
private void initDataCenters() {
    getDataCenters().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            clearVms();
            exportDomain.setEntity(null);
            loadProviders();
            StoragePool dataCenter = dataCenters.getSelectedItem();
            Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, new IdQueryParameters(dataCenter.getId()), new AsyncQuery<>(createGetStorageDomainsByStoragePoolIdCallback()));
        }
    });
    dataCenters.getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            AsyncDataProvider.getInstance().getHostListByDataCenter(new AsyncQuery<>(new AsyncCallback<List<VDS>>() {

                @Override
                public void onSuccess(List<VDS> hosts) {
                    List<VDS> upHosts = filterUpHosts(hosts);
                    proxyHosts.setItems(addAnyHostInCluster(upHosts));
                    xenProxyHosts.setItems(addAnyHostInCluster(upHosts));
                    kvmProxyHosts.setItems(addAnyHostInCluster(upHosts));
                    ImportVmsModel.this.hosts.setItems(upHosts);
                    stopProgress();
                }
            }), dataCenters.getSelectedItem().getId());
        }

        private List<VDS> filterUpHosts(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>();
            for (VDS host : hosts) {
                if (host.getStatus() == VDSStatus.Up) {
                    result.add(host);
                }
            }
            return result;
        }

        private List<VDS> addAnyHostInCluster(List<VDS> hosts) {
            List<VDS> result = new ArrayList<>(hosts);
            // Any host in the cluster
            result.add(0, null);
            return result;
        }
    });
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(new AsyncCallback<List<StoragePool>>() {

        @Override
        public void onSuccess(List<StoragePool> returnValue) {
            List<StoragePool> dataCenters = new ArrayList<>();
            for (StoragePool a : returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (dataCenters.isEmpty()) {
                getDataCenters().setIsChangeable(false);
                getImportSources().setIsChangeable(false);
                setError(constants.notAvailableWithNoUpDC());
                stopProgress();
                return;
            }
            Collections.sort(dataCenters, new NameableComparator());
            ImportVmsModel.this.dataCenters.setItems(dataCenters);
        }
    }));
}
#end_block

#method_before
private void loadVmwareProviders() {
    AsyncDataProvider.getInstance().getAllProvidersByType(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<Provider<VmwareVmProviderProperties>> providers = new ArrayList<>();
            for (Provider<VmwareVmProviderProperties> provider : (List<Provider<VmwareVmProviderProperties>>) returnValue) {
                if (getDataCenters().getSelectedItem().getId().equals(provider.getAdditionalProperties().getStoragePoolId()) || provider.getAdditionalProperties().getStoragePoolId() == null) {
                    providers.add(provider);
                }
            }
            providers.add(0, null);
            getVmwareProviders().setItems(providers);
        }
    }), ProviderType.VMWARE);
}
#method_after
private void loadVmwareProviders() {
    AsyncDataProvider.getInstance().getAllProvidersByType(new AsyncQuery<>(new AsyncCallback<List<Provider<?>>>() {

        @Override
        public void onSuccess(List<Provider<?>> returnValue) {
            List<Provider<VmwareVmProviderProperties>> providers = new ArrayList<>();
            for (Provider<VmwareVmProviderProperties> provider : (List<Provider<VmwareVmProviderProperties>>) (List) returnValue) {
                if (getDataCenters().getSelectedItem().getId().equals(provider.getAdditionalProperties().getStoragePoolId()) || provider.getAdditionalProperties().getStoragePoolId() == null) {
                    providers.add(provider);
                }
            }
            providers.add(0, null);
            getVmwareProviders().setItems(providers);
        }
    }), ProviderType.VMWARE);
}
#end_block

#method_before
private void loadKvmProviders() {
    AsyncDataProvider.getInstance().getAllProvidersByType(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<Provider<KVMVmProviderProperties>> providers = new ArrayList<>();
            for (Provider<KVMVmProviderProperties> provider : (List<Provider<KVMVmProviderProperties>>) returnValue) {
                if (getDataCenters().getSelectedItem().getId().equals(provider.getAdditionalProperties().getStoragePoolId()) || provider.getAdditionalProperties().getStoragePoolId() == null) {
                    providers.add(provider);
                }
            }
            providers.add(0, null);
            getKvmProviders().setItems(providers);
        }
    }), ProviderType.KVM);
}
#method_after
private void loadKvmProviders() {
    AsyncDataProvider.getInstance().getAllProvidersByType(new AsyncQuery<>(new AsyncCallback<List<Provider<?>>>() {

        @Override
        public void onSuccess(List<Provider<?>> returnValue) {
            List<Provider<KVMVmProviderProperties>> providers = new ArrayList<>();
            for (Provider<KVMVmProviderProperties> provider : (List<Provider<KVMVmProviderProperties>>) (List) returnValue) {
                if (getDataCenters().getSelectedItem().getId().equals(provider.getAdditionalProperties().getStoragePoolId()) || provider.getAdditionalProperties().getStoragePoolId() == null) {
                    providers.add(provider);
                }
            }
            providers.add(0, null);
            getKvmProviders().setItems(providers);
        }
    }), ProviderType.KVM);
}
#end_block

#method_before
private void loadXenProviders() {
    AsyncDataProvider.getInstance().getAllProvidersByType(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<Provider<XENVmProviderProperties>> providers = new ArrayList<>();
            for (Provider<XENVmProviderProperties> provider : (List<Provider<XENVmProviderProperties>>) returnValue) {
                if (getDataCenters().getSelectedItem().getId().equals(provider.getAdditionalProperties().getStoragePoolId()) || provider.getAdditionalProperties().getStoragePoolId() == null) {
                    providers.add(provider);
                }
            }
            providers.add(0, null);
            getXenProviders().setItems(providers);
        }
    }), ProviderType.XEN);
}
#method_after
private void loadXenProviders() {
    AsyncDataProvider.getInstance().getAllProvidersByType(new AsyncQuery<>(new AsyncCallback<List<Provider<?>>>() {

        @Override
        public void onSuccess(List<Provider<?>> returnValue) {
            List<Provider<XENVmProviderProperties>> providers = new ArrayList<>();
            for (Provider<XENVmProviderProperties> provider : (List<Provider<XENVmProviderProperties>>) (List) returnValue) {
                if (getDataCenters().getSelectedItem().getId().equals(provider.getAdditionalProperties().getStoragePoolId()) || provider.getAdditionalProperties().getStoragePoolId() == null) {
                    providers.add(provider);
                }
            }
            providers.add(0, null);
            getXenProviders().setItems(providers);
        }
    }), ProviderType.XEN);
}
#end_block

#method_before
public void loadVmsFromExportDomain() {
    clearProblem();
    startProgress();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmsFromExportDomain, new GetAllFromExportDomainQueryParameters(getDataCenters().getSelectedItem().getId(), exportDomain.getEntity().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            updateVms(((VdcQueryReturnValue) returnValue).<List<VM>>getReturnValue());
        }
    }));
}
#method_after
public void loadVmsFromExportDomain() {
    clearProblem();
    startProgress();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmsFromExportDomain, new GetAllFromExportDomainQueryParameters(getDataCenters().getSelectedItem().getId(), exportDomain.getEntity().getId()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            updateVms(returnValue.<List<VM>>getReturnValue());
        }
    }));
}
#end_block

#method_before
public void loadVmFromOva() {
    clearForLoad();
    if (!validateOvaConfiguration()) {
        return;
    }
    startProgress();
    AsyncDataProvider.getInstance().getVmFromOva(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) returnValue;
            if (queryReturnValue.getSucceeded()) {
                VM vm = queryReturnValue.getReturnValue();
                updateVms(Collections.singletonList(vm));
            } else {
                setError(messages.failedToLoadOva(getOvaPath().getEntity()));
            }
            stopProgress();
        }
    }), getHosts().getSelectedItem().getId(), getOvaPath().getEntity());
}
#method_after
public void loadVmFromOva() {
    clearForLoad();
    if (!validateOvaConfiguration()) {
        return;
    }
    startProgress();
    AsyncDataProvider.getInstance().getVmFromOva(new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            if (returnValue.getSucceeded()) {
                VM vm = returnValue.getReturnValue();
                updateVms(Collections.singletonList(vm));
            } else {
                setError(messages.failedToLoadOva(getOvaPath().getEntity()));
            }
            stopProgress();
        }
    }), getHosts().getSelectedItem().getId(), getOvaPath().getEntity());
}
#end_block

#method_before
private void loadVMsFromExternalProvider(final OriginType type, String uri, String username, String password, Guid proxyId) {
    startProgress();
    AsyncQuery query = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            if (returnValue instanceof VdcQueryReturnValue) {
                setError(messages.providerFailure());
                stopProgress();
            } else {
                List<VM> remoteVms = (List<VM>) returnValue;
                List<VM> remoteDownVms = new ArrayList<>();
                for (VM vm : remoteVms) {
                    if (vm.isDown()) {
                        remoteDownVms.add(vm);
                    }
                }
                if (remoteVms.size() != remoteDownVms.size()) {
                    setWarning(constants.runningVmsWereFilteredOnImportVm());
                }
                updateVms(remoteDownVms);
            }
        }
    });
    boolean dcSupportsApiForLoadingExternalVmsNamesOnly = getDataCenters().getSelectedItem().getCompatibilityVersion().greaterOrEquals(Version.v4_1);
    query.setHandleFailure(true);
    AsyncDataProvider.getInstance().getVmsForDisplayingFromExternalServer(query, getDataCenters().getSelectedItem().getId(), proxyId, uri, username, password, type, dcSupportsApiForLoadingExternalVmsNamesOnly);
}
#method_after
private void loadVMsFromExternalProvider(final OriginType type, String uri, String username, String password, Guid proxyId) {
    startProgress();
    AsyncQuery query = new AsyncQuery(new AsyncCallback() {

        @Override
        public void onSuccess(Object returnValue) {
            if (returnValue instanceof VdcQueryReturnValue) {
                setError(messages.providerFailure());
                stopProgress();
            } else {
                List<VM> remoteVms = (List<VM>) returnValue;
                List<VM> remoteDownVms = new ArrayList<>();
                for (VM vm : remoteVms) {
                    if (vm.isDown()) {
                        remoteDownVms.add(vm);
                    }
                }
                if (remoteVms.size() != remoteDownVms.size()) {
                    setWarning(constants.runningVmsWereFilteredOnImportVm());
                }
                updateVms(remoteDownVms);
            }
        }
    });
    query.setHandleFailure(true);
    AsyncDataProvider.getInstance().getVmsFromExternalServer(query, getDataCenters().getSelectedItem().getId(), proxyId, uri, username, password, type, null);
}
#end_block

#method_before
public boolean vmsToImportHaveFullInfo() {
    switch(importSources.getSelectedItem()) {
        case VMWARE:
        case KVM:
        case XEN:
            if (getDataCenters().getSelectedItem().getCompatibilityVersion().greaterOrEquals(Version.v4_1)) {
                return false;
            }
            break;
        default:
    }
    return true;
}
#method_after
public boolean vmsToImportHaveFullInfo() {
    switch(importSources.getSelectedItem()) {
        case VMWARE:
        case KVM:
        case XEN:
            if (AsyncDataProvider.getInstance().isGetNamesOfVmsFromExternalProviderSupported(getDataCenters().getSelectedItem().getCompatibilityVersion())) {
                return false;
            }
            break;
        default:
    }
    return true;
}
#end_block

#method_before
@Override
protected void init(T parameters) {
    super.init(parameters);
    // Otherwise, we'll fail on validate.
    if (getRepresentativeImage().isPresent()) {
        DiskImage representativeImage = getRepresentativeImage().get();
        setImage(representativeImage);
        getParameters().setStorageDomainId(representativeImage.getStorageIds().get(0));
        getParameters().setDiskAlias(representativeImage.getDiskAlias());
        getParameters().setUseCinderCommandCallback(!ImagesHandler.filterDisksBasedOnCinder(getImages()).isEmpty());
        if (Guid.isNullOrEmpty(getParameters().getContainerId())) {
            List<VM> listVms = getVmDao().getVmsListForDisk(representativeImage.getId(), false);
            if (!listVms.isEmpty()) {
                VM vm = listVms.get(0);
                setVm(vm);
                getParameters().setContainerId(vm.getId());
            }
        }
    }
    setVmId(getParameters().getContainerId());
    setStorageDomainId(getParameters().getStorageDomainId());
    // thus initTaskHandlers() can't yet tell if this is a live or cold merge.
    if (isLiveMerge()) {
        clearTaskHandlers();
    }
}
#method_after
@Override
protected void init(T parameters) {
    super.init(parameters);
    // Otherwise, we'll fail on validate.
    if (getRepresentativeImage().isPresent()) {
        DiskImage representativeImage = getRepresentativeImage().get();
        setImage(representativeImage);
        getParameters().setStorageDomainId(representativeImage.getStorageIds().get(0));
        getParameters().setDiskAlias(representativeImage.getDiskAlias());
        getParameters().setUseCinderCommandCallback(!ImagesHandler.filterDisksBasedOnCinder(getImages()).isEmpty());
        if (Guid.isNullOrEmpty(getParameters().getContainerId())) {
            List<VM> listVms = getVmDao().getVmsListForDisk(representativeImage.getId(), false);
            if (!listVms.isEmpty()) {
                VM vm = listVms.get(0);
                setVm(vm);
                getParameters().setContainerId(vm.getId());
            }
        }
    }
    setVmId(getParameters().getContainerId());
    setStorageDomainId(getParameters().getStorageDomainId());
}
#end_block

#method_before
@Override
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    List<SPMAsyncTaskHandler> taskHandlers = new ArrayList<>();
    // merge (and we can't yet run isLiveMerge()), so we just use an explicit flag.
    if (!getParameters().isImageIdsSorted()) {
        // Retrieve and sort the entire chain of images
        List<DiskImage> images = getAllImagesForDisk();
        ImagesHandler.sortImageList(images);
        // Get a sorted list of the selected images
        List<DiskImage> sortedImages = images.stream().filter(image -> getImages().contains(image)).filter(image -> image.getDiskStorageType() == DiskStorageType.IMAGE).collect(Collectors.toList());
        getParameters().setImageIds(new ArrayList<>(ImagesHandler.getDiskImageIds(sortedImages)));
        getParameters().setImageIdsSorted(true);
    }
    for (Guid imageId : getParameters().getImageIds()) {
        taskHandlers.add(new RemoveDiskSnapshotTaskHandler(this, imageId, getImageGroupId(), getVmId()));
    }
    return !taskHandlers.isEmpty() ? taskHandlers : null;
}
#method_after
@Override
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    List<SPMAsyncTaskHandler> taskHandlers = new ArrayList<>();
    // merge (and we can't yet run isLiveMerge()), so we just use an explicit flag.
    if (!getParameters().isImageIdsSorted()) {
        // Retrieve and sort the entire chain of images
        List<DiskImage> images = getAllImagesForDisk();
        ImagesHandler.sortImageList(images);
        // Get a sorted list of the selected images
        List<DiskImage> sortedImages = images.stream().filter(image -> image.getDiskStorageType() == DiskStorageType.IMAGE).filter(image -> getImages().contains(image)).collect(Collectors.toList());
        getParameters().setImageIds(new ArrayList<>(ImagesHandler.getDiskImageIds(sortedImages)));
        getParameters().setImageIdsSorted(true);
    }
    if (!isLiveMerge()) {
        for (Guid imageId : getParameters().getImageIds()) {
            taskHandlers.add(new RemoveDiskSnapshotTaskHandler(this, imageId, getImageGroupId(), getVmId()));
        }
    }
    return !taskHandlers.isEmpty() ? taskHandlers : null;
}
#end_block

